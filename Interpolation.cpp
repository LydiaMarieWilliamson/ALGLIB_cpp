// ALGLIB++
// Based on ALGLIB: Copyright (c) Sergey Bochkanov (ALGLIB project).
// Revisions Copyright (c) Lydia Marie Williamson, Mark Hopkins Consulting
// Source License:
//	This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation (www.fsf.org);
//	either version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
//	without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//	See the GNU General Public License for more details.
//
//	A copy of the GNU General Public License is available at http://www.fsf.org/licensing/licenses
#define InAlgLib
#include "Interpolation.h"

// === RATINT Package ===
// Depends on: (AlgLibInternal) TSORT
namespace alglib_impl {
// Rational interpolation using barycentric formula
//
// F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))
//
// Inputs:
//     B   -   barycentric interpolant built with one of model building
//             subroutines.
//     T   -   interpolation point
//
// Result:
//     barycentric interpolant F(t)
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
// API: double barycentriccalc(const barycentricinterpolant &b, const double t, const xparams _xparams = xdefault);
double barycentriccalc(barycentricinterpolant *b, double t, ae_state *_state) {
   double s1;
   double s2;
   double s;
   double v;
   ae_int_t i;
   double result;
   ae_assert(!ae_isinf(t, _state), "BarycentricCalc: infinite T!", _state);
// special case: NaN
   if (ae_isnan(t, _state)) {
      result = _state->v_nan;
      return result;
   }
// special case: N=1
   if (b->n == 1) {
      result = b->sy * b->y.xR[0];
      return result;
   }
// Here we assume that task is normalized, i.e.:
// 1. abs(Y[i]) <= 1
// 2. abs(W[i]) <= 1
// 3. X[] is ordered
   s = ae_fabs(t - b->x.xR[0], _state);
   for (i = 0; i < b->n; i++) {
      v = b->x.xR[i];
      if (v == t) {
         result = b->sy * b->y.xR[i];
         return result;
      }
      v = ae_fabs(t - v, _state);
      if (v < s) {
         s = v;
      }
   }
   s1 = 0.0;
   s2 = 0.0;
   for (i = 0; i < b->n; i++) {
      v = s / (t - b->x.xR[i]);
      v *= b->w.xR[i];
      s1 += v * b->y.xR[i];
      s2 += v;
   }
   result = b->sy * s1 / s2;
   return result;
}

// Differentiation of barycentric interpolant: first derivative.
//
// Algorithm used in this subroutine is very robust and should not fail until
// provided with values too close to MaxRealNumber  (usually  MaxRealNumber/N
// or greater will overflow).
//
// Inputs:
//     B   -   barycentric interpolant built with one of model building
//             subroutines.
//     T   -   interpolation point
//
// Outputs:
//     F   -   barycentric interpolant at T
//     DF  -   first derivative
//
// NOTE
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
// API: void barycentricdiff1(const barycentricinterpolant &b, const double t, double &f, double &df, const xparams _xparams = xdefault);
void barycentricdiff1(barycentricinterpolant *b, double t, double *f, double *df, ae_state *_state) {
   double v;
   double vv;
   ae_int_t i;
   ae_int_t k;
   double n0;
   double n1;
   double d0;
   double d1;
   double s0;
   double s1;
   double xk;
   double xi;
   double xmin;
   double xmax;
   double xscale1;
   double xoffs1;
   double xscale2;
   double xoffs2;
   double xprev;
   *f = 0;
   *df = 0;
   ae_assert(!ae_isinf(t, _state), "BarycentricDiff1: infinite T!", _state);
// special case: NaN
   if (ae_isnan(t, _state)) {
      *f = _state->v_nan;
      *df = _state->v_nan;
      return;
   }
// special case: N=1
   if (b->n == 1) {
      *f = b->sy * b->y.xR[0];
      *df = 0.0;
      return;
   }
   if (b->sy == 0.0) {
      *f = 0.0;
      *df = 0.0;
      return;
   }
   ae_assert(b->sy > 0.0, "BarycentricDiff1: internal error", _state);
// We assume than N>1 and B.SY>0. Find:
// 1. pivot point (X[i] closest to T)
// 2. width of interval containing X[i]
   v = ae_fabs(b->x.xR[0] - t, _state);
   k = 0;
   xmin = b->x.xR[0];
   xmax = b->x.xR[0];
   for (i = 1; i < b->n; i++) {
      vv = b->x.xR[i];
      if (ae_fabs(vv - t, _state) < v) {
         v = ae_fabs(vv - t, _state);
         k = i;
      }
      xmin = minreal(xmin, vv, _state);
      xmax = maxreal(xmax, vv, _state);
   }
// pivot point found, calculate dNumerator and dDenominator
   xscale1 = 1 / (xmax - xmin);
   xoffs1 = -xmin / (xmax - xmin) + 1;
   xscale2 = 2.0;
   xoffs2 = -3.0;
   t = t * xscale1 + xoffs1;
   t = t * xscale2 + xoffs2;
   xk = b->x.xR[k];
   xk = xk * xscale1 + xoffs1;
   xk = xk * xscale2 + xoffs2;
   v = t - xk;
   n0 = 0.0;
   n1 = 0.0;
   d0 = 0.0;
   d1 = 0.0;
   xprev = -2.0;
   for (i = 0; i < b->n; i++) {
      xi = b->x.xR[i];
      xi = xi * xscale1 + xoffs1;
      xi = xi * xscale2 + xoffs2;
      ae_assert(xi > xprev, "BarycentricDiff1: points are too close!", _state);
      xprev = xi;
      if (i != k) {
         vv = sqr(t - xi, _state);
         s0 = (t - xk) / (t - xi);
         s1 = (xk - xi) / vv;
      } else {
         s0 = 1.0;
         s1 = 0.0;
      }
      vv = b->w.xR[i] * b->y.xR[i];
      n0 += s0 * vv;
      n1 += s1 * vv;
      vv = b->w.xR[i];
      d0 += s0 * vv;
      d1 += s1 * vv;
   }
   *f = b->sy * n0 / d0;
   *df = (n1 * d0 - n0 * d1) / sqr(d0, _state);
   if (*df != 0.0) {
      *df = sign(*df, _state) * ae_exp(ae_log(ae_fabs(*df, _state), _state) + ae_log(b->sy, _state) + ae_log(xscale1, _state) + ae_log(xscale2, _state), _state);
   }
}

// Differentiation of barycentric interpolant: first/second derivatives.
//
// Inputs:
//     B   -   barycentric interpolant built with one of model building
//             subroutines.
//     T   -   interpolation point
//
// Outputs:
//     F   -   barycentric interpolant at T
//     DF  -   first derivative
//     D2F -   second derivative
//
// NOTE: this algorithm may fail due to overflow/underflor if  used  on  data
// whose values are close to MaxRealNumber or MinRealNumber.  Use more robust
// BarycentricDiff1() subroutine in such cases.
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
// API: void barycentricdiff2(const barycentricinterpolant &b, const double t, double &f, double &df, double &d2f, const xparams _xparams = xdefault);
void barycentricdiff2(barycentricinterpolant *b, double t, double *f, double *df, double *d2f, ae_state *_state) {
   double v;
   double vv;
   ae_int_t i;
   ae_int_t k;
   double n0;
   double n1;
   double n2;
   double d0;
   double d1;
   double d2;
   double s0;
   double s1;
   double s2;
   double xk;
   double xi;
   *f = 0;
   *df = 0;
   *d2f = 0;
   ae_assert(!ae_isinf(t, _state), "BarycentricDiff1: infinite T!", _state);
// special case: NaN
   if (ae_isnan(t, _state)) {
      *f = _state->v_nan;
      *df = _state->v_nan;
      *d2f = _state->v_nan;
      return;
   }
// special case: N=1
   if (b->n == 1) {
      *f = b->sy * b->y.xR[0];
      *df = 0.0;
      *d2f = 0.0;
      return;
   }
   if (b->sy == 0.0) {
      *f = 0.0;
      *df = 0.0;
      *d2f = 0.0;
      return;
   }
// We assume than N>1 and B.SY>0. Find:
// 1. pivot point (X[i] closest to T)
// 2. width of interval containing X[i]
   ae_assert(b->sy > 0.0, "BarycentricDiff: internal error", _state);
   *f = 0.0;
   *df = 0.0;
   *d2f = 0.0;
   v = ae_fabs(b->x.xR[0] - t, _state);
   k = 0;
   for (i = 1; i < b->n; i++) {
      vv = b->x.xR[i];
      if (ae_fabs(vv - t, _state) < v) {
         v = ae_fabs(vv - t, _state);
         k = i;
      }
   }
// pivot point found, calculate dNumerator and dDenominator
   xk = b->x.xR[k];
   v = t - xk;
   n0 = 0.0;
   n1 = 0.0;
   n2 = 0.0;
   d0 = 0.0;
   d1 = 0.0;
   d2 = 0.0;
   for (i = 0; i < b->n; i++) {
      if (i != k) {
         xi = b->x.xR[i];
         vv = sqr(t - xi, _state);
         s0 = (t - xk) / (t - xi);
         s1 = (xk - xi) / vv;
         s2 = -2 * (xk - xi) / (vv * (t - xi));
      } else {
         s0 = 1.0;
         s1 = 0.0;
         s2 = 0.0;
      }
      vv = b->w.xR[i] * b->y.xR[i];
      n0 += s0 * vv;
      n1 += s1 * vv;
      n2 += s2 * vv;
      vv = b->w.xR[i];
      d0 += s0 * vv;
      d1 += s1 * vv;
      d2 += s2 * vv;
   }
   *f = b->sy * n0 / d0;
   *df = b->sy * (n1 * d0 - n0 * d1) / sqr(d0, _state);
   *d2f = b->sy * ((n2 * d0 - n0 * d2) * sqr(d0, _state) - (n1 * d0 - n0 * d1) * 2 * d0 * d1) / sqr(sqr(d0, _state), _state);
}

// This subroutine performs linear transformation of the argument.
//
// Inputs:
//     B       -   rational interpolant in barycentric form
//     CA, CB  -   transformation coefficients: x = CA*t + CB
//
// Outputs:
//     B       -   transformed interpolant with X replaced by T
// ALGLIB Project: Copyright 19.08.2009 by Sergey Bochkanov
// API: void barycentriclintransx(const barycentricinterpolant &b, const double ca, const double cb, const xparams _xparams = xdefault);
void barycentriclintransx(barycentricinterpolant *b, double ca, double cb, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   double v;
// special case, replace by constant F(CB)
   if (ca == 0.0) {
      b->sy = barycentriccalc(b, cb, _state);
      v = 1.0;
      for (i = 0; i < b->n; i++) {
         b->y.xR[i] = 1.0;
         b->w.xR[i] = v;
         v = -v;
      }
      return;
   }
// general case: CA != 0
   for (i = 0; i < b->n; i++) {
      b->x.xR[i] = (b->x.xR[i] - cb) / ca;
   }
   if (ca < 0.0) {
      for (i = 0; i < b->n; i++) {
         if (i < b->n - 1 - i) {
            j = b->n - 1 - i;
            v = b->x.xR[i];
            b->x.xR[i] = b->x.xR[j];
            b->x.xR[j] = v;
            v = b->y.xR[i];
            b->y.xR[i] = b->y.xR[j];
            b->y.xR[j] = v;
            v = b->w.xR[i];
            b->w.xR[i] = b->w.xR[j];
            b->w.xR[j] = v;
         } else {
            break;
         }
      }
   }
}

// This  subroutine   performs   linear  transformation  of  the  barycentric
// interpolant.
//
// Inputs:
//     B       -   rational interpolant in barycentric form
//     CA, CB  -   transformation coefficients: B2(x) = CA*B(x) + CB
//
// Outputs:
//     B       -   transformed interpolant
// ALGLIB Project: Copyright 19.08.2009 by Sergey Bochkanov
// API: void barycentriclintransy(const barycentricinterpolant &b, const double ca, const double cb, const xparams _xparams = xdefault);
void barycentriclintransy(barycentricinterpolant *b, double ca, double cb, ae_state *_state) {
   ae_int_t i;
   double v;
   for (i = 0; i < b->n; i++) {
      b->y.xR[i] = ca * b->sy * b->y.xR[i] + cb;
   }
   b->sy = 0.0;
   for (i = 0; i < b->n; i++) {
      b->sy = maxreal(b->sy, ae_fabs(b->y.xR[i], _state), _state);
   }
   if (b->sy > 0.0) {
      v = 1 / b->sy;
      ae_v_muld(b->y.xR, 1, b->n, v);
   }
}

// Extracts X/Y/W arrays from rational interpolant
//
// Inputs:
//     B   -   barycentric interpolant
//
// Outputs:
//     N   -   nodes count, N>0
//     X   -   interpolation nodes, array[0..N-1]
//     F   -   function values, array[0..N-1]
//     W   -   barycentric weights, array[0..N-1]
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
// API: void barycentricunpack(const barycentricinterpolant &b, ae_int_t &n, real_1d_array &x, real_1d_array &y, real_1d_array &w, const xparams _xparams = xdefault);
void barycentricunpack(barycentricinterpolant *b, ae_int_t *n, RVector *x, RVector *y, RVector *w, ae_state *_state) {
   double v;
   *n = 0;
   SetVector(x);
   SetVector(y);
   SetVector(w);
   *n = b->n;
   ae_vector_set_length(x, *n, _state);
   ae_vector_set_length(y, *n, _state);
   ae_vector_set_length(w, *n, _state);
   v = b->sy;
   ae_v_move(x->xR, 1, b->x.xR, 1, *n);
   ae_v_moved(y->xR, 1, b->y.xR, 1, *n, v);
   ae_v_move(w->xR, 1, b->w.xR, 1, *n);
}

// Normalization of barycentric interpolant:
// * B.N, B.X, B.Y and B.W are initialized
// * B.SY is NOT initialized
// * Y[] is normalized, scaling coefficient is stored in B.SY
// * W[] is normalized, no scaling coefficient is stored
// * X[] is sorted
//
// Internal subroutine.
static void ratint_barycentricnormalize(barycentricinterpolant *b, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t j2;
   double v;
   ae_frame_make(_state, &_frame_block);
   NewVector(p1, 0, DT_INT, _state);
   NewVector(p2, 0, DT_INT, _state);
// Normalize task: |Y| <= 1, |W| <= 1, sort X[]
   b->sy = 0.0;
   for (i = 0; i < b->n; i++) {
      b->sy = maxreal(b->sy, ae_fabs(b->y.xR[i], _state), _state);
   }
   if (b->sy > 0.0 && ae_fabs(b->sy - 1, _state) > 10 * machineepsilon) {
      v = 1 / b->sy;
      ae_v_muld(b->y.xR, 1, b->n, v);
   }
   v = 0.0;
   for (i = 0; i < b->n; i++) {
      v = maxreal(v, ae_fabs(b->w.xR[i], _state), _state);
   }
   if (v > 0.0 && ae_fabs(v - 1, _state) > 10 * machineepsilon) {
      v = 1 / v;
      ae_v_muld(b->w.xR, 1, b->n, v);
   }
   for (i = 0; i < b->n - 1; i++) {
      if (b->x.xR[i + 1] < b->x.xR[i]) {
         tagsort(&b->x, b->n, &p1, &p2, _state);
         for (j = 0; j < b->n; j++) {
            j2 = p2.xZ[j];
            v = b->y.xR[j];
            b->y.xR[j] = b->y.xR[j2];
            b->y.xR[j2] = v;
            v = b->w.xR[j];
            b->w.xR[j] = b->w.xR[j2];
            b->w.xR[j2] = v;
         }
         break;
      }
   }
   ae_frame_leave(_state);
}

// Rational interpolant from X/Y/W arrays
//
// F(t) = SUM(i=0,n-1,w[i]*f[i]/(t-x[i])) / SUM(i=0,n-1,w[i]/(t-x[i]))
//
// Inputs:
//     X   -   interpolation nodes, array[0..N-1]
//     F   -   function values, array[0..N-1]
//     W   -   barycentric weights, array[0..N-1]
//     N   -   nodes count, N>0
//
// Outputs:
//     B   -   barycentric interpolant built from (X, Y, W)
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
// API: void barycentricbuildxyw(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const ae_int_t n, barycentricinterpolant &b, const xparams _xparams = xdefault);
void barycentricbuildxyw(RVector *x, RVector *y, RVector *w, ae_int_t n, barycentricinterpolant *b, ae_state *_state) {
   SetObj(barycentricinterpolant, b);
   ae_assert(n > 0, "BarycentricBuildXYW: incorrect N!", _state);
// fill X/Y/W
   ae_vector_set_length(&b->x, n, _state);
   ae_vector_set_length(&b->y, n, _state);
   ae_vector_set_length(&b->w, n, _state);
   ae_v_move(b->x.xR, 1, x->xR, 1, n);
   ae_v_move(b->y.xR, 1, y->xR, 1, n);
   ae_v_move(b->w.xR, 1, w->xR, 1, n);
   b->n = n;
// Normalize
   ratint_barycentricnormalize(b, _state);
}

// Rational interpolant without poles
//
// The subroutine constructs the rational interpolating function without real
// poles  (see  'Barycentric rational interpolation with no  poles  and  high
// rates of approximation', Michael S. Floater. and  Kai  Hormann,  for  more
// information on this subject).
//
// Inputs:
//     X   -   interpolation nodes, array[0..N-1].
//     Y   -   function values, array[0..N-1].
//     N   -   number of nodes, N>0.
//     D   -   order of the interpolation scheme, 0 <= D <= N-1.
//             D<0 will cause an error.
//             D >= N it will be replaced with D=N-1.
//             if you don't know what D to choose, use small value about 3-5.
//
// Outputs:
//     B   -   barycentric interpolant.
//
// Note:
//     this algorithm always succeeds and calculates the weights  with  close
//     to machine precision.
// ALGLIB Project: Copyright 17.06.2007 by Sergey Bochkanov
// API: void barycentricbuildfloaterhormann(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t d, barycentricinterpolant &b, const xparams _xparams = xdefault);
void barycentricbuildfloaterhormann(RVector *x, RVector *y, ae_int_t n, ae_int_t d, barycentricinterpolant *b, ae_state *_state) {
   ae_frame _frame_block;
   double s0;
   double s;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_frame_make(_state, &_frame_block);
   SetObj(barycentricinterpolant, b);
   NewVector(perm, 0, DT_INT, _state);
   NewVector(wtemp, 0, DT_REAL, _state);
   NewVector(sortrbuf, 0, DT_REAL, _state);
   NewVector(sortrbuf2, 0, DT_REAL, _state);
   ae_assert(n > 0, "BarycentricFloaterHormann: N <= 0!", _state);
   ae_assert(d >= 0, "BarycentricFloaterHormann: incorrect D!", _state);
// Prepare
   if (d > n - 1) {
      d = n - 1;
   }
   b->n = n;
// special case: N=1
   if (n == 1) {
      ae_vector_set_length(&b->x, n, _state);
      ae_vector_set_length(&b->y, n, _state);
      ae_vector_set_length(&b->w, n, _state);
      b->x.xR[0] = x->xR[0];
      b->y.xR[0] = y->xR[0];
      b->w.xR[0] = 1.0;
      ratint_barycentricnormalize(b, _state);
      ae_frame_leave(_state);
      return;
   }
// Fill X/Y
   ae_vector_set_length(&b->x, n, _state);
   ae_vector_set_length(&b->y, n, _state);
   ae_v_move(b->x.xR, 1, x->xR, 1, n);
   ae_v_move(b->y.xR, 1, y->xR, 1, n);
   tagsortfastr(&b->x, &b->y, &sortrbuf, &sortrbuf2, n, _state);
// Calculate Wk
   ae_vector_set_length(&b->w, n, _state);
   s0 = 1.0;
   for (k = 1; k <= d; k++) {
      s0 = -s0;
   }
   for (k = 0; k < n; k++) {
   // Wk
      s = 0.0;
      for (i = maxint(k - d, 0, _state); i <= k && i < n - d; i++) {
         v = 1.0;
         for (j = i; j <= i + d; j++) {
            if (j != k) {
               v /= ae_fabs(b->x.xR[k] - b->x.xR[j], _state);
            }
         }
         s += v;
      }
      b->w.xR[k] = s0 * s;
   // Next S0
      s0 = -s0;
   }
// Normalize
   ratint_barycentricnormalize(b, _state);
   ae_frame_leave(_state);
}

// Copying of the barycentric interpolant (for internal use only)
//
// Inputs:
//     B   -   barycentric interpolant
//
// Outputs:
//     B2  -   copy(B1)
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
void barycentriccopy(barycentricinterpolant *b, barycentricinterpolant *b2, ae_state *_state) {
   SetObj(barycentricinterpolant, b2);
   b2->n = b->n;
   b2->sy = b->sy;
   ae_vector_set_length(&b2->x, b2->n, _state);
   ae_vector_set_length(&b2->y, b2->n, _state);
   ae_vector_set_length(&b2->w, b2->n, _state);
   ae_v_move(b2->x.xR, 1, b->x.xR, 1, b2->n);
   ae_v_move(b2->y.xR, 1, b->y.xR, 1, b2->n);
   ae_v_move(b2->w.xR, 1, b->w.xR, 1, b2->n);
}

void barycentricinterpolant_init(void *_p, ae_state *_state, bool make_automatic) {
   barycentricinterpolant *p = (barycentricinterpolant *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->x, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->y, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->w, 0, DT_REAL, _state, make_automatic);
}

void barycentricinterpolant_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   barycentricinterpolant *dst = (barycentricinterpolant *)_dst;
   barycentricinterpolant *src = (barycentricinterpolant *)_src;
   dst->n = src->n;
   dst->sy = src->sy;
   ae_vector_copy(&dst->x, &src->x, _state, make_automatic);
   ae_vector_copy(&dst->y, &src->y, _state, make_automatic);
   ae_vector_copy(&dst->w, &src->w, _state, make_automatic);
}

void barycentricinterpolant_free(void *_p, bool make_automatic) {
   barycentricinterpolant *p = (barycentricinterpolant *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->x, make_automatic);
   ae_vector_free(&p->y, make_automatic);
   ae_vector_free(&p->w, make_automatic);
}
} // end of namespace alglib_impl

namespace alglib {
// Barycentric interpolant.
DefClass(barycentricinterpolant, )

double barycentriccalc(const barycentricinterpolant &b, const double t, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::barycentriccalc(ConstT(barycentricinterpolant, b), t, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

void barycentricdiff1(const barycentricinterpolant &b, const double t, double &f, double &df, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::barycentricdiff1(ConstT(barycentricinterpolant, b), t, &f, &df, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void barycentricdiff2(const barycentricinterpolant &b, const double t, double &f, double &df, double &d2f, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::barycentricdiff2(ConstT(barycentricinterpolant, b), t, &f, &df, &d2f, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void barycentriclintransx(const barycentricinterpolant &b, const double ca, const double cb, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::barycentriclintransx(ConstT(barycentricinterpolant, b), ca, cb, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void barycentriclintransy(const barycentricinterpolant &b, const double ca, const double cb, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::barycentriclintransy(ConstT(barycentricinterpolant, b), ca, cb, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void barycentricunpack(const barycentricinterpolant &b, ae_int_t &n, real_1d_array &x, real_1d_array &y, real_1d_array &w, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::barycentricunpack(ConstT(barycentricinterpolant, b), &n, ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_vector, w), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void barycentricbuildxyw(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const ae_int_t n, barycentricinterpolant &b, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::barycentricbuildxyw(ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_vector, w), n, ConstT(barycentricinterpolant, b), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void barycentricbuildfloaterhormann(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t d, barycentricinterpolant &b, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::barycentricbuildfloaterhormann(ConstT(ae_vector, x), ConstT(ae_vector, y), n, d, ConstT(barycentricinterpolant, b), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
} // end of namespace alglib

// === IDW Package ===
// Depends on: (AlgLibMisc) HQRND, NEARESTNEIGHBOR
// Depends on: (LinAlg) ABLAS
namespace alglib_impl {
static const double idw_w0 = 1.0;
static const double idw_meps = 1.0E-50;
static const ae_int_t idw_defaultnlayers = 16;
static const double idw_defaultlambda0 = 0.3333;

// This function creates buffer  structure  which  can  be  used  to  perform
// parallel  IDW  model  evaluations  (with  one  IDW  model  instance  being
// used from multiple threads, as long as  different  threads  use  different
// instances of buffer).
//
// This buffer object can be used with  idwtscalcbuf()  function  (here  "ts"
// stands for "thread-safe", "buf" is a suffix which denotes  function  which
// reuses previously allocated output space).
//
// How to use it:
// * create IDW model structure or load it from file
// * call idwcreatecalcbuffer(), once per thread working with IDW model  (you
//   should call this function only AFTER model initialization, see below for
//   more information)
// * call idwtscalcbuf() from different threads,  with  each  thread  working
//   with its own copy of buffer object.
//
// Inputs:
//     S           -   IDW model
//
// Outputs:
//     Buf         -   external buffer.
//
//
// IMPORTANT: buffer object should be used only with  IDW model object  which
//            was used to initialize buffer. Any attempt to use buffer   with
//            different object is dangerous - you may  get  memory  violation
//            error because sizes of internal arrays do not fit to dimensions
//            of the IDW structure.
//
// IMPORTANT: you  should  call  this function only for model which was built
//            with model builder (or unserialized from file). Sizes  of  some
//            internal structures are determined only after model  is  built,
//            so buffer object created before model construction  stage  will
//            be useless (and any attempt to use it will result in exception).
// ALGLIB: Copyright 22.10.2018 by Sergey Bochkanov
// API: void idwcreatecalcbuffer(const idwmodel &s, idwcalcbuffer &buf, const xparams _xparams = xdefault);
void idwcreatecalcbuffer(idwmodel *s, idwcalcbuffer *buf, ae_state *_state) {
   SetObj(idwcalcbuffer, buf);
   ae_assert(s->nx >= 1, "IDWCreateCalcBuffer: integrity check failed", _state);
   ae_assert(s->ny >= 1, "IDWCreateCalcBuffer: integrity check failed", _state);
   ae_assert(s->nlayers >= 0, "IDWCreateCalcBuffer: integrity check failed", _state);
   ae_assert(s->algotype >= 0, "IDWCreateCalcBuffer: integrity check failed", _state);
   if (s->nlayers >= 1 && s->algotype != 0) {
      kdtreecreaterequestbuffer(&s->tree, &buf->requestbuffer, _state);
   }
   rvectorsetlengthatleast(&buf->x, s->nx, _state);
   rvectorsetlengthatleast(&buf->y, s->ny, _state);
   rvectorsetlengthatleast(&buf->tsyw, s->ny * maxint(s->nlayers, 1, _state), _state);
   rvectorsetlengthatleast(&buf->tsw, maxint(s->nlayers, 1, _state), _state);
}

// This subroutine creates builder object used  to  generate IDW  model  from
// irregularly sampled (scattered) dataset.  Multidimensional  scalar/vector-
// -valued are supported.
//
// Builder object is used to fit model to data as follows:
// * builder object is created with idwbuildercreate() function
// * dataset is added with idwbuildersetpoints() function
// * one of the modern IDW algorithms is chosen with either:
//   * idwbuildersetalgomstab()            - Multilayer STABilized algorithm (interpolation)
//   Alternatively, one of the textbook algorithms can be chosen (not recommended):
//   * idwbuildersetalgotextbookshepard()  - textbook Shepard algorithm
//   * idwbuildersetalgotextbookmodshepard()-textbook modified Shepard algorithm
// * finally, model construction is performed with idwfit() function.
//
// Inputs:
//     NX  -   dimensionality of the argument, NX >= 1
//     NY  -   dimensionality of the function being modeled, NY >= 1;
//             NY=1 corresponds to classic scalar function, NY >= 1 corresponds
//             to vector-valued function.
//
// Outputs:
//     State-  builder object
// ALGLIB Project: Copyright 22.10.2018 by Sergey Bochkanov
// API: void idwbuildercreate(const ae_int_t nx, const ae_int_t ny, idwbuilder &state, const xparams _xparams = xdefault);
void idwbuildercreate(ae_int_t nx, ae_int_t ny, idwbuilder *state, ae_state *_state) {
   SetObj(idwbuilder, state);
   ae_assert(nx >= 1, "IDWBuilderCreate: NX <= 0", _state);
   ae_assert(ny >= 1, "IDWBuilderCreate: NY <= 0", _state);
// We choose reasonable defaults for the algorithm:
// * MSTAB algorithm
// * 12 layers
// * default radius
// * default Lambda0
   state->algotype = 2;
   state->priortermtype = 2;
   rvectorsetlengthatleast(&state->priortermval, ny, _state);
   state->nlayers = idw_defaultnlayers;
   state->r0 = 0.0;
   state->rdecay = 0.5;
   state->lambda0 = idw_defaultlambda0;
   state->lambdalast = 0.0;
   state->lambdadecay = 1.0;
// Other parameters, not used but initialized
   state->shepardp = 0.0;
// Initial dataset is empty
   state->npoints = 0;
   state->nx = nx;
   state->ny = ny;
}

// This function changes number of layers used by IDW-MSTAB algorithm.
//
// The more layers you have, the finer details can  be  reproduced  with  IDW
// model. The less layers you have, the less memory and CPU time is  consumed
// by the model.
//
// Memory consumption grows linearly with layers count,  running  time  grows
// sub-linearly.
//
// The default number of layers is 16, which allows you to reproduce  details
// at distance down to SRad/65536. You will rarely need to change it.
//
// Inputs:
//     State   -   builder object
//     NLayers -   NLayers >= 1, the number of layers used by the model.
// ALGLIB: Copyright 22.10.2018 by Sergey Bochkanov
// API: void idwbuildersetnlayers(const idwbuilder &state, const ae_int_t nlayers, const xparams _xparams = xdefault);
void idwbuildersetnlayers(idwbuilder *state, ae_int_t nlayers, ae_state *_state) {
   ae_assert(nlayers >= 1, "IDWBuilderSetNLayers: N<1", _state);
   state->nlayers = nlayers;
}

// This function adds dataset to the builder object.
//
// This function overrides results of the previous calls, i.e. multiple calls
// of this function will result in only the last set being added.
//
// Inputs:
//     State   -   builder object
//     XY      -   points, array[N,NX+NY]. One row  corresponds to  one point
//                 in the dataset. First NX elements  are  coordinates,  next
//                 NY elements are function values. Array may  be larger than
//                 specified, in  this  case  only leading [N,NX+NY] elements
//                 will be used.
//     N       -   number of points in the dataset, N >= 0.
// ALGLIB: Copyright 22.10.2018 by Sergey Bochkanov
// API: void idwbuildersetpoints(const idwbuilder &state, const real_2d_array &xy, const ae_int_t n, const xparams _xparams = xdefault);
// API: void idwbuildersetpoints(const idwbuilder &state, const real_2d_array &xy, const xparams _xparams = xdefault);
void idwbuildersetpoints(idwbuilder *state, RMatrix *xy, ae_int_t n, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t ew;
   ae_assert(n >= 0, "IDWBuilderSetPoints: N<0", _state);
   ae_assert(xy->rows >= n, "IDWBuilderSetPoints: Rows(XY)<N", _state);
   ae_assert(n == 0 || xy->cols >= state->nx + state->ny, "IDWBuilderSetPoints: Cols(XY)<NX+NY", _state);
   ae_assert(apservisfinitematrix(xy, n, state->nx + state->ny, _state), "IDWBuilderSetPoints: XY contains infinite or NaN values!", _state);
   state->npoints = n;
   ew = state->nx + state->ny;
   rvectorsetlengthatleast(&state->xy, n * ew, _state);
   for (i = 0; i < n; i++) {
      for (j = 0; j < ew; j++) {
         state->xy.xR[i * ew + j] = xy->xyR[i][j];
      }
   }
}

// This function sets IDW model  construction  algorithm  to  the  Multilayer
// Stabilized IDW method (IDW-MSTAB), a  latest  incarnation  of  the inverse
// distance weighting interpolation which fixes shortcomings of  the original
// and modified Shepard's variants.
//
// The distinctive features of IDW-MSTAB are:
// 1) exact interpolation  is  pursued  (as  opposed  to  fitting  and  noise
//    suppression)
// 2) improved robustness when compared with that of other algorithms:
//    * MSTAB shows almost no strange  fitting  artifacts  like  ripples  and
//      sharp spikes (unlike N-dimensional splines and HRBFs)
//    * MSTAB does not return function values far from the  interval  spanned
//      by the dataset; say, if all your points have |f| <= 1, you  can be sure
//      that model value won't deviate too much from [-1,+1]
// 3) good model construction time competing with that of HRBFs  and  bicubic
//    splines
// 4) ability to work with any number of dimensions, starting from NX=1
//
// The drawbacks of IDW-MSTAB (and all IDW algorithms in general) are:
// 1) dependence of the model evaluation time on the search radius
// 2) bad extrapolation properties, models built by this method  are  usually
//    conservative in their predictions
//
// Thus, IDW-MSTAB is  a  good  "default"  option  if  you  want  to  perform
// scattered multidimensional interpolation. Although it has  its  drawbacks,
// it is easy to use and robust, which makes it a good first step.
//
//
// Inputs:
//     State   -   builder object
//     SRad    -   initial search radius, SRad>0 is required. A model  value
//                 is obtained by "smart" averaging  of  the  dataset  points
//                 within search radius.
//
// NOTE 1: IDW interpolation can  correctly  handle  ANY  dataset,  including
//         datasets with non-distinct points. In case non-distinct points are
//         found, an average value for this point will be calculated.
//
// NOTE 2: the memory requirements for model storage are O(NPoints*NLayers).
//         The model construction needs twice as much memory as model storage.
//
// NOTE 3: by default 16 IDW layers are built which is enough for most cases.
//         You can change this parameter with idwbuildersetnlayers()  method.
//         Larger values may be necessary if you need to reproduce  extrafine
//         details at distances smaller than SRad/65536.  Smaller value   may
//         be necessary if you have to save memory and  computing  time,  and
//         ready to sacrifice some model quality.
//
//
// ALGORITHM DESCRIPTION
//
// ALGLIB implementation of IDW is somewhat similar to the modified Shepard's
// method (one with search radius R) but overcomes several of its  drawbacks,
// namely:
// 1) a tendency to show stepwise behavior for uniform datasets
// 2) a tendency to show terrible interpolation properties for highly
//    nonuniform datasets which often arise in geospatial tasks
//   (function values are densely sampled across multiple separated
//   "tracks")
//
// IDW-MSTAB method performs several passes over dataset and builds a sequence
// of progressively refined IDW models  (layers),  which starts from one with
// largest search radius SRad  and continues to smaller  search  radii  until
// required number of  layers  is  built.  Highest  layers  reproduce  global
// behavior of the target function at larger distances  whilst  lower  layers
// reproduce fine details at smaller distances.
//
// Each layer is an IDW model built with following modifications:
// * weights go to zero when distance approach to the current search radius
// * an additional regularizing term is added to the distance: w=1/(d^2+lambda)
// * an additional fictional term with unit weight and zero function value is
//   added in order to promote continuity  properties  at  the  isolated  and
//   boundary points
//
// By default, 16 layers is built, which is enough for most  cases.  You  can
// change this parameter with idwbuildersetnlayers() method.
// ALGLIB: Copyright 22.10.2018 by Sergey Bochkanov
// API: void idwbuildersetalgomstab(const idwbuilder &state, const double srad, const xparams _xparams = xdefault);
void idwbuildersetalgomstab(idwbuilder *state, double srad, ae_state *_state) {
   ae_assert(ae_isfinite(srad, _state), "IDWBuilderSetAlgoMSTAB: SRad is not finite", _state);
   ae_assert(srad > 0.0, "IDWBuilderSetAlgoMSTAB: SRad <= 0", _state);
// Set algorithm
   state->algotype = 2;
// Set options
   state->r0 = srad;
   state->rdecay = 0.5;
   state->lambda0 = idw_defaultlambda0;
   state->lambdalast = 0.0;
   state->lambdadecay = 1.0;
}

// This function sets  IDW  model  construction  algorithm  to  the  textbook
// Shepard's algorithm with custom (user-specified) power parameter.
//
// IMPORTANT: we do NOT recommend using textbook IDW algorithms because  they
//            have terrible interpolation properties. Use MSTAB in all cases.
//
// Inputs:
//     State   -   builder object
//     P       -   power parameter, P>0; good value to start with is 2.0
//
// NOTE 1: IDW interpolation can  correctly  handle  ANY  dataset,  including
//         datasets with non-distinct points. In case non-distinct points are
//         found, an average value for this point will be calculated.
// ALGLIB: Copyright 22.10.2018 by Sergey Bochkanov
// API: void idwbuildersetalgotextbookshepard(const idwbuilder &state, const double p, const xparams _xparams = xdefault);
void idwbuildersetalgotextbookshepard(idwbuilder *state, double p, ae_state *_state) {
   ae_assert(ae_isfinite(p, _state), "IDWBuilderSetAlgoShepard: P is not finite", _state);
   ae_assert(p > 0.0, "IDWBuilderSetAlgoShepard: P <= 0", _state);
// Set algorithm and options
   state->algotype = 0;
   state->shepardp = p;
}

// This function sets  IDW  model  construction  algorithm  to the 'textbook'
// modified Shepard's algorithm with user-specified search radius.
//
// IMPORTANT: we do NOT recommend using textbook IDW algorithms because  they
//            have terrible interpolation properties. Use MSTAB in all cases.
//
// Inputs:
//     State   -   builder object
//     R       -   search radius
//
// NOTE 1: IDW interpolation can  correctly  handle  ANY  dataset,  including
//         datasets with non-distinct points. In case non-distinct points are
//         found, an average value for this point will be calculated.
// ALGLIB: Copyright 22.10.2018 by Sergey Bochkanov
// API: void idwbuildersetalgotextbookmodshepard(const idwbuilder &state, const double r, const xparams _xparams = xdefault);
void idwbuildersetalgotextbookmodshepard(idwbuilder *state, double r, ae_state *_state) {
   ae_assert(ae_isfinite(r, _state), "IDWBuilderSetAlgoModShepard: R is not finite", _state);
   ae_assert(r > 0.0, "IDWBuilderSetAlgoModShepard: R <= 0", _state);
// Set algorithm and options
   state->algotype = 1;
   state->r0 = r;
}

// This function sets prior term (model value at infinity) as  user-specified
// value.
//
// Inputs:
//     S       -   spline builder
//     V       -   value for user-defined prior
//
// NOTE: for vector-valued models all components of the prior are set to same
//       user-specified value
// ALGLIB: Copyright 29.10.2018 by Sergey Bochkanov
// API: void idwbuildersetuserterm(const idwbuilder &state, const double v, const xparams _xparams = xdefault);
void idwbuildersetuserterm(idwbuilder *state, double v, ae_state *_state) {
   ae_int_t j;
   ae_assert(ae_isfinite(v, _state), "IDWBuilderSetUserTerm: infinite/NAN value passed", _state);
   state->priortermtype = 0;
   for (j = 0; j < state->ny; j++) {
      state->priortermval.xR[j] = v;
   }
}

// This function sets constant prior term (model value at infinity).
//
// Constant prior term is determined as mean value over dataset.
//
// Inputs:
//     S       -   spline builder
// ALGLIB: Copyright 29.10.2018 by Sergey Bochkanov
// API: void idwbuildersetconstterm(const idwbuilder &state, const xparams _xparams = xdefault);
void idwbuildersetconstterm(idwbuilder *state, ae_state *_state) {
   state->priortermtype = 2;
}

// This function sets zero prior term (model value at infinity).
//
// Inputs:
//     S       -   spline builder
// ALGLIB: Copyright 29.10.2018 by Sergey Bochkanov
// API: void idwbuildersetzeroterm(const idwbuilder &state, const xparams _xparams = xdefault);
void idwbuildersetzeroterm(idwbuilder *state, ae_state *_state) {
   state->priortermtype = 3;
}

// This function calculates values of the IDW model at the given point, using
// external  buffer  object  (internal  temporaries  of  IDW  model  are  not
// modified).
//
// This function allows to use same IDW model object  in  different  threads,
// assuming  that  different   threads  use different instances of the buffer
// structure.
//
// Inputs:
//     S       -   IDW model, may be shared between different threads
//     Buf     -   buffer object created for this particular instance of  IDW
//                 model with idwcreatecalcbuffer().
//     X       -   coordinates, array[NX]. X may have more than NX  elements,
//                 in this case only  leading NX will be used.
//     Y       -   possibly preallocated array
//
// Outputs:
//     Y       -   function value, array[NY]. Y is not reallocated when it
//                 is larger than NY.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: void idwtscalcbuf(const idwmodel &s, const idwcalcbuffer &buf, const real_1d_array &x, real_1d_array &y, const xparams _xparams = xdefault);
void idwtscalcbuf(idwmodel *s, idwcalcbuffer *buf, RVector *x, RVector *y, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t ew;
   ae_int_t k;
   ae_int_t layeridx;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t npoints;
   double v;
   double vv;
   double f;
   double p;
   double r;
   double eps;
   double lambdacur;
   double lambdadecay;
   double invrdecay;
   double invr;
   bool fastcalcpossible;
   double wf0;
   double ws0;
   double wf1;
   double ws1;
   nx = s->nx;
   ny = s->ny;
   ae_assert(x->cnt >= nx, "IDWTsCalcBuf: Length(X)<NX", _state);
   ae_assert(isfinitevector(x, nx, _state), "IDWTsCalcBuf: X contains infinite or NaN values", _state);
// Avoid spurious compiler warnings
   wf0 = 0.0;
   ws0 = 0.0;
   wf1 = 0.0;
   ws1 = 0.0;
// Allocate output
   if (y->cnt < ny) {
      ae_vector_set_length(y, ny, _state);
   }
// Quick exit for NLayers=0 (no dataset)
   if (s->nlayers == 0) {
      for (j = 0; j < ny; j++) {
         y->xR[j] = s->globalprior.xR[j];
      }
      return;
   }
// Textbook Shepard's method
   if (s->algotype == 0) {
      npoints = s->npoints;
      ae_assert(npoints > 0, "IDWTsCalcBuf: integrity check failed", _state);
      eps = 1.0E-50;
      ew = nx + ny;
      p = s->shepardp;
      for (j = 0; j < ny; j++) {
         y->xR[j] = 0.0;
         buf->tsyw.xR[j] = eps;
      }
      for (i = 0; i < npoints; i++) {
      // Compute squared distance
         v = 0.0;
         for (j = 0; j < nx; j++) {
            vv = s->shepardxy.xR[i * ew + j] - x->xR[j];
            v += vv * vv;
         }
      // Compute weight (with small regularizing addition)
         v = ae_pow(v, p * 0.5, _state);
         v = 1 / (eps + v);
      // Accumulate
         for (j = 0; j < ny; j++) {
            y->xR[j] += v * s->shepardxy.xR[i * ew + nx + j];
            buf->tsyw.xR[j] += v;
         }
      }
      for (j = 0; j < ny; j++) {
         y->xR[j] = y->xR[j] / buf->tsyw.xR[j] + s->globalprior.xR[j];
      }
      return;
   }
// Textbook modified Shepard's method
   if (s->algotype == 1) {
      eps = 1.0E-50;
      r = s->r0;
      for (j = 0; j < ny; j++) {
         y->xR[j] = 0.0;
         buf->tsyw.xR[j] = eps;
      }
      k = kdtreetsqueryrnn(&s->tree, &buf->requestbuffer, x, r, true, _state);
      kdtreetsqueryresultsxy(&s->tree, &buf->requestbuffer, &buf->tsxy, _state);
      kdtreetsqueryresultsdistances(&s->tree, &buf->requestbuffer, &buf->tsdist, _state);
      for (i = 0; i < k; i++) {
         v = buf->tsdist.xR[i];
         v = (r - v) / (r * v + eps);
         v *= v;
         for (j = 0; j < ny; j++) {
            y->xR[j] += v * buf->tsxy.xyR[i][nx + j];
            buf->tsyw.xR[j] += v;
         }
      }
      for (j = 0; j < ny; j++) {
         y->xR[j] = y->xR[j] / buf->tsyw.xR[j] + s->globalprior.xR[j];
      }
      return;
   }
// MSTAB
   if (s->algotype == 2) {
      ae_assert(idw_w0 == 1.0, "IDWTsCalcBuf: unexpected W0, integrity check failed", _state);
      invrdecay = 1 / s->rdecay;
      invr = 1 / s->r0;
      lambdadecay = s->lambdadecay;
      fastcalcpossible = (ny == 1 && s->nlayers >= 3) && lambdadecay == 1.0;
      if (fastcalcpossible) {
      // Important special case, NY=1, no lambda-decay,
      // we can perform optimized fast evaluation
         wf0 = 0.0;
         ws0 = idw_w0;
         wf1 = 0.0;
         ws1 = idw_w0;
         for (j = 0; j < s->nlayers; j++) {
            buf->tsyw.xR[j] = 0.0;
            buf->tsw.xR[j] = idw_w0;
         }
      } else {
      // Setup variables for generic evaluation path
         for (j = 0; j < ny * s->nlayers; j++) {
            buf->tsyw.xR[j] = 0.0;
         }
         for (j = 0; j < s->nlayers; j++) {
            buf->tsw.xR[j] = idw_w0;
         }
      }
      k = kdtreetsqueryrnnu(&s->tree, &buf->requestbuffer, x, s->r0, true, _state);
      kdtreetsqueryresultsxy(&s->tree, &buf->requestbuffer, &buf->tsxy, _state);
      kdtreetsqueryresultsdistances(&s->tree, &buf->requestbuffer, &buf->tsdist, _state);
      for (i = 0; i < k; i++) {
         lambdacur = s->lambda0;
         vv = buf->tsdist.xR[i] * invr;
         if (fastcalcpossible) {
         // Important special case, fast evaluation possible
            v = vv * vv;
            v = (1 - v) * (1 - v) / (v + lambdacur);
            f = buf->tsxy.xyR[i][nx + 0];
            wf0 += v * f;
            ws0 += v;
            vv *= invrdecay;
            if (vv >= 1.0) {
               continue;
            }
            v = vv * vv;
            v = (1 - v) * (1 - v) / (v + lambdacur);
            f = buf->tsxy.xyR[i][nx + 1];
            wf1 += v * f;
            ws1 += v;
            vv *= invrdecay;
            if (vv >= 1.0) {
               continue;
            }
            for (layeridx = 2; layeridx < s->nlayers; layeridx++) {
               if (layeridx == s->nlayers - 1) {
                  lambdacur = s->lambdalast;
               }
               v = vv * vv;
               v = (1 - v) * (1 - v) / (v + lambdacur);
               f = buf->tsxy.xyR[i][nx + layeridx];
               buf->tsyw.xR[layeridx] += v * f;
               buf->tsw.xR[layeridx] += v;
               vv *= invrdecay;
               if (vv >= 1.0) {
                  break;
               }
            }
         } else {
         // General case
            for (layeridx = 0; layeridx < s->nlayers; layeridx++) {
               if (layeridx == s->nlayers - 1) {
                  lambdacur = s->lambdalast;
               }
               if (vv >= 1.0) {
                  break;
               }
               v = vv * vv;
               v = (1 - v) * (1 - v) / (v + lambdacur);
               for (j = 0; j < ny; j++) {
                  f = buf->tsxy.xyR[i][nx + layeridx * ny + j];
                  buf->tsyw.xR[layeridx * ny + j] += v * f;
               }
               buf->tsw.xR[layeridx] += v;
               lambdacur *= lambdadecay;
               vv *= invrdecay;
            }
         }
      }
      if (fastcalcpossible) {
      // Important special case, finalize evaluations
         buf->tsyw.xR[0] = wf0;
         buf->tsw.xR[0] = ws0;
         buf->tsyw.xR[1] = wf1;
         buf->tsw.xR[1] = ws1;
      }
      for (j = 0; j < ny; j++) {
         y->xR[j] = s->globalprior.xR[j];
      }
      for (layeridx = 0; layeridx < s->nlayers; layeridx++) {
         for (j = 0; j < ny; j++) {
            y->xR[j] += buf->tsyw.xR[layeridx * ny + j] / buf->tsw.xR[layeridx];
         }
      }
      return;
   }
//
   ae_assert(false, "IDWTsCalcBuf: unexpected AlgoType", _state);
}

// This function calculates values of the IDW model at the given point.
//
// This is general function which can be used for arbitrary NX (dimension  of
// the space of arguments) and NY (dimension of the function itself). However
// when  you  have  NY=1  you  may  find more convenient to  use  idwcalc1(),
// idwcalc2() or idwcalc3().
//
// NOTE: this function modifies internal temporaries of the  IDW  model, thus
//       IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
//       evaluation from the multiple threads, use idwtscalcbuf()  with  per-
//       thread buffer object.
//
// Inputs:
//     S       -   IDW model
//     X       -   coordinates, array[NX]. X may have more than NX  elements,
//                 in this case only leading NX will be used.
//
// Outputs:
//     Y       -   function value, array[NY]. Y is out-parameter and will  be
//                 reallocated after call to this function. In case you  want
//                 to reuse previously allocated Y, you may use idwcalcbuf(),
//                 which reallocates Y only when it is too small.
// ALGLIB: Copyright 22.10.2018 by Sergey Bochkanov
// API: void idwcalc(const idwmodel &s, const real_1d_array &x, real_1d_array &y, const xparams _xparams = xdefault);
void idwcalc(idwmodel *s, RVector *x, RVector *y, ae_state *_state) {
   SetVector(y);
   idwtscalcbuf(s, &s->buffer, x, y, _state);
}

// This function calculates values of the IDW model at the given point.
//
// Same as idwcalc(), but does not reallocate Y when in is large enough to
// store function values.
//
// NOTE: this function modifies internal temporaries of the  IDW  model, thus
//       IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
//       evaluation from the multiple threads, use idwtscalcbuf()  with  per-
//       thread buffer object.
//
// Inputs:
//     S       -   IDW model
//     X       -   coordinates, array[NX]. X may have more than NX  elements,
//                 in this case only leading NX will be used.
//     Y       -   possibly preallocated array
//
// Outputs:
//     Y       -   function value, array[NY]. Y is not reallocated when it
//                 is larger than NY.
// ALGLIB: Copyright 22.10.2018 by Sergey Bochkanov
// API: void idwcalcbuf(const idwmodel &s, const real_1d_array &x, real_1d_array &y, const xparams _xparams = xdefault);
void idwcalcbuf(idwmodel *s, RVector *x, RVector *y, ae_state *_state) {
   idwtscalcbuf(s, &s->buffer, x, y, _state);
}

// IDW interpolation: scalar target, 1-dimensional argument
//
// NOTE: this function modifies internal temporaries of the  IDW  model, thus
//       IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
//       evaluation from the multiple threads, use idwtscalcbuf()  with  per-
//       thread buffer object.
//
// Inputs:
//     S   -   IDW interpolant built with IDW builder
//     X0  -   argument value
//
// Result:
//     IDW interpolant S(X0)
// ALGLIB: Copyright 22.10.2018 by Sergey Bochkanov
// API: double idwcalc1(const idwmodel &s, const double x0, const xparams _xparams = xdefault);
double idwcalc1(idwmodel *s, double x0, ae_state *_state) {
   double result;
   ae_assert(s->nx == 1, "IDWCalc1: S.NX != 1", _state);
   ae_assert(s->ny == 1, "IDWCalc1: S.NY != 1", _state);
   ae_assert(ae_isfinite(x0, _state), "IDWCalc1: X0 is INF or NAN", _state);
   s->buffer.x.xR[0] = x0;
   idwtscalcbuf(s, &s->buffer, &s->buffer.x, &s->buffer.y, _state);
   result = s->buffer.y.xR[0];
   return result;
}

// IDW interpolation: scalar target, 2-dimensional argument
//
// NOTE: this function modifies internal temporaries of the  IDW  model, thus
//       IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
//       evaluation from the multiple threads, use idwtscalcbuf()  with  per-
//       thread buffer object.
//
// Inputs:
//     S       -   IDW interpolant built with IDW builder
//     X0, X1  -   argument value
//
// Result:
//     IDW interpolant S(X0,X1)
// ALGLIB: Copyright 22.10.2018 by Sergey Bochkanov
// API: double idwcalc2(const idwmodel &s, const double x0, const double x1, const xparams _xparams = xdefault);
double idwcalc2(idwmodel *s, double x0, double x1, ae_state *_state) {
   double result;
   ae_assert(s->nx == 2, "IDWCalc2: S.NX != 2", _state);
   ae_assert(s->ny == 1, "IDWCalc2: S.NY != 1", _state);
   ae_assert(ae_isfinite(x0, _state), "IDWCalc2: X0 is INF or NAN", _state);
   ae_assert(ae_isfinite(x1, _state), "IDWCalc2: X1 is INF or NAN", _state);
   s->buffer.x.xR[0] = x0;
   s->buffer.x.xR[1] = x1;
   idwtscalcbuf(s, &s->buffer, &s->buffer.x, &s->buffer.y, _state);
   result = s->buffer.y.xR[0];
   return result;
}

// IDW interpolation: scalar target, 3-dimensional argument
//
// NOTE: this function modifies internal temporaries of the  IDW  model, thus
//       IT IS NOT  THREAD-SAFE!  If  you  want  to  perform  parallel  model
//       evaluation from the multiple threads, use idwtscalcbuf()  with  per-
//       thread buffer object.
//
// Inputs:
//     S       -   IDW interpolant built with IDW builder
//     X0,X1,X2-   argument value
//
// Result:
//     IDW interpolant S(X0,X1,X2)
// ALGLIB: Copyright 22.10.2018 by Sergey Bochkanov
// API: double idwcalc3(const idwmodel &s, const double x0, const double x1, const double x2, const xparams _xparams = xdefault);
double idwcalc3(idwmodel *s, double x0, double x1, double x2, ae_state *_state) {
   double result;
   ae_assert(s->nx == 3, "IDWCalc3: S.NX != 3", _state);
   ae_assert(s->ny == 1, "IDWCalc3: S.NY != 1", _state);
   ae_assert(ae_isfinite(x0, _state), "IDWCalc3: X0 is INF or NAN", _state);
   ae_assert(ae_isfinite(x1, _state), "IDWCalc3: X1 is INF or NAN", _state);
   ae_assert(ae_isfinite(x2, _state), "IDWCalc3: X2 is INF or NAN", _state);
   s->buffer.x.xR[0] = x0;
   s->buffer.x.xR[1] = x1;
   s->buffer.x.xR[2] = x2;
   idwtscalcbuf(s, &s->buffer, &s->buffer.x, &s->buffer.y, _state);
   result = s->buffer.y.xR[0];
   return result;
}

// This function evaluates error metrics for the model  using  IDWTsCalcBuf()
// to calculate model at each point.
//
// NOTE: modern IDW algorithms (MSTAB, MSMOOTH) can generate residuals during
//       model construction, so they do not need this function  in  order  to
//       evaluate error metrics.
//
// Following fields of Rep are filled:
// * rep.rmserror
// * rep.avgerror
// * rep.maxerror
// * rep.r2
// ALGLIB: Copyright 22.10.2018 by Sergey Bochkanov
static void idw_errormetricsviacalc(idwbuilder *state, idwmodel *model, idwreport *rep, ae_state *_state) {
   ae_int_t npoints;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t i;
   ae_int_t j;
   double v;
   double vv;
   double rss;
   double tss;
   npoints = state->npoints;
   nx = state->nx;
   ny = state->ny;
   if (npoints == 0) {
      rep->rmserror = 0.0;
      rep->avgerror = 0.0;
      rep->maxerror = 0.0;
      rep->r2 = 1.0;
      return;
   }
   rep->rmserror = 0.0;
   rep->avgerror = 0.0;
   rep->maxerror = 0.0;
   rss = 0.0;
   tss = 0.0;
   for (i = 0; i < npoints; i++) {
      for (j = 0; j < nx; j++) {
         model->buffer.x.xR[j] = state->xy.xR[i * (nx + ny) + j];
      }
      idwtscalcbuf(model, &model->buffer, &model->buffer.x, &model->buffer.y, _state);
      for (j = 0; j < ny; j++) {
         vv = state->xy.xR[i * (nx + ny) + nx + j];
         v = ae_fabs(vv - model->buffer.y.xR[j], _state);
         rep->rmserror += v * v;
         rep->avgerror += v;
         rep->maxerror = maxreal(rep->maxerror, v, _state);
         rss += v * v;
         tss += sqr(vv - state->tmpmean.xR[j], _state);
      }
   }
   rep->rmserror = ae_sqrt(rep->rmserror / (npoints * ny), _state);
   rep->avgerror /= npoints * ny;
   rep->r2 = 1.0 - rss / coalesce(tss, 1.0, _state);
}

// This function fits IDW model to the dataset using current IDW construction
// algorithm. A model being built and fitting report are returned.
//
// Inputs:
//     State   -   builder object
//
// Outputs:
//     Model   -   an IDW model built with current algorithm
//     Rep     -   model fitting report, fields of this structure contain
//                 information about average fitting errors.
//
// NOTE: although IDW-MSTAB algorithm is an  interpolation  method,  i.e.  it
//       tries to fit the model exactly, it can  handle  datasets  with  non-
//       distinct points which can not be fit exactly; in such  cases  least-
//       squares fitting is performed.
// ALGLIB: Copyright 22.10.2018 by Sergey Bochkanov
// API: void idwfit(const idwbuilder &state, idwmodel &model, idwreport &rep, const xparams _xparams = xdefault);
void idwfit(idwbuilder *state, idwmodel *model, idwreport *rep, ae_state *_state) {
   ae_int_t i;
   ae_int_t i0;
   ae_int_t j;
   ae_int_t k;
   ae_int_t layeridx;
   ae_int_t srcidx;
   double v;
   double vv;
   ae_int_t npoints;
   ae_int_t nx;
   ae_int_t ny;
   double rcur;
   double lambdacur;
   double rss;
   double tss;
   SetObj(idwmodel, model);
   SetObj(idwreport, rep);
   nx = state->nx;
   ny = state->ny;
   npoints = state->npoints;
// Clear report fields
   rep->rmserror = 0.0;
   rep->avgerror = 0.0;
   rep->maxerror = 0.0;
   rep->r2 = 1.0;
// Quick exit for empty dataset
   if (state->npoints == 0) {
      model->nx = nx;
      model->ny = ny;
      ae_vector_set_length(&model->globalprior, ny, _state);
      for (i = 0; i < ny; i++) {
         model->globalprior.xR[i] = 0.0;
      }
      model->algotype = 0;
      model->nlayers = 0;
      model->r0 = 1.0;
      model->rdecay = 0.5;
      model->lambda0 = 0.0;
      model->lambdalast = 0.0;
      model->lambdadecay = 1.0;
      model->shepardp = 2.0;
      model->npoints = 0;
      idwcreatecalcbuffer(model, &model->buffer, _state);
      return;
   }
// Compute temporaries which will be required later:
// * global mean
   ae_assert(state->npoints > 0, "IDWFit: integrity check failed", _state);
   rvectorsetlengthatleast(&state->tmpmean, ny, _state);
   for (j = 0; j < ny; j++) {
      state->tmpmean.xR[j] = 0.0;
   }
   for (i = 0; i < npoints; i++) {
      for (j = 0; j < ny; j++) {
         state->tmpmean.xR[j] += state->xy.xR[i * (nx + ny) + nx + j];
      }
   }
   for (j = 0; j < ny; j++) {
      state->tmpmean.xR[j] /= npoints;
   }
// Compute global prior
//
// NOTE: for original Shepard's method it is always mean value
   rvectorsetlengthatleast(&model->globalprior, ny, _state);
   for (j = 0; j < ny; j++) {
      model->globalprior.xR[j] = state->tmpmean.xR[j];
   }
   if (state->algotype != 0) {
   // Algorithm is set to one of the "advanced" versions with search
   // radius which can handle non-mean prior term
      if (state->priortermtype == 0) {
      // User-specified prior
         for (j = 0; j < ny; j++) {
            model->globalprior.xR[j] = state->priortermval.xR[j];
         }
      }
      if (state->priortermtype == 3) {
      // Zero prior
         for (j = 0; j < ny; j++) {
            model->globalprior.xR[j] = 0.0;
         }
      }
   }
// Textbook Shepard
   if (state->algotype == 0) {
   // Initialize model
      model->algotype = 0;
      model->nx = nx;
      model->ny = ny;
      model->nlayers = 1;
      model->r0 = 1.0;
      model->rdecay = 0.5;
      model->lambda0 = 0.0;
      model->lambdalast = 0.0;
      model->lambdadecay = 1.0;
      model->shepardp = state->shepardp;
   // Copy dataset
      rvectorsetlengthatleast(&model->shepardxy, npoints * (nx + ny), _state);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nx; j++) {
            model->shepardxy.xR[i * (nx + ny) + j] = state->xy.xR[i * (nx + ny) + j];
         }
         for (j = 0; j < ny; j++) {
            model->shepardxy.xR[i * (nx + ny) + nx + j] = state->xy.xR[i * (nx + ny) + nx + j] - model->globalprior.xR[j];
         }
      }
      model->npoints = npoints;
   // Prepare internal buffer
   // Evaluate report fields
      idwcreatecalcbuffer(model, &model->buffer, _state);
      idw_errormetricsviacalc(state, model, rep, _state);
      return;
   }
// Textbook modified Shepard's method
   if (state->algotype == 1) {
   // Initialize model
      model->algotype = 1;
      model->nx = nx;
      model->ny = ny;
      model->nlayers = 1;
      model->r0 = state->r0;
      model->rdecay = 1.0;
      model->lambda0 = 0.0;
      model->lambdalast = 0.0;
      model->lambdadecay = 1.0;
      model->shepardp = 0.0;
   // Build kd-tree search structure
      rmatrixsetlengthatleast(&state->tmpxy, npoints, nx + ny, _state);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nx; j++) {
            state->tmpxy.xyR[i][j] = state->xy.xR[i * (nx + ny) + j];
         }
         for (j = 0; j < ny; j++) {
            state->tmpxy.xyR[i][nx + j] = state->xy.xR[i * (nx + ny) + nx + j] - model->globalprior.xR[j];
         }
      }
      kdtreebuild(&state->tmpxy, npoints, nx, ny, 2, &model->tree, _state);
   // Prepare internal buffer
   // Evaluate report fields
      idwcreatecalcbuffer(model, &model->buffer, _state);
      idw_errormetricsviacalc(state, model, rep, _state);
      return;
   }
// MSTAB algorithm
   if (state->algotype == 2) {
      ae_assert(state->nlayers >= 1, "IDWFit: integrity check failed", _state);
   // Initialize model
      model->algotype = 2;
      model->nx = nx;
      model->ny = ny;
      model->nlayers = state->nlayers;
      model->r0 = state->r0;
      model->rdecay = 0.5;
      model->lambda0 = state->lambda0;
      model->lambdadecay = 1.0;
      model->lambdalast = idw_meps;
      model->shepardp = 0.0;
   // Build kd-tree search structure,
   // prepare input residuals for the first layer of the model
      rmatrixsetlengthatleast(&state->tmpxy, npoints, nx, _state);
      rmatrixsetlengthatleast(&state->tmplayers, npoints, nx + ny * (state->nlayers + 1), _state);
      ivectorsetlengthatleast(&state->tmptags, npoints, _state);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nx; j++) {
            v = state->xy.xR[i * (nx + ny) + j];
            state->tmpxy.xyR[i][j] = v;
            state->tmplayers.xyR[i][j] = v;
         }
         state->tmptags.xZ[i] = i;
         for (j = 0; j < ny; j++) {
            state->tmplayers.xyR[i][nx + j] = state->xy.xR[i * (nx + ny) + nx + j] - model->globalprior.xR[j];
         }
      }
      kdtreebuildtagged(&state->tmpxy, &state->tmptags, npoints, nx, 0, 2, &state->tmptree, _state);
   // Iteratively build layer by layer
      rvectorsetlengthatleast(&state->tmpx, nx, _state);
      rvectorsetlengthatleast(&state->tmpwy, ny, _state);
      rvectorsetlengthatleast(&state->tmpw, ny, _state);
      for (layeridx = 0; layeridx < state->nlayers; layeridx++) {
      // Determine layer metrics
         rcur = model->r0 * ae_pow(model->rdecay, (double)layeridx, _state);
         lambdacur = model->lambda0 * ae_pow(model->lambdadecay, (double)layeridx, _state);
         if (layeridx == state->nlayers - 1) {
            lambdacur = model->lambdalast;
         }
      // For each point compute residual from fitting with current layer
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nx; j++) {
               state->tmpx.xR[j] = state->tmplayers.xyR[i][j];
            }
            k = kdtreequeryrnn(&state->tmptree, &state->tmpx, rcur, true, _state);
            kdtreequeryresultstags(&state->tmptree, &state->tmptags, _state);
            kdtreequeryresultsdistances(&state->tmptree, &state->tmpdist, _state);
            for (j = 0; j < ny; j++) {
               state->tmpwy.xR[j] = 0.0;
               state->tmpw.xR[j] = idw_w0;
            }
            for (i0 = 0; i0 < k; i0++) {
               vv = state->tmpdist.xR[i0] / rcur;
               vv *= vv;
               v = (1 - vv) * (1 - vv) / (vv + lambdacur);
               srcidx = state->tmptags.xZ[i0];
               for (j = 0; j < ny; j++) {
                  state->tmpwy.xR[j] += v * state->tmplayers.xyR[srcidx][nx + layeridx * ny + j];
                  state->tmpw.xR[j] += v;
               }
            }
            for (j = 0; j < ny; j++) {
               v = state->tmplayers.xyR[i][nx + layeridx * ny + j];
               state->tmplayers.xyR[i][nx + (layeridx + 1) * ny + j] = v - state->tmpwy.xR[j] / state->tmpw.xR[j];
            }
         }
      }
      kdtreebuild(&state->tmplayers, npoints, nx, ny * state->nlayers, 2, &model->tree, _state);
   // Evaluate report fields
      rep->rmserror = 0.0;
      rep->avgerror = 0.0;
      rep->maxerror = 0.0;
      rss = 0.0;
      tss = 0.0;
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < ny; j++) {
            v = ae_fabs(state->tmplayers.xyR[i][nx + state->nlayers * ny + j], _state);
            rep->rmserror += v * v;
            rep->avgerror += v;
            rep->maxerror = maxreal(rep->maxerror, ae_fabs(v, _state), _state);
            rss += v * v;
            tss += sqr(state->xy.xR[i * (nx + ny) + nx + j] - state->tmpmean.xR[j], _state);
         }
      }
      rep->rmserror = ae_sqrt(rep->rmserror / (npoints * ny), _state);
      rep->avgerror /= npoints * ny;
      rep->r2 = 1.0 - rss / coalesce(tss, 1.0, _state);
   // Prepare internal buffer
      idwcreatecalcbuffer(model, &model->buffer, _state);
      return;
   }
// Unknown algorithm
   ae_assert(false, "IDWFit: integrity check failed, unexpected algorithm", _state);
}

// Serializer: allocation
// ALGLIB: Copyright 28.02.2018 by Sergey Bochkanov
void idwalloc(ae_serializer *s, idwmodel *model, ae_state *_state) {
   bool processed;
// Header
   ae_serializer_alloc_entry(s);
// Algorithm type and fields which are set for all algorithms
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   allocrealarray(s, &model->globalprior, -1, _state);
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
// Algorithm-specific fields
   processed = false;
   if (model->algotype == 0) {
      ae_serializer_alloc_entry(s);
      allocrealarray(s, &model->shepardxy, -1, _state);
      processed = true;
   }
   if (model->algotype > 0) {
      kdtreealloc(s, &model->tree, _state);
      processed = true;
   }
   ae_assert(processed, "IDW: integrity check failed during serialization", _state);
}

// Serializer: serialization
// These functions serialize a data structure to a C++ string or stream.
// * serialization can be freely moved across 32-bit and 64-bit systems,
//   and different byte orders. For example, you can serialize a string
//   on a SPARC and unserialize it on an x86.
// * ALGLIB++ serialization is compatible with serialization in ALGLIB,
//   in both directions.
// Important properties of s_out:
// * it contains alphanumeric characters, dots, underscores, minus signs
// * these symbols are grouped into words, which are separated by spaces
//   and Windows-style (CR+LF) newlines
// ALGLIB: Copyright 28.02.2018 by Sergey Bochkanov
// API: void idwserialize(idwmodel &obj, std::string &s_out);
// API: void idwserialize(idwmodel &obj, std::ostream &s_out);
void idwserialize(ae_serializer *s, idwmodel *model, ae_state *_state) {
   bool processed;
// Header
   ae_serializer_serialize_int(s, getidwserializationcode(_state), _state);
// Algorithm type and fields which are set for all algorithms
   ae_serializer_serialize_int(s, model->algotype, _state);
   ae_serializer_serialize_int(s, model->nx, _state);
   ae_serializer_serialize_int(s, model->ny, _state);
   serializerealarray(s, &model->globalprior, -1, _state);
   ae_serializer_serialize_int(s, model->nlayers, _state);
   ae_serializer_serialize_double(s, model->r0, _state);
   ae_serializer_serialize_double(s, model->rdecay, _state);
   ae_serializer_serialize_double(s, model->lambda0, _state);
   ae_serializer_serialize_double(s, model->lambdalast, _state);
   ae_serializer_serialize_double(s, model->lambdadecay, _state);
   ae_serializer_serialize_double(s, model->shepardp, _state);
// Algorithm-specific fields
   processed = false;
   if (model->algotype == 0) {
      ae_serializer_serialize_int(s, model->npoints, _state);
      serializerealarray(s, &model->shepardxy, -1, _state);
      processed = true;
   }
   if (model->algotype > 0) {
      kdtreeserialize(s, &model->tree, _state);
      processed = true;
   }
   ae_assert(processed, "IDW: integrity check failed during serialization", _state);
}

// Serializer: unserialization
// These functions unserialize a data structure from a C++ string or stream.
// Important properties of s_in:
// * any combination of spaces, tabs, Windows or Unix stype newlines can
//   be used as separators, so as to allow flexible reformatting of the
//   stream or string from text or XML files.
// * But you should not insert separators into the middle of the "words"
//   nor you should change case of letters.
// ALGLIB: Copyright 28.02.2018 by Sergey Bochkanov
// API: void idwunserialize(const std::string &s_in, idwmodel &obj);
// API: void idwunserialize(const std::istream &s_in, idwmodel &obj);
void idwunserialize(ae_serializer *s, idwmodel *model, ae_state *_state) {
   bool processed;
   ae_int_t scode;
   SetObj(idwmodel, model);
// Header
   ae_serializer_unserialize_int(s, &scode, _state);
   ae_assert(scode == getidwserializationcode(_state), "IDWUnserialize: stream header corrupted", _state);
// Algorithm type and fields which are set for all algorithms
   ae_serializer_unserialize_int(s, &model->algotype, _state);
   ae_serializer_unserialize_int(s, &model->nx, _state);
   ae_serializer_unserialize_int(s, &model->ny, _state);
   unserializerealarray(s, &model->globalprior, _state);
   ae_serializer_unserialize_int(s, &model->nlayers, _state);
   ae_serializer_unserialize_double(s, &model->r0, _state);
   ae_serializer_unserialize_double(s, &model->rdecay, _state);
   ae_serializer_unserialize_double(s, &model->lambda0, _state);
   ae_serializer_unserialize_double(s, &model->lambdalast, _state);
   ae_serializer_unserialize_double(s, &model->lambdadecay, _state);
   ae_serializer_unserialize_double(s, &model->shepardp, _state);
// Algorithm-specific fields
   processed = false;
   if (model->algotype == 0) {
      ae_serializer_unserialize_int(s, &model->npoints, _state);
      unserializerealarray(s, &model->shepardxy, _state);
      processed = true;
   }
   if (model->algotype > 0) {
      kdtreeunserialize(s, &model->tree, _state);
      processed = true;
   }
   ae_assert(processed, "IDW: integrity check failed during serialization", _state);
// Temporary buffers
   idwcreatecalcbuffer(model, &model->buffer, _state);
}

void idwcalcbuffer_init(void *_p, ae_state *_state, bool make_automatic) {
   idwcalcbuffer *p = (idwcalcbuffer *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->x, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->y, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tsyw, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tsw, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->tsxy, 0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tsdist, 0, DT_REAL, _state, make_automatic);
   kdtreerequestbuffer_init(&p->requestbuffer, _state, make_automatic);
}

void idwcalcbuffer_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   idwcalcbuffer *dst = (idwcalcbuffer *)_dst;
   idwcalcbuffer *src = (idwcalcbuffer *)_src;
   ae_vector_copy(&dst->x, &src->x, _state, make_automatic);
   ae_vector_copy(&dst->y, &src->y, _state, make_automatic);
   ae_vector_copy(&dst->tsyw, &src->tsyw, _state, make_automatic);
   ae_vector_copy(&dst->tsw, &src->tsw, _state, make_automatic);
   ae_matrix_copy(&dst->tsxy, &src->tsxy, _state, make_automatic);
   ae_vector_copy(&dst->tsdist, &src->tsdist, _state, make_automatic);
   kdtreerequestbuffer_copy(&dst->requestbuffer, &src->requestbuffer, _state, make_automatic);
}

void idwcalcbuffer_free(void *_p, bool make_automatic) {
   idwcalcbuffer *p = (idwcalcbuffer *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->x, make_automatic);
   ae_vector_free(&p->y, make_automatic);
   ae_vector_free(&p->tsyw, make_automatic);
   ae_vector_free(&p->tsw, make_automatic);
   ae_matrix_free(&p->tsxy, make_automatic);
   ae_vector_free(&p->tsdist, make_automatic);
   kdtreerequestbuffer_free(&p->requestbuffer, make_automatic);
}

void idwmodel_init(void *_p, ae_state *_state, bool make_automatic) {
   idwmodel *p = (idwmodel *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->globalprior, 0, DT_REAL, _state, make_automatic);
   kdtree_init(&p->tree, _state, make_automatic);
   ae_vector_init(&p->shepardxy, 0, DT_REAL, _state, make_automatic);
   idwcalcbuffer_init(&p->buffer, _state, make_automatic);
}

void idwmodel_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   idwmodel *dst = (idwmodel *)_dst;
   idwmodel *src = (idwmodel *)_src;
   dst->nx = src->nx;
   dst->ny = src->ny;
   ae_vector_copy(&dst->globalprior, &src->globalprior, _state, make_automatic);
   dst->algotype = src->algotype;
   dst->nlayers = src->nlayers;
   dst->r0 = src->r0;
   dst->rdecay = src->rdecay;
   dst->lambda0 = src->lambda0;
   dst->lambdalast = src->lambdalast;
   dst->lambdadecay = src->lambdadecay;
   dst->shepardp = src->shepardp;
   kdtree_copy(&dst->tree, &src->tree, _state, make_automatic);
   dst->npoints = src->npoints;
   ae_vector_copy(&dst->shepardxy, &src->shepardxy, _state, make_automatic);
   idwcalcbuffer_copy(&dst->buffer, &src->buffer, _state, make_automatic);
}

void idwmodel_free(void *_p, bool make_automatic) {
   idwmodel *p = (idwmodel *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->globalprior, make_automatic);
   kdtree_free(&p->tree, make_automatic);
   ae_vector_free(&p->shepardxy, make_automatic);
   idwcalcbuffer_free(&p->buffer, make_automatic);
}

void idwbuilder_init(void *_p, ae_state *_state, bool make_automatic) {
   idwbuilder *p = (idwbuilder *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->priortermval, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->xy, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->tmpxy, 0, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->tmplayers, 0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tmptags, 0, DT_INT, _state, make_automatic);
   ae_vector_init(&p->tmpdist, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tmpx, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tmpwy, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tmpw, 0, DT_REAL, _state, make_automatic);
   kdtree_init(&p->tmptree, _state, make_automatic);
   ae_vector_init(&p->tmpmean, 0, DT_REAL, _state, make_automatic);
}

void idwbuilder_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   idwbuilder *dst = (idwbuilder *)_dst;
   idwbuilder *src = (idwbuilder *)_src;
   dst->priortermtype = src->priortermtype;
   ae_vector_copy(&dst->priortermval, &src->priortermval, _state, make_automatic);
   dst->algotype = src->algotype;
   dst->nlayers = src->nlayers;
   dst->r0 = src->r0;
   dst->rdecay = src->rdecay;
   dst->lambda0 = src->lambda0;
   dst->lambdalast = src->lambdalast;
   dst->lambdadecay = src->lambdadecay;
   dst->shepardp = src->shepardp;
   ae_vector_copy(&dst->xy, &src->xy, _state, make_automatic);
   dst->npoints = src->npoints;
   dst->nx = src->nx;
   dst->ny = src->ny;
   ae_matrix_copy(&dst->tmpxy, &src->tmpxy, _state, make_automatic);
   ae_matrix_copy(&dst->tmplayers, &src->tmplayers, _state, make_automatic);
   ae_vector_copy(&dst->tmptags, &src->tmptags, _state, make_automatic);
   ae_vector_copy(&dst->tmpdist, &src->tmpdist, _state, make_automatic);
   ae_vector_copy(&dst->tmpx, &src->tmpx, _state, make_automatic);
   ae_vector_copy(&dst->tmpwy, &src->tmpwy, _state, make_automatic);
   ae_vector_copy(&dst->tmpw, &src->tmpw, _state, make_automatic);
   kdtree_copy(&dst->tmptree, &src->tmptree, _state, make_automatic);
   ae_vector_copy(&dst->tmpmean, &src->tmpmean, _state, make_automatic);
}

void idwbuilder_free(void *_p, bool make_automatic) {
   idwbuilder *p = (idwbuilder *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->priortermval, make_automatic);
   ae_vector_free(&p->xy, make_automatic);
   ae_matrix_free(&p->tmpxy, make_automatic);
   ae_matrix_free(&p->tmplayers, make_automatic);
   ae_vector_free(&p->tmptags, make_automatic);
   ae_vector_free(&p->tmpdist, make_automatic);
   ae_vector_free(&p->tmpx, make_automatic);
   ae_vector_free(&p->tmpwy, make_automatic);
   ae_vector_free(&p->tmpw, make_automatic);
   kdtree_free(&p->tmptree, make_automatic);
   ae_vector_free(&p->tmpmean, make_automatic);
}

void idwreport_init(void *_p, ae_state *_state, bool make_automatic) {
   idwreport *p = (idwreport *)_p;
   ae_touch_ptr((void *)p);
}

void idwreport_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   idwreport *dst = (idwreport *)_dst;
   idwreport *src = (idwreport *)_src;
   dst->rmserror = src->rmserror;
   dst->avgerror = src->avgerror;
   dst->maxerror = src->maxerror;
   dst->r2 = src->r2;
}

void idwreport_free(void *_p, bool make_automatic) {
   idwreport *p = (idwreport *)_p;
   ae_touch_ptr((void *)p);
}
} // end of namespace alglib_impl

namespace alglib {
// Buffer  object  which  is  used  to  perform  evaluation  requests  in  the
// multithreaded mode (multiple threads working with same IDW object).
//
// This object should be created with idwcreatecalcbuffer().
DefClass(idwcalcbuffer, )

// IDW (Inverse Distance Weighting) model object.
DefClass(idwmodel, )

// Builder object used to generate IDW (Inverse Distance Weighting) model.
DefClass(idwbuilder, )

// IDW fitting report:
//     rmserror        RMS error
//     avgerror        average error
//     maxerror        maximum error
//     r2              coefficient of determination,  R-squared, 1-RSS/TSS
DefClass(idwreport, DecVal(rmserror) DecVal(avgerror) DecVal(maxerror) DecVal(r2))

void idwserialize(idwmodel &obj, std::string &s_out) {
   alglib_impl::ae_int_t ssize;
   alglib_impl::ae_state state; alglib_impl::ae_state_init(&state);
   TryCatch(state, )
   NewSerializer(serializer);
   alglib_impl::ae_serializer_alloc_start(&serializer);
   alglib_impl::idwalloc(&serializer, obj.c_ptr(), &state);
   ssize = alglib_impl::ae_serializer_get_alloc_size(&serializer);
   s_out.clear();
   s_out.reserve((size_t)(ssize + 1));
   alglib_impl::ae_serializer_sstart_str(&serializer, &s_out);
   alglib_impl::idwserialize(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_stop(&serializer, &state);
   alglib_impl::ae_assert(s_out.length() <= (size_t)ssize, "ALGLIB: serialization integrity error", &state);
   alglib_impl::ae_state_clear(&state);
}
void idwserialize(idwmodel &obj, std::ostream &s_out) {
   alglib_impl::ae_state state; alglib_impl::ae_state_init(&state);
   TryCatch(state, )
   NewSerializer(serializer);
   alglib_impl::ae_serializer_alloc_start(&serializer);
   alglib_impl::idwalloc(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_get_alloc_size(&serializer); // not actually needed, but we have to ask
   alglib_impl::ae_serializer_sstart_stream(&serializer, &s_out);
   alglib_impl::idwserialize(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_stop(&serializer, &state);
   alglib_impl::ae_state_clear(&state);
}

void idwunserialize(const std::string &s_in, idwmodel &obj) {
   alglib_impl::ae_state state; alglib_impl::ae_state_init(&state);
   TryCatch(state, )
   NewSerializer(serializer);
   alglib_impl::ae_serializer_ustart_str(&serializer, &s_in);
   alglib_impl::idwunserialize(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_stop(&serializer, &state);
   alglib_impl::ae_state_clear(&state);
}
void idwunserialize(const std::istream &s_in, idwmodel &obj) {
   alglib_impl::ae_state state; alglib_impl::ae_state_init(&state);
   TryCatch(state, )
   NewSerializer(serializer);
   alglib_impl::ae_serializer_ustart_stream(&serializer, &s_in);
   alglib_impl::idwunserialize(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_stop(&serializer, &state);
   alglib_impl::ae_state_clear(&state);
}

void idwcreatecalcbuffer(const idwmodel &s, idwcalcbuffer &buf, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwcreatecalcbuffer(ConstT(idwmodel, s), ConstT(idwcalcbuffer, buf), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void idwbuildercreate(const ae_int_t nx, const ae_int_t ny, idwbuilder &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwbuildercreate(nx, ny, ConstT(idwbuilder, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void idwbuildersetnlayers(const idwbuilder &state, const ae_int_t nlayers, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwbuildersetnlayers(ConstT(idwbuilder, state), nlayers, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void idwbuildersetpoints(const idwbuilder &state, const real_2d_array &xy, const ae_int_t n, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwbuildersetpoints(ConstT(idwbuilder, state), ConstT(ae_matrix, xy), n, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void idwbuildersetpoints(const idwbuilder &state, const real_2d_array &xy, const xparams _xparams) {
   ae_int_t n = xy.rows();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwbuildersetpoints(ConstT(idwbuilder, state), ConstT(ae_matrix, xy), n, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void idwbuildersetalgomstab(const idwbuilder &state, const double srad, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwbuildersetalgomstab(ConstT(idwbuilder, state), srad, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void idwbuildersetalgotextbookshepard(const idwbuilder &state, const double p, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwbuildersetalgotextbookshepard(ConstT(idwbuilder, state), p, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void idwbuildersetalgotextbookmodshepard(const idwbuilder &state, const double r, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwbuildersetalgotextbookmodshepard(ConstT(idwbuilder, state), r, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void idwbuildersetuserterm(const idwbuilder &state, const double v, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwbuildersetuserterm(ConstT(idwbuilder, state), v, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void idwbuildersetconstterm(const idwbuilder &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwbuildersetconstterm(ConstT(idwbuilder, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void idwbuildersetzeroterm(const idwbuilder &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwbuildersetzeroterm(ConstT(idwbuilder, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void idwtscalcbuf(const idwmodel &s, const idwcalcbuffer &buf, const real_1d_array &x, real_1d_array &y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwtscalcbuf(ConstT(idwmodel, s), ConstT(idwcalcbuffer, buf), ConstT(ae_vector, x), ConstT(ae_vector, y), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void idwcalc(const idwmodel &s, const real_1d_array &x, real_1d_array &y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwcalc(ConstT(idwmodel, s), ConstT(ae_vector, x), ConstT(ae_vector, y), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void idwcalcbuf(const idwmodel &s, const real_1d_array &x, real_1d_array &y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwcalcbuf(ConstT(idwmodel, s), ConstT(ae_vector, x), ConstT(ae_vector, y), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

double idwcalc1(const idwmodel &s, const double x0, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::idwcalc1(ConstT(idwmodel, s), x0, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

double idwcalc2(const idwmodel &s, const double x0, const double x1, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::idwcalc2(ConstT(idwmodel, s), x0, x1, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

double idwcalc3(const idwmodel &s, const double x0, const double x1, const double x2, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::idwcalc3(ConstT(idwmodel, s), x0, x1, x2, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

void idwfit(const idwbuilder &state, idwmodel &model, idwreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::idwfit(ConstT(idwbuilder, state), ConstT(idwmodel, model), ConstT(idwreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
} // end of namespace alglib

// === INTFITSERV Package ===
// Depends on: (LinAlg) TRFAC
namespace alglib_impl {
// Internal subroutine: automatic scaling for LLS tasks.
// NEVER CALL IT DIRECTLY!
//
// Maps abscissas to [-1,1], standartizes ordinates and correspondingly scales
// constraints. It also scales weights so that max(W[i])=1
//
// Transformations performed:
// * X, XC         [XA,XB] => [-1,+1]
//                 transformation makes min(X)=-1, max(X)=+1
//
// * Y             [SA,SB] => [0,1]
//                 transformation makes mean(Y)=0, stddev(Y)=1
//
// * YC            transformed accordingly to SA, SB, DC[I]
// ALGLIB Project: Copyright 08.09.2009 by Sergey Bochkanov
void lsfitscalexy(RVector *x, RVector *y, RVector *w, ae_int_t n, RVector *xc, RVector *yc, ZVector *dc, ae_int_t k, double *xa, double *xb, double *sa, double *sb, RVector *xoriginal, RVector *yoriginal, ae_state *_state) {
   double xmin;
   double xmax;
   ae_int_t i;
   double mx;
   *xa = 0;
   *xb = 0;
   *sa = 0;
   *sb = 0;
   SetVector(xoriginal);
   SetVector(yoriginal);
   ae_assert(n >= 1, "LSFitScaleXY: incorrect N", _state);
   ae_assert(k >= 0, "LSFitScaleXY: incorrect K", _state);
   xmin = x->xR[0];
   xmax = x->xR[0];
   for (i = 1; i < n; i++) {
      xmin = minreal(xmin, x->xR[i], _state);
      xmax = maxreal(xmax, x->xR[i], _state);
   }
   for (i = 0; i < k; i++) {
      xmin = minreal(xmin, xc->xR[i], _state);
      xmax = maxreal(xmax, xc->xR[i], _state);
   }
   if (xmin == xmax) {
      if (xmin == 0.0) {
         xmin = -1.0;
         xmax = 1.0;
      } else {
         if (xmin > 0.0) {
            xmin *= 0.5;
         } else {
            xmax *= 0.5;
         }
      }
   }
   ae_vector_set_length(xoriginal, n, _state);
   ae_v_move(xoriginal->xR, 1, x->xR, 1, n);
   *xa = xmin;
   *xb = xmax;
   for (i = 0; i < n; i++) {
      x->xR[i] = 2 * (x->xR[i] - 0.5 * (*xa + (*xb))) / (*xb - (*xa));
   }
   for (i = 0; i < k; i++) {
      ae_assert(dc->xZ[i] >= 0, "LSFitScaleXY: internal error!", _state);
      xc->xR[i] = 2 * (xc->xR[i] - 0.5 * (*xa + (*xb))) / (*xb - (*xa));
      yc->xR[i] *= ae_pow(0.5 * (*xb - (*xa)), (double)dc->xZ[i], _state);
   }
   ae_vector_set_length(yoriginal, n, _state);
   ae_v_move(yoriginal->xR, 1, y->xR, 1, n);
   *sa = 0.0;
   for (i = 0; i < n; i++) {
      *sa += y->xR[i];
   }
   *sa /= n;
   *sb = 0.0;
   for (i = 0; i < n; i++) {
      *sb += sqr(y->xR[i] - (*sa), _state);
   }
   *sb = ae_sqrt(*sb / n, _state) + (*sa);
   if (*sb == *sa) {
      *sb = 2 * (*sa);
   }
   if (*sb == *sa) {
      *sb = *sa + 1;
   }
   for (i = 0; i < n; i++) {
      y->xR[i] = (y->xR[i] - (*sa)) / (*sb - (*sa));
   }
   for (i = 0; i < k; i++) {
      if (dc->xZ[i] == 0) {
         yc->xR[i] = (yc->xR[i] - (*sa)) / (*sb - (*sa));
      } else {
         yc->xR[i] /= *sb - (*sa);
      }
   }
   mx = 0.0;
   for (i = 0; i < n; i++) {
      mx = maxreal(mx, ae_fabs(w->xR[i], _state), _state);
   }
   if (mx != 0.0) {
      for (i = 0; i < n; i++) {
         w->xR[i] /= mx;
      }
   }
}

void buildpriorterm(RMatrix *xy, ae_int_t n, ae_int_t nx, ae_int_t ny, ae_int_t modeltype, double priorval, RMatrix *v, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t j0;
   ae_int_t j1;
   double rj;
   double lambdareg;
   ae_int_t rfsits;
   ae_frame_make(_state, &_frame_block);
   SetMatrix(v);
   NewMatrix(araw, 0, 0, DT_REAL, _state);
   NewMatrix(amod, 0, 0, DT_REAL, _state);
   NewMatrix(braw, 0, 0, DT_REAL, _state);
   NewVector(tmp0, 0, DT_REAL, _state);
   ae_assert(n >= 0, "BuildPriorTerm: N<0", _state);
   ae_assert(nx > 0, "BuildPriorTerm: NX <= 0", _state);
   ae_assert(ny > 0, "BuildPriorTerm: NY <= 0", _state);
   ae_matrix_set_length(v, ny, nx + 1, _state);
   for (i = 0; i < v->rows; i++) {
      for (j = 0; j < v->cols; j++) {
         v->xyR[i][j] = 0.0;
      }
   }
   if (n == 0) {
      if (modeltype == 0) {
         for (i = 0; i < ny; i++) {
            v->xyR[i][nx] = priorval;
         }
         ae_frame_leave(_state);
         return;
      }
      if (modeltype == 1) {
         ae_frame_leave(_state);
         return;
      }
      if (modeltype == 2) {
         ae_frame_leave(_state);
         return;
      }
      if (modeltype == 3) {
         ae_frame_leave(_state);
         return;
      }
      ae_assert(false, "BuildPriorTerm: unexpected model type", _state);
   }
   if (modeltype == 0) {
      for (i = 0; i < ny; i++) {
         v->xyR[i][nx] = priorval;
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < ny; j++) {
            xy->xyR[i][nx + j] -= priorval;
         }
      }
      ae_frame_leave(_state);
      return;
   }
   if (modeltype == 2) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < ny; j++) {
            v->xyR[j][nx] += xy->xyR[i][nx + j];
         }
      }
      for (j = 0; j < ny; j++) {
         v->xyR[j][nx] /= coalesce((double)n, 1.0, _state);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < ny; j++) {
            xy->xyR[i][nx + j] -= v->xyR[j][nx];
         }
      }
      ae_frame_leave(_state);
      return;
   }
   if (modeltype == 3) {
      ae_frame_leave(_state);
      return;
   }
   ae_assert(modeltype == 1, "BuildPriorTerm: unexpected model type", _state);
   lambdareg = 0.0;
   ae_matrix_set_length(&araw, nx + 1, nx + 1, _state);
   ae_matrix_set_length(&braw, nx + 1, ny, _state);
   ae_vector_set_length(&tmp0, nx + 1, _state);
   ae_matrix_set_length(&amod, nx + 1, nx + 1, _state);
   for (i = 0; i <= nx; i++) {
      for (j = 0; j <= nx; j++) {
         araw.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < nx; j++) {
         tmp0.xR[j] = xy->xyR[i][j];
      }
      tmp0.xR[nx] = 1.0;
      for (j0 = 0; j0 <= nx; j0++) {
         for (j1 = 0; j1 <= nx; j1++) {
            araw.xyR[j0][j1] += tmp0.xR[j0] * tmp0.xR[j1];
         }
      }
   }
   for (rfsits = 1; rfsits <= 3; rfsits++) {
      for (i = 0; i <= nx; i++) {
         for (j = 0; j < ny; j++) {
            braw.xyR[i][j] = 0.0;
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < nx; j++) {
            tmp0.xR[j] = xy->xyR[i][j];
         }
         tmp0.xR[nx] = 1.0;
         for (j = 0; j < ny; j++) {
            rj = xy->xyR[i][nx + j];
            for (j0 = 0; j0 <= nx; j0++) {
               rj -= tmp0.xR[j0] * v->xyR[j][j0];
            }
            for (j0 = 0; j0 <= nx; j0++) {
               braw.xyR[j0][j] += rj * tmp0.xR[j0];
            }
         }
      }
      while (true) {
         for (i = 0; i <= nx; i++) {
            for (j = 0; j <= nx; j++) {
               amod.xyR[i][j] = araw.xyR[i][j];
            }
            amod.xyR[i][i] += lambdareg * coalesce(amod.xyR[i][i], 1.0, _state);
         }
         if (spdmatrixcholesky(&amod, nx + 1, true, _state)) {
            break;
         }
         lambdareg = coalesce(10 * lambdareg, 1.0E-12, _state);
      }
      rmatrixlefttrsm(nx + 1, ny, &amod, 0, 0, true, false, 1, &braw, 0, 0, _state);
      rmatrixlefttrsm(nx + 1, ny, &amod, 0, 0, true, false, 0, &braw, 0, 0, _state);
      for (i = 0; i <= nx; i++) {
         for (j = 0; j < ny; j++) {
            v->xyR[j][i] += braw.xyR[i][j];
         }
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < nx; j++) {
         tmp0.xR[j] = xy->xyR[i][j];
      }
      tmp0.xR[nx] = 1.0;
      for (j = 0; j < ny; j++) {
         rj = 0.0;
         for (j0 = 0; j0 <= nx; j0++) {
            rj += tmp0.xR[j0] * v->xyR[j][j0];
         }
         xy->xyR[i][nx + j] -= rj;
      }
   }
   ae_frame_leave(_state);
}

void buildpriorterm1(RVector *xy1, ae_int_t n, ae_int_t nx, ae_int_t ny, ae_int_t modeltype, double priorval, RMatrix *v, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t j0;
   ae_int_t j1;
   ae_int_t ew;
   double rj;
   double lambdareg;
   ae_int_t rfsits;
   ae_frame_make(_state, &_frame_block);
   SetMatrix(v);
   NewMatrix(araw, 0, 0, DT_REAL, _state);
   NewMatrix(amod, 0, 0, DT_REAL, _state);
   NewMatrix(braw, 0, 0, DT_REAL, _state);
   NewVector(tmp0, 0, DT_REAL, _state);
   ae_assert(n >= 0, "BuildPriorTerm: N<0", _state);
   ae_assert(nx > 0, "BuildPriorTerm: NX <= 0", _state);
   ae_assert(ny > 0, "BuildPriorTerm: NY <= 0", _state);
   ew = nx + ny;
   ae_matrix_set_length(v, ny, nx + 1, _state);
   for (i = 0; i < v->rows; i++) {
      for (j = 0; j < v->cols; j++) {
         v->xyR[i][j] = 0.0;
      }
   }
   if (n == 0) {
      if (modeltype == 0) {
         for (i = 0; i < ny; i++) {
            v->xyR[i][nx] = priorval;
         }
         ae_frame_leave(_state);
         return;
      }
      if (modeltype == 1) {
         ae_frame_leave(_state);
         return;
      }
      if (modeltype == 2) {
         ae_frame_leave(_state);
         return;
      }
      if (modeltype == 3) {
         ae_frame_leave(_state);
         return;
      }
      ae_assert(false, "BuildPriorTerm: unexpected model type", _state);
   }
   if (modeltype == 0) {
      for (i = 0; i < ny; i++) {
         v->xyR[i][nx] = priorval;
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < ny; j++) {
            xy1->xR[i * ew + nx + j] -= priorval;
         }
      }
      ae_frame_leave(_state);
      return;
   }
   if (modeltype == 2) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < ny; j++) {
            v->xyR[j][nx] += xy1->xR[i * ew + nx + j];
         }
      }
      for (j = 0; j < ny; j++) {
         v->xyR[j][nx] /= coalesce((double)n, 1.0, _state);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < ny; j++) {
            xy1->xR[i * ew + nx + j] -= v->xyR[j][nx];
         }
      }
      ae_frame_leave(_state);
      return;
   }
   if (modeltype == 3) {
      ae_frame_leave(_state);
      return;
   }
   ae_assert(modeltype == 1, "BuildPriorTerm: unexpected model type", _state);
   lambdareg = 0.0;
   ae_matrix_set_length(&araw, nx + 1, nx + 1, _state);
   ae_matrix_set_length(&braw, nx + 1, ny, _state);
   ae_vector_set_length(&tmp0, nx + 1, _state);
   ae_matrix_set_length(&amod, nx + 1, nx + 1, _state);
   for (i = 0; i <= nx; i++) {
      for (j = 0; j <= nx; j++) {
         araw.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < nx; j++) {
         tmp0.xR[j] = xy1->xR[i * ew + j];
      }
      tmp0.xR[nx] = 1.0;
      for (j0 = 0; j0 <= nx; j0++) {
         for (j1 = 0; j1 <= nx; j1++) {
            araw.xyR[j0][j1] += tmp0.xR[j0] * tmp0.xR[j1];
         }
      }
   }
   for (rfsits = 1; rfsits <= 3; rfsits++) {
      for (i = 0; i <= nx; i++) {
         for (j = 0; j < ny; j++) {
            braw.xyR[i][j] = 0.0;
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < nx; j++) {
            tmp0.xR[j] = xy1->xR[i * ew + j];
         }
         tmp0.xR[nx] = 1.0;
         for (j = 0; j < ny; j++) {
            rj = xy1->xR[i * ew + nx + j];
            for (j0 = 0; j0 <= nx; j0++) {
               rj -= tmp0.xR[j0] * v->xyR[j][j0];
            }
            for (j0 = 0; j0 <= nx; j0++) {
               braw.xyR[j0][j] += rj * tmp0.xR[j0];
            }
         }
      }
      while (true) {
         for (i = 0; i <= nx; i++) {
            for (j = 0; j <= nx; j++) {
               amod.xyR[i][j] = araw.xyR[i][j];
            }
            amod.xyR[i][i] += lambdareg * coalesce(amod.xyR[i][i], 1.0, _state);
         }
         if (spdmatrixcholesky(&amod, nx + 1, true, _state)) {
            break;
         }
         lambdareg = coalesce(10 * lambdareg, 1.0E-12, _state);
      }
      rmatrixlefttrsm(nx + 1, ny, &amod, 0, 0, true, false, 1, &braw, 0, 0, _state);
      rmatrixlefttrsm(nx + 1, ny, &amod, 0, 0, true, false, 0, &braw, 0, 0, _state);
      for (i = 0; i <= nx; i++) {
         for (j = 0; j < ny; j++) {
            v->xyR[j][i] += braw.xyR[i][j];
         }
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < nx; j++) {
         tmp0.xR[j] = xy1->xR[i * ew + j];
      }
      tmp0.xR[nx] = 1.0;
      for (j = 0; j < ny; j++) {
         rj = 0.0;
         for (j0 = 0; j0 <= nx; j0++) {
            rj += tmp0.xR[j0] * v->xyR[j][j0];
         }
         xy1->xR[i * ew + nx + j] -= rj;
      }
   }
   ae_frame_leave(_state);
}
} // end of namespace alglib_impl

// === POLINT Package ===
// Depends on: RATINT
namespace alglib_impl {
// Lagrange intepolant: generation of the model on the general grid.
// This function has O(N^2) complexity.
//
// Inputs:
//     X   -   abscissas, array[0..N-1]
//     Y   -   function values, array[0..N-1]
//     N   -   number of points, N >= 1
//
// Outputs:
//     P   -   barycentric model which represents Lagrange interpolant
//             (see ratint unit info and BarycentricCalc() description for
//             more information).
// ALGLIB: Copyright 02.12.2009 by Sergey Bochkanov
// API: void polynomialbuild(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, barycentricinterpolant &p, const xparams _xparams = xdefault);
// API: void polynomialbuild(const real_1d_array &x, const real_1d_array &y, barycentricinterpolant &p, const xparams _xparams = xdefault);
void polynomialbuild(RVector *x, RVector *y, ae_int_t n, barycentricinterpolant *p, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t j;
   ae_int_t k;
   double b;
   double a;
   double v;
   double mx;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   SetObj(barycentricinterpolant, p);
   NewVector(w, 0, DT_REAL, _state);
   NewVector(sortrbuf, 0, DT_REAL, _state);
   NewVector(sortrbuf2, 0, DT_REAL, _state);
   ae_assert(n > 0, "PolynomialBuild: N <= 0!", _state);
   ae_assert(x->cnt >= n, "PolynomialBuild: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "PolynomialBuild: Length(Y)<N!", _state);
   ae_assert(isfinitevector(x, n, _state), "PolynomialBuild: X contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "PolynomialBuild: Y contains infinite or NaN values!", _state);
   tagsortfastr(x, y, &sortrbuf, &sortrbuf2, n, _state);
   ae_assert(aredistinct(x, n, _state), "PolynomialBuild: at least two consequent points are too close!", _state);
// calculate W[j]
// multi-pass algorithm is used to avoid overflow
   ae_vector_set_length(&w, n, _state);
   a = x->xR[0];
   b = x->xR[0];
   for (j = 0; j < n; j++) {
      w.xR[j] = 1.0;
      a = minreal(a, x->xR[j], _state);
      b = maxreal(b, x->xR[j], _state);
   }
   for (k = 0; k < n; k++) {
   // W[K] is used instead of 0.0 because
   // cycle on J does not touch K-th element
   // and we MUST get maximum from ALL elements
      mx = ae_fabs(w.xR[k], _state);
      for (j = 0; j < n; j++) {
         if (j != k) {
            v = (b - a) / (x->xR[j] - x->xR[k]);
            w.xR[j] *= v;
            mx = maxreal(mx, ae_fabs(w.xR[j], _state), _state);
         }
      }
      if (k % 5 == 0) {
      // every 5-th run we renormalize W[]
         v = 1 / mx;
         ae_v_muld(w.xR, 1, n, v);
      }
   }
   barycentricbuildxyw(x, y, &w, n, p, _state);
   ae_frame_leave(_state);
}

// Lagrange intepolant: generation of the model on equidistant grid.
// This function has O(N) complexity.
//
// Inputs:
//     A   -   left boundary of [A,B]
//     B   -   right boundary of [A,B]
//     Y   -   function values at the nodes, array[0..N-1]
//     N   -   number of points, N >= 1
//             for N=1 a constant model is constructed.
//
// Outputs:
//     P   -   barycentric model which represents Lagrange interpolant
//             (see ratint unit info and BarycentricCalc() description for
//             more information).
// ALGLIB: Copyright 03.12.2009 by Sergey Bochkanov
// API: void polynomialbuildeqdist(const double a, const double b, const real_1d_array &y, const ae_int_t n, barycentricinterpolant &p, const xparams _xparams = xdefault);
// API: void polynomialbuildeqdist(const double a, const double b, const real_1d_array &y, barycentricinterpolant &p, const xparams _xparams = xdefault);
void polynomialbuildeqdist(double a, double b, RVector *y, ae_int_t n, barycentricinterpolant *p, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   double v;
   ae_frame_make(_state, &_frame_block);
   SetObj(barycentricinterpolant, p);
   NewVector(w, 0, DT_REAL, _state);
   NewVector(x, 0, DT_REAL, _state);
   ae_assert(n > 0, "PolynomialBuildEqDist: N <= 0!", _state);
   ae_assert(y->cnt >= n, "PolynomialBuildEqDist: Length(Y)<N!", _state);
   ae_assert(ae_isfinite(a, _state), "PolynomialBuildEqDist: A is infinite or NaN!", _state);
   ae_assert(ae_isfinite(b, _state), "PolynomialBuildEqDist: B is infinite or NaN!", _state);
   ae_assert(isfinitevector(y, n, _state), "PolynomialBuildEqDist: Y contains infinite or NaN values!", _state);
   ae_assert(b != a, "PolynomialBuildEqDist: B=A!", _state);
   ae_assert(a + (b - a) / n != a, "PolynomialBuildEqDist: B is too close to A!", _state);
// Special case: N=1
   if (n == 1) {
      ae_vector_set_length(&x, 1, _state);
      ae_vector_set_length(&w, 1, _state);
      x.xR[0] = 0.5 * (b + a);
      w.xR[0] = 1.0;
      barycentricbuildxyw(&x, y, &w, 1, p, _state);
      ae_frame_leave(_state);
      return;
   }
// general case
   ae_vector_set_length(&x, n, _state);
   ae_vector_set_length(&w, n, _state);
   v = 1.0;
   for (i = 0; i < n; i++) {
      w.xR[i] = v;
      x.xR[i] = a + (b - a) * i / (n - 1);
      v *= -(n - 1 - i);
      v /= i + 1;
   }
   barycentricbuildxyw(&x, y, &w, n, p, _state);
   ae_frame_leave(_state);
}

// Lagrange intepolant on Chebyshev grid (first kind).
// This function has O(N) complexity.
//
// Inputs:
//     A   -   left boundary of [A,B]
//     B   -   right boundary of [A,B]
//     Y   -   function values at the nodes, array[0..N-1],
//             Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n)))
//     N   -   number of points, N >= 1
//             for N=1 a constant model is constructed.
//
// Outputs:
//     P   -   barycentric model which represents Lagrange interpolant
//             (see ratint unit info and BarycentricCalc() description for
//             more information).
// ALGLIB: Copyright 03.12.2009 by Sergey Bochkanov
// API: void polynomialbuildcheb1(const double a, const double b, const real_1d_array &y, const ae_int_t n, barycentricinterpolant &p, const xparams _xparams = xdefault);
// API: void polynomialbuildcheb1(const double a, const double b, const real_1d_array &y, barycentricinterpolant &p, const xparams _xparams = xdefault);
void polynomialbuildcheb1(double a, double b, RVector *y, ae_int_t n, barycentricinterpolant *p, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   double v;
   double t;
   ae_frame_make(_state, &_frame_block);
   SetObj(barycentricinterpolant, p);
   NewVector(w, 0, DT_REAL, _state);
   NewVector(x, 0, DT_REAL, _state);
   ae_assert(n > 0, "PolynomialBuildCheb1: N <= 0!", _state);
   ae_assert(y->cnt >= n, "PolynomialBuildCheb1: Length(Y)<N!", _state);
   ae_assert(ae_isfinite(a, _state), "PolynomialBuildCheb1: A is infinite or NaN!", _state);
   ae_assert(ae_isfinite(b, _state), "PolynomialBuildCheb1: B is infinite or NaN!", _state);
   ae_assert(isfinitevector(y, n, _state), "PolynomialBuildCheb1: Y contains infinite or NaN values!", _state);
   ae_assert(b != a, "PolynomialBuildCheb1: B=A!", _state);
// Special case: N=1
   if (n == 1) {
      ae_vector_set_length(&x, 1, _state);
      ae_vector_set_length(&w, 1, _state);
      x.xR[0] = 0.5 * (b + a);
      w.xR[0] = 1.0;
      barycentricbuildxyw(&x, y, &w, 1, p, _state);
      ae_frame_leave(_state);
      return;
   }
// general case
   ae_vector_set_length(&x, n, _state);
   ae_vector_set_length(&w, n, _state);
   v = 1.0;
   for (i = 0; i < n; i++) {
      t = ae_tan(0.5 * pi * (2 * i + 1) / (2 * n), _state);
      w.xR[i] = 2 * v * t / (1 + sqr(t, _state));
      x.xR[i] = 0.5 * (b + a) + 0.5 * (b - a) * (1 - sqr(t, _state)) / (1 + sqr(t, _state));
      v = -v;
   }
   barycentricbuildxyw(&x, y, &w, n, p, _state);
   ae_frame_leave(_state);
}

// Lagrange intepolant on Chebyshev grid (second kind).
// This function has O(N) complexity.
//
// Inputs:
//     A   -   left boundary of [A,B]
//     B   -   right boundary of [A,B]
//     Y   -   function values at the nodes, array[0..N-1],
//             Y[I] = Y(0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1)))
//     N   -   number of points, N >= 1
//             for N=1 a constant model is constructed.
//
// Outputs:
//     P   -   barycentric model which represents Lagrange interpolant
//             (see ratint unit info and BarycentricCalc() description for
//             more information).
// ALGLIB: Copyright 03.12.2009 by Sergey Bochkanov
// API: void polynomialbuildcheb2(const double a, const double b, const real_1d_array &y, const ae_int_t n, barycentricinterpolant &p, const xparams _xparams = xdefault);
// API: void polynomialbuildcheb2(const double a, const double b, const real_1d_array &y, barycentricinterpolant &p, const xparams _xparams = xdefault);
void polynomialbuildcheb2(double a, double b, RVector *y, ae_int_t n, barycentricinterpolant *p, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   double v;
   ae_frame_make(_state, &_frame_block);
   SetObj(barycentricinterpolant, p);
   NewVector(w, 0, DT_REAL, _state);
   NewVector(x, 0, DT_REAL, _state);
   ae_assert(n > 0, "PolynomialBuildCheb2: N <= 0!", _state);
   ae_assert(y->cnt >= n, "PolynomialBuildCheb2: Length(Y)<N!", _state);
   ae_assert(ae_isfinite(a, _state), "PolynomialBuildCheb2: A is infinite or NaN!", _state);
   ae_assert(ae_isfinite(b, _state), "PolynomialBuildCheb2: B is infinite or NaN!", _state);
   ae_assert(b != a, "PolynomialBuildCheb2: B=A!", _state);
   ae_assert(isfinitevector(y, n, _state), "PolynomialBuildCheb2: Y contains infinite or NaN values!", _state);
// Special case: N=1
   if (n == 1) {
      ae_vector_set_length(&x, 1, _state);
      ae_vector_set_length(&w, 1, _state);
      x.xR[0] = 0.5 * (b + a);
      w.xR[0] = 1.0;
      barycentricbuildxyw(&x, y, &w, 1, p, _state);
      ae_frame_leave(_state);
      return;
   }
// general case
   ae_vector_set_length(&x, n, _state);
   ae_vector_set_length(&w, n, _state);
   v = 1.0;
   for (i = 0; i < n; i++) {
      if (i == 0 || i == n - 1) {
         w.xR[i] = v * 0.5;
      } else {
         w.xR[i] = v;
      }
      x.xR[i] = 0.5 * (b + a) + 0.5 * (b - a) * ae_cos(pi * i / (n - 1), _state);
      v = -v;
   }
   barycentricbuildxyw(&x, y, &w, n, p, _state);
   ae_frame_leave(_state);
}

// Conversion from barycentric representation to Chebyshev basis.
// This function has O(N^2) complexity.
//
// Inputs:
//     P   -   polynomial in barycentric form
//     A,B -   base interval for Chebyshev polynomials (see below)
//             A != B
//
// Outputs:
//     T   -   coefficients of Chebyshev representation;
//             P(x) = sum { T[i]*Ti(2*(x-A)/(B-A)-1), i=0..N-1 },
//             where Ti - I-th Chebyshev polynomial.
//
// NOTES:
//     barycentric interpolant passed as P may be either polynomial  obtained
//     from  polynomial  interpolation/ fitting or rational function which is
//     NOT polynomial. We can't distinguish between these two cases, and this
//     algorithm just tries to work assuming that P IS a polynomial.  If not,
//     algorithm will return results, but they won't have any meaning.
// ALGLIB: Copyright 30.09.2010 by Sergey Bochkanov
// API: void polynomialbar2cheb(const barycentricinterpolant &p, const double a, const double b, real_1d_array &t, const xparams _xparams = xdefault);
void polynomialbar2cheb(barycentricinterpolant *p, double a, double b, RVector *t, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t k;
   double v;
   ae_frame_make(_state, &_frame_block);
   SetVector(t);
   NewVector(vp, 0, DT_REAL, _state);
   NewVector(vx, 0, DT_REAL, _state);
   NewVector(tk, 0, DT_REAL, _state);
   NewVector(tk1, 0, DT_REAL, _state);
   ae_assert(ae_isfinite(a, _state), "PolynomialBar2Cheb: A is not finite!", _state);
   ae_assert(ae_isfinite(b, _state), "PolynomialBar2Cheb: B is not finite!", _state);
   ae_assert(a != b, "PolynomialBar2Cheb: A=B!", _state);
   ae_assert(p->n > 0, "PolynomialBar2Cheb: P is not correctly initialized barycentric interpolant!", _state);
// Calculate function values on a Chebyshev grid
   ae_vector_set_length(&vp, p->n, _state);
   ae_vector_set_length(&vx, p->n, _state);
   for (i = 0; i < p->n; i++) {
      vx.xR[i] = ae_cos(pi * (i + 0.5) / p->n, _state);
      vp.xR[i] = barycentriccalc(p, 0.5 * (vx.xR[i] + 1) * (b - a) + a, _state);
   }
// T[0]
   ae_vector_set_length(t, p->n, _state);
   v = 0.0;
   for (i = 0; i < p->n; i++) {
      v += vp.xR[i];
   }
   t->xR[0] = v / p->n;
// other T's.
//
// NOTES:
// 1. TK stores T{k} on VX, TK1 stores T{k-1} on VX
// 2. we can do same calculations with fast DCT, but it
//    * adds dependencies
//    * still leaves us with O(N^2) algorithm because
//      preparation of function values is O(N^2) process
   if (p->n > 1) {
      ae_vector_set_length(&tk, p->n, _state);
      ae_vector_set_length(&tk1, p->n, _state);
      for (i = 0; i < p->n; i++) {
         tk.xR[i] = vx.xR[i];
         tk1.xR[i] = 1.0;
      }
      for (k = 1; k < p->n; k++) {
      // calculate discrete product of function vector and TK
         v = ae_v_dotproduct(tk.xR, 1, vp.xR, 1, p->n);
         t->xR[k] = v / (0.5 * p->n);
      // Update TK and TK1
         for (i = 0; i < p->n; i++) {
            v = 2 * vx.xR[i] * tk.xR[i] - tk1.xR[i];
            tk1.xR[i] = tk.xR[i];
            tk.xR[i] = v;
         }
      }
   }
   ae_frame_leave(_state);
}

// Conversion from Chebyshev basis to barycentric representation.
// This function has O(N^2) complexity.
//
// Inputs:
//     T   -   coefficients of Chebyshev representation;
//             P(x) = sum { T[i]*Ti(2*(x-A)/(B-A)-1), i=0..N },
//             where Ti - I-th Chebyshev polynomial.
//     N   -   number of coefficients:
//             * if given, only leading N elements of T are used
//             * if not given, automatically determined from size of T
//     A,B -   base interval for Chebyshev polynomials (see above)
//             A<B
//
// Outputs:
//     P   -   polynomial in barycentric form
// ALGLIB: Copyright 30.09.2010 by Sergey Bochkanov
// API: void polynomialcheb2bar(const real_1d_array &t, const ae_int_t n, const double a, const double b, barycentricinterpolant &p, const xparams _xparams = xdefault);
// API: void polynomialcheb2bar(const real_1d_array &t, const double a, const double b, barycentricinterpolant &p, const xparams _xparams = xdefault);
void polynomialcheb2bar(RVector *t, ae_int_t n, double a, double b, barycentricinterpolant *p, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t k;
   double tk;
   double tk1;
   double vx;
   double vy;
   double v;
   ae_frame_make(_state, &_frame_block);
   SetObj(barycentricinterpolant, p);
   NewVector(y, 0, DT_REAL, _state);
   ae_assert(ae_isfinite(a, _state), "PolynomialBar2Cheb: A is not finite!", _state);
   ae_assert(ae_isfinite(b, _state), "PolynomialBar2Cheb: B is not finite!", _state);
   ae_assert(a != b, "PolynomialBar2Cheb: A=B!", _state);
   ae_assert(n >= 1, "PolynomialBar2Cheb: N<1", _state);
   ae_assert(t->cnt >= n, "PolynomialBar2Cheb: Length(T)<N", _state);
   ae_assert(isfinitevector(t, n, _state), "PolynomialBar2Cheb: T[] contains INF or NAN", _state);
// Calculate function values on a Chebyshev grid spanning [-1,+1]
   ae_vector_set_length(&y, n, _state);
   for (i = 0; i < n; i++) {
   // Calculate value on a grid spanning [-1,+1]
      vx = ae_cos(pi * (i + 0.5) / n, _state);
      vy = t->xR[0];
      tk1 = 1.0;
      tk = vx;
      for (k = 1; k < n; k++) {
         vy += t->xR[k] * tk;
         v = 2 * vx * tk - tk1;
         tk1 = tk;
         tk = v;
      }
      y.xR[i] = vy;
   }
// Build barycentric interpolant, map grid from [-1,+1] to [A,B]
   polynomialbuildcheb1(a, b, &y, n, p, _state);
   ae_frame_leave(_state);
}

// Conversion from barycentric representation to power basis.
// This function has O(N^2) complexity.
//
// Inputs:
//     P   -   polynomial in barycentric form
//     C   -   offset (see below); 0.0 is used as default value.
//     S   -   scale (see below);  1.0 is used as default value. S != 0.
//
// Outputs:
//     A   -   coefficients, P(x) = sum { A[i]*((X-C)/S)^i, i=0..N-1 }
//     N   -   number of coefficients (polynomial degree plus 1)
//
// NOTES:
// 1.  this function accepts offset and scale, which can be  set  to  improve
//     numerical properties of polynomial. For example, if P was obtained  as
//     result of interpolation on [-1,+1],  you  can  set  C=0  and  S=1  and
//     represent  P  as sum of 1, x, x^2, x^3 and so on. In most cases you it
//     is exactly what you need.
//
//     However, if your interpolation model was built on [999,1001], you will
//     see significant growth of numerical errors when using {1, x, x^2, x^3}
//     as basis. Representing P as sum of 1, (x-1000), (x-1000)^2, (x-1000)^3
//     will be better option. Such representation can be  obtained  by  using
//     1000.0 as offset C and 1.0 as scale S.
//
// 2.  power basis is ill-conditioned and tricks described above can't  solve
//     this problem completely. This function  will  return  coefficients  in
//     any  case,  but  for  N>8  they  will  become unreliable. However, N's
//     less than 5 are pretty safe.
//
// 3.  barycentric interpolant passed as P may be either polynomial  obtained
//     from  polynomial  interpolation/ fitting or rational function which is
//     NOT polynomial. We can't distinguish between these two cases, and this
//     algorithm just tries to work assuming that P IS a polynomial.  If not,
//     algorithm will return results, but they won't have any meaning.
// ALGLIB: Copyright 30.09.2010 by Sergey Bochkanov
// API: void polynomialbar2pow(const barycentricinterpolant &p, const double c, const double s, real_1d_array &a, const xparams _xparams = xdefault);
// API: void polynomialbar2pow(const barycentricinterpolant &p, real_1d_array &a, const xparams _xparams = xdefault);
void polynomialbar2pow(barycentricinterpolant *p, double c, double s, RVector *a, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t k;
   double e;
   double d;
   double v;
   double c0;
   double s0;
   double va;
   double vb;
   double minx;
   double maxx;
   ae_frame_make(_state, &_frame_block);
   SetVector(a);
   NewVector(vp, 0, DT_REAL, _state);
   NewVector(vx, 0, DT_REAL, _state);
   NewVector(tk, 0, DT_REAL, _state);
   NewVector(tk1, 0, DT_REAL, _state);
   NewVector(t, 0, DT_REAL, _state);
   NewVector(vai, 0, DT_REAL, _state);
   NewVector(vbi, 0, DT_REAL, _state);
// We have barycentric model built using set of points X[], and we
// want to convert it to power basis centered about point  C  with
// scale S: I-th basis function is ((X-C)/S)^i.
//
// We use following three-stage algorithm:
//
// 1. we build Chebyshev representation of polynomial using
//    intermediate center C0 and scale S0, which are derived from X[]:
//    C0 = 0.5*(min(X)+max(X)), S0 = 0.5*(max(X)-min(X)). Chebyshev
//    representation is built by sampling points around center C0,
//    with typical distance between them proportional to S0.
// 2. then we transform form Chebyshev basis to intermediate power
//    basis, using same center/scale C0/S0.
// 3. after that, we apply linear transformation to intermediate
//    power basis which moves it to final center/scale C/S.
//
// The idea of such multi-stage algorithm is that it is much easier to
// transform barycentric model to Chebyshev basis, and only later to
// power basis, than transforming it directly to power basis. It is
// also more numerically stable to sample points using intermediate C0/S0,
// which are derived from user-supplied model, than using "final" C/S,
// which may be unsuitable for sampling (say, if S=1, we may have stability
// problems when working with models built from dataset with non-unit
// scale of abscissas).
   ae_assert(ae_isfinite(c, _state), "PolynomialBar2Pow: C is not finite!", _state);
   ae_assert(ae_isfinite(s, _state), "PolynomialBar2Pow: S is not finite!", _state);
   ae_assert(s != 0.0, "PolynomialBar2Pow: S=0!", _state);
   ae_assert(p->n > 0, "PolynomialBar2Pow: P is not correctly initialized barycentric interpolant!", _state);
// Select intermediate center/scale
   minx = p->x.xR[0];
   maxx = p->x.xR[0];
   for (i = 1; i < p->n; i++) {
      minx = minreal(minx, p->x.xR[i], _state);
      maxx = maxreal(maxx, p->x.xR[i], _state);
   }
   if (minx == maxx) {
      c0 = minx;
      s0 = 1.0;
   } else {
      c0 = 0.5 * (maxx + minx);
      s0 = 0.5 * (maxx - minx);
   }
// Calculate function values on a Chebyshev grid using intermediate C0/S0
   ae_vector_set_length(&vp, p->n + 1, _state);
   ae_vector_set_length(&vx, p->n, _state);
   for (i = 0; i < p->n; i++) {
      vx.xR[i] = ae_cos(pi * (i + 0.5) / p->n, _state);
      vp.xR[i] = barycentriccalc(p, s0 * vx.xR[i] + c0, _state);
   }
// T[0]
   ae_vector_set_length(&t, p->n, _state);
   v = 0.0;
   for (i = 0; i < p->n; i++) {
      v += vp.xR[i];
   }
   t.xR[0] = v / p->n;
// other T's.
//
// NOTES:
// 1. TK stores T{k} on VX, TK1 stores T{k-1} on VX
// 2. we can do same calculations with fast DCT, but it
//    * adds dependencies
//    * still leaves us with O(N^2) algorithm because
//      preparation of function values is O(N^2) process
   if (p->n > 1) {
      ae_vector_set_length(&tk, p->n, _state);
      ae_vector_set_length(&tk1, p->n, _state);
      for (i = 0; i < p->n; i++) {
         tk.xR[i] = vx.xR[i];
         tk1.xR[i] = 1.0;
      }
      for (k = 1; k < p->n; k++) {
      // calculate discrete product of function vector and TK
         v = ae_v_dotproduct(tk.xR, 1, vp.xR, 1, p->n);
         t.xR[k] = v / (0.5 * p->n);
      // Update TK and TK1
         for (i = 0; i < p->n; i++) {
            v = 2 * vx.xR[i] * tk.xR[i] - tk1.xR[i];
            tk1.xR[i] = tk.xR[i];
            tk.xR[i] = v;
         }
      }
   }
// Convert from Chebyshev basis to power basis
   ae_vector_set_length(a, p->n, _state);
   for (i = 0; i < p->n; i++) {
      a->xR[i] = 0.0;
   }
   d = 0.0;
   for (i = 0; i < p->n; i++) {
      for (k = i; k < p->n; k++) {
         e = a->xR[k];
         a->xR[k] = 0.0;
         if (i <= 1 && k == i) {
            a->xR[k] = 1.0;
         } else {
            if (i != 0) {
               a->xR[k] = 2 * d;
            }
            if (k > i + 1) {
               a->xR[k] -= a->xR[k - 2];
            }
         }
         d = e;
      }
      d = a->xR[i];
      e = 0.0;
      k = i;
      while (k < p->n) {
         e += a->xR[k] * t.xR[k];
         k += 2;
      }
      a->xR[i] = e;
   }
// Apply linear transformation which converts basis from intermediate
// one Fi=((x-C0)/S0)^i to final one Fi=((x-C)/S)^i.
//
// We have y=(x-C0)/S0, z=(x-C)/S, and coefficients A[] for basis Fi(y).
// Because we have y=A*z+B, for A=s/s0 and B=c/s0-c0/s0, we can perform
// substitution and get coefficients A_new[] in basis Fi(z).
   ae_assert(vp.cnt >= p->n + 1, "PolynomialBar2Pow: internal error", _state);
   ae_assert(t.cnt >= p->n, "PolynomialBar2Pow: internal error", _state);
   for (i = 0; i < p->n; i++) {
      t.xR[i] = 0.0;
   }
   va = s / s0;
   vb = c / s0 - c0 / s0;
   ae_vector_set_length(&vai, p->n, _state);
   ae_vector_set_length(&vbi, p->n, _state);
   vai.xR[0] = 1.0;
   vbi.xR[0] = 1.0;
   for (k = 1; k < p->n; k++) {
      vai.xR[k] = vai.xR[k - 1] * va;
      vbi.xR[k] = vbi.xR[k - 1] * vb;
   }
   for (k = 0; k < p->n; k++) {
   // Generate set of binomial coefficients in VP[]
      if (k > 0) {
         vp.xR[k] = 1.0;
         for (i = k - 1; i >= 1; i--) {
            vp.xR[i] += vp.xR[i - 1];
         }
         vp.xR[0] = 1.0;
      } else {
         vp.xR[0] = 1.0;
      }
   // Update T[] with expansion of K-th basis function
      for (i = 0; i <= k; i++) {
         t.xR[i] += a->xR[k] * vai.xR[i] * vbi.xR[k - i] * vp.xR[i];
      }
   }
   for (k = 0; k < p->n; k++) {
      a->xR[k] = t.xR[k];
   }
   ae_frame_leave(_state);
}

// Conversion from power basis to barycentric representation.
// This function has O(N^2) complexity.
//
// Inputs:
//     A   -   coefficients, P(x) = sum { A[i]*((X-C)/S)^i, i=0..N-1 }
//     N   -   number of coefficients (polynomial degree plus 1)
//             * if given, only leading N elements of A are used
//             * if not given, automatically determined from size of A
//     C   -   offset (see below); 0.0 is used as default value.
//     S   -   scale (see below);  1.0 is used as default value. S != 0.
//
// Outputs:
//     P   -   polynomial in barycentric form
//
//
// NOTES:
// 1.  this function accepts offset and scale, which can be  set  to  improve
//     numerical properties of polynomial. For example, if you interpolate on
//     [-1,+1],  you  can  set C=0 and S=1 and convert from sum of 1, x, x^2,
//     x^3 and so on. In most cases you it is exactly what you need.
//
//     However, if your interpolation model was built on [999,1001], you will
//     see significant growth of numerical errors when using {1, x, x^2, x^3}
//     as  input  basis.  Converting  from  sum  of  1, (x-1000), (x-1000)^2,
//     (x-1000)^3 will be better option (you have to specify 1000.0 as offset
//     C and 1.0 as scale S).
//
// 2.  power basis is ill-conditioned and tricks described above can't  solve
//     this problem completely. This function  will  return barycentric model
//     in any case, but for N>8 accuracy well degrade. However, N's less than
//     5 are pretty safe.
// ALGLIB: Copyright 30.09.2010 by Sergey Bochkanov
// API: void polynomialpow2bar(const real_1d_array &a, const ae_int_t n, const double c, const double s, barycentricinterpolant &p, const xparams _xparams = xdefault);
// API: void polynomialpow2bar(const real_1d_array &a, barycentricinterpolant &p, const xparams _xparams = xdefault);
void polynomialpow2bar(RVector *a, ae_int_t n, double c, double s, barycentricinterpolant *p, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t k;
   double vx;
   double vy;
   double px;
   ae_frame_make(_state, &_frame_block);
   SetObj(barycentricinterpolant, p);
   NewVector(y, 0, DT_REAL, _state);
   ae_assert(ae_isfinite(c, _state), "PolynomialPow2Bar: C is not finite!", _state);
   ae_assert(ae_isfinite(s, _state), "PolynomialPow2Bar: S is not finite!", _state);
   ae_assert(s != 0.0, "PolynomialPow2Bar: S is zero!", _state);
   ae_assert(n >= 1, "PolynomialPow2Bar: N<1", _state);
   ae_assert(a->cnt >= n, "PolynomialPow2Bar: Length(A)<N", _state);
   ae_assert(isfinitevector(a, n, _state), "PolynomialPow2Bar: A[] contains INF or NAN", _state);
// Calculate function values on a Chebyshev grid spanning [-1,+1]
   ae_vector_set_length(&y, n, _state);
   for (i = 0; i < n; i++) {
   // Calculate value on a grid spanning [-1,+1]
      vx = ae_cos(pi * (i + 0.5) / n, _state);
      vy = a->xR[0];
      px = vx;
      for (k = 1; k < n; k++) {
         vy += px * a->xR[k];
         px *= vx;
      }
      y.xR[i] = vy;
   }
// Build barycentric interpolant, map grid from [-1,+1] to [A,B]
   polynomialbuildcheb1(c - s, c + s, &y, n, p, _state);
   ae_frame_leave(_state);
}

// Fast equidistant polynomial interpolation function with O(N) complexity
//
// Inputs:
//     A   -   left boundary of [A,B]
//     B   -   right boundary of [A,B]
//     F   -   function values, array[0..N-1]
//     N   -   number of points on equidistant grid, N >= 1
//             for N=1 a constant model is constructed.
//     T   -   position where P(x) is calculated
//
// Result:
//     value of the Lagrange interpolant at T
//
// IMPORTANT
//     this function provides fast interface which is not overflow-safe
//     nor it is very precise.
//     the best option is to use  PolynomialBuildEqDist()/BarycentricCalc()
//     subroutines unless you are pretty sure that your data will not result
//     in overflow.
// ALGLIB: Copyright 02.12.2009 by Sergey Bochkanov
// API: double polynomialcalceqdist(const double a, const double b, const real_1d_array &f, const ae_int_t n, const double t, const xparams _xparams = xdefault);
// API: double polynomialcalceqdist(const double a, const double b, const real_1d_array &f, const double t, const xparams _xparams = xdefault);
double polynomialcalceqdist(double a, double b, RVector *f, ae_int_t n, double t, ae_state *_state) {
   double s1;
   double s2;
   double v;
   double threshold;
   double s;
   double h;
   ae_int_t i;
   ae_int_t j;
   double w;
   double x;
   double result;
   ae_assert(n > 0, "PolynomialCalcEqDist: N <= 0!", _state);
   ae_assert(f->cnt >= n, "PolynomialCalcEqDist: Length(F)<N!", _state);
   ae_assert(ae_isfinite(a, _state), "PolynomialCalcEqDist: A is infinite or NaN!", _state);
   ae_assert(ae_isfinite(b, _state), "PolynomialCalcEqDist: B is infinite or NaN!", _state);
   ae_assert(isfinitevector(f, n, _state), "PolynomialCalcEqDist: F contains infinite or NaN values!", _state);
   ae_assert(b != a, "PolynomialCalcEqDist: B=A!", _state);
   ae_assert(!ae_isinf(t, _state), "PolynomialCalcEqDist: T is infinite!", _state);
// Special case: T is NAN
   if (ae_isnan(t, _state)) {
      result = _state->v_nan;
      return result;
   }
// Special case: N=1
   if (n == 1) {
      result = f->xR[0];
      return result;
   }
// First, decide: should we use "safe" formula (guarded
// against overflow) or fast one?
   threshold = ae_sqrt(minrealnumber, _state);
   j = 0;
   s = t - a;
   for (i = 1; i < n; i++) {
      x = a + (double)i / (n - 1) * (b - a);
      if (ae_fabs(t - x, _state) < ae_fabs(s, _state)) {
         s = t - x;
         j = i;
      }
   }
   if (s == 0.0) {
      result = f->xR[j];
      return result;
   }
   if (ae_fabs(s, _state) > threshold) {
   // use fast formula
      j = -1;
      s = 1.0;
   }
// Calculate using safe or fast barycentric formula
   s1 = 0.0;
   s2 = 0.0;
   w = 1.0;
   h = (b - a) / (n - 1);
   for (i = 0; i < n; i++) {
      if (i != j) {
         v = s * w / (t - (a + i * h));
         s1 += v * f->xR[i];
         s2 += v;
      } else {
         v = w;
         s1 += v * f->xR[i];
         s2 += v;
      }
      w *= -(n - 1 - i);
      w /= i + 1;
   }
   result = s1 / s2;
   return result;
}

// Fast polynomial interpolation function on Chebyshev points (first kind)
// with O(N) complexity.
//
// Inputs:
//     A   -   left boundary of [A,B]
//     B   -   right boundary of [A,B]
//     F   -   function values, array[0..N-1]
//     N   -   number of points on Chebyshev grid (first kind),
//             X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*(2*i+1)/(2*n))
//             for N=1 a constant model is constructed.
//     T   -   position where P(x) is calculated
//
// Result:
//     value of the Lagrange interpolant at T
//
// IMPORTANT
//     this function provides fast interface which is not overflow-safe
//     nor it is very precise.
//     the best option is to use  PolIntBuildCheb1()/BarycentricCalc()
//     subroutines unless you are pretty sure that your data will not result
//     in overflow.
// ALGLIB: Copyright 02.12.2009 by Sergey Bochkanov
// API: double polynomialcalccheb1(const double a, const double b, const real_1d_array &f, const ae_int_t n, const double t, const xparams _xparams = xdefault);
// API: double polynomialcalccheb1(const double a, const double b, const real_1d_array &f, const double t, const xparams _xparams = xdefault);
double polynomialcalccheb1(double a, double b, RVector *f, ae_int_t n, double t, ae_state *_state) {
   double s1;
   double s2;
   double v;
   double threshold;
   double s;
   ae_int_t i;
   ae_int_t j;
   double a0;
   double delta;
   double alpha;
   double beta;
   double ca;
   double sa;
   double tempc;
   double temps;
   double x;
   double w;
   double p1;
   double result;
   ae_assert(n > 0, "PolynomialCalcCheb1: N <= 0!", _state);
   ae_assert(f->cnt >= n, "PolynomialCalcCheb1: Length(F)<N!", _state);
   ae_assert(ae_isfinite(a, _state), "PolynomialCalcCheb1: A is infinite or NaN!", _state);
   ae_assert(ae_isfinite(b, _state), "PolynomialCalcCheb1: B is infinite or NaN!", _state);
   ae_assert(isfinitevector(f, n, _state), "PolynomialCalcCheb1: F contains infinite or NaN values!", _state);
   ae_assert(b != a, "PolynomialCalcCheb1: B=A!", _state);
   ae_assert(!ae_isinf(t, _state), "PolynomialCalcCheb1: T is infinite!", _state);
// Special case: T is NAN
   if (ae_isnan(t, _state)) {
      result = _state->v_nan;
      return result;
   }
// Special case: N=1
   if (n == 1) {
      result = f->xR[0];
      return result;
   }
// Prepare information for the recurrence formula
// used to calculate sin(pi*(2j+1)/(2n+2)) and
// cos(pi*(2j+1)/(2n+2)):
//
// A0    = pi/(2n+2)
// Delta = pi/(n+1)
// Alpha = 2 sin^2 (Delta/2)
// Beta  = sin(Delta)
//
// so that sin(..) = sin(A0+j*delta) and cos(..) = cos(A0+j*delta).
// Then we use
//
// sin(x+delta) = sin(x) - (alpha*sin(x) - beta*cos(x))
// cos(x+delta) = cos(x) - (alpha*cos(x) - beta*sin(x))
//
// to repeatedly calculate sin(..) and cos(..).
   threshold = ae_sqrt(minrealnumber, _state);
   t = (t - 0.5 * (a + b)) / (0.5 * (b - a));
   a0 = pi / (2 * (n - 1) + 2);
   delta = 2 * pi / (2 * (n - 1) + 2);
   alpha = 2 * sqr(ae_sin(delta / 2, _state), _state);
   beta = ae_sin(delta, _state);
// First, decide: should we use "safe" formula (guarded
// against overflow) or fast one?
   ca = ae_cos(a0, _state);
   sa = ae_sin(a0, _state);
   j = 0;
   x = ca;
   s = t - x;
   for (i = 1; i < n; i++) {
   // Next X[i]
      temps = sa - (alpha * sa - beta * ca);
      tempc = ca - (alpha * ca + beta * sa);
      sa = temps;
      ca = tempc;
      x = ca;
   // Use X[i]
      if (ae_fabs(t - x, _state) < ae_fabs(s, _state)) {
         s = t - x;
         j = i;
      }
   }
   if (s == 0.0) {
      result = f->xR[j];
      return result;
   }
   if (ae_fabs(s, _state) > threshold) {
   // use fast formula
      j = -1;
      s = 1.0;
   }
// Calculate using safe or fast barycentric formula
   s1 = 0.0;
   s2 = 0.0;
   ca = ae_cos(a0, _state);
   sa = ae_sin(a0, _state);
   p1 = 1.0;
   for (i = 0; i < n; i++) {
   // Calculate X[i], W[i]
      x = ca;
      w = p1 * sa;
   // Proceed
      if (i != j) {
         v = s * w / (t - x);
         s1 += v * f->xR[i];
         s2 += v;
      } else {
         v = w;
         s1 += v * f->xR[i];
         s2 += v;
      }
   // Next CA, SA, P1
      temps = sa - (alpha * sa - beta * ca);
      tempc = ca - (alpha * ca + beta * sa);
      sa = temps;
      ca = tempc;
      p1 = -p1;
   }
   result = s1 / s2;
   return result;
}

// Fast polynomial interpolation function on Chebyshev points (second kind)
// with O(N) complexity.
//
// Inputs:
//     A   -   left boundary of [A,B]
//     B   -   right boundary of [A,B]
//     F   -   function values, array[0..N-1]
//     N   -   number of points on Chebyshev grid (second kind),
//             X[i] = 0.5*(B+A) + 0.5*(B-A)*Cos(PI*i/(n-1))
//             for N=1 a constant model is constructed.
//     T   -   position where P(x) is calculated
//
// Result:
//     value of the Lagrange interpolant at T
//
// IMPORTANT
//     this function provides fast interface which is not overflow-safe
//     nor it is very precise.
//     the best option is to use PolIntBuildCheb2()/BarycentricCalc()
//     subroutines unless you are pretty sure that your data will not result
//     in overflow.
// ALGLIB: Copyright 02.12.2009 by Sergey Bochkanov
// API: double polynomialcalccheb2(const double a, const double b, const real_1d_array &f, const ae_int_t n, const double t, const xparams _xparams = xdefault);
// API: double polynomialcalccheb2(const double a, const double b, const real_1d_array &f, const double t, const xparams _xparams = xdefault);
double polynomialcalccheb2(double a, double b, RVector *f, ae_int_t n, double t, ae_state *_state) {
   double s1;
   double s2;
   double v;
   double threshold;
   double s;
   ae_int_t i;
   ae_int_t j;
   double a0;
   double delta;
   double alpha;
   double beta;
   double ca;
   double sa;
   double tempc;
   double temps;
   double x;
   double w;
   double p1;
   double result;
   ae_assert(n > 0, "PolynomialCalcCheb2: N <= 0!", _state);
   ae_assert(f->cnt >= n, "PolynomialCalcCheb2: Length(F)<N!", _state);
   ae_assert(ae_isfinite(a, _state), "PolynomialCalcCheb2: A is infinite or NaN!", _state);
   ae_assert(ae_isfinite(b, _state), "PolynomialCalcCheb2: B is infinite or NaN!", _state);
   ae_assert(b != a, "PolynomialCalcCheb2: B=A!", _state);
   ae_assert(isfinitevector(f, n, _state), "PolynomialCalcCheb2: F contains infinite or NaN values!", _state);
   ae_assert(!ae_isinf(t, _state), "PolynomialCalcEqDist: T is infinite!", _state);
// Special case: T is NAN
   if (ae_isnan(t, _state)) {
      result = _state->v_nan;
      return result;
   }
// Special case: N=1
   if (n == 1) {
      result = f->xR[0];
      return result;
   }
// Prepare information for the recurrence formula
// used to calculate sin(pi*i/n) and
// cos(pi*i/n):
//
// A0    = 0
// Delta = pi/n
// Alpha = 2 sin^2 (Delta/2)
// Beta  = sin(Delta)
//
// so that sin(..) = sin(A0+j*delta) and cos(..) = cos(A0+j*delta).
// Then we use
//
// sin(x+delta) = sin(x) - (alpha*sin(x) - beta*cos(x))
// cos(x+delta) = cos(x) - (alpha*cos(x) - beta*sin(x))
//
// to repeatedly calculate sin(..) and cos(..).
   threshold = ae_sqrt(minrealnumber, _state);
   t = (t - 0.5 * (a + b)) / (0.5 * (b - a));
   a0 = 0.0;
   delta = pi / (n - 1);
   alpha = 2 * sqr(ae_sin(delta / 2, _state), _state);
   beta = ae_sin(delta, _state);
// First, decide: should we use "safe" formula (guarded
// against overflow) or fast one?
   ca = ae_cos(a0, _state);
   sa = ae_sin(a0, _state);
   j = 0;
   x = ca;
   s = t - x;
   for (i = 1; i < n; i++) {
   // Next X[i]
      temps = sa - (alpha * sa - beta * ca);
      tempc = ca - (alpha * ca + beta * sa);
      sa = temps;
      ca = tempc;
      x = ca;
   // Use X[i]
      if (ae_fabs(t - x, _state) < ae_fabs(s, _state)) {
         s = t - x;
         j = i;
      }
   }
   if (s == 0.0) {
      result = f->xR[j];
      return result;
   }
   if (ae_fabs(s, _state) > threshold) {
   // use fast formula
      j = -1;
      s = 1.0;
   }
// Calculate using safe or fast barycentric formula
   s1 = 0.0;
   s2 = 0.0;
   ca = ae_cos(a0, _state);
   sa = ae_sin(a0, _state);
   p1 = 1.0;
   for (i = 0; i < n; i++) {
   // Calculate X[i], W[i]
      x = ca;
      if (i == 0 || i == n - 1) {
         w = 0.5 * p1;
      } else {
         w = 1.0 * p1;
      }
   // Proceed
      if (i != j) {
         v = s * w / (t - x);
         s1 += v * f->xR[i];
         s2 += v;
      } else {
         v = w;
         s1 += v * f->xR[i];
         s2 += v;
      }
   // Next CA, SA, P1
      temps = sa - (alpha * sa - beta * ca);
      tempc = ca - (alpha * ca + beta * sa);
      sa = temps;
      ca = tempc;
      p1 = -p1;
   }
   result = s1 / s2;
   return result;
}
} // end of namespace alglib_impl

namespace alglib {
void polynomialbuild(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, barycentricinterpolant &p, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialbuild(ConstT(ae_vector, x), ConstT(ae_vector, y), n, ConstT(barycentricinterpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void polynomialbuild(const real_1d_array &x, const real_1d_array &y, barycentricinterpolant &p, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'polynomialbuild': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialbuild(ConstT(ae_vector, x), ConstT(ae_vector, y), n, ConstT(barycentricinterpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void polynomialbuildeqdist(const double a, const double b, const real_1d_array &y, const ae_int_t n, barycentricinterpolant &p, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialbuildeqdist(a, b, ConstT(ae_vector, y), n, ConstT(barycentricinterpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void polynomialbuildeqdist(const double a, const double b, const real_1d_array &y, barycentricinterpolant &p, const xparams _xparams) {
   ae_int_t n = y.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialbuildeqdist(a, b, ConstT(ae_vector, y), n, ConstT(barycentricinterpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void polynomialbuildcheb1(const double a, const double b, const real_1d_array &y, const ae_int_t n, barycentricinterpolant &p, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialbuildcheb1(a, b, ConstT(ae_vector, y), n, ConstT(barycentricinterpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void polynomialbuildcheb1(const double a, const double b, const real_1d_array &y, barycentricinterpolant &p, const xparams _xparams) {
   ae_int_t n = y.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialbuildcheb1(a, b, ConstT(ae_vector, y), n, ConstT(barycentricinterpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void polynomialbuildcheb2(const double a, const double b, const real_1d_array &y, const ae_int_t n, barycentricinterpolant &p, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialbuildcheb2(a, b, ConstT(ae_vector, y), n, ConstT(barycentricinterpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void polynomialbuildcheb2(const double a, const double b, const real_1d_array &y, barycentricinterpolant &p, const xparams _xparams) {
   ae_int_t n = y.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialbuildcheb2(a, b, ConstT(ae_vector, y), n, ConstT(barycentricinterpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void polynomialbar2cheb(const barycentricinterpolant &p, const double a, const double b, real_1d_array &t, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialbar2cheb(ConstT(barycentricinterpolant, p), a, b, ConstT(ae_vector, t), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void polynomialcheb2bar(const real_1d_array &t, const ae_int_t n, const double a, const double b, barycentricinterpolant &p, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialcheb2bar(ConstT(ae_vector, t), n, a, b, ConstT(barycentricinterpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void polynomialcheb2bar(const real_1d_array &t, const double a, const double b, barycentricinterpolant &p, const xparams _xparams) {
   ae_int_t n = t.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialcheb2bar(ConstT(ae_vector, t), n, a, b, ConstT(barycentricinterpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void polynomialbar2pow(const barycentricinterpolant &p, const double c, const double s, real_1d_array &a, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialbar2pow(ConstT(barycentricinterpolant, p), c, s, ConstT(ae_vector, a), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void polynomialbar2pow(const barycentricinterpolant &p, real_1d_array &a, const xparams _xparams) {
   double c = 0.0;
   double s = 1.0;
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialbar2pow(ConstT(barycentricinterpolant, p), c, s, ConstT(ae_vector, a), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void polynomialpow2bar(const real_1d_array &a, const ae_int_t n, const double c, const double s, barycentricinterpolant &p, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialpow2bar(ConstT(ae_vector, a), n, c, s, ConstT(barycentricinterpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void polynomialpow2bar(const real_1d_array &a, barycentricinterpolant &p, const xparams _xparams) {
   ae_int_t n = a.length();
   double c = 0.0;
   double s = 1.0;
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialpow2bar(ConstT(ae_vector, a), n, c, s, ConstT(barycentricinterpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

double polynomialcalceqdist(const double a, const double b, const real_1d_array &f, const ae_int_t n, const double t, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::polynomialcalceqdist(a, b, ConstT(ae_vector, f), n, t, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}
#if !defined AE_NO_EXCEPTIONS
double polynomialcalceqdist(const double a, const double b, const real_1d_array &f, const double t, const xparams _xparams) {
   ae_int_t n = f.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::polynomialcalceqdist(a, b, ConstT(ae_vector, f), n, t, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}
#endif

double polynomialcalccheb1(const double a, const double b, const real_1d_array &f, const ae_int_t n, const double t, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::polynomialcalccheb1(a, b, ConstT(ae_vector, f), n, t, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}
#if !defined AE_NO_EXCEPTIONS
double polynomialcalccheb1(const double a, const double b, const real_1d_array &f, const double t, const xparams _xparams) {
   ae_int_t n = f.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::polynomialcalccheb1(a, b, ConstT(ae_vector, f), n, t, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}
#endif

double polynomialcalccheb2(const double a, const double b, const real_1d_array &f, const ae_int_t n, const double t, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::polynomialcalccheb2(a, b, ConstT(ae_vector, f), n, t, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}
#if !defined AE_NO_EXCEPTIONS
double polynomialcalccheb2(const double a, const double b, const real_1d_array &f, const double t, const xparams _xparams) {
   ae_int_t n = f.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::polynomialcalccheb2(a, b, ConstT(ae_vector, f), n, t, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}
#endif
} // end of namespace alglib

// === SPLINE1D Package ===
// Depends on: (LinAlg) FBLS
// Depends on: (Solvers) LINLSQR
// Depends on: INTFITSERV
namespace alglib_impl {
static const double spline1d_lambdareg = 1.0e-9;
static const double spline1d_cholreg = 1.0e-12;

// Internal subroutine. Heap sort.
static void spline1d_heapsortpoints(RVector *x, RVector *y, ae_int_t n, ae_state *_state) {
   ae_frame _frame_block;
   ae_frame_make(_state, &_frame_block);
   NewVector(bufx, 0, DT_REAL, _state);
   NewVector(bufy, 0, DT_REAL, _state);
   tagsortfastr(x, y, &bufx, &bufy, n, _state);
   ae_frame_leave(_state);
}

// Internal subroutine. Heap sort.
//
// Accepts:
//     X, Y    -   points
//     P       -   empty or preallocated array
//
// Returns:
//     X, Y    -   sorted by X
//     P       -   array of permutations; I-th position of output
//                 arrays X/Y contains (X[P[I]],Y[P[I]])
static void spline1d_heapsortppoints(RVector *x, RVector *y, ZVector *p, ae_int_t n, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   NewVector(rbuf, 0, DT_REAL, _state);
   NewVector(ibuf, 0, DT_INT, _state);
   if (p->cnt < n) {
      ae_vector_set_length(p, n, _state);
   }
   ae_vector_set_length(&rbuf, n, _state);
   for (i = 0; i < n; i++) {
      p->xZ[i] = i;
   }
   tagsortfasti(x, p, &rbuf, &ibuf, n, _state);
   for (i = 0; i < n; i++) {
      rbuf.xR[i] = y->xR[p->xZ[i]];
   }
   ae_v_move(y->xR, 1, rbuf.xR, 1, n);
   ae_frame_leave(_state);
}

// Internal subroutine. Heap sort.
void heapsortdpoints(RVector *x, RVector *y, RVector *d, ae_int_t n, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   NewVector(rbuf, 0, DT_REAL, _state);
   NewVector(ibuf, 0, DT_INT, _state);
   NewVector(rbuf2, 0, DT_REAL, _state);
   NewVector(ibuf2, 0, DT_INT, _state);
   ae_vector_set_length(&ibuf, n, _state);
   ae_vector_set_length(&rbuf, n, _state);
   for (i = 0; i < n; i++) {
      ibuf.xZ[i] = i;
   }
   tagsortfasti(x, &ibuf, &rbuf2, &ibuf2, n, _state);
   for (i = 0; i < n; i++) {
      rbuf.xR[i] = y->xR[ibuf.xZ[i]];
   }
   ae_v_move(y->xR, 1, rbuf.xR, 1, n);
   for (i = 0; i < n; i++) {
      rbuf.xR[i] = d->xR[ibuf.xZ[i]];
   }
   ae_v_move(d->xR, 1, rbuf.xR, 1, n);
   ae_frame_leave(_state);
}

// Internal subroutine. Tridiagonal solver. Solves
//
// ( B[0] C[0]
// ( A[1] B[1] C[1]                 )
// (      A[2] B[2] C[2]            )
// (            ..........          ) * X = D
// (            ..........          )
// (           A[N-2] B[N-2] C[N-2] )
// (                  A[N-1] B[N-1] )
//
static void spline1d_solvetridiagonal(RVector *a, RVector *b, RVector *c, RVector *d, ae_int_t n, RVector *x, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t k;
   double t;
   ae_frame_make(_state, &_frame_block);
   DupVector(b, _state);
   DupVector(d, _state);
   if (x->cnt < n) {
      ae_vector_set_length(x, n, _state);
   }
   for (k = 1; k < n; k++) {
      t = a->xR[k] / b->xR[k - 1];
      b->xR[k] -= t * c->xR[k - 1];
      d->xR[k] -= t * d->xR[k - 1];
   }
   x->xR[n - 1] = d->xR[n - 1] / b->xR[n - 1];
   for (k = n - 2; k >= 0; k--) {
      x->xR[k] = (d->xR[k] - c->xR[k] * x->xR[k + 1]) / b->xR[k];
   }
   ae_frame_leave(_state);
}

// Internal subroutine. Cyclic tridiagonal solver. Solves
//
// ( B[0] C[0]                 A[0] )
// ( A[1] B[1] C[1]                 )
// (      A[2] B[2] C[2]            )
// (            ..........          ) * X = D
// (            ..........          )
// (           A[N-2] B[N-2] C[N-2] )
// ( C[N-1]           A[N-1] B[N-1] )
static void spline1d_solvecyclictridiagonal(RVector *a, RVector *b, RVector *c, RVector *d, ae_int_t n, RVector *x, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t k;
   double alpha;
   double beta;
   double gamma;
   ae_frame_make(_state, &_frame_block);
   DupVector(b, _state);
   NewVector(y, 0, DT_REAL, _state);
   NewVector(z, 0, DT_REAL, _state);
   NewVector(u, 0, DT_REAL, _state);
   if (x->cnt < n) {
      ae_vector_set_length(x, n, _state);
   }
   beta = a->xR[0];
   alpha = c->xR[n - 1];
   gamma = -b->xR[0];
   b->xR[0] *= 2;
   b->xR[n - 1] -= alpha * beta / gamma;
   ae_vector_set_length(&u, n, _state);
   for (k = 0; k < n; k++) {
      u.xR[k] = 0.0;
   }
   u.xR[0] = gamma;
   u.xR[n - 1] = alpha;
   spline1d_solvetridiagonal(a, b, c, d, n, &y, _state);
   spline1d_solvetridiagonal(a, b, c, &u, n, &z, _state);
   for (k = 0; k < n; k++) {
      x->xR[k] = y.xR[k] - (y.xR[0] + beta / gamma * y.xR[n - 1]) / (1 + z.xR[0] + beta / gamma * z.xR[n - 1]) * z.xR[k];
   }
   ae_frame_leave(_state);
}

// Internal version of Spline1DGridDiffCubic.
//
// Accepts pre-ordered X/Y, temporary arrays (which may be  preallocated,  if
// you want to save time, or not) and output array (which may be preallocated
// too).
//
// Y is passed as var-parameter because we may need to force last element  to
// be equal to the first one (if periodic boundary conditions are specified).
// ALGLIB Project: Copyright 03.09.2010 by Sergey Bochkanov
static void spline1d_spline1dgriddiffcubicinternal(RVector *x, RVector *y, ae_int_t n, ae_int_t boundltype, double boundl, ae_int_t boundrtype, double boundr, RVector *d, RVector *a1, RVector *a2, RVector *a3, RVector *b, RVector *dt, ae_state *_state) {
   ae_int_t i;
// allocate arrays
   if (d->cnt < n) {
      ae_vector_set_length(d, n, _state);
   }
   if (a1->cnt < n) {
      ae_vector_set_length(a1, n, _state);
   }
   if (a2->cnt < n) {
      ae_vector_set_length(a2, n, _state);
   }
   if (a3->cnt < n) {
      ae_vector_set_length(a3, n, _state);
   }
   if (b->cnt < n) {
      ae_vector_set_length(b, n, _state);
   }
   if (dt->cnt < n) {
      ae_vector_set_length(dt, n, _state);
   }
// Special cases:
// * N=2, parabolic terminated boundary condition on both ends
// * N=2, periodic boundary condition
   if ((n == 2 && boundltype == 0) && boundrtype == 0) {
      d->xR[0] = (y->xR[1] - y->xR[0]) / (x->xR[1] - x->xR[0]);
      d->xR[1] = d->xR[0];
      return;
   }
   if ((n == 2 && boundltype == -1) && boundrtype == -1) {
      d->xR[0] = 0.0;
      d->xR[1] = 0.0;
      return;
   }
// Periodic and non-periodic boundary conditions are
// two separate classes
   if (boundrtype == -1 && boundltype == -1) {
   // Periodic boundary conditions
      y->xR[n - 1] = y->xR[0];
   // Boundary conditions at N-1 points
   // (one point less because last point is the same as first point).
      a1->xR[0] = x->xR[1] - x->xR[0];
      a2->xR[0] = 2 * (x->xR[1] - x->xR[0] + x->xR[n - 1] - x->xR[n - 2]);
      a3->xR[0] = x->xR[n - 1] - x->xR[n - 2];
      b->xR[0] = 3 * (y->xR[n - 1] - y->xR[n - 2]) / (x->xR[n - 1] - x->xR[n - 2]) * (x->xR[1] - x->xR[0]) + 3 * (y->xR[1] - y->xR[0]) / (x->xR[1] - x->xR[0]) * (x->xR[n - 1] - x->xR[n - 2]);
      for (i = 1; i < n - 1; i++) {
      // Altough last point is [N-2], we use X[N-1] and Y[N-1]
      // (because of periodicity)
         a1->xR[i] = x->xR[i + 1] - x->xR[i];
         a2->xR[i] = 2 * (x->xR[i + 1] - x->xR[i - 1]);
         a3->xR[i] = x->xR[i] - x->xR[i - 1];
         b->xR[i] = 3 * (y->xR[i] - y->xR[i - 1]) / (x->xR[i] - x->xR[i - 1]) * (x->xR[i + 1] - x->xR[i]) + 3 * (y->xR[i + 1] - y->xR[i]) / (x->xR[i + 1] - x->xR[i]) * (x->xR[i] - x->xR[i - 1]);
      }
   // Solve, add last point (with index N-1)
      spline1d_solvecyclictridiagonal(a1, a2, a3, b, n - 1, dt, _state);
      ae_v_move(d->xR, 1, dt->xR, 1, n - 1);
      d->xR[n - 1] = d->xR[0];
   } else {
   // Non-periodic boundary condition.
   // Left boundary conditions.
      if (boundltype == 0) {
         a1->xR[0] = 0.0;
         a2->xR[0] = 1.0;
         a3->xR[0] = 1.0;
         b->xR[0] = 2 * (y->xR[1] - y->xR[0]) / (x->xR[1] - x->xR[0]);
      }
      if (boundltype == 1) {
         a1->xR[0] = 0.0;
         a2->xR[0] = 1.0;
         a3->xR[0] = 0.0;
         b->xR[0] = boundl;
      }
      if (boundltype == 2) {
         a1->xR[0] = 0.0;
         a2->xR[0] = 2.0;
         a3->xR[0] = 1.0;
         b->xR[0] = 3 * (y->xR[1] - y->xR[0]) / (x->xR[1] - x->xR[0]) - 0.5 * boundl * (x->xR[1] - x->xR[0]);
      }
   // Central conditions
      for (i = 1; i < n - 1; i++) {
         a1->xR[i] = x->xR[i + 1] - x->xR[i];
         a2->xR[i] = 2 * (x->xR[i + 1] - x->xR[i - 1]);
         a3->xR[i] = x->xR[i] - x->xR[i - 1];
         b->xR[i] = 3 * (y->xR[i] - y->xR[i - 1]) / (x->xR[i] - x->xR[i - 1]) * (x->xR[i + 1] - x->xR[i]) + 3 * (y->xR[i + 1] - y->xR[i]) / (x->xR[i + 1] - x->xR[i]) * (x->xR[i] - x->xR[i - 1]);
      }
   // Right boundary conditions
      if (boundrtype == 0) {
         a1->xR[n - 1] = 1.0;
         a2->xR[n - 1] = 1.0;
         a3->xR[n - 1] = 0.0;
         b->xR[n - 1] = 2 * (y->xR[n - 1] - y->xR[n - 2]) / (x->xR[n - 1] - x->xR[n - 2]);
      }
      if (boundrtype == 1) {
         a1->xR[n - 1] = 0.0;
         a2->xR[n - 1] = 1.0;
         a3->xR[n - 1] = 0.0;
         b->xR[n - 1] = boundr;
      }
      if (boundrtype == 2) {
         a1->xR[n - 1] = 1.0;
         a2->xR[n - 1] = 2.0;
         a3->xR[n - 1] = 0.0;
         b->xR[n - 1] = 3 * (y->xR[n - 1] - y->xR[n - 2]) / (x->xR[n - 1] - x->xR[n - 2]) + 0.5 * boundr * (x->xR[n - 1] - x->xR[n - 2]);
      }
   // Solve
      spline1d_solvetridiagonal(a1, a2, a3, b, n, d, _state);
   }
}

// Internal subroutine. Three-point differentiation
static double spline1d_diffthreepoint(double t, double x0, double f0, double x1, double f1, double x2, double f2, ae_state *_state) {
   double a;
   double b;
   double result;
   t -= x0;
   x1 -= x0;
   x2 -= x0;
   a = (f2 - f0 - x2 / x1 * (f1 - f0)) / (sqr(x2, _state) - x1 * x2);
   b = (f1 - f0 - a * sqr(x1, _state)) / x1;
   result = 2 * a * t + b;
   return result;
}

// This subroutine builds linear spline interpolant
//
// Inputs:
//     X   -   spline nodes, array[0..N-1]
//     Y   -   function values, array[0..N-1]
//     N   -   points count (optional):
//             * N >= 2
//             * if given, only first N points are used to build spline
//             * if not given, automatically detected from X/Y sizes
//               (len(X) must be equal to len(Y))
//
// Outputs:
//     C   -   spline interpolant
//
//
// ORDER OF POINTS
//
// Subroutine automatically sorts points, so caller may pass unsorted array.
// ALGLIB Project: Copyright 24.06.2007 by Sergey Bochkanov
// API: void spline1dbuildlinear(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, spline1dinterpolant &c, const xparams _xparams = xdefault);
// API: void spline1dbuildlinear(const real_1d_array &x, const real_1d_array &y, spline1dinterpolant &c, const xparams _xparams = xdefault);
void spline1dbuildlinear(RVector *x, RVector *y, ae_int_t n, spline1dinterpolant *c, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   SetObj(spline1dinterpolant, c);
   ae_assert(n > 1, "Spline1DBuildLinear: N<2!", _state);
   ae_assert(x->cnt >= n, "Spline1DBuildLinear: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DBuildLinear: Length(Y)<N!", _state);
// check and sort points
   ae_assert(isfinitevector(x, n, _state), "Spline1DBuildLinear: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "Spline1DBuildLinear: Y contains infinite or NAN values!", _state);
   spline1d_heapsortpoints(x, y, n, _state);
   ae_assert(aredistinct(x, n, _state), "Spline1DBuildLinear: at least two consequent points are too close!", _state);
// Build
   c->periodic = false;
   c->n = n;
   c->k = 3;
   c->continuity = 0;
   ae_vector_set_length(&c->x, n, _state);
   ae_vector_set_length(&c->c, 4 * (n - 1) + 2, _state);
   for (i = 0; i < n; i++) {
      c->x.xR[i] = x->xR[i];
   }
   for (i = 0; i < n - 1; i++) {
      c->c.xR[4 * i + 0] = y->xR[i];
      c->c.xR[4 * i + 1] = (y->xR[i + 1] - y->xR[i]) / (x->xR[i + 1] - x->xR[i]);
      c->c.xR[4 * i + 2] = 0.0;
      c->c.xR[4 * i + 3] = 0.0;
   }
   c->c.xR[4 * (n - 1) + 0] = y->xR[n - 1];
   c->c.xR[4 * (n - 1) + 1] = c->c.xR[4 * (n - 2) + 1];
   ae_frame_leave(_state);
}

// This subroutine builds Hermite spline interpolant.
//
// Inputs:
//     X           -   spline nodes, array[0..N-1]
//     Y           -   function values, array[0..N-1]
//     D           -   derivatives, array[0..N-1]
//     N           -   points count (optional):
//                     * N >= 2
//                     * if given, only first N points are used to build spline
//                     * if not given, automatically detected from X/Y sizes
//                       (len(X) must be equal to len(Y))
//
// Outputs:
//     C           -   spline interpolant.
//
//
// ORDER OF POINTS
//
// Subroutine automatically sorts points, so caller may pass unsorted array.
// ALGLIB Project: Copyright 23.06.2007 by Sergey Bochkanov
// API: void spline1dbuildhermite(const real_1d_array &x, const real_1d_array &y, const real_1d_array &d, const ae_int_t n, spline1dinterpolant &c, const xparams _xparams = xdefault);
// API: void spline1dbuildhermite(const real_1d_array &x, const real_1d_array &y, const real_1d_array &d, spline1dinterpolant &c, const xparams _xparams = xdefault);
void spline1dbuildhermite(RVector *x, RVector *y, RVector *d, ae_int_t n, spline1dinterpolant *c, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   double delta;
   double delta2;
   double delta3;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   DupVector(d, _state);
   SetObj(spline1dinterpolant, c);
   ae_assert(n >= 2, "Spline1DBuildHermite: N<2!", _state);
   ae_assert(x->cnt >= n, "Spline1DBuildHermite: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DBuildHermite: Length(Y)<N!", _state);
   ae_assert(d->cnt >= n, "Spline1DBuildHermite: Length(D)<N!", _state);
// check and sort points
   ae_assert(isfinitevector(x, n, _state), "Spline1DBuildHermite: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "Spline1DBuildHermite: Y contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(d, n, _state), "Spline1DBuildHermite: D contains infinite or NAN values!", _state);
   heapsortdpoints(x, y, d, n, _state);
   ae_assert(aredistinct(x, n, _state), "Spline1DBuildHermite: at least two consequent points are too close!", _state);
// Build
   ae_vector_set_length(&c->x, n, _state);
   ae_vector_set_length(&c->c, 4 * (n - 1) + 2, _state);
   c->periodic = false;
   c->k = 3;
   c->n = n;
   c->continuity = 1;
   for (i = 0; i < n; i++) {
      c->x.xR[i] = x->xR[i];
   }
   for (i = 0; i < n - 1; i++) {
      delta = x->xR[i + 1] - x->xR[i];
      delta2 = sqr(delta, _state);
      delta3 = delta * delta2;
      c->c.xR[4 * i + 0] = y->xR[i];
      c->c.xR[4 * i + 1] = d->xR[i];
      c->c.xR[4 * i + 2] = (3 * (y->xR[i + 1] - y->xR[i]) - 2 * d->xR[i] * delta - d->xR[i + 1] * delta) / delta2;
      c->c.xR[4 * i + 3] = (2 * (y->xR[i] - y->xR[i + 1]) + d->xR[i] * delta + d->xR[i + 1] * delta) / delta3;
   }
   c->c.xR[4 * (n - 1) + 0] = y->xR[n - 1];
   c->c.xR[4 * (n - 1) + 1] = d->xR[n - 1];
   ae_frame_leave(_state);
}

// This subroutine builds cubic spline interpolant.
//
// Inputs:
//     X           -   spline nodes, array[0..N-1].
//     Y           -   function values, array[0..N-1].
//
// Optional Parameters:
//     N           -   points count:
//                     * N >= 2
//                     * if given, only first N points are used to build spline
//                     * if not given, automatically detected from X/Y sizes
//                       (len(X) must be equal to len(Y))
//     BoundLType  -   boundary condition type for the left boundary
//     BoundL      -   left boundary condition (first or second derivative,
//                     depending on the BoundLType)
//     BoundRType  -   boundary condition type for the right boundary
//     BoundR      -   right boundary condition (first or second derivative,
//                     depending on the BoundRType)
//
// Outputs:
//     C           -   spline interpolant
//
// ORDER OF POINTS
//
// Subroutine automatically sorts points, so caller may pass unsorted array.
//
// SETTING BOUNDARY VALUES:
//
// The BoundLType/BoundRType parameters can have the following values:
//     * -1, which corresonds to the periodic (cyclic) boundary conditions.
//           In this case:
//           * both BoundLType and BoundRType must be equal to -1.
//           * BoundL/BoundR are ignored
//           * Y[last] is ignored (it is assumed to be equal to Y[first]).
//     *  0, which  corresponds  to  the  parabolically   terminated  spline
//           (BoundL and/or BoundR are ignored).
//     *  1, which corresponds to the first derivative boundary condition
//     *  2, which corresponds to the second derivative boundary condition
//     *  by default, BoundType=0 is used
//
// PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
//
// Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
// However, this subroutine doesn't require you to specify equal  values  for
// the first and last points - it automatically forces them  to  be  equal by
// copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
// Y[last_point]. However it is recommended to pass consistent values of Y[],
// i.e. to make Y[first_point]=Y[last_point].
// ALGLIB Project: Copyright 23.06.2007 by Sergey Bochkanov
// API: void spline1dbuildcubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t boundltype, const double boundl, const ae_int_t boundrtype, const double boundr, spline1dinterpolant &c, const xparams _xparams = xdefault);
// API: void spline1dbuildcubic(const real_1d_array &x, const real_1d_array &y, spline1dinterpolant &c, const xparams _xparams = xdefault);
void spline1dbuildcubic(RVector *x, RVector *y, ae_int_t n, ae_int_t boundltype, double boundl, ae_int_t boundrtype, double boundr, spline1dinterpolant *c, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t ylen;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   SetObj(spline1dinterpolant, c);
   NewVector(a1, 0, DT_REAL, _state);
   NewVector(a2, 0, DT_REAL, _state);
   NewVector(a3, 0, DT_REAL, _state);
   NewVector(b, 0, DT_REAL, _state);
   NewVector(dt, 0, DT_REAL, _state);
   NewVector(d, 0, DT_REAL, _state);
   NewVector(p, 0, DT_INT, _state);
// check correctness of boundary conditions
   ae_assert(((boundltype == -1 || boundltype == 0) || boundltype == 1) || boundltype == 2, "Spline1DBuildCubic: incorrect BoundLType!", _state);
   ae_assert(((boundrtype == -1 || boundrtype == 0) || boundrtype == 1) || boundrtype == 2, "Spline1DBuildCubic: incorrect BoundRType!", _state);
   ae_assert((boundrtype == -1 && boundltype == -1) || (boundrtype != -1 && boundltype != -1), "Spline1DBuildCubic: incorrect BoundLType/BoundRType!", _state);
   if (boundltype == 1 || boundltype == 2) {
      ae_assert(ae_isfinite(boundl, _state), "Spline1DBuildCubic: BoundL is infinite or NAN!", _state);
   }
   if (boundrtype == 1 || boundrtype == 2) {
      ae_assert(ae_isfinite(boundr, _state), "Spline1DBuildCubic: BoundR is infinite or NAN!", _state);
   }
// check lengths of arguments
   ae_assert(n >= 2, "Spline1DBuildCubic: N<2!", _state);
   ae_assert(x->cnt >= n, "Spline1DBuildCubic: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DBuildCubic: Length(Y)<N!", _state);
// check and sort points
   ylen = n;
   if (boundltype == -1) {
      ylen = n - 1;
   }
   ae_assert(isfinitevector(x, n, _state), "Spline1DBuildCubic: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, ylen, _state), "Spline1DBuildCubic: Y contains infinite or NAN values!", _state);
   spline1d_heapsortppoints(x, y, &p, n, _state);
   ae_assert(aredistinct(x, n, _state), "Spline1DBuildCubic: at least two consequent points are too close!", _state);
// Now we've checked and preordered everything,
// so we can call internal function to calculate derivatives,
// and then build Hermite spline using these derivatives
   if (boundltype == -1 || boundrtype == -1) {
      y->xR[n - 1] = y->xR[0];
   }
   spline1d_spline1dgriddiffcubicinternal(x, y, n, boundltype, boundl, boundrtype, boundr, &d, &a1, &a2, &a3, &b, &dt, _state);
   spline1dbuildhermite(x, y, &d, n, c, _state);
   c->periodic = boundltype == -1 || boundrtype == -1;
   c->continuity = 2;
   ae_frame_leave(_state);
}

// This subroutine builds Catmull-Rom spline interpolant.
//
// Inputs:
//     X           -   spline nodes, array[0..N-1].
//     Y           -   function values, array[0..N-1].
//
// Optional Parameters:
//     N           -   points count:
//                     * N >= 2
//                     * if given, only first N points are used to build spline
//                     * if not given, automatically detected from X/Y sizes
//                       (len(X) must be equal to len(Y))
//     BoundType   -   boundary condition type:
//                     * -1 for periodic boundary condition
//                     *  0 for parabolically terminated spline (default)
//     Tension     -   tension parameter:
//                     * tension=0   corresponds to classic Catmull-Rom spline (default)
//                     * 0<tension<1 corresponds to more general form - cardinal spline
//
// Outputs:
//     C           -   spline interpolant
//
//
// ORDER OF POINTS
//
// Subroutine automatically sorts points, so caller may pass unsorted array.
//
// PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
//
// Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
// However, this subroutine doesn't require you to specify equal  values  for
// the first and last points - it automatically forces them  to  be  equal by
// copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
// Y[last_point]. However it is recommended to pass consistent values of Y[],
// i.e. to make Y[first_point]=Y[last_point].
// ALGLIB Project: Copyright 23.06.2007 by Sergey Bochkanov
// API: void spline1dbuildcatmullrom(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t boundtype, const double tension, spline1dinterpolant &c, const xparams _xparams = xdefault);
// API: void spline1dbuildcatmullrom(const real_1d_array &x, const real_1d_array &y, spline1dinterpolant &c, const xparams _xparams = xdefault);
void spline1dbuildcatmullrom(RVector *x, RVector *y, ae_int_t n, ae_int_t boundtype, double tension, spline1dinterpolant *c, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   SetObj(spline1dinterpolant, c);
   NewVector(d, 0, DT_REAL, _state);
   ae_assert(n >= 2, "Spline1DBuildCatmullRom: N<2!", _state);
   ae_assert(boundtype == -1 || boundtype == 0, "Spline1DBuildCatmullRom: incorrect BoundType!", _state);
   ae_assert(tension >= 0.0, "Spline1DBuildCatmullRom: Tension<0!", _state);
   ae_assert(tension <= 1.0, "Spline1DBuildCatmullRom: Tension>1!", _state);
   ae_assert(x->cnt >= n, "Spline1DBuildCatmullRom: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DBuildCatmullRom: Length(Y)<N!", _state);
// check and sort points
   ae_assert(isfinitevector(x, n, _state), "Spline1DBuildCatmullRom: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "Spline1DBuildCatmullRom: Y contains infinite or NAN values!", _state);
   spline1d_heapsortpoints(x, y, n, _state);
   ae_assert(aredistinct(x, n, _state), "Spline1DBuildCatmullRom: at least two consequent points are too close!", _state);
// Special cases:
// * N=2, parabolic terminated boundary condition on both ends
// * N=2, periodic boundary condition
   if (n == 2 && boundtype == 0) {
   // Just linear spline
      spline1dbuildlinear(x, y, n, c, _state);
      ae_frame_leave(_state);
      return;
   }
   if (n == 2 && boundtype == -1) {
   // Same as cubic spline with periodic conditions
      spline1dbuildcubic(x, y, n, -1, 0.0, -1, 0.0, c, _state);
      ae_frame_leave(_state);
      return;
   }
// Periodic or non-periodic boundary conditions
   if (boundtype == -1) {
   // Periodic boundary conditions
      y->xR[n - 1] = y->xR[0];
      ae_vector_set_length(&d, n, _state);
      d.xR[0] = (y->xR[1] - y->xR[n - 2]) / (2 * (x->xR[1] - x->xR[0] + x->xR[n - 1] - x->xR[n - 2]));
      for (i = 1; i < n - 1; i++) {
         d.xR[i] = (1 - tension) * (y->xR[i + 1] - y->xR[i - 1]) / (x->xR[i + 1] - x->xR[i - 1]);
      }
      d.xR[n - 1] = d.xR[0];
   // Now problem is reduced to the cubic Hermite spline
      spline1dbuildhermite(x, y, &d, n, c, _state);
      c->periodic = true;
   } else {
   // Non-periodic boundary conditions
      ae_vector_set_length(&d, n, _state);
      for (i = 1; i < n - 1; i++) {
         d.xR[i] = (1 - tension) * (y->xR[i + 1] - y->xR[i - 1]) / (x->xR[i + 1] - x->xR[i - 1]);
      }
      d.xR[0] = 2 * (y->xR[1] - y->xR[0]) / (x->xR[1] - x->xR[0]) - d.xR[1];
      d.xR[n - 1] = 2 * (y->xR[n - 1] - y->xR[n - 2]) / (x->xR[n - 1] - x->xR[n - 2]) - d.xR[n - 2];
   // Now problem is reduced to the cubic Hermite spline
      spline1dbuildhermite(x, y, &d, n, c, _state);
   }
   ae_frame_leave(_state);
}

// This subroutine builds Akima spline interpolant
//
// Inputs:
//     X           -   spline nodes, array[0..N-1]
//     Y           -   function values, array[0..N-1]
//     N           -   points count (optional):
//                     * N >= 2
//                     * if given, only first N points are used to build spline
//                     * if not given, automatically detected from X/Y sizes
//                       (len(X) must be equal to len(Y))
//
// Outputs:
//     C           -   spline interpolant
//
//
// ORDER OF POINTS
//
// Subroutine automatically sorts points, so caller may pass unsorted array.
// ALGLIB Project: Copyright 24.06.2007 by Sergey Bochkanov
// API: void spline1dbuildakima(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, spline1dinterpolant &c, const xparams _xparams = xdefault);
// API: void spline1dbuildakima(const real_1d_array &x, const real_1d_array &y, spline1dinterpolant &c, const xparams _xparams = xdefault);
void spline1dbuildakima(RVector *x, RVector *y, ae_int_t n, spline1dinterpolant *c, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   SetObj(spline1dinterpolant, c);
   NewVector(d, 0, DT_REAL, _state);
   NewVector(w, 0, DT_REAL, _state);
   NewVector(diff, 0, DT_REAL, _state);
   ae_assert(n >= 2, "Spline1DBuildAkima: N<2!", _state);
   ae_assert(x->cnt >= n, "Spline1DBuildAkima: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DBuildAkima: Length(Y)<N!", _state);
// check and sort points
   ae_assert(isfinitevector(x, n, _state), "Spline1DBuildAkima: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "Spline1DBuildAkima: Y contains infinite or NAN values!", _state);
   spline1d_heapsortpoints(x, y, n, _state);
   ae_assert(aredistinct(x, n, _state), "Spline1DBuildAkima: at least two consequent points are too close!", _state);
// Handle special cases: N=2, N=3, N=4
   if (n <= 4) {
      spline1dbuildcubic(x, y, n, 0, 0.0, 0, 0.0, c, _state);
      ae_frame_leave(_state);
      return;
   }
// Prepare W (weights), Diff (divided differences)
   ae_vector_set_length(&w, n - 1, _state);
   ae_vector_set_length(&diff, n - 1, _state);
   for (i = 0; i < n - 1; i++) {
      diff.xR[i] = (y->xR[i + 1] - y->xR[i]) / (x->xR[i + 1] - x->xR[i]);
   }
   for (i = 1; i < n - 1; i++) {
      w.xR[i] = ae_fabs(diff.xR[i] - diff.xR[i - 1], _state);
   }
// Prepare Hermite interpolation scheme
   ae_vector_set_length(&d, n, _state);
   for (i = 2; i < n - 2; i++) {
      if (ae_fabs(w.xR[i - 1], _state) + ae_fabs(w.xR[i + 1], _state) != 0.0) {
         d.xR[i] = (w.xR[i + 1] * diff.xR[i - 1] + w.xR[i - 1] * diff.xR[i]) / (w.xR[i + 1] + w.xR[i - 1]);
      } else {
         d.xR[i] = ((x->xR[i + 1] - x->xR[i]) * diff.xR[i - 1] + (x->xR[i] - x->xR[i - 1]) * diff.xR[i]) / (x->xR[i + 1] - x->xR[i - 1]);
      }
   }
   d.xR[0] = spline1d_diffthreepoint(x->xR[0], x->xR[0], y->xR[0], x->xR[1], y->xR[1], x->xR[2], y->xR[2], _state);
   d.xR[1] = spline1d_diffthreepoint(x->xR[1], x->xR[0], y->xR[0], x->xR[1], y->xR[1], x->xR[2], y->xR[2], _state);
   d.xR[n - 2] = spline1d_diffthreepoint(x->xR[n - 2], x->xR[n - 3], y->xR[n - 3], x->xR[n - 2], y->xR[n - 2], x->xR[n - 1], y->xR[n - 1], _state);
   d.xR[n - 1] = spline1d_diffthreepoint(x->xR[n - 1], x->xR[n - 3], y->xR[n - 3], x->xR[n - 2], y->xR[n - 2], x->xR[n - 1], y->xR[n - 1], _state);
// Build Akima spline using Hermite interpolation scheme
   spline1dbuildhermite(x, y, &d, n, c, _state);
   ae_frame_leave(_state);
}

// This function builds monotone cubic Hermite interpolant. This interpolant
// is monotonic in [x(0),x(n-1)] and is constant outside of this interval.
//
// In  case  y[]  form  non-monotonic  sequence,  interpolant  is  piecewise
// monotonic.  Say, for x=(0,1,2,3,4)  and  y=(0,1,2,1,0)  interpolant  will
// monotonically grow at [0..2] and monotonically decrease at [2..4].
//
// Inputs:
//     X           -   spline nodes, array[0..N-1]. Subroutine automatically
//                     sorts points, so caller may pass unsorted array.
//     Y           -   function values, array[0..N-1]
//     N           -   the number of points(N >= 2).
//
// Outputs:
//     C           -   spline interpolant.
// ALGLIB Project: Copyright 21.06.2012 by Sergey Bochkanov
// API: void spline1dbuildmonotone(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, spline1dinterpolant &c, const xparams _xparams = xdefault);
// API: void spline1dbuildmonotone(const real_1d_array &x, const real_1d_array &y, spline1dinterpolant &c, const xparams _xparams = xdefault);
void spline1dbuildmonotone(RVector *x, RVector *y, ae_int_t n, spline1dinterpolant *c, ae_state *_state) {
   ae_frame _frame_block;
   double delta;
   double alpha;
   double beta;
   ae_int_t tmpn;
   ae_int_t sn;
   double ca;
   double cb;
   double epsilon;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   SetObj(spline1dinterpolant, c);
   NewVector(d, 0, DT_REAL, _state);
   NewVector(ex, 0, DT_REAL, _state);
   NewVector(ey, 0, DT_REAL, _state);
   NewVector(p, 0, DT_INT, _state);
// Check lengths of arguments
   ae_assert(n >= 2, "Spline1DBuildMonotone: N<2", _state);
   ae_assert(x->cnt >= n, "Spline1DBuildMonotone: Length(X)<N", _state);
   ae_assert(y->cnt >= n, "Spline1DBuildMonotone: Length(Y)<N", _state);
// Check and sort points
   ae_assert(isfinitevector(x, n, _state), "Spline1DBuildMonotone: X contains infinite or NAN values", _state);
   ae_assert(isfinitevector(y, n, _state), "Spline1DBuildMonotone: Y contains infinite or NAN values", _state);
   spline1d_heapsortppoints(x, y, &p, n, _state);
   ae_assert(aredistinct(x, n, _state), "Spline1DBuildMonotone: at least two consequent points are too close", _state);
   epsilon = machineepsilon;
   n += 2;
   ae_vector_set_length(&d, n, _state);
   ae_vector_set_length(&ex, n, _state);
   ae_vector_set_length(&ey, n, _state);
   ex.xR[0] = x->xR[0] - ae_fabs(x->xR[1] - x->xR[0], _state);
   ex.xR[n - 1] = x->xR[n - 3] + ae_fabs(x->xR[n - 3] - x->xR[n - 4], _state);
   ey.xR[0] = y->xR[0];
   ey.xR[n - 1] = y->xR[n - 3];
   for (i = 1; i < n - 1; i++) {
      ex.xR[i] = x->xR[i - 1];
      ey.xR[i] = y->xR[i - 1];
   }
// Init sign of the function for first segment
   i = 0;
   ca = 0.0;
   do {
      ca = ey.xR[i + 1] - ey.xR[i];
      i++;
   } while (!(ca != 0.0 || i > n - 2));
   if (ca != 0.0) {
      ca /= ae_fabs(ca, _state);
   }
   i = 0;
   while (i < n - 1) {
   // Partition of the segment [X0;Xn]
      tmpn = 1;
      for (j = i; j < n - 1; j++) {
         cb = ey.xR[j + 1] - ey.xR[j];
         if (ca * cb >= 0.0) {
            tmpn++;
         } else {
            ca = cb / ae_fabs(cb, _state);
            break;
         }
      }
      sn = i + tmpn;
      ae_assert(tmpn >= 2, "Spline1DBuildMonotone: internal error", _state);
   // Calculate derivatives for current segment
      d.xR[i] = 0.0;
      d.xR[sn - 1] = 0.0;
      for (j = i + 1; j < sn - 1; j++) {
         d.xR[j] = ((ey.xR[j] - ey.xR[j - 1]) / (ex.xR[j] - ex.xR[j - 1]) + (ey.xR[j + 1] - ey.xR[j]) / (ex.xR[j + 1] - ex.xR[j])) / 2;
      }
      for (j = i; j < sn - 1; j++) {
         delta = (ey.xR[j + 1] - ey.xR[j]) / (ex.xR[j + 1] - ex.xR[j]);
         if (ae_fabs(delta, _state) <= epsilon) {
            d.xR[j] = 0.0;
            d.xR[j + 1] = 0.0;
         } else {
            alpha = d.xR[j] / delta;
            beta = d.xR[j + 1] / delta;
            if (alpha != 0.0) {
               cb = alpha * ae_sqrt(1 + sqr(beta / alpha, _state), _state);
            } else {
               if (beta != 0.0) {
                  cb = beta;
               } else {
                  continue;
               }
            }
            if (cb > 3.0) {
               d.xR[j] = 3 * alpha * delta / cb;
               d.xR[j + 1] = 3 * beta * delta / cb;
            }
         }
      }
   // Transition to next segment
      i = sn - 1;
   }
   spline1dbuildhermite(&ex, &ey, &d, n, c, _state);
   c->continuity = 2;
   ae_frame_leave(_state);
}

// This function solves following problem: given table y[] of function values
// at nodes x[], it calculates and returns table of function derivatives  d[]
// (calculated at the same nodes x[]).
//
// This function yields same result as Spline1DBuildCubic() call followed  by
// sequence of Spline1DDiff() calls, but it can be several times faster  when
// called for ordered X[] and X2[].
//
// Inputs:
//     X           -   spline nodes
//     Y           -   function values
//
// Optional Parameters:
//     N           -   points count:
//                     * N >= 2
//                     * if given, only first N points are used
//                     * if not given, automatically detected from X/Y sizes
//                       (len(X) must be equal to len(Y))
//     BoundLType  -   boundary condition type for the left boundary
//     BoundL      -   left boundary condition (first or second derivative,
//                     depending on the BoundLType)
//     BoundRType  -   boundary condition type for the right boundary
//     BoundR      -   right boundary condition (first or second derivative,
//                     depending on the BoundRType)
//
// Outputs:
//     D           -   derivative values at X[]
//
// ORDER OF POINTS
//
// Subroutine automatically sorts points, so caller may pass unsorted array.
// Derivative values are correctly reordered on return, so  D[I]  is  always
// equal to S'(X[I]) independently of points order.
//
// SETTING BOUNDARY VALUES:
//
// The BoundLType/BoundRType parameters can have the following values:
//     * -1, which corresonds to the periodic (cyclic) boundary conditions.
//           In this case:
//           * both BoundLType and BoundRType must be equal to -1.
//           * BoundL/BoundR are ignored
//           * Y[last] is ignored (it is assumed to be equal to Y[first]).
//     *  0, which  corresponds  to  the  parabolically   terminated  spline
//           (BoundL and/or BoundR are ignored).
//     *  1, which corresponds to the first derivative boundary condition
//     *  2, which corresponds to the second derivative boundary condition
//     *  by default, BoundType=0 is used
//
// PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
//
// Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
// However, this subroutine doesn't require you to specify equal  values  for
// the first and last points - it automatically forces them  to  be  equal by
// copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
// Y[last_point]. However it is recommended to pass consistent values of Y[],
// i.e. to make Y[first_point]=Y[last_point].
// ALGLIB Project: Copyright 03.09.2010 by Sergey Bochkanov
// API: void spline1dgriddiffcubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t boundltype, const double boundl, const ae_int_t boundrtype, const double boundr, real_1d_array &d, const xparams _xparams = xdefault);
// API: void spline1dgriddiffcubic(const real_1d_array &x, const real_1d_array &y, real_1d_array &d, const xparams _xparams = xdefault);
void spline1dgriddiffcubic(RVector *x, RVector *y, ae_int_t n, ae_int_t boundltype, double boundl, ae_int_t boundrtype, double boundr, RVector *d, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t ylen;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   SetVector(d);
   NewVector(a1, 0, DT_REAL, _state);
   NewVector(a2, 0, DT_REAL, _state);
   NewVector(a3, 0, DT_REAL, _state);
   NewVector(b, 0, DT_REAL, _state);
   NewVector(dt, 0, DT_REAL, _state);
   NewVector(p, 0, DT_INT, _state);
// check correctness of boundary conditions
   ae_assert(((boundltype == -1 || boundltype == 0) || boundltype == 1) || boundltype == 2, "Spline1DGridDiffCubic: incorrect BoundLType!", _state);
   ae_assert(((boundrtype == -1 || boundrtype == 0) || boundrtype == 1) || boundrtype == 2, "Spline1DGridDiffCubic: incorrect BoundRType!", _state);
   ae_assert((boundrtype == -1 && boundltype == -1) || (boundrtype != -1 && boundltype != -1), "Spline1DGridDiffCubic: incorrect BoundLType/BoundRType!", _state);
   if (boundltype == 1 || boundltype == 2) {
      ae_assert(ae_isfinite(boundl, _state), "Spline1DGridDiffCubic: BoundL is infinite or NAN!", _state);
   }
   if (boundrtype == 1 || boundrtype == 2) {
      ae_assert(ae_isfinite(boundr, _state), "Spline1DGridDiffCubic: BoundR is infinite or NAN!", _state);
   }
// check lengths of arguments
   ae_assert(n >= 2, "Spline1DGridDiffCubic: N<2!", _state);
   ae_assert(x->cnt >= n, "Spline1DGridDiffCubic: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DGridDiffCubic: Length(Y)<N!", _state);
// check and sort points
   ylen = n;
   if (boundltype == -1) {
      ylen = n - 1;
   }
   ae_assert(isfinitevector(x, n, _state), "Spline1DGridDiffCubic: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, ylen, _state), "Spline1DGridDiffCubic: Y contains infinite or NAN values!", _state);
   spline1d_heapsortppoints(x, y, &p, n, _state);
   ae_assert(aredistinct(x, n, _state), "Spline1DGridDiffCubic: at least two consequent points are too close!", _state);
// Now we've checked and preordered everything,
// so we can call internal function.
   spline1d_spline1dgriddiffcubicinternal(x, y, n, boundltype, boundl, boundrtype, boundr, d, &a1, &a2, &a3, &b, &dt, _state);
// Remember that HeapSortPPoints() call?
// Now we have to reorder them back.
   if (dt.cnt < n) {
      ae_vector_set_length(&dt, n, _state);
   }
   for (i = 0; i < n; i++) {
      dt.xR[p.xZ[i]] = d->xR[i];
   }
   ae_v_move(d->xR, 1, dt.xR, 1, n);
   ae_frame_leave(_state);
}

// This function solves following problem: given table y[] of function values
// at  nodes  x[],  it  calculates  and  returns  tables  of first and second
// function derivatives d1[] and d2[] (calculated at the same nodes x[]).
//
// This function yields same result as Spline1DBuildCubic() call followed  by
// sequence of Spline1DDiff() calls, but it can be several times faster  when
// called for ordered X[] and X2[].
//
// Inputs:
//     X           -   spline nodes
//     Y           -   function values
//
// Optional Parameters:
//     N           -   points count:
//                     * N >= 2
//                     * if given, only first N points are used
//                     * if not given, automatically detected from X/Y sizes
//                       (len(X) must be equal to len(Y))
//     BoundLType  -   boundary condition type for the left boundary
//     BoundL      -   left boundary condition (first or second derivative,
//                     depending on the BoundLType)
//     BoundRType  -   boundary condition type for the right boundary
//     BoundR      -   right boundary condition (first or second derivative,
//                     depending on the BoundRType)
//
// Outputs:
//     D1          -   S' values at X[]
//     D2          -   S'' values at X[]
//
// ORDER OF POINTS
//
// Subroutine automatically sorts points, so caller may pass unsorted array.
// Derivative values are correctly reordered on return, so  D[I]  is  always
// equal to S'(X[I]) independently of points order.
//
// SETTING BOUNDARY VALUES:
//
// The BoundLType/BoundRType parameters can have the following values:
//     * -1, which corresonds to the periodic (cyclic) boundary conditions.
//           In this case:
//           * both BoundLType and BoundRType must be equal to -1.
//           * BoundL/BoundR are ignored
//           * Y[last] is ignored (it is assumed to be equal to Y[first]).
//     *  0, which  corresponds  to  the  parabolically   terminated  spline
//           (BoundL and/or BoundR are ignored).
//     *  1, which corresponds to the first derivative boundary condition
//     *  2, which corresponds to the second derivative boundary condition
//     *  by default, BoundType=0 is used
//
// PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
//
// Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
// However, this subroutine doesn't require you to specify equal  values  for
// the first and last points - it automatically forces them  to  be  equal by
// copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
// Y[last_point]. However it is recommended to pass consistent values of Y[],
// i.e. to make Y[first_point]=Y[last_point].
// ALGLIB Project: Copyright 03.09.2010 by Sergey Bochkanov
// API: void spline1dgriddiff2cubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t boundltype, const double boundl, const ae_int_t boundrtype, const double boundr, real_1d_array &d1, real_1d_array &d2, const xparams _xparams = xdefault);
// API: void spline1dgriddiff2cubic(const real_1d_array &x, const real_1d_array &y, real_1d_array &d1, real_1d_array &d2, const xparams _xparams = xdefault);
void spline1dgriddiff2cubic(RVector *x, RVector *y, ae_int_t n, ae_int_t boundltype, double boundl, ae_int_t boundrtype, double boundr, RVector *d1, RVector *d2, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t ylen;
   double delta;
   double delta2;
   double delta3;
   double s2;
   double s3;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   SetVector(d1);
   SetVector(d2);
   NewVector(a1, 0, DT_REAL, _state);
   NewVector(a2, 0, DT_REAL, _state);
   NewVector(a3, 0, DT_REAL, _state);
   NewVector(b, 0, DT_REAL, _state);
   NewVector(dt, 0, DT_REAL, _state);
   NewVector(p, 0, DT_INT, _state);
// check correctness of boundary conditions
   ae_assert(((boundltype == -1 || boundltype == 0) || boundltype == 1) || boundltype == 2, "Spline1DGridDiff2Cubic: incorrect BoundLType!", _state);
   ae_assert(((boundrtype == -1 || boundrtype == 0) || boundrtype == 1) || boundrtype == 2, "Spline1DGridDiff2Cubic: incorrect BoundRType!", _state);
   ae_assert((boundrtype == -1 && boundltype == -1) || (boundrtype != -1 && boundltype != -1), "Spline1DGridDiff2Cubic: incorrect BoundLType/BoundRType!", _state);
   if (boundltype == 1 || boundltype == 2) {
      ae_assert(ae_isfinite(boundl, _state), "Spline1DGridDiff2Cubic: BoundL is infinite or NAN!", _state);
   }
   if (boundrtype == 1 || boundrtype == 2) {
      ae_assert(ae_isfinite(boundr, _state), "Spline1DGridDiff2Cubic: BoundR is infinite or NAN!", _state);
   }
// check lengths of arguments
   ae_assert(n >= 2, "Spline1DGridDiff2Cubic: N<2!", _state);
   ae_assert(x->cnt >= n, "Spline1DGridDiff2Cubic: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DGridDiff2Cubic: Length(Y)<N!", _state);
// check and sort points
   ylen = n;
   if (boundltype == -1) {
      ylen = n - 1;
   }
   ae_assert(isfinitevector(x, n, _state), "Spline1DGridDiff2Cubic: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, ylen, _state), "Spline1DGridDiff2Cubic: Y contains infinite or NAN values!", _state);
   spline1d_heapsortppoints(x, y, &p, n, _state);
   ae_assert(aredistinct(x, n, _state), "Spline1DGridDiff2Cubic: at least two consequent points are too close!", _state);
// Now we've checked and preordered everything,
// so we can call internal function.
//
// After this call we will calculate second derivatives
// (manually, by converting to the power basis)
   spline1d_spline1dgriddiffcubicinternal(x, y, n, boundltype, boundl, boundrtype, boundr, d1, &a1, &a2, &a3, &b, &dt, _state);
   ae_vector_set_length(d2, n, _state);
   delta = 0.0;
   s2 = 0.0;
   s3 = 0.0;
   for (i = 0; i < n - 1; i++) {
   // We convert from Hermite basis to the power basis.
   // Si is coefficient before x^i.
   //
   // Inside this cycle we need just S2,
   // because we calculate S'' exactly at spline node,
   // (only x^2 matters at x=0), but after iterations
   // will be over, we will need other coefficients
   // to calculate spline value at the last node.
      delta = x->xR[i + 1] - x->xR[i];
      delta2 = sqr(delta, _state);
      delta3 = delta * delta2;
      s2 = (3 * (y->xR[i + 1] - y->xR[i]) - 2 * d1->xR[i] * delta - d1->xR[i + 1] * delta) / delta2;
      s3 = (2 * (y->xR[i] - y->xR[i + 1]) + d1->xR[i] * delta + d1->xR[i + 1] * delta) / delta3;
      d2->xR[i] = 2 * s2;
   }
   d2->xR[n - 1] = 2 * s2 + 6 * s3 * delta;
// Remember that HeapSortPPoints() call?
// Now we have to reorder them back.
   if (dt.cnt < n) {
      ae_vector_set_length(&dt, n, _state);
   }
   for (i = 0; i < n; i++) {
      dt.xR[p.xZ[i]] = d1->xR[i];
   }
   ae_v_move(d1->xR, 1, dt.xR, 1, n);
   for (i = 0; i < n; i++) {
      dt.xR[p.xZ[i]] = d2->xR[i];
   }
   ae_v_move(d2->xR, 1, dt.xR, 1, n);
   ae_frame_leave(_state);
}

// Internal version of Spline1DConvDiff
//
// Converts from Hermite spline given by grid XOld to new grid X2
//
// Inputs:
//     XOld    -   old grid
//     YOld    -   values at old grid
//     DOld    -   first derivative at old grid
//     N       -   grid size
//     X2      -   new grid
//     N2      -   new grid size
//     Y       -   possibly preallocated output array
//                 (reallocate if too small)
//     NeedY   -   do we need Y?
//     D1      -   possibly preallocated output array
//                 (reallocate if too small)
//     NeedD1  -   do we need D1?
//     D2      -   possibly preallocated output array
//                 (reallocate if too small)
//     NeedD2  -   do we need D1?
//
// OUTPUT ARRAYS:
//     Y       -   values, if needed
//     D1      -   first derivative, if needed
//     D2      -   second derivative, if needed
// ALGLIB Project: Copyright 03.09.2010 by Sergey Bochkanov
void spline1dconvdiffinternal(RVector *xold, RVector *yold, RVector *dold, ae_int_t n, RVector *x2, ae_int_t n2, RVector *y, bool needy, RVector *d1, bool needd1, RVector *d2, bool needd2, ae_state *_state) {
   ae_int_t intervalindex;
   ae_int_t pointindex;
   bool havetoadvance;
   double c0;
   double c1;
   double c2;
   double c3;
   double a;
   double b;
   double w;
   double w2;
   double w3;
   double fa;
   double fb;
   double da;
   double db;
   double t;
// Prepare space
   if (needy && y->cnt < n2) {
      ae_vector_set_length(y, n2, _state);
   }
   if (needd1 && d1->cnt < n2) {
      ae_vector_set_length(d1, n2, _state);
   }
   if (needd2 && d2->cnt < n2) {
      ae_vector_set_length(d2, n2, _state);
   }
// These assignments aren't actually needed
// (variables are initialized in the loop below),
// but without them compiler will complain about uninitialized locals
   c0 = 0.0;
   c1 = 0.0;
   c2 = 0.0;
   c3 = 0.0;
   a = 0.0;
   b = 0.0;
// Cycle
   intervalindex = -1;
   pointindex = 0;
   while (true) {
   // are we ready to exit?
      if (pointindex >= n2) {
         break;
      }
      t = x2->xR[pointindex];
   // do we need to advance interval?
      havetoadvance = false;
      if (intervalindex == -1) {
         havetoadvance = true;
      } else {
         if (intervalindex < n - 2) {
            havetoadvance = t >= b;
         }
      }
      if (havetoadvance) {
         intervalindex++;
         a = xold->xR[intervalindex];
         b = xold->xR[intervalindex + 1];
         w = b - a;
         w2 = w * w;
         w3 = w * w2;
         fa = yold->xR[intervalindex];
         fb = yold->xR[intervalindex + 1];
         da = dold->xR[intervalindex];
         db = dold->xR[intervalindex + 1];
         c0 = fa;
         c1 = da;
         c2 = (3 * (fb - fa) - 2 * da * w - db * w) / w2;
         c3 = (2 * (fa - fb) + da * w + db * w) / w3;
         continue;
      }
   // Calculate spline and its derivatives using power basis
      t -= a;
      if (needy) {
         y->xR[pointindex] = c0 + t * (c1 + t * (c2 + t * c3));
      }
      if (needd1) {
         d1->xR[pointindex] = c1 + 2 * t * c2 + 3 * t * t * c3;
      }
      if (needd2) {
         d2->xR[pointindex] = 2 * c2 + 6 * t * c3;
      }
      pointindex++;
   }
}

// This function solves following problem: given table y[] of function values
// at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
// function values y2[] (calculated at x2[]).
//
// This function yields same result as Spline1DBuildCubic() call followed  by
// sequence of Spline1DDiff() calls, but it can be several times faster  when
// called for ordered X[] and X2[].
//
// Inputs:
//     X           -   old spline nodes
//     Y           -   function values
//     X2           -  new spline nodes
//
// Optional Parameters:
//     N           -   points count:
//                     * N >= 2
//                     * if given, only first N points from X/Y are used
//                     * if not given, automatically detected from X/Y sizes
//                       (len(X) must be equal to len(Y))
//     BoundLType  -   boundary condition type for the left boundary
//     BoundL      -   left boundary condition (first or second derivative,
//                     depending on the BoundLType)
//     BoundRType  -   boundary condition type for the right boundary
//     BoundR      -   right boundary condition (first or second derivative,
//                     depending on the BoundRType)
//     N2          -   new points count:
//                     * N2 >= 2
//                     * if given, only first N2 points from X2 are used
//                     * if not given, automatically detected from X2 size
//
// Outputs:
//     F2          -   function values at X2[]
//
// ORDER OF POINTS
//
// Subroutine automatically sorts points, so caller  may pass unsorted array.
// Function  values  are correctly reordered on  return, so F2[I]  is  always
// equal to S(X2[I]) independently of points order.
//
// SETTING BOUNDARY VALUES:
//
// The BoundLType/BoundRType parameters can have the following values:
//     * -1, which corresonds to the periodic (cyclic) boundary conditions.
//           In this case:
//           * both BoundLType and BoundRType must be equal to -1.
//           * BoundL/BoundR are ignored
//           * Y[last] is ignored (it is assumed to be equal to Y[first]).
//     *  0, which  corresponds  to  the  parabolically   terminated  spline
//           (BoundL and/or BoundR are ignored).
//     *  1, which corresponds to the first derivative boundary condition
//     *  2, which corresponds to the second derivative boundary condition
//     *  by default, BoundType=0 is used
//
// PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
//
// Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
// However, this subroutine doesn't require you to specify equal  values  for
// the first and last points - it automatically forces them  to  be  equal by
// copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
// Y[last_point]. However it is recommended to pass consistent values of Y[],
// i.e. to make Y[first_point]=Y[last_point].
// ALGLIB Project: Copyright 03.09.2010 by Sergey Bochkanov
// API: void spline1dconvcubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t boundltype, const double boundl, const ae_int_t boundrtype, const double boundr, const real_1d_array &x2, const ae_int_t n2, real_1d_array &y2, const xparams _xparams = xdefault);
// API: void spline1dconvcubic(const real_1d_array &x, const real_1d_array &y, const real_1d_array &x2, real_1d_array &y2, const xparams _xparams = xdefault);
void spline1dconvcubic(RVector *x, RVector *y, ae_int_t n, ae_int_t boundltype, double boundl, ae_int_t boundrtype, double boundr, RVector *x2, ae_int_t n2, RVector *y2, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t ylen;
   double t;
   double t2;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   DupVector(x2, _state);
   SetVector(y2);
   NewVector(a1, 0, DT_REAL, _state);
   NewVector(a2, 0, DT_REAL, _state);
   NewVector(a3, 0, DT_REAL, _state);
   NewVector(b, 0, DT_REAL, _state);
   NewVector(d, 0, DT_REAL, _state);
   NewVector(dt, 0, DT_REAL, _state);
   NewVector(d1, 0, DT_REAL, _state);
   NewVector(d2, 0, DT_REAL, _state);
   NewVector(p, 0, DT_INT, _state);
   NewVector(p2, 0, DT_INT, _state);
// check correctness of boundary conditions
   ae_assert(((boundltype == -1 || boundltype == 0) || boundltype == 1) || boundltype == 2, "Spline1DConvCubic: incorrect BoundLType!", _state);
   ae_assert(((boundrtype == -1 || boundrtype == 0) || boundrtype == 1) || boundrtype == 2, "Spline1DConvCubic: incorrect BoundRType!", _state);
   ae_assert((boundrtype == -1 && boundltype == -1) || (boundrtype != -1 && boundltype != -1), "Spline1DConvCubic: incorrect BoundLType/BoundRType!", _state);
   if (boundltype == 1 || boundltype == 2) {
      ae_assert(ae_isfinite(boundl, _state), "Spline1DConvCubic: BoundL is infinite or NAN!", _state);
   }
   if (boundrtype == 1 || boundrtype == 2) {
      ae_assert(ae_isfinite(boundr, _state), "Spline1DConvCubic: BoundR is infinite or NAN!", _state);
   }
// check lengths of arguments
   ae_assert(n >= 2, "Spline1DConvCubic: N<2!", _state);
   ae_assert(x->cnt >= n, "Spline1DConvCubic: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DConvCubic: Length(Y)<N!", _state);
   ae_assert(n2 >= 2, "Spline1DConvCubic: N2<2!", _state);
   ae_assert(x2->cnt >= n2, "Spline1DConvCubic: Length(X2)<N2!", _state);
// check and sort X/Y
   ylen = n;
   if (boundltype == -1) {
      ylen = n - 1;
   }
   ae_assert(isfinitevector(x, n, _state), "Spline1DConvCubic: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, ylen, _state), "Spline1DConvCubic: Y contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(x2, n2, _state), "Spline1DConvCubic: X2 contains infinite or NAN values!", _state);
   spline1d_heapsortppoints(x, y, &p, n, _state);
   ae_assert(aredistinct(x, n, _state), "Spline1DConvCubic: at least two consequent points are too close!", _state);
// set up DT (we will need it below)
   ae_vector_set_length(&dt, maxint(n, n2, _state), _state);
// sort X2:
// * use fake array DT because HeapSortPPoints() needs both integer AND real arrays
// * if we have periodic problem, wrap points
// * sort them, store permutation at P2
   if (boundrtype == -1 && boundltype == -1) {
      for (i = 0; i < n2; i++) {
         t = x2->xR[i];
         apperiodicmap(&t, x->xR[0], x->xR[n - 1], &t2, _state);
         x2->xR[i] = t;
      }
   }
   spline1d_heapsortppoints(x2, &dt, &p2, n2, _state);
// Now we've checked and preordered everything, so we:
// * call internal GridDiff() function to get Hermite form of spline
// * convert using internal Conv() function
// * convert Y2 back to original order
   spline1d_spline1dgriddiffcubicinternal(x, y, n, boundltype, boundl, boundrtype, boundr, &d, &a1, &a2, &a3, &b, &dt, _state);
   spline1dconvdiffinternal(x, y, &d, n, x2, n2, y2, true, &d1, false, &d2, false, _state);
   ae_assert(dt.cnt >= n2, "Spline1DConvCubic: internal error!", _state);
   for (i = 0; i < n2; i++) {
      dt.xR[p2.xZ[i]] = y2->xR[i];
   }
   ae_v_move(y2->xR, 1, dt.xR, 1, n2);
   ae_frame_leave(_state);
}

// This function solves following problem: given table y[] of function values
// at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
// function values y2[] and derivatives d2[] (calculated at x2[]).
//
// This function yields same result as Spline1DBuildCubic() call followed  by
// sequence of Spline1DDiff() calls, but it can be several times faster  when
// called for ordered X[] and X2[].
//
// Inputs:
//     X           -   old spline nodes
//     Y           -   function values
//     X2           -  new spline nodes
//
// Optional Parameters:
//     N           -   points count:
//                     * N >= 2
//                     * if given, only first N points from X/Y are used
//                     * if not given, automatically detected from X/Y sizes
//                       (len(X) must be equal to len(Y))
//     BoundLType  -   boundary condition type for the left boundary
//     BoundL      -   left boundary condition (first or second derivative,
//                     depending on the BoundLType)
//     BoundRType  -   boundary condition type for the right boundary
//     BoundR      -   right boundary condition (first or second derivative,
//                     depending on the BoundRType)
//     N2          -   new points count:
//                     * N2 >= 2
//                     * if given, only first N2 points from X2 are used
//                     * if not given, automatically detected from X2 size
//
// Outputs:
//     F2          -   function values at X2[]
//     D2          -   first derivatives at X2[]
//
// ORDER OF POINTS
//
// Subroutine automatically sorts points, so caller  may pass unsorted array.
// Function  values  are correctly reordered on  return, so F2[I]  is  always
// equal to S(X2[I]) independently of points order.
//
// SETTING BOUNDARY VALUES:
//
// The BoundLType/BoundRType parameters can have the following values:
//     * -1, which corresonds to the periodic (cyclic) boundary conditions.
//           In this case:
//           * both BoundLType and BoundRType must be equal to -1.
//           * BoundL/BoundR are ignored
//           * Y[last] is ignored (it is assumed to be equal to Y[first]).
//     *  0, which  corresponds  to  the  parabolically   terminated  spline
//           (BoundL and/or BoundR are ignored).
//     *  1, which corresponds to the first derivative boundary condition
//     *  2, which corresponds to the second derivative boundary condition
//     *  by default, BoundType=0 is used
//
// PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
//
// Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
// However, this subroutine doesn't require you to specify equal  values  for
// the first and last points - it automatically forces them  to  be  equal by
// copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
// Y[last_point]. However it is recommended to pass consistent values of Y[],
// i.e. to make Y[first_point]=Y[last_point].
// ALGLIB Project: Copyright 03.09.2010 by Sergey Bochkanov
// API: void spline1dconvdiffcubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t boundltype, const double boundl, const ae_int_t boundrtype, const double boundr, const real_1d_array &x2, const ae_int_t n2, real_1d_array &y2, real_1d_array &d2, const xparams _xparams = xdefault);
// API: void spline1dconvdiffcubic(const real_1d_array &x, const real_1d_array &y, const real_1d_array &x2, real_1d_array &y2, real_1d_array &d2, const xparams _xparams = xdefault);
void spline1dconvdiffcubic(RVector *x, RVector *y, ae_int_t n, ae_int_t boundltype, double boundl, ae_int_t boundrtype, double boundr, RVector *x2, ae_int_t n2, RVector *y2, RVector *d2, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t ylen;
   double t;
   double t2;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   DupVector(x2, _state);
   SetVector(y2);
   SetVector(d2);
   NewVector(a1, 0, DT_REAL, _state);
   NewVector(a2, 0, DT_REAL, _state);
   NewVector(a3, 0, DT_REAL, _state);
   NewVector(b, 0, DT_REAL, _state);
   NewVector(d, 0, DT_REAL, _state);
   NewVector(dt, 0, DT_REAL, _state);
   NewVector(rt1, 0, DT_REAL, _state);
   NewVector(p, 0, DT_INT, _state);
   NewVector(p2, 0, DT_INT, _state);
// check correctness of boundary conditions
   ae_assert(((boundltype == -1 || boundltype == 0) || boundltype == 1) || boundltype == 2, "Spline1DConvDiffCubic: incorrect BoundLType!", _state);
   ae_assert(((boundrtype == -1 || boundrtype == 0) || boundrtype == 1) || boundrtype == 2, "Spline1DConvDiffCubic: incorrect BoundRType!", _state);
   ae_assert((boundrtype == -1 && boundltype == -1) || (boundrtype != -1 && boundltype != -1), "Spline1DConvDiffCubic: incorrect BoundLType/BoundRType!", _state);
   if (boundltype == 1 || boundltype == 2) {
      ae_assert(ae_isfinite(boundl, _state), "Spline1DConvDiffCubic: BoundL is infinite or NAN!", _state);
   }
   if (boundrtype == 1 || boundrtype == 2) {
      ae_assert(ae_isfinite(boundr, _state), "Spline1DConvDiffCubic: BoundR is infinite or NAN!", _state);
   }
// check lengths of arguments
   ae_assert(n >= 2, "Spline1DConvDiffCubic: N<2!", _state);
   ae_assert(x->cnt >= n, "Spline1DConvDiffCubic: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DConvDiffCubic: Length(Y)<N!", _state);
   ae_assert(n2 >= 2, "Spline1DConvDiffCubic: N2<2!", _state);
   ae_assert(x2->cnt >= n2, "Spline1DConvDiffCubic: Length(X2)<N2!", _state);
// check and sort X/Y
   ylen = n;
   if (boundltype == -1) {
      ylen = n - 1;
   }
   ae_assert(isfinitevector(x, n, _state), "Spline1DConvDiffCubic: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, ylen, _state), "Spline1DConvDiffCubic: Y contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(x2, n2, _state), "Spline1DConvDiffCubic: X2 contains infinite or NAN values!", _state);
   spline1d_heapsortppoints(x, y, &p, n, _state);
   ae_assert(aredistinct(x, n, _state), "Spline1DConvDiffCubic: at least two consequent points are too close!", _state);
// set up DT (we will need it below)
   ae_vector_set_length(&dt, maxint(n, n2, _state), _state);
// sort X2:
// * use fake array DT because HeapSortPPoints() needs both integer AND real arrays
// * if we have periodic problem, wrap points
// * sort them, store permutation at P2
   if (boundrtype == -1 && boundltype == -1) {
      for (i = 0; i < n2; i++) {
         t = x2->xR[i];
         apperiodicmap(&t, x->xR[0], x->xR[n - 1], &t2, _state);
         x2->xR[i] = t;
      }
   }
   spline1d_heapsortppoints(x2, &dt, &p2, n2, _state);
// Now we've checked and preordered everything, so we:
// * call internal GridDiff() function to get Hermite form of spline
// * convert using internal Conv() function
// * convert Y2 back to original order
   spline1d_spline1dgriddiffcubicinternal(x, y, n, boundltype, boundl, boundrtype, boundr, &d, &a1, &a2, &a3, &b, &dt, _state);
   spline1dconvdiffinternal(x, y, &d, n, x2, n2, y2, true, d2, true, &rt1, false, _state);
   ae_assert(dt.cnt >= n2, "Spline1DConvDiffCubic: internal error!", _state);
   for (i = 0; i < n2; i++) {
      dt.xR[p2.xZ[i]] = y2->xR[i];
   }
   ae_v_move(y2->xR, 1, dt.xR, 1, n2);
   for (i = 0; i < n2; i++) {
      dt.xR[p2.xZ[i]] = d2->xR[i];
   }
   ae_v_move(d2->xR, 1, dt.xR, 1, n2);
   ae_frame_leave(_state);
}

// This function solves following problem: given table y[] of function values
// at old nodes x[]  and new nodes  x2[],  it calculates and returns table of
// function  values  y2[],  first  and  second  derivatives  d2[]  and  dd2[]
// (calculated at x2[]).
//
// This function yields same result as Spline1DBuildCubic() call followed  by
// sequence of Spline1DDiff() calls, but it can be several times faster  when
// called for ordered X[] and X2[].
//
// Inputs:
//     X           -   old spline nodes
//     Y           -   function values
//     X2           -  new spline nodes
//
// Optional Parameters:
//     N           -   points count:
//                     * N >= 2
//                     * if given, only first N points from X/Y are used
//                     * if not given, automatically detected from X/Y sizes
//                       (len(X) must be equal to len(Y))
//     BoundLType  -   boundary condition type for the left boundary
//     BoundL      -   left boundary condition (first or second derivative,
//                     depending on the BoundLType)
//     BoundRType  -   boundary condition type for the right boundary
//     BoundR      -   right boundary condition (first or second derivative,
//                     depending on the BoundRType)
//     N2          -   new points count:
//                     * N2 >= 2
//                     * if given, only first N2 points from X2 are used
//                     * if not given, automatically detected from X2 size
//
// Outputs:
//     F2          -   function values at X2[]
//     D2          -   first derivatives at X2[]
//     DD2         -   second derivatives at X2[]
//
// ORDER OF POINTS
//
// Subroutine automatically sorts points, so caller  may pass unsorted array.
// Function  values  are correctly reordered on  return, so F2[I]  is  always
// equal to S(X2[I]) independently of points order.
//
// SETTING BOUNDARY VALUES:
//
// The BoundLType/BoundRType parameters can have the following values:
//     * -1, which corresonds to the periodic (cyclic) boundary conditions.
//           In this case:
//           * both BoundLType and BoundRType must be equal to -1.
//           * BoundL/BoundR are ignored
//           * Y[last] is ignored (it is assumed to be equal to Y[first]).
//     *  0, which  corresponds  to  the  parabolically   terminated  spline
//           (BoundL and/or BoundR are ignored).
//     *  1, which corresponds to the first derivative boundary condition
//     *  2, which corresponds to the second derivative boundary condition
//     *  by default, BoundType=0 is used
//
// PROBLEMS WITH PERIODIC BOUNDARY CONDITIONS:
//
// Problems with periodic boundary conditions have Y[first_point]=Y[last_point].
// However, this subroutine doesn't require you to specify equal  values  for
// the first and last points - it automatically forces them  to  be  equal by
// copying  Y[first_point]  (corresponds  to the leftmost,  minimal  X[])  to
// Y[last_point]. However it is recommended to pass consistent values of Y[],
// i.e. to make Y[first_point]=Y[last_point].
// ALGLIB Project: Copyright 03.09.2010 by Sergey Bochkanov
// API: void spline1dconvdiff2cubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t boundltype, const double boundl, const ae_int_t boundrtype, const double boundr, const real_1d_array &x2, const ae_int_t n2, real_1d_array &y2, real_1d_array &d2, real_1d_array &dd2, const xparams _xparams = xdefault);
// API: void spline1dconvdiff2cubic(const real_1d_array &x, const real_1d_array &y, const real_1d_array &x2, real_1d_array &y2, real_1d_array &d2, real_1d_array &dd2, const xparams _xparams = xdefault);
void spline1dconvdiff2cubic(RVector *x, RVector *y, ae_int_t n, ae_int_t boundltype, double boundl, ae_int_t boundrtype, double boundr, RVector *x2, ae_int_t n2, RVector *y2, RVector *d2, RVector *dd2, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t ylen;
   double t;
   double t2;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   DupVector(x2, _state);
   SetVector(y2);
   SetVector(d2);
   SetVector(dd2);
   NewVector(a1, 0, DT_REAL, _state);
   NewVector(a2, 0, DT_REAL, _state);
   NewVector(a3, 0, DT_REAL, _state);
   NewVector(b, 0, DT_REAL, _state);
   NewVector(d, 0, DT_REAL, _state);
   NewVector(dt, 0, DT_REAL, _state);
   NewVector(p, 0, DT_INT, _state);
   NewVector(p2, 0, DT_INT, _state);
// check correctness of boundary conditions
   ae_assert(((boundltype == -1 || boundltype == 0) || boundltype == 1) || boundltype == 2, "Spline1DConvDiff2Cubic: incorrect BoundLType!", _state);
   ae_assert(((boundrtype == -1 || boundrtype == 0) || boundrtype == 1) || boundrtype == 2, "Spline1DConvDiff2Cubic: incorrect BoundRType!", _state);
   ae_assert((boundrtype == -1 && boundltype == -1) || (boundrtype != -1 && boundltype != -1), "Spline1DConvDiff2Cubic: incorrect BoundLType/BoundRType!", _state);
   if (boundltype == 1 || boundltype == 2) {
      ae_assert(ae_isfinite(boundl, _state), "Spline1DConvDiff2Cubic: BoundL is infinite or NAN!", _state);
   }
   if (boundrtype == 1 || boundrtype == 2) {
      ae_assert(ae_isfinite(boundr, _state), "Spline1DConvDiff2Cubic: BoundR is infinite or NAN!", _state);
   }
// check lengths of arguments
   ae_assert(n >= 2, "Spline1DConvDiff2Cubic: N<2!", _state);
   ae_assert(x->cnt >= n, "Spline1DConvDiff2Cubic: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DConvDiff2Cubic: Length(Y)<N!", _state);
   ae_assert(n2 >= 2, "Spline1DConvDiff2Cubic: N2<2!", _state);
   ae_assert(x2->cnt >= n2, "Spline1DConvDiff2Cubic: Length(X2)<N2!", _state);
// check and sort X/Y
   ylen = n;
   if (boundltype == -1) {
      ylen = n - 1;
   }
   ae_assert(isfinitevector(x, n, _state), "Spline1DConvDiff2Cubic: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, ylen, _state), "Spline1DConvDiff2Cubic: Y contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(x2, n2, _state), "Spline1DConvDiff2Cubic: X2 contains infinite or NAN values!", _state);
   spline1d_heapsortppoints(x, y, &p, n, _state);
   ae_assert(aredistinct(x, n, _state), "Spline1DConvDiff2Cubic: at least two consequent points are too close!", _state);
// set up DT (we will need it below)
   ae_vector_set_length(&dt, maxint(n, n2, _state), _state);
// sort X2:
// * use fake array DT because HeapSortPPoints() needs both integer AND real arrays
// * if we have periodic problem, wrap points
// * sort them, store permutation at P2
   if (boundrtype == -1 && boundltype == -1) {
      for (i = 0; i < n2; i++) {
         t = x2->xR[i];
         apperiodicmap(&t, x->xR[0], x->xR[n - 1], &t2, _state);
         x2->xR[i] = t;
      }
   }
   spline1d_heapsortppoints(x2, &dt, &p2, n2, _state);
// Now we've checked and preordered everything, so we:
// * call internal GridDiff() function to get Hermite form of spline
// * convert using internal Conv() function
// * convert Y2 back to original order
   spline1d_spline1dgriddiffcubicinternal(x, y, n, boundltype, boundl, boundrtype, boundr, &d, &a1, &a2, &a3, &b, &dt, _state);
   spline1dconvdiffinternal(x, y, &d, n, x2, n2, y2, true, d2, true, dd2, true, _state);
   ae_assert(dt.cnt >= n2, "Spline1DConvDiff2Cubic: internal error!", _state);
   for (i = 0; i < n2; i++) {
      dt.xR[p2.xZ[i]] = y2->xR[i];
   }
   ae_v_move(y2->xR, 1, dt.xR, 1, n2);
   for (i = 0; i < n2; i++) {
      dt.xR[p2.xZ[i]] = d2->xR[i];
   }
   ae_v_move(d2->xR, 1, dt.xR, 1, n2);
   for (i = 0; i < n2; i++) {
      dt.xR[p2.xZ[i]] = dd2->xR[i];
   }
   ae_v_move(dd2->xR, 1, dt.xR, 1, n2);
   ae_frame_leave(_state);
}

// This subroutine calculates the value of the spline at the given point X.
//
// Inputs:
//     C   -   spline interpolant
//     X   -   point
//
// Result:
//     S(x)
// ALGLIB Project: Copyright 23.06.2007 by Sergey Bochkanov
// API: double spline1dcalc(const spline1dinterpolant &c, const double x, const xparams _xparams = xdefault);
double spline1dcalc(spline1dinterpolant *c, double x, ae_state *_state) {
   ae_int_t l;
   ae_int_t r;
   ae_int_t m;
   double t;
   double result;
   ae_assert(c->k == 3, "Spline1DCalc: internal error", _state);
   ae_assert(!ae_isinf(x, _state), "Spline1DCalc: infinite X!", _state);
// special case: NaN
   if (ae_isnan(x, _state)) {
      result = _state->v_nan;
      return result;
   }
// correct if periodic
   if (c->periodic) {
      apperiodicmap(&x, c->x.xR[0], c->x.xR[c->n - 1], &t, _state);
   }
// Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
   l = 0;
   r = c->n - 2 + 1;
   while (l != r - 1) {
      m = (l + r) / 2;
      if (c->x.xR[m] >= x) {
         r = m;
      } else {
         l = m;
      }
   }
// Interpolation
   x -= c->x.xR[l];
   m = 4 * l;
   result = c->c.xR[m] + x * (c->c.xR[m + 1] + x * (c->c.xR[m + 2] + x * c->c.xR[m + 3]));
   return result;
}

// This subroutine differentiates the spline.
//
// Inputs:
//     C   -   spline interpolant.
//     X   -   point
//
// Result:
//     S   -   S(x)
//     DS  -   S'(x)
//     D2S -   S''(x)
// ALGLIB Project: Copyright 24.06.2007 by Sergey Bochkanov
// API: void spline1ddiff(const spline1dinterpolant &c, const double x, double &s, double &ds, double &d2s, const xparams _xparams = xdefault);
void spline1ddiff(spline1dinterpolant *c, double x, double *s, double *ds, double *d2s, ae_state *_state) {
   ae_int_t l;
   ae_int_t r;
   ae_int_t m;
   double t;
   *s = 0;
   *ds = 0;
   *d2s = 0;
   ae_assert(c->k == 3, "Spline1DDiff: internal error", _state);
   ae_assert(!ae_isinf(x, _state), "Spline1DDiff: infinite X!", _state);
// special case: NaN
   if (ae_isnan(x, _state)) {
      *s = _state->v_nan;
      *ds = _state->v_nan;
      *d2s = _state->v_nan;
      return;
   }
// correct if periodic
   if (c->periodic) {
      apperiodicmap(&x, c->x.xR[0], c->x.xR[c->n - 1], &t, _state);
   }
// Binary search
   l = 0;
   r = c->n - 2 + 1;
   while (l != r - 1) {
      m = (l + r) / 2;
      if (c->x.xR[m] >= x) {
         r = m;
      } else {
         l = m;
      }
   }
// Differentiation
   x -= c->x.xR[l];
   m = 4 * l;
   *s = c->c.xR[m] + x * (c->c.xR[m + 1] + x * (c->c.xR[m + 2] + x * c->c.xR[m + 3]));
   *ds = c->c.xR[m + 1] + 2 * x * c->c.xR[m + 2] + 3 * sqr(x, _state) * c->c.xR[m + 3];
   *d2s = 2 * c->c.xR[m + 2] + 6 * x * c->c.xR[m + 3];
}

// This subroutine makes the copy of the spline.
//
// Inputs:
//     C   -   spline interpolant.
//
// Result:
//     CC  -   spline copy
// ALGLIB Project: Copyright 29.06.2007 by Sergey Bochkanov
void spline1dcopy(spline1dinterpolant *c, spline1dinterpolant *cc, ae_state *_state) {
   ae_int_t s;
   SetObj(spline1dinterpolant, cc);
   cc->periodic = c->periodic;
   cc->n = c->n;
   cc->k = c->k;
   cc->continuity = c->continuity;
   ae_vector_set_length(&cc->x, cc->n, _state);
   ae_v_move(cc->x.xR, 1, c->x.xR, 1, cc->n);
   s = c->c.cnt;
   ae_vector_set_length(&cc->c, s, _state);
   ae_v_move(cc->c.xR, 1, c->c.xR, 1, s);
}

// This subroutine unpacks the spline into the coefficients table.
//
// Inputs:
//     C   -   spline interpolant.
//     X   -   point
//
// Outputs:
//     Tbl -   coefficients table, unpacked format, array[0..N-2, 0..5].
//             For I = 0...N-2:
//                 Tbl[I,0] = X[i]
//                 Tbl[I,1] = X[i+1]
//                 Tbl[I,2] = C0
//                 Tbl[I,3] = C1
//                 Tbl[I,4] = C2
//                 Tbl[I,5] = C3
//             On [x[i], x[i+1]] spline is equals to:
//                 S(x) = C0 + C1*t + C2*t^2 + C3*t^3
//                 t = x-x[i]
//
// NOTE:
//     You  can rebuild spline with  Spline1DBuildHermite()  function,  which
//     accepts as inputs function values and derivatives at nodes, which  are
//     easy to calculate when you have coefficients.
// ALGLIB Project: Copyright 29.06.2007 by Sergey Bochkanov
// API: void spline1dunpack(const spline1dinterpolant &c, ae_int_t &n, real_2d_array &tbl, const xparams _xparams = xdefault);
void spline1dunpack(spline1dinterpolant *c, ae_int_t *n, RMatrix *tbl, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   *n = 0;
   SetMatrix(tbl);
   ae_matrix_set_length(tbl, c->n - 2 + 1, 2 + c->k + 1, _state);
   *n = c->n;
// Fill
   for (i = 0; i < *n - 1; i++) {
      tbl->xyR[i][0] = c->x.xR[i];
      tbl->xyR[i][1] = c->x.xR[i + 1];
      for (j = 0; j <= c->k; j++) {
         tbl->xyR[i][2 + j] = c->c.xR[(c->k + 1) * i + j];
      }
   }
}

// This subroutine performs linear transformation of the spline argument.
//
// Inputs:
//     C   -   spline interpolant.
//     A, B-   transformation coefficients: x = A*t + B
// Result:
//     C   -   transformed spline
// ALGLIB Project: Copyright 30.06.2007 by Sergey Bochkanov
// API: void spline1dlintransx(const spline1dinterpolant &c, const double a, const double b, const xparams _xparams = xdefault);
void spline1dlintransx(spline1dinterpolant *c, double a, double b, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t n;
   double v;
   double dv;
   double d2v;
   bool isperiodic;
   ae_int_t contval;
   ae_frame_make(_state, &_frame_block);
   NewVector(x, 0, DT_REAL, _state);
   NewVector(y, 0, DT_REAL, _state);
   NewVector(d, 0, DT_REAL, _state);
   ae_assert(c->k == 3, "Spline1DLinTransX: internal error", _state);
   n = c->n;
   ae_vector_set_length(&x, n, _state);
   ae_vector_set_length(&y, n, _state);
   ae_vector_set_length(&d, n, _state);
// Unpack, X, Y, dY/dX.
// Scale and pack with Spline1DBuildHermite again.
   if (a == 0.0) {
   // Special case: A=0
      v = spline1dcalc(c, b, _state);
      for (i = 0; i < n; i++) {
         x.xR[i] = c->x.xR[i];
         y.xR[i] = v;
         d.xR[i] = 0.0;
      }
   } else {
   // General case, A != 0
      for (i = 0; i < n; i++) {
         x.xR[i] = c->x.xR[i];
         spline1ddiff(c, x.xR[i], &v, &dv, &d2v, _state);
         x.xR[i] = (x.xR[i] - b) / a;
         y.xR[i] = v;
         d.xR[i] = a * dv;
      }
   }
   isperiodic = c->periodic;
   contval = c->continuity;
   if (contval > 0) {
      spline1dbuildhermite(&x, &y, &d, n, c, _state);
   } else {
      spline1dbuildlinear(&x, &y, n, c, _state);
   }
   c->periodic = isperiodic;
   c->continuity = contval;
   ae_frame_leave(_state);
}

// This subroutine performs linear transformation of the spline.
//
// Inputs:
//     C   -   spline interpolant.
//     A, B-   transformation coefficients: S2(x) = A*S(x) + B
// Result:
//     C   -   transformed spline
// ALGLIB Project: Copyright 30.06.2007 by Sergey Bochkanov
// API: void spline1dlintransy(const spline1dinterpolant &c, const double a, const double b, const xparams _xparams = xdefault);
void spline1dlintransy(spline1dinterpolant *c, double a, double b, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_assert(c->k == 3, "Spline1DLinTransX: internal error", _state);
   n = c->n;
   for (i = 0; i < n - 1; i++) {
      c->c.xR[4 * i] = a * c->c.xR[4 * i] + b;
      for (j = 1; j <= 3; j++) {
         c->c.xR[4 * i + j] *= a;
      }
   }
   c->c.xR[4 * (n - 1) + 0] = a * c->c.xR[4 * (n - 1) + 0] + b;
   c->c.xR[4 * (n - 1) + 1] *= a;
}

// This subroutine integrates the spline.
//
// Inputs:
//     C   -   spline interpolant.
//     X   -   right bound of the integration interval [a, x],
//             here 'a' denotes min(x[])
// Result:
//     integral(S(t)dt,a,x)
// ALGLIB Project: Copyright 23.06.2007 by Sergey Bochkanov
// API: double spline1dintegrate(const spline1dinterpolant &c, const double x, const xparams _xparams = xdefault);
double spline1dintegrate(spline1dinterpolant *c, double x, ae_state *_state) {
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t l;
   ae_int_t r;
   ae_int_t m;
   double w;
   double v;
   double t;
   double intab;
   double additionalterm;
   double result;
   n = c->n;
// Periodic splines require special treatment. We make
// following transformation:
//
//     integral(S(t)dt,A,X) = integral(S(t)dt,A,Z)+AdditionalTerm
//
// here X may lie outside of [A,B], Z lies strictly in [A,B],
// AdditionalTerm is equals to integral(S(t)dt,A,B) times some
// integer number (may be zero).
   if (c->periodic && (x < c->x.xR[0] || x > c->x.xR[c->n - 1])) {
   // compute integral(S(x)dx,A,B)
      intab = 0.0;
      for (i = 0; i < c->n - 1; i++) {
         w = c->x.xR[i + 1] - c->x.xR[i];
         m = (c->k + 1) * i;
         intab += c->c.xR[m] * w;
         v = w;
         for (j = 1; j <= c->k; j++) {
            v *= w;
            intab += c->c.xR[m + j] * v / (j + 1);
         }
      }
   // map X into [A,B]
      apperiodicmap(&x, c->x.xR[0], c->x.xR[c->n - 1], &t, _state);
      additionalterm = t * intab;
   } else {
      additionalterm = 0.0;
   }
// Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
   l = 0;
   r = n - 2 + 1;
   while (l != r - 1) {
      m = (l + r) / 2;
      if (c->x.xR[m] >= x) {
         r = m;
      } else {
         l = m;
      }
   }
// Integration
   result = 0.0;
   for (i = 0; i < l; i++) {
      w = c->x.xR[i + 1] - c->x.xR[i];
      m = (c->k + 1) * i;
      result += c->c.xR[m] * w;
      v = w;
      for (j = 1; j <= c->k; j++) {
         v *= w;
         result += c->c.xR[m + j] * v / (j + 1);
      }
   }
   w = x - c->x.xR[l];
   m = (c->k + 1) * l;
   v = w;
   result += c->c.xR[m] * w;
   for (j = 1; j <= c->k; j++) {
      v *= w;
      result += c->c.xR[m + j] * v / (j + 1);
   }
   result += additionalterm;
   return result;
}

// Fitting by smoothing (penalized) cubic spline.
//
// This function approximates N scattered points (some of X[] may be equal to
// each other) by cubic spline with M  nodes  at  equidistant  grid  spanning
// interval [min(x,xc),max(x,xc)].
//
// The problem is regularized by adding nonlinearity penalty to  usual  least
// squares penalty function:
//
//     MERIT_FUNC = F_LS + F_NL
//
// where F_LS is a least squares error  term,  and  F_NL  is  a  nonlinearity
// penalty which is roughly proportional to LambdaNS*integral{ S''(x)^2*dx }.
// Algorithm applies automatic renormalization of F_NL  which  makes  penalty
// term roughly invariant to scaling of X[] and changes in M.
//
// This function is a new edition  of  penalized  regression  spline fitting,
// a fast and compact one which needs much less resources that  its  previous
// version: just O(maxMN) memory and O(maxMN*log(maxMN)) time.
//
// NOTE: it is OK to run this function with both M<<N and M>>N;  say,  it  is
//       possible to process 100 points with 1000-node spline.
//
// Inputs:
//     X           -   points, array[0..N-1].
//     Y           -   function values, array[0..N-1].
//     N           -   number of points (optional):
//                     * N>0
//                     * if given, only first N elements of X/Y are processed
//                     * if not given, automatically determined from lengths
//     M           -   number of basis functions ( = number_of_nodes), M >= 4.
//     LambdaNS    -   LambdaNS >= 0, regularization  constant  passed by user.
//                     It penalizes nonlinearity in the regression spline.
//                     Possible values to start from are 0.00001, 0.1, 1
//
// Outputs:
//     S   -   spline interpolant.
//     Rep -   Following fields are set:
//             * RMSError      rms error on the (X,Y).
//             * AvgError      average error on the (X,Y).
//             * AvgRelError   average relative error on the non-zero Y
//             * MaxError      maximum error
// ALGLIB Project: Copyright 27.08.2019 by Sergey Bochkanov
// API: void spline1dfit(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t m, const double lambdans, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams = xdefault);
// API: void spline1dfit(const real_1d_array &x, const real_1d_array &y, const ae_int_t m, const double lambdans, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams = xdefault);
void spline1dfit(RVector *x, RVector *y, ae_int_t n, ae_int_t m, double lambdans, spline1dinterpolant *s, spline1dfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t bfrad;
   double xa;
   double xb;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t k0;
   ae_int_t k1;
   double v;
   double dv;
   double d2v;
   ae_int_t gridexpansion;
   double meany;
   ae_int_t lsqrcnt;
   ae_int_t nrel;
   double rss;
   double tss;
   ae_int_t arows;
   double creg;
   double mxata;
   ae_int_t bw;
   ae_int_t nzcnt;
   double scaletargetsby;
   double scalepenaltyby;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   SetObj(spline1dinterpolant, s);
   SetObj(spline1dfitreport, rep);
   NewVector(xywork, 0, DT_REAL, _state);
   NewMatrix(vterm, 0, 0, DT_REAL, _state);
   NewVector(sx, 0, DT_REAL, _state);
   NewVector(sy, 0, DT_REAL, _state);
   NewVector(sdy, 0, DT_REAL, _state);
   NewVector(tmpx, 0, DT_REAL, _state);
   NewVector(tmpy, 0, DT_REAL, _state);
   NewObj(spline1dinterpolant, basis1, _state);
   NewObj(sparsematrix, av, _state);
   NewObj(sparsematrix, ah, _state);
   NewObj(sparsematrix, ata, _state);
   NewVector(targets, 0, DT_REAL, _state);
   NewVector(tmp0, 0, DT_REAL, _state);
   NewVector(tmp1, 0, DT_REAL, _state);
   NewObj(linlsqrstate, solver, _state);
   NewObj(linlsqrreport, srep, _state);
   NewVector(nzidx, 0, DT_INT, _state);
   NewVector(nzval, 0, DT_REAL, _state);
   ae_assert(n >= 1, "Spline1DFit: N<1!", _state);
   ae_assert(m >= 1, "Spline1DFit: M<1!", _state);
   ae_assert(x->cnt >= n, "Spline1DFit: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DFit: Length(Y)<N!", _state);
   ae_assert(isfinitevector(x, n, _state), "Spline1DFit: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "Spline1DFit: Y contains infinite or NAN values!", _state);
   ae_assert(ae_isfinite(lambdans, _state), "Spline1DFit: LambdaNS is infinite!", _state);
   ae_assert(lambdans >= 0.0, "Spline1DFit: LambdaNS<0!", _state);
   bfrad = 2;
   lsqrcnt = 10;
// Sort points.
// Determine actual area size, make sure that XA<XB
   tagsortfastr(x, y, &tmpx, &tmpy, n, _state);
   xa = x->xR[0];
   xb = x->xR[n - 1];
   if (xa == xb) {
      v = xa;
      if (v >= 0.0) {
         xa = v / 2 - 1;
         xb = v * 2 + 1;
      } else {
         xa = v * 2 - 1;
         xb = v / 2 + 1;
      }
   }
   ae_assert(xa < xb, "Spline1DFit: integrity error", _state);
// Perform a grid correction according to current grid expansion size.
   m = maxint(m, 4, _state);
   gridexpansion = 1;
   v = (xb - xa) / m;
   xa -= v * gridexpansion;
   xb += v * gridexpansion;
   m += 2 * gridexpansion;
// Convert X/Y to work representation, remove linear trend (in
// order to improve condition number).
//
// Compute total-sum-of-squares (needed later for R2 coefficient).
   ae_vector_set_length(&xywork, 2 * n, _state);
   for (i = 0; i < n; i++) {
      xywork.xR[2 * i + 0] = (x->xR[i] - xa) / (xb - xa);
      xywork.xR[2 * i + 1] = y->xR[i];
   }
   buildpriorterm1(&xywork, n, 1, 1, 1, 0.0, &vterm, _state);
   meany = 0.0;
   for (i = 0; i < n; i++) {
      meany += y->xR[i];
   }
   meany /= n;
   tss = 0.0;
   for (i = 0; i < n; i++) {
      tss += sqr(y->xR[i] - meany, _state);
   }
// Build 1D compact basis function
// Generate design matrix AV ("vertical") and its transpose AH ("horizontal").
   ae_vector_set_length(&tmpx, 7, _state);
   ae_vector_set_length(&tmpy, 7, _state);
   tmpx.xR[0] = -3.0 / (m - 1);
   tmpx.xR[1] = -2.0 / (m - 1);
   tmpx.xR[2] = -1.0 / (m - 1);
   tmpx.xR[3] = 0.0 / (m - 1);
   tmpx.xR[4] = 1.0 / (m - 1);
   tmpx.xR[5] = 2.0 / (m - 1);
   tmpx.xR[6] = 3.0 / (m - 1);
   tmpy.xR[0] = 0.0;
   tmpy.xR[1] = 0.0;
   tmpy.xR[2] = 1.0 / 12.0;
   tmpy.xR[3] = 2.0 / 6.0;
   tmpy.xR[4] = 1.0 / 12.0;
   tmpy.xR[5] = 0.0;
   tmpy.xR[6] = 0.0;
   spline1dbuildcubic(&tmpx, &tmpy, tmpx.cnt, 2, 0.0, 2, 0.0, &basis1, _state);
   arows = n + 2 * m;
   sparsecreate(arows, m, 0, &av, _state);
   setlengthzero(&targets, arows, _state);
   scaletargetsby = 1 / ae_sqrt((double)n, _state);
   scalepenaltyby = 1 / ae_sqrt((double)m, _state);
   for (i = 0; i < n; i++) {
   // Generate design matrix row #I which corresponds to I-th dataset point
      k = ifloor(boundval(xywork.xR[2 * i + 0] * (m - 1), 0.0, (double)(m - 1), _state), _state);
      k0 = maxint(k - (bfrad - 1), 0, _state);
      k1 = minint(k + bfrad, m - 1, _state);
      for (j = k0; j <= k1; j++) {
         sparseset(&av, i, j, spline1dcalc(&basis1, xywork.xR[2 * i + 0] - (double)j / (m - 1), _state) * scaletargetsby, _state);
      }
      targets.xR[i] = xywork.xR[2 * i + 1] * scaletargetsby;
   }
   for (i = 0; i < m; i++) {
   // Generate design matrix row #(I+N) which corresponds to nonlinearity penalty at I-th node
      k0 = maxint(i - (bfrad - 1), 0, _state);
      k1 = minint(i + (bfrad - 1), m - 1, _state);
      for (j = k0; j <= k1; j++) {
         spline1ddiff(&basis1, (double)i / (m - 1) - (double)j / (m - 1), &v, &dv, &d2v, _state);
         sparseset(&av, n + i, j, lambdans * d2v * scalepenaltyby, _state);
      }
   }
   for (i = 0; i < m; i++) {
   // Generate design matrix row #(I+N+M) which corresponds to regularization for I-th coefficient
      sparseset(&av, n + m + i, i, spline1d_lambdareg, _state);
   }
   sparseconverttocrs(&av, _state);
   sparsecopytransposecrs(&av, &ah, _state);
// Build 7-diagonal (bandwidth=3) normal equations matrix and perform Cholesky
// decomposition (to be used later as preconditioner for LSQR iterations).
   bw = 3;
   sparsecreatesksband(m, m, bw, &ata, _state);
   mxata = 0.0;
   for (i = 0; i < m; i++) {
      for (j = i; j <= i + bw && j < m; j++) {
      // Get pattern of nonzeros in one of the rows (let it be I-th one)
      // and compute dot product only for nonzero entries.
         sparsegetcompressedrow(&ah, i, &nzidx, &nzval, &nzcnt, _state);
         v = 0.0;
         for (k = 0; k < nzcnt; k++) {
            v += sparseget(&ah, i, nzidx.xZ[k], _state) * sparseget(&ah, j, nzidx.xZ[k], _state);
         }
      // Update ATA and max(ATA)
         sparseset(&ata, i, j, v, _state);
         if (i == j) {
            mxata = maxreal(mxata, ae_fabs(v, _state), _state);
         }
      }
   }
   mxata = coalesce(mxata, 1.0, _state);
   creg = spline1d_cholreg;
   while (true) {
   // Regularization
      for (i = 0; i < m; i++) {
         sparseset(&ata, i, i, sparseget(&ata, i, i, _state) + mxata * creg, _state);
      }
   // Try Cholesky factorization.
      if (!sparsecholeskyskyline(&ata, m, true, _state)) {
      // Factorization failed, increase regularizer and repeat
         creg = coalesce(10 * creg, 1.0E-12, _state);
         continue;
      }
      break;
   }
// Solve with preconditioned LSQR:
//
// use Cholesky factor U of squared design matrix A'*A to
// transform min|A*x-b| to min|[A*inv(U)]*y-b| with y=U*x.
//
// Preconditioned problem is solved with LSQR solver, which
// gives superior results to normal equations approach. Due
// to Cholesky preconditioner being utilized we can solve
// problem in just a few iterations.
   rvectorsetlengthatleast(&tmp0, arows, _state);
   rvectorsetlengthatleast(&tmp1, m, _state);
   linlsqrcreatebuf(arows, m, &solver, _state);
   linlsqrsetb(&solver, &targets, _state);
   linlsqrsetcond(&solver, 1.0E-14, 1.0E-14, lsqrcnt, _state);
   while (linlsqriteration(&solver, _state)) {
      if (solver.needmv) {
         for (i = 0; i < m; i++) {
            tmp1.xR[i] = solver.x.xR[i];
         }
      // Use Cholesky factorization of the system matrix
      // as preconditioner: solve TRSV(U,Solver.X)
         sparsetrsv(&ata, true, false, 0, &tmp1, _state);
      // After preconditioning is done, multiply by A
         sparsemv(&av, &tmp1, &solver.mv, _state);
      }
      if (solver.needmtv) {
      // Multiply by design matrix A
         sparsemtv(&av, &solver.x, &solver.mtv, _state);
      // Multiply by preconditioner: solve TRSV(U',A*Solver.X)
         sparsetrsv(&ata, true, false, 1, &solver.mtv, _state);
      }
   }
   linlsqrresults(&solver, &tmp1, &srep, _state);
   sparsetrsv(&ata, true, false, 0, &tmp1, _state);
// Generate output spline as a table of spline valued and first
// derivatives at nodes (used to build Hermite spline)
   ae_vector_set_length(&sx, m, _state);
   ae_vector_set_length(&sy, m, _state);
   ae_vector_set_length(&sdy, m, _state);
   for (i = 0; i < m; i++) {
      sx.xR[i] = (double)i / (m - 1);
      sy.xR[i] = 0.0;
      sdy.xR[i] = 0.0;
   }
   for (i = 0; i < m; i++) {
      k0 = maxint(i - (bfrad - 1), 0, _state);
      k1 = minint(i + bfrad, m - 1, _state);
      for (j = k0; j <= k1; j++) {
         spline1ddiff(&basis1, (double)j / (m - 1) - (double)i / (m - 1), &v, &dv, &d2v, _state);
         sy.xR[j] += tmp1.xR[i] * v;
         sdy.xR[j] += tmp1.xR[i] * dv;
      }
   }
// Calculate model values
   sparsemv(&av, &tmp1, &tmp0, _state);
   for (i = 0; i < n; i++) {
      tmp0.xR[i] /= scaletargetsby;
   }
   rss = 0.0;
   nrel = 0;
   rep->rmserror = 0.0;
   rep->maxerror = 0.0;
   rep->avgerror = 0.0;
   rep->avgrelerror = 0.0;
   for (i = 0; i < n; i++) {
      v = xywork.xR[2 * i + 1] - tmp0.xR[i];
      rss += v * v;
      rep->rmserror += sqr(v, _state);
      rep->avgerror += ae_fabs(v, _state);
      rep->maxerror = maxreal(rep->maxerror, ae_fabs(v, _state), _state);
      if (y->xR[i] != 0.0) {
         rep->avgrelerror += ae_fabs(v / y->xR[i], _state);
         nrel++;
      }
   }
   rep->rmserror = ae_sqrt(rep->rmserror / n, _state);
   rep->avgerror /= n;
   rep->avgrelerror /= coalesce((double)nrel, 1.0, _state);
// Append prior term.
// Transform spline to original coordinates.
// Output.
   for (i = 0; i < m; i++) {
      sy.xR[i] += vterm.xyR[0][0] * sx.xR[i] + vterm.xyR[0][1];
      sdy.xR[i] += vterm.xyR[0][0];
   }
   for (i = 0; i < m; i++) {
      sx.xR[i] = sx.xR[i] * (xb - xa) + xa;
      sdy.xR[i] /= xb - xa;
   }
   spline1dbuildhermite(&sx, &sy, &sdy, m, s, _state);
   ae_frame_leave(_state);
}

// This procedure search roots of an quadratic equation inside [0;1] and it number of roots.
//
// Inputs:
//     P0   -   value of a function at 0
//     M0   -   value of a derivative at 0
//     P1   -   value of a function at 1
//     M1   -   value of a derivative at 1
//
// Outputs:
//     X0   -  first root of an equation
//     X1   -  second root of an equation
//     NR   -  number of roots
//
// RESTRICTIONS OF PARAMETERS:
//
// Parameters for this procedure has't to be zero simultaneously. Is expected,
// that input polinom is't degenerate or constant identicaly ZERO.
//
//
// REMARK:
//
// The procedure always fill value for X1 and X2, even if it is't belongs to [0;1].
// But first true root(even if existing one) is in X1.
// Number of roots is NR.
// ALGLIB Project: Copyright 26.09.2011 by Sergey Bochkanov
void solvepolinom2(double p0, double m0, double p1, double m1, double *x0, double *x1, ae_int_t *nr, ae_state *_state) {
   double a;
   double b;
   double c;
   double dd;
   double tmp;
   double exf;
   double extr;
   *x0 = 0;
   *x1 = 0;
   *nr = 0;
// calculate parameters for equation: A, B  and C
   a = 6 * p0 + 3 * m0 - 6 * p1 + 3 * m1;
   b = -6 * p0 - 4 * m0 + 6 * p1 - 2 * m1;
   c = m0;
// check case, when A=0
// we are considering the linear equation
   if (a == 0.0) {
   // B != 0 and root inside [0;1]
   // one root
      if ((b != 0.0 && sign(c, _state) * sign(b, _state) <= 0) && ae_fabs(b, _state) >= ae_fabs(c, _state)) {
         *x0 = -c / b;
         *nr = 1;
         return;
      } else {
         *nr = 0;
         return;
      }
   }
// consider case, when extremumu outside (0;1)
// exist one root only
   if (ae_fabs(2 * a, _state) <= ae_fabs(b, _state) || sign(b, _state) * sign(a, _state) >= 0) {
      if (sign(m0, _state) * sign(m1, _state) > 0) {
         *nr = 0;
         return;
      }
   // consider case, when the one exist
   // same sign of derivative
      if (sign(m0, _state) * sign(m1, _state) < 0) {
         *nr = 1;
         extr = -b / (2 * a);
         dd = b * b - 4 * a * c;
         if (dd < 0.0) {
            return;
         }
         *x0 = (-b - ae_sqrt(dd, _state)) / (2 * a);
         *x1 = (-b + ae_sqrt(dd, _state)) / (2 * a);
         if ((extr >= 1.0 && *x1 <= extr) || (extr <= 0.0 && *x1 >= extr)) {
            *x0 = *x1;
         }
         return;
      }
   // consider case, when the one is 0
      if (m0 == 0.0) {
         *x0 = 0.0;
         *nr = 1;
         return;
      }
      if (m1 == 0.0) {
         *x0 = 1.0;
         *nr = 1;
         return;
      }
   } else {
   // consider case, when both of derivatives is 0
      if (m0 == 0.0 && m1 == 0.0) {
         *x0 = 0.0;
         *x1 = 1.0;
         *nr = 2;
         return;
      }
   // consider case, when derivative at 0 is 0, and derivative at 1 is't 0
      if (m0 == 0.0 && m1 != 0.0) {
         dd = b * b - 4 * a * c;
         if (dd < 0.0) {
            *x0 = 0.0;
            *nr = 1;
            return;
         }
         *x0 = (-b - ae_sqrt(dd, _state)) / (2 * a);
         *x1 = (-b + ae_sqrt(dd, _state)) / (2 * a);
         extr = -b / (2 * a);
         exf = a * extr * extr + b * extr + c;
         if (sign(exf, _state) * sign(m1, _state) > 0) {
            *x0 = 0.0;
            *nr = 1;
            return;
         } else {
            if (extr > *x0) {
               *x0 = 0.0;
            } else {
               *x1 = 0.0;
            }
            *nr = 2;
         // roots must placed ascending
            if (*x0 > *x1) {
               tmp = *x0;
               *x0 = *x1;
               *x1 = tmp;
            }
            return;
         }
      }
      if (m1 == 0.0 && m0 != 0.0) {
         dd = b * b - 4 * a * c;
         if (dd < 0.0) {
            *x0 = 1.0;
            *nr = 1;
            return;
         }
         *x0 = (-b - ae_sqrt(dd, _state)) / (2 * a);
         *x1 = (-b + ae_sqrt(dd, _state)) / (2 * a);
         extr = -b / (2 * a);
         exf = a * extr * extr + b * extr + c;
         if (sign(exf, _state) * sign(m0, _state) > 0) {
            *x0 = 1.0;
            *nr = 1;
            return;
         } else {
            if (extr < *x0) {
               *x0 = 1.0;
            } else {
               *x1 = 1.0;
            }
            *nr = 2;
         // roots must placed ascending
            if (*x0 > *x1) {
               tmp = *x0;
               *x0 = *x1;
               *x1 = tmp;
            }
            return;
         }
      } else {
         extr = -b / (2 * a);
         exf = a * extr * extr + b * extr + c;
         if (sign(exf, _state) * sign(m0, _state) > 0 && sign(exf, _state) * sign(m1, _state) > 0) {
            *nr = 0;
            return;
         }
         dd = b * b - 4 * a * c;
         if (dd < 0.0) {
            *nr = 0;
            return;
         }
         *x0 = (-b - ae_sqrt(dd, _state)) / (2 * a);
         *x1 = (-b + ae_sqrt(dd, _state)) / (2 * a);
      // if EXF and m0, EXF and m1 has different signs, then equation has two roots
         if (sign(exf, _state) * sign(m0, _state) < 0 && sign(exf, _state) * sign(m1, _state) < 0) {
            *nr = 2;
         // roots must placed ascending
            if (*x0 > *x1) {
               tmp = *x0;
               *x0 = *x1;
               *x1 = tmp;
            }
            return;
         } else {
            *nr = 1;
            if (sign(exf, _state) * sign(m0, _state) < 0) {
               if (*x1 < extr) {
                  *x0 = *x1;
               }
               return;
            }
            if (sign(exf, _state) * sign(m1, _state) < 0) {
               if (*x1 > extr) {
                  *x0 = *x1;
               }
               return;
            }
         }
      }
   }
}

// Procedure for calculating value of a function is providet in the form of
// Hermite polinom
//
// Inputs:
//     P0   -   value of a function at 0
//     M0   -   value of a derivative at 0
//     P1   -   value of a function at 1
//     M1   -   value of a derivative at 1
//     T    -   point inside [0;1]
//
// Outputs:
//     S    -   value of a function at T
//     B0   -   value of a derivative function at T
// ALGLIB Project: Copyright 26.09.2011 by Sergey Bochkanov
static void spline1d_hermitecalc(double p0, double m0, double p1, double m1, double t, double *s, double *ds, ae_state *_state) {
   *s = 0;
   *ds = 0;
   *s = p0 * (1 + 2 * t) * (1 - t) * (1 - t) + m0 * t * (1 - t) * (1 - t) + p1 * (3 - 2 * t) * t * t + m1 * t * t * (t - 1);
   *ds = -p0 * 6 * t * (1 - t) + m0 * (1 - t) * (1 - 3 * t) + p1 * 6 * t * (1 - t) + m1 * t * (3 * t - 2);
}

// Function for searching a root at [A;B] by bisection method and return number of roots
// (0 or 1)
//
// Inputs:
//     pA   -   value of a function at A
//     mA   -   value of a derivative at A
//     pB   -   value of a function at B
//     mB   -   value of a derivative at B
//     A0   -   left border [A0;B0]
//     B0   -   right border [A0;B0]
//
// RESTRICTIONS OF PARAMETERS:
//
// We assume, that B0>A0.
//
//
// REMARK:
//
// Assume, that exist one root only at [A;B], else
// function may be work incorrectly.
// The function dont check value A0,B0!
// ALGLIB Project: Copyright 26.09.2011 by Sergey Bochkanov
ae_int_t bisectmethod(double pa, double ma, double pb, double mb, double a, double b, double *x, ae_state *_state) {
   double vacuum;
   double eps;
   double a0;
   double b0;
   double m;
   double lf;
   double rf;
   double mf;
   ae_int_t result;
   *x = 0;
// accuracy
   eps = 1000 * (b - a) * machineepsilon;
// initialization left and right borders
   a0 = a;
   b0 = b;
// initialize function value at 'A' and 'B'
   spline1d_hermitecalc(pa, ma, pb, mb, a, &lf, &vacuum, _state);
   spline1d_hermitecalc(pa, ma, pb, mb, b, &rf, &vacuum, _state);
// check, that 'A' and 'B' are't roots,
// and that root exist
   if (sign(lf, _state) * sign(rf, _state) > 0) {
      result = 0;
      return result;
   } else {
      if (lf == 0.0) {
         *x = a;
         result = 1;
         return result;
      } else {
         if (rf == 0.0) {
            *x = b;
            result = 1;
            return result;
         }
      }
   }
// searching a root
   do {
      m = (b0 + a0) / 2;
      spline1d_hermitecalc(pa, ma, pb, mb, a0, &lf, &vacuum, _state);
      spline1d_hermitecalc(pa, ma, pb, mb, b0, &rf, &vacuum, _state);
      spline1d_hermitecalc(pa, ma, pb, mb, m, &mf, &vacuum, _state);
      if (sign(mf, _state) * sign(lf, _state) < 0) {
         b0 = m;
      } else {
         if (sign(mf, _state) * sign(rf, _state) < 0) {
            a0 = m;
         } else {
            if (lf == 0.0) {
               *x = a0;
               result = 1;
               return result;
            }
            if (rf == 0.0) {
               *x = b0;
               result = 1;
               return result;
            }
            if (mf == 0.0) {
               *x = m;
               result = 1;
               return result;
            }
         }
      }
   } while (ae_fabs(b0 - a0, _state) >= eps);
   *x = m;
   result = 1;
   return result;
}

// Function for mapping from [A0;B0] to [A1;B1]
//
// Inputs:
//     A0   -   left border [A0;B0]
//     B0   -   right border [A0;B0]
//     A1   -   left border [A1;B1]
//     B1   -   right border [A1;B1]
//     T    -   value inside [A0;B0]
//
// RESTRICTIONS OF PARAMETERS:
//
// We assume, that B0>A0 and B1>A1. But we chech, that T is inside [A0;B0],
// and if T<A0 then T become A1, if T>B0 then T - B1.
//
// Inputs:
//         A0   -   left border for segment [A0;B0] from 'T' is converted to [A1;B1]
//         B0   -   right border for segment [A0;B0] from 'T' is converted to [A1;B1]
//         A1   -   left border for segment [A1;B1] to 'T' is converted from [A0;B0]
//         B1   -   right border for segment [A1;B1] to 'T' is converted from [A0;B0]
//         T    -   the parameter is mapped from [A0;B0] to [A1;B1]
//
// Result:
//     is converted value for 'T' from [A0;B0] to [A1;B1]
//
// REMARK:
//
// The function dont check value A0,B0 and A1,B1!
// ALGLIB Project: Copyright 26.09.2011 by Sergey Bochkanov
static double spline1d_rescaleval(double a0, double b0, double a1, double b1, double t, ae_state *_state) {
   double result;
// return left border
   if (t <= a0) {
      result = a1;
      return result;
   }
// return right border
   if (t >= b0) {
      result = b1;
      return result;
   }
// return value between left and right borders
   result = (b1 - a1) * (t - a0) / (b0 - a0) + a1;
   return result;
}

// This procedure search roots of an cubic equation inside [A;B], it number of roots
// and number of extremums.
//
// Inputs:
//     pA   -   value of a function at A
//     mA   -   value of a derivative at A
//     pB   -   value of a function at B
//     mB   -   value of a derivative at B
//     A0   -   left border [A0;B0]
//     B0   -   right border [A0;B0]
//
// Outputs:
//     X0   -  first root of an equation
//     X1   -  second root of an equation
//     X2   -  third root of an equation
//     EX0  -  first extremum of a function
//     EX0  -  second extremum of a function
//     NR   -  number of roots
//     NR   -  number of extrmums
//
// RESTRICTIONS OF PARAMETERS:
//
// Length of [A;B] must be positive and is't zero, i.e. A != B and A<B.
//
//
// REMARK:
//
// If 'NR' is -1 it's mean, than polinom has infiniti roots.
// If 'NE' is -1 it's mean, than polinom has infiniti extremums.
// ALGLIB Project: Copyright 26.09.2011 by Sergey Bochkanov
void solvecubicpolinom(double pa, double ma, double pb, double mb, double a, double b, double *x0, double *x1, double *x2, double *ex0, double *ex1, ae_int_t *nr, ae_int_t *ne, RVector *tempdata, ae_state *_state) {
   ae_int_t i;
   double tmpma;
   double tmpmb;
   double tex0;
   double tex1;
   *x0 = 0;
   *x1 = 0;
   *x2 = 0;
   *ex0 = 0;
   *ex1 = 0;
   *nr = 0;
   *ne = 0;
   rvectorsetlengthatleast(tempdata, 3, _state);
// case, when A>B
   ae_assert(a < b, "\nSolveCubicPolinom: incorrect borders for [A;B]!\n", _state);
// case 1
// function can be identicaly to ZERO
   if (((ma == 0.0 && mb == 0.0) && pa == pb) && pa == 0.0) {
      *nr = -1;
      *ne = -1;
      return;
   }
   if ((ma == 0.0 && mb == 0.0) && pa == pb) {
      *nr = 0;
      *ne = -1;
      return;
   }
   tmpma = ma * (b - a);
   tmpmb = mb * (b - a);
   solvepolinom2(pa, tmpma, pb, tmpmb, ex0, ex1, ne, _state);
   *ex0 = spline1d_rescaleval(0.0, 1.0, a, b, *ex0, _state);
   *ex1 = spline1d_rescaleval(0.0, 1.0, a, b, *ex1, _state);
// case 3.1
// no extremums at [A;B]
   if (*ne == 0) {
      *nr = bisectmethod(pa, tmpma, pb, tmpmb, 0.0, 1.0, x0, _state);
      if (*nr == 1) {
         *x0 = spline1d_rescaleval(0.0, 1.0, a, b, *x0, _state);
      }
      return;
   }
// case 3.2
// one extremum
   if (*ne == 1) {
      if (*ex0 == a || *ex0 == b) {
         *nr = bisectmethod(pa, tmpma, pb, tmpmb, 0.0, 1.0, x0, _state);
         if (*nr == 1) {
            *x0 = spline1d_rescaleval(0.0, 1.0, a, b, *x0, _state);
         }
         return;
      } else {
         *nr = 0;
         i = 0;
         tex0 = spline1d_rescaleval(a, b, 0.0, 1.0, *ex0, _state);
         *nr += bisectmethod(pa, tmpma, pb, tmpmb, 0.0, tex0, x0, _state);
         if (*nr > i) {
            tempdata->xR[i] = spline1d_rescaleval(0.0, tex0, a, *ex0, *x0, _state);
            i++;
         }
         *nr += bisectmethod(pa, tmpma, pb, tmpmb, tex0, 1.0, x0, _state);
         if (*nr > i) {
            *x0 = spline1d_rescaleval(tex0, 1.0, *ex0, b, *x0, _state);
            if (i > 0) {
               if (*x0 != tempdata->xR[i - 1]) {
                  tempdata->xR[i] = *x0;
                  i++;
               } else {
                  --*nr;
               }
            } else {
               tempdata->xR[i] = *x0;
               i++;
            }
         }
         if (*nr > 0) {
            *x0 = tempdata->xR[0];
            if (*nr > 1) {
               *x1 = tempdata->xR[1];
            }
            return;
         }
      }
      return;
   } else {
   // case 3.3
   // two extremums(or more, but it's impossible)
   //
   //
   // case 3.3.0
   // both extremums at the border
      if (*ex0 == a && *ex1 == b) {
         *nr = bisectmethod(pa, tmpma, pb, tmpmb, 0.0, 1.0, x0, _state);
         if (*nr == 1) {
            *x0 = spline1d_rescaleval(0.0, 1.0, a, b, *x0, _state);
         }
         return;
      }
      if (*ex0 == a && *ex1 != b) {
         *nr = 0;
         i = 0;
         tex1 = spline1d_rescaleval(a, b, 0.0, 1.0, *ex1, _state);
         *nr += bisectmethod(pa, tmpma, pb, tmpmb, 0.0, tex1, x0, _state);
         if (*nr > i) {
            tempdata->xR[i] = spline1d_rescaleval(0.0, tex1, a, *ex1, *x0, _state);
            i++;
         }
         *nr += bisectmethod(pa, tmpma, pb, tmpmb, tex1, 1.0, x0, _state);
         if (*nr > i) {
            *x0 = spline1d_rescaleval(tex1, 1.0, *ex1, b, *x0, _state);
            if (*x0 != tempdata->xR[i - 1]) {
               tempdata->xR[i] = *x0;
               i++;
            } else {
               --*nr;
            }
         }
         if (*nr > 0) {
            *x0 = tempdata->xR[0];
            if (*nr > 1) {
               *x1 = tempdata->xR[1];
            }
            return;
         }
      }
      if (*ex1 == b && *ex0 != a) {
         *nr = 0;
         i = 0;
         tex0 = spline1d_rescaleval(a, b, 0.0, 1.0, *ex0, _state);
         *nr += bisectmethod(pa, tmpma, pb, tmpmb, 0.0, tex0, x0, _state);
         if (*nr > i) {
            tempdata->xR[i] = spline1d_rescaleval(0.0, tex0, a, *ex0, *x0, _state);
            i++;
         }
         *nr += bisectmethod(pa, tmpma, pb, tmpmb, tex0, 1.0, x0, _state);
         if (*nr > i) {
            *x0 = spline1d_rescaleval(tex0, 1.0, *ex0, b, *x0, _state);
            if (i > 0) {
               if (*x0 != tempdata->xR[i - 1]) {
                  tempdata->xR[i] = *x0;
                  i++;
               } else {
                  --*nr;
               }
            } else {
               tempdata->xR[i] = *x0;
               i++;
            }
         }
         if (*nr > 0) {
            *x0 = tempdata->xR[0];
            if (*nr > 1) {
               *x1 = tempdata->xR[1];
            }
            return;
         }
      } else {
      // case 3.3.2
      // both extremums inside (0;1)
         *nr = 0;
         i = 0;
         tex0 = spline1d_rescaleval(a, b, 0.0, 1.0, *ex0, _state);
         tex1 = spline1d_rescaleval(a, b, 0.0, 1.0, *ex1, _state);
         *nr += bisectmethod(pa, tmpma, pb, tmpmb, 0.0, tex0, x0, _state);
         if (*nr > i) {
            tempdata->xR[i] = spline1d_rescaleval(0.0, tex0, a, *ex0, *x0, _state);
            i++;
         }
         *nr += bisectmethod(pa, tmpma, pb, tmpmb, tex0, tex1, x0, _state);
         if (*nr > i) {
            *x0 = spline1d_rescaleval(tex0, tex1, *ex0, *ex1, *x0, _state);
            if (i > 0) {
               if (*x0 != tempdata->xR[i - 1]) {
                  tempdata->xR[i] = *x0;
                  i++;
               } else {
                  --*nr;
               }
            } else {
               tempdata->xR[i] = *x0;
               i++;
            }
         }
         *nr += bisectmethod(pa, tmpma, pb, tmpmb, tex1, 1.0, x0, _state);
         if (*nr > i) {
            *x0 = spline1d_rescaleval(tex1, 1.0, *ex1, b, *x0, _state);
            if (i > 0) {
               if (*x0 != tempdata->xR[i - 1]) {
                  tempdata->xR[i] = *x0;
                  i++;
               } else {
                  --*nr;
               }
            } else {
               tempdata->xR[i] = *x0;
               i++;
            }
         }
      // write are found roots
         if (*nr > 0) {
            *x0 = tempdata->xR[0];
            if (*nr > 1) {
               *x1 = tempdata->xR[1];
            }
            if (*nr > 2) {
               *x2 = tempdata->xR[2];
            }
            return;
         }
      }
   }
}

// This function finds all roots and extrema of the spline S(x)  defined  at
// [A,B] (interval which contains spline nodes).
//
// It  does not extrapolates function, so roots and extrema located  outside
// of [A,B] will not be found. It returns all isolated (including  multiple)
// roots and extrema.
//
// Inputs:
//     C           -   spline interpolant
//
// Outputs:
//     R           -   array[NR], contains roots of the spline.
//                     In case there is no roots, this array has zero length.
//     NR          -   number of roots, >= 0
//     DR          -   is set to True in case there is at least one interval
//                     where spline is just a zero constant. Such degenerate
//                     cases are not reported in the R/NR
//     E           -   array[NE], contains  extrema  (maximums/minimums)  of
//                     the spline. In case there is no extrema,  this  array
//                     has zero length.
//     ET          -   array[NE], extrema types:
//                     * ET[i]>0 in case I-th extrema is a minimum
//                     * ET[i]<0 in case I-th extrema is a maximum
//     NE          -   number of extrema, >= 0
//     DE          -   is set to True in case there is at least one interval
//                     where spline is a constant. Such degenerate cases are
//                     not reported in the E/NE.
//
// NOTES:
//
// 1. This function does NOT report following kinds of roots:
//    * intervals where function is constantly zero
//    * roots which are outside of [A,B] (note: it CAN return A or B)
//
// 2. This function does NOT report following kinds of extrema:
//    * intervals where function is a constant
//    * extrema which are outside of (A,B) (note: it WON'T return A or B)
// ALGLIB Project: Copyright 26.09.2011 by Sergey Bochkanov
void spline1drootsandextrema(spline1dinterpolant *c, RVector *r, ae_int_t *nr, bool *dr, RVector *e, ZVector *et, ae_int_t *ne, bool *de, ae_state *_state) {
   ae_frame _frame_block;
   double pl;
   double ml;
   double pll;
   double pr;
   double mr;
   double x0;
   double x1;
   double x2;
   double ex0;
   double ex1;
   ae_int_t tne;
   ae_int_t tnr;
   ae_int_t i;
   ae_int_t j;
   bool nstep;
   ae_frame_make(_state, &_frame_block);
   SetVector(r);
   *nr = 0;
   *dr = false;
   SetVector(e);
   SetVector(et);
   *ne = 0;
   *de = false;
   NewVector(tr, 0, DT_REAL, _state);
   NewVector(tmpr, 0, DT_REAL, _state);
   NewVector(tmpe, 0, DT_REAL, _state);
   NewVector(tmpet, 0, DT_INT, _state);
   NewVector(tmpc, 0, DT_REAL, _state);
// exception handling
   ae_assert(c->k == 3, "Spline1DRootsAndExtrema : incorrect parameter C.K!", _state);
   ae_assert(c->continuity >= 0, "Spline1DRootsAndExtrema : parameter C.Continuity must not be less than 0!", _state);
// initialization of variable
   *nr = 0;
   *ne = 0;
   *dr = false;
   *de = false;
   nstep = true;
// consider case, when C.Continuty=0
   if (c->continuity == 0) {
   // allocation for auxiliary arrays
   // 'TmpR ' - it stores a time value for roots
   // 'TmpE ' - it stores a time value for extremums
   // 'TmpET '- it stores a time value for extremums type
      rvectorsetlengthatleast(&tmpr, 3 * (c->n - 1), _state);
      rvectorsetlengthatleast(&tmpe, 2 * (c->n - 1), _state);
      ivectorsetlengthatleast(&tmpet, 2 * (c->n - 1), _state);
   // start calculating
      for (i = 0; i < c->n - 1; i++) {
      // initialization pL, mL, pR, mR
         pl = c->c.xR[4 * i];
         ml = c->c.xR[4 * i + 1];
         pr = c->c.xR[4 * (i + 1)];
         mr = c->c.xR[4 * i + 1] + 2 * c->c.xR[4 * i + 2] * (c->x.xR[i + 1] - c->x.xR[i]) + 3 * c->c.xR[4 * i + 3] * (c->x.xR[i + 1] - c->x.xR[i]) * (c->x.xR[i + 1] - c->x.xR[i]);
      // pre-searching roots and extremums
         solvecubicpolinom(pl, ml, pr, mr, c->x.xR[i], c->x.xR[i + 1], &x0, &x1, &x2, &ex0, &ex1, &tnr, &tne, &tr, _state);
         *dr = *dr || tnr == -1;
         *de = *de || tne == -1;
      // searching of roots
         if (tnr == 1 && nstep) {
         // is there roots?
            if (*nr > 0) {
            // is a next root equal a previous root?
            // if is't, then write new root
               if (x0 != tmpr.xR[*nr - 1]) {
                  tmpr.xR[*nr] = x0;
                  ++*nr;
               }
            } else {
            // write a first root
               tmpr.xR[*nr] = x0;
               ++*nr;
            }
         } else {
         // case when function at a segment identically to zero
         // then we have to clear a root, if the one located on a
         // constant segment
            if (tnr == -1) {
            // safe state variable as constant
               if (nstep) {
                  nstep = false;
               }
            // clear the root, if there is
               if (*nr > 0) {
                  if (c->x.xR[i] == tmpr.xR[*nr - 1]) {
                     --*nr;
                  }
               }
            // change state for 'DR'
               if (!*dr) {
                  *dr = true;
               }
            } else {
               nstep = true;
            }
         }
      // searching of extremums
         if (i > 0) {
            pll = c->c.xR[4 * (i - 1)];
         // if pL=pLL or pL=pR then
            if (tne == -1) {
               if (!*de) {
                  *de = true;
               }
            } else {
               if (pl > pll && pl > pr) {
               // maximum
                  tmpet.xZ[*ne] = -1;
                  tmpe.xR[*ne] = c->x.xR[i];
                  ++*ne;
               } else {
                  if (pl < pll && pl < pr) {
                  // minimum
                     tmpet.xZ[*ne] = 1;
                     tmpe.xR[*ne] = c->x.xR[i];
                     ++*ne;
                  }
               }
            }
         }
      }
   // write final result
      rvectorsetlengthatleast(r, *nr, _state);
      rvectorsetlengthatleast(e, *ne, _state);
      ivectorsetlengthatleast(et, *ne, _state);
   // write roots
      for (i = 0; i < *nr; i++) {
         r->xR[i] = tmpr.xR[i];
      }
   // write extremums and their types
      for (i = 0; i < *ne; i++) {
         e->xR[i] = tmpe.xR[i];
         et->xZ[i] = tmpet.xZ[i];
      }
   } else {
   // case, when C.Continuity >= 1
   // 'TmpR ' - it stores a time value for roots
   // 'TmpC' - it stores a time value for extremums and
   // their function value (TmpC={EX0,F(EX0), EX1,F(EX1), ..., EXn,F(EXn)};)
   // 'TmpE' - it stores a time value for extremums only
   // 'TmpET'- it stores a time value for extremums type
      rvectorsetlengthatleast(&tmpr, 2 * c->n - 1, _state);
      rvectorsetlengthatleast(&tmpc, 4 * c->n, _state);
      rvectorsetlengthatleast(&tmpe, 2 * c->n, _state);
      ivectorsetlengthatleast(&tmpet, 2 * c->n, _state);
   // start calculating
      for (i = 0; i < c->n - 1; i++) {
      // we calculate pL,mL, pR,mR as Fi+1(F'i+1) at left border
         pl = c->c.xR[4 * i];
         ml = c->c.xR[4 * i + 1];
         pr = c->c.xR[4 * (i + 1)];
         mr = c->c.xR[4 * (i + 1) + 1];
      // calculating roots and extremums at [X[i],X[i+1]]
         solvecubicpolinom(pl, ml, pr, mr, c->x.xR[i], c->x.xR[i + 1], &x0, &x1, &x2, &ex0, &ex1, &tnr, &tne, &tr, _state);
      // searching roots
         if (tnr > 0) {
         // re-init tR
            if (tnr >= 1) {
               tr.xR[0] = x0;
            }
            if (tnr >= 2) {
               tr.xR[1] = x1;
            }
            if (tnr == 3) {
               tr.xR[2] = x2;
            }
         // start root selection
            if (*nr > 0) {
               if (tmpr.xR[*nr - 1] != x0) {
               // previous segment was't constant identical zero
                  if (nstep) {
                     for (j = 0; j < tnr; j++) {
                        tmpr.xR[*nr + j] = tr.xR[j];
                     }
                     *nr += tnr;
                  } else {
                  // previous segment was constant identical zero
                  // and we must ignore [NR+j-1] root
                     for (j = 1; j < tnr; j++) {
                        tmpr.xR[*nr + j - 1] = tr.xR[j];
                     }
                     *nr += tnr - 1;
                     nstep = true;
                  }
               } else {
                  for (j = 1; j < tnr; j++) {
                     tmpr.xR[*nr + j - 1] = tr.xR[j];
                  }
                  *nr += tnr - 1;
               }
            } else {
            // write first root
               for (j = 0; j < tnr; j++) {
                  tmpr.xR[*nr + j] = tr.xR[j];
               }
               *nr += tnr;
            }
         } else {
            if (tnr == -1) {
            // decrement 'NR' if at previous step was writen a root
            // (previous segment identical zero)
               if (*nr > 0 && nstep) {
                  --*nr;
               }
            // previous segment is't constant
               if (nstep) {
                  nstep = false;
               }
            // rewrite 'DR'
               if (!*dr) {
                  *dr = true;
               }
            }
         }
      // searching extremums
      // write all term like extremums
         if (tne == 1) {
            if (*ne > 0) {
            // just ignore identical extremums
            // because he must be one
               if (tmpc.xR[*ne - 2] != ex0) {
                  tmpc.xR[*ne] = ex0;
                  tmpc.xR[*ne + 1] = c->c.xR[4 * i] + c->c.xR[4 * i + 1] * (ex0 - c->x.xR[i]) + c->c.xR[4 * i + 2] * (ex0 - c->x.xR[i]) * (ex0 - c->x.xR[i]) + c->c.xR[4 * i + 3] * (ex0 - c->x.xR[i]) * (ex0 - c->x.xR[i]) * (ex0 - c->x.xR[i]);
                  *ne += 2;
               }
            } else {
            // write first extremum and it function value
               tmpc.xR[*ne] = ex0;
               tmpc.xR[*ne + 1] = c->c.xR[4 * i] + c->c.xR[4 * i + 1] * (ex0 - c->x.xR[i]) + c->c.xR[4 * i + 2] * (ex0 - c->x.xR[i]) * (ex0 - c->x.xR[i]) + c->c.xR[4 * i + 3] * (ex0 - c->x.xR[i]) * (ex0 - c->x.xR[i]) * (ex0 - c->x.xR[i]);
               *ne += 2;
            }
         } else {
            if (tne == 2) {
               if (*ne > 0) {
               // ignore identical extremum
                  if (tmpc.xR[*ne - 2] != ex0) {
                     tmpc.xR[*ne] = ex0;
                     tmpc.xR[*ne + 1] = c->c.xR[4 * i] + c->c.xR[4 * i + 1] * (ex0 - c->x.xR[i]) + c->c.xR[4 * i + 2] * (ex0 - c->x.xR[i]) * (ex0 - c->x.xR[i]) + c->c.xR[4 * i + 3] * (ex0 - c->x.xR[i]) * (ex0 - c->x.xR[i]) * (ex0 - c->x.xR[i]);
                     *ne += 2;
                  }
               } else {
               // write first extremum
                  tmpc.xR[*ne] = ex0;
                  tmpc.xR[*ne + 1] = c->c.xR[4 * i] + c->c.xR[4 * i + 1] * (ex0 - c->x.xR[i]) + c->c.xR[4 * i + 2] * (ex0 - c->x.xR[i]) * (ex0 - c->x.xR[i]) + c->c.xR[4 * i + 3] * (ex0 - c->x.xR[i]) * (ex0 - c->x.xR[i]) * (ex0 - c->x.xR[i]);
                  *ne += 2;
               }
            // write second extremum
               tmpc.xR[*ne] = ex1;
               tmpc.xR[*ne + 1] = c->c.xR[4 * i] + c->c.xR[4 * i + 1] * (ex1 - c->x.xR[i]) + c->c.xR[4 * i + 2] * (ex1 - c->x.xR[i]) * (ex1 - c->x.xR[i]) + c->c.xR[4 * i + 3] * (ex1 - c->x.xR[i]) * (ex1 - c->x.xR[i]) * (ex1 - c->x.xR[i]);
               *ne += 2;
            } else {
               if (tne == -1) {
                  if (!*de) {
                     *de = true;
                  }
               }
            }
         }
      }
   // checking of arrays
   // get number of extremums (tNe=NE/2)
   // initialize pL as value F0(X[0]) and
   // initialize pR as value Fn-1(X[N])
      tne = *ne / 2;
      *ne = 0;
      pl = c->c.xR[0];
      pr = c->c.xR[4 * (c->n - 1)];
      for (i = 0; i < tne; i++) {
         if (i > 0 && i < tne - 1) {
            if (tmpc.xR[2 * i + 1] > tmpc.xR[2 * (i - 1) + 1] && tmpc.xR[2 * i + 1] > tmpc.xR[2 * (i + 1) + 1]) {
            // maximum
               tmpe.xR[*ne] = tmpc.xR[2 * i];
               tmpet.xZ[*ne] = -1;
               ++*ne;
            } else {
               if (tmpc.xR[2 * i + 1] < tmpc.xR[2 * (i - 1) + 1] && tmpc.xR[2 * i + 1] < tmpc.xR[2 * (i + 1) + 1]) {
               // minimum
                  tmpe.xR[*ne] = tmpc.xR[2 * i];
                  tmpet.xZ[*ne] = 1;
                  ++*ne;
               }
            }
         } else {
            if (i == 0) {
               if (tmpc.xR[2 * i] != c->x.xR[0]) {
                  if (tmpc.xR[2 * i + 1] > pl && tmpc.xR[2 * i + 1] > tmpc.xR[2 * (i + 1) + 1]) {
                  // maximum
                     tmpe.xR[*ne] = tmpc.xR[2 * i];
                     tmpet.xZ[*ne] = -1;
                     ++*ne;
                  } else {
                     if (tmpc.xR[2 * i + 1] < pl && tmpc.xR[2 * i + 1] < tmpc.xR[2 * (i + 1) + 1]) {
                     // minimum
                        tmpe.xR[*ne] = tmpc.xR[2 * i];
                        tmpet.xZ[*ne] = 1;
                        ++*ne;
                     }
                  }
               }
            } else {
               if (i == tne - 1) {
                  if (tmpc.xR[2 * i] != c->x.xR[c->n - 1]) {
                     if (tmpc.xR[2 * i + 1] > tmpc.xR[2 * (i - 1) + 1] && tmpc.xR[2 * i + 1] > pr) {
                     // maximum
                        tmpe.xR[*ne] = tmpc.xR[2 * i];
                        tmpet.xZ[*ne] = -1;
                        ++*ne;
                     } else {
                        if (tmpc.xR[2 * i + 1] < tmpc.xR[2 * (i - 1) + 1] && tmpc.xR[2 * i + 1] < pr) {
                        // minimum
                           tmpe.xR[*ne] = tmpc.xR[2 * i];
                           tmpet.xZ[*ne] = 1;
                           ++*ne;
                        }
                     }
                  }
               }
            }
         }
      }
   // final results
   // allocate R, E, ET
      rvectorsetlengthatleast(r, *nr, _state);
      rvectorsetlengthatleast(e, *ne, _state);
      ivectorsetlengthatleast(et, *ne, _state);
   // write result for extremus and their types
      for (i = 0; i < *ne; i++) {
         e->xR[i] = tmpe.xR[i];
         et->xZ[i] = tmpet.xZ[i];
      }
   // write result for roots
      for (i = 0; i < *nr; i++) {
         r->xR[i] = tmpr.xR[i];
      }
   }
   ae_frame_leave(_state);
}

void spline1dinterpolant_init(void *_p, ae_state *_state, bool make_automatic) {
   spline1dinterpolant *p = (spline1dinterpolant *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->x, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->c, 0, DT_REAL, _state, make_automatic);
}

void spline1dinterpolant_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   spline1dinterpolant *dst = (spline1dinterpolant *)_dst;
   spline1dinterpolant *src = (spline1dinterpolant *)_src;
   dst->periodic = src->periodic;
   dst->n = src->n;
   dst->k = src->k;
   dst->continuity = src->continuity;
   ae_vector_copy(&dst->x, &src->x, _state, make_automatic);
   ae_vector_copy(&dst->c, &src->c, _state, make_automatic);
}

void spline1dinterpolant_free(void *_p, bool make_automatic) {
   spline1dinterpolant *p = (spline1dinterpolant *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->x, make_automatic);
   ae_vector_free(&p->c, make_automatic);
}

void spline1dfitreport_init(void *_p, ae_state *_state, bool make_automatic) {
   spline1dfitreport *p = (spline1dfitreport *)_p;
   ae_touch_ptr((void *)p);
}

void spline1dfitreport_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   spline1dfitreport *dst = (spline1dfitreport *)_dst;
   spline1dfitreport *src = (spline1dfitreport *)_src;
   dst->taskrcond = src->taskrcond;
   dst->rmserror = src->rmserror;
   dst->avgerror = src->avgerror;
   dst->avgrelerror = src->avgrelerror;
   dst->maxerror = src->maxerror;
}

void spline1dfitreport_free(void *_p, bool make_automatic) {
   spline1dfitreport *p = (spline1dfitreport *)_p;
   ae_touch_ptr((void *)p);
}
} // end of namespace alglib_impl

namespace alglib {
// 1-dimensional spline interpolant
DefClass(spline1dinterpolant, )

// Spline fitting report:
//     RMSError        RMS error
//     AvgError        average error
//     AvgRelError     average relative error (for non-zero Y[I])
//     MaxError        maximum error
//
// Fields  below are  filled  by   obsolete    functions   (Spline1DFitCubic,
// Spline1DFitHermite). Modern fitting functions do NOT fill these fields:
//     TaskRCond       reciprocal of task's condition number
DefClass(spline1dfitreport, DecVal(taskrcond) DecVal(rmserror) DecVal(avgerror) DecVal(avgrelerror) DecVal(maxerror))

void spline1dbuildlinear(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, spline1dinterpolant &c, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dbuildlinear(ConstT(ae_vector, x), ConstT(ae_vector, y), n, ConstT(spline1dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dbuildlinear(const real_1d_array &x, const real_1d_array &y, spline1dinterpolant &c, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'spline1dbuildlinear': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dbuildlinear(ConstT(ae_vector, x), ConstT(ae_vector, y), n, ConstT(spline1dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void spline1dbuildhermite(const real_1d_array &x, const real_1d_array &y, const real_1d_array &d, const ae_int_t n, spline1dinterpolant &c, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dbuildhermite(ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_vector, d), n, ConstT(spline1dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dbuildhermite(const real_1d_array &x, const real_1d_array &y, const real_1d_array &d, spline1dinterpolant &c, const xparams _xparams) {
   if (x.length() != y.length() || x.length() != d.length()) ThrowError("Error while calling 'spline1dbuildhermite': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dbuildhermite(ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_vector, d), n, ConstT(spline1dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void spline1dbuildcubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t boundltype, const double boundl, const ae_int_t boundrtype, const double boundr, spline1dinterpolant &c, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dbuildcubic(ConstT(ae_vector, x), ConstT(ae_vector, y), n, boundltype, boundl, boundrtype, boundr, ConstT(spline1dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dbuildcubic(const real_1d_array &x, const real_1d_array &y, spline1dinterpolant &c, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'spline1dbuildcubic': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   ae_int_t boundltype = 0;
   double boundl = 0.0;
   ae_int_t boundrtype = 0;
   double boundr = 0.0;
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dbuildcubic(ConstT(ae_vector, x), ConstT(ae_vector, y), n, boundltype, boundl, boundrtype, boundr, ConstT(spline1dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void spline1dbuildcatmullrom(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t boundtype, const double tension, spline1dinterpolant &c, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dbuildcatmullrom(ConstT(ae_vector, x), ConstT(ae_vector, y), n, boundtype, tension, ConstT(spline1dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dbuildcatmullrom(const real_1d_array &x, const real_1d_array &y, spline1dinterpolant &c, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'spline1dbuildcatmullrom': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   ae_int_t boundtype = 0;
   double tension = 0.0;
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dbuildcatmullrom(ConstT(ae_vector, x), ConstT(ae_vector, y), n, boundtype, tension, ConstT(spline1dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void spline1dbuildakima(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, spline1dinterpolant &c, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dbuildakima(ConstT(ae_vector, x), ConstT(ae_vector, y), n, ConstT(spline1dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dbuildakima(const real_1d_array &x, const real_1d_array &y, spline1dinterpolant &c, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'spline1dbuildakima': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dbuildakima(ConstT(ae_vector, x), ConstT(ae_vector, y), n, ConstT(spline1dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void spline1dbuildmonotone(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, spline1dinterpolant &c, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dbuildmonotone(ConstT(ae_vector, x), ConstT(ae_vector, y), n, ConstT(spline1dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dbuildmonotone(const real_1d_array &x, const real_1d_array &y, spline1dinterpolant &c, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'spline1dbuildmonotone': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dbuildmonotone(ConstT(ae_vector, x), ConstT(ae_vector, y), n, ConstT(spline1dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void spline1dgriddiffcubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t boundltype, const double boundl, const ae_int_t boundrtype, const double boundr, real_1d_array &d, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dgriddiffcubic(ConstT(ae_vector, x), ConstT(ae_vector, y), n, boundltype, boundl, boundrtype, boundr, ConstT(ae_vector, d), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dgriddiffcubic(const real_1d_array &x, const real_1d_array &y, real_1d_array &d, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'spline1dgriddiffcubic': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   ae_int_t boundltype = 0;
   double boundl = 0.0;
   ae_int_t boundrtype = 0;
   double boundr = 0.0;
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dgriddiffcubic(ConstT(ae_vector, x), ConstT(ae_vector, y), n, boundltype, boundl, boundrtype, boundr, ConstT(ae_vector, d), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void spline1dgriddiff2cubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t boundltype, const double boundl, const ae_int_t boundrtype, const double boundr, real_1d_array &d1, real_1d_array &d2, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dgriddiff2cubic(ConstT(ae_vector, x), ConstT(ae_vector, y), n, boundltype, boundl, boundrtype, boundr, ConstT(ae_vector, d1), ConstT(ae_vector, d2), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dgriddiff2cubic(const real_1d_array &x, const real_1d_array &y, real_1d_array &d1, real_1d_array &d2, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'spline1dgriddiff2cubic': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   ae_int_t boundltype = 0;
   double boundl = 0.0;
   ae_int_t boundrtype = 0;
   double boundr = 0.0;
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dgriddiff2cubic(ConstT(ae_vector, x), ConstT(ae_vector, y), n, boundltype, boundl, boundrtype, boundr, ConstT(ae_vector, d1), ConstT(ae_vector, d2), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void spline1dconvcubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t boundltype, const double boundl, const ae_int_t boundrtype, const double boundr, const real_1d_array &x2, const ae_int_t n2, real_1d_array &y2, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dconvcubic(ConstT(ae_vector, x), ConstT(ae_vector, y), n, boundltype, boundl, boundrtype, boundr, ConstT(ae_vector, x2), n2, ConstT(ae_vector, y2), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dconvcubic(const real_1d_array &x, const real_1d_array &y, const real_1d_array &x2, real_1d_array &y2, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'spline1dconvcubic': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   ae_int_t boundltype = 0;
   double boundl = 0.0;
   ae_int_t boundrtype = 0;
   double boundr = 0.0;
   ae_int_t n2 = x2.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dconvcubic(ConstT(ae_vector, x), ConstT(ae_vector, y), n, boundltype, boundl, boundrtype, boundr, ConstT(ae_vector, x2), n2, ConstT(ae_vector, y2), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void spline1dconvdiffcubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t boundltype, const double boundl, const ae_int_t boundrtype, const double boundr, const real_1d_array &x2, const ae_int_t n2, real_1d_array &y2, real_1d_array &d2, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dconvdiffcubic(ConstT(ae_vector, x), ConstT(ae_vector, y), n, boundltype, boundl, boundrtype, boundr, ConstT(ae_vector, x2), n2, ConstT(ae_vector, y2), ConstT(ae_vector, d2), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dconvdiffcubic(const real_1d_array &x, const real_1d_array &y, const real_1d_array &x2, real_1d_array &y2, real_1d_array &d2, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'spline1dconvdiffcubic': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   ae_int_t boundltype = 0;
   double boundl = 0.0;
   ae_int_t boundrtype = 0;
   double boundr = 0.0;
   ae_int_t n2 = x2.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dconvdiffcubic(ConstT(ae_vector, x), ConstT(ae_vector, y), n, boundltype, boundl, boundrtype, boundr, ConstT(ae_vector, x2), n2, ConstT(ae_vector, y2), ConstT(ae_vector, d2), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void spline1dconvdiff2cubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t boundltype, const double boundl, const ae_int_t boundrtype, const double boundr, const real_1d_array &x2, const ae_int_t n2, real_1d_array &y2, real_1d_array &d2, real_1d_array &dd2, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dconvdiff2cubic(ConstT(ae_vector, x), ConstT(ae_vector, y), n, boundltype, boundl, boundrtype, boundr, ConstT(ae_vector, x2), n2, ConstT(ae_vector, y2), ConstT(ae_vector, d2), ConstT(ae_vector, dd2), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dconvdiff2cubic(const real_1d_array &x, const real_1d_array &y, const real_1d_array &x2, real_1d_array &y2, real_1d_array &d2, real_1d_array &dd2, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'spline1dconvdiff2cubic': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   ae_int_t boundltype = 0;
   double boundl = 0.0;
   ae_int_t boundrtype = 0;
   double boundr = 0.0;
   ae_int_t n2 = x2.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dconvdiff2cubic(ConstT(ae_vector, x), ConstT(ae_vector, y), n, boundltype, boundl, boundrtype, boundr, ConstT(ae_vector, x2), n2, ConstT(ae_vector, y2), ConstT(ae_vector, d2), ConstT(ae_vector, dd2), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

double spline1dcalc(const spline1dinterpolant &c, const double x, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::spline1dcalc(ConstT(spline1dinterpolant, c), x, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

void spline1ddiff(const spline1dinterpolant &c, const double x, double &s, double &ds, double &d2s, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1ddiff(ConstT(spline1dinterpolant, c), x, &s, &ds, &d2s, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline1dunpack(const spline1dinterpolant &c, ae_int_t &n, real_2d_array &tbl, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dunpack(ConstT(spline1dinterpolant, c), &n, ConstT(ae_matrix, tbl), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline1dlintransx(const spline1dinterpolant &c, const double a, const double b, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dlintransx(ConstT(spline1dinterpolant, c), a, b, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline1dlintransy(const spline1dinterpolant &c, const double a, const double b, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dlintransy(ConstT(spline1dinterpolant, c), a, b, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

double spline1dintegrate(const spline1dinterpolant &c, const double x, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::spline1dintegrate(ConstT(spline1dinterpolant, c), x, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

void spline1dfit(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t m, const double lambdans, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dfit(ConstT(ae_vector, x), ConstT(ae_vector, y), n, m, lambdans, ConstT(spline1dinterpolant, s), ConstT(spline1dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dfit(const real_1d_array &x, const real_1d_array &y, const ae_int_t m, const double lambdans, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'spline1dfit': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dfit(ConstT(ae_vector, x), ConstT(ae_vector, y), n, m, lambdans, ConstT(spline1dinterpolant, s), ConstT(spline1dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif
} // end of namespace alglib

// === LSFIT Package ===
// Depends on: (Optimization) MINLM
// Depends on: POLINT, SPLINE1D
namespace alglib_impl {
// This function analyzes section of curve for processing by RDP algorithm:
// given set of points X,Y with indexes [I0,I1] it returns point with
// worst deviation from linear model (non-parametric version which sees curve
// as Y(x)).
//
// Inputs:
//     X, Y        -   SORTED arrays.
//     I0,I1       -   interval (boundaries included) to process
//     Eps         -   desired precision
//
// Outputs:
//     WorstIdx    -   index of worst point
//     WorstError  -   error at worst point
//
// NOTE: this function guarantees that it returns exactly zero for a section
//       with less than 3 points.
// ALGLIB Project: Copyright 02.10.2014 by Sergey Bochkanov
static void lsfit_rdpanalyzesection(RVector *x, RVector *y, ae_int_t i0, ae_int_t i1, ae_int_t *worstidx, double *worsterror, ae_state *_state) {
   ae_int_t i;
   double xleft;
   double xright;
   double vx;
   double ve;
   double a;
   double b;
   *worstidx = 0;
   *worsterror = 0;
   xleft = x->xR[i0];
   xright = x->xR[i1];
   if (i1 - i0 + 1 < 3 || xright == xleft) {
      *worstidx = i0;
      *worsterror = 0.0;
      return;
   }
   a = (y->xR[i1] - y->xR[i0]) / (xright - xleft);
   b = (y->xR[i0] * xright - y->xR[i1] * xleft) / (xright - xleft);
   *worstidx = -1;
   *worsterror = 0.0;
   for (i = i0 + 1; i < i1; i++) {
      vx = x->xR[i];
      ve = ae_fabs(a * vx + b - y->xR[i], _state);
      if ((vx > xleft && vx < xright) && ve > *worsterror) {
         *worsterror = ve;
         *worstidx = i;
      }
   }
}

// Recursive splitting of interval [I0,I1] (right boundary included) with RDP
// algorithm (non-parametric version which sees curve as Y(x)).
//
// Inputs:
//     X, Y        -   SORTED arrays.
//     I0,I1       -   interval (boundaries included) to process
//     Eps         -   desired precision
//     XOut,YOut   -   preallocated output arrays large enough to store result;
//                     XOut[0..1], YOut[0..1] contain first and last points of
//                     curve
//     NOut        -   must contain 2 on input
//
// Outputs:
//     XOut, YOut  -   curve generated by RDP algorithm, UNSORTED
//     NOut        -   number of points in curve
// ALGLIB Project: Copyright 02.10.2014 by Sergey Bochkanov
static void lsfit_rdprecursive(RVector *x, RVector *y, ae_int_t i0, ae_int_t i1, double eps, RVector *xout, RVector *yout, ae_int_t *nout, ae_state *_state) {
   ae_int_t worstidx;
   double worsterror;
   ae_assert(eps > 0.0, "RDPRecursive: internal error, Eps<0", _state);
   lsfit_rdpanalyzesection(x, y, i0, i1, &worstidx, &worsterror, _state);
   if (worsterror <= eps) {
      return;
   }
   xout->xR[*nout] = x->xR[worstidx];
   yout->xR[*nout] = y->xR[worstidx];
   ++*nout;
   if (worstidx - i0 < i1 - worstidx) {
      lsfit_rdprecursive(x, y, i0, worstidx, eps, xout, yout, nout, _state);
      lsfit_rdprecursive(x, y, worstidx, i1, eps, xout, yout, nout, _state);
   } else {
      lsfit_rdprecursive(x, y, worstidx, i1, eps, xout, yout, nout, _state);
      lsfit_rdprecursive(x, y, i0, worstidx, eps, xout, yout, nout, _state);
   }
}

// This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
// Peucker algorithm, which stops after generating specified number of linear
// sections.
//
// IMPORTANT:
// * it does NOT perform least-squares fitting; it  builds  curve,  but  this
//   curve does not minimize some least squares metric.  See  description  of
//   RDP algorithm (say, in Wikipedia) for more details on WHAT is performed.
// * this function does NOT work with parametric curves  (i.e.  curves  which
//   can be represented as {X(t),Y(t)}. It works with curves   which  can  be
//   represented as Y(X). Thus,  it  is  impossible  to  model  figures  like
//   circles  with  this  functions.
//   If  you  want  to  work  with  parametric   curves,   you   should   use
//   ParametricRDPFixed() function provided  by  "Parametric"  subpackage  of
//   "Interpolation" package.
//
// Inputs:
//     X       -   array of X-coordinates:
//                 * at least N elements
//                 * can be unordered (points are automatically sorted)
//                 * this function may accept non-distinct X (see below for
//                   more information on handling of such inputs)
//     Y       -   array of Y-coordinates:
//                 * at least N elements
//     N       -   number of elements in X/Y
//     M       -   desired number of sections:
//                 * at most M sections are generated by this function
//                 * less than M sections can be generated if we have N<M
//                   (or some X are non-distinct).
//
// Outputs:
//     X2      -   X-values of corner points for piecewise approximation,
//                 has length NSections+1 or zero (for NSections=0).
//     Y2      -   Y-values of corner points,
//                 has length NSections+1 or zero (for NSections=0).
//     NSections-  number of sections found by algorithm, NSections <= M,
//                 NSections can be zero for degenerate datasets
//                 (N <= 1 or all X[] are non-distinct).
//
// NOTE: X2/Y2 are ordered arrays, i.e. (X2[0],Y2[0]) is  a  first  point  of
//       curve, (X2[NSection-1],Y2[NSection-1]) is the last point.
// ALGLIB: Copyright 02.10.2014 by Sergey Bochkanov
// API: void lstfitpiecewiselinearrdpfixed(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t m, real_1d_array &x2, real_1d_array &y2, ae_int_t &nsections, const xparams _xparams = xdefault);
void lstfitpiecewiselinearrdpfixed(RVector *x, RVector *y, ae_int_t n, ae_int_t m, RVector *x2, RVector *y2, ae_int_t *nsections, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t k2;
   double v;
   ae_int_t worstidx;
   double worsterror;
   ae_int_t idx0;
   ae_int_t idx1;
   double e0;
   double e1;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   SetVector(x2);
   SetVector(y2);
   *nsections = 0;
   NewVector(buf0, 0, DT_REAL, _state);
   NewVector(buf1, 0, DT_REAL, _state);
   NewMatrix(sections, 0, 0, DT_REAL, _state);
   NewVector(points, 0, DT_REAL, _state);
   NewVector(heaperrors, 0, DT_REAL, _state);
   NewVector(heaptags, 0, DT_INT, _state);
   ae_assert(n >= 0, "LSTFitPiecewiseLinearRDPFixed: N<0", _state);
   ae_assert(m >= 1, "LSTFitPiecewiseLinearRDPFixed: M<1", _state);
   ae_assert(x->cnt >= n, "LSTFitPiecewiseLinearRDPFixed: Length(X)<N", _state);
   ae_assert(y->cnt >= n, "LSTFitPiecewiseLinearRDPFixed: Length(Y)<N", _state);
   if (n <= 1) {
      *nsections = 0;
      ae_frame_leave(_state);
      return;
   }
// Sort points.
// Handle possible ties (tied values are replaced by their mean)
   tagsortfastr(x, y, &buf0, &buf1, n, _state);
   i = 0;
   while (i < n) {
      j = i + 1;
      v = y->xR[i];
      while (j < n && x->xR[j] == x->xR[i]) {
         v += y->xR[j];
         j++;
      }
      v /= j - i;
      for (k = i; k < j; k++) {
         y->xR[k] = v;
      }
      i = j;
   }
// Handle degenerate case x[0]=x[N-1]
   if (x->xR[n - 1] == x->xR[0]) {
      *nsections = 0;
      ae_frame_leave(_state);
      return;
   }
// Prepare first section
   lsfit_rdpanalyzesection(x, y, 0, n - 1, &worstidx, &worsterror, _state);
   ae_matrix_set_length(&sections, m, 4, _state);
   ae_vector_set_length(&heaperrors, m, _state);
   ae_vector_set_length(&heaptags, m, _state);
   *nsections = 1;
   sections.xyR[0][0] = 0.0;
   sections.xyR[0][1] = (double)(n - 1);
   sections.xyR[0][2] = (double)worstidx;
   sections.xyR[0][3] = worsterror;
   heaperrors.xR[0] = worsterror;
   heaptags.xZ[0] = 0;
   ae_assert(sections.xyR[0][1] == (double)(n - 1), "RDP algorithm: integrity check failed", _state);
// Main loop.
// Repeatedly find section with worst error and divide it.
// Terminate after M-th section, or because of other reasons (see loop internals).
   while (*nsections < m) {
   // Break if worst section has zero error.
   // Store index of worst section to K.
      if (heaperrors.xR[0] == 0.0) {
         break;
      }
      k = heaptags.xZ[0];
   // K-th section is divided in two:
   // * first  one spans interval from X[Sections[K,0]] to X[Sections[K,2]]
   // * second one spans interval from X[Sections[K,2]] to X[Sections[K,1]]
   //
   // First section is stored at K-th position, second one is appended to the table.
   // Then we update heap which stores pairs of (error,section_index)
      k0 = iround(sections.xyR[k][0], _state);
      k1 = iround(sections.xyR[k][1], _state);
      k2 = iround(sections.xyR[k][2], _state);
      lsfit_rdpanalyzesection(x, y, k0, k2, &idx0, &e0, _state);
      lsfit_rdpanalyzesection(x, y, k2, k1, &idx1, &e1, _state);
      sections.xyR[k][0] = (double)k0;
      sections.xyR[k][1] = (double)k2;
      sections.xyR[k][2] = (double)idx0;
      sections.xyR[k][3] = e0;
      tagheapreplacetopi(&heaperrors, &heaptags, *nsections, e0, k, _state);
      sections.xyR[*nsections][0] = (double)k2;
      sections.xyR[*nsections][1] = (double)k1;
      sections.xyR[*nsections][2] = (double)idx1;
      sections.xyR[*nsections][3] = e1;
      tagheappushi(&heaperrors, &heaptags, nsections, e1, *nsections, _state);
   }
// Convert from sections to points
   ae_vector_set_length(&points, *nsections + 1, _state);
   k = iround(sections.xyR[0][1], _state);
   for (i = 0; i < *nsections; i++) {
      points.xR[i] = round(sections.xyR[i][0]);
      if (x->xR[iround(sections.xyR[i][1], _state)] > x->xR[k]) {
         k = iround(sections.xyR[i][1], _state);
      }
   }
   points.xR[*nsections] = (double)k;
   tagsortfast(&points, &buf0, *nsections + 1, _state);
// Output sections:
// * first NSection elements of X2/Y2 are filled by x/y at left boundaries of sections
// * last element of X2/Y2 is filled by right boundary of rightmost section
// * X2/Y2 is sorted by ascending of X2
   ae_vector_set_length(x2, *nsections + 1, _state);
   ae_vector_set_length(y2, *nsections + 1, _state);
   for (i = 0; i <= *nsections; i++) {
      x2->xR[i] = x->xR[iround(points.xR[i], _state)];
      y2->xR[i] = y->xR[iround(points.xR[i], _state)];
   }
   ae_frame_leave(_state);
}

// This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
// Peucker algorithm, which stops after achieving desired precision.
//
// IMPORTANT:
// * it performs non-least-squares fitting; it builds curve, but  this  curve
//   does not minimize some least squares  metric.  See  description  of  RDP
//   algorithm (say, in Wikipedia) for more details on WHAT is performed.
// * this function does NOT work with parametric curves  (i.e.  curves  which
//   can be represented as {X(t),Y(t)}. It works with curves   which  can  be
//   represented as Y(X). Thus, it is impossible to model figures like circles
//   with this functions.
//   If  you  want  to  work  with  parametric   curves,   you   should   use
//   ParametricRDPFixed() function provided  by  "Parametric"  subpackage  of
//   "Interpolation" package.
//
// Inputs:
//     X       -   array of X-coordinates:
//                 * at least N elements
//                 * can be unordered (points are automatically sorted)
//                 * this function may accept non-distinct X (see below for
//                   more information on handling of such inputs)
//     Y       -   array of Y-coordinates:
//                 * at least N elements
//     N       -   number of elements in X/Y
//     Eps     -   positive number, desired precision.
//
//
// Outputs:
//     X2      -   X-values of corner points for piecewise approximation,
//                 has length NSections+1 or zero (for NSections=0).
//     Y2      -   Y-values of corner points,
//                 has length NSections+1 or zero (for NSections=0).
//     NSections-  number of sections found by algorithm,
//                 NSections can be zero for degenerate datasets
//                 (N <= 1 or all X[] are non-distinct).
//
// NOTE: X2/Y2 are ordered arrays, i.e. (X2[0],Y2[0]) is  a  first  point  of
//       curve, (X2[NSection-1],Y2[NSection-1]) is the last point.
// ALGLIB: Copyright 02.10.2014 by Sergey Bochkanov
// API: void lstfitpiecewiselinearrdp(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const double eps, real_1d_array &x2, real_1d_array &y2, ae_int_t &nsections, const xparams _xparams = xdefault);
void lstfitpiecewiselinearrdp(RVector *x, RVector *y, ae_int_t n, double eps, RVector *x2, RVector *y2, ae_int_t *nsections, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_int_t npts;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   SetVector(x2);
   SetVector(y2);
   *nsections = 0;
   NewVector(buf0, 0, DT_REAL, _state);
   NewVector(buf1, 0, DT_REAL, _state);
   NewVector(xtmp, 0, DT_REAL, _state);
   NewVector(ytmp, 0, DT_REAL, _state);
   ae_assert(n >= 0, "LSTFitPiecewiseLinearRDP: N<0", _state);
   ae_assert(eps > 0.0, "LSTFitPiecewiseLinearRDP: Eps <= 0", _state);
   ae_assert(x->cnt >= n, "LSTFitPiecewiseLinearRDP: Length(X)<N", _state);
   ae_assert(y->cnt >= n, "LSTFitPiecewiseLinearRDP: Length(Y)<N", _state);
   if (n <= 1) {
      *nsections = 0;
      ae_frame_leave(_state);
      return;
   }
// Sort points.
// Handle possible ties (tied values are replaced by their mean)
   tagsortfastr(x, y, &buf0, &buf1, n, _state);
   i = 0;
   while (i < n) {
      j = i + 1;
      v = y->xR[i];
      while (j < n && x->xR[j] == x->xR[i]) {
         v += y->xR[j];
         j++;
      }
      v /= j - i;
      for (k = i; k < j; k++) {
         y->xR[k] = v;
      }
      i = j;
   }
// Handle degenerate case x[0]=x[N-1]
   if (x->xR[n - 1] == x->xR[0]) {
      *nsections = 0;
      ae_frame_leave(_state);
      return;
   }
// Prepare data for recursive algorithm
   ae_vector_set_length(&xtmp, n, _state);
   ae_vector_set_length(&ytmp, n, _state);
   npts = 2;
   xtmp.xR[0] = x->xR[0];
   ytmp.xR[0] = y->xR[0];
   xtmp.xR[1] = x->xR[n - 1];
   ytmp.xR[1] = y->xR[n - 1];
   lsfit_rdprecursive(x, y, 0, n - 1, eps, &xtmp, &ytmp, &npts, _state);
// Output sections:
// * first NSection elements of X2/Y2 are filled by x/y at left boundaries of sections
// * last element of X2/Y2 is filled by right boundary of rightmost section
// * X2/Y2 is sorted by ascending of X2
   *nsections = npts - 1;
   ae_vector_set_length(x2, npts, _state);
   ae_vector_set_length(y2, npts, _state);
   for (i = 0; i <= *nsections; i++) {
      x2->xR[i] = xtmp.xR[i];
      y2->xR[i] = ytmp.xR[i];
   }
   tagsortfastr(x2, y2, &buf0, &buf1, npts, _state);
   ae_frame_leave(_state);
}

static void lsfit_clearreport(lsfitreport *rep, ae_state *_state) {
   rep->taskrcond = 0.0;
   rep->iterationscount = 0;
   rep->varidx = -1;
   rep->rmserror = 0.0;
   rep->avgerror = 0.0;
   rep->avgrelerror = 0.0;
   rep->maxerror = 0.0;
   rep->wrmserror = 0.0;
   rep->r2 = 0.0;
   ae_matrix_set_length(&rep->covpar, 0, 0, _state);
   ae_vector_set_length(&rep->errpar, 0, _state);
   ae_vector_set_length(&rep->errcurve, 0, _state);
   ae_vector_set_length(&rep->noise, 0, _state);
}

// This internal function estimates covariance matrix and other error-related
// information for linear/nonlinear least squares model.
//
// It has a bit awkward interface, but it can be used  for  both  linear  and
// nonlinear problems.
//
// Inputs:
//     F1  -   array[0..N-1,0..K-1]:
//             * for linear problems - matrix of function values
//             * for nonlinear problems - Jacobian matrix
//     F0  -   array[0..N-1]:
//             * for linear problems - must be filled with zeros
//             * for nonlinear problems - must store values of function being
//               fitted
//     Y   -   array[0..N-1]:
//             * for linear and nonlinear problems - must store target values
//     W   -   weights, array[0..N-1]:
//             * for linear and nonlinear problems - weights
//     X   -   array[0..K-1]:
//             * for linear and nonlinear problems - current solution
//     S   -   array[0..K-1]:
//             * its components should be strictly positive
//             * squared inverse of this diagonal matrix is used as damping
//               factor for covariance matrix (linear and nonlinear problems)
//             * for nonlinear problems, when scale of the variables is usually
//               explicitly given by user, you may use scale vector for this
//               parameter
//             * for linear problems you may set this parameter to
//               S=sqrt(1/diag(F'*F))
//             * this parameter is automatically rescaled by this function,
//               only relative magnitudes of its components (with respect to
//               each other) matter.
//     N   -   number of points, N>0.
//     K   -   number of dimensions
//     Rep -   structure which is used to store results
//     Z   -   additional matrix which, depending on ZKind, may contain some
//             information used to accelerate calculations - or just can be
//             temporary buffer:
//             * for ZKind=0       Z contains no information, just temporary
//                                 buffer which can be resized and used as needed
//             * for ZKind=1       Z contains triangular matrix from QR
//                                 decomposition of W*F1. This matrix can be used
//                                 to speedup calculation of covariance matrix.
//                                 It should not be changed by algorithm.
//     ZKind-  contents of Z
//
// Outputs:
//
// * Rep.CovPar        covariance matrix for parameters, array[K,K].
// * Rep.ErrPar        errors in parameters, array[K],
//                     errpar = sqrt(diag(CovPar))
// * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
//                     best-fit curve from "ideal" best-fit curve built  with
//                     infinite number of samples, array[N].
//                     errcurve = sqrt(diag(J*CovPar*J')),
//                     where J is Jacobian matrix.
// * Rep.Noise         vector of per-point estimates of noise, array[N]
// * Rep.R2            coefficient of determination (non-weighted)
//
// Other fields of Rep are not changed.
//
// IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
//             account boundary/linear constraints! Presence  of  constraints
//             changes distribution of errors, but there is no  easy  way  to
//             account for constraints when you calculate covariance matrix.
//
// NOTE:       noise in the data is estimated as follows:
//             * for fitting without user-supplied  weights  all  points  are
//               assumed to have same level of noise, which is estimated from
//               the data
//             * for fitting with user-supplied weights we assume that  noise
//               level in I-th point is inversely proportional to Ith weight.
//               Coefficient of proportionality is estimated from the data.
//
// NOTE:       we apply small amount of regularization when we invert squared
//             Jacobian and calculate covariance matrix. It  guarantees  that
//             algorithm won't divide by zero  during  inversion,  but  skews
//             error estimates a bit (fractional error is about 10^-9).
//
//             However, we believe that this difference is insignificant  for
//             all practical purposes except for the situation when you  want
//             to compare ALGLIB results with "reference"  implementation  up
//             to the last significant digit.
// ALGLIB Project: Copyright 10.12.2009 by Sergey Bochkanov
static void lsfit_estimateerrors(RMatrix *f1, RVector *f0, RVector *y, RVector *w, RVector *x, RVector *s, ae_int_t n, ae_int_t k, lsfitreport *rep, RMatrix *z, ae_int_t zkind, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t j1;
   double v;
   double noisec;
   ae_int_t info;
   ae_int_t nzcnt;
   double avg;
   double rss;
   double tss;
   double sz;
   double ss;
   ae_frame_make(_state, &_frame_block);
   DupVector(s, _state);
   NewObj(matinvreport, invrep, _state);
// Compute NZCnt - count of non-zero weights
   nzcnt = 0;
   for (i = 0; i < n; i++) {
      if (w->xR[i] != 0.0) {
         nzcnt++;
      }
   }
// Compute R2
   if (nzcnt > 0) {
      avg = 0.0;
      for (i = 0; i < n; i++) {
         if (w->xR[i] != 0.0) {
            avg += y->xR[i];
         }
      }
      avg /= nzcnt;
      rss = 0.0;
      tss = 0.0;
      for (i = 0; i < n; i++) {
         if (w->xR[i] != 0.0) {
            v = ae_v_dotproduct(f1->xyR[i], 1, x->xR, 1, k);
            v += f0->xR[i];
            rss += sqr(v - y->xR[i], _state);
            tss += sqr(y->xR[i] - avg, _state);
         }
      }
      if (tss != 0.0) {
         rep->r2 = maxreal(1.0 - rss / tss, 0.0, _state);
      } else {
         rep->r2 = 1.0;
      }
   } else {
      rep->r2 = 0.0;
   }
// Compute estimate of proportionality between noise in the data and weights:
//     NoiseC = mean(per-point-noise*per-point-weight)
// Noise level (standard deviation) at each point is equal to NoiseC/W[I].
   if (nzcnt > k) {
      noisec = 0.0;
      for (i = 0; i < n; i++) {
         if (w->xR[i] != 0.0) {
            v = ae_v_dotproduct(f1->xyR[i], 1, x->xR, 1, k);
            v += f0->xR[i];
            noisec += sqr((v - y->xR[i]) * w->xR[i], _state);
         }
      }
      noisec = ae_sqrt(noisec / (nzcnt - k), _state);
   } else {
      noisec = 0.0;
   }
// Two branches on noise level:
// * NoiseC>0   normal situation
// * NoiseC=0   degenerate case CovPar is filled by zeros
   rmatrixsetlengthatleast(&rep->covpar, k, k, _state);
   if (noisec > 0.0) {
   // Normal situation: non-zero noise level
      ae_assert(zkind == 0 || zkind == 1, "LSFit: internal error in EstimateErrors() function", _state);
      if (zkind == 0) {
      // Z contains no additional information which can be used to speed up
      // calculations. We have to calculate covariance matrix on our own:
      // * Compute scaled Jacobian N*J, where N[i,i]=WCur[I]/NoiseC, store in Z
      // * Compute Z'*Z, store in CovPar
      // * Apply moderate regularization to CovPar and compute matrix inverse.
      //   In case inverse failed, increase regularization parameter and try
      //   again.
         rmatrixsetlengthatleast(z, n, k, _state);
         for (i = 0; i < n; i++) {
            v = w->xR[i] / noisec;
            ae_v_moved(z->xyR[i], 1, f1->xyR[i], 1, k, v);
         }
      // Convert S to automatically scaled damped matrix:
      // * calculate SZ - sum of diagonal elements of Z'*Z
      // * calculate SS - sum of diagonal elements of S^(-2)
      // * overwrite S by (SZ/SS)*S^(-2)
      // * now S has approximately same magnitude as giagonal of Z'*Z
         sz = 0.0;
         for (i = 0; i < n; i++) {
            for (j = 0; j < k; j++) {
               sz += z->xyR[i][j] * z->xyR[i][j];
            }
         }
         if (sz == 0.0) {
            sz = 1.0;
         }
         ss = 0.0;
         for (j = 0; j < k; j++) {
            ss += 1 / sqr(s->xR[j], _state);
         }
         for (j = 0; j < k; j++) {
            s->xR[j] = sz / ss / sqr(s->xR[j], _state);
         }
      // Calculate damped inverse inv(Z'*Z+S).
      // We increase damping factor V until Z'*Z become well-conditioned.
         v = 1.0E3 * machineepsilon;
         do {
            rmatrixsyrk(k, n, 1.0, z, 0, 0, 2, 0.0, &rep->covpar, 0, 0, true, _state);
            for (i = 0; i < k; i++) {
               rep->covpar.xyR[i][i] += v * s->xR[i];
            }
            spdmatrixinverse(&rep->covpar, k, true, &info, &invrep, _state);
            v *= 10;
         } while (info <= 0);
         for (i = 0; i < k; i++) {
            for (j = i + 1; j < k; j++) {
               rep->covpar.xyR[j][i] = rep->covpar.xyR[i][j];
            }
         }
      }
      if (zkind == 1) {
      // We can reuse additional information:
      // * Z contains R matrix from QR decomposition of W*F1
      // * After multiplication by 1/NoiseC we get Z_mod = N*F1, where diag(N)=w[i]/NoiseC
      // * Such triangular Z_mod is a Cholesky factor from decomposition of J'*N'*N*J.
      //   Thus, we can calculate covariance matrix as inverse of the matrix given by
      //   its Cholesky decomposition. It allow us to avoid time-consuming calculation
      //   of J'*N'*N*J in CovPar - complexity is reduced from O(N*K^2) to O(K^3), which
      //   is quite good because K is usually orders of magnitude smaller than N.
      //
      // First, convert S to automatically scaled damped matrix:
      // * calculate SZ - sum of magnitudes of diagonal elements of Z/NoiseC
      // * calculate SS - sum of diagonal elements of S^(-1)
      // * overwrite S by (SZ/SS)*S^(-1)
      // * now S has approximately same magnitude as giagonal of Z'*Z
         sz = 0.0;
         for (j = 0; j < k; j++) {
            sz += ae_fabs(z->xyR[j][j] / noisec, _state);
         }
         if (sz == 0.0) {
            sz = 1.0;
         }
         ss = 0.0;
         for (j = 0; j < k; j++) {
            ss += 1 / s->xR[j];
         }
         for (j = 0; j < k; j++) {
            s->xR[j] = sz / ss / s->xR[j];
         }
      // Calculate damped inverse of inv((Z+v*S)'*(Z+v*S))
      // We increase damping factor V until matrix become well-conditioned.
         v = 1.0E3 * machineepsilon;
         do {
            for (i = 0; i < k; i++) {
               for (j = i; j < k; j++) {
                  rep->covpar.xyR[i][j] = z->xyR[i][j] / noisec;
               }
               rep->covpar.xyR[i][i] += v * s->xR[i];
            }
            spdmatrixcholeskyinverse(&rep->covpar, k, true, &info, &invrep, _state);
            v *= 10;
         } while (info <= 0);
         for (i = 0; i < k; i++) {
            for (j = i + 1; j < k; j++) {
               rep->covpar.xyR[j][i] = rep->covpar.xyR[i][j];
            }
         }
      }
   } else {
   // Degenerate situation: zero noise level, covariance matrix is zero.
      for (i = 0; i < k; i++) {
         for (j = 0; j < k; j++) {
            rep->covpar.xyR[j][i] = 0.0;
         }
      }
   }
// Estimate erorrs in parameters, curve and per-point noise
   rvectorsetlengthatleast(&rep->errpar, k, _state);
   rvectorsetlengthatleast(&rep->errcurve, n, _state);
   rvectorsetlengthatleast(&rep->noise, n, _state);
   for (i = 0; i < k; i++) {
      rep->errpar.xR[i] = ae_sqrt(rep->covpar.xyR[i][i], _state);
   }
   for (i = 0; i < n; i++) {
   // ErrCurve[I] is sqrt(P[i,i]) where P=J*CovPar*J'
      v = 0.0;
      for (j = 0; j < k; j++) {
         for (j1 = 0; j1 < k; j1++) {
            v += f1->xyR[i][j] * rep->covpar.xyR[j][j1] * f1->xyR[i][j1];
         }
      }
      rep->errcurve.xR[i] = ae_sqrt(v, _state);
   // Noise[i] is filled using weights and current estimate of noise level
      if (w->xR[i] != 0.0) {
         rep->noise.xR[i] = noisec / w->xR[i];
      } else {
         rep->noise.xR[i] = 0.0;
      }
   }
   ae_frame_leave(_state);
}

// Internal fitting subroutine
static void lsfit_lsfitlinearinternal(RVector *y, RVector *w, RMatrix *fmatrix, ae_int_t n, ae_int_t m, ae_int_t *info, RVector *c, lsfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   double threshold;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_int_t relcnt;
   ae_frame_make(_state, &_frame_block);
   *info = 0;
   SetVector(c);
   SetObj(lsfitreport, rep);
   NewMatrix(ft, 0, 0, DT_REAL, _state);
   NewMatrix(q, 0, 0, DT_REAL, _state);
   NewMatrix(l, 0, 0, DT_REAL, _state);
   NewMatrix(r, 0, 0, DT_REAL, _state);
   NewVector(b, 0, DT_REAL, _state);
   NewVector(wmod, 0, DT_REAL, _state);
   NewVector(tau, 0, DT_REAL, _state);
   NewVector(nzeros, 0, DT_REAL, _state);
   NewVector(s, 0, DT_REAL, _state);
   NewVector(sv, 0, DT_REAL, _state);
   NewMatrix(u, 0, 0, DT_REAL, _state);
   NewMatrix(vt, 0, 0, DT_REAL, _state);
   NewVector(tmp, 0, DT_REAL, _state);
   NewVector(utb, 0, DT_REAL, _state);
   NewVector(sutb, 0, DT_REAL, _state);
   lsfit_clearreport(rep, _state);
   if (n < 1 || m < 1) {
      *info = -1;
      ae_frame_leave(_state);
      return;
   }
   *info = 1;
   threshold = ae_sqrt(machineepsilon, _state);
// Degenerate case, needs special handling
   if (n < m) {
   // Create design matrix.
      ae_matrix_set_length(&ft, n, m, _state);
      ae_vector_set_length(&b, n, _state);
      ae_vector_set_length(&wmod, n, _state);
      for (j = 0; j < n; j++) {
         v = w->xR[j];
         ae_v_moved(ft.xyR[j], 1, fmatrix->xyR[j], 1, m, v);
         b.xR[j] = w->xR[j] * y->xR[j];
         wmod.xR[j] = 1.0;
      }
   // LQ decomposition and reduction to M=N
      ae_vector_set_length(c, m, _state);
      for (i = 0; i < m; i++) {
         c->xR[i] = 0.0;
      }
      rep->taskrcond = 0.0;
      rmatrixlq(&ft, n, m, &tau, _state);
      rmatrixlqunpackq(&ft, n, m, &tau, n, &q, _state);
      rmatrixlqunpackl(&ft, n, m, &l, _state);
      lsfit_lsfitlinearinternal(&b, &wmod, &l, n, n, info, &tmp, rep, _state);
      if (*info <= 0) {
         ae_frame_leave(_state);
         return;
      }
      for (i = 0; i < n; i++) {
         v = tmp.xR[i];
         ae_v_addd(c->xR, 1, q.xyR[i], 1, m, v);
      }
      ae_frame_leave(_state);
      return;
   }
// N >= M. Generate design matrix and reduce to N=M using
// QR decomposition.
   ae_matrix_set_length(&ft, n, m, _state);
   ae_vector_set_length(&b, n, _state);
   for (j = 0; j < n; j++) {
      v = w->xR[j];
      ae_v_moved(ft.xyR[j], 1, fmatrix->xyR[j], 1, m, v);
      b.xR[j] = w->xR[j] * y->xR[j];
   }
   rmatrixqr(&ft, n, m, &tau, _state);
   rmatrixqrunpackq(&ft, n, m, &tau, m, &q, _state);
   rmatrixqrunpackr(&ft, n, m, &r, _state);
   ae_vector_set_length(&tmp, m, _state);
   for (i = 0; i < m; i++) {
      tmp.xR[i] = 0.0;
   }
   for (i = 0; i < n; i++) {
      v = b.xR[i];
      ae_v_addd(tmp.xR, 1, q.xyR[i], 1, m, v);
   }
   ae_vector_set_length(&b, m, _state);
   ae_v_move(b.xR, 1, tmp.xR, 1, m);
// R contains reduced MxM design upper triangular matrix,
// B contains reduced Mx1 right part.
//
// Determine system condition number and decide
// should we use triangular solver (faster) or
// SVD-based solver (more stable).
//
// We can use LU-based RCond estimator for this task.
   rep->taskrcond = rmatrixlurcondinf(&r, m, _state);
   if (rep->taskrcond > threshold) {
   // use QR-based solver
      ae_vector_set_length(c, m, _state);
      c->xR[m - 1] = b.xR[m - 1] / r.xyR[m - 1][m - 1];
      for (i = m - 2; i >= 0; i--) {
         v = ae_v_dotproduct(&r.xyR[i][i + 1], 1, &c->xR[i + 1], 1, m - i - 1);
         c->xR[i] = (b.xR[i] - v) / r.xyR[i][i];
      }
   } else {
   // use SVD-based solver
      if (!rmatrixsvd(&r, m, m, 1, 1, 2, &sv, &u, &vt, _state)) {
         *info = -4;
         ae_frame_leave(_state);
         return;
      }
      ae_vector_set_length(&utb, m, _state);
      ae_vector_set_length(&sutb, m, _state);
      for (i = 0; i < m; i++) {
         utb.xR[i] = 0.0;
      }
      for (i = 0; i < m; i++) {
         v = b.xR[i];
         ae_v_addd(utb.xR, 1, u.xyR[i], 1, m, v);
      }
      if (sv.xR[0] > 0.0) {
         rep->taskrcond = sv.xR[m - 1] / sv.xR[0];
         for (i = 0; i < m; i++) {
            if (sv.xR[i] > threshold * sv.xR[0]) {
               sutb.xR[i] = utb.xR[i] / sv.xR[i];
            } else {
               sutb.xR[i] = 0.0;
            }
         }
      } else {
         rep->taskrcond = 0.0;
         for (i = 0; i < m; i++) {
            sutb.xR[i] = 0.0;
         }
      }
      ae_vector_set_length(c, m, _state);
      for (i = 0; i < m; i++) {
         c->xR[i] = 0.0;
      }
      for (i = 0; i < m; i++) {
         v = sutb.xR[i];
         ae_v_addd(c->xR, 1, vt.xyR[i], 1, m, v);
      }
   }
// calculate errors
   rep->rmserror = 0.0;
   rep->avgerror = 0.0;
   rep->avgrelerror = 0.0;
   rep->maxerror = 0.0;
   relcnt = 0;
   for (i = 0; i < n; i++) {
      v = ae_v_dotproduct(fmatrix->xyR[i], 1, c->xR, 1, m);
      rep->rmserror += sqr(v - y->xR[i], _state);
      rep->avgerror += ae_fabs(v - y->xR[i], _state);
      if (y->xR[i] != 0.0) {
         rep->avgrelerror += ae_fabs(v - y->xR[i], _state) / ae_fabs(y->xR[i], _state);
         relcnt++;
      }
      rep->maxerror = maxreal(rep->maxerror, ae_fabs(v - y->xR[i], _state), _state);
   }
   rep->rmserror = ae_sqrt(rep->rmserror / n, _state);
   rep->avgerror /= n;
   if (relcnt != 0) {
      rep->avgrelerror /= relcnt;
   }
   ae_vector_set_length(&nzeros, n, _state);
   ae_vector_set_length(&s, m, _state);
   for (i = 0; i < m; i++) {
      s.xR[i] = 0.0;
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < m; j++) {
         s.xR[j] += sqr(fmatrix->xyR[i][j], _state);
      }
      nzeros.xR[i] = 0.0;
   }
   for (i = 0; i < m; i++) {
      if (s.xR[i] != 0.0) {
         s.xR[i] = ae_sqrt(1 / s.xR[i], _state);
      } else {
         s.xR[i] = 1.0;
      }
   }
   lsfit_estimateerrors(fmatrix, &nzeros, y, w, c, &s, n, m, rep, &r, 1, _state);
   ae_frame_leave(_state);
}

// Weighted linear least squares fitting.
//
// QR decomposition is used to reduce task to MxM, then triangular solver  or
// SVD-based solver is used depending on condition number of the  system.  It
// allows to maximize speed and retain decent accuracy.
//
// IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
//            convenient to use PolynomialFit() function. This function gives
//            best  results  on  polynomial  problems  and  solves  numerical
//            stability  issues  which  arise  when   you   fit   high-degree
//            polynomials to your data.
//
// Inputs:
//     Y       -   array[0..N-1] Function values in  N  points.
//     W       -   array[0..N-1]  Weights  corresponding to function  values.
//                 Each summand in square  sum  of  approximation  deviations
//                 from  given  values  is  multiplied  by  the   square   of
//                 corresponding weight.
//     FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
//                 FMatrix[I, J] - value of J-th basis function in I-th point.
//     N       -   number of points used. N >= 1.
//     M       -   number of basis functions, M >= 1.
//
// Outputs:
//     Info    -   error code:
//                 * -4    internal SVD decomposition subroutine failed (very
//                         rare and for degenerate systems only)
//                 * -1    incorrect N/M were specified
//                 *  1    task is solved
//     C       -   decomposition coefficients, array[0..M-1]
//     Rep     -   fitting report. Following fields are set:
//                 * Rep.TaskRCond     reciprocal of condition number
//                 * R2                non-adjusted coefficient of determination
//                                     (non-weighted)
//                 * RMSError          rms error on the (X,Y).
//                 * AvgError          average error on the (X,Y).
//                 * AvgRelError       average relative error on the non-zero Y
//                 * MaxError          maximum error
//                                     NON-WEIGHTED ERRORS ARE CALCULATED
//
// ERRORS IN PARAMETERS
//
// This  solver  also  calculates different kinds of errors in parameters and
// fills corresponding fields of report:
// * Rep.CovPar        covariance matrix for parameters, array[K,K].
// * Rep.ErrPar        errors in parameters, array[K],
//                     errpar = sqrt(diag(CovPar))
// * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
//                     best-fit curve from "ideal" best-fit curve built  with
//                     infinite number of samples, array[N].
//                     errcurve = sqrt(diag(F*CovPar*F')),
//                     where F is functions matrix.
// * Rep.Noise         vector of per-point estimates of noise, array[N]
//
// NOTE:       noise in the data is estimated as follows:
//             * for fitting without user-supplied  weights  all  points  are
//               assumed to have same level of noise, which is estimated from
//               the data
//             * for fitting with user-supplied weights we assume that  noise
//               level in I-th point is inversely proportional to Ith weight.
//               Coefficient of proportionality is estimated from the data.
//
// NOTE:       we apply small amount of regularization when we invert squared
//             Jacobian and calculate covariance matrix. It  guarantees  that
//             algorithm won't divide by zero  during  inversion,  but  skews
//             error estimates a bit (fractional error is about 10^-9).
//
//             However, we believe that this difference is insignificant  for
//             all practical purposes except for the situation when you  want
//             to compare ALGLIB results with "reference"  implementation  up
//             to the last significant digit.
//
// NOTE:       covariance matrix is estimated using  correction  for  degrees
//             of freedom (covariances are divided by N-M instead of dividing
//             by N).
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
// API: void lsfitlinearw(const real_1d_array &y, const real_1d_array &w, const real_2d_array &fmatrix, const ae_int_t n, const ae_int_t m, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams = xdefault);
// API: void lsfitlinearw(const real_1d_array &y, const real_1d_array &w, const real_2d_array &fmatrix, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams = xdefault);
void lsfitlinearw(RVector *y, RVector *w, RMatrix *fmatrix, ae_int_t n, ae_int_t m, ae_int_t *info, RVector *c, lsfitreport *rep, ae_state *_state) {
   *info = 0;
   SetVector(c);
   SetObj(lsfitreport, rep);
   ae_assert(n >= 1, "LSFitLinearW: N<1!", _state);
   ae_assert(m >= 1, "LSFitLinearW: M<1!", _state);
   ae_assert(y->cnt >= n, "LSFitLinearW: length(Y)<N!", _state);
   ae_assert(isfinitevector(y, n, _state), "LSFitLinearW: Y contains infinite or NaN values!", _state);
   ae_assert(w->cnt >= n, "LSFitLinearW: length(W)<N!", _state);
   ae_assert(isfinitevector(w, n, _state), "LSFitLinearW: W contains infinite or NaN values!", _state);
   ae_assert(fmatrix->rows >= n, "LSFitLinearW: rows(FMatrix)<N!", _state);
   ae_assert(fmatrix->cols >= m, "LSFitLinearW: cols(FMatrix)<M!", _state);
   ae_assert(apservisfinitematrix(fmatrix, n, m, _state), "LSFitLinearW: FMatrix contains infinite or NaN values!", _state);
   lsfit_lsfitlinearinternal(y, w, fmatrix, n, m, info, c, rep, _state);
}

// Weighted constained linear least squares fitting.
//
// This  is  variation  of LSFitLinearW(), which searchs for min|A*x=b| given
// that  K  additional  constaints  C*x=bc are satisfied. It reduces original
// task to modified one: min|B*y-d| WITHOUT constraints,  then LSFitLinearW()
// is called.
//
// IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
//            convenient to use PolynomialFit() function. This function gives
//            best  results  on  polynomial  problems  and  solves  numerical
//            stability  issues  which  arise  when   you   fit   high-degree
//            polynomials to your data.
//
// Inputs:
//     Y       -   array[0..N-1] Function values in  N  points.
//     W       -   array[0..N-1]  Weights  corresponding to function  values.
//                 Each summand in square  sum  of  approximation  deviations
//                 from  given  values  is  multiplied  by  the   square   of
//                 corresponding weight.
//     FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
//                 FMatrix[I,J] - value of J-th basis function in I-th point.
//     CMatrix -   a table of constaints, array[0..K-1,0..M].
//                 I-th row of CMatrix corresponds to I-th linear constraint:
//                 CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
//     N       -   number of points used. N >= 1.
//     M       -   number of basis functions, M >= 1.
//     K       -   number of constraints, 0 <= K < M
//                 K=0 corresponds to absence of constraints.
//
// Outputs:
//     Info    -   error code:
//                 * -4    internal SVD decomposition subroutine failed (very
//                         rare and for degenerate systems only)
//                 * -3    either   too   many  constraints  (M   or   more),
//                         degenerate  constraints   (some   constraints  are
//                         repetead twice) or inconsistent  constraints  were
//                         specified.
//                 *  1    task is solved
//     C       -   decomposition coefficients, array[0..M-1]
//     Rep     -   fitting report. Following fields are set:
//                 * R2                non-adjusted coefficient of determination
//                                     (non-weighted)
//                 * RMSError          rms error on the (X,Y).
//                 * AvgError          average error on the (X,Y).
//                 * AvgRelError       average relative error on the non-zero Y
//                 * MaxError          maximum error
//                                     NON-WEIGHTED ERRORS ARE CALCULATED
//
// IMPORTANT:
//     this subroitine doesn't calculate task's condition number for K != 0.
//
// ERRORS IN PARAMETERS
//
// This  solver  also  calculates different kinds of errors in parameters and
// fills corresponding fields of report:
// * Rep.CovPar        covariance matrix for parameters, array[K,K].
// * Rep.ErrPar        errors in parameters, array[K],
//                     errpar = sqrt(diag(CovPar))
// * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
//                     best-fit curve from "ideal" best-fit curve built  with
//                     infinite number of samples, array[N].
//                     errcurve = sqrt(diag(F*CovPar*F')),
//                     where F is functions matrix.
// * Rep.Noise         vector of per-point estimates of noise, array[N]
//
// IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
//             account boundary/linear constraints! Presence  of  constraints
//             changes distribution of errors, but there is no  easy  way  to
//             account for constraints when you calculate covariance matrix.
//
// NOTE:       noise in the data is estimated as follows:
//             * for fitting without user-supplied  weights  all  points  are
//               assumed to have same level of noise, which is estimated from
//               the data
//             * for fitting with user-supplied weights we assume that  noise
//               level in I-th point is inversely proportional to Ith weight.
//               Coefficient of proportionality is estimated from the data.
//
// NOTE:       we apply small amount of regularization when we invert squared
//             Jacobian and calculate covariance matrix. It  guarantees  that
//             algorithm won't divide by zero  during  inversion,  but  skews
//             error estimates a bit (fractional error is about 10^-9).
//
//             However, we believe that this difference is insignificant  for
//             all practical purposes except for the situation when you  want
//             to compare ALGLIB results with "reference"  implementation  up
//             to the last significant digit.
//
// NOTE:       covariance matrix is estimated using  correction  for  degrees
//             of freedom (covariances are divided by N-M instead of dividing
//             by N).
// ALGLIB: Copyright 07.09.2009 by Sergey Bochkanov
// API: void lsfitlinearwc(const real_1d_array &y, const real_1d_array &w, const real_2d_array &fmatrix, const real_2d_array &cmatrix, const ae_int_t n, const ae_int_t m, const ae_int_t k, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams = xdefault);
// API: void lsfitlinearwc(const real_1d_array &y, const real_1d_array &w, const real_2d_array &fmatrix, const real_2d_array &cmatrix, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams = xdefault);
void lsfitlinearwc(RVector *y, RVector *w, RMatrix *fmatrix, RMatrix *cmatrix, ae_int_t n, ae_int_t m, ae_int_t k, ae_int_t *info, RVector *c, lsfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_frame_make(_state, &_frame_block);
   DupVector(y, _state);
   DupMatrix(cmatrix, _state);
   *info = 0;
   SetVector(c);
   SetObj(lsfitreport, rep);
   NewVector(tau, 0, DT_REAL, _state);
   NewMatrix(q, 0, 0, DT_REAL, _state);
   NewMatrix(f2, 0, 0, DT_REAL, _state);
   NewVector(tmp, 0, DT_REAL, _state);
   NewVector(c0, 0, DT_REAL, _state);
   ae_assert(n >= 1, "LSFitLinearWC: N<1!", _state);
   ae_assert(m >= 1, "LSFitLinearWC: M<1!", _state);
   ae_assert(k >= 0, "LSFitLinearWC: K<0!", _state);
   ae_assert(y->cnt >= n, "LSFitLinearWC: length(Y)<N!", _state);
   ae_assert(isfinitevector(y, n, _state), "LSFitLinearWC: Y contains infinite or NaN values!", _state);
   ae_assert(w->cnt >= n, "LSFitLinearWC: length(W)<N!", _state);
   ae_assert(isfinitevector(w, n, _state), "LSFitLinearWC: W contains infinite or NaN values!", _state);
   ae_assert(fmatrix->rows >= n, "LSFitLinearWC: rows(FMatrix)<N!", _state);
   ae_assert(fmatrix->cols >= m, "LSFitLinearWC: cols(FMatrix)<M!", _state);
   ae_assert(apservisfinitematrix(fmatrix, n, m, _state), "LSFitLinearWC: FMatrix contains infinite or NaN values!", _state);
   ae_assert(cmatrix->rows >= k, "LSFitLinearWC: rows(CMatrix)<K!", _state);
   ae_assert(cmatrix->cols >= m + 1 || k == 0, "LSFitLinearWC: cols(CMatrix)<M+1!", _state);
   ae_assert(apservisfinitematrix(cmatrix, k, m + 1, _state), "LSFitLinearWC: CMatrix contains infinite or NaN values!", _state);
   if (k >= m) {
      *info = -3;
      ae_frame_leave(_state);
      return;
   }
// Solve
   if (k == 0) {
   // no constraints
      lsfit_lsfitlinearinternal(y, w, fmatrix, n, m, info, c, rep, _state);
   } else {
   // First, find general form solution of constraints system:
   // * factorize C = L*Q
   // * unpack Q
   // * fill upper part of C with zeros (for RCond)
   //
   // We got C=C0+Q2'*y where Q2 is lower M-K rows of Q.
      rmatrixlq(cmatrix, k, m, &tau, _state);
      rmatrixlqunpackq(cmatrix, k, m, &tau, m, &q, _state);
      for (i = 0; i < k; i++) {
         for (j = i + 1; j < m; j++) {
            cmatrix->xyR[i][j] = 0.0;
         }
      }
      if (rmatrixlurcondinf(cmatrix, k, _state) < 1000 * machineepsilon) {
         *info = -3;
         ae_frame_leave(_state);
         return;
      }
      ae_vector_set_length(&tmp, k, _state);
      for (i = 0; i < k; i++) {
         if (i > 0) {
            v = ae_v_dotproduct(cmatrix->xyR[i], 1, tmp.xR, 1, i);
         } else {
            v = 0.0;
         }
         tmp.xR[i] = (cmatrix->xyR[i][m] - v) / cmatrix->xyR[i][i];
      }
      ae_vector_set_length(&c0, m, _state);
      for (i = 0; i < m; i++) {
         c0.xR[i] = 0.0;
      }
      for (i = 0; i < k; i++) {
         v = tmp.xR[i];
         ae_v_addd(c0.xR, 1, q.xyR[i], 1, m, v);
      }
   // Second, prepare modified matrix F2 = F*Q2' and solve modified task
      ae_vector_set_length(&tmp, maxint(n, m, _state) + 1, _state);
      ae_matrix_set_length(&f2, n, m - k, _state);
      matrixvectormultiply(fmatrix, 0, n - 1, 0, m - 1, false, &c0, 0, m - 1, -1.0, y, 0, n - 1, 1.0, _state);
      rmatrixgemm(n, m - k, m, 1.0, fmatrix, 0, 0, 0, &q, k, 0, 1, 0.0, &f2, 0, 0, _state);
      lsfit_lsfitlinearinternal(y, w, &f2, n, m - k, info, &tmp, rep, _state);
      rep->taskrcond = -1.0;
      if (*info <= 0) {
         ae_frame_leave(_state);
         return;
      }
   // then, convert back to original answer: C = C0 + Q2'*Y0
      ae_vector_set_length(c, m, _state);
      ae_v_move(c->xR, 1, c0.xR, 1, m);
      matrixvectormultiply(&q, k, m - 1, 0, m - 1, true, &tmp, 0, m - k - 1, 1.0, c, 0, m - 1, 1.0, _state);
   }
   ae_frame_leave(_state);
}

// Linear least squares fitting.
//
// QR decomposition is used to reduce task to MxM, then triangular solver  or
// SVD-based solver is used depending on condition number of the  system.  It
// allows to maximize speed and retain decent accuracy.
//
// IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
//            convenient to use PolynomialFit() function. This function gives
//            best  results  on  polynomial  problems  and  solves  numerical
//            stability  issues  which  arise  when   you   fit   high-degree
//            polynomials to your data.
//
// Inputs:
//     Y       -   array[0..N-1] Function values in  N  points.
//     FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
//                 FMatrix[I, J] - value of J-th basis function in I-th point.
//     N       -   number of points used. N >= 1.
//     M       -   number of basis functions, M >= 1.
//
// Outputs:
//     Info    -   error code:
//                 * -4    internal SVD decomposition subroutine failed (very
//                         rare and for degenerate systems only)
//                 *  1    task is solved
//     C       -   decomposition coefficients, array[0..M-1]
//     Rep     -   fitting report. Following fields are set:
//                 * Rep.TaskRCond     reciprocal of condition number
//                 * R2                non-adjusted coefficient of determination
//                                     (non-weighted)
//                 * RMSError          rms error on the (X,Y).
//                 * AvgError          average error on the (X,Y).
//                 * AvgRelError       average relative error on the non-zero Y
//                 * MaxError          maximum error
//                                     NON-WEIGHTED ERRORS ARE CALCULATED
//
// ERRORS IN PARAMETERS
//
// This  solver  also  calculates different kinds of errors in parameters and
// fills corresponding fields of report:
// * Rep.CovPar        covariance matrix for parameters, array[K,K].
// * Rep.ErrPar        errors in parameters, array[K],
//                     errpar = sqrt(diag(CovPar))
// * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
//                     best-fit curve from "ideal" best-fit curve built  with
//                     infinite number of samples, array[N].
//                     errcurve = sqrt(diag(F*CovPar*F')),
//                     where F is functions matrix.
// * Rep.Noise         vector of per-point estimates of noise, array[N]
//
// NOTE:       noise in the data is estimated as follows:
//             * for fitting without user-supplied  weights  all  points  are
//               assumed to have same level of noise, which is estimated from
//               the data
//             * for fitting with user-supplied weights we assume that  noise
//               level in I-th point is inversely proportional to Ith weight.
//               Coefficient of proportionality is estimated from the data.
//
// NOTE:       we apply small amount of regularization when we invert squared
//             Jacobian and calculate covariance matrix. It  guarantees  that
//             algorithm won't divide by zero  during  inversion,  but  skews
//             error estimates a bit (fractional error is about 10^-9).
//
//             However, we believe that this difference is insignificant  for
//             all practical purposes except for the situation when you  want
//             to compare ALGLIB results with "reference"  implementation  up
//             to the last significant digit.
//
// NOTE:       covariance matrix is estimated using  correction  for  degrees
//             of freedom (covariances are divided by N-M instead of dividing
//             by N).
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
// API: void lsfitlinear(const real_1d_array &y, const real_2d_array &fmatrix, const ae_int_t n, const ae_int_t m, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams = xdefault);
// API: void lsfitlinear(const real_1d_array &y, const real_2d_array &fmatrix, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams = xdefault);
void lsfitlinear(RVector *y, RMatrix *fmatrix, ae_int_t n, ae_int_t m, ae_int_t *info, RVector *c, lsfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   *info = 0;
   SetVector(c);
   SetObj(lsfitreport, rep);
   NewVector(w, 0, DT_REAL, _state);
   ae_assert(n >= 1, "LSFitLinear: N<1!", _state);
   ae_assert(m >= 1, "LSFitLinear: M<1!", _state);
   ae_assert(y->cnt >= n, "LSFitLinear: length(Y)<N!", _state);
   ae_assert(isfinitevector(y, n, _state), "LSFitLinear: Y contains infinite or NaN values!", _state);
   ae_assert(fmatrix->rows >= n, "LSFitLinear: rows(FMatrix)<N!", _state);
   ae_assert(fmatrix->cols >= m, "LSFitLinear: cols(FMatrix)<M!", _state);
   ae_assert(apservisfinitematrix(fmatrix, n, m, _state), "LSFitLinear: FMatrix contains infinite or NaN values!", _state);
   ae_vector_set_length(&w, n, _state);
   for (i = 0; i < n; i++) {
      w.xR[i] = 1.0;
   }
   lsfit_lsfitlinearinternal(y, &w, fmatrix, n, m, info, c, rep, _state);
   ae_frame_leave(_state);
}

// Constained linear least squares fitting.
//
// This  is  variation  of LSFitLinear(),  which searchs for min|A*x=b| given
// that  K  additional  constaints  C*x=bc are satisfied. It reduces original
// task to modified one: min|B*y-d| WITHOUT constraints,  then  LSFitLinear()
// is called.
//
// IMPORTANT: if you want to perform  polynomial  fitting,  it  may  be  more
//            convenient to use PolynomialFit() function. This function gives
//            best  results  on  polynomial  problems  and  solves  numerical
//            stability  issues  which  arise  when   you   fit   high-degree
//            polynomials to your data.
//
// Inputs:
//     Y       -   array[0..N-1] Function values in  N  points.
//     FMatrix -   a table of basis functions values, array[0..N-1, 0..M-1].
//                 FMatrix[I,J] - value of J-th basis function in I-th point.
//     CMatrix -   a table of constaints, array[0..K-1,0..M].
//                 I-th row of CMatrix corresponds to I-th linear constraint:
//                 CMatrix[I,0]*C[0] + ... + CMatrix[I,M-1]*C[M-1] = CMatrix[I,M]
//     N       -   number of points used. N >= 1.
//     M       -   number of basis functions, M >= 1.
//     K       -   number of constraints, 0 <= K < M
//                 K=0 corresponds to absence of constraints.
//
// Outputs:
//     Info    -   error code:
//                 * -4    internal SVD decomposition subroutine failed (very
//                         rare and for degenerate systems only)
//                 * -3    either   too   many  constraints  (M   or   more),
//                         degenerate  constraints   (some   constraints  are
//                         repetead twice) or inconsistent  constraints  were
//                         specified.
//                 *  1    task is solved
//     C       -   decomposition coefficients, array[0..M-1]
//     Rep     -   fitting report. Following fields are set:
//                 * R2                non-adjusted coefficient of determination
//                                     (non-weighted)
//                 * RMSError          rms error on the (X,Y).
//                 * AvgError          average error on the (X,Y).
//                 * AvgRelError       average relative error on the non-zero Y
//                 * MaxError          maximum error
//                                     NON-WEIGHTED ERRORS ARE CALCULATED
//
// IMPORTANT:
//     this subroitine doesn't calculate task's condition number for K != 0.
//
// ERRORS IN PARAMETERS
//
// This  solver  also  calculates different kinds of errors in parameters and
// fills corresponding fields of report:
// * Rep.CovPar        covariance matrix for parameters, array[K,K].
// * Rep.ErrPar        errors in parameters, array[K],
//                     errpar = sqrt(diag(CovPar))
// * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
//                     best-fit curve from "ideal" best-fit curve built  with
//                     infinite number of samples, array[N].
//                     errcurve = sqrt(diag(F*CovPar*F')),
//                     where F is functions matrix.
// * Rep.Noise         vector of per-point estimates of noise, array[N]
//
// IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
//             account boundary/linear constraints! Presence  of  constraints
//             changes distribution of errors, but there is no  easy  way  to
//             account for constraints when you calculate covariance matrix.
//
// NOTE:       noise in the data is estimated as follows:
//             * for fitting without user-supplied  weights  all  points  are
//               assumed to have same level of noise, which is estimated from
//               the data
//             * for fitting with user-supplied weights we assume that  noise
//               level in I-th point is inversely proportional to Ith weight.
//               Coefficient of proportionality is estimated from the data.
//
// NOTE:       we apply small amount of regularization when we invert squared
//             Jacobian and calculate covariance matrix. It  guarantees  that
//             algorithm won't divide by zero  during  inversion,  but  skews
//             error estimates a bit (fractional error is about 10^-9).
//
//             However, we believe that this difference is insignificant  for
//             all practical purposes except for the situation when you  want
//             to compare ALGLIB results with "reference"  implementation  up
//             to the last significant digit.
//
// NOTE:       covariance matrix is estimated using  correction  for  degrees
//             of freedom (covariances are divided by N-M instead of dividing
//             by N).
// ALGLIB: Copyright 07.09.2009 by Sergey Bochkanov
// API: void lsfitlinearc(const real_1d_array &y, const real_2d_array &fmatrix, const real_2d_array &cmatrix, const ae_int_t n, const ae_int_t m, const ae_int_t k, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams = xdefault);
// API: void lsfitlinearc(const real_1d_array &y, const real_2d_array &fmatrix, const real_2d_array &cmatrix, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams = xdefault);
void lsfitlinearc(RVector *y, RMatrix *fmatrix, RMatrix *cmatrix, ae_int_t n, ae_int_t m, ae_int_t k, ae_int_t *info, RVector *c, lsfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   DupVector(y, _state);
   *info = 0;
   SetVector(c);
   SetObj(lsfitreport, rep);
   NewVector(w, 0, DT_REAL, _state);
   ae_assert(n >= 1, "LSFitLinearC: N<1!", _state);
   ae_assert(m >= 1, "LSFitLinearC: M<1!", _state);
   ae_assert(k >= 0, "LSFitLinearC: K<0!", _state);
   ae_assert(y->cnt >= n, "LSFitLinearC: length(Y)<N!", _state);
   ae_assert(isfinitevector(y, n, _state), "LSFitLinearC: Y contains infinite or NaN values!", _state);
   ae_assert(fmatrix->rows >= n, "LSFitLinearC: rows(FMatrix)<N!", _state);
   ae_assert(fmatrix->cols >= m, "LSFitLinearC: cols(FMatrix)<M!", _state);
   ae_assert(apservisfinitematrix(fmatrix, n, m, _state), "LSFitLinearC: FMatrix contains infinite or NaN values!", _state);
   ae_assert(cmatrix->rows >= k, "LSFitLinearC: rows(CMatrix)<K!", _state);
   ae_assert(cmatrix->cols >= m + 1 || k == 0, "LSFitLinearC: cols(CMatrix)<M+1!", _state);
   ae_assert(apservisfinitematrix(cmatrix, k, m + 1, _state), "LSFitLinearC: CMatrix contains infinite or NaN values!", _state);
   ae_vector_set_length(&w, n, _state);
   for (i = 0; i < n; i++) {
      w.xR[i] = 1.0;
   }
   lsfitlinearwc(y, &w, fmatrix, cmatrix, n, m, k, info, c, rep, _state);
   ae_frame_leave(_state);
}

// This is internal function for Chebyshev fitting.
//
// It assumes that input data are normalized:
// * X/XC belong to [-1,+1],
// * mean(Y)=0, stddev(Y)=1.
//
// It does not checks inputs for errors.
//
// This function is used to fit general (shifted) Chebyshev models, power
// basis models or barycentric models.
//
// Inputs:
//     X   -   points, array[0..N-1].
//     Y   -   function values, array[0..N-1].
//     W   -   weights, array[0..N-1]
//     N   -   number of points, N>0.
//     XC  -   points where polynomial values/derivatives are constrained,
//             array[0..K-1].
//     YC  -   values of constraints, array[0..K-1]
//     DC  -   array[0..K-1], types of constraints:
//             * DC[i]=0   means that P(XC[i])=YC[i]
//             * DC[i]=1   means that P'(XC[i])=YC[i]
//     K   -   number of constraints, 0 <= K<M.
//             K=0 means no constraints (XC/YC/DC are not used in such cases)
//     M   -   number of basis functions (= polynomial_degree + 1), M >= 1
//
// Outputs:
//     Info-   same format as in LSFitLinearW() subroutine:
//             * Info>0    task is solved
//             * Info <= 0   an error occured:
//                         -4 means inconvergence of internal SVD
//                         -3 means inconsistent constraints
//     C   -   interpolant in Chebyshev form; [-1,+1] is used as base interval
//     Rep -   report, same format as in LSFitLinearW() subroutine.
//             Following fields are set:
//             * RMSError      rms error on the (X,Y).
//             * AvgError      average error on the (X,Y).
//             * AvgRelError   average relative error on the non-zero Y
//             * MaxError      maximum error
//                             NON-WEIGHTED ERRORS ARE CALCULATED
//
// IMPORTANT:
//     this subroitine doesn't calculate task's condition number for K != 0.
// ALGLIB Project: Copyright 10.12.2009 by Sergey Bochkanov
static void lsfit_internalchebyshevfit(RVector *x, RVector *y, RVector *w, ae_int_t n, RVector *xc, RVector *yc, ZVector *dc, ae_int_t k, ae_int_t m, ae_int_t *info, RVector *c, lsfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double mx;
   double decay;
   ae_frame_make(_state, &_frame_block);
   DupVector(xc, _state);
   DupVector(yc, _state);
   *info = 0;
   SetVector(c);
   SetObj(lsfitreport, rep);
   NewVector(y2, 0, DT_REAL, _state);
   NewVector(w2, 0, DT_REAL, _state);
   NewVector(tmp, 0, DT_REAL, _state);
   NewVector(tmp2, 0, DT_REAL, _state);
   NewVector(tmpdiff, 0, DT_REAL, _state);
   NewVector(bx, 0, DT_REAL, _state);
   NewVector(by, 0, DT_REAL, _state);
   NewVector(bw, 0, DT_REAL, _state);
   NewMatrix(fmatrix, 0, 0, DT_REAL, _state);
   NewMatrix(cmatrix, 0, 0, DT_REAL, _state);
   lsfit_clearreport(rep, _state);
// weight decay for correct handling of task which becomes
// degenerate after constraints are applied
   decay = 10000 * machineepsilon;
// allocate space, initialize/fill:
// * FMatrix-   values of basis functions at X[]
// * CMatrix-   values (derivatives) of basis functions at XC[]
// * fill constraints matrix
// * fill first N rows of design matrix with values
// * fill next M rows of design matrix with regularizing term
// * append M zeros to Y
// * append M elements, mean(abs(W)) each, to W
   ae_vector_set_length(&y2, n + m, _state);
   ae_vector_set_length(&w2, n + m, _state);
   ae_vector_set_length(&tmp, m, _state);
   ae_vector_set_length(&tmpdiff, m, _state);
   ae_matrix_set_length(&fmatrix, n + m, m, _state);
   if (k > 0) {
      ae_matrix_set_length(&cmatrix, k, m + 1, _state);
   }
// Fill design matrix, Y2, W2:
// * first N rows with basis functions for original points
// * next M rows with decay terms
   for (i = 0; i < n; i++) {
   // prepare Ith row
   // use Tmp for calculations to avoid multidimensional arrays overhead
      for (j = 0; j < m; j++) {
         if (j == 0) {
            tmp.xR[j] = 1.0;
         } else {
            if (j == 1) {
               tmp.xR[j] = x->xR[i];
            } else {
               tmp.xR[j] = 2 * x->xR[i] * tmp.xR[j - 1] - tmp.xR[j - 2];
            }
         }
      }
      ae_v_move(fmatrix.xyR[i], 1, tmp.xR, 1, m);
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < m; j++) {
         if (i == j) {
            fmatrix.xyR[n + i][j] = decay;
         } else {
            fmatrix.xyR[n + i][j] = 0.0;
         }
      }
   }
   ae_v_move(y2.xR, 1, y->xR, 1, n);
   ae_v_move(w2.xR, 1, w->xR, 1, n);
   mx = 0.0;
   for (i = 0; i < n; i++) {
      mx += ae_fabs(w->xR[i], _state);
   }
   mx /= n;
   for (i = 0; i < m; i++) {
      y2.xR[n + i] = 0.0;
      w2.xR[n + i] = mx;
   }
// fill constraints matrix
   for (i = 0; i < k; i++) {
   // prepare Ith row
   // use Tmp for basis function values,
   // TmpDiff for basos function derivatives
      for (j = 0; j < m; j++) {
         if (j == 0) {
            tmp.xR[j] = 1.0;
            tmpdiff.xR[j] = 0.0;
         } else {
            if (j == 1) {
               tmp.xR[j] = xc->xR[i];
               tmpdiff.xR[j] = 1.0;
            } else {
               tmp.xR[j] = 2 * xc->xR[i] * tmp.xR[j - 1] - tmp.xR[j - 2];
               tmpdiff.xR[j] = 2 * (tmp.xR[j - 1] + xc->xR[i] * tmpdiff.xR[j - 1]) - tmpdiff.xR[j - 2];
            }
         }
      }
      if (dc->xZ[i] == 0) {
         ae_v_move(cmatrix.xyR[i], 1, tmp.xR, 1, m);
      }
      if (dc->xZ[i] == 1) {
         ae_v_move(cmatrix.xyR[i], 1, tmpdiff.xR, 1, m);
      }
      cmatrix.xyR[i][m] = yc->xR[i];
   }
// Solve constrained task
   if (k > 0) {
   // solve using regularization
      lsfitlinearwc(&y2, &w2, &fmatrix, &cmatrix, n + m, m, k, info, c, rep, _state);
   } else {
   // no constraints, no regularization needed
      lsfitlinearwc(y, w, &fmatrix, &cmatrix, n, m, 0, info, c, rep, _state);
   }
   if (*info < 0) {
      ae_frame_leave(_state);
      return;
   }
   ae_frame_leave(_state);
}

// Weighted  fitting by polynomials in barycentric form, with constraints  on
// function values or first derivatives.
//
// Small regularizing term is used when solving constrained tasks (to improve
// stability).
//
// Task is linear, so linear least squares solver is used. Complexity of this
// computational scheme is O(N*M^2), mostly dominated by least squares solver
//
// SEE ALSO:
//     PolynomialFit()
//
// NOTES:
//     you can convert P from barycentric form  to  the  power  or  Chebyshev
//     basis with PolynomialBar2Pow() or PolynomialBar2Cheb() functions  from
//     POLINT subpackage.
//
// Inputs:
//     X   -   points, array[0..N-1].
//     Y   -   function values, array[0..N-1].
//     W   -   weights, array[0..N-1]
//             Each summand in square  sum  of  approximation deviations from
//             given  values  is  multiplied  by  the square of corresponding
//             weight. Fill it by 1's if you don't  want  to  solve  weighted
//             task.
//     N   -   number of points, N>0.
//             * if given, only leading N elements of X/Y/W are used
//             * if not given, automatically determined from sizes of X/Y/W
//     XC  -   points where polynomial values/derivatives are constrained,
//             array[0..K-1].
//     YC  -   values of constraints, array[0..K-1]
//     DC  -   array[0..K-1], types of constraints:
//             * DC[i]=0   means that P(XC[i])=YC[i]
//             * DC[i]=1   means that P'(XC[i])=YC[i]
//             SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
//     K   -   number of constraints, 0 <= K<M.
//             K=0 means no constraints (XC/YC/DC are not used in such cases)
//     M   -   number of basis functions (= polynomial_degree + 1), M >= 1
//
// Outputs:
//     Info-   same format as in LSFitLinearW() subroutine:
//             * Info>0    task is solved
//             * Info <= 0   an error occured:
//                         -4 means inconvergence of internal SVD
//                         -3 means inconsistent constraints
//     P   -   interpolant in barycentric form.
//     Rep -   report, same format as in LSFitLinearW() subroutine.
//             Following fields are set:
//             * RMSError      rms error on the (X,Y).
//             * AvgError      average error on the (X,Y).
//             * AvgRelError   average relative error on the non-zero Y
//             * MaxError      maximum error
//                             NON-WEIGHTED ERRORS ARE CALCULATED
//
// IMPORTANT:
//     this subroitine doesn't calculate task's condition number for K != 0.
//
// SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
//
// Setting constraints can lead  to undesired  results,  like ill-conditioned
// behavior, or inconsistency being detected. From the other side,  it allows
// us to improve quality of the fit. Here we summarize  our  experience  with
// constrained regression splines:
// * even simple constraints can be inconsistent, see  Wikipedia  article  on
//   this subject: http://en.wikipedia.org/wiki/Birkhoff_interpolation
// * the  greater  is  M (given  fixed  constraints),  the  more chances that
//   constraints will be consistent
// * in the general case, consistency of constraints is NOT GUARANTEED.
// * in the one special cases, however, we can  guarantee  consistency.  This
//   case  is:  M>1  and constraints on the function values (NOT DERIVATIVES)
//
// Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
// can't solve your task without them. Anything beyond  special  cases  given
// above is not guaranteed and may result in inconsistency.
// ALGLIB Project: Copyright 10.12.2009 by Sergey Bochkanov
// API: void polynomialfitwc(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const ae_int_t n, const real_1d_array &xc, const real_1d_array &yc, const integer_1d_array &dc, const ae_int_t k, const ae_int_t m, ae_int_t &info, barycentricinterpolant &p, polynomialfitreport &rep, const xparams _xparams = xdefault);
// API: void polynomialfitwc(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &xc, const real_1d_array &yc, const integer_1d_array &dc, const ae_int_t m, ae_int_t &info, barycentricinterpolant &p, polynomialfitreport &rep, const xparams _xparams = xdefault);
void polynomialfitwc(RVector *x, RVector *y, RVector *w, ae_int_t n, RVector *xc, RVector *yc, ZVector *dc, ae_int_t k, ae_int_t m, ae_int_t *info, barycentricinterpolant *p, polynomialfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   double xa;
   double xb;
   double sa;
   double sb;
   ae_int_t i;
   ae_int_t j;
   double u;
   double v;
   double s;
   ae_int_t relcnt;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   DupVector(w, _state);
   DupVector(xc, _state);
   DupVector(yc, _state);
   *info = 0;
   SetObj(barycentricinterpolant, p);
   SetObj(polynomialfitreport, rep);
   NewVector(xoriginal, 0, DT_REAL, _state);
   NewVector(yoriginal, 0, DT_REAL, _state);
   NewVector(y2, 0, DT_REAL, _state);
   NewVector(w2, 0, DT_REAL, _state);
   NewVector(tmp, 0, DT_REAL, _state);
   NewVector(tmp2, 0, DT_REAL, _state);
   NewVector(bx, 0, DT_REAL, _state);
   NewVector(by, 0, DT_REAL, _state);
   NewVector(bw, 0, DT_REAL, _state);
   NewObj(lsfitreport, lrep, _state);
   ae_assert(n > 0, "PolynomialFitWC: N <= 0!", _state);
   ae_assert(m > 0, "PolynomialFitWC: M <= 0!", _state);
   ae_assert(k >= 0, "PolynomialFitWC: K<0!", _state);
   ae_assert(k < m, "PolynomialFitWC: K >= M!", _state);
   ae_assert(x->cnt >= n, "PolynomialFitWC: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "PolynomialFitWC: Length(Y)<N!", _state);
   ae_assert(w->cnt >= n, "PolynomialFitWC: Length(W)<N!", _state);
   ae_assert(xc->cnt >= k, "PolynomialFitWC: Length(XC)<K!", _state);
   ae_assert(yc->cnt >= k, "PolynomialFitWC: Length(YC)<K!", _state);
   ae_assert(dc->cnt >= k, "PolynomialFitWC: Length(DC)<K!", _state);
   ae_assert(isfinitevector(x, n, _state), "PolynomialFitWC: X contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "PolynomialFitWC: Y contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(w, n, _state), "PolynomialFitWC: X contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(xc, k, _state), "PolynomialFitWC: XC contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(yc, k, _state), "PolynomialFitWC: YC contains infinite or NaN values!", _state);
   for (i = 0; i < k; i++) {
      ae_assert(dc->xZ[i] == 0 || dc->xZ[i] == 1, "PolynomialFitWC: one of DC[] is not 0 or 1!", _state);
   }
// Scale X, Y, XC, YC.
// Solve scaled problem using internal Chebyshev fitting function.
   lsfitscalexy(x, y, w, n, xc, yc, dc, k, &xa, &xb, &sa, &sb, &xoriginal, &yoriginal, _state);
   lsfit_internalchebyshevfit(x, y, w, n, xc, yc, dc, k, m, info, &tmp, &lrep, _state);
   if (*info < 0) {
      ae_frame_leave(_state);
      return;
   }
// Generate barycentric model and scale it
// * BX, BY store barycentric model nodes
// * FMatrix is reused (remember - it is at least MxM, what we need)
//
// Model intialization is done in O(M^2). In principle, it can be
// done in O(M*log(M)), but before it we solved task with O(N*M^2)
// complexity, so it is only a small amount of total time spent.
   ae_vector_set_length(&bx, m, _state);
   ae_vector_set_length(&by, m, _state);
   ae_vector_set_length(&bw, m, _state);
   ae_vector_set_length(&tmp2, m, _state);
   s = 1.0;
   for (i = 0; i < m; i++) {
      if (m != 1) {
         u = ae_cos(pi * i / (m - 1), _state);
      } else {
         u = 0.0;
      }
      v = 0.0;
      for (j = 0; j < m; j++) {
         if (j == 0) {
            tmp2.xR[j] = 1.0;
         } else {
            if (j == 1) {
               tmp2.xR[j] = u;
            } else {
               tmp2.xR[j] = 2 * u * tmp2.xR[j - 1] - tmp2.xR[j - 2];
            }
         }
         v += tmp.xR[j] * tmp2.xR[j];
      }
      bx.xR[i] = u;
      by.xR[i] = v;
      bw.xR[i] = s;
      if (i == 0 || i == m - 1) {
         bw.xR[i] *= 0.5;
      }
      s = -s;
   }
   barycentricbuildxyw(&bx, &by, &bw, m, p, _state);
   barycentriclintransx(p, 2 / (xb - xa), -(xa + xb) / (xb - xa), _state);
   barycentriclintransy(p, sb - sa, sa, _state);
// Scale absolute errors obtained from LSFitLinearW.
// Relative error should be calculated separately
// (because of shifting/scaling of the task)
   rep->taskrcond = lrep.taskrcond;
   rep->rmserror = lrep.rmserror * (sb - sa);
   rep->avgerror = lrep.avgerror * (sb - sa);
   rep->maxerror = lrep.maxerror * (sb - sa);
   rep->avgrelerror = 0.0;
   relcnt = 0;
   for (i = 0; i < n; i++) {
      if (yoriginal.xR[i] != 0.0) {
         rep->avgrelerror += ae_fabs(barycentriccalc(p, xoriginal.xR[i], _state) - yoriginal.xR[i], _state) / ae_fabs(yoriginal.xR[i], _state);
         relcnt++;
      }
   }
   if (relcnt != 0) {
      rep->avgrelerror /= relcnt;
   }
   ae_frame_leave(_state);
}

// Fitting by polynomials in barycentric form. This function provides  simple
// unterface for unconstrained unweighted fitting. See  PolynomialFitWC()  if
// you need constrained fitting.
//
// The task is linear, thus the linear least  squares  solver  is  used.  The
// complexity of this computational scheme is O(N*M^2), mostly  dominated  by
// the least squares solver
//
// SEE ALSO:
//     PolynomialFitWC()
//
// NOTES:
//     you can convert P from barycentric form  to  the  power  or  Chebyshev
//     basis with PolynomialBar2Pow() or PolynomialBar2Cheb() functions  from
//     POLINT subpackage.
//
// Inputs:
//     X   -   points, array[0..N-1].
//     Y   -   function values, array[0..N-1].
//     N   -   number of points, N>0
//             * if given, only leading N elements of X/Y are used
//             * if not given, automatically determined from sizes of X/Y
//     M   -   number of basis functions (= polynomial_degree + 1), M >= 1
//
// Outputs:
//     Info-   same format as in LSFitLinearW() subroutine:
//             * Info>0    task is solved
//             * Info <= 0   an error occured:
//                         -4 means inconvergence of internal SVD
//     P   -   interpolant in barycentric form.
//     Rep -   report, same format as in LSFitLinearW() subroutine.
//             Following fields are set:
//             * RMSError      rms error on the (X,Y).
//             * AvgError      average error on the (X,Y).
//             * AvgRelError   average relative error on the non-zero Y
//             * MaxError      maximum error
//                             NON-WEIGHTED ERRORS ARE CALCULATED
// ALGLIB Project: Copyright 10.12.2009 by Sergey Bochkanov
// API: void polynomialfit(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t m, ae_int_t &info, barycentricinterpolant &p, polynomialfitreport &rep, const xparams _xparams = xdefault);
// API: void polynomialfit(const real_1d_array &x, const real_1d_array &y, const ae_int_t m, ae_int_t &info, barycentricinterpolant &p, polynomialfitreport &rep, const xparams _xparams = xdefault);
void polynomialfit(RVector *x, RVector *y, ae_int_t n, ae_int_t m, ae_int_t *info, barycentricinterpolant *p, polynomialfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   *info = 0;
   SetObj(barycentricinterpolant, p);
   SetObj(polynomialfitreport, rep);
   NewVector(w, 0, DT_REAL, _state);
   NewVector(xc, 0, DT_REAL, _state);
   NewVector(yc, 0, DT_REAL, _state);
   NewVector(dc, 0, DT_INT, _state);
   ae_assert(n > 0, "PolynomialFit: N <= 0!", _state);
   ae_assert(m > 0, "PolynomialFit: M <= 0!", _state);
   ae_assert(x->cnt >= n, "PolynomialFit: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "PolynomialFit: Length(Y)<N!", _state);
   ae_assert(isfinitevector(x, n, _state), "PolynomialFit: X contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "PolynomialFit: Y contains infinite or NaN values!", _state);
   ae_vector_set_length(&w, n, _state);
   for (i = 0; i < n; i++) {
      w.xR[i] = 1.0;
   }
   polynomialfitwc(x, y, &w, n, &xc, &yc, &dc, 0, m, info, p, rep, _state);
   ae_frame_leave(_state);
}

// This function calculates value of four-parameter logistic (4PL)  model  at
// specified point X. 4PL model has following form:
//
//     F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))
//
// Inputs:
//     X       -   current point, X >= 0:
//                 * zero X is correctly handled even for B <= 0
//                 * negative X results in exception.
//     A, B, C, D- parameters of 4PL model:
//                 * A is unconstrained
//                 * B is unconstrained; zero or negative values are handled
//                   correctly.
//                 * C>0, non-positive value results in exception
//                 * D is unconstrained
//
// Result:
//     model value at X
//
// NOTE: if B=0, denominator is assumed to be equal to 2.0 even  for  zero  X
//       (strictly speaking, 0^0 is undefined).
//
// NOTE: this function also throws exception  if  all  input  parameters  are
//       correct, but overflow was detected during calculations.
//
// NOTE: this function performs a lot of checks;  if  you  need  really  high
//       performance, consider evaluating model  yourself,  without  checking
//       for degenerate cases.
// ALGLIB Project: Copyright 14.05.2014 by Sergey Bochkanov
// API: double logisticcalc4(const double x, const double a, const double b, const double c, const double d, const xparams _xparams = xdefault);
double logisticcalc4(double x, double a, double b, double c, double d, ae_state *_state) {
   double result;
   ae_assert(ae_isfinite(x, _state), "LogisticCalc4: X is not finite", _state);
   ae_assert(ae_isfinite(a, _state), "LogisticCalc4: A is not finite", _state);
   ae_assert(ae_isfinite(b, _state), "LogisticCalc4: B is not finite", _state);
   ae_assert(ae_isfinite(c, _state), "LogisticCalc4: C is not finite", _state);
   ae_assert(ae_isfinite(d, _state), "LogisticCalc4: D is not finite", _state);
   ae_assert(x >= 0.0, "LogisticCalc4: X is negative", _state);
   ae_assert(c > 0.0, "LogisticCalc4: C is non-positive", _state);
// Check for degenerate cases
   if (b == 0.0) {
      result = 0.5 * (a + d);
      return result;
   }
   if (x == 0.0) {
      if (b > 0.0) {
         result = a;
      } else {
         result = d;
      }
      return result;
   }
// General case
   result = d + (a - d) / (1.0 + ae_pow(x / c, b, _state));
   ae_assert(ae_isfinite(result, _state), "LogisticCalc4: overflow during calculations", _state);
   return result;
}

// This function calculates value of five-parameter logistic (5PL)  model  at
// specified point X. 5PL model has following form:
//
//     F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)
//
// Inputs:
//     X       -   current point, X >= 0:
//                 * zero X is correctly handled even for B <= 0
//                 * negative X results in exception.
//     A, B, C, D, G- parameters of 5PL model:
//                 * A is unconstrained
//                 * B is unconstrained; zero or negative values are handled
//                   correctly.
//                 * C>0, non-positive value results in exception
//                 * D is unconstrained
//                 * G>0, non-positive value results in exception
//
// Result:
//     model value at X
//
// NOTE: if B=0, denominator is assumed to be equal to Power(2.0,G) even  for
//       zero X (strictly speaking, 0^0 is undefined).
//
// NOTE: this function also throws exception  if  all  input  parameters  are
//       correct, but overflow was detected during calculations.
//
// NOTE: this function performs a lot of checks;  if  you  need  really  high
//       performance, consider evaluating model  yourself,  without  checking
//       for degenerate cases.
// ALGLIB Project: Copyright 14.05.2014 by Sergey Bochkanov
// API: double logisticcalc5(const double x, const double a, const double b, const double c, const double d, const double g, const xparams _xparams = xdefault);
double logisticcalc5(double x, double a, double b, double c, double d, double g, ae_state *_state) {
   double result;
   ae_assert(ae_isfinite(x, _state), "LogisticCalc5: X is not finite", _state);
   ae_assert(ae_isfinite(a, _state), "LogisticCalc5: A is not finite", _state);
   ae_assert(ae_isfinite(b, _state), "LogisticCalc5: B is not finite", _state);
   ae_assert(ae_isfinite(c, _state), "LogisticCalc5: C is not finite", _state);
   ae_assert(ae_isfinite(d, _state), "LogisticCalc5: D is not finite", _state);
   ae_assert(ae_isfinite(g, _state), "LogisticCalc5: G is not finite", _state);
   ae_assert(x >= 0.0, "LogisticCalc5: X is negative", _state);
   ae_assert(c > 0.0, "LogisticCalc5: C is non-positive", _state);
   ae_assert(g > 0.0, "LogisticCalc5: G is non-positive", _state);
// Check for degenerate cases
   if (b == 0.0) {
      result = d + (a - d) / ae_pow(2.0, g, _state);
      return result;
   }
   if (x == 0.0) {
      if (b > 0.0) {
         result = a;
      } else {
         result = d;
      }
      return result;
   }
// General case
   result = d + (a - d) / ae_pow(1.0 + ae_pow(x / c, b, _state), g, _state);
   ae_assert(ae_isfinite(result, _state), "LogisticCalc5: overflow during calculations", _state);
   return result;
}

// Internal 4PL/5PL fitting function.
//
// Accepts X, Y and already initialized and prepared MinLMState structure.
// On input P1 contains initial guess, on output it contains solution.  FLast
// stores function value at P1.
static void lsfit_logisticfitinternal(RVector *x, RVector *y, ae_int_t n, bool is4pl, double lambdav, minlmstate *state, minlmreport *replm, RVector *p1, double *flast, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   double ta;
   double tb;
   double tc;
   double td;
   double tg;
   double vp0;
   double vp1;
   *flast = 0;
   minlmrestartfrom(state, p1, _state);
   while (minlmiteration(state, _state)) {
      ta = state->x.xR[0];
      tb = state->x.xR[1];
      tc = state->x.xR[2];
      td = state->x.xR[3];
      tg = state->x.xR[4];
      if (state->xupdated) {
      // Save best function value obtained so far.
         *flast = state->f;
         continue;
      }
      if (state->needfi || state->needfij) {
      // Function vector and Jacobian
         for (i = 0; i < n; i++) {
            ae_assert(x->xR[i] >= 0.0, "LogisticFitInternal: integrity error", _state);
         // Handle zero X
            if (x->xR[i] == 0.0) {
               if (tb >= 0.0) {
               // Positive or zero TB, limit X^TB subject to X->+0 is equal to zero.
                  state->fi.xR[i] = ta - y->xR[i];
                  if (state->needfij) {
                     state->j.xyR[i][0] = 1.0;
                     state->j.xyR[i][1] = 0.0;
                     state->j.xyR[i][2] = 0.0;
                     state->j.xyR[i][3] = 0.0;
                     state->j.xyR[i][4] = 0.0;
                  }
               } else {
               // Negative TB, limit X^TB subject to X->+0 is equal to +INF.
                  state->fi.xR[i] = td - y->xR[i];
                  if (state->needfij) {
                     state->j.xyR[i][0] = 0.0;
                     state->j.xyR[i][1] = 0.0;
                     state->j.xyR[i][2] = 0.0;
                     state->j.xyR[i][3] = 1.0;
                     state->j.xyR[i][4] = 0.0;
                  }
               }
               continue;
            }
         // Positive X.
         // Prepare VP0/VP1, it may become infinite or nearly overflow in some rare cases,
         // handle these cases
            vp0 = ae_pow(x->xR[i] / tc, tb, _state);
            if (is4pl) {
               vp1 = 1 + vp0;
            } else {
               vp1 = ae_pow(1 + vp0, tg, _state);
            }
            if ((!ae_isfinite(vp1, _state) || vp0 > 1.0E50) || vp1 > 1.0E50) {
            // VP0/VP1 are not finite, assume that it is +INF or -INF
               state->fi.xR[i] = td - y->xR[i];
               if (state->needfij) {
                  state->j.xyR[i][0] = 0.0;
                  state->j.xyR[i][1] = 0.0;
                  state->j.xyR[i][2] = 0.0;
                  state->j.xyR[i][3] = 1.0;
                  state->j.xyR[i][4] = 0.0;
               }
               continue;
            }
         // VP0/VP1 are finite, normal processing
            if (is4pl) {
               state->fi.xR[i] = td + (ta - td) / vp1 - y->xR[i];
               if (state->needfij) {
                  state->j.xyR[i][0] = 1 / vp1;
                  state->j.xyR[i][1] = -(ta - td) * vp0 * ae_log(x->xR[i] / tc, _state) / sqr(vp1, _state);
                  state->j.xyR[i][2] = (ta - td) * (tb / tc) * vp0 / sqr(vp1, _state);
                  state->j.xyR[i][3] = 1 - 1 / vp1;
                  state->j.xyR[i][4] = 0.0;
               }
            } else {
               state->fi.xR[i] = td + (ta - td) / vp1 - y->xR[i];
               if (state->needfij) {
                  state->j.xyR[i][0] = 1 / vp1;
                  state->j.xyR[i][1] = (ta - td) * (-tg) * ae_pow(1 + vp0, -tg - 1, _state) * vp0 * ae_log(x->xR[i] / tc, _state);
                  state->j.xyR[i][2] = (ta - td) * (-tg) * ae_pow(1 + vp0, -tg - 1, _state) * vp0 * (-tb / tc);
                  state->j.xyR[i][3] = 1 - 1 / vp1;
                  state->j.xyR[i][4] = -(ta - td) / vp1 * ae_log(1 + vp0, _state);
               }
            }
         }
      // Add regularizer
         for (i = 0; i <= 4; i++) {
            state->fi.xR[n + i] = lambdav * state->x.xR[i];
            if (state->needfij) {
               for (j = 0; j <= 4; j++) {
                  state->j.xyR[n + i][j] = 0.0;
               }
               state->j.xyR[n + i][i] = lambdav;
            }
         }
      // Done
         continue;
      }
      ae_assert(false, "LogisticFitX: internal error", _state);
   }
   minlmresultsbuf(state, p1, replm, _state);
   ae_assert(replm->terminationtype > 0, "LogisticFitX: internal error", _state);
}

// Calculate errors for 4PL/5PL fit.
// Leaves other fields of Rep unchanged, so caller should properly initialize
// it with ClearRep() call.
// ALGLIB Project: Copyright 28.04.2017 by Sergey Bochkanov
static void lsfit_logisticfit45errors(RVector *x, RVector *y, ae_int_t n, double a, double b, double c, double d, double g, lsfitreport *rep, ae_state *_state) {
   ae_int_t i;
   ae_int_t k;
   double v;
   double rss;
   double tss;
   double meany;
// Calculate errors
   rep->rmserror = 0.0;
   rep->avgerror = 0.0;
   rep->avgrelerror = 0.0;
   rep->maxerror = 0.0;
   k = 0;
   rss = 0.0;
   tss = 0.0;
   meany = 0.0;
   for (i = 0; i < n; i++) {
      meany += y->xR[i];
   }
   meany /= n;
   for (i = 0; i < n; i++) {
   // Calculate residual from regression
      if (x->xR[i] > 0.0) {
         v = d + (a - d) / ae_pow(1.0 + ae_pow(x->xR[i] / c, b, _state), g, _state) - y->xR[i];
      } else {
         if (b >= 0.0) {
            v = a - y->xR[i];
         } else {
            v = d - y->xR[i];
         }
      }
   // Update RSS (residual sum of squares) and TSS (total sum of squares)
   // which are used to calculate coefficient of determination.
   //
   // NOTE: we use formula R2 = 1-RSS/TSS because it has nice property of
   //       being equal to 0.0 if and only if model perfectly fits data.
   //
   //       When we fit nonlinear models, there are exist multiple ways of
   //       determining R2, each of them giving different results. Formula
   //       above is the most intuitive one.
      rss += v * v;
      tss += sqr(y->xR[i] - meany, _state);
   // Update errors
      rep->rmserror += sqr(v, _state);
      rep->avgerror += ae_fabs(v, _state);
      if (y->xR[i] != 0.0) {
         rep->avgrelerror += ae_fabs(v / y->xR[i], _state);
         k++;
      }
      rep->maxerror = maxreal(rep->maxerror, ae_fabs(v, _state), _state);
   }
   rep->rmserror = ae_sqrt(rep->rmserror / n, _state);
   rep->avgerror /= n;
   if (k > 0) {
      rep->avgrelerror /= k;
   }
   rep->r2 = 1.0 - rss / tss;
}

// This is "expert" 4PL/5PL fitting function, which can be used if  you  need
// better control over fitting process than provided  by  LogisticFit4()  or
// LogisticFit5().
//
// This function fits model of the form
//
//     F(x|A,B,C,D)   = D+(A-D)/(1+Power(x/C,B))           (4PL model)
//
// or
//
//     F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)    (5PL model)
//
// Here:
//     * A, D - unconstrained
//     * B >= 0 for 4PL, unconstrained for 5PL
//     * C>0
//     * G>0 (if present)
//
// Inputs:
//     X       -   array[N], stores X-values.
//                 MUST include only non-negative numbers  (but  may  include
//                 zero values). Can be unsorted.
//     Y       -   array[N], values to fit.
//     N       -   number of points. If N is less than  length  of  X/Y, only
//                 leading N elements are used.
//     CnstrLeft-  optional equality constraint for model value at the   left
//                 boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
//                 not need constraint on the model value at X=0 (in C++  you
//                 can pass NAN as parameter, in  C#  it  will  be
//                 Double.NaN).
//                 See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
//                 information about constraints.
//     CnstrRight- optional equality constraint for model value at X=infinity.
//                 Specify NAN (Not-a-Number) if you do not  need  constraint
//                 on the model value (in C++  you can pass NAN as
//                 parameter, in  C# it will  be Double.NaN).
//                 See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
//                 information about constraints.
//     Is4PL   -   whether 4PL or 5PL models are fitted
//     LambdaV -   regularization coefficient, LambdaV >= 0.
//                 Set it to zero unless you know what you are doing.
//     EpsX    -   stopping condition (step size), EpsX >= 0.
//                 Zero value means that small step is automatically chosen.
//                 See notes below for more information.
//     RsCnt   -   number of repeated restarts from  random  points.  4PL/5PL
//                 models are prone to problem of bad local extrema. Utilizing
//                 multiple random restarts allows  us  to  improve algorithm
//                 convergence.
//                 RsCnt >= 0.
//                 Zero value means that function automatically choose  small
//                 amount of restarts (recommended).
//
// Outputs:
//     A, B, C, D- parameters of 4PL model
//     G       -   parameter of 5PL model; for Is4PL=True, G=1 is returned.
//     Rep     -   fitting report. This structure has many fields,  but  ONLY
//                 ONES LISTED BELOW ARE SET:
//                 * Rep.IterationsCount - number of iterations performed
//                 * Rep.RMSError - root-mean-square error
//                 * Rep.AvgError - average absolute error
//                 * Rep.AvgRelError - average relative error (calculated for
//                   non-zero Y-values)
//                 * Rep.MaxError - maximum absolute error
//                 * Rep.R2 - coefficient of determination,  R-squared.  This
//                   coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
//                   of nonlinear  regression  there  are  multiple  ways  to
//                   define R2, each of them giving different results).
//
// NOTE: for better stability B  parameter is restricted by [+-1/1000,+-1000]
//       range, and G is restricted by [1/10,10] range. It prevents algorithm
//       from making trial steps deep into the area of bad parameters.
//
// NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
//       LogisticCalc5() function.
//
// NOTE: step is automatically scaled according to scale of parameters  being
//       fitted before we compare its length with EpsX. Thus,  this  function
//       can be used to fit data with very small or very large values without
//       changing EpsX.
//
// EQUALITY CONSTRAINTS ON PARAMETERS
//
// 4PL/5PL solver supports equality constraints on model values at  the  left
// boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
// completely optional and you can specify both of them, only  one  -  or  no
// constraints at all.
//
// Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
// fitting), and CnstrRight contains right  one.  For  4PL,  left  constraint
// ALWAYS corresponds to parameter A, and right one is ALWAYS  constraint  on
// D. That's because 4PL model is normalized in such way that B >= 0.
//
// For 5PL model things are different. Unlike  4PL  one,  5PL  model  is  NOT
// symmetric with respect to  change  in  sign  of  B. Thus, negative B's are
// possible, and left constraint may constrain parameter A (for positive B's)
// - or parameter D (for negative B's). Similarly changes  meaning  of  right
// constraint.
//
// You do not have to decide what parameter to  constrain  -  algorithm  will
// automatically determine correct parameters as fitting progresses. However,
// question highlighted above is important when you interpret fitting results.
// ALGLIB Project: Copyright 14.02.2014 by Sergey Bochkanov
// API: void logisticfit45x(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const double cnstrleft, const double cnstrright, const bool is4pl, const double lambdav, const double epsx, const ae_int_t rscnt, double &a, double &b, double &c, double &d, double &g, lsfitreport &rep, const xparams _xparams = xdefault);
void logisticfit45x(RVector *x, RVector *y, ae_int_t n, double cnstrleft, double cnstrright, bool is4pl, double lambdav, double epsx, ae_int_t rscnt, double *a, double *b, double *c, double *d, double *g, lsfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t outerit;
   ae_int_t nz;
   double v;
   ae_int_t maxits;
   double fbest;
   double flast;
   double scalex;
   double scaley;
   double fposb;
   double fnegb;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   *a = 0;
   *b = 0;
   *c = 0;
   *d = 0;
   *g = 0;
   SetObj(lsfitreport, rep);
   NewVector(p0, 0, DT_REAL, _state);
   NewVector(p1, 0, DT_REAL, _state);
   NewVector(p2, 0, DT_REAL, _state);
   NewVector(bndl, 0, DT_REAL, _state);
   NewVector(bndu, 0, DT_REAL, _state);
   NewVector(s, 0, DT_REAL, _state);
   NewVector(bndl1, 0, DT_REAL, _state);
   NewVector(bndu1, 0, DT_REAL, _state);
   NewVector(bndl2, 0, DT_REAL, _state);
   NewVector(bndu2, 0, DT_REAL, _state);
   NewMatrix(z, 0, 0, DT_REAL, _state);
   NewObj(hqrndstate, rs, _state);
   NewObj(minlmstate, state, _state);
   NewObj(minlmreport, replm, _state);
   NewVector(bufx, 0, DT_REAL, _state);
   NewVector(bufy, 0, DT_REAL, _state);
   ae_assert(ae_isfinite(epsx, _state), "LogisticFitX: EpsX is infinite/NAN", _state);
   ae_assert(ae_isfinite(lambdav, _state), "LogisticFitX: LambdaV is infinite/NAN", _state);
   ae_assert(ae_isfinite(cnstrleft, _state) || ae_isnan(cnstrleft, _state), "LogisticFitX: CnstrLeft is NOT finite or NAN", _state);
   ae_assert(ae_isfinite(cnstrright, _state) || ae_isnan(cnstrright, _state), "LogisticFitX: CnstrRight is NOT finite or NAN", _state);
   ae_assert(lambdav >= 0.0, "LogisticFitX: negative LambdaV", _state);
   ae_assert(n > 0, "LogisticFitX: N <= 0", _state);
   ae_assert(rscnt >= 0, "LogisticFitX: RsCnt<0", _state);
   ae_assert(epsx >= 0.0, "LogisticFitX: EpsX<0", _state);
   ae_assert(x->cnt >= n, "LogisticFitX: Length(X)<N", _state);
   ae_assert(y->cnt >= n, "LogisticFitX: Length(Y)<N", _state);
   ae_assert(isfinitevector(x, n, _state), "LogisticFitX: X contains infinite/NAN values", _state);
   ae_assert(isfinitevector(y, n, _state), "LogisticFitX: X contains infinite/NAN values", _state);
   hqrndseed(2211, 1033044, &rs, _state);
   lsfit_clearreport(rep, _state);
   if (epsx == 0.0) {
      epsx = 1.0E-10;
   }
   if (rscnt == 0) {
      rscnt = 4;
   }
   maxits = 1000;
// Sort points by X.
// Determine number of zero and non-zero values.
   tagsortfastr(x, y, &bufx, &bufy, n, _state);
   ae_assert(x->xR[0] >= 0.0, "LogisticFitX: some X[] are negative", _state);
   nz = n;
   for (i = 0; i < n; i++) {
      if (x->xR[i] > 0.0) {
         nz = i;
         break;
      }
   }
// For NZ=N (all X[] are zero) special code is used.
// For NZ<N we use general-purpose code.
   rep->iterationscount = 0;
   if (nz == n) {
   // NZ=N, degenerate problem.
   // No need to run optimizer.
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += y->xR[i];
      }
      v /= n;
      if (ae_isfinite(cnstrleft, _state)) {
         *a = cnstrleft;
      } else {
         *a = v;
      }
      *b = 1.0;
      *c = 1.0;
      if (ae_isfinite(cnstrright, _state)) {
         *d = cnstrright;
      } else {
         *d = *a;
      }
      *g = 1.0;
      lsfit_logisticfit45errors(x, y, n, *a, *b, *c, *d, *g, rep, _state);
      ae_frame_leave(_state);
      return;
   }
// Non-degenerate problem.
// Determine scale of data.
   scalex = x->xR[nz + (n - nz) / 2];
   ae_assert(scalex > 0.0, "LogisticFitX: internal error", _state);
   v = 0.0;
   for (i = 0; i < n; i++) {
      v += y->xR[i];
   }
   v /= n;
   scaley = 0.0;
   for (i = 0; i < n; i++) {
      scaley += sqr(y->xR[i] - v, _state);
   }
   scaley = ae_sqrt(scaley / n, _state);
   if (scaley == 0.0) {
      scaley = 1.0;
   }
   ae_vector_set_length(&s, 5, _state);
   s.xR[0] = scaley;
   s.xR[1] = 0.1;
   s.xR[2] = scalex;
   s.xR[3] = scaley;
   s.xR[4] = 0.1;
   ae_vector_set_length(&p0, 5, _state);
   p0.xR[0] = 0.0;
   p0.xR[1] = 0.0;
   p0.xR[2] = 0.0;
   p0.xR[3] = 0.0;
   p0.xR[4] = 0.0;
   ae_vector_set_length(&bndl, 5, _state);
   ae_vector_set_length(&bndu, 5, _state);
   ae_vector_set_length(&bndl1, 5, _state);
   ae_vector_set_length(&bndu1, 5, _state);
   ae_vector_set_length(&bndl2, 5, _state);
   ae_vector_set_length(&bndu2, 5, _state);
   minlmcreatevj(5, n + 5, &p0, &state, _state);
   minlmsetscale(&state, &s, _state);
   minlmsetcond(&state, epsx, maxits, _state);
   minlmsetxrep(&state, true, _state);
   ae_vector_set_length(&p1, 5, _state);
   ae_vector_set_length(&p2, 5, _state);
// Is it 4PL problem?
   if (is4pl) {
   // Run outer iterations
      *a = 0.0;
      *b = 1.0;
      *c = 1.0;
      *d = 1.0;
      *g = 1.0;
      fbest = maxrealnumber;
      for (outerit = 0; outerit < rscnt; outerit++) {
      // Prepare initial point; use B>0
         if (ae_isfinite(cnstrleft, _state)) {
            p1.xR[0] = cnstrleft;
         } else {
            p1.xR[0] = y->xR[0] + 0.15 * scaley * (hqrnduniformr(&rs, _state) - 0.5);
         }
         p1.xR[1] = 0.5 + hqrnduniformr(&rs, _state);
         p1.xR[2] = x->xR[nz + hqrnduniformi(&rs, n - nz, _state)];
         if (ae_isfinite(cnstrright, _state)) {
            p1.xR[3] = cnstrright;
         } else {
            p1.xR[3] = y->xR[n - 1] + 0.25 * scaley * (hqrnduniformr(&rs, _state) - 0.5);
         }
         p1.xR[4] = 1.0;
      // Run optimization with tight constraints and increased regularization
         if (ae_isfinite(cnstrleft, _state)) {
            bndl.xR[0] = cnstrleft;
            bndu.xR[0] = cnstrleft;
         } else {
            bndl.xR[0] = _state->v_neginf;
            bndu.xR[0] = _state->v_posinf;
         }
         bndl.xR[1] = 0.5;
         bndu.xR[1] = 2.0;
         bndl.xR[2] = 0.5 * scalex;
         bndu.xR[2] = 2.0 * scalex;
         if (ae_isfinite(cnstrright, _state)) {
            bndl.xR[3] = cnstrright;
            bndu.xR[3] = cnstrright;
         } else {
            bndl.xR[3] = _state->v_neginf;
            bndu.xR[3] = _state->v_posinf;
         }
         bndl.xR[4] = 1.0;
         bndu.xR[4] = 1.0;
         minlmsetbc(&state, &bndl, &bndu, _state);
         lsfit_logisticfitinternal(x, y, n, is4pl, 100 * lambdav, &state, &replm, &p1, &flast, _state);
         rep->iterationscount += replm.iterationscount;
      // Relax constraints, run optimization one more time
         bndl.xR[1] = 0.1;
         bndu.xR[1] = 10.0;
         bndl.xR[2] = machineepsilon * scalex;
         bndu.xR[2] = scalex / machineepsilon;
         minlmsetbc(&state, &bndl, &bndu, _state);
         lsfit_logisticfitinternal(x, y, n, is4pl, lambdav, &state, &replm, &p1, &flast, _state);
         rep->iterationscount += replm.iterationscount;
      // Relax constraints more, run optimization one more time
         bndl.xR[1] = 0.01;
         bndu.xR[1] = 100.0;
         minlmsetbc(&state, &bndl, &bndu, _state);
         lsfit_logisticfitinternal(x, y, n, is4pl, lambdav, &state, &replm, &p1, &flast, _state);
         rep->iterationscount += replm.iterationscount;
      // Relax constraints ever more, run optimization one more time
         bndl.xR[1] = 0.001;
         bndu.xR[1] = 1000.0;
         minlmsetbc(&state, &bndl, &bndu, _state);
         lsfit_logisticfitinternal(x, y, n, is4pl, lambdav, &state, &replm, &p1, &flast, _state);
         rep->iterationscount += replm.iterationscount;
      // Compare results with best value found so far.
         if (flast < fbest) {
            *a = p1.xR[0];
            *b = p1.xR[1];
            *c = p1.xR[2];
            *d = p1.xR[3];
            *g = p1.xR[4];
            fbest = flast;
         }
      }
      lsfit_logisticfit45errors(x, y, n, *a, *b, *c, *d, *g, rep, _state);
      ae_frame_leave(_state);
      return;
   }
// Well.... we have 5PL fit, and we have to test two separate branches:
// B>0 and B<0, because of asymmetry in the curve. First, we run optimization
// with tight constraints two times, in order to determine better sign for B.
//
// Run outer iterations
   *a = 0.0;
   *b = 1.0;
   *c = 1.0;
   *d = 1.0;
   *g = 1.0;
   fbest = maxrealnumber;
   for (outerit = 0; outerit < rscnt; outerit++) {
   // First, we try positive B.
      p1.xR[0] = y->xR[0] + 0.15 * scaley * (hqrnduniformr(&rs, _state) - 0.5);
      p1.xR[1] = 0.5 + hqrnduniformr(&rs, _state);
      p1.xR[2] = x->xR[nz + hqrnduniformi(&rs, n - nz, _state)];
      p1.xR[3] = y->xR[n - 1] + 0.25 * scaley * (hqrnduniformr(&rs, _state) - 0.5);
      p1.xR[4] = 1.0;
      bndl1.xR[0] = _state->v_neginf;
      bndu1.xR[0] = _state->v_posinf;
      bndl1.xR[1] = 0.5;
      bndu1.xR[1] = 2.0;
      bndl1.xR[2] = 0.5 * scalex;
      bndu1.xR[2] = 2.0 * scalex;
      bndl1.xR[3] = _state->v_neginf;
      bndu1.xR[3] = _state->v_posinf;
      bndl1.xR[4] = 0.5;
      bndu1.xR[4] = 2.0;
      if (ae_isfinite(cnstrleft, _state)) {
         p1.xR[0] = cnstrleft;
         bndl1.xR[0] = cnstrleft;
         bndu1.xR[0] = cnstrleft;
      }
      if (ae_isfinite(cnstrright, _state)) {
         p1.xR[3] = cnstrright;
         bndl1.xR[3] = cnstrright;
         bndu1.xR[3] = cnstrright;
      }
      minlmsetbc(&state, &bndl1, &bndu1, _state);
      lsfit_logisticfitinternal(x, y, n, is4pl, 100 * lambdav, &state, &replm, &p1, &fposb, _state);
      rep->iterationscount += replm.iterationscount;
   // Second attempt - with negative B (constraints are still tight).
      p2.xR[0] = y->xR[n - 1] + 0.15 * scaley * (hqrnduniformr(&rs, _state) - 0.5);
      p2.xR[1] = -(0.5 + hqrnduniformr(&rs, _state));
      p2.xR[2] = x->xR[nz + hqrnduniformi(&rs, n - nz, _state)];
      p2.xR[3] = y->xR[0] + 0.25 * scaley * (hqrnduniformr(&rs, _state) - 0.5);
      p2.xR[4] = 1.0;
      bndl2.xR[0] = _state->v_neginf;
      bndu2.xR[0] = _state->v_posinf;
      bndl2.xR[1] = -2.0;
      bndu2.xR[1] = -0.5;
      bndl2.xR[2] = 0.5 * scalex;
      bndu2.xR[2] = 2.0 * scalex;
      bndl2.xR[3] = _state->v_neginf;
      bndu2.xR[3] = _state->v_posinf;
      bndl2.xR[4] = 0.5;
      bndu2.xR[4] = 2.0;
      if (ae_isfinite(cnstrleft, _state)) {
         p2.xR[3] = cnstrleft;
         bndl2.xR[3] = cnstrleft;
         bndu2.xR[3] = cnstrleft;
      }
      if (ae_isfinite(cnstrright, _state)) {
         p2.xR[0] = cnstrright;
         bndl2.xR[0] = cnstrright;
         bndu2.xR[0] = cnstrright;
      }
      minlmsetbc(&state, &bndl2, &bndu2, _state);
      lsfit_logisticfitinternal(x, y, n, is4pl, 100 * lambdav, &state, &replm, &p2, &fnegb, _state);
      rep->iterationscount += replm.iterationscount;
   // Select best version of B sign
      if (fposb < fnegb) {
      // Prepare relaxed constraints assuming that B is positive
         bndl1.xR[1] = 0.1;
         bndu1.xR[1] = 10.0;
         bndl1.xR[2] = machineepsilon * scalex;
         bndu1.xR[2] = scalex / machineepsilon;
         bndl1.xR[4] = 0.1;
         bndu1.xR[4] = 10.0;
         minlmsetbc(&state, &bndl1, &bndu1, _state);
         lsfit_logisticfitinternal(x, y, n, is4pl, lambdav, &state, &replm, &p1, &flast, _state);
         rep->iterationscount += replm.iterationscount;
      // Prepare stronger relaxation of constraints
         bndl1.xR[1] = 0.01;
         bndu1.xR[1] = 100.0;
         minlmsetbc(&state, &bndl1, &bndu1, _state);
         lsfit_logisticfitinternal(x, y, n, is4pl, lambdav, &state, &replm, &p1, &flast, _state);
         rep->iterationscount += replm.iterationscount;
      // Prepare stronger relaxation of constraints
         bndl1.xR[1] = 0.001;
         bndu1.xR[1] = 1000.0;
         minlmsetbc(&state, &bndl1, &bndu1, _state);
         lsfit_logisticfitinternal(x, y, n, is4pl, lambdav, &state, &replm, &p1, &flast, _state);
         rep->iterationscount += replm.iterationscount;
      // Compare results with best value found so far.
         if (flast < fbest) {
            *a = p1.xR[0];
            *b = p1.xR[1];
            *c = p1.xR[2];
            *d = p1.xR[3];
            *g = p1.xR[4];
            fbest = flast;
         }
      } else {
      // Prepare relaxed constraints assuming that B is negative
         bndl2.xR[1] = -10.0;
         bndu2.xR[1] = -0.1;
         bndl2.xR[2] = machineepsilon * scalex;
         bndu2.xR[2] = scalex / machineepsilon;
         bndl2.xR[4] = 0.1;
         bndu2.xR[4] = 10.0;
         minlmsetbc(&state, &bndl2, &bndu2, _state);
         lsfit_logisticfitinternal(x, y, n, is4pl, lambdav, &state, &replm, &p2, &flast, _state);
         rep->iterationscount += replm.iterationscount;
      // Prepare stronger relaxation
         bndl2.xR[1] = -100.0;
         bndu2.xR[1] = -0.01;
         minlmsetbc(&state, &bndl2, &bndu2, _state);
         lsfit_logisticfitinternal(x, y, n, is4pl, lambdav, &state, &replm, &p2, &flast, _state);
         rep->iterationscount += replm.iterationscount;
      // Prepare stronger relaxation
         bndl2.xR[1] = -1000.0;
         bndu2.xR[1] = -0.001;
         minlmsetbc(&state, &bndl2, &bndu2, _state);
         lsfit_logisticfitinternal(x, y, n, is4pl, lambdav, &state, &replm, &p2, &flast, _state);
         rep->iterationscount += replm.iterationscount;
      // Compare results with best value found so far.
         if (flast < fbest) {
            *a = p2.xR[0];
            *b = p2.xR[1];
            *c = p2.xR[2];
            *d = p2.xR[3];
            *g = p2.xR[4];
            fbest = flast;
         }
      }
   }
   lsfit_logisticfit45errors(x, y, n, *a, *b, *c, *d, *g, rep, _state);
   ae_frame_leave(_state);
}

// This function fits four-parameter logistic (4PL) model  to  data  provided
// by user. 4PL model has following form:
//
//     F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))
//
// Here:
//     * A, D - unconstrained (see LogisticFit4EC() for constrained 4PL)
//     * B >= 0
//     * C>0
//
// IMPORTANT: output of this function is constrained in  such  way that  B>0.
//            Because 4PL model is symmetric with respect to B, there  is  no
//            need to explore  B<0.  Constraining  B  makes  algorithm easier
//            to stabilize and debug.
//            Users  who  for  some  reason  prefer to work with negative B's
//            should transform output themselves (swap A and D, replace B  by
//            -B).
//
// 4PL fitting is implemented as follows:
// * we perform small number of restarts from random locations which helps to
//   solve problem of bad local extrema. Locations are only partially  random
//   - we use input data to determine good  initial  guess,  but  we  include
//   controlled amount of randomness.
// * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
//   parameters B and C - it allows us to find good  initial  guess  for  the
//   second stage without risk of running into "flat spot".
// * second  Levenberg-Marquardt  round  is   performed   without   excessive
//   constraints. Results from the previous round are used as initial guess.
// * after fitting is done, we compare results with best values found so far,
//   rewrite "best solution" if needed, and move to next random location.
//
// Overall algorithm is very stable and is not prone to  bad  local  extrema.
// Furthermore, it automatically scales when input data have  very  large  or
// very small range.
//
// Inputs:
//     X       -   array[N], stores X-values.
//                 MUST include only non-negative numbers  (but  may  include
//                 zero values). Can be unsorted.
//     Y       -   array[N], values to fit.
//     N       -   number of points. If N is less than  length  of  X/Y, only
//                 leading N elements are used.
//
// Outputs:
//     A, B, C, D- parameters of 4PL model
//     Rep     -   fitting report. This structure has many fields,  but  ONLY
//                 ONES LISTED BELOW ARE SET:
//                 * Rep.IterationsCount - number of iterations performed
//                 * Rep.RMSError - root-mean-square error
//                 * Rep.AvgError - average absolute error
//                 * Rep.AvgRelError - average relative error (calculated for
//                   non-zero Y-values)
//                 * Rep.MaxError - maximum absolute error
//                 * Rep.R2 - coefficient of determination,  R-squared.  This
//                   coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
//                   of nonlinear  regression  there  are  multiple  ways  to
//                   define R2, each of them giving different results).
//
// NOTE: for stability reasons the B parameter is restricted by [1/1000,1000]
//       range. It prevents  algorithm from making trial steps  deep into the
//       area of bad parameters.
//
// NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
//       LogisticCalc4() function.
//
// NOTE: if you need better control over fitting process than provided by this
//       function, you may use LogisticFit45X().
//
// NOTE: step is automatically scaled according to scale of parameters  being
//       fitted before we compare its length with EpsX. Thus,  this  function
//       can be used to fit data with very small or very large values without
//       changing EpsX.
// ALGLIB Project: Copyright 14.02.2014 by Sergey Bochkanov
// API: void logisticfit4(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, double &a, double &b, double &c, double &d, lsfitreport &rep, const xparams _xparams = xdefault);
void logisticfit4(RVector *x, RVector *y, ae_int_t n, double *a, double *b, double *c, double *d, lsfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   double g;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   *a = 0;
   *b = 0;
   *c = 0;
   *d = 0;
   SetObj(lsfitreport, rep);
   logisticfit45x(x, y, n, _state->v_nan, _state->v_nan, true, 0.0, 0.0, 0, a, b, c, d, &g, rep, _state);
   ae_frame_leave(_state);
}

// This function fits four-parameter logistic (4PL) model  to  data  provided
// by user, with optional constraints on parameters A and D.  4PL  model  has
// following form:
//
//     F(x|A,B,C,D) = D+(A-D)/(1+Power(x/C,B))
//
// Here:
//     * A, D - with optional equality constraints
//     * B >= 0
//     * C>0
//
// IMPORTANT: output of this function is constrained in  such  way that  B>0.
//            Because 4PL model is symmetric with respect to B, there  is  no
//            need to explore  B<0.  Constraining  B  makes  algorithm easier
//            to stabilize and debug.
//            Users  who  for  some  reason  prefer to work with negative B's
//            should transform output themselves (swap A and D, replace B  by
//            -B).
//
// 4PL fitting is implemented as follows:
// * we perform small number of restarts from random locations which helps to
//   solve problem of bad local extrema. Locations are only partially  random
//   - we use input data to determine good  initial  guess,  but  we  include
//   controlled amount of randomness.
// * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
//   parameters B and C - it allows us to find good  initial  guess  for  the
//   second stage without risk of running into "flat spot".
// * second  Levenberg-Marquardt  round  is   performed   without   excessive
//   constraints. Results from the previous round are used as initial guess.
// * after fitting is done, we compare results with best values found so far,
//   rewrite "best solution" if needed, and move to next random location.
//
// Overall algorithm is very stable and is not prone to  bad  local  extrema.
// Furthermore, it automatically scales when input data have  very  large  or
// very small range.
//
// Inputs:
//     X       -   array[N], stores X-values.
//                 MUST include only non-negative numbers  (but  may  include
//                 zero values). Can be unsorted.
//     Y       -   array[N], values to fit.
//     N       -   number of points. If N is less than  length  of  X/Y, only
//                 leading N elements are used.
//     CnstrLeft-  optional equality constraint for model value at the   left
//                 boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
//                 not need constraint on the model value at X=0 (in C++  you
//                 can pass NAN as parameter, in  C#  it  will  be
//                 Double.NaN).
//                 See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
//                 information about constraints.
//     CnstrRight- optional equality constraint for model value at X=infinity.
//                 Specify NAN (Not-a-Number) if you do not  need  constraint
//                 on the model value (in C++  you can pass NAN as
//                 parameter, in  C# it will  be Double.NaN).
//                 See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
//                 information about constraints.
//
// Outputs:
//     A, B, C, D- parameters of 4PL model
//     Rep     -   fitting report. This structure has many fields,  but  ONLY
//                 ONES LISTED BELOW ARE SET:
//                 * Rep.IterationsCount - number of iterations performed
//                 * Rep.RMSError - root-mean-square error
//                 * Rep.AvgError - average absolute error
//                 * Rep.AvgRelError - average relative error (calculated for
//                   non-zero Y-values)
//                 * Rep.MaxError - maximum absolute error
//                 * Rep.R2 - coefficient of determination,  R-squared.  This
//                   coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
//                   of nonlinear  regression  there  are  multiple  ways  to
//                   define R2, each of them giving different results).
//
// NOTE: for stability reasons the B parameter is restricted by [1/1000,1000]
//       range. It prevents  algorithm from making trial steps  deep into the
//       area of bad parameters.
//
// NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
//       LogisticCalc4() function.
//
// NOTE: if you need better control over fitting process than provided by this
//       function, you may use LogisticFit45X().
//
// NOTE: step is automatically scaled according to scale of parameters  being
//       fitted before we compare its length with EpsX. Thus,  this  function
//       can be used to fit data with very small or very large values without
//       changing EpsX.
//
// EQUALITY CONSTRAINTS ON PARAMETERS
//
// 4PL/5PL solver supports equality constraints on model values at  the  left
// boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
// completely optional and you can specify both of them, only  one  -  or  no
// constraints at all.
//
// Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
// fitting), and CnstrRight contains right  one.  For  4PL,  left  constraint
// ALWAYS corresponds to parameter A, and right one is ALWAYS  constraint  on
// D. That's because 4PL model is normalized in such way that B >= 0.
// ALGLIB Project: Copyright 14.02.2014 by Sergey Bochkanov
// API: void logisticfit4ec(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const double cnstrleft, const double cnstrright, double &a, double &b, double &c, double &d, lsfitreport &rep, const xparams _xparams = xdefault);
void logisticfit4ec(RVector *x, RVector *y, ae_int_t n, double cnstrleft, double cnstrright, double *a, double *b, double *c, double *d, lsfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   double g;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   *a = 0;
   *b = 0;
   *c = 0;
   *d = 0;
   SetObj(lsfitreport, rep);
   logisticfit45x(x, y, n, cnstrleft, cnstrright, true, 0.0, 0.0, 0, a, b, c, d, &g, rep, _state);
   ae_frame_leave(_state);
}

// This function fits five-parameter logistic (5PL) model  to  data  provided
// by user. 5PL model has following form:
//
//     F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)
//
// Here:
//     * A, D - unconstrained
//     * B - unconstrained
//     * C>0
//     * G>0
//
// IMPORTANT: unlike in  4PL  fitting,  output  of  this  function   is   NOT
//            constrained in  such  way that B is guaranteed to be  positive.
//            Furthermore,  unlike  4PL,  5PL  model  is  NOT  symmetric with
//            respect to B, so you can NOT transform model to equivalent one,
//            with B having desired sign (>0 or <0).
//
// 5PL fitting is implemented as follows:
// * we perform small number of restarts from random locations which helps to
//   solve problem of bad local extrema. Locations are only partially  random
//   - we use input data to determine good  initial  guess,  but  we  include
//   controlled amount of randomness.
// * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
//   parameters B and C - it allows us to find good  initial  guess  for  the
//   second stage without risk of running into "flat spot".  Parameter  G  is
//   fixed at G=1.
// * second  Levenberg-Marquardt  round  is   performed   without   excessive
//   constraints on B and C, but with G still equal to 1.  Results  from  the
//   previous round are used as initial guess.
// * third Levenberg-Marquardt round relaxes constraints on G  and  tries  two
//   different models - one with B>0 and one with B<0.
// * after fitting is done, we compare results with best values found so far,
//   rewrite "best solution" if needed, and move to next random location.
//
// Overall algorithm is very stable and is not prone to  bad  local  extrema.
// Furthermore, it automatically scales when input data have  very  large  or
// very small range.
//
// Inputs:
//     X       -   array[N], stores X-values.
//                 MUST include only non-negative numbers  (but  may  include
//                 zero values). Can be unsorted.
//     Y       -   array[N], values to fit.
//     N       -   number of points. If N is less than  length  of  X/Y, only
//                 leading N elements are used.
//
// Outputs:
//     A,B,C,D,G-  parameters of 5PL model
//     Rep     -   fitting report. This structure has many fields,  but  ONLY
//                 ONES LISTED BELOW ARE SET:
//                 * Rep.IterationsCount - number of iterations performed
//                 * Rep.RMSError - root-mean-square error
//                 * Rep.AvgError - average absolute error
//                 * Rep.AvgRelError - average relative error (calculated for
//                   non-zero Y-values)
//                 * Rep.MaxError - maximum absolute error
//                 * Rep.R2 - coefficient of determination,  R-squared.  This
//                   coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
//                   of nonlinear  regression  there  are  multiple  ways  to
//                   define R2, each of them giving different results).
//
// NOTE: for better stability B  parameter is restricted by [+-1/1000,+-1000]
//       range, and G is restricted by [1/10,10] range. It prevents algorithm
//       from making trial steps deep into the area of bad parameters.
//
// NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
//       LogisticCalc5() function.
//
// NOTE: if you need better control over fitting process than provided by this
//       function, you may use LogisticFit45X().
//
// NOTE: step is automatically scaled according to scale of parameters  being
//       fitted before we compare its length with EpsX. Thus,  this  function
//       can be used to fit data with very small or very large values without
//       changing EpsX.
// ALGLIB Project: Copyright 14.02.2014 by Sergey Bochkanov
// API: void logisticfit5(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, double &a, double &b, double &c, double &d, double &g, lsfitreport &rep, const xparams _xparams = xdefault);
void logisticfit5(RVector *x, RVector *y, ae_int_t n, double *a, double *b, double *c, double *d, double *g, lsfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   *a = 0;
   *b = 0;
   *c = 0;
   *d = 0;
   *g = 0;
   SetObj(lsfitreport, rep);
   logisticfit45x(x, y, n, _state->v_nan, _state->v_nan, false, 0.0, 0.0, 0, a, b, c, d, g, rep, _state);
   ae_frame_leave(_state);
}

// This function fits five-parameter logistic (5PL) model  to  data  provided
// by user, subject to optional equality constraints on parameters A  and  D.
// 5PL model has following form:
//
//     F(x|A,B,C,D,G) = D+(A-D)/Power(1+Power(x/C,B),G)
//
// Here:
//     * A, D - with optional equality constraints
//     * B - unconstrained
//     * C>0
//     * G>0
//
// IMPORTANT: unlike in  4PL  fitting,  output  of  this  function   is   NOT
//            constrained in  such  way that B is guaranteed to be  positive.
//            Furthermore,  unlike  4PL,  5PL  model  is  NOT  symmetric with
//            respect to B, so you can NOT transform model to equivalent one,
//            with B having desired sign (>0 or <0).
//
// 5PL fitting is implemented as follows:
// * we perform small number of restarts from random locations which helps to
//   solve problem of bad local extrema. Locations are only partially  random
//   - we use input data to determine good  initial  guess,  but  we  include
//   controlled amount of randomness.
// * we perform Levenberg-Marquardt fitting with very  tight  constraints  on
//   parameters B and C - it allows us to find good  initial  guess  for  the
//   second stage without risk of running into "flat spot".  Parameter  G  is
//   fixed at G=1.
// * second  Levenberg-Marquardt  round  is   performed   without   excessive
//   constraints on B and C, but with G still equal to 1.  Results  from  the
//   previous round are used as initial guess.
// * third Levenberg-Marquardt round relaxes constraints on G  and  tries  two
//   different models - one with B>0 and one with B<0.
// * after fitting is done, we compare results with best values found so far,
//   rewrite "best solution" if needed, and move to next random location.
//
// Overall algorithm is very stable and is not prone to  bad  local  extrema.
// Furthermore, it automatically scales when input data have  very  large  or
// very small range.
//
// Inputs:
//     X       -   array[N], stores X-values.
//                 MUST include only non-negative numbers  (but  may  include
//                 zero values). Can be unsorted.
//     Y       -   array[N], values to fit.
//     N       -   number of points. If N is less than  length  of  X/Y, only
//                 leading N elements are used.
//     CnstrLeft-  optional equality constraint for model value at the   left
//                 boundary (at X=0). Specify NAN (Not-a-Number)  if  you  do
//                 not need constraint on the model value at X=0 (in C++  you
//                 can pass NAN as parameter, in  C#  it  will  be
//                 Double.NaN).
//                 See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
//                 information about constraints.
//     CnstrRight- optional equality constraint for model value at X=infinity.
//                 Specify NAN (Not-a-Number) if you do not  need  constraint
//                 on the model value (in C++  you can pass NAN as
//                 parameter, in  C# it will  be Double.NaN).
//                 See  below,  section  "EQUALITY  CONSTRAINTS"   for   more
//                 information about constraints.
//
// Outputs:
//     A,B,C,D,G-  parameters of 5PL model
//     Rep     -   fitting report. This structure has many fields,  but  ONLY
//                 ONES LISTED BELOW ARE SET:
//                 * Rep.IterationsCount - number of iterations performed
//                 * Rep.RMSError - root-mean-square error
//                 * Rep.AvgError - average absolute error
//                 * Rep.AvgRelError - average relative error (calculated for
//                   non-zero Y-values)
//                 * Rep.MaxError - maximum absolute error
//                 * Rep.R2 - coefficient of determination,  R-squared.  This
//                   coefficient   is  calculated  as  R2=1-RSS/TSS  (in case
//                   of nonlinear  regression  there  are  multiple  ways  to
//                   define R2, each of them giving different results).
//
// NOTE: for better stability B  parameter is restricted by [+-1/1000,+-1000]
//       range, and G is restricted by [1/10,10] range. It prevents algorithm
//       from making trial steps deep into the area of bad parameters.
//
// NOTE: after  you  obtained  coefficients,  you  can  evaluate  model  with
//       LogisticCalc5() function.
//
// NOTE: if you need better control over fitting process than provided by this
//       function, you may use LogisticFit45X().
//
// NOTE: step is automatically scaled according to scale of parameters  being
//       fitted before we compare its length with EpsX. Thus,  this  function
//       can be used to fit data with very small or very large values without
//       changing EpsX.
//
// EQUALITY CONSTRAINTS ON PARAMETERS
//
// 5PL solver supports equality constraints on model  values  at   the   left
// boundary (X=0) and right  boundary  (X=infinity).  These  constraints  are
// completely optional and you can specify both of them, only  one  -  or  no
// constraints at all.
//
// Parameter  CnstrLeft  contains  left  constraint (or NAN for unconstrained
// fitting), and CnstrRight contains right  one.
//
// Unlike 4PL one, 5PL model is NOT symmetric with respect to  change in sign
// of B. Thus, negative B's are possible, and left constraint  may  constrain
// parameter A (for positive B's)  -  or  parameter  D  (for  negative  B's).
// Similarly changes meaning of right constraint.
//
// You do not have to decide what parameter to  constrain  -  algorithm  will
// automatically determine correct parameters as fitting progresses. However,
// question highlighted above is important when you interpret fitting results.
// ALGLIB Project: Copyright 14.02.2014 by Sergey Bochkanov
// API: void logisticfit5ec(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const double cnstrleft, const double cnstrright, double &a, double &b, double &c, double &d, double &g, lsfitreport &rep, const xparams _xparams = xdefault);
void logisticfit5ec(RVector *x, RVector *y, ae_int_t n, double cnstrleft, double cnstrright, double *a, double *b, double *c, double *d, double *g, lsfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   *a = 0;
   *b = 0;
   *c = 0;
   *d = 0;
   *g = 0;
   SetObj(lsfitreport, rep);
   logisticfit45x(x, y, n, cnstrleft, cnstrright, false, 0.0, 0.0, 0, a, b, c, d, g, rep, _state);
   ae_frame_leave(_state);
}

// Internal subroutine, calculates barycentric basis functions.
// Used for efficient simultaneous calculation of N basis functions.
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
static void lsfit_barycentriccalcbasis(barycentricinterpolant *b, double t, RVector *y, ae_state *_state) {
   double s2;
   double s;
   double v;
   ae_int_t i;
   ae_int_t j;
// special case: N=1
   if (b->n == 1) {
      y->xR[0] = 1.0;
      return;
   }
// Here we assume that task is normalized, i.e.:
// 1. abs(Y[i]) <= 1
// 2. abs(W[i]) <= 1
// 3. X[] is ordered
//
// First, we decide: should we use "safe" formula (guarded
// against overflow) or fast one?
   s = ae_fabs(t - b->x.xR[0], _state);
   for (i = 0; i < b->n; i++) {
      v = b->x.xR[i];
      if (v == t) {
         for (j = 0; j < b->n; j++) {
            y->xR[j] = 0.0;
         }
         y->xR[i] = 1.0;
         return;
      }
      v = ae_fabs(t - v, _state);
      if (v < s) {
         s = v;
      }
   }
   s2 = 0.0;
   for (i = 0; i < b->n; i++) {
      v = s / (t - b->x.xR[i]);
      v *= b->w.xR[i];
      y->xR[i] = v;
      s2 += v;
   }
   v = 1 / s2;
   ae_v_muld(y->xR, 1, b->n, v);
}

// Internal Floater-Hormann fitting subroutine for fixed D
static void lsfit_barycentricfitwcfixedd(RVector *x, RVector *y, RVector *w, ae_int_t n, RVector *xc, RVector *yc, ZVector *dc, ae_int_t k, ae_int_t m, ae_int_t d, ae_int_t *info, barycentricinterpolant *b, barycentricfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   double v0;
   double v1;
   double mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t relcnt;
   double xa;
   double xb;
   double sa;
   double sb;
   double decay;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   DupVector(w, _state);
   DupVector(xc, _state);
   DupVector(yc, _state);
   *info = 0;
   SetObj(barycentricinterpolant, b);
   SetObj(barycentricfitreport, rep);
   NewMatrix(fmatrix, 0, 0, DT_REAL, _state);
   NewMatrix(cmatrix, 0, 0, DT_REAL, _state);
   NewVector(y2, 0, DT_REAL, _state);
   NewVector(w2, 0, DT_REAL, _state);
   NewVector(sx, 0, DT_REAL, _state);
   NewVector(sy, 0, DT_REAL, _state);
   NewVector(sbf, 0, DT_REAL, _state);
   NewVector(xoriginal, 0, DT_REAL, _state);
   NewVector(yoriginal, 0, DT_REAL, _state);
   NewVector(tmp, 0, DT_REAL, _state);
   NewObj(lsfitreport, lrep, _state);
   NewObj(barycentricinterpolant, b2, _state);
   if (((n < 1 || m < 2) || k < 0) || k >= m) {
      *info = -1;
      ae_frame_leave(_state);
      return;
   }
   for (i = 0; i < k; i++) {
      *info = 0;
      if (dc->xZ[i] < 0) {
         *info = -1;
      }
      if (dc->xZ[i] > 1) {
         *info = -1;
      }
      if (*info < 0) {
         ae_frame_leave(_state);
         return;
      }
   }
// weight decay for correct handling of task which becomes
// degenerate after constraints are applied
   decay = 10000 * machineepsilon;
// Scale X, Y, XC, YC
   lsfitscalexy(x, y, w, n, xc, yc, dc, k, &xa, &xb, &sa, &sb, &xoriginal, &yoriginal, _state);
// allocate space, initialize:
// * FMatrix-   values of basis functions at X[]
// * CMatrix-   values (derivatives) of basis functions at XC[]
   ae_vector_set_length(&y2, n + m, _state);
   ae_vector_set_length(&w2, n + m, _state);
   ae_matrix_set_length(&fmatrix, n + m, m, _state);
   if (k > 0) {
      ae_matrix_set_length(&cmatrix, k, m + 1, _state);
   }
   ae_vector_set_length(&y2, n + m, _state);
   ae_vector_set_length(&w2, n + m, _state);
// Prepare design and constraints matrices:
// * fill constraints matrix
// * fill first N rows of design matrix with values
// * fill next M rows of design matrix with regularizing term
// * append M zeros to Y
// * append M elements, mean(abs(W)) each, to W
   ae_vector_set_length(&sx, m, _state);
   ae_vector_set_length(&sy, m, _state);
   ae_vector_set_length(&sbf, m, _state);
   for (j = 0; j < m; j++) {
      sx.xR[j] = (double)(2 * j) / (m - 1) - 1;
   }
   for (i = 0; i < m; i++) {
      sy.xR[i] = 1.0;
   }
   barycentricbuildfloaterhormann(&sx, &sy, m, d, &b2, _state);
   mx = 0.0;
   for (i = 0; i < n; i++) {
      lsfit_barycentriccalcbasis(&b2, x->xR[i], &sbf, _state);
      ae_v_move(fmatrix.xyR[i], 1, sbf.xR, 1, m);
      y2.xR[i] = y->xR[i];
      w2.xR[i] = w->xR[i];
      mx += ae_fabs(w->xR[i], _state) / n;
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < m; j++) {
         if (i == j) {
            fmatrix.xyR[n + i][j] = decay;
         } else {
            fmatrix.xyR[n + i][j] = 0.0;
         }
      }
      y2.xR[n + i] = 0.0;
      w2.xR[n + i] = mx;
   }
   if (k > 0) {
      for (j = 0; j < m; j++) {
         for (i = 0; i < m; i++) {
            sy.xR[i] = 0.0;
         }
         sy.xR[j] = 1.0;
         barycentricbuildfloaterhormann(&sx, &sy, m, d, &b2, _state);
         for (i = 0; i < k; i++) {
            ae_assert(dc->xZ[i] >= 0 && dc->xZ[i] <= 1, "BarycentricFit: internal error!", _state);
            barycentricdiff1(&b2, xc->xR[i], &v0, &v1, _state);
            if (dc->xZ[i] == 0) {
               cmatrix.xyR[i][j] = v0;
            }
            if (dc->xZ[i] == 1) {
               cmatrix.xyR[i][j] = v1;
            }
         }
      }
      for (i = 0; i < k; i++) {
         cmatrix.xyR[i][m] = yc->xR[i];
      }
   }
// Solve constrained task
   if (k > 0) {
   // solve using regularization
      lsfitlinearwc(&y2, &w2, &fmatrix, &cmatrix, n + m, m, k, info, &tmp, &lrep, _state);
   } else {
   // no constraints, no regularization needed
      lsfitlinearwc(y, w, &fmatrix, &cmatrix, n, m, k, info, &tmp, &lrep, _state);
   }
   if (*info < 0) {
      ae_frame_leave(_state);
      return;
   }
// Generate interpolant and scale it
   ae_v_move(sy.xR, 1, tmp.xR, 1, m);
   barycentricbuildfloaterhormann(&sx, &sy, m, d, b, _state);
   barycentriclintransx(b, 2 / (xb - xa), -(xa + xb) / (xb - xa), _state);
   barycentriclintransy(b, sb - sa, sa, _state);
// Scale absolute errors obtained from LSFitLinearW.
// Relative error should be calculated separately
// (because of shifting/scaling of the task)
   rep->taskrcond = lrep.taskrcond;
   rep->rmserror = lrep.rmserror * (sb - sa);
   rep->avgerror = lrep.avgerror * (sb - sa);
   rep->maxerror = lrep.maxerror * (sb - sa);
   rep->avgrelerror = 0.0;
   relcnt = 0;
   for (i = 0; i < n; i++) {
      if (yoriginal.xR[i] != 0.0) {
         rep->avgrelerror += ae_fabs(barycentriccalc(b, xoriginal.xR[i], _state) - yoriginal.xR[i], _state) / ae_fabs(yoriginal.xR[i], _state);
         relcnt++;
      }
   }
   if (relcnt != 0) {
      rep->avgrelerror /= relcnt;
   }
   ae_frame_leave(_state);
}

// Weghted rational least  squares  fitting  using  Floater-Hormann  rational
// functions  with  optimal  D  chosen  from  [0,9],  with  constraints   and
// individual weights.
//
// Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
// functions. Different values of D are tried, optimal D (least WEIGHTED root
// mean square error) is chosen.  Task  is  linear,  so  linear least squares
// solver  is  used.  Complexity  of  this  computational  scheme is O(N*M^2)
// (mostly dominated by the least squares solver).
//
// SEE ALSO
// * BarycentricFitFloaterHormann(), "lightweight" fitting without invididual
//   weights and constraints.
//
// Inputs:
//     X   -   points, array[0..N-1].
//     Y   -   function values, array[0..N-1].
//     W   -   weights, array[0..N-1]
//             Each summand in square  sum  of  approximation deviations from
//             given  values  is  multiplied  by  the square of corresponding
//             weight. Fill it by 1's if you don't  want  to  solve  weighted
//             task.
//     N   -   number of points, N>0.
//     XC  -   points where function values/derivatives are constrained,
//             array[0..K-1].
//     YC  -   values of constraints, array[0..K-1]
//     DC  -   array[0..K-1], types of constraints:
//             * DC[i]=0   means that S(XC[i])=YC[i]
//             * DC[i]=1   means that S'(XC[i])=YC[i]
//             SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
//     K   -   number of constraints, 0 <= K<M.
//             K=0 means no constraints (XC/YC/DC are not used in such cases)
//     M   -   number of basis functions ( = number_of_nodes), M >= 2.
//
// Outputs:
//     Info-   same format as in LSFitLinearWC() subroutine.
//             * Info>0    task is solved
//             * Info <= 0   an error occured:
//                         -4 means inconvergence of internal SVD
//                         -3 means inconsistent constraints
//                         -1 means another errors in parameters passed
//                            (N <= 0, for example)
//     B   -   barycentric interpolant.
//     Rep -   report, same format as in LSFitLinearWC() subroutine.
//             Following fields are set:
//             * DBest         best value of the D parameter
//             * RMSError      rms error on the (X,Y).
//             * AvgError      average error on the (X,Y).
//             * AvgRelError   average relative error on the non-zero Y
//             * MaxError      maximum error
//                             NON-WEIGHTED ERRORS ARE CALCULATED
//
// IMPORTANT:
//     this subroutine doesn't calculate task's condition number for K != 0.
//
// SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
//
// Setting constraints can lead  to undesired  results,  like ill-conditioned
// behavior, or inconsistency being detected. From the other side,  it allows
// us to improve quality of the fit. Here we summarize  our  experience  with
// constrained barycentric interpolants:
// * excessive  constraints  can  be  inconsistent.   Floater-Hormann   basis
//   functions aren't as flexible as splines (although they are very smooth).
// * the more evenly constraints are spread across [min(x),max(x)],  the more
//   chances that they will be consistent
// * the  greater  is  M (given  fixed  constraints),  the  more chances that
//   constraints will be consistent
// * in the general case, consistency of constraints IS NOT GUARANTEED.
// * in the several special cases, however, we CAN guarantee consistency.
// * one of this cases is constraints on the function  VALUES at the interval
//   boundaries. Note that consustency of the  constraints  on  the  function
//   DERIVATIVES is NOT guaranteed (you can use in such cases  cubic  splines
//   which are more flexible).
// * another  special  case  is ONE constraint on the function value (OR, but
//   not AND, derivative) anywhere in the interval
//
// Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
// can't solve your task without them. Anything beyond  special  cases  given
// above is not guaranteed and may result in inconsistency.
// ALGLIB Project: Copyright 18.08.2009 by Sergey Bochkanov
// API: void barycentricfitfloaterhormannwc(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const ae_int_t n, const real_1d_array &xc, const real_1d_array &yc, const integer_1d_array &dc, const ae_int_t k, const ae_int_t m, ae_int_t &info, barycentricinterpolant &b, barycentricfitreport &rep, const xparams _xparams = xdefault);
void barycentricfitfloaterhormannwc(RVector *x, RVector *y, RVector *w, ae_int_t n, RVector *xc, RVector *yc, ZVector *dc, ae_int_t k, ae_int_t m, ae_int_t *info, barycentricinterpolant *b, barycentricfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t d;
   ae_int_t i;
   double wrmscur;
   double wrmsbest;
   ae_int_t locinfo;
   ae_frame_make(_state, &_frame_block);
   *info = 0;
   SetObj(barycentricinterpolant, b);
   SetObj(barycentricfitreport, rep);
   NewObj(barycentricinterpolant, locb, _state);
   NewObj(barycentricfitreport, locrep, _state);
   ae_assert(n > 0, "BarycentricFitFloaterHormannWC: N <= 0!", _state);
   ae_assert(m > 0, "BarycentricFitFloaterHormannWC: M <= 0!", _state);
   ae_assert(k >= 0, "BarycentricFitFloaterHormannWC: K<0!", _state);
   ae_assert(k < m, "BarycentricFitFloaterHormannWC: K >= M!", _state);
   ae_assert(x->cnt >= n, "BarycentricFitFloaterHormannWC: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "BarycentricFitFloaterHormannWC: Length(Y)<N!", _state);
   ae_assert(w->cnt >= n, "BarycentricFitFloaterHormannWC: Length(W)<N!", _state);
   ae_assert(xc->cnt >= k, "BarycentricFitFloaterHormannWC: Length(XC)<K!", _state);
   ae_assert(yc->cnt >= k, "BarycentricFitFloaterHormannWC: Length(YC)<K!", _state);
   ae_assert(dc->cnt >= k, "BarycentricFitFloaterHormannWC: Length(DC)<K!", _state);
   ae_assert(isfinitevector(x, n, _state), "BarycentricFitFloaterHormannWC: X contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "BarycentricFitFloaterHormannWC: Y contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(w, n, _state), "BarycentricFitFloaterHormannWC: X contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(xc, k, _state), "BarycentricFitFloaterHormannWC: XC contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(yc, k, _state), "BarycentricFitFloaterHormannWC: YC contains infinite or NaN values!", _state);
   for (i = 0; i < k; i++) {
      ae_assert(dc->xZ[i] == 0 || dc->xZ[i] == 1, "BarycentricFitFloaterHormannWC: one of DC[] is not 0 or 1!", _state);
   }
// Find optimal D
//
// Info is -3 by default (degenerate constraints).
// If LocInfo will always be equal to -3, Info will remain equal to -3.
// If at least once LocInfo will be -4, Info will be -4.
   wrmsbest = maxrealnumber;
   rep->dbest = -1;
   *info = -3;
   for (d = 0; d < minint(10, n, _state); d++) {
      lsfit_barycentricfitwcfixedd(x, y, w, n, xc, yc, dc, k, m, d, &locinfo, &locb, &locrep, _state);
      ae_assert((locinfo == -4 || locinfo == -3) || locinfo > 0, "BarycentricFitFloaterHormannWC: unexpected result from BarycentricFitWCFixedD!", _state);
      if (locinfo > 0) {
      // Calculate weghted RMS
         wrmscur = 0.0;
         for (i = 0; i < n; i++) {
            wrmscur += sqr(w->xR[i] * (y->xR[i] - barycentriccalc(&locb, x->xR[i], _state)), _state);
         }
         wrmscur = ae_sqrt(wrmscur / n, _state);
         if (wrmscur < wrmsbest || rep->dbest < 0) {
            barycentriccopy(&locb, b, _state);
            rep->dbest = d;
            *info = 1;
            rep->rmserror = locrep.rmserror;
            rep->avgerror = locrep.avgerror;
            rep->avgrelerror = locrep.avgrelerror;
            rep->maxerror = locrep.maxerror;
            rep->taskrcond = locrep.taskrcond;
            wrmsbest = wrmscur;
         }
      } else {
         if (locinfo != -3 && *info < 0) {
            *info = locinfo;
         }
      }
   }
   ae_frame_leave(_state);
}

// Rational least squares fitting using  Floater-Hormann  rational  functions
// with optimal D chosen from [0,9].
//
// Equidistant  grid  with M node on [min(x),max(x)]  is  used to build basis
// functions. Different values of D are tried, optimal  D  (least  root  mean
// square error) is chosen.  Task  is  linear, so linear least squares solver
// is used. Complexity  of  this  computational  scheme is  O(N*M^2)  (mostly
// dominated by the least squares solver).
//
// Inputs:
//     X   -   points, array[0..N-1].
//     Y   -   function values, array[0..N-1].
//     N   -   number of points, N>0.
//     M   -   number of basis functions ( = number_of_nodes), M >= 2.
//
// Outputs:
//     Info-   same format as in LSFitLinearWC() subroutine.
//             * Info>0    task is solved
//             * Info <= 0   an error occured:
//                         -4 means inconvergence of internal SVD
//                         -3 means inconsistent constraints
//     B   -   barycentric interpolant.
//     Rep -   report, same format as in LSFitLinearWC() subroutine.
//             Following fields are set:
//             * DBest         best value of the D parameter
//             * RMSError      rms error on the (X,Y).
//             * AvgError      average error on the (X,Y).
//             * AvgRelError   average relative error on the non-zero Y
//             * MaxError      maximum error
//                             NON-WEIGHTED ERRORS ARE CALCULATED
// ALGLIB Project: Copyright 18.08.2009 by Sergey Bochkanov
// API: void barycentricfitfloaterhormann(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t m, ae_int_t &info, barycentricinterpolant &b, barycentricfitreport &rep, const xparams _xparams = xdefault);
void barycentricfitfloaterhormann(RVector *x, RVector *y, ae_int_t n, ae_int_t m, ae_int_t *info, barycentricinterpolant *b, barycentricfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   *info = 0;
   SetObj(barycentricinterpolant, b);
   SetObj(barycentricfitreport, rep);
   NewVector(w, 0, DT_REAL, _state);
   NewVector(xc, 0, DT_REAL, _state);
   NewVector(yc, 0, DT_REAL, _state);
   NewVector(dc, 0, DT_INT, _state);
   ae_assert(n > 0, "BarycentricFitFloaterHormann: N <= 0!", _state);
   ae_assert(m > 0, "BarycentricFitFloaterHormann: M <= 0!", _state);
   ae_assert(x->cnt >= n, "BarycentricFitFloaterHormann: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "BarycentricFitFloaterHormann: Length(Y)<N!", _state);
   ae_assert(isfinitevector(x, n, _state), "BarycentricFitFloaterHormann: X contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "BarycentricFitFloaterHormann: Y contains infinite or NaN values!", _state);
   ae_vector_set_length(&w, n, _state);
   for (i = 0; i < n; i++) {
      w.xR[i] = 1.0;
   }
   barycentricfitfloaterhormannwc(x, y, &w, n, &xc, &yc, &dc, 0, m, info, b, rep, _state);
   ae_frame_leave(_state);
}

// Internal spline fitting subroutine
// ALGLIB Project: Copyright 08.09.2009 by Sergey Bochkanov
static void lsfit_spline1dfitinternal(ae_int_t st, RVector *x, RVector *y, RVector *w, ae_int_t n, RVector *xc, RVector *yc, ZVector *dc, ae_int_t k, ae_int_t m, ae_int_t *info, spline1dinterpolant *s, spline1dfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   double v0;
   double v1;
   double v2;
   double mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t relcnt;
   double xa;
   double xb;
   double sa;
   double sb;
   double bl;
   double br;
   double decay;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   DupVector(w, _state);
   DupVector(xc, _state);
   DupVector(yc, _state);
   *info = 0;
   SetObj(spline1dinterpolant, s);
   SetObj(spline1dfitreport, rep);
   NewMatrix(fmatrix, 0, 0, DT_REAL, _state);
   NewMatrix(cmatrix, 0, 0, DT_REAL, _state);
   NewVector(y2, 0, DT_REAL, _state);
   NewVector(w2, 0, DT_REAL, _state);
   NewVector(sx, 0, DT_REAL, _state);
   NewVector(sy, 0, DT_REAL, _state);
   NewVector(sd, 0, DT_REAL, _state);
   NewVector(tmp, 0, DT_REAL, _state);
   NewVector(xoriginal, 0, DT_REAL, _state);
   NewVector(yoriginal, 0, DT_REAL, _state);
   NewObj(lsfitreport, lrep, _state);
   NewObj(spline1dinterpolant, s2, _state);
   ae_assert(st == 0 || st == 1, "Spline1DFit: internal error!", _state);
   if (st == 0 && m < 4) {
      *info = -1;
      ae_frame_leave(_state);
      return;
   }
   if (st == 1 && m < 4) {
      *info = -1;
      ae_frame_leave(_state);
      return;
   }
   if ((n < 1 || k < 0) || k >= m) {
      *info = -1;
      ae_frame_leave(_state);
      return;
   }
   for (i = 0; i < k; i++) {
      *info = 0;
      if (dc->xZ[i] < 0) {
         *info = -1;
      }
      if (dc->xZ[i] > 1) {
         *info = -1;
      }
      if (*info < 0) {
         ae_frame_leave(_state);
         return;
      }
   }
   if (st == 1 && m % 2 != 0) {
   // Hermite fitter must have even number of basis functions
      *info = -2;
      ae_frame_leave(_state);
      return;
   }
// weight decay for correct handling of task which becomes
// degenerate after constraints are applied
   decay = 10000 * machineepsilon;
// Scale X, Y, XC, YC
   lsfitscalexy(x, y, w, n, xc, yc, dc, k, &xa, &xb, &sa, &sb, &xoriginal, &yoriginal, _state);
// allocate space, initialize:
// * SX     -   grid for basis functions
// * SY     -   values of basis functions at grid points
// * FMatrix-   values of basis functions at X[]
// * CMatrix-   values (derivatives) of basis functions at XC[]
   ae_vector_set_length(&y2, n + m, _state);
   ae_vector_set_length(&w2, n + m, _state);
   ae_matrix_set_length(&fmatrix, n + m, m, _state);
   if (k > 0) {
      ae_matrix_set_length(&cmatrix, k, m + 1, _state);
   }
   if (st == 0) {
   // allocate space for cubic spline
      ae_vector_set_length(&sx, m - 2, _state);
      ae_vector_set_length(&sy, m - 2, _state);
      for (j = 0; j < m - 2; j++) {
         sx.xR[j] = (double)(2 * j) / (m - 2 - 1) - 1;
      }
   }
   if (st == 1) {
   // allocate space for Hermite spline
      ae_vector_set_length(&sx, m / 2, _state);
      ae_vector_set_length(&sy, m / 2, _state);
      ae_vector_set_length(&sd, m / 2, _state);
      for (j = 0; j < m / 2; j++) {
         sx.xR[j] = (double)(2 * j) / (m / 2 - 1) - 1;
      }
   }
// Prepare design and constraints matrices:
// * fill constraints matrix
// * fill first N rows of design matrix with values
// * fill next M rows of design matrix with regularizing term
// * append M zeros to Y
// * append M elements, mean(abs(W)) each, to W
   for (j = 0; j < m; j++) {
   // prepare Jth basis function
      if (st == 0) {
      // cubic spline basis
         for (i = 0; i < m - 2; i++) {
            sy.xR[i] = 0.0;
         }
         bl = 0.0;
         br = 0.0;
         if (j < m - 2) {
            sy.xR[j] = 1.0;
         }
         if (j == m - 2) {
            bl = 1.0;
         }
         if (j == m - 1) {
            br = 1.0;
         }
         spline1dbuildcubic(&sx, &sy, m - 2, 1, bl, 1, br, &s2, _state);
      }
      if (st == 1) {
      // Hermite basis
         for (i = 0; i < m / 2; i++) {
            sy.xR[i] = 0.0;
            sd.xR[i] = 0.0;
         }
         if (j % 2 == 0) {
            sy.xR[j / 2] = 1.0;
         } else {
            sd.xR[j / 2] = 1.0;
         }
         spline1dbuildhermite(&sx, &sy, &sd, m / 2, &s2, _state);
      }
   // values at X[], XC[]
      for (i = 0; i < n; i++) {
         fmatrix.xyR[i][j] = spline1dcalc(&s2, x->xR[i], _state);
      }
      for (i = 0; i < k; i++) {
         ae_assert(dc->xZ[i] >= 0 && dc->xZ[i] <= 2, "Spline1DFit: internal error!", _state);
         spline1ddiff(&s2, xc->xR[i], &v0, &v1, &v2, _state);
         if (dc->xZ[i] == 0) {
            cmatrix.xyR[i][j] = v0;
         }
         if (dc->xZ[i] == 1) {
            cmatrix.xyR[i][j] = v1;
         }
         if (dc->xZ[i] == 2) {
            cmatrix.xyR[i][j] = v2;
         }
      }
   }
   for (i = 0; i < k; i++) {
      cmatrix.xyR[i][m] = yc->xR[i];
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < m; j++) {
         if (i == j) {
            fmatrix.xyR[n + i][j] = decay;
         } else {
            fmatrix.xyR[n + i][j] = 0.0;
         }
      }
   }
   ae_vector_set_length(&y2, n + m, _state);
   ae_vector_set_length(&w2, n + m, _state);
   ae_v_move(y2.xR, 1, y->xR, 1, n);
   ae_v_move(w2.xR, 1, w->xR, 1, n);
   mx = 0.0;
   for (i = 0; i < n; i++) {
      mx += ae_fabs(w->xR[i], _state);
   }
   mx /= n;
   for (i = 0; i < m; i++) {
      y2.xR[n + i] = 0.0;
      w2.xR[n + i] = mx;
   }
// Solve constrained task
   if (k > 0) {
   // solve using regularization
      lsfitlinearwc(&y2, &w2, &fmatrix, &cmatrix, n + m, m, k, info, &tmp, &lrep, _state);
   } else {
   // no constraints, no regularization needed
      lsfitlinearwc(y, w, &fmatrix, &cmatrix, n, m, k, info, &tmp, &lrep, _state);
   }
   if (*info < 0) {
      ae_frame_leave(_state);
      return;
   }
// Generate spline and scale it
   if (st == 0) {
   // cubic spline basis
      ae_v_move(sy.xR, 1, tmp.xR, 1, m - 2);
      spline1dbuildcubic(&sx, &sy, m - 2, 1, tmp.xR[m - 2], 1, tmp.xR[m - 1], s, _state);
   }
   if (st == 1) {
   // Hermite basis
      for (i = 0; i < m / 2; i++) {
         sy.xR[i] = tmp.xR[2 * i];
         sd.xR[i] = tmp.xR[2 * i + 1];
      }
      spline1dbuildhermite(&sx, &sy, &sd, m / 2, s, _state);
   }
   spline1dlintransx(s, 2 / (xb - xa), -(xa + xb) / (xb - xa), _state);
   spline1dlintransy(s, sb - sa, sa, _state);
// Scale absolute errors obtained from LSFitLinearW.
// Relative error should be calculated separately
// (because of shifting/scaling of the task)
   rep->taskrcond = lrep.taskrcond;
   rep->rmserror = lrep.rmserror * (sb - sa);
   rep->avgerror = lrep.avgerror * (sb - sa);
   rep->maxerror = lrep.maxerror * (sb - sa);
   rep->avgrelerror = 0.0;
   relcnt = 0;
   for (i = 0; i < n; i++) {
      if (yoriginal.xR[i] != 0.0) {
         rep->avgrelerror += ae_fabs(spline1dcalc(s, xoriginal.xR[i], _state) - yoriginal.xR[i], _state) / ae_fabs(yoriginal.xR[i], _state);
         relcnt++;
      }
   }
   if (relcnt != 0) {
      rep->avgrelerror /= relcnt;
   }
   ae_frame_leave(_state);
}

// Weighted fitting by cubic  spline,  with constraints on function values or
// derivatives.
//
// Equidistant grid with M-2 nodes on [min(x,xc),max(x,xc)] is  used to build
// basis functions. Basis functions are cubic splines with continuous  second
// derivatives  and  non-fixed first  derivatives  at  interval  ends.  Small
// regularizing term is used  when  solving  constrained  tasks  (to  improve
// stability).
//
// Task is linear, so linear least squares solver is used. Complexity of this
// computational scheme is O(N*M^2), mostly dominated by least squares solver
//
// SEE ALSO
//     Spline1DFitHermiteWC()  -   fitting by Hermite splines (more flexible,
//                                 less smooth)
//     Spline1DFitCubic()      -   "lightweight" fitting  by  cubic  splines,
//                                 without invididual weights and constraints
//
// Inputs:
//     X   -   points, array[0..N-1].
//     Y   -   function values, array[0..N-1].
//     W   -   weights, array[0..N-1]
//             Each summand in square  sum  of  approximation deviations from
//             given  values  is  multiplied  by  the square of corresponding
//             weight. Fill it by 1's if you don't  want  to  solve  weighted
//             task.
//     N   -   number of points (optional):
//             * N>0
//             * if given, only first N elements of X/Y/W are processed
//             * if not given, automatically determined from X/Y/W sizes
//     XC  -   points where spline values/derivatives are constrained,
//             array[0..K-1].
//     YC  -   values of constraints, array[0..K-1]
//     DC  -   array[0..K-1], types of constraints:
//             * DC[i]=0   means that S(XC[i])=YC[i]
//             * DC[i]=1   means that S'(XC[i])=YC[i]
//             SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
//     K   -   number of constraints (optional):
//             * 0 <= K<M.
//             * K=0 means no constraints (XC/YC/DC are not used)
//             * if given, only first K elements of XC/YC/DC are used
//             * if not given, automatically determined from XC/YC/DC
//     M   -   number of basis functions ( = number_of_nodes+2), M >= 4.
//
// Outputs:
//     Info-   same format as in LSFitLinearWC() subroutine.
//             * Info>0    task is solved
//             * Info <= 0   an error occured:
//                         -4 means inconvergence of internal SVD
//                         -3 means inconsistent constraints
//     S   -   spline interpolant.
//     Rep -   report, same format as in LSFitLinearWC() subroutine.
//             Following fields are set:
//             * RMSError      rms error on the (X,Y).
//             * AvgError      average error on the (X,Y).
//             * AvgRelError   average relative error on the non-zero Y
//             * MaxError      maximum error
//                             NON-WEIGHTED ERRORS ARE CALCULATED
//
// IMPORTANT:
//     this subroitine doesn't calculate task's condition number for K != 0.
//
//
// ORDER OF POINTS
//
// Subroutine automatically sorts points, so caller may pass unsorted array.
//
// SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
//
// Setting constraints can lead  to undesired  results,  like ill-conditioned
// behavior, or inconsistency being detected. From the other side,  it allows
// us to improve quality of the fit. Here we summarize  our  experience  with
// constrained regression splines:
// * excessive constraints can be inconsistent. Splines are  piecewise  cubic
//   functions, and it is easy to create an example, where  large  number  of
//   constraints  concentrated  in  small  area will result in inconsistency.
//   Just because spline is not flexible enough to satisfy all of  them.  And
//   same constraints spread across the  [min(x),max(x)]  will  be  perfectly
//   consistent.
// * the more evenly constraints are spread across [min(x),max(x)],  the more
//   chances that they will be consistent
// * the  greater  is  M (given  fixed  constraints),  the  more chances that
//   constraints will be consistent
// * in the general case, consistency of constraints IS NOT GUARANTEED.
// * in the several special cases, however, we CAN guarantee consistency.
// * one of this cases is constraints  on  the  function  values  AND/OR  its
//   derivatives at the interval boundaries.
// * another  special  case  is ONE constraint on the function value (OR, but
//   not AND, derivative) anywhere in the interval
//
// Our final recommendation is to use constraints  WHEN  AND  ONLY  WHEN  you
// can't solve your task without them. Anything beyond  special  cases  given
// above is not guaranteed and may result in inconsistency.
// ALGLIB Project: Copyright 18.08.2009 by Sergey Bochkanov
// API: void spline1dfitcubicwc(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const ae_int_t n, const real_1d_array &xc, const real_1d_array &yc, const integer_1d_array &dc, const ae_int_t k, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams = xdefault);
// API: void spline1dfitcubicwc(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &xc, const real_1d_array &yc, const integer_1d_array &dc, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams = xdefault);
void spline1dfitcubicwc(RVector *x, RVector *y, RVector *w, ae_int_t n, RVector *xc, RVector *yc, ZVector *dc, ae_int_t k, ae_int_t m, ae_int_t *info, spline1dinterpolant *s, spline1dfitreport *rep, ae_state *_state) {
   ae_int_t i;
   *info = 0;
   SetObj(spline1dinterpolant, s);
   SetObj(spline1dfitreport, rep);
   ae_assert(n >= 1, "Spline1DFitCubicWC: N<1!", _state);
   ae_assert(m >= 4, "Spline1DFitCubicWC: M<4!", _state);
   ae_assert(k >= 0, "Spline1DFitCubicWC: K<0!", _state);
   ae_assert(k < m, "Spline1DFitCubicWC: K >= M!", _state);
   ae_assert(x->cnt >= n, "Spline1DFitCubicWC: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DFitCubicWC: Length(Y)<N!", _state);
   ae_assert(w->cnt >= n, "Spline1DFitCubicWC: Length(W)<N!", _state);
   ae_assert(xc->cnt >= k, "Spline1DFitCubicWC: Length(XC)<K!", _state);
   ae_assert(yc->cnt >= k, "Spline1DFitCubicWC: Length(YC)<K!", _state);
   ae_assert(dc->cnt >= k, "Spline1DFitCubicWC: Length(DC)<K!", _state);
   ae_assert(isfinitevector(x, n, _state), "Spline1DFitCubicWC: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "Spline1DFitCubicWC: Y contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(w, n, _state), "Spline1DFitCubicWC: Y contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(xc, k, _state), "Spline1DFitCubicWC: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(yc, k, _state), "Spline1DFitCubicWC: Y contains infinite or NAN values!", _state);
   for (i = 0; i < k; i++) {
      ae_assert(dc->xZ[i] == 0 || dc->xZ[i] == 1, "Spline1DFitCubicWC: DC[i] is neither 0 or 1!", _state);
   }
   lsfit_spline1dfitinternal(0, x, y, w, n, xc, yc, dc, k, m, info, s, rep, _state);
}

// Least squares fitting by cubic spline.
//
// This subroutine is "lightweight" alternative for more complex and feature-
// rich Spline1DFitCubicWC().  See  Spline1DFitCubicWC() for more information
// about subroutine parameters (we don't duplicate it here because of length)
// ALGLIB Project: Copyright 18.08.2009 by Sergey Bochkanov
// API: void spline1dfitcubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams = xdefault);
// API: void spline1dfitcubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams = xdefault);
void spline1dfitcubic(RVector *x, RVector *y, ae_int_t n, ae_int_t m, ae_int_t *info, spline1dinterpolant *s, spline1dfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   *info = 0;
   SetObj(spline1dinterpolant, s);
   SetObj(spline1dfitreport, rep);
   NewVector(w, 0, DT_REAL, _state);
   NewVector(xc, 0, DT_REAL, _state);
   NewVector(yc, 0, DT_REAL, _state);
   NewVector(dc, 0, DT_INT, _state);
   ae_assert(n >= 1, "Spline1DFitCubic: N<1!", _state);
   ae_assert(m >= 4, "Spline1DFitCubic: M<4!", _state);
   ae_assert(x->cnt >= n, "Spline1DFitCubic: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DFitCubic: Length(Y)<N!", _state);
   ae_assert(isfinitevector(x, n, _state), "Spline1DFitCubic: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "Spline1DFitCubic: Y contains infinite or NAN values!", _state);
   ae_vector_set_length(&w, n, _state);
   for (i = 0; i < n; i++) {
      w.xR[i] = 1.0;
   }
   spline1dfitcubicwc(x, y, &w, n, &xc, &yc, &dc, 0, m, info, s, rep, _state);
   ae_frame_leave(_state);
}

// Weighted  fitting  by Hermite spline,  with constraints on function values
// or first derivatives.
//
// Equidistant grid with M nodes on [min(x,xc),max(x,xc)] is  used  to  build
// basis functions. Basis functions are Hermite splines.  Small  regularizing
// term is used when solving constrained tasks (to improve stability).
//
// Task is linear, so linear least squares solver is used. Complexity of this
// computational scheme is O(N*M^2), mostly dominated by least squares solver
//
// SEE ALSO
//     Spline1DFitCubicWC()    -   fitting by Cubic splines (less flexible,
//                                 more smooth)
//     Spline1DFitHermite()    -   "lightweight" Hermite fitting, without
//                                 invididual weights and constraints
//
// Inputs:
//     X   -   points, array[0..N-1].
//     Y   -   function values, array[0..N-1].
//     W   -   weights, array[0..N-1]
//             Each summand in square  sum  of  approximation deviations from
//             given  values  is  multiplied  by  the square of corresponding
//             weight. Fill it by 1's if you don't  want  to  solve  weighted
//             task.
//     N   -   number of points (optional):
//             * N>0
//             * if given, only first N elements of X/Y/W are processed
//             * if not given, automatically determined from X/Y/W sizes
//     XC  -   points where spline values/derivatives are constrained,
//             array[0..K-1].
//     YC  -   values of constraints, array[0..K-1]
//     DC  -   array[0..K-1], types of constraints:
//             * DC[i]=0   means that S(XC[i])=YC[i]
//             * DC[i]=1   means that S'(XC[i])=YC[i]
//             SEE BELOW FOR IMPORTANT INFORMATION ON CONSTRAINTS
//     K   -   number of constraints (optional):
//             * 0 <= K<M.
//             * K=0 means no constraints (XC/YC/DC are not used)
//             * if given, only first K elements of XC/YC/DC are used
//             * if not given, automatically determined from XC/YC/DC
//     M   -   number of basis functions (= 2 * number of nodes),
//             M >= 4,
//             M IS EVEN!
//
// Outputs:
//     Info-   same format as in LSFitLinearW() subroutine:
//             * Info>0    task is solved
//             * Info <= 0   an error occured:
//                         -4 means inconvergence of internal SVD
//                         -3 means inconsistent constraints
//                         -2 means odd M was passed (which is not supported)
//                         -1 means another errors in parameters passed
//                            (N <= 0, for example)
//     S   -   spline interpolant.
//     Rep -   report, same format as in LSFitLinearW() subroutine.
//             Following fields are set:
//             * RMSError      rms error on the (X,Y).
//             * AvgError      average error on the (X,Y).
//             * AvgRelError   average relative error on the non-zero Y
//             * MaxError      maximum error
//                             NON-WEIGHTED ERRORS ARE CALCULATED
//
// IMPORTANT:
//     this subroitine doesn't calculate task's condition number for K != 0.
//
// IMPORTANT:
//     this subroitine supports only even M's
//
//
// ORDER OF POINTS
//
// Subroutine automatically sorts points, so caller may pass unsorted array.
//
// SETTING CONSTRAINTS - DANGERS AND OPPORTUNITIES:
//
// Setting constraints can lead  to undesired  results,  like ill-conditioned
// behavior, or inconsistency being detected. From the other side,  it allows
// us to improve quality of the fit. Here we summarize  our  experience  with
// constrained regression splines:
// * excessive constraints can be inconsistent. Splines are  piecewise  cubic
//   functions, and it is easy to create an example, where  large  number  of
//   constraints  concentrated  in  small  area will result in inconsistency.
//   Just because spline is not flexible enough to satisfy all of  them.  And
//   same constraints spread across the  [min(x),max(x)]  will  be  perfectly
//   consistent.
// * the more evenly constraints are spread across [min(x),max(x)],  the more
//   chances that they will be consistent
// * the  greater  is  M (given  fixed  constraints),  the  more chances that
//   constraints will be consistent
// * in the general case, consistency of constraints is NOT GUARANTEED.
// * in the several special cases, however, we can guarantee consistency.
// * one of this cases is  M >= 4  and   constraints  on   the  function  value
//   (AND/OR its derivative) at the interval boundaries.
// * another special case is M >= 4  and  ONE  constraint on the function value
//   (OR, BUT NOT AND, derivative) anywhere in [min(x),max(x)]
//
// Our final recommendation is to use constraints  WHEN  AND  ONLY  when  you
// can't solve your task without them. Anything beyond  special  cases  given
// above is not guaranteed and may result in inconsistency.
// ALGLIB Project: Copyright 18.08.2009 by Sergey Bochkanov
// API: void spline1dfithermitewc(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const ae_int_t n, const real_1d_array &xc, const real_1d_array &yc, const integer_1d_array &dc, const ae_int_t k, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams = xdefault);
// API: void spline1dfithermitewc(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &xc, const real_1d_array &yc, const integer_1d_array &dc, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams = xdefault);
void spline1dfithermitewc(RVector *x, RVector *y, RVector *w, ae_int_t n, RVector *xc, RVector *yc, ZVector *dc, ae_int_t k, ae_int_t m, ae_int_t *info, spline1dinterpolant *s, spline1dfitreport *rep, ae_state *_state) {
   ae_int_t i;
   *info = 0;
   SetObj(spline1dinterpolant, s);
   SetObj(spline1dfitreport, rep);
   ae_assert(n >= 1, "Spline1DFitHermiteWC: N<1!", _state);
   ae_assert(m >= 4, "Spline1DFitHermiteWC: M<4!", _state);
   ae_assert(m % 2 == 0, "Spline1DFitHermiteWC: M is odd!", _state);
   ae_assert(k >= 0, "Spline1DFitHermiteWC: K<0!", _state);
   ae_assert(k < m, "Spline1DFitHermiteWC: K >= M!", _state);
   ae_assert(x->cnt >= n, "Spline1DFitHermiteWC: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DFitHermiteWC: Length(Y)<N!", _state);
   ae_assert(w->cnt >= n, "Spline1DFitHermiteWC: Length(W)<N!", _state);
   ae_assert(xc->cnt >= k, "Spline1DFitHermiteWC: Length(XC)<K!", _state);
   ae_assert(yc->cnt >= k, "Spline1DFitHermiteWC: Length(YC)<K!", _state);
   ae_assert(dc->cnt >= k, "Spline1DFitHermiteWC: Length(DC)<K!", _state);
   ae_assert(isfinitevector(x, n, _state), "Spline1DFitHermiteWC: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "Spline1DFitHermiteWC: Y contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(w, n, _state), "Spline1DFitHermiteWC: Y contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(xc, k, _state), "Spline1DFitHermiteWC: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(yc, k, _state), "Spline1DFitHermiteWC: Y contains infinite or NAN values!", _state);
   for (i = 0; i < k; i++) {
      ae_assert(dc->xZ[i] == 0 || dc->xZ[i] == 1, "Spline1DFitHermiteWC: DC[i] is neither 0 or 1!", _state);
   }
   lsfit_spline1dfitinternal(1, x, y, w, n, xc, yc, dc, k, m, info, s, rep, _state);
}

// Least squares fitting by Hermite spline.
//
// This subroutine is "lightweight" alternative for more complex and feature-
// rich Spline1DFitHermiteWC().  See Spline1DFitHermiteWC()  description  for
// more information about subroutine parameters (we don't duplicate  it  here
// because of length).
// ALGLIB Project: Copyright 18.08.2009 by Sergey Bochkanov
// API: void spline1dfithermite(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams = xdefault);
// API: void spline1dfithermite(const real_1d_array &x, const real_1d_array &y, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams = xdefault);
void spline1dfithermite(RVector *x, RVector *y, ae_int_t n, ae_int_t m, ae_int_t *info, spline1dinterpolant *s, spline1dfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   *info = 0;
   SetObj(spline1dinterpolant, s);
   SetObj(spline1dfitreport, rep);
   NewVector(w, 0, DT_REAL, _state);
   NewVector(xc, 0, DT_REAL, _state);
   NewVector(yc, 0, DT_REAL, _state);
   NewVector(dc, 0, DT_INT, _state);
   ae_assert(n >= 1, "Spline1DFitHermite: N<1!", _state);
   ae_assert(m >= 4, "Spline1DFitHermite: M<4!", _state);
   ae_assert(m % 2 == 0, "Spline1DFitHermite: M is odd!", _state);
   ae_assert(x->cnt >= n, "Spline1DFitHermite: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DFitHermite: Length(Y)<N!", _state);
   ae_assert(isfinitevector(x, n, _state), "Spline1DFitHermite: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "Spline1DFitHermite: Y contains infinite or NAN values!", _state);
   ae_vector_set_length(&w, n, _state);
   for (i = 0; i < n; i++) {
      w.xR[i] = 1.0;
   }
   spline1dfithermitewc(x, y, &w, n, &xc, &yc, &dc, 0, m, info, s, rep, _state);
   ae_frame_leave(_state);
}

// Stopping conditions for nonlinear least squares fitting.
//
// Inputs:
//     State   -   structure which stores algorithm state
//     EpsX    - >= 0
//                 The subroutine finishes its work if  on  k+1-th  iteration
//                 the condition |v| <= EpsX is fulfilled, where:
//                 * |.| means Euclidian norm
//                 * v - scaled step vector, v[i]=dx[i]/s[i]
//                 * dx - ste pvector, dx=X(k+1)-X(k)
//                 * s - scaling coefficients set by LSFitSetScale()
//     MaxIts  -   maximum number of iterations. If MaxIts=0, the  number  of
//                 iterations   is    unlimited.   Only   Levenberg-Marquardt
//                 iterations  are  counted  (L-BFGS/CG  iterations  are  NOT
//                 counted because their cost is very low compared to that of
//                 LM).
//
// NOTE
//
// Passing EpsX=0  and  MaxIts=0  (simultaneously)  will  lead  to  automatic
// stopping criterion selection (according to the scheme used by MINLM unit).
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
// API: void lsfitsetcond(const lsfitstate &state, const double epsx, const ae_int_t maxits, const xparams _xparams = xdefault);
void lsfitsetcond(lsfitstate *state, double epsx, ae_int_t maxits, ae_state *_state) {
   ae_assert(ae_isfinite(epsx, _state), "LSFitSetCond: EpsX is not finite!", _state);
   ae_assert(epsx >= 0.0, "LSFitSetCond: negative EpsX!", _state);
   ae_assert(maxits >= 0, "LSFitSetCond: negative MaxIts!", _state);
   state->epsx = epsx;
   state->maxits = maxits;
}

// This function sets maximum step length
//
// Inputs:
//     State   -   structure which stores algorithm state
//     StpMax  -   maximum step length, >= 0. Set StpMax to 0.0,  if you don't
//                 want to limit step length.
//
// Use this subroutine when you optimize target function which contains exp()
// or  other  fast  growing  functions,  and optimization algorithm makes too
// large  steps  which  leads  to overflow. This function allows us to reject
// steps  that  are  too  large  (and  therefore  expose  us  to the possible
// overflow) without actually calculating function value at the x+stp*d.
//
// NOTE: non-zero StpMax leads to moderate  performance  degradation  because
// intermediate  step  of  preconditioned L-BFGS optimization is incompatible
// with limits on step size.
// ALGLIB: Copyright 02.04.2010 by Sergey Bochkanov
// API: void lsfitsetstpmax(const lsfitstate &state, const double stpmax, const xparams _xparams = xdefault);
void lsfitsetstpmax(lsfitstate *state, double stpmax, ae_state *_state) {
   ae_assert(stpmax >= 0.0, "LSFitSetStpMax: StpMax<0!", _state);
   state->stpmax = stpmax;
}

// This function turns on/off reporting.
//
// Inputs:
//     State   -   structure which stores algorithm state
//     NeedXRep-   whether iteration reports are needed or not
//
// When reports are needed, State.C (current parameters) and State.F (current
// value of fitting function) are reported.
// ALGLIB: Copyright 15.08.2010 by Sergey Bochkanov
// API: void lsfitsetxrep(const lsfitstate &state, const bool needxrep, const xparams _xparams = xdefault);
void lsfitsetxrep(lsfitstate *state, bool needxrep, ae_state *_state) {
   state->xrep = needxrep;
}

// This function sets scaling coefficients for underlying optimizer.
//
// ALGLIB optimizers use scaling matrices to test stopping  conditions  (step
// size and gradient are scaled before comparison with tolerances).  Scale of
// the I-th variable is a translation invariant measure of:
// a) "how large" the variable is
// b) how large the step should be to make significant changes in the function
//
// Generally, scale is NOT considered to be a form of preconditioner.  But LM
// optimizer is unique in that it uses scaling matrix both  in  the  stopping
// condition tests and as Marquardt damping factor.
//
// Proper scaling is very important for the algorithm performance. It is less
// important for the quality of results, but still has some influence (it  is
// easier  to  converge  when  variables  are  properly  scaled, so premature
// stopping is possible when very badly scalled variables are  combined  with
// relaxed stopping conditions).
//
// Inputs:
//     State   -   structure stores algorithm state
//     S       -   array[N], non-zero scaling coefficients
//                 S[i] may be negative, sign doesn't matter.
// ALGLIB: Copyright 14.01.2011 by Sergey Bochkanov
// API: void lsfitsetscale(const lsfitstate &state, const real_1d_array &s, const xparams _xparams = xdefault);
void lsfitsetscale(lsfitstate *state, RVector *s, ae_state *_state) {
   ae_int_t i;
   ae_assert(s->cnt >= state->k, "LSFitSetScale: Length(S)<K", _state);
   for (i = 0; i < state->k; i++) {
      ae_assert(ae_isfinite(s->xR[i], _state), "LSFitSetScale: S contains infinite or NAN elements", _state);
      ae_assert(s->xR[i] != 0.0, "LSFitSetScale: S contains infinite or NAN elements", _state);
      state->s.xR[i] = ae_fabs(s->xR[i], _state);
   }
}

// This function sets boundary constraints for underlying optimizer
//
// Boundary constraints are inactive by default (after initial creation).
// They are preserved until explicitly turned off with another SetBC() call.
//
// Inputs:
//     State   -   structure stores algorithm state
//     BndL    -   lower bounds, array[K].
//                 If some (all) variables are unbounded, you may specify
//                 very small number or -INF (latter is recommended because
//                 it will allow solver to use better algorithm).
//     BndU    -   upper bounds, array[K].
//                 If some (all) variables are unbounded, you may specify
//                 very large number or +INF (latter is recommended because
//                 it will allow solver to use better algorithm).
//
// NOTE 1: it is possible to specify BndL[i]=BndU[i]. In this case I-th
// variable will be "frozen" at X[i]=BndL[i]=BndU[i].
//
// NOTE 2: unlike other constrained optimization algorithms, this solver  has
// following useful properties:
// * bound constraints are always satisfied exactly
// * function is evaluated only INSIDE area specified by bound constraints
// ALGLIB: Copyright 14.01.2011 by Sergey Bochkanov
// API: void lsfitsetbc(const lsfitstate &state, const real_1d_array &bndl, const real_1d_array &bndu, const xparams _xparams = xdefault);
void lsfitsetbc(lsfitstate *state, RVector *bndl, RVector *bndu, ae_state *_state) {
   ae_int_t i;
   ae_int_t k;
   k = state->k;
   ae_assert(bndl->cnt >= k, "LSFitSetBC: Length(BndL)<K", _state);
   ae_assert(bndu->cnt >= k, "LSFitSetBC: Length(BndU)<K", _state);
   for (i = 0; i < k; i++) {
      ae_assert(ae_isfinite(bndl->xR[i], _state) || ae_isneginf(bndl->xR[i], _state), "LSFitSetBC: BndL contains NAN or +INF", _state);
      ae_assert(ae_isfinite(bndu->xR[i], _state) || ae_isposinf(bndu->xR[i], _state), "LSFitSetBC: BndU contains NAN or -INF", _state);
      if (ae_isfinite(bndl->xR[i], _state) && ae_isfinite(bndu->xR[i], _state)) {
         ae_assert(bndl->xR[i] <= bndu->xR[i], "LSFitSetBC: BndL[i]>BndU[i]", _state);
      }
      state->bndl.xR[i] = bndl->xR[i];
      state->bndu.xR[i] = bndu->xR[i];
   }
}

// This function sets linear constraints for underlying optimizer
//
// Linear constraints are inactive by default (after initial creation).
// They are preserved until explicitly turned off with another SetLC() call.
//
// Inputs:
//     State   -   structure stores algorithm state
//     C       -   linear constraints, array[K,N+1].
//                 Each row of C represents one constraint, either equality
//                 or inequality (see below):
//                 * first N elements correspond to coefficients,
//                 * last element corresponds to the right part.
//                 All elements of C (including right part) must be finite.
//     CT      -   type of constraints, array[K]:
//                 * if CT[i]>0, then I-th constraint is C[i,*]*x >= C[i,n+1]
//                 * if CT[i]=0, then I-th constraint is C[i,*]*x  = C[i,n+1]
//                 * if CT[i]<0, then I-th constraint is C[i,*]*x <= C[i,n+1]
//     K       -   number of equality/inequality constraints, K >= 0:
//                 * if given, only leading K elements of C/CT are used
//                 * if not given, automatically determined from sizes of C/CT
//
// IMPORTANT: if you have linear constraints, it is strongly  recommended  to
//            set scale of variables with lsfitsetscale(). QP solver which is
//            used to calculate linearly constrained steps heavily relies  on
//            good scaling of input problems.
//
// NOTE: linear  (non-box)  constraints  are  satisfied only approximately  -
//       there  always  exists some violation due  to  numerical  errors  and
//       algorithmic limitations.
//
// NOTE: general linear constraints  add  significant  overhead  to  solution
//       process. Although solver performs roughly same amount of  iterations
//       (when compared  with  similar  box-only  constrained  problem), each
//       iteration   now    involves  solution  of  linearly  constrained  QP
//       subproblem, which requires ~3-5 times more Cholesky  decompositions.
//       Thus, if you can reformulate your problem in such way  this  it  has
//       only box constraints, it may be beneficial to do so.
// ALGLIB: Copyright 29.04.2017 by Sergey Bochkanov
// API: void lsfitsetlc(const lsfitstate &state, const real_2d_array &c, const integer_1d_array &ct, const ae_int_t k, const xparams _xparams = xdefault);
// API: void lsfitsetlc(const lsfitstate &state, const real_2d_array &c, const integer_1d_array &ct, const xparams _xparams = xdefault);
void lsfitsetlc(lsfitstate *state, RMatrix *c, ZVector *ct, ae_int_t k, ae_state *_state) {
   ae_int_t i;
   ae_int_t n;
   n = state->k;
// First, check for errors in the inputs
   ae_assert(k >= 0, "LSFitSetLC: K<0", _state);
   ae_assert(c->cols >= n + 1 || k == 0, "LSFitSetLC: Cols(C)<N+1", _state);
   ae_assert(c->rows >= k, "LSFitSetLC: Rows(C)<K", _state);
   ae_assert(ct->cnt >= k, "LSFitSetLC: Length(CT)<K", _state);
   ae_assert(apservisfinitematrix(c, k, n + 1, _state), "LSFitSetLC: C contains infinite or NaN values!", _state);
// Handle zero K
   if (k == 0) {
      state->nec = 0;
      state->nic = 0;
      return;
   }
// Equality constraints are stored first, in the upper
// NEC rows of State.CLEIC matrix. Inequality constraints
// are stored in the next NIC rows.
//
// NOTE: we convert inequality constraints to the form
// A*x <= b before copying them.
   rmatrixsetlengthatleast(&state->cleic, k, n + 1, _state);
   state->nec = 0;
   state->nic = 0;
   for (i = 0; i < k; i++) {
      if (ct->xZ[i] == 0) {
         ae_v_move(state->cleic.xyR[state->nec], 1, c->xyR[i], 1, n + 1);
         state->nec++;
      }
   }
   for (i = 0; i < k; i++) {
      if (ct->xZ[i] != 0) {
         if (ct->xZ[i] > 0) {
            ae_v_moveneg(state->cleic.xyR[state->nec + state->nic], 1, c->xyR[i], 1, n + 1);
         } else {
            ae_v_move(state->cleic.xyR[state->nec + state->nic], 1, c->xyR[i], 1, n + 1);
         }
         state->nic++;
      }
   }
}

// This  subroutine  turns  on  verification  of  the  user-supplied analytic
// gradient:
// * user calls this subroutine before fitting begins
// * LSFitFit() is called
// * prior to actual fitting, for  each  point  in  data  set  X_i  and  each
//   component  of  parameters  being  fited C_j algorithm performs following
//   steps:
//   * two trial steps are made to C_j-TestStep*S[j] and C_j+TestStep*S[j],
//     where C_j is j-th parameter and S[j] is a scale of j-th parameter
//   * if needed, steps are bounded with respect to constraints on C[]
//   * F(X_i|C) is evaluated at these trial points
//   * we perform one more evaluation in the middle point of the interval
//   * we  build  cubic  model using function values and derivatives at trial
//     points and we compare its prediction with actual value in  the  middle
//     point
//   * in case difference between prediction and actual value is higher  than
//     some predetermined threshold, algorithm stops with completion code -7;
//     Rep.VarIdx is set to index of the parameter with incorrect derivative.
// * after verification is over, algorithm proceeds to the actual optimization.
//
// NOTE 1: verification needs N*K (points count * parameters count)  gradient
//         evaluations. It is very costly and you should use it only for  low
//         dimensional  problems,  when  you  want  to  be  sure  that you've
//         correctly calculated analytic derivatives. You should not  use  it
//         in the production code  (unless  you  want  to  check  derivatives
//         provided by some third party).
//
// NOTE 2: you  should  carefully  choose  TestStep. Value which is too large
//         (so large that function behaviour is significantly non-cubic) will
//         lead to false alarms. You may use  different  step  for  different
//         parameters by means of setting scale with LSFitSetScale().
//
// NOTE 3: this function may lead to false positives. In case it reports that
//         I-th  derivative was calculated incorrectly, you may decrease test
//         step  and  try  one  more  time  - maybe your function changes too
//         sharply  and  your  step  is  too  large for such rapidly chanding
//         function.
//
// NOTE 4: this function works only for optimizers created with LSFitCreateWFG()
//         or LSFitCreateFG() constructors.
//
// Inputs:
//     State       -   structure used to store algorithm state
//     TestStep    -   verification step:
//                     * TestStep=0 turns verification off
//                     * TestStep>0 activates verification
// ALGLIB: Copyright 15.06.2012 by Sergey Bochkanov
// API: void lsfitsetgradientcheck(const lsfitstate &state, const double teststep, const xparams _xparams = xdefault);
void lsfitsetgradientcheck(lsfitstate *state, double teststep, ae_state *_state) {
   ae_assert(ae_isfinite(teststep, _state), "LSFitSetGradientCheck: TestStep contains NaN or Infinite", _state);
   ae_assert(teststep >= 0.0, "LSFitSetGradientCheck: invalid argument TestStep(TestStep<0)", _state);
   state->teststep = teststep;
}

// Internal subroutine
static void lsfit_lsfitclearrequestfields(lsfitstate *state, ae_state *_state) {
   state->needf = false;
   state->needfg = false;
   state->needfgh = false;
   state->xupdated = false;
}

// Weighted nonlinear least squares fitting using function values only.
//
// Combination of numerical differentiation and secant updates is used to
// obtain function Jacobian.
//
// Nonlinear task min(F(c)) is solved, where
//
//     F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,
//
//     * N is a number of points,
//     * M is a dimension of a space points belong to,
//     * K is a dimension of a space of parameters being fitted,
//     * w is an N-dimensional vector of weight coefficients,
//     * x is a set of N points, each of them is an M-dimensional vector,
//     * c is a K-dimensional vector of parameters being fitted
//
// This subroutine uses only f(c,x[i]).
//
// Inputs:
//     X       -   array[0..N-1,0..M-1], points (one row = one point)
//     Y       -   array[0..N-1], function values.
//     W       -   weights, array[0..N-1]
//     C       -   array[0..K-1], initial approximation to the solution,
//     N       -   number of points, N>1
//     M       -   dimension of space
//     K       -   number of parameters being fitted
//     DiffStep-   numerical differentiation step;
//                 should not be very small or large;
//                 large = loss of accuracy
//                 small = growth of round-off errors
//
// Outputs:
//     State   -   structure which stores algorithm state
// ALGLIB: Copyright 18.10.2008 by Sergey Bochkanov
// API: void lsfitcreatewf(const real_2d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &c, const ae_int_t n, const ae_int_t m, const ae_int_t k, const double diffstep, lsfitstate &state, const xparams _xparams = xdefault);
// API: void lsfitcreatewf(const real_2d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &c, const double diffstep, lsfitstate &state, const xparams _xparams = xdefault);
void lsfitcreatewf(RMatrix *x, RVector *y, RVector *w, RVector *c, ae_int_t n, ae_int_t m, ae_int_t k, double diffstep, lsfitstate *state, ae_state *_state) {
   ae_int_t i;
   SetObj(lsfitstate, state);
   ae_assert(n >= 1, "LSFitCreateWF: N<1!", _state);
   ae_assert(m >= 1, "LSFitCreateWF: M<1!", _state);
   ae_assert(k >= 1, "LSFitCreateWF: K<1!", _state);
   ae_assert(c->cnt >= k, "LSFitCreateWF: length(C)<K!", _state);
   ae_assert(isfinitevector(c, k, _state), "LSFitCreateWF: C contains infinite or NaN values!", _state);
   ae_assert(y->cnt >= n, "LSFitCreateWF: length(Y)<N!", _state);
   ae_assert(isfinitevector(y, n, _state), "LSFitCreateWF: Y contains infinite or NaN values!", _state);
   ae_assert(w->cnt >= n, "LSFitCreateWF: length(W)<N!", _state);
   ae_assert(isfinitevector(w, n, _state), "LSFitCreateWF: W contains infinite or NaN values!", _state);
   ae_assert(x->rows >= n, "LSFitCreateWF: rows(X)<N!", _state);
   ae_assert(x->cols >= m, "LSFitCreateWF: cols(X)<M!", _state);
   ae_assert(apservisfinitematrix(x, n, m, _state), "LSFitCreateWF: X contains infinite or NaN values!", _state);
   ae_assert(ae_isfinite(diffstep, _state), "LSFitCreateWF: DiffStep is not finite!", _state);
   ae_assert(diffstep > 0.0, "LSFitCreateWF: DiffStep <= 0!", _state);
   state->teststep = 0.0;
   state->diffstep = diffstep;
   state->npoints = n;
   state->nweights = n;
   state->wkind = 1;
   state->m = m;
   state->k = k;
   lsfitsetcond(state, 0.0, 0, _state);
   lsfitsetstpmax(state, 0.0, _state);
   lsfitsetxrep(state, false, _state);
   ae_matrix_set_length(&state->taskx, n, m, _state);
   ae_vector_set_length(&state->tasky, n, _state);
   ae_vector_set_length(&state->taskw, n, _state);
   ae_vector_set_length(&state->c, k, _state);
   ae_vector_set_length(&state->c0, k, _state);
   ae_vector_set_length(&state->c1, k, _state);
   ae_v_move(state->c0.xR, 1, c->xR, 1, k);
   ae_v_move(state->c1.xR, 1, c->xR, 1, k);
   ae_vector_set_length(&state->x, m, _state);
   ae_v_move(state->taskw.xR, 1, w->xR, 1, n);
   for (i = 0; i < n; i++) {
      ae_v_move(state->taskx.xyR[i], 1, x->xyR[i], 1, m);
      state->tasky.xR[i] = y->xR[i];
   }
   ae_vector_set_length(&state->s, k, _state);
   ae_vector_set_length(&state->bndl, k, _state);
   ae_vector_set_length(&state->bndu, k, _state);
   for (i = 0; i < k; i++) {
      state->s.xR[i] = 1.0;
      state->bndl.xR[i] = _state->v_neginf;
      state->bndu.xR[i] = _state->v_posinf;
   }
   state->optalgo = 0;
   state->prevnpt = -1;
   state->prevalgo = -1;
   state->nec = 0;
   state->nic = 0;
   minlmcreatev(k, n, &state->c0, diffstep, &state->optstate, _state);
   lsfit_lsfitclearrequestfields(state, _state);
   ae_vector_set_length(&state->rstate.ia, 6 + 1, _state);
   ae_vector_set_length(&state->rstate.ra, 8 + 1, _state);
   state->rstate.stage = -1;
}

// Nonlinear least squares fitting using function values only.
//
// Combination of numerical differentiation and secant updates is used to
// obtain function Jacobian.
//
// Nonlinear task min(F(c)) is solved, where
//
//     F(c) = (f(c,x[0])-y[0])^2 + ... + (f(c,x[n-1])-y[n-1])^2,
//
//     * N is a number of points,
//     * M is a dimension of a space points belong to,
//     * K is a dimension of a space of parameters being fitted,
//     * w is an N-dimensional vector of weight coefficients,
//     * x is a set of N points, each of them is an M-dimensional vector,
//     * c is a K-dimensional vector of parameters being fitted
//
// This subroutine uses only f(c,x[i]).
//
// Inputs:
//     X       -   array[0..N-1,0..M-1], points (one row = one point)
//     Y       -   array[0..N-1], function values.
//     C       -   array[0..K-1], initial approximation to the solution,
//     N       -   number of points, N>1
//     M       -   dimension of space
//     K       -   number of parameters being fitted
//     DiffStep-   numerical differentiation step;
//                 should not be very small or large;
//                 large = loss of accuracy
//                 small = growth of round-off errors
//
// Outputs:
//     State   -   structure which stores algorithm state
// ALGLIB: Copyright 18.10.2008 by Sergey Bochkanov
// API: void lsfitcreatef(const real_2d_array &x, const real_1d_array &y, const real_1d_array &c, const ae_int_t n, const ae_int_t m, const ae_int_t k, const double diffstep, lsfitstate &state, const xparams _xparams = xdefault);
// API: void lsfitcreatef(const real_2d_array &x, const real_1d_array &y, const real_1d_array &c, const double diffstep, lsfitstate &state, const xparams _xparams = xdefault);
void lsfitcreatef(RMatrix *x, RVector *y, RVector *c, ae_int_t n, ae_int_t m, ae_int_t k, double diffstep, lsfitstate *state, ae_state *_state) {
   ae_int_t i;
   SetObj(lsfitstate, state);
   ae_assert(n >= 1, "LSFitCreateF: N<1!", _state);
   ae_assert(m >= 1, "LSFitCreateF: M<1!", _state);
   ae_assert(k >= 1, "LSFitCreateF: K<1!", _state);
   ae_assert(c->cnt >= k, "LSFitCreateF: length(C)<K!", _state);
   ae_assert(isfinitevector(c, k, _state), "LSFitCreateF: C contains infinite or NaN values!", _state);
   ae_assert(y->cnt >= n, "LSFitCreateF: length(Y)<N!", _state);
   ae_assert(isfinitevector(y, n, _state), "LSFitCreateF: Y contains infinite or NaN values!", _state);
   ae_assert(x->rows >= n, "LSFitCreateF: rows(X)<N!", _state);
   ae_assert(x->cols >= m, "LSFitCreateF: cols(X)<M!", _state);
   ae_assert(apservisfinitematrix(x, n, m, _state), "LSFitCreateF: X contains infinite or NaN values!", _state);
   ae_assert(x->rows >= n, "LSFitCreateF: rows(X)<N!", _state);
   ae_assert(x->cols >= m, "LSFitCreateF: cols(X)<M!", _state);
   ae_assert(apservisfinitematrix(x, n, m, _state), "LSFitCreateF: X contains infinite or NaN values!", _state);
   ae_assert(ae_isfinite(diffstep, _state), "LSFitCreateF: DiffStep is not finite!", _state);
   ae_assert(diffstep > 0.0, "LSFitCreateF: DiffStep <= 0!", _state);
   state->teststep = 0.0;
   state->diffstep = diffstep;
   state->npoints = n;
   state->wkind = 0;
   state->m = m;
   state->k = k;
   lsfitsetcond(state, 0.0, 0, _state);
   lsfitsetstpmax(state, 0.0, _state);
   lsfitsetxrep(state, false, _state);
   ae_matrix_set_length(&state->taskx, n, m, _state);
   ae_vector_set_length(&state->tasky, n, _state);
   ae_vector_set_length(&state->c, k, _state);
   ae_vector_set_length(&state->c0, k, _state);
   ae_vector_set_length(&state->c1, k, _state);
   ae_v_move(state->c0.xR, 1, c->xR, 1, k);
   ae_v_move(state->c1.xR, 1, c->xR, 1, k);
   ae_vector_set_length(&state->x, m, _state);
   for (i = 0; i < n; i++) {
      ae_v_move(state->taskx.xyR[i], 1, x->xyR[i], 1, m);
      state->tasky.xR[i] = y->xR[i];
   }
   ae_vector_set_length(&state->s, k, _state);
   ae_vector_set_length(&state->bndl, k, _state);
   ae_vector_set_length(&state->bndu, k, _state);
   for (i = 0; i < k; i++) {
      state->s.xR[i] = 1.0;
      state->bndl.xR[i] = _state->v_neginf;
      state->bndu.xR[i] = _state->v_posinf;
   }
   state->optalgo = 0;
   state->prevnpt = -1;
   state->prevalgo = -1;
   state->nec = 0;
   state->nic = 0;
   minlmcreatev(k, n, &state->c0, diffstep, &state->optstate, _state);
   lsfit_lsfitclearrequestfields(state, _state);
   ae_vector_set_length(&state->rstate.ia, 6 + 1, _state);
   ae_vector_set_length(&state->rstate.ra, 8 + 1, _state);
   state->rstate.stage = -1;
}

// Weighted nonlinear least squares fitting using gradient only.
//
// Nonlinear task min(F(c)) is solved, where
//
//     F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,
//
//     * N is a number of points,
//     * M is a dimension of a space points belong to,
//     * K is a dimension of a space of parameters being fitted,
//     * w is an N-dimensional vector of weight coefficients,
//     * x is a set of N points, each of them is an M-dimensional vector,
//     * c is a K-dimensional vector of parameters being fitted
//
// This subroutine uses only f(c,x[i]) and its gradient.
//
// Inputs:
//     X       -   array[0..N-1,0..M-1], points (one row = one point)
//     Y       -   array[0..N-1], function values.
//     W       -   weights, array[0..N-1]
//     C       -   array[0..K-1], initial approximation to the solution,
//     N       -   number of points, N>1
//     M       -   dimension of space
//     K       -   number of parameters being fitted
//     CheapFG -   boolean flag, which is:
//                 * True  if both function and gradient calculation complexity
//                         are less than O(M^2).  An improved  algorithm  can
//                         be  used  which corresponds  to  FGJ  scheme  from
//                         MINLM unit.
//                 * False otherwise.
//                         Standard Jacibian-bases  Levenberg-Marquardt  algo
//                         will be used (FJ scheme).
//
// Outputs:
//     State   -   structure which stores algorithm state
//
// See also:
//     LSFitResults
//     LSFitCreateFG (fitting without weights)
//     LSFitCreateWFGH (fitting using Hessian)
//     LSFitCreateFGH (fitting using Hessian, without weights)
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
// API: void lsfitcreatewfg(const real_2d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &c, const ae_int_t n, const ae_int_t m, const ae_int_t k, const bool cheapfg, lsfitstate &state, const xparams _xparams = xdefault);
// API: void lsfitcreatewfg(const real_2d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &c, const bool cheapfg, lsfitstate &state, const xparams _xparams = xdefault);
void lsfitcreatewfg(RMatrix *x, RVector *y, RVector *w, RVector *c, ae_int_t n, ae_int_t m, ae_int_t k, bool cheapfg, lsfitstate *state, ae_state *_state) {
   ae_int_t i;
   SetObj(lsfitstate, state);
   ae_assert(n >= 1, "LSFitCreateWFG: N<1!", _state);
   ae_assert(m >= 1, "LSFitCreateWFG: M<1!", _state);
   ae_assert(k >= 1, "LSFitCreateWFG: K<1!", _state);
   ae_assert(c->cnt >= k, "LSFitCreateWFG: length(C)<K!", _state);
   ae_assert(isfinitevector(c, k, _state), "LSFitCreateWFG: C contains infinite or NaN values!", _state);
   ae_assert(y->cnt >= n, "LSFitCreateWFG: length(Y)<N!", _state);
   ae_assert(isfinitevector(y, n, _state), "LSFitCreateWFG: Y contains infinite or NaN values!", _state);
   ae_assert(w->cnt >= n, "LSFitCreateWFG: length(W)<N!", _state);
   ae_assert(isfinitevector(w, n, _state), "LSFitCreateWFG: W contains infinite or NaN values!", _state);
   ae_assert(x->rows >= n, "LSFitCreateWFG: rows(X)<N!", _state);
   ae_assert(x->cols >= m, "LSFitCreateWFG: cols(X)<M!", _state);
   ae_assert(apservisfinitematrix(x, n, m, _state), "LSFitCreateWFG: X contains infinite or NaN values!", _state);
   state->teststep = 0.0;
   state->diffstep = 0.0;
   state->npoints = n;
   state->nweights = n;
   state->wkind = 1;
   state->m = m;
   state->k = k;
   lsfitsetcond(state, 0.0, 0, _state);
   lsfitsetstpmax(state, 0.0, _state);
   lsfitsetxrep(state, false, _state);
   ae_matrix_set_length(&state->taskx, n, m, _state);
   ae_vector_set_length(&state->tasky, n, _state);
   ae_vector_set_length(&state->taskw, n, _state);
   ae_vector_set_length(&state->c, k, _state);
   ae_vector_set_length(&state->c0, k, _state);
   ae_vector_set_length(&state->c1, k, _state);
   ae_v_move(state->c0.xR, 1, c->xR, 1, k);
   ae_v_move(state->c1.xR, 1, c->xR, 1, k);
   ae_vector_set_length(&state->x, m, _state);
   ae_vector_set_length(&state->g, k, _state);
   ae_v_move(state->taskw.xR, 1, w->xR, 1, n);
   for (i = 0; i < n; i++) {
      ae_v_move(state->taskx.xyR[i], 1, x->xyR[i], 1, m);
      state->tasky.xR[i] = y->xR[i];
   }
   ae_vector_set_length(&state->s, k, _state);
   ae_vector_set_length(&state->bndl, k, _state);
   ae_vector_set_length(&state->bndu, k, _state);
   for (i = 0; i < k; i++) {
      state->s.xR[i] = 1.0;
      state->bndl.xR[i] = _state->v_neginf;
      state->bndu.xR[i] = _state->v_posinf;
   }
   state->optalgo = 1;
   state->prevnpt = -1;
   state->prevalgo = -1;
   state->nec = 0;
   state->nic = 0;
   if (cheapfg) {
      minlmcreatevgj(k, n, &state->c0, &state->optstate, _state);
   } else {
      minlmcreatevj(k, n, &state->c0, &state->optstate, _state);
   }
   lsfit_lsfitclearrequestfields(state, _state);
   ae_vector_set_length(&state->rstate.ia, 6 + 1, _state);
   ae_vector_set_length(&state->rstate.ra, 8 + 1, _state);
   state->rstate.stage = -1;
}

// Nonlinear least squares fitting using gradient only, without individual
// weights.
//
// Nonlinear task min(F(c)) is solved, where
//
//     F(c) = ((f(c,x[0])-y[0]))^2 + ... + ((f(c,x[n-1])-y[n-1]))^2,
//
//     * N is a number of points,
//     * M is a dimension of a space points belong to,
//     * K is a dimension of a space of parameters being fitted,
//     * x is a set of N points, each of them is an M-dimensional vector,
//     * c is a K-dimensional vector of parameters being fitted
//
// This subroutine uses only f(c,x[i]) and its gradient.
//
// Inputs:
//     X       -   array[0..N-1,0..M-1], points (one row = one point)
//     Y       -   array[0..N-1], function values.
//     C       -   array[0..K-1], initial approximation to the solution,
//     N       -   number of points, N>1
//     M       -   dimension of space
//     K       -   number of parameters being fitted
//     CheapFG -   boolean flag, which is:
//                 * True  if both function and gradient calculation complexity
//                         are less than O(M^2).  An improved  algorithm  can
//                         be  used  which corresponds  to  FGJ  scheme  from
//                         MINLM unit.
//                 * False otherwise.
//                         Standard Jacibian-bases  Levenberg-Marquardt  algo
//                         will be used (FJ scheme).
//
// Outputs:
//     State   -   structure which stores algorithm state
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
// API: void lsfitcreatefg(const real_2d_array &x, const real_1d_array &y, const real_1d_array &c, const ae_int_t n, const ae_int_t m, const ae_int_t k, const bool cheapfg, lsfitstate &state, const xparams _xparams = xdefault);
// API: void lsfitcreatefg(const real_2d_array &x, const real_1d_array &y, const real_1d_array &c, const bool cheapfg, lsfitstate &state, const xparams _xparams = xdefault);
void lsfitcreatefg(RMatrix *x, RVector *y, RVector *c, ae_int_t n, ae_int_t m, ae_int_t k, bool cheapfg, lsfitstate *state, ae_state *_state) {
   ae_int_t i;
   SetObj(lsfitstate, state);
   ae_assert(n >= 1, "LSFitCreateFG: N<1!", _state);
   ae_assert(m >= 1, "LSFitCreateFG: M<1!", _state);
   ae_assert(k >= 1, "LSFitCreateFG: K<1!", _state);
   ae_assert(c->cnt >= k, "LSFitCreateFG: length(C)<K!", _state);
   ae_assert(isfinitevector(c, k, _state), "LSFitCreateFG: C contains infinite or NaN values!", _state);
   ae_assert(y->cnt >= n, "LSFitCreateFG: length(Y)<N!", _state);
   ae_assert(isfinitevector(y, n, _state), "LSFitCreateFG: Y contains infinite or NaN values!", _state);
   ae_assert(x->rows >= n, "LSFitCreateFG: rows(X)<N!", _state);
   ae_assert(x->cols >= m, "LSFitCreateFG: cols(X)<M!", _state);
   ae_assert(apservisfinitematrix(x, n, m, _state), "LSFitCreateFG: X contains infinite or NaN values!", _state);
   ae_assert(x->rows >= n, "LSFitCreateFG: rows(X)<N!", _state);
   ae_assert(x->cols >= m, "LSFitCreateFG: cols(X)<M!", _state);
   ae_assert(apservisfinitematrix(x, n, m, _state), "LSFitCreateFG: X contains infinite or NaN values!", _state);
   state->teststep = 0.0;
   state->diffstep = 0.0;
   state->npoints = n;
   state->wkind = 0;
   state->m = m;
   state->k = k;
   lsfitsetcond(state, 0.0, 0, _state);
   lsfitsetstpmax(state, 0.0, _state);
   lsfitsetxrep(state, false, _state);
   ae_matrix_set_length(&state->taskx, n, m, _state);
   ae_vector_set_length(&state->tasky, n, _state);
   ae_vector_set_length(&state->c, k, _state);
   ae_vector_set_length(&state->c0, k, _state);
   ae_vector_set_length(&state->c1, k, _state);
   ae_v_move(state->c0.xR, 1, c->xR, 1, k);
   ae_v_move(state->c1.xR, 1, c->xR, 1, k);
   ae_vector_set_length(&state->x, m, _state);
   ae_vector_set_length(&state->g, k, _state);
   for (i = 0; i < n; i++) {
      ae_v_move(state->taskx.xyR[i], 1, x->xyR[i], 1, m);
      state->tasky.xR[i] = y->xR[i];
   }
   ae_vector_set_length(&state->s, k, _state);
   ae_vector_set_length(&state->bndl, k, _state);
   ae_vector_set_length(&state->bndu, k, _state);
   for (i = 0; i < k; i++) {
      state->s.xR[i] = 1.0;
      state->bndl.xR[i] = _state->v_neginf;
      state->bndu.xR[i] = _state->v_posinf;
   }
   state->optalgo = 1;
   state->prevnpt = -1;
   state->prevalgo = -1;
   state->nec = 0;
   state->nic = 0;
   if (cheapfg) {
      minlmcreatevgj(k, n, &state->c0, &state->optstate, _state);
   } else {
      minlmcreatevj(k, n, &state->c0, &state->optstate, _state);
   }
   lsfit_lsfitclearrequestfields(state, _state);
   ae_vector_set_length(&state->rstate.ia, 6 + 1, _state);
   ae_vector_set_length(&state->rstate.ra, 8 + 1, _state);
   state->rstate.stage = -1;
}

// Weighted nonlinear least squares fitting using gradient/Hessian.
//
// Nonlinear task min(F(c)) is solved, where
//
//     F(c) = (w[0]*(f(c,x[0])-y[0]))^2 + ... + (w[n-1]*(f(c,x[n-1])-y[n-1]))^2,
//
//     * N is a number of points,
//     * M is a dimension of a space points belong to,
//     * K is a dimension of a space of parameters being fitted,
//     * w is an N-dimensional vector of weight coefficients,
//     * x is a set of N points, each of them is an M-dimensional vector,
//     * c is a K-dimensional vector of parameters being fitted
//
// This subroutine uses f(c,x[i]), its gradient and its Hessian.
//
// Inputs:
//     X       -   array[0..N-1,0..M-1], points (one row = one point)
//     Y       -   array[0..N-1], function values.
//     W       -   weights, array[0..N-1]
//     C       -   array[0..K-1], initial approximation to the solution,
//     N       -   number of points, N>1
//     M       -   dimension of space
//     K       -   number of parameters being fitted
//
// Outputs:
//     State   -   structure which stores algorithm state
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
// API: void lsfitcreatewfgh(const real_2d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &c, const ae_int_t n, const ae_int_t m, const ae_int_t k, lsfitstate &state, const xparams _xparams = xdefault);
// API: void lsfitcreatewfgh(const real_2d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &c, lsfitstate &state, const xparams _xparams = xdefault);
void lsfitcreatewfgh(RMatrix *x, RVector *y, RVector *w, RVector *c, ae_int_t n, ae_int_t m, ae_int_t k, lsfitstate *state, ae_state *_state) {
   ae_int_t i;
   SetObj(lsfitstate, state);
   ae_assert(n >= 1, "LSFitCreateWFGH: N<1!", _state);
   ae_assert(m >= 1, "LSFitCreateWFGH: M<1!", _state);
   ae_assert(k >= 1, "LSFitCreateWFGH: K<1!", _state);
   ae_assert(c->cnt >= k, "LSFitCreateWFGH: length(C)<K!", _state);
   ae_assert(isfinitevector(c, k, _state), "LSFitCreateWFGH: C contains infinite or NaN values!", _state);
   ae_assert(y->cnt >= n, "LSFitCreateWFGH: length(Y)<N!", _state);
   ae_assert(isfinitevector(y, n, _state), "LSFitCreateWFGH: Y contains infinite or NaN values!", _state);
   ae_assert(w->cnt >= n, "LSFitCreateWFGH: length(W)<N!", _state);
   ae_assert(isfinitevector(w, n, _state), "LSFitCreateWFGH: W contains infinite or NaN values!", _state);
   ae_assert(x->rows >= n, "LSFitCreateWFGH: rows(X)<N!", _state);
   ae_assert(x->cols >= m, "LSFitCreateWFGH: cols(X)<M!", _state);
   ae_assert(apservisfinitematrix(x, n, m, _state), "LSFitCreateWFGH: X contains infinite or NaN values!", _state);
   state->teststep = 0.0;
   state->diffstep = 0.0;
   state->npoints = n;
   state->nweights = n;
   state->wkind = 1;
   state->m = m;
   state->k = k;
   lsfitsetcond(state, 0.0, 0, _state);
   lsfitsetstpmax(state, 0.0, _state);
   lsfitsetxrep(state, false, _state);
   ae_matrix_set_length(&state->taskx, n, m, _state);
   ae_vector_set_length(&state->tasky, n, _state);
   ae_vector_set_length(&state->taskw, n, _state);
   ae_vector_set_length(&state->c, k, _state);
   ae_vector_set_length(&state->c0, k, _state);
   ae_vector_set_length(&state->c1, k, _state);
   ae_v_move(state->c0.xR, 1, c->xR, 1, k);
   ae_v_move(state->c1.xR, 1, c->xR, 1, k);
   ae_matrix_set_length(&state->h, k, k, _state);
   ae_vector_set_length(&state->x, m, _state);
   ae_vector_set_length(&state->g, k, _state);
   ae_v_move(state->taskw.xR, 1, w->xR, 1, n);
   for (i = 0; i < n; i++) {
      ae_v_move(state->taskx.xyR[i], 1, x->xyR[i], 1, m);
      state->tasky.xR[i] = y->xR[i];
   }
   ae_vector_set_length(&state->s, k, _state);
   ae_vector_set_length(&state->bndl, k, _state);
   ae_vector_set_length(&state->bndu, k, _state);
   for (i = 0; i < k; i++) {
      state->s.xR[i] = 1.0;
      state->bndl.xR[i] = _state->v_neginf;
      state->bndu.xR[i] = _state->v_posinf;
   }
   state->optalgo = 2;
   state->prevnpt = -1;
   state->prevalgo = -1;
   state->nec = 0;
   state->nic = 0;
   minlmcreatefgh(k, &state->c0, &state->optstate, _state);
   lsfit_lsfitclearrequestfields(state, _state);
   ae_vector_set_length(&state->rstate.ia, 6 + 1, _state);
   ae_vector_set_length(&state->rstate.ra, 8 + 1, _state);
   state->rstate.stage = -1;
}

// Nonlinear least squares fitting using gradient/Hessian, without individial
// weights.
//
// Nonlinear task min(F(c)) is solved, where
//
//     F(c) = ((f(c,x[0])-y[0]))^2 + ... + ((f(c,x[n-1])-y[n-1]))^2,
//
//     * N is a number of points,
//     * M is a dimension of a space points belong to,
//     * K is a dimension of a space of parameters being fitted,
//     * x is a set of N points, each of them is an M-dimensional vector,
//     * c is a K-dimensional vector of parameters being fitted
//
// This subroutine uses f(c,x[i]), its gradient and its Hessian.
//
// Inputs:
//     X       -   array[0..N-1,0..M-1], points (one row = one point)
//     Y       -   array[0..N-1], function values.
//     C       -   array[0..K-1], initial approximation to the solution,
//     N       -   number of points, N>1
//     M       -   dimension of space
//     K       -   number of parameters being fitted
//
// Outputs:
//     State   -   structure which stores algorithm state
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
// API: void lsfitcreatefgh(const real_2d_array &x, const real_1d_array &y, const real_1d_array &c, const ae_int_t n, const ae_int_t m, const ae_int_t k, lsfitstate &state, const xparams _xparams = xdefault);
// API: void lsfitcreatefgh(const real_2d_array &x, const real_1d_array &y, const real_1d_array &c, lsfitstate &state, const xparams _xparams = xdefault);
void lsfitcreatefgh(RMatrix *x, RVector *y, RVector *c, ae_int_t n, ae_int_t m, ae_int_t k, lsfitstate *state, ae_state *_state) {
   ae_int_t i;
   SetObj(lsfitstate, state);
   ae_assert(n >= 1, "LSFitCreateFGH: N<1!", _state);
   ae_assert(m >= 1, "LSFitCreateFGH: M<1!", _state);
   ae_assert(k >= 1, "LSFitCreateFGH: K<1!", _state);
   ae_assert(c->cnt >= k, "LSFitCreateFGH: length(C)<K!", _state);
   ae_assert(isfinitevector(c, k, _state), "LSFitCreateFGH: C contains infinite or NaN values!", _state);
   ae_assert(y->cnt >= n, "LSFitCreateFGH: length(Y)<N!", _state);
   ae_assert(isfinitevector(y, n, _state), "LSFitCreateFGH: Y contains infinite or NaN values!", _state);
   ae_assert(x->rows >= n, "LSFitCreateFGH: rows(X)<N!", _state);
   ae_assert(x->cols >= m, "LSFitCreateFGH: cols(X)<M!", _state);
   ae_assert(apservisfinitematrix(x, n, m, _state), "LSFitCreateFGH: X contains infinite or NaN values!", _state);
   state->teststep = 0.0;
   state->diffstep = 0.0;
   state->npoints = n;
   state->wkind = 0;
   state->m = m;
   state->k = k;
   lsfitsetcond(state, 0.0, 0, _state);
   lsfitsetstpmax(state, 0.0, _state);
   lsfitsetxrep(state, false, _state);
   ae_matrix_set_length(&state->taskx, n, m, _state);
   ae_vector_set_length(&state->tasky, n, _state);
   ae_vector_set_length(&state->c, k, _state);
   ae_vector_set_length(&state->c0, k, _state);
   ae_vector_set_length(&state->c1, k, _state);
   ae_v_move(state->c0.xR, 1, c->xR, 1, k);
   ae_v_move(state->c1.xR, 1, c->xR, 1, k);
   ae_matrix_set_length(&state->h, k, k, _state);
   ae_vector_set_length(&state->x, m, _state);
   ae_vector_set_length(&state->g, k, _state);
   for (i = 0; i < n; i++) {
      ae_v_move(state->taskx.xyR[i], 1, x->xyR[i], 1, m);
      state->tasky.xR[i] = y->xR[i];
   }
   ae_vector_set_length(&state->s, k, _state);
   ae_vector_set_length(&state->bndl, k, _state);
   ae_vector_set_length(&state->bndu, k, _state);
   for (i = 0; i < k; i++) {
      state->s.xR[i] = 1.0;
      state->bndl.xR[i] = _state->v_neginf;
      state->bndu.xR[i] = _state->v_posinf;
   }
   state->optalgo = 2;
   state->prevnpt = -1;
   state->prevalgo = -1;
   state->nec = 0;
   state->nic = 0;
   minlmcreatefgh(k, &state->c0, &state->optstate, _state);
   lsfit_lsfitclearrequestfields(state, _state);
   ae_vector_set_length(&state->rstate.ia, 6 + 1, _state);
   ae_vector_set_length(&state->rstate.ra, 8 + 1, _state);
   state->rstate.stage = -1;
}

// This function provides a reverse communication interface, which is not documented or recommended for use.
// Instead, it is recommended that you use the better-documented API functions lsfititeration() listed below.
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
// API: bool lsfititeration(const lsfitstate &state, const xparams _xparams = xdefault);
// API: void lsfitfit(lsfitstate &state, void (*func)(const real_1d_array &c, const real_1d_array &x, double &func, void *ptr), void (*rep)(const real_1d_array &c, double func, void *ptr) = NULL, void *ptr = NULL, const xparams _xparams = xdefault);
// API: void lsfitfit(lsfitstate &state, void (*func)(const real_1d_array &c, const real_1d_array &x, double &func, void *ptr), void (*grad)(const real_1d_array &c, const real_1d_array &x, double &func, real_1d_array &grad, void *ptr), void (*rep)(const real_1d_array &c, double func, void *ptr) = NULL, void *ptr = NULL, const xparams _xparams = xdefault);
// API: void lsfitfit(lsfitstate &state, void (*func)(const real_1d_array &c, const real_1d_array &x, double &func, void *ptr), void (*grad)(const real_1d_array &c, const real_1d_array &x, double &func, real_1d_array &grad, void *ptr), void (*hess)(const real_1d_array &c, const real_1d_array &x, double &func, real_1d_array &grad, real_2d_array &hess, void *ptr), void (*rep)(const real_1d_array &c, double func, void *ptr) = NULL, void *ptr = NULL, const xparams _xparams = xdefault);
bool lsfititeration(lsfitstate *state, ae_state *_state) {
   double lx;
   double lf;
   double ld;
   double rx;
   double rf;
   double rd;
   ae_int_t n;
   ae_int_t m;
   ae_int_t k;
   double v;
   double vv;
   double relcnt;
   ae_int_t i;
   ae_int_t j;
   ae_int_t j1;
   ae_int_t info;
   bool result;
// Reverse communication preparations
// I know it looks ugly, but it works the same way
// anywhere from C++ to Python.
//
// This code initializes locals by:
// * random values determined during code
//   generation - on first subroutine call
// * values from previous call - on subsequent calls
   if (state->rstate.stage >= 0) {
      n = state->rstate.ia.xZ[0];
      m = state->rstate.ia.xZ[1];
      k = state->rstate.ia.xZ[2];
      i = state->rstate.ia.xZ[3];
      j = state->rstate.ia.xZ[4];
      j1 = state->rstate.ia.xZ[5];
      info = state->rstate.ia.xZ[6];
      lx = state->rstate.ra.xR[0];
      lf = state->rstate.ra.xR[1];
      ld = state->rstate.ra.xR[2];
      rx = state->rstate.ra.xR[3];
      rf = state->rstate.ra.xR[4];
      rd = state->rstate.ra.xR[5];
      v = state->rstate.ra.xR[6];
      vv = state->rstate.ra.xR[7];
      relcnt = state->rstate.ra.xR[8];
   } else {
      n = 359;
      m = -58;
      k = -919;
      i = -909;
      j = 81;
      j1 = 255;
      info = 74;
      lx = -788;
      lf = 809;
      ld = 205;
      rx = -838;
      rf = 939;
      rd = -526;
      v = 763;
      vv = -541;
      relcnt = -698;
   }
   if (state->rstate.stage == 0) {
      goto lbl_0;
   }
   if (state->rstate.stage == 1) {
      goto lbl_1;
   }
   if (state->rstate.stage == 2) {
      goto lbl_2;
   }
   if (state->rstate.stage == 3) {
      goto lbl_3;
   }
   if (state->rstate.stage == 4) {
      goto lbl_4;
   }
   if (state->rstate.stage == 5) {
      goto lbl_5;
   }
   if (state->rstate.stage == 6) {
      goto lbl_6;
   }
   if (state->rstate.stage == 7) {
      goto lbl_7;
   }
   if (state->rstate.stage == 8) {
      goto lbl_8;
   }
   if (state->rstate.stage == 9) {
      goto lbl_9;
   }
   if (state->rstate.stage == 10) {
      goto lbl_10;
   }
   if (state->rstate.stage == 11) {
      goto lbl_11;
   }
   if (state->rstate.stage == 12) {
      goto lbl_12;
   }
   if (state->rstate.stage == 13) {
      goto lbl_13;
   }
// Routine body
// Init
   if (state->wkind == 1) {
      ae_assert(state->npoints == state->nweights, "LSFitFit: number of points is not equal to the number of weights", _state);
   }
   state->repvaridx = -1;
   n = state->npoints;
   m = state->m;
   k = state->k;
   ivectorsetlengthatleast(&state->tmpct, state->nec + state->nic, _state);
   for (i = 0; i < state->nec; i++) {
      state->tmpct.xZ[i] = 0;
   }
   for (i = 0; i < state->nic; i++) {
      state->tmpct.xZ[state->nec + i] = -1;
   }
   minlmsetcond(&state->optstate, state->epsx, state->maxits, _state);
   minlmsetstpmax(&state->optstate, state->stpmax, _state);
   minlmsetxrep(&state->optstate, state->xrep, _state);
   minlmsetscale(&state->optstate, &state->s, _state);
   minlmsetbc(&state->optstate, &state->bndl, &state->bndu, _state);
   minlmsetlc(&state->optstate, &state->cleic, &state->tmpct, state->nec + state->nic, _state);
//  Check that user-supplied gradient is correct
   lsfit_lsfitclearrequestfields(state, _state);
   if (!(state->teststep > 0.0 && state->optalgo == 1)) {
      goto lbl_14;
   }
   for (i = 0; i < k; i++) {
      state->c.xR[i] = state->c0.xR[i];
      if (ae_isfinite(state->bndl.xR[i], _state)) {
         state->c.xR[i] = maxreal(state->c.xR[i], state->bndl.xR[i], _state);
      }
      if (ae_isfinite(state->bndu.xR[i], _state)) {
         state->c.xR[i] = minreal(state->c.xR[i], state->bndu.xR[i], _state);
      }
   }
   state->needfg = true;
   i = 0;
lbl_16:
   if (i > k - 1) {
      goto lbl_18;
   }
   ae_assert(state->bndl.xR[i] <= state->c.xR[i] && state->c.xR[i] <= state->bndu.xR[i], "LSFitIteration: internal error(State.C is out of bounds)", _state);
   v = state->c.xR[i];
   j = 0;
lbl_19:
   if (j > n - 1) {
      goto lbl_21;
   }
   ae_v_move(state->x.xR, 1, state->taskx.xyR[j], 1, m);
   state->c.xR[i] = v - state->teststep * state->s.xR[i];
   if (ae_isfinite(state->bndl.xR[i], _state)) {
      state->c.xR[i] = maxreal(state->c.xR[i], state->bndl.xR[i], _state);
   }
   lx = state->c.xR[i];
   state->rstate.stage = 0;
   goto lbl_rcomm;
lbl_0:
   lf = state->f;
   ld = state->g.xR[i];
   state->c.xR[i] = v + state->teststep * state->s.xR[i];
   if (ae_isfinite(state->bndu.xR[i], _state)) {
      state->c.xR[i] = minreal(state->c.xR[i], state->bndu.xR[i], _state);
   }
   rx = state->c.xR[i];
   state->rstate.stage = 1;
   goto lbl_rcomm;
lbl_1:
   rf = state->f;
   rd = state->g.xR[i];
   state->c.xR[i] = (lx + rx) / 2;
   if (ae_isfinite(state->bndl.xR[i], _state)) {
      state->c.xR[i] = maxreal(state->c.xR[i], state->bndl.xR[i], _state);
   }
   if (ae_isfinite(state->bndu.xR[i], _state)) {
      state->c.xR[i] = minreal(state->c.xR[i], state->bndu.xR[i], _state);
   }
   state->rstate.stage = 2;
   goto lbl_rcomm;
lbl_2:
   state->c.xR[i] = v;
   if (!derivativecheck(lf, ld, rf, rd, state->f, state->g.xR[i], rx - lx, _state)) {
      state->repvaridx = i;
      state->repterminationtype = -7;
      result = false;
      return result;
   }
   j++;
   goto lbl_19;
lbl_21:
   i++;
   goto lbl_16;
lbl_18:
   state->needfg = false;
lbl_14:
// Fill WCur by weights:
// * for WKind=0 unit weights are chosen
// * for WKind=1 we use user-supplied weights stored in State.TaskW
   rvectorsetlengthatleast(&state->wcur, n, _state);
   for (i = 0; i < n; i++) {
      state->wcur.xR[i] = 1.0;
      if (state->wkind == 1) {
         state->wcur.xR[i] = state->taskw.xR[i];
      }
   }
// Optimize
lbl_22:
   if (!minlmiteration(&state->optstate, _state)) {
      goto lbl_23;
   }
   if (!state->optstate.needfi) {
      goto lbl_24;
   }
// calculate f[] = wi*(f(xi,c)-yi)
   i = 0;
lbl_26:
   if (i > n - 1) {
      goto lbl_28;
   }
   ae_v_move(state->c.xR, 1, state->optstate.x.xR, 1, k);
   ae_v_move(state->x.xR, 1, state->taskx.xyR[i], 1, m);
   state->pointindex = i;
   lsfit_lsfitclearrequestfields(state, _state);
   state->needf = true;
   state->rstate.stage = 3;
   goto lbl_rcomm;
lbl_3:
   state->needf = false;
   vv = state->wcur.xR[i];
   state->optstate.fi.xR[i] = vv * (state->f - state->tasky.xR[i]);
   i++;
   goto lbl_26;
lbl_28:
   goto lbl_22;
lbl_24:
   if (!state->optstate.needf) {
      goto lbl_29;
   }
// calculate F = sum (wi*(f(xi,c)-yi))^2
   state->optstate.f = 0.0;
   i = 0;
lbl_31:
   if (i > n - 1) {
      goto lbl_33;
   }
   ae_v_move(state->c.xR, 1, state->optstate.x.xR, 1, k);
   ae_v_move(state->x.xR, 1, state->taskx.xyR[i], 1, m);
   state->pointindex = i;
   lsfit_lsfitclearrequestfields(state, _state);
   state->needf = true;
   state->rstate.stage = 4;
   goto lbl_rcomm;
lbl_4:
   state->needf = false;
   vv = state->wcur.xR[i];
   state->optstate.f += sqr(vv * (state->f - state->tasky.xR[i]), _state);
   i++;
   goto lbl_31;
lbl_33:
   goto lbl_22;
lbl_29:
   if (!state->optstate.needfg) {
      goto lbl_34;
   }
// calculate F/gradF
   state->optstate.f = 0.0;
   for (i = 0; i < k; i++) {
      state->optstate.g.xR[i] = 0.0;
   }
   i = 0;
lbl_36:
   if (i > n - 1) {
      goto lbl_38;
   }
   ae_v_move(state->c.xR, 1, state->optstate.x.xR, 1, k);
   ae_v_move(state->x.xR, 1, state->taskx.xyR[i], 1, m);
   state->pointindex = i;
   lsfit_lsfitclearrequestfields(state, _state);
   state->needfg = true;
   state->rstate.stage = 5;
   goto lbl_rcomm;
lbl_5:
   state->needfg = false;
   vv = state->wcur.xR[i];
   state->optstate.f += sqr(vv * (state->f - state->tasky.xR[i]), _state);
   v = sqr(vv, _state) * 2 * (state->f - state->tasky.xR[i]);
   ae_v_addd(state->optstate.g.xR, 1, state->g.xR, 1, k, v);
   i++;
   goto lbl_36;
lbl_38:
   goto lbl_22;
lbl_34:
   if (!state->optstate.needfij) {
      goto lbl_39;
   }
// calculate Fi/jac(Fi)
   i = 0;
lbl_41:
   if (i > n - 1) {
      goto lbl_43;
   }
   ae_v_move(state->c.xR, 1, state->optstate.x.xR, 1, k);
   ae_v_move(state->x.xR, 1, state->taskx.xyR[i], 1, m);
   state->pointindex = i;
   lsfit_lsfitclearrequestfields(state, _state);
   state->needfg = true;
   state->rstate.stage = 6;
   goto lbl_rcomm;
lbl_6:
   state->needfg = false;
   vv = state->wcur.xR[i];
   state->optstate.fi.xR[i] = vv * (state->f - state->tasky.xR[i]);
   ae_v_moved(state->optstate.j.xyR[i], 1, state->g.xR, 1, k, vv);
   i++;
   goto lbl_41;
lbl_43:
   goto lbl_22;
lbl_39:
   if (!state->optstate.needfgh) {
      goto lbl_44;
   }
// calculate F/grad(F)/hess(F)
   state->optstate.f = 0.0;
   for (i = 0; i < k; i++) {
      state->optstate.g.xR[i] = 0.0;
   }
   for (i = 0; i < k; i++) {
      for (j = 0; j < k; j++) {
         state->optstate.h.xyR[i][j] = 0.0;
      }
   }
   i = 0;
lbl_46:
   if (i > n - 1) {
      goto lbl_48;
   }
   ae_v_move(state->c.xR, 1, state->optstate.x.xR, 1, k);
   ae_v_move(state->x.xR, 1, state->taskx.xyR[i], 1, m);
   state->pointindex = i;
   lsfit_lsfitclearrequestfields(state, _state);
   state->needfgh = true;
   state->rstate.stage = 7;
   goto lbl_rcomm;
lbl_7:
   state->needfgh = false;
   vv = state->wcur.xR[i];
   state->optstate.f += sqr(vv * (state->f - state->tasky.xR[i]), _state);
   v = sqr(vv, _state) * 2 * (state->f - state->tasky.xR[i]);
   ae_v_addd(state->optstate.g.xR, 1, state->g.xR, 1, k, v);
   for (j = 0; j < k; j++) {
      v = 2 * sqr(vv, _state) * state->g.xR[j];
      ae_v_addd(state->optstate.h.xyR[j], 1, state->g.xR, 1, k, v);
      v = 2 * sqr(vv, _state) * (state->f - state->tasky.xR[i]);
      ae_v_addd(state->optstate.h.xyR[j], 1, state->h.xyR[j], 1, k, v);
   }
   i++;
   goto lbl_46;
lbl_48:
   goto lbl_22;
lbl_44:
   if (!state->optstate.xupdated) {
      goto lbl_49;
   }
// Report new iteration
   ae_v_move(state->c.xR, 1, state->optstate.x.xR, 1, k);
   state->f = state->optstate.f;
   lsfit_lsfitclearrequestfields(state, _state);
   state->xupdated = true;
   state->rstate.stage = 8;
   goto lbl_rcomm;
lbl_8:
   state->xupdated = false;
   goto lbl_22;
lbl_49:
   goto lbl_22;
lbl_23:
// Extract results
//
// NOTE: reverse communication protocol used by this unit does NOT
//       allow us to reallocate State.C[] array. Thus, we extract
//       results to the temporary variable in order to avoid possible
//       reallocation.
   minlmresults(&state->optstate, &state->c1, &state->optrep, _state);
   state->repterminationtype = state->optrep.terminationtype;
   state->repiterationscount = state->optrep.iterationscount;
// calculate errors
   if (state->repterminationtype <= 0) {
      goto lbl_51;
   }
// Calculate RMS/Avg/Max/... errors
   state->reprmserror = 0.0;
   state->repwrmserror = 0.0;
   state->repavgerror = 0.0;
   state->repavgrelerror = 0.0;
   state->repmaxerror = 0.0;
   relcnt = 0.0;
   i = 0;
lbl_53:
   if (i > n - 1) {
      goto lbl_55;
   }
   ae_v_move(state->c.xR, 1, state->c1.xR, 1, k);
   ae_v_move(state->x.xR, 1, state->taskx.xyR[i], 1, m);
   state->pointindex = i;
   lsfit_lsfitclearrequestfields(state, _state);
   state->needf = true;
   state->rstate.stage = 9;
   goto lbl_rcomm;
lbl_9:
   state->needf = false;
   v = state->f;
   vv = state->wcur.xR[i];
   state->reprmserror += sqr(v - state->tasky.xR[i], _state);
   state->repwrmserror += sqr(vv * (v - state->tasky.xR[i]), _state);
   state->repavgerror += ae_fabs(v - state->tasky.xR[i], _state);
   if (state->tasky.xR[i] != 0.0) {
      state->repavgrelerror += ae_fabs(v - state->tasky.xR[i], _state) / ae_fabs(state->tasky.xR[i], _state);
      relcnt++;
   }
   state->repmaxerror = maxreal(state->repmaxerror, ae_fabs(v - state->tasky.xR[i], _state), _state);
   i++;
   goto lbl_53;
lbl_55:
   state->reprmserror = ae_sqrt(state->reprmserror / n, _state);
   state->repwrmserror = ae_sqrt(state->repwrmserror / n, _state);
   state->repavgerror /= n;
   if (relcnt != 0.0) {
      state->repavgrelerror /= relcnt;
   }
// Calculate covariance matrix
   rmatrixsetlengthatleast(&state->tmpjac, n, k, _state);
   rvectorsetlengthatleast(&state->tmpf, n, _state);
   rvectorsetlengthatleast(&state->tmp, k, _state);
   if (state->diffstep <= 0.0) {
      goto lbl_56;
   }
// Compute Jacobian by means of numerical differentiation
   lsfit_lsfitclearrequestfields(state, _state);
   state->needf = true;
   i = 0;
lbl_58:
   if (i > n - 1) {
      goto lbl_60;
   }
   ae_v_move(state->x.xR, 1, state->taskx.xyR[i], 1, m);
   state->pointindex = i;
   state->rstate.stage = 10;
   goto lbl_rcomm;
lbl_10:
   state->tmpf.xR[i] = state->f;
   j = 0;
lbl_61:
   if (j > k - 1) {
      goto lbl_63;
   }
   v = state->c.xR[j];
   lx = v - state->diffstep * state->s.xR[j];
   state->c.xR[j] = lx;
   if (ae_isfinite(state->bndl.xR[j], _state)) {
      state->c.xR[j] = maxreal(state->c.xR[j], state->bndl.xR[j], _state);
   }
   state->rstate.stage = 11;
   goto lbl_rcomm;
lbl_11:
   lf = state->f;
   rx = v + state->diffstep * state->s.xR[j];
   state->c.xR[j] = rx;
   if (ae_isfinite(state->bndu.xR[j], _state)) {
      state->c.xR[j] = minreal(state->c.xR[j], state->bndu.xR[j], _state);
   }
   state->rstate.stage = 12;
   goto lbl_rcomm;
lbl_12:
   rf = state->f;
   state->c.xR[j] = v;
   if (rx != lx) {
      state->tmpjac.xyR[i][j] = (rf - lf) / (rx - lx);
   } else {
      state->tmpjac.xyR[i][j] = 0.0;
   }
   j++;
   goto lbl_61;
lbl_63:
   i++;
   goto lbl_58;
lbl_60:
   state->needf = false;
   goto lbl_57;
lbl_56:
// Jacobian is calculated with user-provided analytic gradient
   lsfit_lsfitclearrequestfields(state, _state);
   state->needfg = true;
   i = 0;
lbl_64:
   if (i > n - 1) {
      goto lbl_66;
   }
   ae_v_move(state->x.xR, 1, state->taskx.xyR[i], 1, m);
   state->pointindex = i;
   state->rstate.stage = 13;
   goto lbl_rcomm;
lbl_13:
   state->tmpf.xR[i] = state->f;
   for (j = 0; j < k; j++) {
      state->tmpjac.xyR[i][j] = state->g.xR[j];
   }
   i++;
   goto lbl_64;
lbl_66:
   state->needfg = false;
lbl_57:
   for (i = 0; i < k; i++) {
      state->tmp.xR[i] = 0.0;
   }
   lsfit_estimateerrors(&state->tmpjac, &state->tmpf, &state->tasky, &state->wcur, &state->tmp, &state->s, n, k, &state->rep, &state->tmpjacw, 0, _state);
lbl_51:
   result = false;
   return result;
// Saving state
lbl_rcomm:
   result = true;
   state->rstate.ia.xZ[0] = n;
   state->rstate.ia.xZ[1] = m;
   state->rstate.ia.xZ[2] = k;
   state->rstate.ia.xZ[3] = i;
   state->rstate.ia.xZ[4] = j;
   state->rstate.ia.xZ[5] = j1;
   state->rstate.ia.xZ[6] = info;
   state->rstate.ra.xR[0] = lx;
   state->rstate.ra.xR[1] = lf;
   state->rstate.ra.xR[2] = ld;
   state->rstate.ra.xR[3] = rx;
   state->rstate.ra.xR[4] = rf;
   state->rstate.ra.xR[5] = rd;
   state->rstate.ra.xR[6] = v;
   state->rstate.ra.xR[7] = vv;
   state->rstate.ra.xR[8] = relcnt;
   return result;
}

// Nonlinear least squares fitting results.
//
// Called after return from LSFitFit().
//
// Inputs:
//     State   -   algorithm state
//
// Outputs:
//     Info    -   completion code:
//                     * -8    optimizer   detected  NAN/INF  in  the  target
//                             function and/or gradient
//                     * -7    gradient verification failed.
//                             See LSFitSetGradientCheck() for more information.
//                     * -3    inconsistent constraints
//                     *  2    relative step is no more than EpsX.
//                     *  5    MaxIts steps was taken
//                     *  7    stopping conditions are too stringent,
//                             further improvement is impossible
//     C       -   array[0..K-1], solution
//     Rep     -   optimization report. On success following fields are set:
//                 * R2                non-adjusted coefficient of determination
//                                     (non-weighted)
//                 * RMSError          rms error on the (X,Y).
//                 * AvgError          average error on the (X,Y).
//                 * AvgRelError       average relative error on the non-zero Y
//                 * MaxError          maximum error
//                                     NON-WEIGHTED ERRORS ARE CALCULATED
//                 * WRMSError         weighted rms error on the (X,Y).
//
// ERRORS IN PARAMETERS
//
// This  solver  also  calculates different kinds of errors in parameters and
// fills corresponding fields of report:
// * Rep.CovPar        covariance matrix for parameters, array[K,K].
// * Rep.ErrPar        errors in parameters, array[K],
//                     errpar = sqrt(diag(CovPar))
// * Rep.ErrCurve      vector of fit errors - standard deviations of empirical
//                     best-fit curve from "ideal" best-fit curve built  with
//                     infinite number of samples, array[N].
//                     errcurve = sqrt(diag(J*CovPar*J')),
//                     where J is Jacobian matrix.
// * Rep.Noise         vector of per-point estimates of noise, array[N]
//
// IMPORTANT:  errors  in  parameters  are  calculated  without  taking  into
//             account boundary/linear constraints! Presence  of  constraints
//             changes distribution of errors, but there is no  easy  way  to
//             account for constraints when you calculate covariance matrix.
//
// NOTE:       noise in the data is estimated as follows:
//             * for fitting without user-supplied  weights  all  points  are
//               assumed to have same level of noise, which is estimated from
//               the data
//             * for fitting with user-supplied weights we assume that  noise
//               level in I-th point is inversely proportional to Ith weight.
//               Coefficient of proportionality is estimated from the data.
//
// NOTE:       we apply small amount of regularization when we invert squared
//             Jacobian and calculate covariance matrix. It  guarantees  that
//             algorithm won't divide by zero  during  inversion,  but  skews
//             error estimates a bit (fractional error is about 10^-9).
//
//             However, we believe that this difference is insignificant  for
//             all practical purposes except for the situation when you  want
//             to compare ALGLIB results with "reference"  implementation  up
//             to the last significant digit.
//
// NOTE:       covariance matrix is estimated using  correction  for  degrees
//             of freedom (covariances are divided by N-M instead of dividing
//             by N).
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
// API: void lsfitresults(const lsfitstate &state, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams = xdefault);
void lsfitresults(lsfitstate *state, ae_int_t *info, RVector *c, lsfitreport *rep, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   *info = 0;
   SetVector(c);
   SetObj(lsfitreport, rep);
   lsfit_clearreport(rep, _state);
   *info = state->repterminationtype;
   rep->varidx = state->repvaridx;
   if (*info > 0) {
      ae_vector_set_length(c, state->k, _state);
      ae_v_move(c->xR, 1, state->c1.xR, 1, state->k);
      rep->rmserror = state->reprmserror;
      rep->wrmserror = state->repwrmserror;
      rep->avgerror = state->repavgerror;
      rep->avgrelerror = state->repavgrelerror;
      rep->maxerror = state->repmaxerror;
      rep->iterationscount = state->repiterationscount;
      ae_matrix_set_length(&rep->covpar, state->k, state->k, _state);
      ae_vector_set_length(&rep->errpar, state->k, _state);
      ae_vector_set_length(&rep->errcurve, state->npoints, _state);
      ae_vector_set_length(&rep->noise, state->npoints, _state);
      rep->r2 = state->rep.r2;
      for (i = 0; i < state->k; i++) {
         for (j = 0; j < state->k; j++) {
            rep->covpar.xyR[i][j] = state->rep.covpar.xyR[i][j];
         }
         rep->errpar.xR[i] = state->rep.errpar.xR[i];
      }
      for (i = 0; i < state->npoints; i++) {
         rep->errcurve.xR[i] = state->rep.errcurve.xR[i];
         rep->noise.xR[i] = state->rep.noise.xR[i];
      }
   }
}

void polynomialfitreport_init(void *_p, ae_state *_state, bool make_automatic) {
   polynomialfitreport *p = (polynomialfitreport *)_p;
   ae_touch_ptr((void *)p);
}

void polynomialfitreport_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   polynomialfitreport *dst = (polynomialfitreport *)_dst;
   polynomialfitreport *src = (polynomialfitreport *)_src;
   dst->taskrcond = src->taskrcond;
   dst->rmserror = src->rmserror;
   dst->avgerror = src->avgerror;
   dst->avgrelerror = src->avgrelerror;
   dst->maxerror = src->maxerror;
}

void polynomialfitreport_free(void *_p, bool make_automatic) {
   polynomialfitreport *p = (polynomialfitreport *)_p;
   ae_touch_ptr((void *)p);
}

void barycentricfitreport_init(void *_p, ae_state *_state, bool make_automatic) {
   barycentricfitreport *p = (barycentricfitreport *)_p;
   ae_touch_ptr((void *)p);
}

void barycentricfitreport_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   barycentricfitreport *dst = (barycentricfitreport *)_dst;
   barycentricfitreport *src = (barycentricfitreport *)_src;
   dst->taskrcond = src->taskrcond;
   dst->dbest = src->dbest;
   dst->rmserror = src->rmserror;
   dst->avgerror = src->avgerror;
   dst->avgrelerror = src->avgrelerror;
   dst->maxerror = src->maxerror;
}

void barycentricfitreport_free(void *_p, bool make_automatic) {
   barycentricfitreport *p = (barycentricfitreport *)_p;
   ae_touch_ptr((void *)p);
}

void lsfitreport_init(void *_p, ae_state *_state, bool make_automatic) {
   lsfitreport *p = (lsfitreport *)_p;
   ae_touch_ptr((void *)p);
   ae_matrix_init(&p->covpar, 0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->errpar, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->errcurve, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->noise, 0, DT_REAL, _state, make_automatic);
}

void lsfitreport_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   lsfitreport *dst = (lsfitreport *)_dst;
   lsfitreport *src = (lsfitreport *)_src;
   dst->taskrcond = src->taskrcond;
   dst->iterationscount = src->iterationscount;
   dst->varidx = src->varidx;
   dst->rmserror = src->rmserror;
   dst->avgerror = src->avgerror;
   dst->avgrelerror = src->avgrelerror;
   dst->maxerror = src->maxerror;
   dst->wrmserror = src->wrmserror;
   ae_matrix_copy(&dst->covpar, &src->covpar, _state, make_automatic);
   ae_vector_copy(&dst->errpar, &src->errpar, _state, make_automatic);
   ae_vector_copy(&dst->errcurve, &src->errcurve, _state, make_automatic);
   ae_vector_copy(&dst->noise, &src->noise, _state, make_automatic);
   dst->r2 = src->r2;
}

void lsfitreport_free(void *_p, bool make_automatic) {
   lsfitreport *p = (lsfitreport *)_p;
   ae_touch_ptr((void *)p);
   ae_matrix_free(&p->covpar, make_automatic);
   ae_vector_free(&p->errpar, make_automatic);
   ae_vector_free(&p->errcurve, make_automatic);
   ae_vector_free(&p->noise, make_automatic);
}

void lsfitstate_init(void *_p, ae_state *_state, bool make_automatic) {
   lsfitstate *p = (lsfitstate *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->c0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->c1, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->s, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->bndl, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->bndu, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->taskx, 0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tasky, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->taskw, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->cleic, 0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->x, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->c, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->g, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->h, 0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->wcur, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tmpct, 0, DT_INT, _state, make_automatic);
   ae_vector_init(&p->tmp, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tmpf, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->tmpjac, 0, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->tmpjacw, 0, 0, DT_REAL, _state, make_automatic);
   matinvreport_init(&p->invrep, _state, make_automatic);
   lsfitreport_init(&p->rep, _state, make_automatic);
   minlmstate_init(&p->optstate, _state, make_automatic);
   minlmreport_init(&p->optrep, _state, make_automatic);
   rcommstate_init(&p->rstate, _state, make_automatic);
}

void lsfitstate_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   lsfitstate *dst = (lsfitstate *)_dst;
   lsfitstate *src = (lsfitstate *)_src;
   dst->optalgo = src->optalgo;
   dst->m = src->m;
   dst->k = src->k;
   dst->epsx = src->epsx;
   dst->maxits = src->maxits;
   dst->stpmax = src->stpmax;
   dst->xrep = src->xrep;
   ae_vector_copy(&dst->c0, &src->c0, _state, make_automatic);
   ae_vector_copy(&dst->c1, &src->c1, _state, make_automatic);
   ae_vector_copy(&dst->s, &src->s, _state, make_automatic);
   ae_vector_copy(&dst->bndl, &src->bndl, _state, make_automatic);
   ae_vector_copy(&dst->bndu, &src->bndu, _state, make_automatic);
   ae_matrix_copy(&dst->taskx, &src->taskx, _state, make_automatic);
   ae_vector_copy(&dst->tasky, &src->tasky, _state, make_automatic);
   dst->npoints = src->npoints;
   ae_vector_copy(&dst->taskw, &src->taskw, _state, make_automatic);
   dst->nweights = src->nweights;
   dst->wkind = src->wkind;
   dst->wits = src->wits;
   dst->diffstep = src->diffstep;
   dst->teststep = src->teststep;
   ae_matrix_copy(&dst->cleic, &src->cleic, _state, make_automatic);
   dst->nec = src->nec;
   dst->nic = src->nic;
   dst->xupdated = src->xupdated;
   dst->needf = src->needf;
   dst->needfg = src->needfg;
   dst->needfgh = src->needfgh;
   dst->pointindex = src->pointindex;
   ae_vector_copy(&dst->x, &src->x, _state, make_automatic);
   ae_vector_copy(&dst->c, &src->c, _state, make_automatic);
   dst->f = src->f;
   ae_vector_copy(&dst->g, &src->g, _state, make_automatic);
   ae_matrix_copy(&dst->h, &src->h, _state, make_automatic);
   ae_vector_copy(&dst->wcur, &src->wcur, _state, make_automatic);
   ae_vector_copy(&dst->tmpct, &src->tmpct, _state, make_automatic);
   ae_vector_copy(&dst->tmp, &src->tmp, _state, make_automatic);
   ae_vector_copy(&dst->tmpf, &src->tmpf, _state, make_automatic);
   ae_matrix_copy(&dst->tmpjac, &src->tmpjac, _state, make_automatic);
   ae_matrix_copy(&dst->tmpjacw, &src->tmpjacw, _state, make_automatic);
   dst->tmpnoise = src->tmpnoise;
   matinvreport_copy(&dst->invrep, &src->invrep, _state, make_automatic);
   dst->repiterationscount = src->repiterationscount;
   dst->repterminationtype = src->repterminationtype;
   dst->repvaridx = src->repvaridx;
   dst->reprmserror = src->reprmserror;
   dst->repavgerror = src->repavgerror;
   dst->repavgrelerror = src->repavgrelerror;
   dst->repmaxerror = src->repmaxerror;
   dst->repwrmserror = src->repwrmserror;
   lsfitreport_copy(&dst->rep, &src->rep, _state, make_automatic);
   minlmstate_copy(&dst->optstate, &src->optstate, _state, make_automatic);
   minlmreport_copy(&dst->optrep, &src->optrep, _state, make_automatic);
   dst->prevnpt = src->prevnpt;
   dst->prevalgo = src->prevalgo;
   rcommstate_copy(&dst->rstate, &src->rstate, _state, make_automatic);
}

void lsfitstate_free(void *_p, bool make_automatic) {
   lsfitstate *p = (lsfitstate *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->c0, make_automatic);
   ae_vector_free(&p->c1, make_automatic);
   ae_vector_free(&p->s, make_automatic);
   ae_vector_free(&p->bndl, make_automatic);
   ae_vector_free(&p->bndu, make_automatic);
   ae_matrix_free(&p->taskx, make_automatic);
   ae_vector_free(&p->tasky, make_automatic);
   ae_vector_free(&p->taskw, make_automatic);
   ae_matrix_free(&p->cleic, make_automatic);
   ae_vector_free(&p->x, make_automatic);
   ae_vector_free(&p->c, make_automatic);
   ae_vector_free(&p->g, make_automatic);
   ae_matrix_free(&p->h, make_automatic);
   ae_vector_free(&p->wcur, make_automatic);
   ae_vector_free(&p->tmpct, make_automatic);
   ae_vector_free(&p->tmp, make_automatic);
   ae_vector_free(&p->tmpf, make_automatic);
   ae_matrix_free(&p->tmpjac, make_automatic);
   ae_matrix_free(&p->tmpjacw, make_automatic);
   matinvreport_free(&p->invrep, make_automatic);
   lsfitreport_free(&p->rep, make_automatic);
   minlmstate_free(&p->optstate, make_automatic);
   minlmreport_free(&p->optrep, make_automatic);
   rcommstate_free(&p->rstate, make_automatic);
}
} // end of namespace alglib_impl

namespace alglib {
// Polynomial fitting report:
//     TaskRCond       reciprocal of task's condition number
//     RMSError        RMS error
//     AvgError        average error
//     AvgRelError     average relative error (for non-zero Y[I])
//     MaxError        maximum error
DefClass(polynomialfitreport, DecVal(taskrcond) DecVal(rmserror) DecVal(avgerror) DecVal(avgrelerror) DecVal(maxerror))

// Barycentric fitting report:
//     RMSError        RMS error
//     AvgError        average error
//     AvgRelError     average relative error (for non-zero Y[I])
//     MaxError        maximum error
//     TaskRCond       reciprocal of task's condition number
DefClass(barycentricfitreport, DecVal(taskrcond) DecVal(dbest) DecVal(rmserror) DecVal(avgerror) DecVal(avgrelerror) DecVal(maxerror))

// Least squares fitting report. This structure contains informational fields
// which are set by fitting functions provided by this unit.
//
// Different functions initialize different sets of  fields,  so  you  should
// read documentation on specific function you used in order  to  know  which
// fields are initialized.
//
//     TaskRCond       reciprocal of task's condition number
//     IterationsCount number of internal iterations
//
//     VarIdx          if user-supplied gradient contains errors  which  were
//                     detected by nonlinear fitter, this  field  is  set  to
//                     index  of  the  first  component  of gradient which is
//                     suspected to be spoiled by bugs.
//
//     RMSError        RMS error
//     AvgError        average error
//     AvgRelError     average relative error (for non-zero Y[I])
//     MaxError        maximum error
//
//     WRMSError       weighted RMS error
//
//     CovPar          covariance matrix for parameters, filled by some solvers
//     ErrPar          vector of errors in parameters, filled by some solvers
//     ErrCurve        vector of fit errors -  variability  of  the  best-fit
//                     curve, filled by some solvers.
//     Noise           vector of per-point noise estimates, filled by
//                     some solvers.
//     R2              coefficient of determination (non-weighted, non-adjusted),
//                     filled by some solvers.
DefClass(lsfitreport, DecVal(taskrcond) DecVal(iterationscount) DecVal(varidx) DecVal(rmserror) DecVal(avgerror) DecVal(avgrelerror) DecVal(maxerror) DecVal(wrmserror) DecVar(covpar) DecVar(errpar) DecVar(errcurve) DecVar(noise) DecVal(r2))

// Nonlinear fitter.
//
// You should use ALGLIB functions to work with fitter.
// Never try to access its fields directly!
DefClass(lsfitstate, DecVal(needf) DecVal(needfg) DecVal(needfgh) DecVal(xupdated) DecVar(c) DecVal(f) DecVar(g) DecVar(h) DecVar(x))

void lstfitpiecewiselinearrdpfixed(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t m, real_1d_array &x2, real_1d_array &y2, ae_int_t &nsections, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lstfitpiecewiselinearrdpfixed(ConstT(ae_vector, x), ConstT(ae_vector, y), n, m, ConstT(ae_vector, x2), ConstT(ae_vector, y2), &nsections, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void lstfitpiecewiselinearrdp(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const double eps, real_1d_array &x2, real_1d_array &y2, ae_int_t &nsections, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lstfitpiecewiselinearrdp(ConstT(ae_vector, x), ConstT(ae_vector, y), n, eps, ConstT(ae_vector, x2), ConstT(ae_vector, y2), &nsections, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void lsfitlinearw(const real_1d_array &y, const real_1d_array &w, const real_2d_array &fmatrix, const ae_int_t n, const ae_int_t m, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitlinearw(ConstT(ae_vector, y), ConstT(ae_vector, w), ConstT(ae_matrix, fmatrix), n, m, &info, ConstT(ae_vector, c), ConstT(lsfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void lsfitlinearw(const real_1d_array &y, const real_1d_array &w, const real_2d_array &fmatrix, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams) {
   if (y.length() != w.length() || y.length() != fmatrix.rows()) ThrowError("Error while calling 'lsfitlinearw': looks like one of arguments has wrong size");
   ae_int_t n = y.length();
   ae_int_t m = fmatrix.cols();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitlinearw(ConstT(ae_vector, y), ConstT(ae_vector, w), ConstT(ae_matrix, fmatrix), n, m, &info, ConstT(ae_vector, c), ConstT(lsfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void lsfitlinearwc(const real_1d_array &y, const real_1d_array &w, const real_2d_array &fmatrix, const real_2d_array &cmatrix, const ae_int_t n, const ae_int_t m, const ae_int_t k, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitlinearwc(ConstT(ae_vector, y), ConstT(ae_vector, w), ConstT(ae_matrix, fmatrix), ConstT(ae_matrix, cmatrix), n, m, k, &info, ConstT(ae_vector, c), ConstT(lsfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void lsfitlinearwc(const real_1d_array &y, const real_1d_array &w, const real_2d_array &fmatrix, const real_2d_array &cmatrix, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams) {
   if (y.length() != w.length() || y.length() != fmatrix.rows()) ThrowError("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size");
   if (fmatrix.cols() != cmatrix.cols() - 1) ThrowError("Error while calling 'lsfitlinearwc': looks like one of arguments has wrong size");
   ae_int_t n = y.length();
   ae_int_t m = fmatrix.cols();
   ae_int_t k = cmatrix.rows();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitlinearwc(ConstT(ae_vector, y), ConstT(ae_vector, w), ConstT(ae_matrix, fmatrix), ConstT(ae_matrix, cmatrix), n, m, k, &info, ConstT(ae_vector, c), ConstT(lsfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void lsfitlinear(const real_1d_array &y, const real_2d_array &fmatrix, const ae_int_t n, const ae_int_t m, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitlinear(ConstT(ae_vector, y), ConstT(ae_matrix, fmatrix), n, m, &info, ConstT(ae_vector, c), ConstT(lsfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void lsfitlinear(const real_1d_array &y, const real_2d_array &fmatrix, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams) {
   if (y.length() != fmatrix.rows()) ThrowError("Error while calling 'lsfitlinear': looks like one of arguments has wrong size");
   ae_int_t n = y.length();
   ae_int_t m = fmatrix.cols();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitlinear(ConstT(ae_vector, y), ConstT(ae_matrix, fmatrix), n, m, &info, ConstT(ae_vector, c), ConstT(lsfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void lsfitlinearc(const real_1d_array &y, const real_2d_array &fmatrix, const real_2d_array &cmatrix, const ae_int_t n, const ae_int_t m, const ae_int_t k, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitlinearc(ConstT(ae_vector, y), ConstT(ae_matrix, fmatrix), ConstT(ae_matrix, cmatrix), n, m, k, &info, ConstT(ae_vector, c), ConstT(lsfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void lsfitlinearc(const real_1d_array &y, const real_2d_array &fmatrix, const real_2d_array &cmatrix, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams) {
   if (y.length() != fmatrix.rows()) ThrowError("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size");
   if (fmatrix.cols() != cmatrix.cols() - 1) ThrowError("Error while calling 'lsfitlinearc': looks like one of arguments has wrong size");
   ae_int_t n = y.length();
   ae_int_t m = fmatrix.cols();
   ae_int_t k = cmatrix.rows();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitlinearc(ConstT(ae_vector, y), ConstT(ae_matrix, fmatrix), ConstT(ae_matrix, cmatrix), n, m, k, &info, ConstT(ae_vector, c), ConstT(lsfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void polynomialfitwc(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const ae_int_t n, const real_1d_array &xc, const real_1d_array &yc, const integer_1d_array &dc, const ae_int_t k, const ae_int_t m, ae_int_t &info, barycentricinterpolant &p, polynomialfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialfitwc(ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_vector, w), n, ConstT(ae_vector, xc), ConstT(ae_vector, yc), ConstT(ae_vector, dc), k, m, &info, ConstT(barycentricinterpolant, p), ConstT(polynomialfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void polynomialfitwc(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &xc, const real_1d_array &yc, const integer_1d_array &dc, const ae_int_t m, ae_int_t &info, barycentricinterpolant &p, polynomialfitreport &rep, const xparams _xparams) {
   if (x.length() != y.length() || x.length() != w.length()) ThrowError("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size");
   if (xc.length() != yc.length() || xc.length() != dc.length()) ThrowError("Error while calling 'polynomialfitwc': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   ae_int_t k = xc.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialfitwc(ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_vector, w), n, ConstT(ae_vector, xc), ConstT(ae_vector, yc), ConstT(ae_vector, dc), k, m, &info, ConstT(barycentricinterpolant, p), ConstT(polynomialfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void polynomialfit(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t m, ae_int_t &info, barycentricinterpolant &p, polynomialfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialfit(ConstT(ae_vector, x), ConstT(ae_vector, y), n, m, &info, ConstT(barycentricinterpolant, p), ConstT(polynomialfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void polynomialfit(const real_1d_array &x, const real_1d_array &y, const ae_int_t m, ae_int_t &info, barycentricinterpolant &p, polynomialfitreport &rep, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'polynomialfit': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::polynomialfit(ConstT(ae_vector, x), ConstT(ae_vector, y), n, m, &info, ConstT(barycentricinterpolant, p), ConstT(polynomialfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

double logisticcalc4(const double x, const double a, const double b, const double c, const double d, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::logisticcalc4(x, a, b, c, d, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

double logisticcalc5(const double x, const double a, const double b, const double c, const double d, const double g, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::logisticcalc5(x, a, b, c, d, g, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

void logisticfit45x(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const double cnstrleft, const double cnstrright, const bool is4pl, const double lambdav, const double epsx, const ae_int_t rscnt, double &a, double &b, double &c, double &d, double &g, lsfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::logisticfit45x(ConstT(ae_vector, x), ConstT(ae_vector, y), n, cnstrleft, cnstrright, is4pl, lambdav, epsx, rscnt, &a, &b, &c, &d, &g, ConstT(lsfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void logisticfit4(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, double &a, double &b, double &c, double &d, lsfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::logisticfit4(ConstT(ae_vector, x), ConstT(ae_vector, y), n, &a, &b, &c, &d, ConstT(lsfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void logisticfit4ec(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const double cnstrleft, const double cnstrright, double &a, double &b, double &c, double &d, lsfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::logisticfit4ec(ConstT(ae_vector, x), ConstT(ae_vector, y), n, cnstrleft, cnstrright, &a, &b, &c, &d, ConstT(lsfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void logisticfit5(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, double &a, double &b, double &c, double &d, double &g, lsfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::logisticfit5(ConstT(ae_vector, x), ConstT(ae_vector, y), n, &a, &b, &c, &d, &g, ConstT(lsfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void logisticfit5ec(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const double cnstrleft, const double cnstrright, double &a, double &b, double &c, double &d, double &g, lsfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::logisticfit5ec(ConstT(ae_vector, x), ConstT(ae_vector, y), n, cnstrleft, cnstrright, &a, &b, &c, &d, &g, ConstT(lsfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void barycentricfitfloaterhormannwc(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const ae_int_t n, const real_1d_array &xc, const real_1d_array &yc, const integer_1d_array &dc, const ae_int_t k, const ae_int_t m, ae_int_t &info, barycentricinterpolant &b, barycentricfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::barycentricfitfloaterhormannwc(ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_vector, w), n, ConstT(ae_vector, xc), ConstT(ae_vector, yc), ConstT(ae_vector, dc), k, m, &info, ConstT(barycentricinterpolant, b), ConstT(barycentricfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void barycentricfitfloaterhormann(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t m, ae_int_t &info, barycentricinterpolant &b, barycentricfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::barycentricfitfloaterhormann(ConstT(ae_vector, x), ConstT(ae_vector, y), n, m, &info, ConstT(barycentricinterpolant, b), ConstT(barycentricfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline1dfitcubicwc(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const ae_int_t n, const real_1d_array &xc, const real_1d_array &yc, const integer_1d_array &dc, const ae_int_t k, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dfitcubicwc(ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_vector, w), n, ConstT(ae_vector, xc), ConstT(ae_vector, yc), ConstT(ae_vector, dc), k, m, &info, ConstT(spline1dinterpolant, s), ConstT(spline1dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dfitcubicwc(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &xc, const real_1d_array &yc, const integer_1d_array &dc, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams) {
   if (x.length() != y.length() || x.length() != w.length()) ThrowError("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size");
   if (xc.length() != yc.length() || xc.length() != dc.length()) ThrowError("Error while calling 'spline1dfitcubicwc': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   ae_int_t k = xc.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dfitcubicwc(ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_vector, w), n, ConstT(ae_vector, xc), ConstT(ae_vector, yc), ConstT(ae_vector, dc), k, m, &info, ConstT(spline1dinterpolant, s), ConstT(spline1dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void spline1dfitcubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dfitcubic(ConstT(ae_vector, x), ConstT(ae_vector, y), n, m, &info, ConstT(spline1dinterpolant, s), ConstT(spline1dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dfitcubic(const real_1d_array &x, const real_1d_array &y, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'spline1dfitcubic': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dfitcubic(ConstT(ae_vector, x), ConstT(ae_vector, y), n, m, &info, ConstT(spline1dinterpolant, s), ConstT(spline1dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void spline1dfithermitewc(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const ae_int_t n, const real_1d_array &xc, const real_1d_array &yc, const integer_1d_array &dc, const ae_int_t k, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dfithermitewc(ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_vector, w), n, ConstT(ae_vector, xc), ConstT(ae_vector, yc), ConstT(ae_vector, dc), k, m, &info, ConstT(spline1dinterpolant, s), ConstT(spline1dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dfithermitewc(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &xc, const real_1d_array &yc, const integer_1d_array &dc, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams) {
   if (x.length() != y.length() || x.length() != w.length()) ThrowError("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size");
   if (xc.length() != yc.length() || xc.length() != dc.length()) ThrowError("Error while calling 'spline1dfithermitewc': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   ae_int_t k = xc.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dfithermitewc(ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_vector, w), n, ConstT(ae_vector, xc), ConstT(ae_vector, yc), ConstT(ae_vector, dc), k, m, &info, ConstT(spline1dinterpolant, s), ConstT(spline1dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void spline1dfithermite(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dfithermite(ConstT(ae_vector, x), ConstT(ae_vector, y), n, m, &info, ConstT(spline1dinterpolant, s), ConstT(spline1dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dfithermite(const real_1d_array &x, const real_1d_array &y, const ae_int_t m, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'spline1dfithermite': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dfithermite(ConstT(ae_vector, x), ConstT(ae_vector, y), n, m, &info, ConstT(spline1dinterpolant, s), ConstT(spline1dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void lsfitsetcond(const lsfitstate &state, const double epsx, const ae_int_t maxits, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitsetcond(ConstT(lsfitstate, state), epsx, maxits, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void lsfitsetstpmax(const lsfitstate &state, const double stpmax, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitsetstpmax(ConstT(lsfitstate, state), stpmax, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void lsfitsetxrep(const lsfitstate &state, const bool needxrep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitsetxrep(ConstT(lsfitstate, state), needxrep, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void lsfitsetscale(const lsfitstate &state, const real_1d_array &s, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitsetscale(ConstT(lsfitstate, state), ConstT(ae_vector, s), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void lsfitsetbc(const lsfitstate &state, const real_1d_array &bndl, const real_1d_array &bndu, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitsetbc(ConstT(lsfitstate, state), ConstT(ae_vector, bndl), ConstT(ae_vector, bndu), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void lsfitsetlc(const lsfitstate &state, const real_2d_array &c, const integer_1d_array &ct, const ae_int_t k, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitsetlc(ConstT(lsfitstate, state), ConstT(ae_matrix, c), ConstT(ae_vector, ct), k, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void lsfitsetlc(const lsfitstate &state, const real_2d_array &c, const integer_1d_array &ct, const xparams _xparams) {
   if (c.rows() != ct.length()) ThrowError("Error while calling 'lsfitsetlc': looks like one of arguments has wrong size");
   ae_int_t k = c.rows();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitsetlc(ConstT(lsfitstate, state), ConstT(ae_matrix, c), ConstT(ae_vector, ct), k, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void lsfitsetgradientcheck(const lsfitstate &state, const double teststep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitsetgradientcheck(ConstT(lsfitstate, state), teststep, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void lsfitcreatewf(const real_2d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &c, const ae_int_t n, const ae_int_t m, const ae_int_t k, const double diffstep, lsfitstate &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitcreatewf(ConstT(ae_matrix, x), ConstT(ae_vector, y), ConstT(ae_vector, w), ConstT(ae_vector, c), n, m, k, diffstep, ConstT(lsfitstate, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void lsfitcreatewf(const real_2d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &c, const double diffstep, lsfitstate &state, const xparams _xparams) {
   if (x.rows() != y.length() || x.rows() != w.length()) ThrowError("Error while calling 'lsfitcreatewf': looks like one of arguments has wrong size");
   ae_int_t n = x.rows();
   ae_int_t m = x.cols();
   ae_int_t k = c.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitcreatewf(ConstT(ae_matrix, x), ConstT(ae_vector, y), ConstT(ae_vector, w), ConstT(ae_vector, c), n, m, k, diffstep, ConstT(lsfitstate, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void lsfitcreatef(const real_2d_array &x, const real_1d_array &y, const real_1d_array &c, const ae_int_t n, const ae_int_t m, const ae_int_t k, const double diffstep, lsfitstate &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitcreatef(ConstT(ae_matrix, x), ConstT(ae_vector, y), ConstT(ae_vector, c), n, m, k, diffstep, ConstT(lsfitstate, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void lsfitcreatef(const real_2d_array &x, const real_1d_array &y, const real_1d_array &c, const double diffstep, lsfitstate &state, const xparams _xparams) {
   if (x.rows() != y.length()) ThrowError("Error while calling 'lsfitcreatef': looks like one of arguments has wrong size");
   ae_int_t n = x.rows();
   ae_int_t m = x.cols();
   ae_int_t k = c.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitcreatef(ConstT(ae_matrix, x), ConstT(ae_vector, y), ConstT(ae_vector, c), n, m, k, diffstep, ConstT(lsfitstate, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void lsfitcreatewfg(const real_2d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &c, const ae_int_t n, const ae_int_t m, const ae_int_t k, const bool cheapfg, lsfitstate &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitcreatewfg(ConstT(ae_matrix, x), ConstT(ae_vector, y), ConstT(ae_vector, w), ConstT(ae_vector, c), n, m, k, cheapfg, ConstT(lsfitstate, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void lsfitcreatewfg(const real_2d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &c, const bool cheapfg, lsfitstate &state, const xparams _xparams) {
   if (x.rows() != y.length() || x.rows() != w.length()) ThrowError("Error while calling 'lsfitcreatewfg': looks like one of arguments has wrong size");
   ae_int_t n = x.rows();
   ae_int_t m = x.cols();
   ae_int_t k = c.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitcreatewfg(ConstT(ae_matrix, x), ConstT(ae_vector, y), ConstT(ae_vector, w), ConstT(ae_vector, c), n, m, k, cheapfg, ConstT(lsfitstate, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void lsfitcreatefg(const real_2d_array &x, const real_1d_array &y, const real_1d_array &c, const ae_int_t n, const ae_int_t m, const ae_int_t k, const bool cheapfg, lsfitstate &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitcreatefg(ConstT(ae_matrix, x), ConstT(ae_vector, y), ConstT(ae_vector, c), n, m, k, cheapfg, ConstT(lsfitstate, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void lsfitcreatefg(const real_2d_array &x, const real_1d_array &y, const real_1d_array &c, const bool cheapfg, lsfitstate &state, const xparams _xparams) {
   if (x.rows() != y.length()) ThrowError("Error while calling 'lsfitcreatefg': looks like one of arguments has wrong size");
   ae_int_t n = x.rows();
   ae_int_t m = x.cols();
   ae_int_t k = c.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitcreatefg(ConstT(ae_matrix, x), ConstT(ae_vector, y), ConstT(ae_vector, c), n, m, k, cheapfg, ConstT(lsfitstate, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void lsfitcreatewfgh(const real_2d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &c, const ae_int_t n, const ae_int_t m, const ae_int_t k, lsfitstate &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitcreatewfgh(ConstT(ae_matrix, x), ConstT(ae_vector, y), ConstT(ae_vector, w), ConstT(ae_vector, c), n, m, k, ConstT(lsfitstate, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void lsfitcreatewfgh(const real_2d_array &x, const real_1d_array &y, const real_1d_array &w, const real_1d_array &c, lsfitstate &state, const xparams _xparams) {
   if (x.rows() != y.length() || x.rows() != w.length()) ThrowError("Error while calling 'lsfitcreatewfgh': looks like one of arguments has wrong size");
   ae_int_t n = x.rows();
   ae_int_t m = x.cols();
   ae_int_t k = c.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitcreatewfgh(ConstT(ae_matrix, x), ConstT(ae_vector, y), ConstT(ae_vector, w), ConstT(ae_vector, c), n, m, k, ConstT(lsfitstate, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void lsfitcreatefgh(const real_2d_array &x, const real_1d_array &y, const real_1d_array &c, const ae_int_t n, const ae_int_t m, const ae_int_t k, lsfitstate &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitcreatefgh(ConstT(ae_matrix, x), ConstT(ae_vector, y), ConstT(ae_vector, c), n, m, k, ConstT(lsfitstate, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void lsfitcreatefgh(const real_2d_array &x, const real_1d_array &y, const real_1d_array &c, lsfitstate &state, const xparams _xparams) {
   if (x.rows() != y.length()) ThrowError("Error while calling 'lsfitcreatefgh': looks like one of arguments has wrong size");
   ae_int_t n = x.rows();
   ae_int_t m = x.cols();
   ae_int_t k = c.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitcreatefgh(ConstT(ae_matrix, x), ConstT(ae_vector, y), ConstT(ae_vector, c), n, m, k, ConstT(lsfitstate, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

bool lsfititeration(const lsfitstate &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, false)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   bool Ok = alglib_impl::lsfititeration(ConstT(lsfitstate, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return Ok;
}

// This family of functions is used to launcn iterations of nonlinear fitter
//
// These functions accept following parameters:
//     state   -   algorithm state
//     func    -   callback which calculates function (or merit function)
//                 value func at given point x
//     grad    -   callback which calculates function (or merit function)
//                 value func and gradient grad at given point x
//     hess    -   callback which calculates function (or merit function)
//                 value func, gradient grad and Hessian hess at given point x
//     rep     -   optional callback which is called after each iteration
//                 can be NULL
//     ptr     -   optional pointer which is passed to func/grad/hess/jac/rep
//                 can be NULL
//
// NOTES:
//
// 1. this algorithm is somewhat unusual because it works with  parameterized
//    function f(C,X), where X is a function argument (we  have  many  points
//    which are characterized by different  argument  values),  and  C  is  a
//    parameter to fit.
//
//    For example, if we want to do linear fit by f(c0,c1,x) = c0*x+c1,  then
//    x will be argument, and {c0,c1} will be parameters.
//
//    It is important to understand that this algorithm finds minimum in  the
//    space of function PARAMETERS (not arguments), so it  needs  derivatives
//    of f() with respect to C, not X.
//
//    In the example above it will need f=c0*x+c1 and {df/dc0,df/dc1} = {x,1}
//    instead of {df/dx} = {c0}.
//
// 2. Callback functions accept C as the first parameter, and X as the second
//
// 3. If  state  was  created  with  LSFitCreateFG(),  algorithm  needs  just
//    function   and   its   gradient,   but   if   state   was  created with
//    LSFitCreateFGH(), algorithm will need function, gradient and Hessian.
//
//    According  to  the  said  above,  there  ase  several  versions of this
//    function, which accept different sets of callbacks.
//
//    This flexibility opens way to subtle errors - you may create state with
//    LSFitCreateFGH() (optimization using Hessian), but call function  which
//    does not accept Hessian. So when algorithm will request Hessian,  there
//    will be no callback to call. In this case exception will be thrown.
//
//    Be careful to avoid such errors because there is no way to find them at
//    compile time - you can see them at runtime only.
// ALGLIB: Copyright 17.08.2009 by Sergey Bochkanov
void lsfitfit(lsfitstate &state, void (*func)(const real_1d_array &c, const real_1d_array &x, double &func, void *ptr), void (*rep)(const real_1d_array &c, double func, void *ptr), void *ptr, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::ae_assert(func != NULL, "ALGLIB: error in 'lsfitfit()' (func is NULL)", &_alglib_env_state);
   while (alglib_impl::lsfititeration(state.c_ptr(), &_alglib_env_state))
   BegPoll
      if (state.needf) func(state.c, state.x, state.f, ptr);
      else if (state.xupdated) { if (rep != NULL) rep(state.c, state.f, ptr); }
      else alglib_impl::ae_assert(false, "ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)", &_alglib_env_state);
   EndPoll(_alglib_env_state)
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
void lsfitfit(lsfitstate &state, void (*func)(const real_1d_array &c, const real_1d_array &x, double &func, void *ptr), void (*grad)(const real_1d_array &c, const real_1d_array &x, double &func, real_1d_array &grad, void *ptr), void (*rep)(const real_1d_array &c, double func, void *ptr), void *ptr, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::ae_assert(func != NULL, "ALGLIB: error in 'lsfitfit()' (func is NULL)", &_alglib_env_state);
   alglib_impl::ae_assert(grad != NULL, "ALGLIB: error in 'lsfitfit()' (grad is NULL)", &_alglib_env_state);
   while (alglib_impl::lsfititeration(state.c_ptr(), &_alglib_env_state))
   BegPoll
      if (state.needf) func(state.c, state.x, state.f, ptr);
      else if (state.needfg) grad(state.c, state.x, state.f, state.g, ptr);
      else if (state.xupdated) { if (rep != NULL) rep(state.c, state.f, ptr); }
      else alglib_impl::ae_assert(false, "ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)", &_alglib_env_state);
   EndPoll(_alglib_env_state)
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
void lsfitfit(lsfitstate &state, void (*func)(const real_1d_array &c, const real_1d_array &x, double &func, void *ptr), void (*grad)(const real_1d_array &c, const real_1d_array &x, double &func, real_1d_array &grad, void *ptr), void (*hess)(const real_1d_array &c, const real_1d_array &x, double &func, real_1d_array &grad, real_2d_array &hess, void *ptr), void (*rep)(const real_1d_array &c, double func, void *ptr), void *ptr, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::ae_assert(func != NULL, "ALGLIB: error in 'lsfitfit()' (func is NULL)", &_alglib_env_state);
   alglib_impl::ae_assert(grad != NULL, "ALGLIB: error in 'lsfitfit()' (grad is NULL)", &_alglib_env_state);
   alglib_impl::ae_assert(hess != NULL, "ALGLIB: error in 'lsfitfit()' (hess is NULL)", &_alglib_env_state);
   while (alglib_impl::lsfititeration(state.c_ptr(), &_alglib_env_state))
   BegPoll
      if (state.needf) func(state.c, state.x, state.f, ptr);
      else if (state.needfg) grad(state.c, state.x, state.f, state.g, ptr);
      else if (state.needfgh) hess(state.c, state.x, state.f, state.g, state.h, ptr);
      else if (state.xupdated) { if (rep != NULL) rep(state.c, state.f, ptr); }
      else alglib_impl::ae_assert(false, "ALGLIB: error in 'lsfitfit' (some derivatives were not provided?)", &_alglib_env_state);
   EndPoll(_alglib_env_state)
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void lsfitresults(const lsfitstate &state, ae_int_t &info, real_1d_array &c, lsfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::lsfitresults(ConstT(lsfitstate, state), &info, ConstT(ae_vector, c), ConstT(lsfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
} // end of namespace alglib

// === FITSPHERE Package ===
// Depends on: (Optimization) MINLM, MINNLC
namespace alglib_impl {
// Fitting minimum circumscribed, maximum inscribed or minimum  zone  circles
// (or NX-dimensional spheres)  to  data  (a  set of points in NX-dimensional
// space).
//
// Internal computational function.
//
// Inputs:
//     XY      -   array[NPoints,NX] (or larger), contains dataset.
//                 One row = one point in NX-dimensional space.
//     NPoints -   dataset size, NPoints>0
//     NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)
//     ProblemType-used to encode problem type:
//                 * 0 for least squares circle
//                 * 1 for minimum circumscribed circle/sphere fitting (MC)
//                 * 2 for  maximum inscribed circle/sphere fitting (MI)
//                 * 3 for minimum zone circle fitting (difference between
//                     Rhi and Rlo is minimized), denoted as MZ
//     SolverType- solver to use:
//                 * 0 use best solver available (1 in current version)
//                 * 1 use nonlinearly constrained optimization approach, AUL
//                     (it is roughly 10-20 times  slower  than  SPC-LIN, but
//                     much more stable)
//                 * 2 use special fast IMPRECISE solver, SPC-LIN  sequential
//                     linearization approach; SPC-LIN is fast, but sometimes
//                     fails to converge with more than 3 digits of precision;
//                     see comments below.
//                     NOT RECOMMENDED UNLESS YOU REALLY NEED HIGH PERFORMANCE
//                     AT THE COST OF SOME PRECISION.
//                 * 3 use nonlinearly constrained optimization approach, SLP
//                     (most robust one, but somewhat slower than AUL)
//                 Ignored for ProblemType=0.
//     EpsX    -   stopping criteria for SLP and NLC optimizers:
//                 * must be non-negative
//                 * use 0 to choose default value (1.0E-12 is used by default)
//                 * if you use SLP solver, you should use default values
//                 * if you use NLC solver, you may specify larger values, up
//                   to 1.0E-6, if you want to speed-up  solver;  NLC  solver
//                   performs several preconditioned outer iterations, so final
//                   result typically has precision much better than EpsX.
//     AULIts  -   number of iterations performed by NLC optimizer:
//                 * must be non-negative
//                 * use 0 to choose default value (20 is used by default)
//                 * you may specify values smaller than 20 if you want to
//                   speed up solver; 10 often results in good combination of
//                   precision and speed
//                 Ignored for ProblemType=0.
//     Penalty -   penalty coefficient for NLC optimizer (ignored  for  SLP):
//                 * must be non-negative
//                 * use 0 to choose default value (1.0E6 in current version)
//                 * it should be really large, 1.0E6...1.0E7 is a good value
//                   to start from;
//                 * generally, default value is good enough
//                 * ignored by SLP optimizer
//                 Ignored for ProblemType=0.
//
// Outputs:
//     CX      -   central point for a sphere
//     RLo     -   radius:
//                 * for ProblemType=2,3, radius of the inscribed sphere
//                 * for ProblemType=0 - radius of the least squares sphere
//                 * for ProblemType=1 - zero
//     RHo     -   radius:
//                 * for ProblemType=1,3, radius of the circumscribed sphere
//                 * for ProblemType=0 - radius of the least squares sphere
//                 * for ProblemType=2 - zero
// ALGLIB: Copyright 14.04.2017 by Sergey Bochkanov
void fitsphereinternal(RMatrix *xy, ae_int_t npoints, ae_int_t nx, ae_int_t problemtype, ae_int_t solvertype, double epsx, ae_int_t aulits, double penalty, RVector *cx, double *rlo, double *rhi, fitsphereinternalreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   double vv;
   ae_int_t cpr;
   bool userlo;
   bool userhi;
   double vlo;
   double vhi;
   double spread;
   ae_int_t suboffset;
   ae_int_t dstrow;
   ae_int_t outeridx;
   ae_int_t maxouterits;
   ae_int_t maxits;
   double safeguard;
   double bi;
   ae_frame_make(_state, &_frame_block);
   SetVector(cx);
   *rlo = 0;
   *rhi = 0;
   SetObj(fitsphereinternalreport, rep);
   NewVector(vmin, 0, DT_REAL, _state);
   NewVector(vmax, 0, DT_REAL, _state);
   NewVector(pcr, 0, DT_REAL, _state);
   NewVector(scr, 0, DT_REAL, _state);
   NewVector(bl, 0, DT_REAL, _state);
   NewVector(bu, 0, DT_REAL, _state);
   NewObj(minnlcstate, nlcstate, _state);
   NewObj(minnlcreport, nlcrep, _state);
   NewMatrix(cmatrix, 0, 0, DT_REAL, _state);
   NewVector(ct, 0, DT_INT, _state);
   NewObj(minbleicstate, blcstate, _state);
   NewObj(minbleicreport, blcrep, _state);
   NewVector(prevc, 0, DT_REAL, _state);
   NewObj(minlmstate, lmstate, _state);
   NewObj(minlmreport, lmrep, _state);
// Check input parameters
   ae_assert(npoints > 0, "FitSphereX: NPoints <= 0", _state);
   ae_assert(nx > 0, "FitSphereX: NX <= 0", _state);
   ae_assert(apservisfinitematrix(xy, npoints, nx, _state), "FitSphereX: XY contains infinite or NAN values", _state);
   ae_assert(problemtype >= 0 && problemtype <= 3, "FitSphereX: ProblemType is neither 0, 1, 2 or 3", _state);
   ae_assert(solvertype >= 0 && solvertype <= 3, "FitSphereX: ProblemType is neither 1, 2 or 3", _state);
   ae_assert(ae_isfinite(penalty, _state) && penalty >= 0.0, "FitSphereX: Penalty<0 or is not finite", _state);
   ae_assert(ae_isfinite(epsx, _state) && epsx >= 0.0, "FitSphereX: EpsX<0 or is not finite", _state);
   ae_assert(aulits >= 0, "FitSphereX: AULIts<0", _state);
   if (solvertype == 0) {
      solvertype = 1;
   }
   if (penalty == 0.0) {
      penalty = 1.0E6;
   }
   if (epsx == 0.0) {
      epsx = 1.0E-12;
   }
   if (aulits == 0) {
      aulits = 20;
   }
   safeguard = 10.0;
   maxouterits = 10;
   maxits = 10000;
   rep->nfev = 0;
   rep->iterationscount = 0;
// Determine initial values, initial estimates and spread of the points
   ae_vector_set_length(&vmin, nx, _state);
   ae_vector_set_length(&vmax, nx, _state);
   ae_vector_set_length(cx, nx, _state);
   for (j = 0; j < nx; j++) {
      vmin.xR[j] = xy->xyR[0][j];
      vmax.xR[j] = xy->xyR[0][j];
      cx->xR[j] = 0.0;
   }
   for (i = 0; i < npoints; i++) {
      for (j = 0; j < nx; j++) {
         cx->xR[j] += xy->xyR[i][j];
         vmin.xR[j] = minreal(vmin.xR[j], xy->xyR[i][j], _state);
         vmax.xR[j] = maxreal(vmax.xR[j], xy->xyR[i][j], _state);
      }
   }
   spread = 0.0;
   for (j = 0; j < nx; j++) {
      cx->xR[j] /= npoints;
      spread = maxreal(spread, vmax.xR[j] - vmin.xR[j], _state);
   }
   *rlo = maxrealnumber;
   *rhi = 0.0;
   for (i = 0; i < npoints; i++) {
      v = 0.0;
      for (j = 0; j < nx; j++) {
         v += sqr(xy->xyR[i][j] - cx->xR[j], _state);
      }
      v = ae_sqrt(v, _state);
      *rhi = maxreal(*rhi, v, _state);
      *rlo = minreal(*rlo, v, _state);
   }
// Handle degenerate case of zero spread
   if (spread == 0.0) {
      for (j = 0; j < nx; j++) {
         cx->xR[j] = vmin.xR[j];
      }
      *rhi = 0.0;
      *rlo = 0.0;
      ae_frame_leave(_state);
      return;
   }
// Prepare initial point for optimizer, scale vector and box constraints
   ae_vector_set_length(&pcr, nx + 2, _state);
   ae_vector_set_length(&scr, nx + 2, _state);
   ae_vector_set_length(&bl, nx + 2, _state);
   ae_vector_set_length(&bu, nx + 2, _state);
   for (j = 0; j < nx; j++) {
      pcr.xR[j] = cx->xR[j];
      scr.xR[j] = 0.1 * spread;
      bl.xR[j] = cx->xR[j] - safeguard * spread;
      bu.xR[j] = cx->xR[j] + safeguard * spread;
   }
   pcr.xR[nx + 0] = *rlo;
   pcr.xR[nx + 1] = *rhi;
   scr.xR[nx + 0] = 0.5 * spread;
   scr.xR[nx + 1] = 0.5 * spread;
   bl.xR[nx + 0] = 0.0;
   bl.xR[nx + 1] = 0.0;
   bu.xR[nx + 0] = safeguard * (*rhi);
   bu.xR[nx + 1] = safeguard * (*rhi);
// First branch: least squares fitting vs MI/MC/MZ fitting
   if (problemtype == 0) {
   // Solve problem with Levenberg-Marquardt algorithm
      pcr.xR[nx] = *rhi;
      minlmcreatevj(nx + 1, npoints, &pcr, &lmstate, _state);
      minlmsetscale(&lmstate, &scr, _state);
      minlmsetbc(&lmstate, &bl, &bu, _state);
      minlmsetcond(&lmstate, epsx, maxits, _state);
      while (minlmiteration(&lmstate, _state)) {
         if (lmstate.needfij || lmstate.needfi) {
            inc(&rep->nfev, _state);
            for (i = 0; i < npoints; i++) {
               v = 0.0;
               for (j = 0; j < nx; j++) {
                  v += sqr(lmstate.x.xR[j] - xy->xyR[i][j], _state);
               }
               lmstate.fi.xR[i] = ae_sqrt(v, _state) - lmstate.x.xR[nx];
               if (lmstate.needfij) {
                  for (j = 0; j < nx; j++) {
                     lmstate.j.xyR[i][j] = 0.5 / (1.0E-9 * spread + ae_sqrt(v, _state)) * 2 * (lmstate.x.xR[j] - xy->xyR[i][j]);
                  }
                  lmstate.j.xyR[i][nx] = -1.0;
               }
            }
            continue;
         }
         ae_assert(false, "Assertion failed", _state);
      }
      minlmresults(&lmstate, &pcr, &lmrep, _state);
      ae_assert(lmrep.terminationtype > 0, "FitSphereX: unexpected failure of LM solver", _state);
      rep->iterationscount += lmrep.iterationscount;
   // Offload center coordinates from PCR to CX,
   // re-calculate exact value of RLo/RHi using CX.
      for (j = 0; j < nx; j++) {
         cx->xR[j] = pcr.xR[j];
      }
      vv = 0.0;
      for (i = 0; i < npoints; i++) {
         v = 0.0;
         for (j = 0; j < nx; j++) {
            v += sqr(xy->xyR[i][j] - cx->xR[j], _state);
         }
         v = ae_sqrt(v, _state);
         vv += v / npoints;
      }
      *rlo = vv;
      *rhi = vv;
   } else {
   // MI, MC, MZ fitting.
   // Prepare problem metrics
      userlo = problemtype == 2 || problemtype == 3;
      userhi = problemtype == 1 || problemtype == 3;
      if (userlo && userhi) {
         cpr = 2;
      } else {
         cpr = 1;
      }
      if (userlo) {
         vlo = 1.0;
      } else {
         vlo = 0.0;
      }
      if (userhi) {
         vhi = 1.0;
      } else {
         vhi = 0.0;
      }
   // Solve with NLC solver; problem is treated as general nonlinearly constrained
   // programming, with augmented Lagrangian solver or SLP being used.
      if (solvertype == 1 || solvertype == 3) {
         minnlccreate(nx + 2, &pcr, &nlcstate, _state);
         minnlcsetscale(&nlcstate, &scr, _state);
         minnlcsetbc(&nlcstate, &bl, &bu, _state);
         minnlcsetnlc(&nlcstate, 0, cpr * npoints, _state);
         minnlcsetcond(&nlcstate, epsx, maxits, _state);
         minnlcsetprecexactrobust(&nlcstate, 5, _state);
         minnlcsetstpmax(&nlcstate, 0.1, _state);
         if (solvertype == 1) {
            minnlcsetalgoaul(&nlcstate, penalty, aulits, _state);
         } else {
            minnlcsetalgoslp(&nlcstate, _state);
         }
         minnlcrestartfrom(&nlcstate, &pcr, _state);
         while (minnlciteration(&nlcstate, _state)) {
            if (nlcstate.needfij) {
               inc(&rep->nfev, _state);
               nlcstate.fi.xR[0] = vhi * nlcstate.x.xR[nx + 1] - vlo * nlcstate.x.xR[nx + 0];
               for (j = 0; j < nx; j++) {
                  nlcstate.j.xyR[0][j] = 0.0;
               }
               nlcstate.j.xyR[0][nx + 0] = -1 * vlo;
               nlcstate.j.xyR[0][nx + 1] = 1 * vhi;
               for (i = 0; i < npoints; i++) {
                  suboffset = 0;
                  if (userhi) {
                     dstrow = 1 + cpr * i + suboffset;
                     v = 0.0;
                     for (j = 0; j < nx; j++) {
                        vv = nlcstate.x.xR[j] - xy->xyR[i][j];
                        v += vv * vv;
                        nlcstate.j.xyR[dstrow][j] = 2 * vv;
                     }
                     vv = nlcstate.x.xR[nx + 1];
                     v -= vv * vv;
                     nlcstate.j.xyR[dstrow][nx + 0] = 0.0;
                     nlcstate.j.xyR[dstrow][nx + 1] = -2 * vv;
                     nlcstate.fi.xR[dstrow] = v;
                     inc(&suboffset, _state);
                  }
                  if (userlo) {
                     dstrow = 1 + cpr * i + suboffset;
                     v = 0.0;
                     for (j = 0; j < nx; j++) {
                        vv = nlcstate.x.xR[j] - xy->xyR[i][j];
                        v -= vv * vv;
                        nlcstate.j.xyR[dstrow][j] = -2 * vv;
                     }
                     vv = nlcstate.x.xR[nx + 0];
                     v += vv * vv;
                     nlcstate.j.xyR[dstrow][nx + 0] = 2 * vv;
                     nlcstate.j.xyR[dstrow][nx + 1] = 0.0;
                     nlcstate.fi.xR[dstrow] = v;
                     inc(&suboffset, _state);
                  }
                  ae_assert(suboffset == cpr, "Assertion failed", _state);
               }
               continue;
            }
            ae_assert(false, "Assertion failed", _state);
         }
         minnlcresults(&nlcstate, &pcr, &nlcrep, _state);
         ae_assert(nlcrep.terminationtype > 0, "FitSphereX: unexpected failure of NLC solver", _state);
         rep->iterationscount += nlcrep.iterationscount;
      // Offload center coordinates from PCR to CX,
      // re-calculate exact value of RLo/RHi using CX.
         for (j = 0; j < nx; j++) {
            cx->xR[j] = pcr.xR[j];
         }
         *rlo = maxrealnumber;
         *rhi = 0.0;
         for (i = 0; i < npoints; i++) {
            v = 0.0;
            for (j = 0; j < nx; j++) {
               v += sqr(xy->xyR[i][j] - cx->xR[j], _state);
            }
            v = ae_sqrt(v, _state);
            *rhi = maxreal(*rhi, v, _state);
            *rlo = minreal(*rlo, v, _state);
         }
         if (!userlo) {
            *rlo = 0.0;
         }
         if (!userhi) {
            *rhi = 0.0;
         }
         ae_frame_leave(_state);
         return;
      }
   // Solve problem with SLP (sequential LP) approach; this approach
   // is much faster than NLP, but often fails for MI and MC (for MZ
   // it performs well enough).
   //
   // REFERENCE: "On a sequential linear programming approach to finding
   //            the smallest circumscribed, largest inscribed, and minimum
   //            zone circle or sphere", Helmuth Spath and G.A.Watson
      if (solvertype == 2) {
         ae_matrix_set_length(&cmatrix, cpr * npoints, nx + 3, _state);
         ae_vector_set_length(&ct, cpr * npoints, _state);
         ae_vector_set_length(&prevc, nx, _state);
         minbleiccreate(nx + 2, &pcr, &blcstate, _state);
         minbleicsetscale(&blcstate, &scr, _state);
         minbleicsetbc(&blcstate, &bl, &bu, _state);
         minbleicsetcond(&blcstate, 0.0, 0.0, epsx, maxits, _state);
         for (outeridx = 0; outeridx < maxouterits; outeridx++) {
         // Prepare initial point for algorithm; center coordinates at
         // PCR are used to calculate RLo/RHi and update PCR with them.
            *rlo = maxrealnumber;
            *rhi = 0.0;
            for (i = 0; i < npoints; i++) {
               v = 0.0;
               for (j = 0; j < nx; j++) {
                  v += sqr(xy->xyR[i][j] - pcr.xR[j], _state);
               }
               v = ae_sqrt(v, _state);
               *rhi = maxreal(*rhi, v, _state);
               *rlo = minreal(*rlo, v, _state);
            }
            pcr.xR[nx + 0] = *rlo * 0.99999;
            pcr.xR[nx + 1] = *rhi / 0.99999;
         // Generate matrix of linear constraints
            for (i = 0; i < npoints; i++) {
               v = 0.0;
               for (j = 0; j < nx; j++) {
                  v += sqr(xy->xyR[i][j], _state);
               }
               bi = -v / 2;
               suboffset = 0;
               if (userhi) {
                  dstrow = cpr * i + suboffset;
                  for (j = 0; j < nx; j++) {
                     cmatrix.xyR[dstrow][j] = pcr.xR[j] / 2 - xy->xyR[i][j];
                  }
                  cmatrix.xyR[dstrow][nx + 0] = 0.0;
                  cmatrix.xyR[dstrow][nx + 1] = -*rhi / 2;
                  cmatrix.xyR[dstrow][nx + 2] = bi;
                  ct.xZ[dstrow] = -1;
                  inc(&suboffset, _state);
               }
               if (userlo) {
                  dstrow = cpr * i + suboffset;
                  for (j = 0; j < nx; j++) {
                     cmatrix.xyR[dstrow][j] = -(pcr.xR[j] / 2 - xy->xyR[i][j]);
                  }
                  cmatrix.xyR[dstrow][nx + 0] = *rlo / 2;
                  cmatrix.xyR[dstrow][nx + 1] = 0.0;
                  cmatrix.xyR[dstrow][nx + 2] = -bi;
                  ct.xZ[dstrow] = -1;
                  inc(&suboffset, _state);
               }
               ae_assert(suboffset == cpr, "Assertion failed", _state);
            }
         // Solve LP subproblem with MinBLEIC
            for (j = 0; j < nx; j++) {
               prevc.xR[j] = pcr.xR[j];
            }
            minbleicsetlc(&blcstate, &cmatrix, &ct, cpr * npoints, _state);
            minbleicrestartfrom(&blcstate, &pcr, _state);
            while (minbleiciteration(&blcstate, _state)) {
               if (blcstate.needfg) {
                  inc(&rep->nfev, _state);
                  blcstate.f = vhi * blcstate.x.xR[nx + 1] - vlo * blcstate.x.xR[nx + 0];
                  for (j = 0; j < nx; j++) {
                     blcstate.g.xR[j] = 0.0;
                  }
                  blcstate.g.xR[nx + 0] = -1 * vlo;
                  blcstate.g.xR[nx + 1] = 1 * vhi;
                  continue;
               }
            }
            minbleicresults(&blcstate, &pcr, &blcrep, _state);
            ae_assert(blcrep.terminationtype > 0, "FitSphereX: unexpected failure of BLEIC solver", _state);
            rep->iterationscount += blcrep.iterationscount;
         // Terminate iterations early if we converged
            v = 0.0;
            for (j = 0; j < nx; j++) {
               v += sqr(prevc.xR[j] - pcr.xR[j], _state);
            }
            v = ae_sqrt(v, _state);
            if (v <= epsx) {
               break;
            }
         }
      // Offload center coordinates from PCR to CX,
      // re-calculate exact value of RLo/RHi using CX.
         for (j = 0; j < nx; j++) {
            cx->xR[j] = pcr.xR[j];
         }
         *rlo = maxrealnumber;
         *rhi = 0.0;
         for (i = 0; i < npoints; i++) {
            v = 0.0;
            for (j = 0; j < nx; j++) {
               v += sqr(xy->xyR[i][j] - cx->xR[j], _state);
            }
            v = ae_sqrt(v, _state);
            *rhi = maxreal(*rhi, v, _state);
            *rlo = minreal(*rlo, v, _state);
         }
         if (!userlo) {
            *rlo = 0.0;
         }
         if (!userhi) {
            *rhi = 0.0;
         }
         ae_frame_leave(_state);
         return;
      }
   // Oooops...!
      ae_assert(false, "FitSphereX: integrity check failed", _state);
   }
   ae_frame_leave(_state);
}

// Fitting minimum circumscribed, maximum inscribed or minimum  zone  circles
// (or NX-dimensional spheres)  to  data  (a  set of points in NX-dimensional
// space).
//
// This  is  expert  function  which  allows  to  tweak  many  parameters  of
// underlying nonlinear solver:
// * stopping criteria for inner iterations
// * number of outer iterations
// * penalty coefficient used to handle  nonlinear  constraints  (we  convert
//   unconstrained nonsmooth optimization problem ivolving max() and/or min()
//   operations to quadratically constrained smooth one).
//
// You may tweak all these parameters or only some  of  them,  leaving  other
// ones at their default state - just specify zero  value,  and  solver  will
// fill it with appropriate default one.
//
// These comments also include some discussion of  approach  used  to  handle
// such unusual fitting problem,  its  stability,  drawbacks  of  alternative
// methods, and convergence properties.
//
// Inputs:
//     XY      -   array[NPoints,NX] (or larger), contains dataset.
//                 One row = one point in NX-dimensional space.
//     NPoints -   dataset size, NPoints>0
//     NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)
//     ProblemType-used to encode problem type:
//                 * 0 for least squares circle
//                 * 1 for minimum circumscribed circle/sphere fitting (MC)
//                 * 2 for  maximum inscribed circle/sphere fitting (MI)
//                 * 3 for minimum zone circle fitting (difference between
//                     Rhi and Rlo is minimized), denoted as MZ
//     EpsX    -   stopping condition for NLC optimizer:
//                 * must be non-negative
//                 * use 0 to choose default value (1.0E-12 is used by default)
//                 * you may specify larger values, up to 1.0E-6, if you want
//                   to   speed-up   solver;   NLC   solver  performs several
//                   preconditioned  outer  iterations,   so   final   result
//                   typically has precision much better than EpsX.
//     AULIts  -   number of outer iterations performed by NLC optimizer:
//                 * must be non-negative
//                 * use 0 to choose default value (20 is used by default)
//                 * you may specify values smaller than 20 if you want to
//                   speed up solver; 10 often results in good combination of
//                   precision and speed; sometimes you may get good results
//                   with just 6 outer iterations.
//                 Ignored for ProblemType=0.
//     Penalty -   penalty coefficient for NLC optimizer:
//                 * must be non-negative
//                 * use 0 to choose default value (1.0E6 in current version)
//                 * it should be really large, 1.0E6...1.0E7 is a good value
//                   to start from;
//                 * generally, default value is good enough
//                 Ignored for ProblemType=0.
//
// Outputs:
//     CX      -   central point for a sphere
//     RLo     -   radius:
//                 * for ProblemType=2,3, radius of the inscribed sphere
//                 * for ProblemType=0 - radius of the least squares sphere
//                 * for ProblemType=1 - zero
//     RHo     -   radius:
//                 * for ProblemType=1,3, radius of the circumscribed sphere
//                 * for ProblemType=0 - radius of the least squares sphere
//                 * for ProblemType=2 - zero
//
// NOTE: ON THE UNIQUENESS OF SOLUTIONS
//
// ALGLIB provides solution to several related circle fitting  problems:   MC
// (minimum circumscribed), MI (maximum inscribed)   and   MZ  (minimum zone)
// fitting, LS (least squares) fitting.
//
// It  is  important  to  note  that  among these problems only MC and LS are
// convex and have unique solution independently from starting point.
//
// As  for MI,  it  may (or  may  not, depending on dataset properties)  have
// multiple solutions, and it always  has  one degenerate solution C=infinity
// which corresponds to infinitely large radius. Thus, there are no guarantees
// that solution to  MI returned by this solver will be the best one (and  no
// one can provide you with such guarantee because problem is  NP-hard).  The
// only guarantee you have is that this solution is locally optimal, i.e.  it
// can not be improved by infinitesimally small tweaks in the parameters.
//
// It  is  also  possible  to "run away" to infinity when  started  from  bad
// initial point located outside of point cloud (or when point cloud does not
// span entire circumference/surface of the sphere).
//
// Finally,  MZ (minimum zone circle) stands somewhere between MC  and  MI in
// stability. It is somewhat regularized by "circumscribed" term of the merit
// function; however, solutions to  MZ may be non-unique, and in some unlucky
// cases it is also possible to "run away to infinity".
//
//
// NOTE: ON THE NONLINEARLY CONSTRAINED PROGRAMMING APPROACH
//
// The problem formulation for MC  (minimum circumscribed   circle;  for  the
// sake of simplicity we omit MZ and MI here) is:
//
//         [     [         ]2 ]
//     min [ max [ XY[i]-C ]  ]
//      C  [  i  [         ]  ]
//
// i.e. it is unconstrained nonsmooth optimization problem of finding  "best"
// central point, with radius R being unambiguously  determined  from  C.  In
// order to move away from non-smoothness we use following reformulation:
//
//         [   ]                  [         ]2
//     min [ R ] subject to R >= 0, [ XY[i]-C ]  <= R^2
//     C,R [   ]                  [         ]
//
// i.e. it becomes smooth quadratically constrained optimization problem with
// linear target function. Such problem statement is 100% equivalent  to  the
// original nonsmooth one, but much easier  to  approach.  We solve  it  with
// MinNLC solver provided by ALGLIB.
//
//
// NOTE: ON INSTABILITY OF SEQUENTIAL LINEARIZATION APPROACH
//
// ALGLIB  has  nonlinearly  constrained  solver which proved to be stable on
// such problems. However, some authors proposed to linearize constraints  in
// the vicinity of current approximation (Ci,Ri) and to get next  approximate
// solution (Ci+1,Ri+1) as solution to linear programming problem. Obviously,
// LP problems are easier than nonlinearly constrained ones.
//
// Indeed,  such approach  to   MC/MI/MZ   resulted   in  ~10-20x increase in
// performance (when compared with NLC solver). However, it turned  out  that
// in some cases linearized model fails to predict correct direction for next
// step and tells us that we converged to solution even when we are still 2-4
// digits of precision away from it.
//
// It is important that it is not failure of LP solver - it is failure of the
// linear model;  even  when  solved  exactly,  it  fails  to  handle  subtle
// nonlinearities which arise near the solution. We validated it by comparing
// results returned by ALGLIB linear solver with that of MATLAB.
//
// In our experiments with linearization:
// * MC failed most often, at both realistic and synthetic datasets
// * MI sometimes failed, but sometimes succeeded
// * MZ often  succeeded; our guess is that presence of two independent  sets
//   of constraints (one set for Rlo and another one for Rhi) and  two  terms
//   in the target function (Rlo and Rhi) regularizes task,  so  when  linear
//   model fails to handle nonlinearities from Rlo, it uses  Rhi  as  a  hint
//   (and vice versa).
//
// Because linearization approach failed to achieve stable results, we do not
// include it in ALGLIB.
// ALGLIB: Copyright 14.04.2017 by Sergey Bochkanov
// API: void fitspherex(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, const ae_int_t problemtype, const double epsx, const ae_int_t aulits, const double penalty, real_1d_array &cx, double &rlo, double &rhi, const xparams _xparams = xdefault);
void fitspherex(RMatrix *xy, ae_int_t npoints, ae_int_t nx, ae_int_t problemtype, double epsx, ae_int_t aulits, double penalty, RVector *cx, double *rlo, double *rhi, ae_state *_state) {
   ae_frame _frame_block;
   ae_frame_make(_state, &_frame_block);
   SetVector(cx);
   *rlo = 0;
   *rhi = 0;
   NewObj(fitsphereinternalreport, rep, _state);
   ae_assert(ae_isfinite(penalty, _state) && penalty >= 0.0, "FitSphereX: Penalty<0 or is not finite", _state);
   ae_assert(ae_isfinite(epsx, _state) && epsx >= 0.0, "FitSphereX: EpsX<0 or is not finite", _state);
   ae_assert(aulits >= 0, "FitSphereX: AULIts<0", _state);
   fitsphereinternal(xy, npoints, nx, problemtype, 0, epsx, aulits, penalty, cx, rlo, rhi, &rep, _state);
   ae_frame_leave(_state);
}

// Fits least squares (LS) circle (or NX-dimensional sphere) to data  (a  set
// of points in NX-dimensional space).
//
// Least squares circle minimizes sum of squared deviations between distances
// from points to the center and  some  "candidate"  radius,  which  is  also
// fitted to the data.
//
// Inputs:
//     XY      -   array[NPoints,NX] (or larger), contains dataset.
//                 One row = one point in NX-dimensional space.
//     NPoints -   dataset size, NPoints>0
//     NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)
//
// Outputs:
//     CX      -   central point for a sphere
//     R       -   radius
// ALGLIB: Copyright 07.05.2018 by Sergey Bochkanov
// API: void fitspherels(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, real_1d_array &cx, double &r, const xparams _xparams = xdefault);
void fitspherels(RMatrix *xy, ae_int_t npoints, ae_int_t nx, RVector *cx, double *r, ae_state *_state) {
   double dummy;
   SetVector(cx);
   *r = 0;
   fitspherex(xy, npoints, nx, 0, 0.0, 0, 0.0, cx, &dummy, r, _state);
}

// Fits minimum circumscribed (MC) circle (or NX-dimensional sphere) to  data
// (a set of points in NX-dimensional space).
//
// Inputs:
//     XY      -   array[NPoints,NX] (or larger), contains dataset.
//                 One row = one point in NX-dimensional space.
//     NPoints -   dataset size, NPoints>0
//     NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)
//
// Outputs:
//     CX      -   central point for a sphere
//     RHi     -   radius
//
// NOTE: this function is an easy-to-use wrapper around more powerful "expert"
//       function fitspherex().
//
//       This  wrapper  is optimized  for  ease of use and stability - at the
//       cost of somewhat lower  performance  (we  have  to  use  very  tight
//       stopping criteria for inner optimizer because we want to  make  sure
//       that it will converge on any dataset).
//
//       If you are ready to experiment with settings of  "expert"  function,
//       you can achieve ~2-4x speedup over standard "bulletproof" settings.
// ALGLIB: Copyright 14.04.2017 by Sergey Bochkanov
// API: void fitspheremc(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, real_1d_array &cx, double &rhi, const xparams _xparams = xdefault);
void fitspheremc(RMatrix *xy, ae_int_t npoints, ae_int_t nx, RVector *cx, double *rhi, ae_state *_state) {
   double dummy;
   SetVector(cx);
   *rhi = 0;
   fitspherex(xy, npoints, nx, 1, 0.0, 0, 0.0, cx, &dummy, rhi, _state);
}

// Fits maximum inscribed circle (or NX-dimensional sphere) to data (a set of
// points in NX-dimensional space).
//
// Inputs:
//     XY      -   array[NPoints,NX] (or larger), contains dataset.
//                 One row = one point in NX-dimensional space.
//     NPoints -   dataset size, NPoints>0
//     NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)
//
// Outputs:
//     CX      -   central point for a sphere
//     RLo     -   radius
//
// NOTE: this function is an easy-to-use wrapper around more powerful "expert"
//       function fitspherex().
//
//       This  wrapper  is optimized  for  ease of use and stability - at the
//       cost of somewhat lower  performance  (we  have  to  use  very  tight
//       stopping criteria for inner optimizer because we want to  make  sure
//       that it will converge on any dataset).
//
//       If you are ready to experiment with settings of  "expert"  function,
//       you can achieve ~2-4x speedup over standard "bulletproof" settings.
// ALGLIB: Copyright 14.04.2017 by Sergey Bochkanov
// API: void fitspheremi(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, real_1d_array &cx, double &rlo, const xparams _xparams = xdefault);
void fitspheremi(RMatrix *xy, ae_int_t npoints, ae_int_t nx, RVector *cx, double *rlo, ae_state *_state) {
   double dummy;
   SetVector(cx);
   *rlo = 0;
   fitspherex(xy, npoints, nx, 2, 0.0, 0, 0.0, cx, rlo, &dummy, _state);
}

// Fits minimum zone circle (or NX-dimensional sphere)  to  data  (a  set  of
// points in NX-dimensional space).
//
// Inputs:
//     XY      -   array[NPoints,NX] (or larger), contains dataset.
//                 One row = one point in NX-dimensional space.
//     NPoints -   dataset size, NPoints>0
//     NX      -   space dimensionality, NX>0 (1, 2, 3, 4, 5 and so on)
//
// Outputs:
//     CX      -   central point for a sphere
//     RLo     -   radius of inscribed circle
//     RHo     -   radius of circumscribed circle
//
// NOTE: this function is an easy-to-use wrapper around more powerful "expert"
//       function fitspherex().
//
//       This  wrapper  is optimized  for  ease of use and stability - at the
//       cost of somewhat lower  performance  (we  have  to  use  very  tight
//       stopping criteria for inner optimizer because we want to  make  sure
//       that it will converge on any dataset).
//
//       If you are ready to experiment with settings of  "expert"  function,
//       you can achieve ~2-4x speedup over standard "bulletproof" settings.
// ALGLIB: Copyright 14.04.2017 by Sergey Bochkanov
// API: void fitspheremz(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, real_1d_array &cx, double &rlo, double &rhi, const xparams _xparams = xdefault);
void fitspheremz(RMatrix *xy, ae_int_t npoints, ae_int_t nx, RVector *cx, double *rlo, double *rhi, ae_state *_state) {
   SetVector(cx);
   *rlo = 0;
   *rhi = 0;
   fitspherex(xy, npoints, nx, 3, 0.0, 0, 0.0, cx, rlo, rhi, _state);
}

void fitsphereinternalreport_init(void *_p, ae_state *_state, bool make_automatic) {
   fitsphereinternalreport *p = (fitsphereinternalreport *)_p;
   ae_touch_ptr((void *)p);
}

void fitsphereinternalreport_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   fitsphereinternalreport *dst = (fitsphereinternalreport *)_dst;
   fitsphereinternalreport *src = (fitsphereinternalreport *)_src;
   dst->nfev = src->nfev;
   dst->iterationscount = src->iterationscount;
}

void fitsphereinternalreport_free(void *_p, bool make_automatic) {
   fitsphereinternalreport *p = (fitsphereinternalreport *)_p;
   ae_touch_ptr((void *)p);
}
} // end of namespace alglib_impl

namespace alglib {
void fitspherex(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, const ae_int_t problemtype, const double epsx, const ae_int_t aulits, const double penalty, real_1d_array &cx, double &rlo, double &rhi, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::fitspherex(ConstT(ae_matrix, xy), npoints, nx, problemtype, epsx, aulits, penalty, ConstT(ae_vector, cx), &rlo, &rhi, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void fitspherels(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, real_1d_array &cx, double &r, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::fitspherels(ConstT(ae_matrix, xy), npoints, nx, ConstT(ae_vector, cx), &r, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void fitspheremc(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, real_1d_array &cx, double &rhi, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::fitspheremc(ConstT(ae_matrix, xy), npoints, nx, ConstT(ae_vector, cx), &rhi, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void fitspheremi(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, real_1d_array &cx, double &rlo, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::fitspheremi(ConstT(ae_matrix, xy), npoints, nx, ConstT(ae_vector, cx), &rlo, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void fitspheremz(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, real_1d_array &cx, double &rlo, double &rhi, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::fitspheremz(ConstT(ae_matrix, xy), npoints, nx, ConstT(ae_vector, cx), &rlo, &rhi, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
} // end of namespace alglib

// === PARAMETRIC Package ===
// Depends on: (Integration) AUTOGK
// Depends on: SPLINE1D
namespace alglib_impl {
// Builds non-periodic parameterization for 2-dimensional spline
static void parametric_pspline2par(RMatrix *xy, ae_int_t n, ae_int_t pt, RVector *p, ae_state *_state) {
   double v;
   ae_int_t i;
   SetVector(p);
   ae_assert(pt >= 0 && pt <= 2, "PSpline2Par: internal error!", _state);
// Build parameterization:
// * fill by non-normalized values
// * normalize them so we have P[0]=0, P[N-1]=1.
   ae_vector_set_length(p, n, _state);
   if (pt == 0) {
      for (i = 0; i < n; i++) {
         p->xR[i] = (double)i;
      }
   }
   if (pt == 1) {
      p->xR[0] = 0.0;
      for (i = 1; i < n; i++) {
         p->xR[i] = p->xR[i - 1] + safepythag2(xy->xyR[i][0] - xy->xyR[i - 1][0], xy->xyR[i][1] - xy->xyR[i - 1][1], _state);
      }
   }
   if (pt == 2) {
      p->xR[0] = 0.0;
      for (i = 1; i < n; i++) {
         p->xR[i] = p->xR[i - 1] + ae_sqrt(safepythag2(xy->xyR[i][0] - xy->xyR[i - 1][0], xy->xyR[i][1] - xy->xyR[i - 1][1], _state), _state);
      }
   }
   v = 1 / p->xR[n - 1];
   ae_v_muld(p->xR, 1, n, v);
}

// Builds non-periodic parameterization for 3-dimensional spline
static void parametric_pspline3par(RMatrix *xy, ae_int_t n, ae_int_t pt, RVector *p, ae_state *_state) {
   double v;
   ae_int_t i;
   SetVector(p);
   ae_assert(pt >= 0 && pt <= 2, "PSpline3Par: internal error!", _state);
// Build parameterization:
// * fill by non-normalized values
// * normalize them so we have P[0]=0, P[N-1]=1.
   ae_vector_set_length(p, n, _state);
   if (pt == 0) {
      for (i = 0; i < n; i++) {
         p->xR[i] = (double)i;
      }
   }
   if (pt == 1) {
      p->xR[0] = 0.0;
      for (i = 1; i < n; i++) {
         p->xR[i] = p->xR[i - 1] + safepythag3(xy->xyR[i][0] - xy->xyR[i - 1][0], xy->xyR[i][1] - xy->xyR[i - 1][1], xy->xyR[i][2] - xy->xyR[i - 1][2], _state);
      }
   }
   if (pt == 2) {
      p->xR[0] = 0.0;
      for (i = 1; i < n; i++) {
         p->xR[i] = p->xR[i - 1] + ae_sqrt(safepythag3(xy->xyR[i][0] - xy->xyR[i - 1][0], xy->xyR[i][1] - xy->xyR[i - 1][1], xy->xyR[i][2] - xy->xyR[i - 1][2], _state), _state);
      }
   }
   v = 1 / p->xR[n - 1];
   ae_v_muld(p->xR, 1, n, v);
}

// This function  builds  non-periodic 2-dimensional parametric spline  which
// starts at (X[0],Y[0]) and ends at (X[N-1],Y[N-1]).
//
// Inputs:
//     XY  -   points, array[0..N-1,0..1].
//             XY[I,0:1] corresponds to the Ith point.
//             Order of points is important!
//     N   -   points count, N >= 5 for Akima splines, N >= 2 for other types  of
//             splines.
//     ST  -   spline type:
//             * 0     Akima spline
//             * 1     parabolically terminated Catmull-Rom spline (Tension=0)
//             * 2     parabolically terminated cubic spline
//     PT  -   parameterization type:
//             * 0     uniform
//             * 1     chord length
//             * 2     centripetal
//
// Outputs:
//     P   -   parametric spline interpolant
//
//
// NOTES:
// * this function  assumes  that  there all consequent points  are distinct.
//   I.e. (x0,y0) != (x1,y1),  (x1,y1) != (x2,y2),  (x2,y2) != (x3,y3)  and  so on.
//   However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
//   =(x2,y2).
// ALGLIB Project: Copyright 28.05.2010 by Sergey Bochkanov
// API: void pspline2build(const real_2d_array &xy, const ae_int_t n, const ae_int_t st, const ae_int_t pt, pspline2interpolant &p, const xparams _xparams = xdefault);
void pspline2build(RMatrix *xy, ae_int_t n, ae_int_t st, ae_int_t pt, pspline2interpolant *p, ae_state *_state) {
   ae_frame _frame_block;
   ae_frame_make(_state, &_frame_block);
   DupMatrix(xy, _state);
   SetObj(pspline2interpolant, p);
   NewVector(tmp, 0, DT_REAL, _state);
   ae_assert(st >= 0 && st <= 2, "PSpline2Build: incorrect spline type!", _state);
   ae_assert(pt >= 0 && pt <= 2, "PSpline2Build: incorrect parameterization type!", _state);
   if (st == 0) {
      ae_assert(n >= 5, "PSpline2Build: N<5 (minimum value for Akima splines)!", _state);
   } else {
      ae_assert(n >= 2, "PSpline2Build: N<2!", _state);
   }
// Prepare
   p->n = n;
   p->periodic = false;
   ae_vector_set_length(&tmp, n, _state);
// Build parameterization, check that all parameters are distinct
   parametric_pspline2par(xy, n, pt, &p->p, _state);
   ae_assert(aredistinct(&p->p, n, _state), "PSpline2Build: consequent points are too close!", _state);
// Build splines
   if (st == 0) {
      ae_v_move(tmp.xR, 1, xy->xyR[0], xy->stride, n);
      spline1dbuildakima(&p->p, &tmp, n, &p->x, _state);
      ae_v_move(tmp.xR, 1, &xy->xyR[0][1], xy->stride, n);
      spline1dbuildakima(&p->p, &tmp, n, &p->y, _state);
   }
   if (st == 1) {
      ae_v_move(tmp.xR, 1, xy->xyR[0], xy->stride, n);
      spline1dbuildcatmullrom(&p->p, &tmp, n, 0, 0.0, &p->x, _state);
      ae_v_move(tmp.xR, 1, &xy->xyR[0][1], xy->stride, n);
      spline1dbuildcatmullrom(&p->p, &tmp, n, 0, 0.0, &p->y, _state);
   }
   if (st == 2) {
      ae_v_move(tmp.xR, 1, xy->xyR[0], xy->stride, n);
      spline1dbuildcubic(&p->p, &tmp, n, 0, 0.0, 0, 0.0, &p->x, _state);
      ae_v_move(tmp.xR, 1, &xy->xyR[0][1], xy->stride, n);
      spline1dbuildcubic(&p->p, &tmp, n, 0, 0.0, 0, 0.0, &p->y, _state);
   }
   ae_frame_leave(_state);
}

// This function  builds  non-periodic 3-dimensional parametric spline  which
// starts at (X[0],Y[0],Z[0]) and ends at (X[N-1],Y[N-1],Z[N-1]).
//
// Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
// description here.
// ALGLIB Project: Copyright 28.05.2010 by Sergey Bochkanov
// API: void pspline3build(const real_2d_array &xy, const ae_int_t n, const ae_int_t st, const ae_int_t pt, pspline3interpolant &p, const xparams _xparams = xdefault);
void pspline3build(RMatrix *xy, ae_int_t n, ae_int_t st, ae_int_t pt, pspline3interpolant *p, ae_state *_state) {
   ae_frame _frame_block;
   ae_frame_make(_state, &_frame_block);
   DupMatrix(xy, _state);
   SetObj(pspline3interpolant, p);
   NewVector(tmp, 0, DT_REAL, _state);
   ae_assert(st >= 0 && st <= 2, "PSpline3Build: incorrect spline type!", _state);
   ae_assert(pt >= 0 && pt <= 2, "PSpline3Build: incorrect parameterization type!", _state);
   if (st == 0) {
      ae_assert(n >= 5, "PSpline3Build: N<5 (minimum value for Akima splines)!", _state);
   } else {
      ae_assert(n >= 2, "PSpline3Build: N<2!", _state);
   }
// Prepare
   p->n = n;
   p->periodic = false;
   ae_vector_set_length(&tmp, n, _state);
// Build parameterization, check that all parameters are distinct
   parametric_pspline3par(xy, n, pt, &p->p, _state);
   ae_assert(aredistinct(&p->p, n, _state), "PSpline3Build: consequent points are too close!", _state);
// Build splines
   if (st == 0) {
      ae_v_move(tmp.xR, 1, xy->xyR[0], xy->stride, n);
      spline1dbuildakima(&p->p, &tmp, n, &p->x, _state);
      ae_v_move(tmp.xR, 1, &xy->xyR[0][1], xy->stride, n);
      spline1dbuildakima(&p->p, &tmp, n, &p->y, _state);
      ae_v_move(tmp.xR, 1, &xy->xyR[0][2], xy->stride, n);
      spline1dbuildakima(&p->p, &tmp, n, &p->z, _state);
   }
   if (st == 1) {
      ae_v_move(tmp.xR, 1, xy->xyR[0], xy->stride, n);
      spline1dbuildcatmullrom(&p->p, &tmp, n, 0, 0.0, &p->x, _state);
      ae_v_move(tmp.xR, 1, &xy->xyR[0][1], xy->stride, n);
      spline1dbuildcatmullrom(&p->p, &tmp, n, 0, 0.0, &p->y, _state);
      ae_v_move(tmp.xR, 1, &xy->xyR[0][2], xy->stride, n);
      spline1dbuildcatmullrom(&p->p, &tmp, n, 0, 0.0, &p->z, _state);
   }
   if (st == 2) {
      ae_v_move(tmp.xR, 1, xy->xyR[0], xy->stride, n);
      spline1dbuildcubic(&p->p, &tmp, n, 0, 0.0, 0, 0.0, &p->x, _state);
      ae_v_move(tmp.xR, 1, &xy->xyR[0][1], xy->stride, n);
      spline1dbuildcubic(&p->p, &tmp, n, 0, 0.0, 0, 0.0, &p->y, _state);
      ae_v_move(tmp.xR, 1, &xy->xyR[0][2], xy->stride, n);
      spline1dbuildcubic(&p->p, &tmp, n, 0, 0.0, 0, 0.0, &p->z, _state);
   }
   ae_frame_leave(_state);
}

// This  function  builds  periodic  2-dimensional  parametric  spline  which
// starts at (X[0],Y[0]), goes through all points to (X[N-1],Y[N-1]) and then
// back to (X[0],Y[0]).
//
// Inputs:
//     XY  -   points, array[0..N-1,0..1].
//             XY[I,0:1] corresponds to the Ith point.
//             XY[N-1,0:1] must be different from XY[0,0:1].
//             Order of points is important!
//     N   -   points count, N >= 3 for other types of splines.
//     ST  -   spline type:
//             * 1     Catmull-Rom spline (Tension=0) with cyclic boundary conditions
//             * 2     cubic spline with cyclic boundary conditions
//     PT  -   parameterization type:
//             * 0     uniform
//             * 1     chord length
//             * 2     centripetal
//
// Outputs:
//     P   -   parametric spline interpolant
//
//
// NOTES:
// * this function  assumes  that there all consequent points  are  distinct.
//   I.e. (x0,y0) != (x1,y1), (x1,y1) != (x2,y2),  (x2,y2) != (x3,y3)  and  so  on.
//   However, non-consequent points may coincide, i.e. we can  have  (x0,y0)=
//   =(x2,y2).
// * last point of sequence is NOT equal to the first  point.  You  shouldn't
//   make curve "explicitly periodic" by making them equal.
// ALGLIB Project: Copyright 28.05.2010 by Sergey Bochkanov
// API: void pspline2buildperiodic(const real_2d_array &xy, const ae_int_t n, const ae_int_t st, const ae_int_t pt, pspline2interpolant &p, const xparams _xparams = xdefault);
void pspline2buildperiodic(RMatrix *xy, ae_int_t n, ae_int_t st, ae_int_t pt, pspline2interpolant *p, ae_state *_state) {
   ae_frame _frame_block;
   ae_frame_make(_state, &_frame_block);
   DupMatrix(xy, _state);
   SetObj(pspline2interpolant, p);
   NewMatrix(xyp, 0, 0, DT_REAL, _state);
   NewVector(tmp, 0, DT_REAL, _state);
   ae_assert(st >= 1 && st <= 2, "PSpline2BuildPeriodic: incorrect spline type!", _state);
   ae_assert(pt >= 0 && pt <= 2, "PSpline2BuildPeriodic: incorrect parameterization type!", _state);
   ae_assert(n >= 3, "PSpline2BuildPeriodic: N<3!", _state);
// Prepare
   p->n = n;
   p->periodic = true;
   ae_vector_set_length(&tmp, n + 1, _state);
   ae_matrix_set_length(&xyp, n + 1, 2, _state);
   ae_v_move(xyp.xyR[0], xyp.stride, xy->xyR[0], xy->stride, n);
   ae_v_move(&xyp.xyR[0][1], xyp.stride, &xy->xyR[0][1], xy->stride, n);
   ae_v_move(xyp.xyR[n], 1, xy->xyR[0], 1, 1 + 1);
// Build parameterization, check that all parameters are distinct
   parametric_pspline2par(&xyp, n + 1, pt, &p->p, _state);
   ae_assert(aredistinct(&p->p, n + 1, _state), "PSpline2BuildPeriodic: consequent (or first and last) points are too close!", _state);
// Build splines
   if (st == 1) {
      ae_v_move(tmp.xR, 1, xyp.xyR[0], xyp.stride, n + 1);
      spline1dbuildcatmullrom(&p->p, &tmp, n + 1, -1, 0.0, &p->x, _state);
      ae_v_move(tmp.xR, 1, &xyp.xyR[0][1], xyp.stride, n + 1);
      spline1dbuildcatmullrom(&p->p, &tmp, n + 1, -1, 0.0, &p->y, _state);
   }
   if (st == 2) {
      ae_v_move(tmp.xR, 1, xyp.xyR[0], xyp.stride, n + 1);
      spline1dbuildcubic(&p->p, &tmp, n + 1, -1, 0.0, -1, 0.0, &p->x, _state);
      ae_v_move(tmp.xR, 1, &xyp.xyR[0][1], xyp.stride, n + 1);
      spline1dbuildcubic(&p->p, &tmp, n + 1, -1, 0.0, -1, 0.0, &p->y, _state);
   }
   ae_frame_leave(_state);
}

// This  function  builds  periodic  3-dimensional  parametric  spline  which
// starts at (X[0],Y[0],Z[0]), goes through all points to (X[N-1],Y[N-1],Z[N-1])
// and then back to (X[0],Y[0],Z[0]).
//
// Same as PSpline2Build() function, but for 3D, so we  won't  duplicate  its
// description here.
// ALGLIB Project: Copyright 28.05.2010 by Sergey Bochkanov
// API: void pspline3buildperiodic(const real_2d_array &xy, const ae_int_t n, const ae_int_t st, const ae_int_t pt, pspline3interpolant &p, const xparams _xparams = xdefault);
void pspline3buildperiodic(RMatrix *xy, ae_int_t n, ae_int_t st, ae_int_t pt, pspline3interpolant *p, ae_state *_state) {
   ae_frame _frame_block;
   ae_frame_make(_state, &_frame_block);
   DupMatrix(xy, _state);
   SetObj(pspline3interpolant, p);
   NewMatrix(xyp, 0, 0, DT_REAL, _state);
   NewVector(tmp, 0, DT_REAL, _state);
   ae_assert(st >= 1 && st <= 2, "PSpline3BuildPeriodic: incorrect spline type!", _state);
   ae_assert(pt >= 0 && pt <= 2, "PSpline3BuildPeriodic: incorrect parameterization type!", _state);
   ae_assert(n >= 3, "PSpline3BuildPeriodic: N<3!", _state);
// Prepare
   p->n = n;
   p->periodic = true;
   ae_vector_set_length(&tmp, n + 1, _state);
   ae_matrix_set_length(&xyp, n + 1, 3, _state);
   ae_v_move(xyp.xyR[0], xyp.stride, xy->xyR[0], xy->stride, n);
   ae_v_move(&xyp.xyR[0][1], xyp.stride, &xy->xyR[0][1], xy->stride, n);
   ae_v_move(&xyp.xyR[0][2], xyp.stride, &xy->xyR[0][2], xy->stride, n);
   ae_v_move(xyp.xyR[n], 1, xy->xyR[0], 1, 2 + 1);
// Build parameterization, check that all parameters are distinct
   parametric_pspline3par(&xyp, n + 1, pt, &p->p, _state);
   ae_assert(aredistinct(&p->p, n + 1, _state), "PSplineBuild2Periodic: consequent (or first and last) points are too close!", _state);
// Build splines
   if (st == 1) {
      ae_v_move(tmp.xR, 1, xyp.xyR[0], xyp.stride, n + 1);
      spline1dbuildcatmullrom(&p->p, &tmp, n + 1, -1, 0.0, &p->x, _state);
      ae_v_move(tmp.xR, 1, &xyp.xyR[0][1], xyp.stride, n + 1);
      spline1dbuildcatmullrom(&p->p, &tmp, n + 1, -1, 0.0, &p->y, _state);
      ae_v_move(tmp.xR, 1, &xyp.xyR[0][2], xyp.stride, n + 1);
      spline1dbuildcatmullrom(&p->p, &tmp, n + 1, -1, 0.0, &p->z, _state);
   }
   if (st == 2) {
      ae_v_move(tmp.xR, 1, xyp.xyR[0], xyp.stride, n + 1);
      spline1dbuildcubic(&p->p, &tmp, n + 1, -1, 0.0, -1, 0.0, &p->x, _state);
      ae_v_move(tmp.xR, 1, &xyp.xyR[0][1], xyp.stride, n + 1);
      spline1dbuildcubic(&p->p, &tmp, n + 1, -1, 0.0, -1, 0.0, &p->y, _state);
      ae_v_move(tmp.xR, 1, &xyp.xyR[0][2], xyp.stride, n + 1);
      spline1dbuildcubic(&p->p, &tmp, n + 1, -1, 0.0, -1, 0.0, &p->z, _state);
   }
   ae_frame_leave(_state);
}

// This function returns vector of parameter values correspoding to points.
//
// I.e. for P created from (X[0],Y[0])...(X[N-1],Y[N-1]) and U=TValues(P)  we
// have
//     (X[0],Y[0]) = PSpline2Calc(P,U[0]),
//     (X[1],Y[1]) = PSpline2Calc(P,U[1]),
//     (X[2],Y[2]) = PSpline2Calc(P,U[2]),
//     ...
//
// Inputs:
//     P   -   parametric spline interpolant
//
// Outputs:
//     N   -   array size
//     T   -   array[0..N-1]
//
//
// NOTES:
// * for non-periodic splines U[0]=0, U[0]<U[1]<...<U[N-1], U[N-1]=1
// * for periodic splines     U[0]=0, U[0]<U[1]<...<U[N-1], U[N-1]<1
// ALGLIB Project: Copyright 28.05.2010 by Sergey Bochkanov
// API: void pspline2parametervalues(const pspline2interpolant &p, ae_int_t &n, real_1d_array &t, const xparams _xparams = xdefault);
void pspline2parametervalues(pspline2interpolant *p, ae_int_t *n, RVector *t, ae_state *_state) {
   *n = 0;
   SetVector(t);
   ae_assert(p->n >= 2, "PSpline2ParameterValues: internal error!", _state);
   *n = p->n;
   ae_vector_set_length(t, *n, _state);
   ae_v_move(t->xR, 1, p->p.xR, 1, *n);
   t->xR[0] = 0.0;
   if (!p->periodic) {
      t->xR[*n - 1] = 1.0;
   }
}

// This function returns vector of parameter values correspoding to points.
//
// Same as PSpline2ParameterValues(), but for 3D.
// ALGLIB Project: Copyright 28.05.2010 by Sergey Bochkanov
// API: void pspline3parametervalues(const pspline3interpolant &p, ae_int_t &n, real_1d_array &t, const xparams _xparams = xdefault);
void pspline3parametervalues(pspline3interpolant *p, ae_int_t *n, RVector *t, ae_state *_state) {
   *n = 0;
   SetVector(t);
   ae_assert(p->n >= 2, "PSpline3ParameterValues: internal error!", _state);
   *n = p->n;
   ae_vector_set_length(t, *n, _state);
   ae_v_move(t->xR, 1, p->p.xR, 1, *n);
   t->xR[0] = 0.0;
   if (!p->periodic) {
      t->xR[*n - 1] = 1.0;
   }
}

// This function  calculates  the value of the parametric spline for a  given
// value of parameter T
//
// Inputs:
//     P   -   parametric spline interpolant
//     T   -   point:
//             * T in [0,1] corresponds to interval spanned by points
//             * for non-periodic splines T<0 (or T>1) correspond to parts of
//               the curve before the first (after the last) point
//             * for periodic splines T<0 (or T>1) are projected  into  [0,1]
//               by making T=T-floor(T).
//
// Outputs:
//     X   -   X-position
//     Y   -   Y-position
// ALGLIB Project: Copyright 28.05.2010 by Sergey Bochkanov
// API: void pspline2calc(const pspline2interpolant &p, const double t, double &x, double &y, const xparams _xparams = xdefault);
void pspline2calc(pspline2interpolant *p, double t, double *x, double *y, ae_state *_state) {
   *x = 0;
   *y = 0;
   if (p->periodic) {
      t -= ifloor(t, _state);
   }
   *x = spline1dcalc(&p->x, t, _state);
   *y = spline1dcalc(&p->y, t, _state);
}

// This function  calculates  the value of the parametric spline for a  given
// value of parameter T.
//
// Inputs:
//     P   -   parametric spline interpolant
//     T   -   point:
//             * T in [0,1] corresponds to interval spanned by points
//             * for non-periodic splines T<0 (or T>1) correspond to parts of
//               the curve before the first (after the last) point
//             * for periodic splines T<0 (or T>1) are projected  into  [0,1]
//               by making T=T-floor(T).
//
// Outputs:
//     X   -   X-position
//     Y   -   Y-position
//     Z   -   Z-position
// ALGLIB Project: Copyright 28.05.2010 by Sergey Bochkanov
// API: void pspline3calc(const pspline3interpolant &p, const double t, double &x, double &y, double &z, const xparams _xparams = xdefault);
void pspline3calc(pspline3interpolant *p, double t, double *x, double *y, double *z, ae_state *_state) {
   *x = 0;
   *y = 0;
   *z = 0;
   if (p->periodic) {
      t -= ifloor(t, _state);
   }
   *x = spline1dcalc(&p->x, t, _state);
   *y = spline1dcalc(&p->y, t, _state);
   *z = spline1dcalc(&p->z, t, _state);
}

// This function calculates derivative, i.e. it returns (dX/dT,dY/dT).
//
// Inputs:
//     P   -   parametric spline interpolant
//     T   -   point:
//             * T in [0,1] corresponds to interval spanned by points
//             * for non-periodic splines T<0 (or T>1) correspond to parts of
//               the curve before the first (after the last) point
//             * for periodic splines T<0 (or T>1) are projected  into  [0,1]
//               by making T=T-floor(T).
//
// Outputs:
//     X   -   X-value
//     DX  -   X-derivative
//     Y   -   Y-value
//     DY  -   Y-derivative
// ALGLIB Project: Copyright 28.05.2010 by Sergey Bochkanov
// API: void pspline2diff(const pspline2interpolant &p, const double t, double &x, double &dx, double &y, double &dy, const xparams _xparams = xdefault);
void pspline2diff(pspline2interpolant *p, double t, double *x, double *dx, double *y, double *dy, ae_state *_state) {
   double d2s;
   *x = 0;
   *dx = 0;
   *y = 0;
   *dy = 0;
   if (p->periodic) {
      t -= ifloor(t, _state);
   }
   spline1ddiff(&p->x, t, x, dx, &d2s, _state);
   spline1ddiff(&p->y, t, y, dy, &d2s, _state);
}

// This function calculates derivative, i.e. it returns (dX/dT,dY/dT,dZ/dT).
//
// Inputs:
//     P   -   parametric spline interpolant
//     T   -   point:
//             * T in [0,1] corresponds to interval spanned by points
//             * for non-periodic splines T<0 (or T>1) correspond to parts of
//               the curve before the first (after the last) point
//             * for periodic splines T<0 (or T>1) are projected  into  [0,1]
//               by making T=T-floor(T).
//
// Outputs:
//     X   -   X-value
//     DX  -   X-derivative
//     Y   -   Y-value
//     DY  -   Y-derivative
//     Z   -   Z-value
//     DZ  -   Z-derivative
// ALGLIB Project: Copyright 28.05.2010 by Sergey Bochkanov
// API: void pspline3diff(const pspline3interpolant &p, const double t, double &x, double &dx, double &y, double &dy, double &z, double &dz, const xparams _xparams = xdefault);
void pspline3diff(pspline3interpolant *p, double t, double *x, double *dx, double *y, double *dy, double *z, double *dz, ae_state *_state) {
   double d2s;
   *x = 0;
   *dx = 0;
   *y = 0;
   *dy = 0;
   *z = 0;
   *dz = 0;
   if (p->periodic) {
      t -= ifloor(t, _state);
   }
   spline1ddiff(&p->x, t, x, dx, &d2s, _state);
   spline1ddiff(&p->y, t, y, dy, &d2s, _state);
   spline1ddiff(&p->z, t, z, dz, &d2s, _state);
}

// This function  calculates  tangent vector for a given value of parameter T
//
// Inputs:
//     P   -   parametric spline interpolant
//     T   -   point:
//             * T in [0,1] corresponds to interval spanned by points
//             * for non-periodic splines T<0 (or T>1) correspond to parts of
//               the curve before the first (after the last) point
//             * for periodic splines T<0 (or T>1) are projected  into  [0,1]
//               by making T=T-floor(T).
//
// Outputs:
//     X    -   X-component of tangent vector (normalized)
//     Y    -   Y-component of tangent vector (normalized)
//
// NOTE:
//     X^2+Y^2 is either 1 (for non-zero tangent vector) or 0.
// ALGLIB Project: Copyright 28.05.2010 by Sergey Bochkanov
// API: void pspline2tangent(const pspline2interpolant &p, const double t, double &x, double &y, const xparams _xparams = xdefault);
void pspline2tangent(pspline2interpolant *p, double t, double *x, double *y, ae_state *_state) {
   double v;
   double v0;
   double v1;
   *x = 0;
   *y = 0;
   if (p->periodic) {
      t -= ifloor(t, _state);
   }
   pspline2diff(p, t, &v0, x, &v1, y, _state);
   if (*x != 0.0 || *y != 0.0) {
   // this code is a bit more complex than X^2+Y^2 to avoid
   // overflow for large values of X and Y.
      v = safepythag2(*x, *y, _state);
      *x /= v;
      *y /= v;
   }
}

// This function  calculates  tangent vector for a given value of parameter T
//
// Inputs:
//     P   -   parametric spline interpolant
//     T   -   point:
//             * T in [0,1] corresponds to interval spanned by points
//             * for non-periodic splines T<0 (or T>1) correspond to parts of
//               the curve before the first (after the last) point
//             * for periodic splines T<0 (or T>1) are projected  into  [0,1]
//               by making T=T-floor(T).
//
// Outputs:
//     X    -   X-component of tangent vector (normalized)
//     Y    -   Y-component of tangent vector (normalized)
//     Z    -   Z-component of tangent vector (normalized)
//
// NOTE:
//     X^2+Y^2+Z^2 is either 1 (for non-zero tangent vector) or 0.
// ALGLIB Project: Copyright 28.05.2010 by Sergey Bochkanov
// API: void pspline3tangent(const pspline3interpolant &p, const double t, double &x, double &y, double &z, const xparams _xparams = xdefault);
void pspline3tangent(pspline3interpolant *p, double t, double *x, double *y, double *z, ae_state *_state) {
   double v;
   double v0;
   double v1;
   double v2;
   *x = 0;
   *y = 0;
   *z = 0;
   if (p->periodic) {
      t -= ifloor(t, _state);
   }
   pspline3diff(p, t, &v0, x, &v1, y, &v2, z, _state);
   if ((*x != 0.0 || *y != 0.0) || *z != 0.0) {
      v = safepythag3(*x, *y, *z, _state);
      *x /= v;
      *y /= v;
      *z /= v;
   }
}

// This function calculates first and second derivative with respect to T.
//
// Inputs:
//     P   -   parametric spline interpolant
//     T   -   point:
//             * T in [0,1] corresponds to interval spanned by points
//             * for non-periodic splines T<0 (or T>1) correspond to parts of
//               the curve before the first (after the last) point
//             * for periodic splines T<0 (or T>1) are projected  into  [0,1]
//               by making T=T-floor(T).
//
// Outputs:
//     X   -   X-value
//     DX  -   derivative
//     D2X -   second derivative
//     Y   -   Y-value
//     DY  -   derivative
//     D2Y -   second derivative
// ALGLIB Project: Copyright 28.05.2010 by Sergey Bochkanov
// API: void pspline2diff2(const pspline2interpolant &p, const double t, double &x, double &dx, double &d2x, double &y, double &dy, double &d2y, const xparams _xparams = xdefault);
void pspline2diff2(pspline2interpolant *p, double t, double *x, double *dx, double *d2x, double *y, double *dy, double *d2y, ae_state *_state) {
   *x = 0;
   *dx = 0;
   *d2x = 0;
   *y = 0;
   *dy = 0;
   *d2y = 0;
   if (p->periodic) {
      t -= ifloor(t, _state);
   }
   spline1ddiff(&p->x, t, x, dx, d2x, _state);
   spline1ddiff(&p->y, t, y, dy, d2y, _state);
}

// This function calculates first and second derivative with respect to T.
//
// Inputs:
//     P   -   parametric spline interpolant
//     T   -   point:
//             * T in [0,1] corresponds to interval spanned by points
//             * for non-periodic splines T<0 (or T>1) correspond to parts of
//               the curve before the first (after the last) point
//             * for periodic splines T<0 (or T>1) are projected  into  [0,1]
//               by making T=T-floor(T).
//
// Outputs:
//     X   -   X-value
//     DX  -   derivative
//     D2X -   second derivative
//     Y   -   Y-value
//     DY  -   derivative
//     D2Y -   second derivative
//     Z   -   Z-value
//     DZ  -   derivative
//     D2Z -   second derivative
// ALGLIB Project: Copyright 28.05.2010 by Sergey Bochkanov
// API: void pspline3diff2(const pspline3interpolant &p, const double t, double &x, double &dx, double &d2x, double &y, double &dy, double &d2y, double &z, double &dz, double &d2z, const xparams _xparams = xdefault);
void pspline3diff2(pspline3interpolant *p, double t, double *x, double *dx, double *d2x, double *y, double *dy, double *d2y, double *z, double *dz, double *d2z, ae_state *_state) {
   *x = 0;
   *dx = 0;
   *d2x = 0;
   *y = 0;
   *dy = 0;
   *d2y = 0;
   *z = 0;
   *dz = 0;
   *d2z = 0;
   if (p->periodic) {
      t -= ifloor(t, _state);
   }
   spline1ddiff(&p->x, t, x, dx, d2x, _state);
   spline1ddiff(&p->y, t, y, dy, d2y, _state);
   spline1ddiff(&p->z, t, z, dz, d2z, _state);
}

// This function  calculates  arc length, i.e. length of  curve  between  t=a
// and t=b.
//
// Inputs:
//     P   -   parametric spline interpolant
//     A,B -   parameter values corresponding to arc ends:
//             * B>A will result in positive length returned
//             * B<A will result in negative length returned
//
// Result:
//     length of arc starting at T=A and ending at T=B.
// ALGLIB Project: Copyright 30.05.2010 by Sergey Bochkanov
// API: double pspline2arclength(const pspline2interpolant &p, const double a, const double b, const xparams _xparams = xdefault);
double pspline2arclength(pspline2interpolant *p, double a, double b, ae_state *_state) {
   ae_frame _frame_block;
   double sx;
   double dsx;
   double d2sx;
   double sy;
   double dsy;
   double d2sy;
   double result;
   ae_frame_make(_state, &_frame_block);
   NewObj(autogkstate, state, _state);
   NewObj(autogkreport, rep, _state);
   autogksmooth(a, b, &state, _state);
   while (autogkiteration(&state, _state)) {
      spline1ddiff(&p->x, state.x, &sx, &dsx, &d2sx, _state);
      spline1ddiff(&p->y, state.x, &sy, &dsy, &d2sy, _state);
      state.f = safepythag2(dsx, dsy, _state);
   }
   autogkresults(&state, &result, &rep, _state);
   ae_assert(rep.terminationtype > 0, "PSpline2ArcLength: internal error!", _state);
   ae_frame_leave(_state);
   return result;
}

// This function  calculates  arc length, i.e. length of  curve  between  t=a
// and t=b.
//
// Inputs:
//     P   -   parametric spline interpolant
//     A,B -   parameter values corresponding to arc ends:
//             * B>A will result in positive length returned
//             * B<A will result in negative length returned
//
// Result:
//     length of arc starting at T=A and ending at T=B.
// ALGLIB Project: Copyright 30.05.2010 by Sergey Bochkanov
// API: double pspline3arclength(const pspline3interpolant &p, const double a, const double b, const xparams _xparams = xdefault);
double pspline3arclength(pspline3interpolant *p, double a, double b, ae_state *_state) {
   ae_frame _frame_block;
   double sx;
   double dsx;
   double d2sx;
   double sy;
   double dsy;
   double d2sy;
   double sz;
   double dsz;
   double d2sz;
   double result;
   ae_frame_make(_state, &_frame_block);
   NewObj(autogkstate, state, _state);
   NewObj(autogkreport, rep, _state);
   autogksmooth(a, b, &state, _state);
   while (autogkiteration(&state, _state)) {
      spline1ddiff(&p->x, state.x, &sx, &dsx, &d2sx, _state);
      spline1ddiff(&p->y, state.x, &sy, &dsy, &d2sy, _state);
      spline1ddiff(&p->z, state.x, &sz, &dsz, &d2sz, _state);
      state.f = safepythag3(dsx, dsy, dsz, _state);
   }
   autogkresults(&state, &result, &rep, _state);
   ae_assert(rep.terminationtype > 0, "PSpline3ArcLength: internal error!", _state);
   ae_frame_leave(_state);
   return result;
}

// This function analyzes section of curve for processing by RDP algorithm:
// given set of points X,Y with indexes [I0,I1] it returns point with
// worst deviation from linear model (PARAMETRIC version which sees curve
// as X(t) with vector X).
//
// Inputs:
//     XY          -   array
//     I0,I1       -   interval (boundaries included) to process
//     D           -   number of dimensions
//
// Outputs:
//     WorstIdx    -   index of worst point
//     WorstError  -   error at worst point
//
// NOTE: this function guarantees that it returns exactly zero for a section
//       with less than 3 points.
// ALGLIB Project: Copyright 02.10.2014 by Sergey Bochkanov
static void parametric_rdpanalyzesectionpar(RMatrix *xy, ae_int_t i0, ae_int_t i1, ae_int_t d, ae_int_t *worstidx, double *worsterror, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   double v;
   double d2;
   double ts;
   double vv;
   *worstidx = 0;
   *worsterror = 0;
// Quick exit for 0, 1, 2 points
   if (i1 - i0 + 1 < 3) {
      *worstidx = i0;
      *worsterror = 0.0;
      return;
   }
// Estimate D2 - squared distance between XY[I1] and XY[I0].
// In case D2=0 handle it as special case.
   d2 = 0.0;
   for (j = 0; j < d; j++) {
      d2 += sqr(xy->xyR[i1][j] - xy->xyR[i0][j], _state);
   }
   if (d2 == 0.0) {
   // First and last points are equal, interval evaluation is
   // trivial - we just calculate distance from all points to
   // the first/last one.
      *worstidx = i0;
      *worsterror = 0.0;
      for (i = i0 + 1; i < i1; i++) {
         vv = 0.0;
         for (j = 0; j < d; j++) {
            v = xy->xyR[i][j] - xy->xyR[i0][j];
            vv += v * v;
         }
         vv = ae_sqrt(vv, _state);
         if (vv > *worsterror) {
            *worsterror = vv;
            *worstidx = i;
         }
      }
      return;
   }
// General case
//
// Current section of curve is modeled as x(t) = d*t+c, where
//     d = XY[I1]-XY[I0]
//     c = XY[I0]
//     t is in [0,1]
   *worstidx = i0;
   *worsterror = 0.0;
   for (i = i0 + 1; i < i1; i++) {
   // Determine t_s - parameter value for projected point.
      ts = (double)(i - i0) / (i1 - i0);
   // Estimate error norm
      vv = 0.0;
      for (j = 0; j < d; j++) {
         v = (xy->xyR[i1][j] - xy->xyR[i0][j]) * ts - (xy->xyR[i][j] - xy->xyR[i0][j]);
         vv += sqr(v, _state);
      }
      vv = ae_sqrt(vv, _state);
      if (vv > *worsterror) {
         *worsterror = vv;
         *worstidx = i;
      }
   }
}

// This  subroutine fits piecewise linear curve to points with Ramer-Douglas-
// Peucker algorithm. This  function  performs PARAMETRIC fit, i.e. it can be
// used to fit curves like circles.
//
// On  input  it  accepts dataset which describes parametric multidimensional
// curve X(t), with X being vector, and t taking values in [0,N), where N  is
// a number of points in dataset. As result, it returns reduced  dataset  X2,
// which can be used to build  parametric  curve  X2(t),  which  approximates
// X(t) with desired precision (or has specified number of sections).
//
//
// Inputs:
//     X       -   array of multidimensional points:
//                 * at least N elements, leading N elements are used if more
//                   than N elements were specified
//                 * order of points is IMPORTANT because  it  is  parametric
//                   fit
//                 * each row of array is one point which has D coordinates
//     N       -   number of elements in X
//     D       -   number of dimensions (elements per row of X)
//     StopM   -   stopping condition - desired number of sections:
//                 * at most M sections are generated by this function
//                 * less than M sections can be generated if we have N<M
//                   (or some X are non-distinct).
//                 * zero StopM means that algorithm does not stop after
//                   achieving some pre-specified section count
//     StopEps -   stopping condition - desired precision:
//                 * algorithm stops after error in each section is at most Eps
//                 * zero Eps means that algorithm does not stop after
//                   achieving some pre-specified precision
//
// Outputs:
//     X2      -   array of corner points for piecewise approximation,
//                 has length NSections+1 or zero (for NSections=0).
//     Idx2    -   array of indexes (parameter values):
//                 * has length NSections+1 or zero (for NSections=0).
//                 * each element of Idx2 corresponds to same-numbered
//                   element of X2
//                 * each element of Idx2 is index of  corresponding  element
//                   of X2 at original array X, i.e. I-th  row  of  X2  is
//                   Idx2[I]-th row of X.
//                 * elements of Idx2 can be treated as parameter values
//                   which should be used when building new parametric curve
//                 * Idx2[0]=0, Idx2[NSections]=N-1
//     NSections-  number of sections found by algorithm, NSections <= M,
//                 NSections can be zero for degenerate datasets
//                 (N <= 1 or all X[] are non-distinct).
//
// NOTE: algorithm stops after:
//       a) dividing curve into StopM sections
//       b) achieving required precision StopEps
//       c) dividing curve into N-1 sections
//       If both StopM and StopEps are non-zero, algorithm is stopped by  the
//       FIRST criterion which is satisfied. In case both StopM  and  StopEps
//       are zero, algorithm stops because of (c).
// ALGLIB: Copyright 02.10.2014 by Sergey Bochkanov
// API: void parametricrdpfixed(const real_2d_array &x, const ae_int_t n, const ae_int_t d, const ae_int_t stopm, const double stopeps, real_2d_array &x2, integer_1d_array &idx2, ae_int_t &nsections, const xparams _xparams = xdefault);
void parametricrdpfixed(RMatrix *x, ae_int_t n, ae_int_t d, ae_int_t stopm, double stopeps, RMatrix *x2, ZVector *idx2, ae_int_t *nsections, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   bool allsame;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t k2;
   double e0;
   double e1;
   ae_int_t idx0;
   ae_int_t idx1;
   ae_int_t worstidx;
   double worsterror;
   ae_frame_make(_state, &_frame_block);
   SetMatrix(x2);
   SetVector(idx2);
   *nsections = 0;
   NewMatrix(sections, 0, 0, DT_REAL, _state);
   NewVector(heaperrors, 0, DT_REAL, _state);
   NewVector(heaptags, 0, DT_INT, _state);
   NewVector(buf0, 0, DT_REAL, _state);
   NewVector(buf1, 0, DT_REAL, _state);
   ae_assert(n >= 0, "LSTFitPiecewiseLinearParametricRDP: N<0", _state);
   ae_assert(d >= 1, "LSTFitPiecewiseLinearParametricRDP: D <= 0", _state);
   ae_assert(stopm >= 0, "LSTFitPiecewiseLinearParametricRDP: StopM<1", _state);
   ae_assert(ae_isfinite(stopeps, _state) && stopeps >= 0.0, "LSTFitPiecewiseLinearParametricRDP: StopEps<0 or is infinite", _state);
   ae_assert(x->rows >= n, "LSTFitPiecewiseLinearParametricRDP: Rows(X)<N", _state);
   ae_assert(x->cols >= d, "LSTFitPiecewiseLinearParametricRDP: Cols(X)<D", _state);
   ae_assert(apservisfinitematrix(x, n, d, _state), "LSTFitPiecewiseLinearParametricRDP: X contains infinite/NAN values", _state);
// Handle degenerate cases
   if (n <= 1) {
      *nsections = 0;
      ae_frame_leave(_state);
      return;
   }
   allsame = true;
   for (i = 1; i < n; i++) {
      for (j = 0; j < d; j++) {
         allsame = allsame && x->xyR[i][j] == x->xyR[0][j];
      }
   }
   if (allsame) {
      *nsections = 0;
      ae_frame_leave(_state);
      return;
   }
// Prepare first section
   parametric_rdpanalyzesectionpar(x, 0, n - 1, d, &worstidx, &worsterror, _state);
   ae_matrix_set_length(&sections, n, 4, _state);
   ae_vector_set_length(&heaperrors, n, _state);
   ae_vector_set_length(&heaptags, n, _state);
   *nsections = 1;
   sections.xyR[0][0] = 0.0;
   sections.xyR[0][1] = (double)(n - 1);
   sections.xyR[0][2] = (double)worstidx;
   sections.xyR[0][3] = worsterror;
   heaperrors.xR[0] = worsterror;
   heaptags.xZ[0] = 0;
   ae_assert(sections.xyR[0][1] == (double)(n - 1), "RDP algorithm: integrity check failed", _state);
// Main loop.
// Repeatedly find section with worst error and divide it.
// Terminate after M-th section, or because of other reasons (see loop internals).
   while (true) {
   // Break loop if one of the stopping conditions was met.
   // Store index of worst section to K.
      if (heaperrors.xR[0] == 0.0) {
         break;
      }
      if (stopeps > 0.0 && heaperrors.xR[0] <= stopeps) {
         break;
      }
      if (stopm > 0 && *nsections >= stopm) {
         break;
      }
      k = heaptags.xZ[0];
   // K-th section is divided in two:
   // * first  one spans interval from X[Sections[K,0]] to X[Sections[K,2]]
   // * second one spans interval from X[Sections[K,2]] to X[Sections[K,1]]
   //
   // First section is stored at K-th position, second one is appended to the table.
   // Then we update heap which stores pairs of (error,section_index)
      k0 = iround(sections.xyR[k][0], _state);
      k1 = iround(sections.xyR[k][1], _state);
      k2 = iround(sections.xyR[k][2], _state);
      parametric_rdpanalyzesectionpar(x, k0, k2, d, &idx0, &e0, _state);
      parametric_rdpanalyzesectionpar(x, k2, k1, d, &idx1, &e1, _state);
      sections.xyR[k][0] = (double)k0;
      sections.xyR[k][1] = (double)k2;
      sections.xyR[k][2] = (double)idx0;
      sections.xyR[k][3] = e0;
      tagheapreplacetopi(&heaperrors, &heaptags, *nsections, e0, k, _state);
      sections.xyR[*nsections][0] = (double)k2;
      sections.xyR[*nsections][1] = (double)k1;
      sections.xyR[*nsections][2] = (double)idx1;
      sections.xyR[*nsections][3] = e1;
      tagheappushi(&heaperrors, &heaptags, nsections, e1, *nsections, _state);
   }
// Convert from sections to indexes
   ae_vector_set_length(&buf0, *nsections + 1, _state);
   for (i = 0; i < *nsections; i++) {
      buf0.xR[i] = round(sections.xyR[i][0]);
   }
   buf0.xR[*nsections] = (double)(n - 1);
   tagsortfast(&buf0, &buf1, *nsections + 1, _state);
   ae_vector_set_length(idx2, *nsections + 1, _state);
   for (i = 0; i <= *nsections; i++) {
      idx2->xZ[i] = iround(buf0.xR[i], _state);
   }
   ae_assert(idx2->xZ[0] == 0, "RDP algorithm: integrity check failed", _state);
   ae_assert(idx2->xZ[*nsections] == n - 1, "RDP algorithm: integrity check failed", _state);
// Output sections:
// * first NSection elements of X2/Y2 are filled by x/y at left boundaries of sections
// * last element of X2/Y2 is filled by right boundary of rightmost section
// * X2/Y2 is sorted by ascending of X2
   ae_matrix_set_length(x2, *nsections + 1, d, _state);
   for (i = 0; i <= *nsections; i++) {
      for (j = 0; j < d; j++) {
         x2->xyR[i][j] = x->xyR[idx2->xZ[i]][j];
      }
   }
   ae_frame_leave(_state);
}

void pspline2interpolant_init(void *_p, ae_state *_state, bool make_automatic) {
   pspline2interpolant *p = (pspline2interpolant *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->p, 0, DT_REAL, _state, make_automatic);
   spline1dinterpolant_init(&p->x, _state, make_automatic);
   spline1dinterpolant_init(&p->y, _state, make_automatic);
}

void pspline2interpolant_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   pspline2interpolant *dst = (pspline2interpolant *)_dst;
   pspline2interpolant *src = (pspline2interpolant *)_src;
   dst->n = src->n;
   dst->periodic = src->periodic;
   ae_vector_copy(&dst->p, &src->p, _state, make_automatic);
   spline1dinterpolant_copy(&dst->x, &src->x, _state, make_automatic);
   spline1dinterpolant_copy(&dst->y, &src->y, _state, make_automatic);
}

void pspline2interpolant_free(void *_p, bool make_automatic) {
   pspline2interpolant *p = (pspline2interpolant *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->p, make_automatic);
   spline1dinterpolant_free(&p->x, make_automatic);
   spline1dinterpolant_free(&p->y, make_automatic);
}

void pspline3interpolant_init(void *_p, ae_state *_state, bool make_automatic) {
   pspline3interpolant *p = (pspline3interpolant *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->p, 0, DT_REAL, _state, make_automatic);
   spline1dinterpolant_init(&p->x, _state, make_automatic);
   spline1dinterpolant_init(&p->y, _state, make_automatic);
   spline1dinterpolant_init(&p->z, _state, make_automatic);
}

void pspline3interpolant_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   pspline3interpolant *dst = (pspline3interpolant *)_dst;
   pspline3interpolant *src = (pspline3interpolant *)_src;
   dst->n = src->n;
   dst->periodic = src->periodic;
   ae_vector_copy(&dst->p, &src->p, _state, make_automatic);
   spline1dinterpolant_copy(&dst->x, &src->x, _state, make_automatic);
   spline1dinterpolant_copy(&dst->y, &src->y, _state, make_automatic);
   spline1dinterpolant_copy(&dst->z, &src->z, _state, make_automatic);
}

void pspline3interpolant_free(void *_p, bool make_automatic) {
   pspline3interpolant *p = (pspline3interpolant *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->p, make_automatic);
   spline1dinterpolant_free(&p->x, make_automatic);
   spline1dinterpolant_free(&p->y, make_automatic);
   spline1dinterpolant_free(&p->z, make_automatic);
}
} // end of namespace alglib_impl

namespace alglib {
// Parametric spline inteprolant: 2-dimensional curve.
//
// You should not try to access its members directly - use PSpline2XXXXXXXX()
// functions instead.
DefClass(pspline2interpolant, )

// Parametric spline inteprolant: 3-dimensional curve.
//
// You should not try to access its members directly - use PSpline3XXXXXXXX()
// functions instead.
DefClass(pspline3interpolant, )

void pspline2build(const real_2d_array &xy, const ae_int_t n, const ae_int_t st, const ae_int_t pt, pspline2interpolant &p, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::pspline2build(ConstT(ae_matrix, xy), n, st, pt, ConstT(pspline2interpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void pspline3build(const real_2d_array &xy, const ae_int_t n, const ae_int_t st, const ae_int_t pt, pspline3interpolant &p, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::pspline3build(ConstT(ae_matrix, xy), n, st, pt, ConstT(pspline3interpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void pspline2buildperiodic(const real_2d_array &xy, const ae_int_t n, const ae_int_t st, const ae_int_t pt, pspline2interpolant &p, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::pspline2buildperiodic(ConstT(ae_matrix, xy), n, st, pt, ConstT(pspline2interpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void pspline3buildperiodic(const real_2d_array &xy, const ae_int_t n, const ae_int_t st, const ae_int_t pt, pspline3interpolant &p, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::pspline3buildperiodic(ConstT(ae_matrix, xy), n, st, pt, ConstT(pspline3interpolant, p), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void pspline2parametervalues(const pspline2interpolant &p, ae_int_t &n, real_1d_array &t, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::pspline2parametervalues(ConstT(pspline2interpolant, p), &n, ConstT(ae_vector, t), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void pspline3parametervalues(const pspline3interpolant &p, ae_int_t &n, real_1d_array &t, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::pspline3parametervalues(ConstT(pspline3interpolant, p), &n, ConstT(ae_vector, t), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void pspline2calc(const pspline2interpolant &p, const double t, double &x, double &y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::pspline2calc(ConstT(pspline2interpolant, p), t, &x, &y, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void pspline3calc(const pspline3interpolant &p, const double t, double &x, double &y, double &z, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::pspline3calc(ConstT(pspline3interpolant, p), t, &x, &y, &z, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void pspline2diff(const pspline2interpolant &p, const double t, double &x, double &dx, double &y, double &dy, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::pspline2diff(ConstT(pspline2interpolant, p), t, &x, &dx, &y, &dy, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void pspline3diff(const pspline3interpolant &p, const double t, double &x, double &dx, double &y, double &dy, double &z, double &dz, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::pspline3diff(ConstT(pspline3interpolant, p), t, &x, &dx, &y, &dy, &z, &dz, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void pspline2tangent(const pspline2interpolant &p, const double t, double &x, double &y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::pspline2tangent(ConstT(pspline2interpolant, p), t, &x, &y, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void pspline3tangent(const pspline3interpolant &p, const double t, double &x, double &y, double &z, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::pspline3tangent(ConstT(pspline3interpolant, p), t, &x, &y, &z, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void pspline2diff2(const pspline2interpolant &p, const double t, double &x, double &dx, double &d2x, double &y, double &dy, double &d2y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::pspline2diff2(ConstT(pspline2interpolant, p), t, &x, &dx, &d2x, &y, &dy, &d2y, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void pspline3diff2(const pspline3interpolant &p, const double t, double &x, double &dx, double &d2x, double &y, double &dy, double &d2y, double &z, double &dz, double &d2z, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::pspline3diff2(ConstT(pspline3interpolant, p), t, &x, &dx, &d2x, &y, &dy, &d2y, &z, &dz, &d2z, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

double pspline2arclength(const pspline2interpolant &p, const double a, const double b, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::pspline2arclength(ConstT(pspline2interpolant, p), a, b, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

double pspline3arclength(const pspline3interpolant &p, const double a, const double b, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::pspline3arclength(ConstT(pspline3interpolant, p), a, b, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

void parametricrdpfixed(const real_2d_array &x, const ae_int_t n, const ae_int_t d, const ae_int_t stopm, const double stopeps, real_2d_array &x2, integer_1d_array &idx2, ae_int_t &nsections, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::parametricrdpfixed(ConstT(ae_matrix, x), n, d, stopm, stopeps, ConstT(ae_matrix, x2), ConstT(ae_vector, idx2), &nsections, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
} // end of namespace alglib

// === RBFV1 Package ===
// Depends on: (AlgLibMisc) NEARESTNEIGHBOR
// Depends on: LSFIT
namespace alglib_impl {
static const ae_int_t rbfv1_mxnx = 3;
static const double rbfv1_rbffarradius = 6.0;
static const double rbfv1_rbfnearradius = 2.1;
static const double rbfv1_rbfmlradius = 3.0;
static const double rbfv1_minbasecasecost = 100000.0;

// This function creates RBF  model  for  a  scalar (NY=1)  or  vector (NY>1)
// function in a NX-dimensional space (NX=2 or NX=3).
//
// Inputs:
//     NX      -   dimension of the space, NX=2 or NX=3
//     NY      -   function dimension, NY >= 1
//
// Outputs:
//     S       -   RBF model (initially equals to zero)
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
void rbfv1create(ae_int_t nx, ae_int_t ny, rbfv1model *s, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   SetObj(rbfv1model, s);
   ae_assert(nx == 2 || nx == 3, "RBFCreate: NX != 2 and NX != 3", _state);
   ae_assert(ny >= 1, "RBFCreate: NY<1", _state);
   s->nx = nx;
   s->ny = ny;
   s->nl = 0;
   s->nc = 0;
   ae_matrix_set_length(&s->v, ny, rbfv1_mxnx + 1, _state);
   for (i = 0; i < ny; i++) {
      for (j = 0; j <= rbfv1_mxnx; j++) {
         s->v.xyR[i][j] = 0.0;
      }
   }
   s->rmax = 0.0;
}

// This function creates buffer  structure  which  can  be  used  to  perform
// parallel  RBF  model  evaluations  (with  one  RBF  model  instance  being
// used from multiple threads, as long as  different  threads  use  different
// instances of buffer).
//
// This buffer object can be used with  rbftscalcbuf()  function  (here  "ts"
// stands for "thread-safe", "buf" is a suffix which denotes  function  which
// reuses previously allocated output space).
//
// How to use it:
// * create RBF model structure with rbfcreate()
// * load data, tune parameters
// * call rbfbuildmodel()
// * call rbfcreatecalcbuffer(), once per thread working with RBF model  (you
//   should call this function only AFTER call to rbfbuildmodel(), see  below
//   for more information)
// * call rbftscalcbuf() from different threads,  with  each  thread  working
//   with its own copy of buffer object.
//
// Inputs:
//     S           -   RBF model
//
// Outputs:
//     Buf         -   external buffer.
//
//
// IMPORTANT: buffer object should be used only with  RBF model object  which
//            was used to initialize buffer. Any attempt to use buffer   with
//            different object is dangerous - you may  get  memory  violation
//            error because sizes of internal arrays do not fit to dimensions
//            of RBF structure.
//
// IMPORTANT: you  should  call  this function only for model which was built
//            with rbfbuildmodel() function, after successful  invocation  of
//            rbfbuildmodel().  Sizes   of   some   internal  structures  are
//            determined only after model is built, so buffer object  created
//            before model  construction  stage  will  be  useless  (and  any
//            attempt to use it will result in exception).
// ALGLIB: Copyright 02.04.2016 by Sergey Bochkanov
void rbfv1createcalcbuffer(rbfv1model *s, rbfv1calcbuffer *buf, ae_state *_state) {
   SetObj(rbfv1calcbuffer, buf);
   kdtreecreaterequestbuffer(&s->tree, &buf->requestbuffer, _state);
}

static bool rbfv1_rbfv1buildlinearmodel(RMatrix *x, RMatrix *y, ae_int_t n, ae_int_t ny, ae_int_t modeltype, RMatrix *v, ae_state *_state) {
   ae_frame _frame_block;
   double scaling;
   double mn;
   double mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t info;
   bool result;
   ae_frame_make(_state, &_frame_block);
   SetMatrix(v);
   NewVector(tmpy, 0, DT_REAL, _state);
   NewMatrix(a, 0, 0, DT_REAL, _state);
   NewVector(shifting, 0, DT_REAL, _state);
   NewVector(c, 0, DT_REAL, _state);
   NewObj(lsfitreport, rep, _state);
   ae_assert(n >= 0, "BuildLinearModel: N<0", _state);
   ae_assert(ny > 0, "BuildLinearModel: NY <= 0", _state);
// Handle degenerate case (N=0)
   result = true;
   ae_matrix_set_length(v, ny, rbfv1_mxnx + 1, _state);
   if (n == 0) {
      for (j = 0; j <= rbfv1_mxnx; j++) {
         for (i = 0; i < ny; i++) {
            v->xyR[i][j] = 0.0;
         }
      }
      ae_frame_leave(_state);
      return result;
   }
// Allocate temporaries
   ae_vector_set_length(&tmpy, n, _state);
// General linear model.
   if (modeltype == 1) {
   // Calculate scaling/shifting, transform variables, prepare LLS problem
      ae_matrix_set_length(&a, n, rbfv1_mxnx + 1, _state);
      ae_vector_set_length(&shifting, rbfv1_mxnx, _state);
      scaling = 0.0;
      for (i = 0; i < rbfv1_mxnx; i++) {
         mn = x->xyR[0][i];
         mx = mn;
         for (j = 1; j < n; j++) {
            if (mn > x->xyR[j][i]) {
               mn = x->xyR[j][i];
            }
            if (mx < x->xyR[j][i]) {
               mx = x->xyR[j][i];
            }
         }
         scaling = maxreal(scaling, mx - mn, _state);
         shifting.xR[i] = 0.5 * (mx + mn);
      }
      if (scaling == 0.0) {
         scaling = 1.0;
      } else {
         scaling *= 0.5;
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < rbfv1_mxnx; j++) {
            a.xyR[i][j] = (x->xyR[i][j] - shifting.xR[j]) / scaling;
         }
      }
      for (i = 0; i < n; i++) {
         a.xyR[i][rbfv1_mxnx] = 1.0;
      }
   // Solve linear system in transformed variables, make backward
      for (i = 0; i < ny; i++) {
         for (j = 0; j < n; j++) {
            tmpy.xR[j] = y->xyR[j][i];
         }
         lsfitlinear(&tmpy, &a, n, rbfv1_mxnx + 1, &info, &c, &rep, _state);
         if (info <= 0) {
            result = false;
            ae_frame_leave(_state);
            return result;
         }
         for (j = 0; j < rbfv1_mxnx; j++) {
            v->xyR[i][j] = c.xR[j] / scaling;
         }
         v->xyR[i][rbfv1_mxnx] = c.xR[rbfv1_mxnx];
         for (j = 0; j < rbfv1_mxnx; j++) {
            v->xyR[i][rbfv1_mxnx] -= shifting.xR[j] * v->xyR[i][j];
         }
         for (j = 0; j < n; j++) {
            for (k = 0; k < rbfv1_mxnx; k++) {
               y->xyR[j][i] -= x->xyR[j][k] * v->xyR[i][k];
            }
            y->xyR[j][i] -= v->xyR[i][rbfv1_mxnx];
         }
      }
      ae_frame_leave(_state);
      return result;
   }
// Constant model, very simple
   if (modeltype == 2) {
      for (i = 0; i < ny; i++) {
         for (j = 0; j <= rbfv1_mxnx; j++) {
            v->xyR[i][j] = 0.0;
         }
         for (j = 0; j < n; j++) {
            v->xyR[i][rbfv1_mxnx] += y->xyR[j][i];
         }
         if (n > 0) {
            v->xyR[i][rbfv1_mxnx] /= n;
         }
         for (j = 0; j < n; j++) {
            y->xyR[j][i] -= v->xyR[i][rbfv1_mxnx];
         }
      }
      ae_frame_leave(_state);
      return result;
   }
// Zero model
   ae_assert(modeltype == 3, "BuildLinearModel: unknown model type", _state);
   for (i = 0; i < ny; i++) {
      for (j = 0; j <= rbfv1_mxnx; j++) {
         v->xyR[i][j] = 0.0;
      }
   }
   ae_frame_leave(_state);
   return result;
}

static void rbfv1_buildrbfmodellsqr(RMatrix *x, RMatrix *y, RMatrix *xc, RVector *r, ae_int_t n, ae_int_t nc, ae_int_t ny, kdtree *pointstree, kdtree *centerstree, double epsort, double epserr, ae_int_t maxits, ae_int_t *gnnz, ae_int_t *snnz, RMatrix *w, ae_int_t *info, ae_int_t *iterationscount, ae_int_t *nmv, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t maxnearcenterscnt;
   ae_int_t maxnearpointscnt;
   ae_int_t maxfarpointscnt;
   ae_int_t sumnearcenterscnt;
   ae_int_t sumnearpointscnt;
   ae_int_t sumfarpointscnt;
   double maxrad;
   ae_int_t tmpi;
   ae_int_t pointscnt;
   ae_int_t centerscnt;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t sind;
   double vv;
   double vx;
   double vy;
   double vz;
   double vr;
   double gnorm2;
   double fx;
   double mrad;
   ae_frame_make(_state, &_frame_block);
   *gnnz = 0;
   *snnz = 0;
   SetMatrix(w);
   *info = 0;
   *iterationscount = 0;
   *nmv = 0;
   NewObj(linlsqrstate, state, _state);
   NewObj(linlsqrreport, lsqrrep, _state);
   NewObj(sparsematrix, spg, _state);
   NewObj(sparsematrix, sps, _state);
   NewVector(nearcenterscnt, 0, DT_INT, _state);
   NewVector(nearpointscnt, 0, DT_INT, _state);
   NewVector(skipnearpointscnt, 0, DT_INT, _state);
   NewVector(farpointscnt, 0, DT_INT, _state);
   NewVector(pointstags, 0, DT_INT, _state);
   NewVector(centerstags, 0, DT_INT, _state);
   NewMatrix(nearpoints, 0, 0, DT_REAL, _state);
   NewMatrix(nearcenters, 0, 0, DT_REAL, _state);
   NewMatrix(farpoints, 0, 0, DT_REAL, _state);
   NewVector(xcx, 0, DT_REAL, _state);
   NewVector(tmpy, 0, DT_REAL, _state);
   NewVector(tc, 0, DT_REAL, _state);
   NewVector(g, 0, DT_REAL, _state);
   NewVector(c, 0, DT_REAL, _state);
   NewMatrix(a, 0, 0, DT_REAL, _state);
   NewVector(tmp0, 0, DT_REAL, _state);
   NewVector(tmp1, 0, DT_REAL, _state);
   NewVector(tmp2, 0, DT_REAL, _state);
   NewMatrix(xx, 0, 0, DT_REAL, _state);
   NewMatrix(cx, 0, 0, DT_REAL, _state);
// Handle special cases: NC=0
   if (nc == 0) {
      *info = 1;
      *iterationscount = 0;
      *nmv = 0;
      ae_frame_leave(_state);
      return;
   }
// Prepare for general case, NC>0
   ae_vector_set_length(&xcx, rbfv1_mxnx, _state);
   ae_vector_set_length(&pointstags, n, _state);
   ae_vector_set_length(&centerstags, nc, _state);
   *info = -1;
   *iterationscount = 0;
   *nmv = 0;
// This block prepares quantities used to compute approximate cardinal basis functions (ACBFs):
// * NearCentersCnt[]   -   array[NC], whose elements store number of near centers used to build ACBF
// * NearPointsCnt[]    -   array[NC], number of near points used to build ACBF
// * FarPointsCnt[]     -   array[NC], number of far points (ones where ACBF is nonzero)
// * MaxNearCentersCnt  -   max(NearCentersCnt)
// * MaxNearPointsCnt   -   max(NearPointsCnt)
// * SumNearCentersCnt  -   sum(NearCentersCnt)
// * SumNearPointsCnt   -   sum(NearPointsCnt)
// * SumFarPointsCnt    -   sum(FarPointsCnt)
   ae_vector_set_length(&nearcenterscnt, nc, _state);
   ae_vector_set_length(&nearpointscnt, nc, _state);
   ae_vector_set_length(&skipnearpointscnt, nc, _state);
   ae_vector_set_length(&farpointscnt, nc, _state);
   maxnearcenterscnt = 0;
   maxnearpointscnt = 0;
   maxfarpointscnt = 0;
   sumnearcenterscnt = 0;
   sumnearpointscnt = 0;
   sumfarpointscnt = 0;
   for (i = 0; i < nc; i++) {
      for (j = 0; j < rbfv1_mxnx; j++) {
         xcx.xR[j] = xc->xyR[i][j];
      }
   // Determine number of near centers and maximum radius of near centers
      nearcenterscnt.xZ[i] = kdtreequeryrnn(centerstree, &xcx, r->xR[i] * rbfv1_rbfnearradius, true, _state);
      kdtreequeryresultstags(centerstree, &centerstags, _state);
      maxrad = 0.0;
      for (j = 0; j < nearcenterscnt.xZ[i]; j++) {
         maxrad = maxreal(maxrad, ae_fabs(r->xR[centerstags.xZ[j]], _state), _state);
      }
   // Determine number of near points (ones which used to build ACBF)
   // and skipped points (the most near points which are NOT used to build ACBF
   // and are NOT included in the near points count
      skipnearpointscnt.xZ[i] = kdtreequeryrnn(pointstree, &xcx, 0.1 * r->xR[i], true, _state);
      nearpointscnt.xZ[i] = kdtreequeryrnn(pointstree, &xcx, (r->xR[i] + maxrad) * rbfv1_rbfnearradius, true, _state) - skipnearpointscnt.xZ[i];
      ae_assert(nearpointscnt.xZ[i] >= 0, "BuildRBFModelLSQR: internal error", _state);
   // Determine number of far points
      farpointscnt.xZ[i] = kdtreequeryrnn(pointstree, &xcx, maxreal(r->xR[i] * rbfv1_rbfnearradius + maxrad * rbfv1_rbffarradius, r->xR[i] * rbfv1_rbffarradius, _state), true, _state);
   // calculate sum and max, make some basic checks
      ae_assert(nearcenterscnt.xZ[i] > 0, "BuildRBFModelLSQR: internal error", _state);
      maxnearcenterscnt = maxint(maxnearcenterscnt, nearcenterscnt.xZ[i], _state);
      maxnearpointscnt = maxint(maxnearpointscnt, nearpointscnt.xZ[i], _state);
      maxfarpointscnt = maxint(maxfarpointscnt, farpointscnt.xZ[i], _state);
      sumnearcenterscnt += nearcenterscnt.xZ[i];
      sumnearpointscnt += nearpointscnt.xZ[i];
      sumfarpointscnt += farpointscnt.xZ[i];
   }
   *snnz = sumnearcenterscnt;
   *gnnz = sumfarpointscnt;
   ae_assert(maxnearcenterscnt > 0, "BuildRBFModelLSQR: internal error", _state);
// Allocate temporaries.
//
// NOTE: we want to avoid allocation of zero-size arrays, so we
//       use max(desired_size,1) instead of desired_size when performing
//       memory allocation.
   ae_matrix_set_length(&a, maxnearpointscnt + maxnearcenterscnt, maxnearcenterscnt, _state);
   ae_vector_set_length(&tmpy, maxnearpointscnt + maxnearcenterscnt, _state);
   ae_vector_set_length(&g, maxnearcenterscnt, _state);
   ae_vector_set_length(&c, maxnearcenterscnt, _state);
   ae_matrix_set_length(&nearcenters, maxnearcenterscnt, rbfv1_mxnx, _state);
   ae_matrix_set_length(&nearpoints, maxint(maxnearpointscnt, 1, _state), rbfv1_mxnx, _state);
   ae_matrix_set_length(&farpoints, maxint(maxfarpointscnt, 1, _state), rbfv1_mxnx, _state);
// fill matrix SpG
   sparsecreate(n, nc, *gnnz, &spg, _state);
   sparsecreate(nc, nc, *snnz, &sps, _state);
   for (i = 0; i < nc; i++) {
      centerscnt = nearcenterscnt.xZ[i];
   // main center
      for (j = 0; j < rbfv1_mxnx; j++) {
         xcx.xR[j] = xc->xyR[i][j];
      }
   // center's tree
      tmpi = kdtreequeryknn(centerstree, &xcx, centerscnt, true, _state);
      ae_assert(tmpi == centerscnt, "BuildRBFModelLSQR: internal error", _state);
      kdtreequeryresultsx(centerstree, &cx, _state);
      kdtreequeryresultstags(centerstree, &centerstags, _state);
   // point's tree
      mrad = 0.0;
      for (j = 0; j < centerscnt; j++) {
         mrad = maxreal(mrad, r->xR[centerstags.xZ[j]], _state);
      }
   // we need to be sure that 'CTree' contains
   // at least one side center
      sparseset(&sps, i, i, 1.0, _state);
      c.xR[0] = 1.0;
      for (j = 1; j < centerscnt; j++) {
         c.xR[j] = 0.0;
      }
      if (centerscnt > 1 && nearpointscnt.xZ[i] > 0) {
      // first KDTree request for points
         pointscnt = nearpointscnt.xZ[i];
         tmpi = kdtreequeryknn(pointstree, &xcx, skipnearpointscnt.xZ[i] + nearpointscnt.xZ[i], true, _state);
         ae_assert(tmpi == skipnearpointscnt.xZ[i] + nearpointscnt.xZ[i], "BuildRBFModelLSQR: internal error", _state);
         kdtreequeryresultsx(pointstree, &xx, _state);
         sind = skipnearpointscnt.xZ[i];
         for (j = 0; j < pointscnt; j++) {
            vx = xx.xyR[sind + j][0];
            vy = xx.xyR[sind + j][1];
            vz = xx.xyR[sind + j][2];
            for (k = 0; k < centerscnt; k++) {
               vr = 0.0;
               vv = vx - cx.xyR[k][0];
               vr += vv * vv;
               vv = vy - cx.xyR[k][1];
               vr += vv * vv;
               vv = vz - cx.xyR[k][2];
               vr += vv * vv;
               vv = r->xR[centerstags.xZ[k]];
               a.xyR[j][k] = ae_exp(-vr / (vv * vv), _state);
            }
         }
         for (j = 0; j < centerscnt; j++) {
            g.xR[j] = ae_exp(-(sqr(xcx.xR[0] - cx.xyR[j][0], _state) + sqr(xcx.xR[1] - cx.xyR[j][1], _state) + sqr(xcx.xR[2] - cx.xyR[j][2], _state)) / sqr(r->xR[centerstags.xZ[j]], _state), _state);
         }
      // calculate the problem
         gnorm2 = ae_v_dotproduct(g.xR, 1, g.xR, 1, centerscnt);
         for (j = 0; j < pointscnt; j++) {
            vv = ae_v_dotproduct(a.xyR[j], 1, g.xR, 1, centerscnt);
            vv /= gnorm2;
            tmpy.xR[j] = -vv;
            ae_v_subd(a.xyR[j], 1, g.xR, 1, centerscnt, vv);
         }
         for (j = pointscnt; j < pointscnt + centerscnt; j++) {
            for (k = 0; k < centerscnt; k++) {
               a.xyR[j][k] = 0.0;
            }
            a.xyR[j][j - pointscnt] = 1.0E-6;
            tmpy.xR[j] = 0.0;
         }
         fblssolvels(&a, &tmpy, pointscnt + centerscnt, centerscnt, &tmp0, &tmp1, &tmp2, _state);
         ae_v_move(c.xR, 1, tmpy.xR, 1, centerscnt);
         vv = ae_v_dotproduct(g.xR, 1, c.xR, 1, centerscnt);
         vv /= gnorm2;
         ae_v_subd(c.xR, 1, g.xR, 1, centerscnt, vv);
         vv = 1 / gnorm2;
         ae_v_addd(c.xR, 1, g.xR, 1, centerscnt, vv);
         for (j = 0; j < centerscnt; j++) {
            sparseset(&sps, i, centerstags.xZ[j], c.xR[j], _state);
         }
      }
   // second KDTree request for points
      pointscnt = farpointscnt.xZ[i];
      tmpi = kdtreequeryknn(pointstree, &xcx, pointscnt, true, _state);
      ae_assert(tmpi == pointscnt, "BuildRBFModelLSQR: internal error", _state);
      kdtreequeryresultsx(pointstree, &xx, _state);
      kdtreequeryresultstags(pointstree, &pointstags, _state);
   // fill SpG matrix
      for (j = 0; j < pointscnt; j++) {
         fx = 0.0;
         vx = xx.xyR[j][0];
         vy = xx.xyR[j][1];
         vz = xx.xyR[j][2];
         for (k = 0; k < centerscnt; k++) {
            vr = 0.0;
            vv = vx - cx.xyR[k][0];
            vr += vv * vv;
            vv = vy - cx.xyR[k][1];
            vr += vv * vv;
            vv = vz - cx.xyR[k][2];
            vr += vv * vv;
            vv = r->xR[centerstags.xZ[k]];
            vv *= vv;
            fx += c.xR[k] * ae_exp(-vr / vv, _state);
         }
         sparseset(&spg, pointstags.xZ[j], i, fx, _state);
      }
   }
   sparseconverttocrs(&spg, _state);
   sparseconverttocrs(&sps, _state);
// solve by LSQR method
   ae_vector_set_length(&tmpy, n, _state);
   ae_vector_set_length(&tc, nc, _state);
   ae_matrix_set_length(w, nc, ny, _state);
   linlsqrcreate(n, nc, &state, _state);
   linlsqrsetcond(&state, epsort, epserr, maxits, _state);
   for (i = 0; i < ny; i++) {
      for (j = 0; j < n; j++) {
         tmpy.xR[j] = y->xyR[j][i];
      }
      linlsqrsolvesparse(&state, &spg, &tmpy, _state);
      linlsqrresults(&state, &c, &lsqrrep, _state);
      if (lsqrrep.terminationtype <= 0) {
         *info = -4;
         ae_frame_leave(_state);
         return;
      }
      sparsemtv(&sps, &c, &tc, _state);
      for (j = 0; j < nc; j++) {
         w->xyR[j][i] = tc.xR[j];
      }
      *iterationscount += lsqrrep.iterationscount;
      *nmv += lsqrrep.nmv;
   }
   *info = 1;
   ae_frame_leave(_state);
}

static void rbfv1_buildrbfmlayersmodellsqr(RMatrix *x, RMatrix *y, RMatrix *xc, double rval, RVector *r, ae_int_t n, ae_int_t *nc, ae_int_t ny, ae_int_t nlayers, kdtree *centerstree, double epsort, double epserr, ae_int_t maxits, double lambdav, ae_int_t *annz, RMatrix *w, ae_int_t *info, ae_int_t *iterationscount, ae_int_t *nmv, ae_state *_state) {
   ae_frame _frame_block;
   double anorm;
   double yval;
   ae_int_t nec;
   ae_int_t layer;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double rmaxbefore;
   double rmaxafter;
   ae_frame_make(_state, &_frame_block);
   SetMatrix(xc);
   SetVector(r);
   *nc = 0;
   *annz = 0;
   SetMatrix(w);
   *info = 0;
   *iterationscount = 0;
   *nmv = 0;
   NewObj(linlsqrstate, state, _state);
   NewObj(linlsqrreport, lsqrrep, _state);
   NewObj(sparsematrix, spa, _state);
   NewVector(omega, 0, DT_REAL, _state);
   NewVector(xx, 0, DT_REAL, _state);
   NewVector(tmpy, 0, DT_REAL, _state);
   NewMatrix(cx, 0, 0, DT_REAL, _state);
   NewVector(centerstags, 0, DT_INT, _state);
   ae_assert(nlayers >= 0, "BuildRBFMLayersModelLSQR: invalid argument(NLayers<0)", _state);
   ae_assert(n >= 0, "BuildRBFMLayersModelLSQR: invalid argument(N<0)", _state);
   ae_assert(rbfv1_mxnx > 0 && rbfv1_mxnx <= 3, "BuildRBFMLayersModelLSQR: internal error(invalid global const MxNX: either MxNX <= 0 or MxNX>3)", _state);
   *annz = 0;
   if (n == 0 || nlayers == 0) {
      *info = 1;
      *iterationscount = 0;
      *nmv = 0;
      ae_frame_leave(_state);
      return;
   }
   *nc = n * nlayers;
   ae_vector_set_length(&xx, rbfv1_mxnx, _state);
   ae_vector_set_length(&centerstags, n, _state);
   ae_matrix_set_length(xc, *nc, rbfv1_mxnx, _state);
   ae_vector_set_length(r, *nc, _state);
   for (i = 0; i < *nc; i++) {
      for (j = 0; j < rbfv1_mxnx; j++) {
         xc->xyR[i][j] = x->xyR[i % n][j];
      }
   }
   for (i = 0; i < *nc; i++) {
      r->xR[i] = rval / ae_pow(2.0, (double)(i / n), _state);
   }
   for (i = 0; i < n; i++) {
      centerstags.xZ[i] = i;
   }
   kdtreebuildtagged(xc, &centerstags, n, rbfv1_mxnx, 0, 2, centerstree, _state);
   ae_vector_set_length(&omega, n, _state);
   ae_vector_set_length(&tmpy, n, _state);
   ae_matrix_set_length(w, *nc, ny, _state);
   *info = -1;
   *iterationscount = 0;
   *nmv = 0;
   linlsqrcreate(n, n, &state, _state);
   linlsqrsetcond(&state, epsort, epserr, maxits, _state);
   linlsqrsetlambdai(&state, 1.0E-6, _state);
// calculate number of non-zero elements for sparse matrix
   for (i = 0; i < n; i++) {
      for (j = 0; j < rbfv1_mxnx; j++) {
         xx.xR[j] = x->xyR[i][j];
      }
      *annz += kdtreequeryrnn(centerstree, &xx, r->xR[0] * rbfv1_rbfmlradius, true, _state);
   }
   for (layer = 0; layer < nlayers; layer++) {
   // Fill sparse matrix, calculate norm(A)
      anorm = 0.0;
      sparsecreate(n, n, *annz, &spa, _state);
      for (i = 0; i < n; i++) {
         for (j = 0; j < rbfv1_mxnx; j++) {
            xx.xR[j] = x->xyR[i][j];
         }
         nec = kdtreequeryrnn(centerstree, &xx, r->xR[layer * n] * rbfv1_rbfmlradius, true, _state);
         kdtreequeryresultsx(centerstree, &cx, _state);
         kdtreequeryresultstags(centerstree, &centerstags, _state);
         for (j = 0; j < nec; j++) {
            v = ae_exp(-(sqr(xx.xR[0] - cx.xyR[j][0], _state) + sqr(xx.xR[1] - cx.xyR[j][1], _state) + sqr(xx.xR[2] - cx.xyR[j][2], _state)) / sqr(r->xR[layer * n + centerstags.xZ[j]], _state), _state);
            sparseset(&spa, i, centerstags.xZ[j], v, _state);
            anorm += sqr(v, _state);
         }
      }
      anorm = ae_sqrt(anorm, _state);
      sparseconverttocrs(&spa, _state);
   // Calculate maximum residual before adding new layer.
   // This value is not used by algorithm, the only purpose is to make debugging easier.
      rmaxbefore = 0.0;
      for (j = 0; j < n; j++) {
         for (i = 0; i < ny; i++) {
            rmaxbefore = maxreal(rmaxbefore, ae_fabs(y->xyR[j][i], _state), _state);
         }
      }
   // Process NY dimensions of the target function
      for (i = 0; i < ny; i++) {
         for (j = 0; j < n; j++) {
            tmpy.xR[j] = y->xyR[j][i];
         }
      // calculate Omega for current layer
         linlsqrsetlambdai(&state, lambdav * anorm / n, _state);
         linlsqrsolvesparse(&state, &spa, &tmpy, _state);
         linlsqrresults(&state, &omega, &lsqrrep, _state);
         if (lsqrrep.terminationtype <= 0) {
            *info = -4;
            ae_frame_leave(_state);
            return;
         }
      // calculate error for current layer
         for (j = 0; j < n; j++) {
            yval = 0.0;
            for (k = 0; k < rbfv1_mxnx; k++) {
               xx.xR[k] = x->xyR[j][k];
            }
            nec = kdtreequeryrnn(centerstree, &xx, r->xR[layer * n] * rbfv1_rbffarradius, true, _state);
            kdtreequeryresultsx(centerstree, &cx, _state);
            kdtreequeryresultstags(centerstree, &centerstags, _state);
            for (k = 0; k < nec; k++) {
               yval += omega.xR[centerstags.xZ[k]] * ae_exp(-(sqr(xx.xR[0] - cx.xyR[k][0], _state) + sqr(xx.xR[1] - cx.xyR[k][1], _state) + sqr(xx.xR[2] - cx.xyR[k][2], _state)) / sqr(r->xR[layer * n + centerstags.xZ[k]], _state), _state);
            }
            y->xyR[j][i] -= yval;
         }
      // write Omega in out parameter W
         for (j = 0; j < n; j++) {
            w->xyR[layer * n + j][i] = omega.xR[j];
         }
         *iterationscount += lsqrrep.iterationscount;
         *nmv += lsqrrep.nmv;
      }
   // Calculate maximum residual before adding new layer.
   // This value is not used by algorithm, the only purpose is to make debugging easier.
      rmaxafter = 0.0;
      for (j = 0; j < n; j++) {
         for (i = 0; i < ny; i++) {
            rmaxafter = maxreal(rmaxafter, ae_fabs(y->xyR[j][i], _state), _state);
         }
      }
   }
   *info = 1;
   ae_frame_leave(_state);
}

// This   function  builds  RBF  model  and  returns  report  (contains  some
// information which can be used for evaluation of the algorithm properties).
//
// Call to this function modifies RBF model by calculating its centers/radii/
// weights  and  saving  them  into  RBFModel  structure.  Initially RBFModel
// contain zero coefficients, but after call to this function  we  will  have
// coefficients which were calculated in order to fit our dataset.
//
// After you called this function you can call RBFCalc(),  RBFGridCalc()  and
// other model calculation functions.
//
// Inputs:
//     S       -   RBF model, initialized by RBFCreate() call
//     Rep     -   report:
//                 * Rep.TerminationType:
//                   * -5 - non-distinct basis function centers were detected,
//                          interpolation aborted
//                   * -4 - nonconvergence of the internal SVD solver
//                   *  1 - successful termination
//                 Fields are used for debugging purposes:
//                 * Rep.IterationsCount - iterations count of the LSQR solver
//                 * Rep.NMV - number of matrix-vector products
//                 * Rep.ARows - rows count for the system matrix
//                 * Rep.ACols - columns count for the system matrix
//                 * Rep.ANNZ - number of significantly non-zero elements
//                   (elements above some algorithm-determined threshold)
//
// NOTE:  failure  to  build  model will leave current state of the structure
// unchanged.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
void rbfv1buildmodel(RMatrix *x, RMatrix *y, ae_int_t n, ae_int_t aterm, ae_int_t algorithmtype, ae_int_t nlayers, double radvalue, double radzvalue, double lambdav, double epsort, double epserr, ae_int_t maxits, rbfv1model *s, rbfv1report *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t nc;
   double rmax;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t snnz;
   ae_int_t layerscnt;
   bool modelstatus;
   ae_frame_make(_state, &_frame_block);
   SetObj(rbfv1report, rep);
   NewObj(kdtree, tree, _state);
   NewObj(kdtree, ctree, _state);
   NewVector(dist, 0, DT_REAL, _state);
   NewVector(xcx, 0, DT_REAL, _state);
   NewMatrix(a, 0, 0, DT_REAL, _state);
   NewMatrix(v, 0, 0, DT_REAL, _state);
   NewMatrix(omega, 0, 0, DT_REAL, _state);
   NewMatrix(residualy, 0, 0, DT_REAL, _state);
   NewVector(radius, 0, DT_REAL, _state);
   NewMatrix(xc, 0, 0, DT_REAL, _state);
   NewVector(tags, 0, DT_INT, _state);
   NewVector(ctags, 0, DT_INT, _state);
   NewVector(tmp0, 0, DT_REAL, _state);
   NewVector(tmp1, 0, DT_REAL, _state);
   ae_assert(s->nx == 2 || s->nx == 3, "RBFBuildModel: S.NX != 2 or S.NX != 3!", _state);
// Quick exit when we have no points
   if (n == 0) {
      rep->terminationtype = 1;
      rep->iterationscount = 0;
      rep->nmv = 0;
      rep->arows = 0;
      rep->acols = 0;
      kdtreebuildtagged(&s->xc, &tags, 0, rbfv1_mxnx, 0, 2, &s->tree, _state);
      ae_matrix_set_length(&s->xc, 0, 0, _state);
      ae_matrix_set_length(&s->wr, 0, 0, _state);
      s->nc = 0;
      s->rmax = 0.0;
      ae_matrix_set_length(&s->v, s->ny, rbfv1_mxnx + 1, _state);
      for (i = 0; i < s->ny; i++) {
         for (j = 0; j <= rbfv1_mxnx; j++) {
            s->v.xyR[i][j] = 0.0;
         }
      }
      ae_frame_leave(_state);
      return;
   }
// General case, N>0
   rep->annz = 0;
   rep->iterationscount = 0;
   rep->nmv = 0;
   ae_vector_set_length(&xcx, rbfv1_mxnx, _state);
// First model in a sequence - linear model.
// Residuals from linear regression are stored in the ResidualY variable
// (used later to build RBF models).
   ae_matrix_set_length(&residualy, n, s->ny, _state);
   for (i = 0; i < n; i++) {
      for (j = 0; j < s->ny; j++) {
         residualy.xyR[i][j] = y->xyR[i][j];
      }
   }
   if (!rbfv1_rbfv1buildlinearmodel(x, &residualy, n, s->ny, aterm, &v, _state)) {
      rep->terminationtype = -5;
      ae_frame_leave(_state);
      return;
   }
// Handle special case: multilayer model with NLayers=0.
// Quick exit.
   if (algorithmtype == 2 && nlayers == 0) {
      rep->terminationtype = 1;
      rep->iterationscount = 0;
      rep->nmv = 0;
      rep->arows = 0;
      rep->acols = 0;
      kdtreebuildtagged(&s->xc, &tags, 0, rbfv1_mxnx, 0, 2, &s->tree, _state);
      ae_matrix_set_length(&s->xc, 0, 0, _state);
      ae_matrix_set_length(&s->wr, 0, 0, _state);
      s->nc = 0;
      s->rmax = 0.0;
      ae_matrix_set_length(&s->v, s->ny, rbfv1_mxnx + 1, _state);
      for (i = 0; i < s->ny; i++) {
         for (j = 0; j <= rbfv1_mxnx; j++) {
            s->v.xyR[i][j] = v.xyR[i][j];
         }
      }
      ae_frame_leave(_state);
      return;
   }
// Second model in a sequence - RBF term.
//
// NOTE: assignments below are not necessary, but without them
//       MSVC complains about unitialized variables.
   nc = 0;
   rmax = 0.0;
   layerscnt = 0;
   modelstatus = false;
   if (algorithmtype == 1) {
   // Add RBF model.
   // This model uses local KD-trees to speed-up nearest neighbor searches.
      nc = n;
      ae_matrix_set_length(&xc, nc, rbfv1_mxnx, _state);
      for (i = 0; i < nc; i++) {
         for (j = 0; j < rbfv1_mxnx; j++) {
            xc.xyR[i][j] = x->xyR[i][j];
         }
      }
      rmax = 0.0;
      ae_vector_set_length(&radius, nc, _state);
      ae_vector_set_length(&ctags, nc, _state);
      for (i = 0; i < nc; i++) {
         ctags.xZ[i] = i;
      }
      kdtreebuildtagged(&xc, &ctags, nc, rbfv1_mxnx, 0, 2, &ctree, _state);
      if (nc == 0) {
         rmax = 1.0;
      } else {
         if (nc == 1) {
            radius.xR[0] = radvalue;
            rmax = radius.xR[0];
         } else {
         // NC>1, calculate radii using distances to nearest neigbors
            for (i = 0; i < nc; i++) {
               for (j = 0; j < rbfv1_mxnx; j++) {
                  xcx.xR[j] = xc.xyR[i][j];
               }
               if (kdtreequeryknn(&ctree, &xcx, 1, false, _state) > 0) {
                  kdtreequeryresultsdistances(&ctree, &dist, _state);
                  radius.xR[i] = radvalue * dist.xR[0];
               } else {
               // No neighbors found (it will happen when we have only one center).
               // Initialize radius with default value.
                  radius.xR[i] = 1.0;
               }
            }
         // Apply filtering
            rvectorsetlengthatleast(&tmp0, nc, _state);
            for (i = 0; i < nc; i++) {
               tmp0.xR[i] = radius.xR[i];
            }
            tagsortfast(&tmp0, &tmp1, nc, _state);
            for (i = 0; i < nc; i++) {
               radius.xR[i] = minreal(radius.xR[i], radzvalue * tmp0.xR[nc / 2], _state);
            }
         // Calculate RMax, check that all radii are non-zero
            for (i = 0; i < nc; i++) {
               rmax = maxreal(rmax, radius.xR[i], _state);
            }
            for (i = 0; i < nc; i++) {
               if (radius.xR[i] == 0.0) {
                  rep->terminationtype = -5;
                  ae_frame_leave(_state);
                  return;
               }
            }
         }
      }
      ivectorsetlengthatleast(&tags, n, _state);
      for (i = 0; i < n; i++) {
         tags.xZ[i] = i;
      }
      kdtreebuildtagged(x, &tags, n, rbfv1_mxnx, 0, 2, &tree, _state);
      rbfv1_buildrbfmodellsqr(x, &residualy, &xc, &radius, n, nc, s->ny, &tree, &ctree, epsort, epserr, maxits, &rep->annz, &snnz, &omega, &rep->terminationtype, &rep->iterationscount, &rep->nmv, _state);
      layerscnt = 1;
      modelstatus = true;
   }
   if (algorithmtype == 2) {
      rmax = radvalue;
      rbfv1_buildrbfmlayersmodellsqr(x, &residualy, &xc, radvalue, &radius, n, &nc, s->ny, nlayers, &ctree, 1.0E-6, 1.0E-6, 50, lambdav, &rep->annz, &omega, &rep->terminationtype, &rep->iterationscount, &rep->nmv, _state);
      layerscnt = nlayers;
      modelstatus = true;
   }
   ae_assert(modelstatus, "RBFBuildModel: integrity error", _state);
   if (rep->terminationtype <= 0) {
      ae_frame_leave(_state);
      return;
   }
// Model is built
   s->nc = nc / layerscnt;
   s->rmax = rmax;
   s->nl = layerscnt;
   ae_matrix_set_length(&s->xc, s->nc, rbfv1_mxnx, _state);
   ae_matrix_set_length(&s->wr, s->nc, 1 + s->nl * s->ny, _state);
   ae_matrix_set_length(&s->v, s->ny, rbfv1_mxnx + 1, _state);
   for (i = 0; i < s->nc; i++) {
      for (j = 0; j < rbfv1_mxnx; j++) {
         s->xc.xyR[i][j] = xc.xyR[i][j];
      }
   }
   ivectorsetlengthatleast(&tags, s->nc, _state);
   for (i = 0; i < s->nc; i++) {
      tags.xZ[i] = i;
   }
   kdtreebuildtagged(&s->xc, &tags, s->nc, rbfv1_mxnx, 0, 2, &s->tree, _state);
   for (i = 0; i < s->nc; i++) {
      s->wr.xyR[i][0] = radius.xR[i];
      for (k = 0; k < layerscnt; k++) {
         for (j = 0; j < s->ny; j++) {
            s->wr.xyR[i][1 + k * s->ny + j] = omega.xyR[k * s->nc + i][j];
         }
      }
   }
   for (i = 0; i < s->ny; i++) {
      for (j = 0; j <= rbfv1_mxnx; j++) {
         s->v.xyR[i][j] = v.xyR[i][j];
      }
   }
   rep->terminationtype = 1;
   rep->arows = n;
   rep->acols = s->nc;
   ae_frame_leave(_state);
}

// This function calculates values of the RBF model in the given point.
//
// This function should be used when we have NY=1 (scalar function) and  NX=2
// (2-dimensional space). If you have 3-dimensional space, use RBFCalc3(). If
// you have general situation (NX-dimensional space, NY-dimensional function)
// you should use general, less efficient implementation RBFCalc().
//
// If  you  want  to  calculate  function  values  many times, consider using
// RBFGridCalc2(), which is far more efficient than many subsequent calls  to
// RBFCalc2().
//
// This function returns 0.0 when:
// * model is not initialized
// * NX != 2
//  *NY != 1
//
// Inputs:
//     S       -   RBF model
//     X0      -   first coordinate, finite number
//     X1      -   second coordinate, finite number
//
// Result:
//     value of the model or 0.0 (as defined above)
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
double rbfv1calc2(rbfv1model *s, double x0, double x1, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t lx;
   ae_int_t tg;
   double d2;
   double t;
   double bfcur;
   double rcur;
   double result;
   ae_assert(ae_isfinite(x0, _state), "RBFCalc2: invalid value for X0 (X0 is Inf)!", _state);
   ae_assert(ae_isfinite(x1, _state), "RBFCalc2: invalid value for X1 (X1 is Inf)!", _state);
   if (s->ny != 1 || s->nx != 2) {
      result = 0.0;
      return result;
   }
   result = s->v.xyR[0][0] * x0 + s->v.xyR[0][1] * x1 + s->v.xyR[0][rbfv1_mxnx];
   if (s->nc == 0) {
      return result;
   }
   rvectorsetlengthatleast(&s->calcbufxcx, rbfv1_mxnx, _state);
   for (i = 0; i < rbfv1_mxnx; i++) {
      s->calcbufxcx.xR[i] = 0.0;
   }
   s->calcbufxcx.xR[0] = x0;
   s->calcbufxcx.xR[1] = x1;
   lx = kdtreequeryrnn(&s->tree, &s->calcbufxcx, s->rmax * rbfv1_rbffarradius, true, _state);
   kdtreequeryresultsx(&s->tree, &s->calcbufx, _state);
   kdtreequeryresultstags(&s->tree, &s->calcbuftags, _state);
   for (i = 0; i < lx; i++) {
      tg = s->calcbuftags.xZ[i];
      d2 = sqr(x0 - s->calcbufx.xyR[i][0], _state) + sqr(x1 - s->calcbufx.xyR[i][1], _state);
      rcur = s->wr.xyR[tg][0];
      bfcur = ae_exp(-d2 / (rcur * rcur), _state);
      for (j = 0; j < s->nl; j++) {
         result += bfcur * s->wr.xyR[tg][1 + j];
         rcur *= 0.5;
         t = bfcur * bfcur;
         bfcur = t * t;
      }
   }
   return result;
}

// This function calculates values of the RBF model in the given point.
//
// This function should be used when we have NY=1 (scalar function) and  NX=3
// (3-dimensional space). If you have 2-dimensional space, use RBFCalc2(). If
// you have general situation (NX-dimensional space, NY-dimensional function)
// you should use general, less efficient implementation RBFCalc().
//
// This function returns 0.0 when:
// * model is not initialized
// * NX != 3
//  *NY != 1
//
// Inputs:
//     S       -   RBF model
//     X0      -   first coordinate, finite number
//     X1      -   second coordinate, finite number
//     X2      -   third coordinate, finite number
//
// Result:
//     value of the model or 0.0 (as defined above)
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
double rbfv1calc3(rbfv1model *s, double x0, double x1, double x2, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t lx;
   ae_int_t tg;
   double t;
   double rcur;
   double bf;
   double result;
   ae_assert(ae_isfinite(x0, _state), "RBFCalc3: invalid value for X0 (X0 is Inf or NaN)!", _state);
   ae_assert(ae_isfinite(x1, _state), "RBFCalc3: invalid value for X1 (X1 is Inf or NaN)!", _state);
   ae_assert(ae_isfinite(x2, _state), "RBFCalc3: invalid value for X2 (X2 is Inf or NaN)!", _state);
   if (s->ny != 1 || s->nx != 3) {
      result = 0.0;
      return result;
   }
   result = s->v.xyR[0][0] * x0 + s->v.xyR[0][1] * x1 + s->v.xyR[0][2] * x2 + s->v.xyR[0][rbfv1_mxnx];
   if (s->nc == 0) {
      return result;
   }
// calculating value for F(X)
   rvectorsetlengthatleast(&s->calcbufxcx, rbfv1_mxnx, _state);
   for (i = 0; i < rbfv1_mxnx; i++) {
      s->calcbufxcx.xR[i] = 0.0;
   }
   s->calcbufxcx.xR[0] = x0;
   s->calcbufxcx.xR[1] = x1;
   s->calcbufxcx.xR[2] = x2;
   lx = kdtreequeryrnn(&s->tree, &s->calcbufxcx, s->rmax * rbfv1_rbffarradius, true, _state);
   kdtreequeryresultsx(&s->tree, &s->calcbufx, _state);
   kdtreequeryresultstags(&s->tree, &s->calcbuftags, _state);
   for (i = 0; i < lx; i++) {
      tg = s->calcbuftags.xZ[i];
      rcur = s->wr.xyR[tg][0];
      bf = ae_exp(-(sqr(x0 - s->calcbufx.xyR[i][0], _state) + sqr(x1 - s->calcbufx.xyR[i][1], _state) + sqr(x2 - s->calcbufx.xyR[i][2], _state)) / sqr(rcur, _state), _state);
      for (j = 0; j < s->nl; j++) {
         result += bf * s->wr.xyR[tg][1 + j];
         t = bf * bf;
         bf = t * t;
      }
   }
   return result;
}

// This function calculates values of the RBF model at the given point.
//
// Same as RBFCalc(), but does not reallocate Y when in is large enough to
// store function values.
//
// Inputs:
//     S       -   RBF model
//     X       -   coordinates, array[NX].
//                 X may have more than NX elements, in this case only
//                 leading NX will be used.
//     Y       -   possibly preallocated array
//
// Outputs:
//     Y       -   function value, array[NY]. Y is not reallocated when it
//                 is larger than NY.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
void rbfv1calcbuf(rbfv1model *s, RVector *x, RVector *y, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t lx;
   ae_int_t tg;
   double t;
   double rcur;
   double bf;
   ae_assert(x->cnt >= s->nx, "RBFCalcBuf: Length(X)<NX", _state);
   ae_assert(isfinitevector(x, s->nx, _state), "RBFCalcBuf: X contains infinite or NaN values", _state);
   if (y->cnt < s->ny) {
      ae_vector_set_length(y, s->ny, _state);
   }
   for (i = 0; i < s->ny; i++) {
      y->xR[i] = s->v.xyR[i][rbfv1_mxnx];
      for (j = 0; j < s->nx; j++) {
         y->xR[i] += s->v.xyR[i][j] * x->xR[j];
      }
   }
   if (s->nc == 0) {
      return;
   }
   rvectorsetlengthatleast(&s->calcbufxcx, rbfv1_mxnx, _state);
   for (i = 0; i < rbfv1_mxnx; i++) {
      s->calcbufxcx.xR[i] = 0.0;
   }
   for (i = 0; i < s->nx; i++) {
      s->calcbufxcx.xR[i] = x->xR[i];
   }
   lx = kdtreequeryrnn(&s->tree, &s->calcbufxcx, s->rmax * rbfv1_rbffarradius, true, _state);
   kdtreequeryresultsx(&s->tree, &s->calcbufx, _state);
   kdtreequeryresultstags(&s->tree, &s->calcbuftags, _state);
   for (i = 0; i < s->ny; i++) {
      for (j = 0; j < lx; j++) {
         tg = s->calcbuftags.xZ[j];
         rcur = s->wr.xyR[tg][0];
         bf = ae_exp(-(sqr(s->calcbufxcx.xR[0] - s->calcbufx.xyR[j][0], _state) + sqr(s->calcbufxcx.xR[1] - s->calcbufx.xyR[j][1], _state) + sqr(s->calcbufxcx.xR[2] - s->calcbufx.xyR[j][2], _state)) / sqr(rcur, _state), _state);
         for (k = 0; k < s->nl; k++) {
            y->xR[i] += bf * s->wr.xyR[tg][1 + k * s->ny + i];
            t = bf * bf;
            bf = t * t;
         }
      }
   }
}

// This function calculates values of the RBF model at the given point, using
// external  buffer  object  (internal  temporaries  of  RBF  model  are  not
// modified).
//
// This function allows to use same RBF model object  in  different  threads,
// assuming  that  different   threads  use  different  instances  of  buffer
// structure.
//
// Inputs:
//     S       -   RBF model, may be shared between different threads
//     Buf     -   buffer object created for this particular instance of  RBF
//                 model with rbfcreatecalcbuffer().
//     X       -   coordinates, array[NX].
//                 X may have more than NX elements, in this case only
//                 leading NX will be used.
//     Y       -   possibly preallocated array
//
// Outputs:
//     Y       -   function value, array[NY]. Y is not reallocated when it
//                 is larger than NY.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
void rbfv1tscalcbuf(rbfv1model *s, rbfv1calcbuffer *buf, RVector *x, RVector *y, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t lx;
   ae_int_t tg;
   double t;
   double rcur;
   double bf;
   ae_assert(x->cnt >= s->nx, "RBFCalcBuf: Length(X)<NX", _state);
   ae_assert(isfinitevector(x, s->nx, _state), "RBFCalcBuf: X contains infinite or NaN values", _state);
   if (y->cnt < s->ny) {
      ae_vector_set_length(y, s->ny, _state);
   }
   for (i = 0; i < s->ny; i++) {
      y->xR[i] = s->v.xyR[i][rbfv1_mxnx];
      for (j = 0; j < s->nx; j++) {
         y->xR[i] += s->v.xyR[i][j] * x->xR[j];
      }
   }
   if (s->nc == 0) {
      return;
   }
   rvectorsetlengthatleast(&buf->calcbufxcx, rbfv1_mxnx, _state);
   for (i = 0; i < rbfv1_mxnx; i++) {
      buf->calcbufxcx.xR[i] = 0.0;
   }
   for (i = 0; i < s->nx; i++) {
      buf->calcbufxcx.xR[i] = x->xR[i];
   }
   lx = kdtreetsqueryrnn(&s->tree, &buf->requestbuffer, &buf->calcbufxcx, s->rmax * rbfv1_rbffarradius, true, _state);
   kdtreetsqueryresultsx(&s->tree, &buf->requestbuffer, &buf->calcbufx, _state);
   kdtreetsqueryresultstags(&s->tree, &buf->requestbuffer, &buf->calcbuftags, _state);
   for (i = 0; i < s->ny; i++) {
      for (j = 0; j < lx; j++) {
         tg = buf->calcbuftags.xZ[j];
         rcur = s->wr.xyR[tg][0];
         bf = ae_exp(-(sqr(buf->calcbufxcx.xR[0] - buf->calcbufx.xyR[j][0], _state) + sqr(buf->calcbufxcx.xR[1] - buf->calcbufx.xyR[j][1], _state) + sqr(buf->calcbufxcx.xR[2] - buf->calcbufx.xyR[j][2], _state)) / sqr(rcur, _state), _state);
         for (k = 0; k < s->nl; k++) {
            y->xR[i] += bf * s->wr.xyR[tg][1 + k * s->ny + i];
            t = bf * bf;
            bf = t * t;
         }
      }
   }
}

// This function calculates values of the RBF model at the regular grid.
//
// Grid have N0*N1 points, with Point[I,J] = (X0[I], X1[J])
//
// This function returns 0.0 when:
// * model is not initialized
// * NX != 2
//  *NY != 1
//
// Inputs:
//     S       -   RBF model
//     X0      -   array of grid nodes, first coordinates, array[N0]
//     N0      -   grid size (number of nodes) in the first dimension
//     X1      -   array of grid nodes, second coordinates, array[N1]
//     N1      -   grid size (number of nodes) in the second dimension
//
// Outputs:
//     Y       -   function values, array[N0,N1]. Y is out-variable and
//                 is reallocated by this function.
//
// NOTE: as a special exception, this function supports unordered  arrays  X0
//       and X1. However, future versions may be  more  efficient  for  X0/X1
//       ordered by ascending.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
void rbfv1gridcalc2(rbfv1model *s, RVector *x0, ae_int_t n0, RVector *x1, ae_int_t n1, RMatrix *y, ae_state *_state) {
   ae_frame _frame_block;
   double rlimit;
   double xcnorm2;
   ae_int_t hp01;
   double hcpx0;
   double xc0;
   double xc1;
   double omega;
   double radius;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t d;
   ae_int_t i00;
   ae_int_t i01;
   ae_int_t i10;
   ae_int_t i11;
   ae_frame_make(_state, &_frame_block);
   SetMatrix(y);
   NewVector(cpx0, 0, DT_REAL, _state);
   NewVector(cpx1, 0, DT_REAL, _state);
   NewVector(p01, 0, DT_INT, _state);
   NewVector(p11, 0, DT_INT, _state);
   NewVector(p2, 0, DT_INT, _state);
   ae_assert(n0 > 0, "RBFGridCalc2: invalid value for N0 (N0 <= 0)!", _state);
   ae_assert(n1 > 0, "RBFGridCalc2: invalid value for N1 (N1 <= 0)!", _state);
   ae_assert(x0->cnt >= n0, "RBFGridCalc2: Length(X0)<N0", _state);
   ae_assert(x1->cnt >= n1, "RBFGridCalc2: Length(X1)<N1", _state);
   ae_assert(isfinitevector(x0, n0, _state), "RBFGridCalc2: X0 contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(x1, n1, _state), "RBFGridCalc2: X1 contains infinite or NaN values!", _state);
   ae_matrix_set_length(y, n0, n1, _state);
   for (i = 0; i < n0; i++) {
      for (j = 0; j < n1; j++) {
         y->xyR[i][j] = 0.0;
      }
   }
   if ((s->ny != 1 || s->nx != 2) || s->nc == 0) {
      ae_frame_leave(_state);
      return;
   }
// create and sort arrays
   ae_vector_set_length(&cpx0, n0, _state);
   for (i = 0; i < n0; i++) {
      cpx0.xR[i] = x0->xR[i];
   }
   tagsort(&cpx0, n0, &p01, &p2, _state);
   ae_vector_set_length(&cpx1, n1, _state);
   for (i = 0; i < n1; i++) {
      cpx1.xR[i] = x1->xR[i];
   }
   tagsort(&cpx1, n1, &p11, &p2, _state);
// calculate function's value
   for (i = 0; i < s->nc; i++) {
      radius = s->wr.xyR[i][0];
      for (d = 0; d < s->nl; d++) {
         omega = s->wr.xyR[i][1 + d];
         rlimit = radius * rbfv1_rbffarradius;
      // search lower and upper indexes
         i00 = lowerbound(&cpx0, n0, s->xc.xyR[i][0] - rlimit, _state);
         i01 = upperbound(&cpx0, n0, s->xc.xyR[i][0] + rlimit, _state);
         i10 = lowerbound(&cpx1, n1, s->xc.xyR[i][1] - rlimit, _state);
         i11 = upperbound(&cpx1, n1, s->xc.xyR[i][1] + rlimit, _state);
         xc0 = s->xc.xyR[i][0];
         xc1 = s->xc.xyR[i][1];
         for (j = i00; j < i01; j++) {
            hcpx0 = cpx0.xR[j];
            hp01 = p01.xZ[j];
            for (k = i10; k < i11; k++) {
               xcnorm2 = sqr(hcpx0 - xc0, _state) + sqr(cpx1.xR[k] - xc1, _state);
               if (xcnorm2 <= rlimit * rlimit) {
                  y->xyR[hp01][p11.xZ[k]] += ae_exp(-xcnorm2 / sqr(radius, _state), _state) * omega;
               }
            }
         }
         radius *= 0.5;
      }
   }
// add linear term
   for (i = 0; i < n0; i++) {
      for (j = 0; j < n1; j++) {
         y->xyR[i][j] += s->v.xyR[0][0] * x0->xR[i] + s->v.xyR[0][1] * x1->xR[j] + s->v.xyR[0][rbfv1_mxnx];
      }
   }
   ae_frame_leave(_state);
}

void rbfv1gridcalc3vrec(rbfv1model *s, RVector *x0, ae_int_t n0, RVector *x1, ae_int_t n1, RVector *x2, ae_int_t n2, ZVector *blocks0, ae_int_t block0a, ae_int_t block0b, ZVector *blocks1, ae_int_t block1a, ae_int_t block1b, ZVector *blocks2, ae_int_t block2a, ae_int_t block2b, BVector *flagy, bool sparsey, double searchradius, double avgfuncpernode, ae_shared_pool *bufpool, RVector *y, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t t;
   ae_int_t l;
   ae_int_t i0;
   ae_int_t i1;
   ae_int_t i2;
   ae_int_t ic;
   ae_int_t flag12dim1;
   ae_int_t flag12dim2;
   double problemcost;
   ae_int_t maxbs;
   ae_int_t nx;
   ae_int_t ny;
   double v;
   ae_int_t kc;
   ae_int_t tg;
   double rcur;
   double rcur2;
   double basisfuncval;
   ae_int_t dstoffs;
   ae_int_t srcoffs;
   ae_int_t ubnd;
   double w0;
   double w1;
   double w2;
   bool allnodes;
   bool somenodes;
   ae_frame_make(_state, &_frame_block);
   RefObj(gridcalc3v1buf, pbuf, _state);
   nx = s->nx;
   ny = s->ny;
// Try to split large problem
   problemcost = (s->nl + 1) * s->ny * 2 * (avgfuncpernode + 1);
   problemcost *= blocks0->xZ[block0b] - blocks0->xZ[block0a];
   problemcost *= blocks1->xZ[block1b] - blocks1->xZ[block1a];
   problemcost *= blocks2->xZ[block2b] - blocks2->xZ[block2a];
   maxbs = 0;
   maxbs = maxint(maxbs, block0b - block0a, _state);
   maxbs = maxint(maxbs, block1b - block1a, _state);
   maxbs = maxint(maxbs, block2b - block2a, _state);
   if (problemcost >= rbfv1_minbasecasecost && maxbs >= 2) {
      if (block0b - block0a == maxbs) {
         rbfv1gridcalc3vrec(s, x0, n0, x1, n1, x2, n2, blocks0, block0a, block0a + maxbs / 2, blocks1, block1a, block1b, blocks2, block2a, block2b, flagy, sparsey, searchradius, avgfuncpernode, bufpool, y, _state);
         rbfv1gridcalc3vrec(s, x0, n0, x1, n1, x2, n2, blocks0, block0a + maxbs / 2, block0b, blocks1, block1a, block1b, blocks2, block2a, block2b, flagy, sparsey, searchradius, avgfuncpernode, bufpool, y, _state);
         ae_frame_leave(_state);
         return;
      }
      if (block1b - block1a == maxbs) {
         rbfv1gridcalc3vrec(s, x0, n0, x1, n1, x2, n2, blocks0, block0a, block0b, blocks1, block1a, block1a + maxbs / 2, blocks2, block2a, block2b, flagy, sparsey, searchradius, avgfuncpernode, bufpool, y, _state);
         rbfv1gridcalc3vrec(s, x0, n0, x1, n1, x2, n2, blocks0, block0a, block0b, blocks1, block1a + maxbs / 2, block1b, blocks2, block2a, block2b, flagy, sparsey, searchradius, avgfuncpernode, bufpool, y, _state);
         ae_frame_leave(_state);
         return;
      }
      if (block2b - block2a == maxbs) {
         rbfv1gridcalc3vrec(s, x0, n0, x1, n1, x2, n2, blocks0, block0a, block0b, blocks1, block1a, block1b, blocks2, block2a, block2a + maxbs / 2, flagy, sparsey, searchradius, avgfuncpernode, bufpool, y, _state);
         rbfv1gridcalc3vrec(s, x0, n0, x1, n1, x2, n2, blocks0, block0a, block0b, blocks1, block1a, block1b, blocks2, block2a + maxbs / 2, block2b, flagy, sparsey, searchradius, avgfuncpernode, bufpool, y, _state);
         ae_frame_leave(_state);
         return;
      }
   }
// Retrieve buffer object from pool (it will be returned later)
   ae_shared_pool_retrieve(bufpool, &_pbuf, _state);
// Calculate RBF model
   for (i2 = block2a; i2 < block2b; i2++) {
      for (i1 = block1a; i1 < block1b; i1++) {
         for (i0 = block0a; i0 < block0b; i0++) {
         // Analyze block - determine what elements are needed and what are not.
         //
         // After this block is done, two flag variables can be used:
         // * SomeNodes, which is True when there are at least one node which have
         //   to be calculated
         // * AllNodes, which is True when all nodes are required
            somenodes = true;
            allnodes = true;
            flag12dim1 = blocks1->xZ[i1 + 1] - blocks1->xZ[i1];
            flag12dim2 = blocks2->xZ[i2 + 1] - blocks2->xZ[i2];
            if (sparsey) {
            // Use FlagY to determine what is required.
               bvectorsetlengthatleast(&pbuf->flag0, n0, _state);
               bvectorsetlengthatleast(&pbuf->flag1, n1, _state);
               bvectorsetlengthatleast(&pbuf->flag2, n2, _state);
               bvectorsetlengthatleast(&pbuf->flag12, flag12dim1 * flag12dim2, _state);
               for (i = blocks0->xZ[i0]; i < blocks0->xZ[i0 + 1]; i++) {
                  pbuf->flag0.xB[i] = false;
               }
               for (j = blocks1->xZ[i1]; j < blocks1->xZ[i1 + 1]; j++) {
                  pbuf->flag1.xB[j] = false;
               }
               for (k = blocks2->xZ[i2]; k < blocks2->xZ[i2 + 1]; k++) {
                  pbuf->flag2.xB[k] = false;
               }
               for (i = 0; i < flag12dim1 * flag12dim2; i++) {
                  pbuf->flag12.xB[i] = false;
               }
               somenodes = false;
               allnodes = true;
               for (k = blocks2->xZ[i2]; k < blocks2->xZ[i2 + 1]; k++) {
                  for (j = blocks1->xZ[i1]; j < blocks1->xZ[i1 + 1]; j++) {
                     dstoffs = j - blocks1->xZ[i1] + flag12dim1 * (k - blocks2->xZ[i2]);
                     srcoffs = j * n0 + k * n0 * n1;
                     for (i = blocks0->xZ[i0]; i < blocks0->xZ[i0 + 1]; i++) {
                        if (flagy->xB[srcoffs + i]) {
                           pbuf->flag0.xB[i] = true;
                           pbuf->flag1.xB[j] = true;
                           pbuf->flag2.xB[k] = true;
                           pbuf->flag12.xB[dstoffs] = true;
                           somenodes = true;
                        } else {
                           allnodes = false;
                        }
                     }
                  }
               }
            }
         // Skip block if it is completely empty.
            if (!somenodes) {
               continue;
            }
         // compute linear term for block (I0,I1,I2)
            for (k = blocks2->xZ[i2]; k < blocks2->xZ[i2 + 1]; k++) {
               for (j = blocks1->xZ[i1]; j < blocks1->xZ[i1 + 1]; j++) {
               // do we need this micro-row?
                  if (!allnodes && !pbuf->flag12.xB[j - blocks1->xZ[i1] + flag12dim1 * (k - blocks2->xZ[i2])]) {
                     continue;
                  }
               // Compute linear term
                  for (i = blocks0->xZ[i0]; i < blocks0->xZ[i0 + 1]; i++) {
                     pbuf->tx.xR[0] = x0->xR[i];
                     pbuf->tx.xR[1] = x1->xR[j];
                     pbuf->tx.xR[2] = x2->xR[k];
                     for (l = 0; l < s->ny; l++) {
                        v = s->v.xyR[l][rbfv1_mxnx];
                        for (t = 0; t < nx; t++) {
                           v += s->v.xyR[l][t] * pbuf->tx.xR[t];
                        }
                        y->xR[l + ny * (i + j * n0 + k * n0 * n1)] = v;
                     }
                  }
               }
            }
         // compute RBF term for block (I0,I1,I2)
            pbuf->tx.xR[0] = 0.5 * (x0->xR[blocks0->xZ[i0]] + x0->xR[blocks0->xZ[i0 + 1] - 1]);
            pbuf->tx.xR[1] = 0.5 * (x1->xR[blocks1->xZ[i1]] + x1->xR[blocks1->xZ[i1 + 1] - 1]);
            pbuf->tx.xR[2] = 0.5 * (x2->xR[blocks2->xZ[i2]] + x2->xR[blocks2->xZ[i2 + 1] - 1]);
            kc = kdtreetsqueryrnn(&s->tree, &pbuf->requestbuf, &pbuf->tx, searchradius, true, _state);
            kdtreetsqueryresultsx(&s->tree, &pbuf->requestbuf, &pbuf->calcbufx, _state);
            kdtreetsqueryresultstags(&s->tree, &pbuf->requestbuf, &pbuf->calcbuftags, _state);
            for (ic = 0; ic < kc; ic++) {
               pbuf->cx.xR[0] = pbuf->calcbufx.xyR[ic][0];
               pbuf->cx.xR[1] = pbuf->calcbufx.xyR[ic][1];
               pbuf->cx.xR[2] = pbuf->calcbufx.xyR[ic][2];
               tg = pbuf->calcbuftags.xZ[ic];
               rcur = s->wr.xyR[tg][0];
               rcur2 = rcur * rcur;
               for (i = blocks0->xZ[i0]; i < blocks0->xZ[i0 + 1]; i++) {
                  if (allnodes || pbuf->flag0.xB[i]) {
                     pbuf->expbuf0.xR[i] = ae_exp(-sqr(x0->xR[i] - pbuf->cx.xR[0], _state) / rcur2, _state);
                  } else {
                     pbuf->expbuf0.xR[i] = 0.0;
                  }
               }
               for (j = blocks1->xZ[i1]; j < blocks1->xZ[i1 + 1]; j++) {
                  if (allnodes || pbuf->flag1.xB[j]) {
                     pbuf->expbuf1.xR[j] = ae_exp(-sqr(x1->xR[j] - pbuf->cx.xR[1], _state) / rcur2, _state);
                  } else {
                     pbuf->expbuf1.xR[j] = 0.0;
                  }
               }
               for (k = blocks2->xZ[i2]; k < blocks2->xZ[i2 + 1]; k++) {
                  if (allnodes || pbuf->flag2.xB[k]) {
                     pbuf->expbuf2.xR[k] = ae_exp(-sqr(x2->xR[k] - pbuf->cx.xR[2], _state) / rcur2, _state);
                  } else {
                     pbuf->expbuf2.xR[k] = 0.0;
                  }
               }
               for (t = 0; t < s->nl; t++) {
               // Calculate
                  for (k = blocks2->xZ[i2]; k < blocks2->xZ[i2 + 1]; k++) {
                     for (j = blocks1->xZ[i1]; j < blocks1->xZ[i1 + 1]; j++) {
                     // do we need this micro-row?
                        if (!allnodes && !pbuf->flag12.xB[j - blocks1->xZ[i1] + flag12dim1 * (k - blocks2->xZ[i2])]) {
                           continue;
                        }
                     // Prepare local variables
                        dstoffs = ny * (blocks0->xZ[i0] + j * n0 + k * n0 * n1);
                        v = pbuf->expbuf1.xR[j] * pbuf->expbuf2.xR[k];
                     // Optimized for NY=1
                        if (s->ny == 1) {
                           w0 = s->wr.xyR[tg][1 + t * s->ny + 0];
                           ubnd = blocks0->xZ[i0 + 1] - 1;
                           for (i = blocks0->xZ[i0]; i <= ubnd; i++) {
                              basisfuncval = pbuf->expbuf0.xR[i] * v;
                              y->xR[dstoffs] += basisfuncval * w0;
                              dstoffs++;
                           }
                           continue;
                        }
                     // Optimized for NY=2
                        if (s->ny == 2) {
                           w0 = s->wr.xyR[tg][1 + t * s->ny + 0];
                           w1 = s->wr.xyR[tg][1 + t * s->ny + 1];
                           ubnd = blocks0->xZ[i0 + 1] - 1;
                           for (i = blocks0->xZ[i0]; i <= ubnd; i++) {
                              basisfuncval = pbuf->expbuf0.xR[i] * v;
                              y->xR[dstoffs + 0] += basisfuncval * w0;
                              y->xR[dstoffs + 1] += basisfuncval * w1;
                              dstoffs += 2;
                           }
                           continue;
                        }
                     // Optimized for NY=3
                        if (s->ny == 3) {
                           w0 = s->wr.xyR[tg][1 + t * s->ny + 0];
                           w1 = s->wr.xyR[tg][1 + t * s->ny + 1];
                           w2 = s->wr.xyR[tg][1 + t * s->ny + 2];
                           ubnd = blocks0->xZ[i0 + 1] - 1;
                           for (i = blocks0->xZ[i0]; i <= ubnd; i++) {
                              basisfuncval = pbuf->expbuf0.xR[i] * v;
                              y->xR[dstoffs + 0] += basisfuncval * w0;
                              y->xR[dstoffs + 1] += basisfuncval * w1;
                              y->xR[dstoffs + 2] += basisfuncval * w2;
                              dstoffs += 3;
                           }
                           continue;
                        }
                     // General case
                        for (i = blocks0->xZ[i0]; i < blocks0->xZ[i0 + 1]; i++) {
                           basisfuncval = pbuf->expbuf0.xR[i] * v;
                           for (l = 0; l < s->ny; l++) {
                              y->xR[l + dstoffs] += basisfuncval * s->wr.xyR[tg][1 + t * s->ny + l];
                           }
                           dstoffs += ny;
                        }
                     }
                  }
               // Update basis functions
                  if (t != s->nl - 1) {
                     ubnd = blocks0->xZ[i0 + 1] - 1;
                     for (i = blocks0->xZ[i0]; i <= ubnd; i++) {
                        if (allnodes || pbuf->flag0.xB[i]) {
                           v = pbuf->expbuf0.xR[i] * pbuf->expbuf0.xR[i];
                           pbuf->expbuf0.xR[i] = v * v;
                        }
                     }
                     ubnd = blocks1->xZ[i1 + 1] - 1;
                     for (j = blocks1->xZ[i1]; j <= ubnd; j++) {
                        if (allnodes || pbuf->flag1.xB[j]) {
                           v = pbuf->expbuf1.xR[j] * pbuf->expbuf1.xR[j];
                           pbuf->expbuf1.xR[j] = v * v;
                        }
                     }
                     ubnd = blocks2->xZ[i2 + 1] - 1;
                     for (k = blocks2->xZ[i2]; k <= ubnd; k++) {
                        if (allnodes || pbuf->flag2.xB[k]) {
                           v = pbuf->expbuf2.xR[k] * pbuf->expbuf2.xR[k];
                           pbuf->expbuf2.xR[k] = v * v;
                        }
                     }
                  }
               }
            }
         }
      }
   }
// Recycle buffer object back to pool
   ae_shared_pool_recycle(bufpool, &_pbuf, _state);
   ae_frame_leave(_state);
}

// This function "unpacks" RBF model by extracting its coefficients.
//
// Inputs:
//     S       -   RBF model
//
// Outputs:
//     NX      -   dimensionality of argument
//     NY      -   dimensionality of the target function
//     XWR     -   model information, array[NC,NX+NY+1].
//                 One row of the array corresponds to one basis function:
//                 * first NX columns  - coordinates of the center
//                 * next NY columns   - weights, one per dimension of the
//                                       function being modelled
//                 * last column       - radius, same for all dimensions of
//                                       the function being modelled
//     NC      -   number of the centers
//     V       -   polynomial  term , array[NY,NX+1]. One row per one
//                 dimension of the function being modelled. First NX
//                 elements are linear coefficients, V[NX] is equal to the
//                 constant part.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
void rbfv1unpack(rbfv1model *s, ae_int_t *nx, ae_int_t *ny, RMatrix *xwr, ae_int_t *nc, RMatrix *v, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   double rcur;
   *nx = 0;
   *ny = 0;
   SetMatrix(xwr);
   *nc = 0;
   SetMatrix(v);
   *nx = s->nx;
   *ny = s->ny;
   *nc = s->nc;
// Fill V
   ae_matrix_set_length(v, s->ny, s->nx + 1, _state);
   for (i = 0; i < s->ny; i++) {
      ae_v_move(v->xyR[i], 1, s->v.xyR[i], 1, s->nx);
      v->xyR[i][s->nx] = s->v.xyR[i][rbfv1_mxnx];
   }
// Fill XWR and V
   if (*nc * s->nl > 0) {
      ae_matrix_set_length(xwr, s->nc * s->nl, s->nx + s->ny + 1, _state);
      for (i = 0; i < s->nc; i++) {
         rcur = s->wr.xyR[i][0];
         for (j = 0; j < s->nl; j++) {
            ae_v_move(xwr->xyR[i * s->nl + j], 1, s->xc.xyR[i], 1, s->nx);
            ae_v_move(&xwr->xyR[i * s->nl + j][s->nx], 1, &s->wr.xyR[i][1 + j * s->ny], 1, s->ny);
            xwr->xyR[i * s->nl + j][s->nx + s->ny] = rcur;
            rcur *= 0.5;
         }
      }
   }
}

// Serializer: allocation
// ALGLIB: Copyright 02.02.2012 by Sergey Bochkanov
void rbfv1alloc(ae_serializer *s, rbfv1model *model, ae_state *_state) {
// Data
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   kdtreealloc(s, &model->tree, _state);
   allocrealmatrix(s, &model->xc, -1, -1, _state);
   allocrealmatrix(s, &model->wr, -1, -1, _state);
   ae_serializer_alloc_entry(s);
   allocrealmatrix(s, &model->v, -1, -1, _state);
}

// Serializer: serialization
// ALGLIB: Copyright 02.02.2012 by Sergey Bochkanov
void rbfv1serialize(ae_serializer *s, rbfv1model *model, ae_state *_state) {
// Data
   ae_serializer_serialize_int(s, model->nx, _state);
   ae_serializer_serialize_int(s, model->ny, _state);
   ae_serializer_serialize_int(s, model->nc, _state);
   ae_serializer_serialize_int(s, model->nl, _state);
   kdtreeserialize(s, &model->tree, _state);
   serializerealmatrix(s, &model->xc, -1, -1, _state);
   serializerealmatrix(s, &model->wr, -1, -1, _state);
   ae_serializer_serialize_double(s, model->rmax, _state);
   serializerealmatrix(s, &model->v, -1, -1, _state);
}

// Serializer: unserialization
// ALGLIB: Copyright 02.02.2012 by Sergey Bochkanov
void rbfv1unserialize(ae_serializer *s, rbfv1model *model, ae_state *_state) {
   ae_int_t nx;
   ae_int_t ny;
   SetObj(rbfv1model, model);
// Unserialize primary model parameters, initialize model.
//
// It is necessary to call RBFCreate() because some internal fields
// which are NOT unserialized will need initialization.
   ae_serializer_unserialize_int(s, &nx, _state);
   ae_serializer_unserialize_int(s, &ny, _state);
   rbfv1create(nx, ny, model, _state);
   ae_serializer_unserialize_int(s, &model->nc, _state);
   ae_serializer_unserialize_int(s, &model->nl, _state);
   kdtreeunserialize(s, &model->tree, _state);
   unserializerealmatrix(s, &model->xc, _state);
   unserializerealmatrix(s, &model->wr, _state);
   ae_serializer_unserialize_double(s, &model->rmax, _state);
   unserializerealmatrix(s, &model->v, _state);
}

void rbfv1calcbuffer_init(void *_p, ae_state *_state, bool make_automatic) {
   rbfv1calcbuffer *p = (rbfv1calcbuffer *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->calcbufxcx, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->calcbufx, 0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->calcbuftags, 0, DT_INT, _state, make_automatic);
   kdtreerequestbuffer_init(&p->requestbuffer, _state, make_automatic);
}

void rbfv1calcbuffer_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   rbfv1calcbuffer *dst = (rbfv1calcbuffer *)_dst;
   rbfv1calcbuffer *src = (rbfv1calcbuffer *)_src;
   ae_vector_copy(&dst->calcbufxcx, &src->calcbufxcx, _state, make_automatic);
   ae_matrix_copy(&dst->calcbufx, &src->calcbufx, _state, make_automatic);
   ae_vector_copy(&dst->calcbuftags, &src->calcbuftags, _state, make_automatic);
   kdtreerequestbuffer_copy(&dst->requestbuffer, &src->requestbuffer, _state, make_automatic);
}

void rbfv1calcbuffer_free(void *_p, bool make_automatic) {
   rbfv1calcbuffer *p = (rbfv1calcbuffer *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->calcbufxcx, make_automatic);
   ae_matrix_free(&p->calcbufx, make_automatic);
   ae_vector_free(&p->calcbuftags, make_automatic);
   kdtreerequestbuffer_free(&p->requestbuffer, make_automatic);
}

void rbfv1model_init(void *_p, ae_state *_state, bool make_automatic) {
   rbfv1model *p = (rbfv1model *)_p;
   ae_touch_ptr((void *)p);
   kdtree_init(&p->tree, _state, make_automatic);
   ae_matrix_init(&p->xc, 0, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->wr, 0, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->v, 0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->calcbufxcx, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->calcbufx, 0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->calcbuftags, 0, DT_INT, _state, make_automatic);
}

void rbfv1model_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   rbfv1model *dst = (rbfv1model *)_dst;
   rbfv1model *src = (rbfv1model *)_src;
   dst->ny = src->ny;
   dst->nx = src->nx;
   dst->nc = src->nc;
   dst->nl = src->nl;
   kdtree_copy(&dst->tree, &src->tree, _state, make_automatic);
   ae_matrix_copy(&dst->xc, &src->xc, _state, make_automatic);
   ae_matrix_copy(&dst->wr, &src->wr, _state, make_automatic);
   dst->rmax = src->rmax;
   ae_matrix_copy(&dst->v, &src->v, _state, make_automatic);
   ae_vector_copy(&dst->calcbufxcx, &src->calcbufxcx, _state, make_automatic);
   ae_matrix_copy(&dst->calcbufx, &src->calcbufx, _state, make_automatic);
   ae_vector_copy(&dst->calcbuftags, &src->calcbuftags, _state, make_automatic);
}

void rbfv1model_free(void *_p, bool make_automatic) {
   rbfv1model *p = (rbfv1model *)_p;
   ae_touch_ptr((void *)p);
   kdtree_free(&p->tree, make_automatic);
   ae_matrix_free(&p->xc, make_automatic);
   ae_matrix_free(&p->wr, make_automatic);
   ae_matrix_free(&p->v, make_automatic);
   ae_vector_free(&p->calcbufxcx, make_automatic);
   ae_matrix_free(&p->calcbufx, make_automatic);
   ae_vector_free(&p->calcbuftags, make_automatic);
}

void gridcalc3v1buf_init(void *_p, ae_state *_state, bool make_automatic) {
   gridcalc3v1buf *p = (gridcalc3v1buf *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->tx, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->cx, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->ty, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->flag0, 0, DT_BOOL, _state, make_automatic);
   ae_vector_init(&p->flag1, 0, DT_BOOL, _state, make_automatic);
   ae_vector_init(&p->flag2, 0, DT_BOOL, _state, make_automatic);
   ae_vector_init(&p->flag12, 0, DT_BOOL, _state, make_automatic);
   ae_vector_init(&p->expbuf0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->expbuf1, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->expbuf2, 0, DT_REAL, _state, make_automatic);
   kdtreerequestbuffer_init(&p->requestbuf, _state, make_automatic);
   ae_matrix_init(&p->calcbufx, 0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->calcbuftags, 0, DT_INT, _state, make_automatic);
}

void gridcalc3v1buf_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   gridcalc3v1buf *dst = (gridcalc3v1buf *)_dst;
   gridcalc3v1buf *src = (gridcalc3v1buf *)_src;
   ae_vector_copy(&dst->tx, &src->tx, _state, make_automatic);
   ae_vector_copy(&dst->cx, &src->cx, _state, make_automatic);
   ae_vector_copy(&dst->ty, &src->ty, _state, make_automatic);
   ae_vector_copy(&dst->flag0, &src->flag0, _state, make_automatic);
   ae_vector_copy(&dst->flag1, &src->flag1, _state, make_automatic);
   ae_vector_copy(&dst->flag2, &src->flag2, _state, make_automatic);
   ae_vector_copy(&dst->flag12, &src->flag12, _state, make_automatic);
   ae_vector_copy(&dst->expbuf0, &src->expbuf0, _state, make_automatic);
   ae_vector_copy(&dst->expbuf1, &src->expbuf1, _state, make_automatic);
   ae_vector_copy(&dst->expbuf2, &src->expbuf2, _state, make_automatic);
   kdtreerequestbuffer_copy(&dst->requestbuf, &src->requestbuf, _state, make_automatic);
   ae_matrix_copy(&dst->calcbufx, &src->calcbufx, _state, make_automatic);
   ae_vector_copy(&dst->calcbuftags, &src->calcbuftags, _state, make_automatic);
}

void gridcalc3v1buf_free(void *_p, bool make_automatic) {
   gridcalc3v1buf *p = (gridcalc3v1buf *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->tx, make_automatic);
   ae_vector_free(&p->cx, make_automatic);
   ae_vector_free(&p->ty, make_automatic);
   ae_vector_free(&p->flag0, make_automatic);
   ae_vector_free(&p->flag1, make_automatic);
   ae_vector_free(&p->flag2, make_automatic);
   ae_vector_free(&p->flag12, make_automatic);
   ae_vector_free(&p->expbuf0, make_automatic);
   ae_vector_free(&p->expbuf1, make_automatic);
   ae_vector_free(&p->expbuf2, make_automatic);
   kdtreerequestbuffer_free(&p->requestbuf, make_automatic);
   ae_matrix_free(&p->calcbufx, make_automatic);
   ae_vector_free(&p->calcbuftags, make_automatic);
}

void rbfv1report_init(void *_p, ae_state *_state, bool make_automatic) {
   rbfv1report *p = (rbfv1report *)_p;
   ae_touch_ptr((void *)p);
}

void rbfv1report_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   rbfv1report *dst = (rbfv1report *)_dst;
   rbfv1report *src = (rbfv1report *)_src;
   dst->arows = src->arows;
   dst->acols = src->acols;
   dst->annz = src->annz;
   dst->iterationscount = src->iterationscount;
   dst->nmv = src->nmv;
   dst->terminationtype = src->terminationtype;
}

void rbfv1report_free(void *_p, bool make_automatic) {
   rbfv1report *p = (rbfv1report *)_p;
   ae_touch_ptr((void *)p);
}
} // end of namespace alglib_impl

// === SPLINE2D Package ===
// Depends on: SPLINE1D
namespace alglib_impl {
static const double spline2d_cholreg = 1.0E-12;
static const double spline2d_lambdaregblocklls = 1.0E-6;
static const double spline2d_lambdaregfastddm = 1.0E-4;
static const double spline2d_lambdadecay = 0.5;

// This subroutine calculates the value of the bilinear or bicubic spline  at
// the given point X.
//
// Inputs:
//     C   -   2D spline object.
//             Built by spline2dbuildbilinearv or spline2dbuildbicubicv.
//     X, Y-   point
//
// Result:
//     S(x,y)
// ALGLIB Project: Copyright 05.07.2007 by Sergey Bochkanov
// API: double spline2dcalc(const spline2dinterpolant &c, const double x, const double y, const xparams _xparams = xdefault);
double spline2dcalc(spline2dinterpolant *c, double x, double y, ae_state *_state) {
   ae_int_t ix;
   ae_int_t iy;
   ae_int_t l;
   ae_int_t r;
   ae_int_t h;
   double t;
   double dt;
   double u;
   double du;
   double y1;
   double y2;
   double y3;
   double y4;
   ae_int_t s1;
   ae_int_t s2;
   ae_int_t s3;
   ae_int_t s4;
   ae_int_t sfx;
   ae_int_t sfy;
   ae_int_t sfxy;
   double t2;
   double t3;
   double u2;
   double u3;
   double ht00;
   double ht01;
   double ht10;
   double ht11;
   double hu00;
   double hu01;
   double hu10;
   double hu11;
   double result;
   ae_assert(c->stype == -1 || c->stype == -3, "Spline2DCalc: incorrect C (incorrect parameter C.SType)", _state);
   ae_assert(ae_isfinite(x, _state) && ae_isfinite(y, _state), "Spline2DCalc: X or Y contains NaN or Infinite value", _state);
   if (c->d != 1) {
      result = 0.0;
      return result;
   }
// Determine evaluation interval
   l = 0;
   r = c->n - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->x.xR[h] >= x) {
         r = h;
      } else {
         l = h;
      }
   }
   dt = 1.0 / (c->x.xR[l + 1] - c->x.xR[l]);
   t = (x - c->x.xR[l]) * dt;
   ix = l;
   l = 0;
   r = c->m - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->y.xR[h] >= y) {
         r = h;
      } else {
         l = h;
      }
   }
   du = 1.0 / (c->y.xR[l + 1] - c->y.xR[l]);
   u = (y - c->y.xR[l]) * du;
   iy = l;
// Bilinear interpolation
   if (c->stype == -1) {
      y1 = c->f.xR[c->n * iy + ix];
      y2 = c->f.xR[c->n * iy + (ix + 1)];
      y3 = c->f.xR[c->n * (iy + 1) + (ix + 1)];
      y4 = c->f.xR[c->n * (iy + 1) + ix];
      result = (1 - t) * (1 - u) * y1 + t * (1 - u) * y2 + t * u * y3 + (1 - t) * u * y4;
      return result;
   }
// Bicubic interpolation:
// * calculate Hermite basis for dimensions X and Y (variables T and U),
//   here HTij means basis function whose I-th derivative has value 1 at T=J.
//   Same for HUij.
// * after initial calculation, apply scaling by DT/DU to the basis
// * calculate using stored table of second derivatives
   ae_assert(c->stype == -3, "Spline2DCalc: integrity check failed", _state);
   sfx = c->n * c->m;
   sfy = 2 * c->n * c->m;
   sfxy = 3 * c->n * c->m;
   s1 = c->n * iy + ix;
   s2 = c->n * iy + (ix + 1);
   s3 = c->n * (iy + 1) + ix;
   s4 = c->n * (iy + 1) + (ix + 1);
   t2 = t * t;
   t3 = t * t2;
   u2 = u * u;
   u3 = u * u2;
   ht00 = 2 * t3 - 3 * t2 + 1;
   ht10 = t3 - 2 * t2 + t;
   ht01 = -2 * t3 + 3 * t2;
   ht11 = t3 - t2;
   hu00 = 2 * u3 - 3 * u2 + 1;
   hu10 = u3 - 2 * u2 + u;
   hu01 = -2 * u3 + 3 * u2;
   hu11 = u3 - u2;
   ht10 /= dt;
   ht11 /= dt;
   hu10 /= du;
   hu11 /= du;
   result = 0.0;
   result += c->f.xR[s1] * ht00 * hu00 + c->f.xR[s2] * ht01 * hu00 + c->f.xR[s3] * ht00 * hu01 + c->f.xR[s4] * ht01 * hu01;
   result += c->f.xR[sfx + s1] * ht10 * hu00 + c->f.xR[sfx + s2] * ht11 * hu00 + c->f.xR[sfx + s3] * ht10 * hu01 + c->f.xR[sfx + s4] * ht11 * hu01;
   result += c->f.xR[sfy + s1] * ht00 * hu10 + c->f.xR[sfy + s2] * ht01 * hu10 + c->f.xR[sfy + s3] * ht00 * hu11 + c->f.xR[sfy + s4] * ht01 * hu11;
   result += c->f.xR[sfxy + s1] * ht10 * hu10 + c->f.xR[sfxy + s2] * ht11 * hu10 + c->f.xR[sfxy + s3] * ht10 * hu11 + c->f.xR[sfxy + s4] * ht11 * hu11;
   return result;
}

// This subroutine calculates bilinear or bicubic vector-valued spline at the
// given point (X,Y).
//
// If you need just some specific component of vector-valued spline, you  can
// use spline2dcalcvi() function.
//
// Inputs:
//     C   -   spline interpolant.
//     X, Y-   point
//     F   -   output buffer, possibly preallocated array. In case array size
//             is large enough to store result, it is not reallocated.  Array
//             which is too short will be reallocated
//
// Outputs:
//     F   -   array[D] (or larger) which stores function values
// ALGLIB Project: Copyright 01.02.2018 by Sergey Bochkanov
// API: void spline2dcalcvbuf(const spline2dinterpolant &c, const double x, const double y, real_1d_array &f, const xparams _xparams = xdefault);
void spline2dcalcvbuf(spline2dinterpolant *c, double x, double y, RVector *f, ae_state *_state) {
   ae_int_t ix;
   ae_int_t iy;
   ae_int_t l;
   ae_int_t r;
   ae_int_t h;
   ae_int_t i;
   double t;
   double dt;
   double u;
   double du;
   double y1;
   double y2;
   double y3;
   double y4;
   ae_int_t s1;
   ae_int_t s2;
   ae_int_t s3;
   ae_int_t s4;
   ae_int_t sfx;
   ae_int_t sfy;
   ae_int_t sfxy;
   double t2;
   double t3;
   double u2;
   double u3;
   double ht00;
   double ht01;
   double ht10;
   double ht11;
   double hu00;
   double hu01;
   double hu10;
   double hu11;
   ae_assert(c->stype == -1 || c->stype == -3, "Spline2DCalcVBuf: incorrect C (incorrect parameter C.SType)", _state);
   ae_assert(ae_isfinite(x, _state) && ae_isfinite(y, _state), "Spline2DCalcVBuf: X or Y contains NaN or Infinite value", _state);
// Allocate place for output
   rvectorsetlengthatleast(f, c->d, _state);
// Determine evaluation interval
   l = 0;
   r = c->n - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->x.xR[h] >= x) {
         r = h;
      } else {
         l = h;
      }
   }
   dt = 1.0 / (c->x.xR[l + 1] - c->x.xR[l]);
   t = (x - c->x.xR[l]) * dt;
   ix = l;
   l = 0;
   r = c->m - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->y.xR[h] >= y) {
         r = h;
      } else {
         l = h;
      }
   }
   du = 1.0 / (c->y.xR[l + 1] - c->y.xR[l]);
   u = (y - c->y.xR[l]) * du;
   iy = l;
// Bilinear interpolation
   if (c->stype == -1) {
      for (i = 0; i < c->d; i++) {
         y1 = c->f.xR[c->d * (c->n * iy + ix) + i];
         y2 = c->f.xR[c->d * (c->n * iy + (ix + 1)) + i];
         y3 = c->f.xR[c->d * (c->n * (iy + 1) + (ix + 1)) + i];
         y4 = c->f.xR[c->d * (c->n * (iy + 1) + ix) + i];
         f->xR[i] = (1 - t) * (1 - u) * y1 + t * (1 - u) * y2 + t * u * y3 + (1 - t) * u * y4;
      }
      return;
   }
// Bicubic interpolation:
// * calculate Hermite basis for dimensions X and Y (variables T and U),
//   here HTij means basis function whose I-th derivative has value 1 at T=J.
//   Same for HUij.
// * after initial calculation, apply scaling by DT/DU to the basis
// * calculate using stored table of second derivatives
   ae_assert(c->stype == -3, "Spline2DCalc: integrity check failed", _state);
   sfx = c->n * c->m * c->d;
   sfy = 2 * c->n * c->m * c->d;
   sfxy = 3 * c->n * c->m * c->d;
   s1 = (c->n * iy + ix) * c->d;
   s2 = (c->n * iy + (ix + 1)) * c->d;
   s3 = (c->n * (iy + 1) + ix) * c->d;
   s4 = (c->n * (iy + 1) + (ix + 1)) * c->d;
   t2 = t * t;
   t3 = t * t2;
   u2 = u * u;
   u3 = u * u2;
   ht00 = 2 * t3 - 3 * t2 + 1;
   ht10 = t3 - 2 * t2 + t;
   ht01 = -2 * t3 + 3 * t2;
   ht11 = t3 - t2;
   hu00 = 2 * u3 - 3 * u2 + 1;
   hu10 = u3 - 2 * u2 + u;
   hu01 = -2 * u3 + 3 * u2;
   hu11 = u3 - u2;
   ht10 /= dt;
   ht11 /= dt;
   hu10 /= du;
   hu11 /= du;
   for (i = 0; i < c->d; i++) {
   // Calculate I-th component
      f->xR[i] = 0.0;
      f->xR[i] += c->f.xR[s1] * ht00 * hu00 + c->f.xR[s2] * ht01 * hu00 + c->f.xR[s3] * ht00 * hu01 + c->f.xR[s4] * ht01 * hu01;
      f->xR[i] += c->f.xR[sfx + s1] * ht10 * hu00 + c->f.xR[sfx + s2] * ht11 * hu00 + c->f.xR[sfx + s3] * ht10 * hu01 + c->f.xR[sfx + s4] * ht11 * hu01;
      f->xR[i] += c->f.xR[sfy + s1] * ht00 * hu10 + c->f.xR[sfy + s2] * ht01 * hu10 + c->f.xR[sfy + s3] * ht00 * hu11 + c->f.xR[sfy + s4] * ht01 * hu11;
      f->xR[i] += c->f.xR[sfxy + s1] * ht10 * hu10 + c->f.xR[sfxy + s2] * ht11 * hu10 + c->f.xR[sfxy + s3] * ht10 * hu11 + c->f.xR[sfxy + s4] * ht11 * hu11;
   // Advance source indexes
      s1++;
      s2++;
      s3++;
      s4++;
   }
}

// This subroutine calculates bilinear or bicubic vector-valued spline at the
// given point (X,Y).
//
// Inputs:
//     C   -   spline interpolant.
//     X, Y-   point
//
// Outputs:
//     F   -   array[D] which stores function values.  F is out-parameter and
//             it  is  reallocated  after  call to this function. In case you
//             want  to    reuse  previously  allocated  F,   you   may   use
//             Spline2DCalcVBuf(),  which  reallocates  F only when it is too
//             small.
// ALGLIB Project: Copyright 16.04.2012 by Sergey Bochkanov
// API: void spline2dcalcv(const spline2dinterpolant &c, const double x, const double y, real_1d_array &f, const xparams _xparams = xdefault);
void spline2dcalcv(spline2dinterpolant *c, double x, double y, RVector *f, ae_state *_state) {
   SetVector(f);
   ae_assert(c->stype == -1 || c->stype == -3, "Spline2DCalcV: incorrect C (incorrect parameter C.SType)", _state);
   ae_assert(ae_isfinite(x, _state) && ae_isfinite(y, _state), "Spline2DCalcV: either X=NaN/Infinite or Y=NaN/Infinite", _state);
   spline2dcalcvbuf(c, x, y, f, _state);
}

// This subroutine calculates specific component of vector-valued bilinear or
// bicubic spline at the given point (X,Y).
//
// Inputs:
//     C   -   spline interpolant.
//     X, Y-   point
//     I   -   component index, in [0,D). An exception is generated for out
//             of range values.
//
// Result:
//     value of I-th component
// ALGLIB Project: Copyright 01.02.2018 by Sergey Bochkanov
// API: double spline2dcalcvi(const spline2dinterpolant &c, const double x, const double y, const ae_int_t i, const xparams _xparams = xdefault);
double spline2dcalcvi(spline2dinterpolant *c, double x, double y, ae_int_t i, ae_state *_state) {
   ae_int_t ix;
   ae_int_t iy;
   ae_int_t l;
   ae_int_t r;
   ae_int_t h;
   double t;
   double dt;
   double u;
   double du;
   double y1;
   double y2;
   double y3;
   double y4;
   ae_int_t s1;
   ae_int_t s2;
   ae_int_t s3;
   ae_int_t s4;
   ae_int_t sfx;
   ae_int_t sfy;
   ae_int_t sfxy;
   double t2;
   double t3;
   double u2;
   double u3;
   double ht00;
   double ht01;
   double ht10;
   double ht11;
   double hu00;
   double hu01;
   double hu10;
   double hu11;
   double result;
   ae_assert(c->stype == -1 || c->stype == -3, "Spline2DCalcVi: incorrect C (incorrect parameter C.SType)", _state);
   ae_assert(ae_isfinite(x, _state) && ae_isfinite(y, _state), "Spline2DCalcVi: X or Y contains NaN or Infinite value", _state);
   ae_assert(i >= 0 && i < c->d, "Spline2DCalcVi: incorrect I (I<0 or I >= D)", _state);
// Determine evaluation interval
   l = 0;
   r = c->n - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->x.xR[h] >= x) {
         r = h;
      } else {
         l = h;
      }
   }
   dt = 1.0 / (c->x.xR[l + 1] - c->x.xR[l]);
   t = (x - c->x.xR[l]) * dt;
   ix = l;
   l = 0;
   r = c->m - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->y.xR[h] >= y) {
         r = h;
      } else {
         l = h;
      }
   }
   du = 1.0 / (c->y.xR[l + 1] - c->y.xR[l]);
   u = (y - c->y.xR[l]) * du;
   iy = l;
// Bilinear interpolation
   if (c->stype == -1) {
      y1 = c->f.xR[c->d * (c->n * iy + ix) + i];
      y2 = c->f.xR[c->d * (c->n * iy + (ix + 1)) + i];
      y3 = c->f.xR[c->d * (c->n * (iy + 1) + (ix + 1)) + i];
      y4 = c->f.xR[c->d * (c->n * (iy + 1) + ix) + i];
      result = (1 - t) * (1 - u) * y1 + t * (1 - u) * y2 + t * u * y3 + (1 - t) * u * y4;
      return result;
   }
// Bicubic interpolation:
// * calculate Hermite basis for dimensions X and Y (variables T and U),
//   here HTij means basis function whose I-th derivative has value 1 at T=J.
//   Same for HUij.
// * after initial calculation, apply scaling by DT/DU to the basis
// * calculate using stored table of second derivatives
   ae_assert(c->stype == -3, "Spline2DCalc: integrity check failed", _state);
   sfx = c->n * c->m * c->d;
   sfy = 2 * c->n * c->m * c->d;
   sfxy = 3 * c->n * c->m * c->d;
   s1 = (c->n * iy + ix) * c->d;
   s2 = (c->n * iy + (ix + 1)) * c->d;
   s3 = (c->n * (iy + 1) + ix) * c->d;
   s4 = (c->n * (iy + 1) + (ix + 1)) * c->d;
   t2 = t * t;
   t3 = t * t2;
   u2 = u * u;
   u3 = u * u2;
   ht00 = 2 * t3 - 3 * t2 + 1;
   ht10 = t3 - 2 * t2 + t;
   ht01 = -2 * t3 + 3 * t2;
   ht11 = t3 - t2;
   hu00 = 2 * u3 - 3 * u2 + 1;
   hu10 = u3 - 2 * u2 + u;
   hu01 = -2 * u3 + 3 * u2;
   hu11 = u3 - u2;
   ht10 /= dt;
   ht11 /= dt;
   hu10 /= du;
   hu11 /= du;
// Advance source indexes to I-th position
   s1 += i;
   s2 += i;
   s3 += i;
   s4 += i;
// Calculate I-th component
   result = 0.0;
   result += c->f.xR[s1] * ht00 * hu00 + c->f.xR[s2] * ht01 * hu00 + c->f.xR[s3] * ht00 * hu01 + c->f.xR[s4] * ht01 * hu01;
   result += c->f.xR[sfx + s1] * ht10 * hu00 + c->f.xR[sfx + s2] * ht11 * hu00 + c->f.xR[sfx + s3] * ht10 * hu01 + c->f.xR[sfx + s4] * ht11 * hu01;
   result += c->f.xR[sfy + s1] * ht00 * hu10 + c->f.xR[sfy + s2] * ht01 * hu10 + c->f.xR[sfy + s3] * ht00 * hu11 + c->f.xR[sfy + s4] * ht01 * hu11;
   result += c->f.xR[sfxy + s1] * ht10 * hu10 + c->f.xR[sfxy + s2] * ht11 * hu10 + c->f.xR[sfxy + s3] * ht10 * hu11 + c->f.xR[sfxy + s4] * ht11 * hu11;
   return result;
}

// This subroutine calculates the value of the bilinear or bicubic spline  at
// the given point X and its derivatives.
//
// Inputs:
//     C   -   spline interpolant.
//     X, Y-   point
//
// Outputs:
//     F   -   S(x,y)
//     FX  -   dS(x,y)/dX
//     FY  -   dS(x,y)/dY
//     FXY -   d2S(x,y)/dXdY
// ALGLIB Project: Copyright 05.07.2007 by Sergey Bochkanov
// API: void spline2ddiff(const spline2dinterpolant &c, const double x, const double y, double &f, double &fx, double &fy, double &fxy, const xparams _xparams = xdefault);
void spline2ddiff(spline2dinterpolant *c, double x, double y, double *f, double *fx, double *fy, double *fxy, ae_state *_state) {
   double t;
   double dt;
   double u;
   double du;
   ae_int_t ix;
   ae_int_t iy;
   ae_int_t l;
   ae_int_t r;
   ae_int_t h;
   ae_int_t s1;
   ae_int_t s2;
   ae_int_t s3;
   ae_int_t s4;
   ae_int_t sfx;
   ae_int_t sfy;
   ae_int_t sfxy;
   double y1;
   double y2;
   double y3;
   double y4;
   double v0;
   double v1;
   double v2;
   double v3;
   double t2;
   double t3;
   double u2;
   double u3;
   double ht00;
   double ht01;
   double ht10;
   double ht11;
   double hu00;
   double hu01;
   double hu10;
   double hu11;
   double dht00;
   double dht01;
   double dht10;
   double dht11;
   double dhu00;
   double dhu01;
   double dhu10;
   double dhu11;
   *f = 0;
   *fx = 0;
   *fy = 0;
   *fxy = 0;
   ae_assert(c->stype == -1 || c->stype == -3, "Spline2DDiff: incorrect C (incorrect parameter C.SType)", _state);
   ae_assert(ae_isfinite(x, _state) && ae_isfinite(y, _state), "Spline2DDiff: X or Y contains NaN or Infinite value", _state);
// Prepare F, dF/dX, dF/dY, d2F/dXdY
   *f = 0.0;
   *fx = 0.0;
   *fy = 0.0;
   *fxy = 0.0;
   if (c->d != 1) {
      return;
   }
// Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
   l = 0;
   r = c->n - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->x.xR[h] >= x) {
         r = h;
      } else {
         l = h;
      }
   }
   t = (x - c->x.xR[l]) / (c->x.xR[l + 1] - c->x.xR[l]);
   dt = 1.0 / (c->x.xR[l + 1] - c->x.xR[l]);
   ix = l;
// Binary search in the [ y[0], ..., y[m-2] ] (y[m-1] is not included)
   l = 0;
   r = c->m - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->y.xR[h] >= y) {
         r = h;
      } else {
         l = h;
      }
   }
   u = (y - c->y.xR[l]) / (c->y.xR[l + 1] - c->y.xR[l]);
   du = 1.0 / (c->y.xR[l + 1] - c->y.xR[l]);
   iy = l;
// Bilinear interpolation
   if (c->stype == -1) {
      y1 = c->f.xR[c->n * iy + ix];
      y2 = c->f.xR[c->n * iy + (ix + 1)];
      y3 = c->f.xR[c->n * (iy + 1) + (ix + 1)];
      y4 = c->f.xR[c->n * (iy + 1) + ix];
      *f = (1 - t) * (1 - u) * y1 + t * (1 - u) * y2 + t * u * y3 + (1 - t) * u * y4;
      *fx = (-(1 - u) * y1 + (1 - u) * y2 + u * y3 - u * y4) * dt;
      *fy = (-(1 - t) * y1 - t * y2 + t * y3 + (1 - t) * y4) * du;
      *fxy = (y1 - y2 + y3 - y4) * du * dt;
      return;
   }
// Bicubic interpolation
   if (c->stype == -3) {
      sfx = c->n * c->m;
      sfy = 2 * c->n * c->m;
      sfxy = 3 * c->n * c->m;
      s1 = c->n * iy + ix;
      s2 = c->n * iy + (ix + 1);
      s3 = c->n * (iy + 1) + ix;
      s4 = c->n * (iy + 1) + (ix + 1);
      t2 = t * t;
      t3 = t * t2;
      u2 = u * u;
      u3 = u * u2;
      ht00 = 2 * t3 - 3 * t2 + 1;
      ht10 = t3 - 2 * t2 + t;
      ht01 = -2 * t3 + 3 * t2;
      ht11 = t3 - t2;
      hu00 = 2 * u3 - 3 * u2 + 1;
      hu10 = u3 - 2 * u2 + u;
      hu01 = -2 * u3 + 3 * u2;
      hu11 = u3 - u2;
      ht10 /= dt;
      ht11 /= dt;
      hu10 /= du;
      hu11 /= du;
      dht00 = 6 * t2 - 6 * t;
      dht10 = 3 * t2 - 4 * t + 1;
      dht01 = -6 * t2 + 6 * t;
      dht11 = 3 * t2 - 2 * t;
      dhu00 = 6 * u2 - 6 * u;
      dhu10 = 3 * u2 - 4 * u + 1;
      dhu01 = -6 * u2 + 6 * u;
      dhu11 = 3 * u2 - 2 * u;
      dht00 *= dt;
      dht01 *= dt;
      dhu00 *= du;
      dhu01 *= du;
      *f = 0.0;
      *fx = 0.0;
      *fy = 0.0;
      *fxy = 0.0;
      v0 = c->f.xR[s1];
      v1 = c->f.xR[s2];
      v2 = c->f.xR[s3];
      v3 = c->f.xR[s4];
      *f += v0 * ht00 * hu00 + v1 * ht01 * hu00 + v2 * ht00 * hu01 + v3 * ht01 * hu01;
      *fx += v0 * dht00 * hu00 + v1 * dht01 * hu00 + v2 * dht00 * hu01 + v3 * dht01 * hu01;
      *fy += v0 * ht00 * dhu00 + v1 * ht01 * dhu00 + v2 * ht00 * dhu01 + v3 * ht01 * dhu01;
      *fxy += v0 * dht00 * dhu00 + v1 * dht01 * dhu00 + v2 * dht00 * dhu01 + v3 * dht01 * dhu01;
      v0 = c->f.xR[sfx + s1];
      v1 = c->f.xR[sfx + s2];
      v2 = c->f.xR[sfx + s3];
      v3 = c->f.xR[sfx + s4];
      *f += v0 * ht10 * hu00 + v1 * ht11 * hu00 + v2 * ht10 * hu01 + v3 * ht11 * hu01;
      *fx += v0 * dht10 * hu00 + v1 * dht11 * hu00 + v2 * dht10 * hu01 + v3 * dht11 * hu01;
      *fy += v0 * ht10 * dhu00 + v1 * ht11 * dhu00 + v2 * ht10 * dhu01 + v3 * ht11 * dhu01;
      *fxy += v0 * dht10 * dhu00 + v1 * dht11 * dhu00 + v2 * dht10 * dhu01 + v3 * dht11 * dhu01;
      v0 = c->f.xR[sfy + s1];
      v1 = c->f.xR[sfy + s2];
      v2 = c->f.xR[sfy + s3];
      v3 = c->f.xR[sfy + s4];
      *f += v0 * ht00 * hu10 + v1 * ht01 * hu10 + v2 * ht00 * hu11 + v3 * ht01 * hu11;
      *fx += v0 * dht00 * hu10 + v1 * dht01 * hu10 + v2 * dht00 * hu11 + v3 * dht01 * hu11;
      *fy += v0 * ht00 * dhu10 + v1 * ht01 * dhu10 + v2 * ht00 * dhu11 + v3 * ht01 * dhu11;
      *fxy += v0 * dht00 * dhu10 + v1 * dht01 * dhu10 + v2 * dht00 * dhu11 + v3 * dht01 * dhu11;
      v0 = c->f.xR[sfxy + s1];
      v1 = c->f.xR[sfxy + s2];
      v2 = c->f.xR[sfxy + s3];
      v3 = c->f.xR[sfxy + s4];
      *f += v0 * ht10 * hu10 + v1 * ht11 * hu10 + v2 * ht10 * hu11 + v3 * ht11 * hu11;
      *fx += v0 * dht10 * hu10 + v1 * dht11 * hu10 + v2 * dht10 * hu11 + v3 * dht11 * hu11;
      *fy += v0 * ht10 * dhu10 + v1 * ht11 * dhu10 + v2 * ht10 * dhu11 + v3 * ht11 * dhu11;
      *fxy += v0 * dht10 * dhu10 + v1 * dht11 * dhu10 + v2 * dht10 * dhu11 + v3 * dht11 * dhu11;
      return;
   }
}

// This subroutine calculates value of  specific  component  of  bilinear  or
// bicubic vector-valued spline and its derivatives.
//
// Inputs:
//     C   -   spline interpolant.
//     X, Y-   point
//     I   -   component index, in [0,D)
//
// Outputs:
//     F   -   S(x,y)
//     FX  -   dS(x,y)/dX
//     FY  -   dS(x,y)/dY
//     FXY -   d2S(x,y)/dXdY
// ALGLIB Project: Copyright 05.07.2007 by Sergey Bochkanov
// API: void spline2ddiffvi(const spline2dinterpolant &c, const double x, const double y, const ae_int_t i, double &f, double &fx, double &fy, double &fxy, const xparams _xparams = xdefault);
void spline2ddiffvi(spline2dinterpolant *c, double x, double y, ae_int_t i, double *f, double *fx, double *fy, double *fxy, ae_state *_state) {
   ae_int_t d;
   double t;
   double dt;
   double u;
   double du;
   ae_int_t ix;
   ae_int_t iy;
   ae_int_t l;
   ae_int_t r;
   ae_int_t h;
   ae_int_t s1;
   ae_int_t s2;
   ae_int_t s3;
   ae_int_t s4;
   ae_int_t sfx;
   ae_int_t sfy;
   ae_int_t sfxy;
   double y1;
   double y2;
   double y3;
   double y4;
   double v0;
   double v1;
   double v2;
   double v3;
   double t2;
   double t3;
   double u2;
   double u3;
   double ht00;
   double ht01;
   double ht10;
   double ht11;
   double hu00;
   double hu01;
   double hu10;
   double hu11;
   double dht00;
   double dht01;
   double dht10;
   double dht11;
   double dhu00;
   double dhu01;
   double dhu10;
   double dhu11;
   *f = 0;
   *fx = 0;
   *fy = 0;
   *fxy = 0;
   ae_assert(c->stype == -1 || c->stype == -3, "Spline2DDiffVI: incorrect C (incorrect parameter C.SType)", _state);
   ae_assert(ae_isfinite(x, _state) && ae_isfinite(y, _state), "Spline2DDiffVI: X or Y contains NaN or Infinite value", _state);
   ae_assert(i >= 0 && i < c->d, "Spline2DDiffVI: I<0 or I >= D", _state);
// Prepare F, dF/dX, dF/dY, d2F/dXdY
   *f = 0.0;
   *fx = 0.0;
   *fy = 0.0;
   *fxy = 0.0;
   d = c->d;
// Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
   l = 0;
   r = c->n - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->x.xR[h] >= x) {
         r = h;
      } else {
         l = h;
      }
   }
   t = (x - c->x.xR[l]) / (c->x.xR[l + 1] - c->x.xR[l]);
   dt = 1.0 / (c->x.xR[l + 1] - c->x.xR[l]);
   ix = l;
// Binary search in the [ y[0], ..., y[m-2] ] (y[m-1] is not included)
   l = 0;
   r = c->m - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->y.xR[h] >= y) {
         r = h;
      } else {
         l = h;
      }
   }
   u = (y - c->y.xR[l]) / (c->y.xR[l + 1] - c->y.xR[l]);
   du = 1.0 / (c->y.xR[l + 1] - c->y.xR[l]);
   iy = l;
// Bilinear interpolation
   if (c->stype == -1) {
      y1 = c->f.xR[d * (c->n * iy + ix) + i];
      y2 = c->f.xR[d * (c->n * iy + (ix + 1)) + i];
      y3 = c->f.xR[d * (c->n * (iy + 1) + (ix + 1)) + i];
      y4 = c->f.xR[d * (c->n * (iy + 1) + ix) + i];
      *f = (1 - t) * (1 - u) * y1 + t * (1 - u) * y2 + t * u * y3 + (1 - t) * u * y4;
      *fx = (-(1 - u) * y1 + (1 - u) * y2 + u * y3 - u * y4) * dt;
      *fy = (-(1 - t) * y1 - t * y2 + t * y3 + (1 - t) * y4) * du;
      *fxy = (y1 - y2 + y3 - y4) * du * dt;
      return;
   }
// Bicubic interpolation
   if (c->stype == -3) {
      sfx = c->n * c->m * d;
      sfy = 2 * c->n * c->m * d;
      sfxy = 3 * c->n * c->m * d;
      s1 = d * (c->n * iy + ix) + i;
      s2 = d * (c->n * iy + (ix + 1)) + i;
      s3 = d * (c->n * (iy + 1) + ix) + i;
      s4 = d * (c->n * (iy + 1) + (ix + 1)) + i;
      t2 = t * t;
      t3 = t * t2;
      u2 = u * u;
      u3 = u * u2;
      ht00 = 2 * t3 - 3 * t2 + 1;
      ht10 = t3 - 2 * t2 + t;
      ht01 = -2 * t3 + 3 * t2;
      ht11 = t3 - t2;
      hu00 = 2 * u3 - 3 * u2 + 1;
      hu10 = u3 - 2 * u2 + u;
      hu01 = -2 * u3 + 3 * u2;
      hu11 = u3 - u2;
      ht10 /= dt;
      ht11 /= dt;
      hu10 /= du;
      hu11 /= du;
      dht00 = 6 * t2 - 6 * t;
      dht10 = 3 * t2 - 4 * t + 1;
      dht01 = -6 * t2 + 6 * t;
      dht11 = 3 * t2 - 2 * t;
      dhu00 = 6 * u2 - 6 * u;
      dhu10 = 3 * u2 - 4 * u + 1;
      dhu01 = -6 * u2 + 6 * u;
      dhu11 = 3 * u2 - 2 * u;
      dht00 *= dt;
      dht01 *= dt;
      dhu00 *= du;
      dhu01 *= du;
      *f = 0.0;
      *fx = 0.0;
      *fy = 0.0;
      *fxy = 0.0;
      v0 = c->f.xR[s1];
      v1 = c->f.xR[s2];
      v2 = c->f.xR[s3];
      v3 = c->f.xR[s4];
      *f += v0 * ht00 * hu00 + v1 * ht01 * hu00 + v2 * ht00 * hu01 + v3 * ht01 * hu01;
      *fx += v0 * dht00 * hu00 + v1 * dht01 * hu00 + v2 * dht00 * hu01 + v3 * dht01 * hu01;
      *fy += v0 * ht00 * dhu00 + v1 * ht01 * dhu00 + v2 * ht00 * dhu01 + v3 * ht01 * dhu01;
      *fxy += v0 * dht00 * dhu00 + v1 * dht01 * dhu00 + v2 * dht00 * dhu01 + v3 * dht01 * dhu01;
      v0 = c->f.xR[sfx + s1];
      v1 = c->f.xR[sfx + s2];
      v2 = c->f.xR[sfx + s3];
      v3 = c->f.xR[sfx + s4];
      *f += v0 * ht10 * hu00 + v1 * ht11 * hu00 + v2 * ht10 * hu01 + v3 * ht11 * hu01;
      *fx += v0 * dht10 * hu00 + v1 * dht11 * hu00 + v2 * dht10 * hu01 + v3 * dht11 * hu01;
      *fy += v0 * ht10 * dhu00 + v1 * ht11 * dhu00 + v2 * ht10 * dhu01 + v3 * ht11 * dhu01;
      *fxy += v0 * dht10 * dhu00 + v1 * dht11 * dhu00 + v2 * dht10 * dhu01 + v3 * dht11 * dhu01;
      v0 = c->f.xR[sfy + s1];
      v1 = c->f.xR[sfy + s2];
      v2 = c->f.xR[sfy + s3];
      v3 = c->f.xR[sfy + s4];
      *f += v0 * ht00 * hu10 + v1 * ht01 * hu10 + v2 * ht00 * hu11 + v3 * ht01 * hu11;
      *fx += v0 * dht00 * hu10 + v1 * dht01 * hu10 + v2 * dht00 * hu11 + v3 * dht01 * hu11;
      *fy += v0 * ht00 * dhu10 + v1 * ht01 * dhu10 + v2 * ht00 * dhu11 + v3 * ht01 * dhu11;
      *fxy += v0 * dht00 * dhu10 + v1 * dht01 * dhu10 + v2 * dht00 * dhu11 + v3 * dht01 * dhu11;
      v0 = c->f.xR[sfxy + s1];
      v1 = c->f.xR[sfxy + s2];
      v2 = c->f.xR[sfxy + s3];
      v3 = c->f.xR[sfxy + s4];
      *f += v0 * ht10 * hu10 + v1 * ht11 * hu10 + v2 * ht10 * hu11 + v3 * ht11 * hu11;
      *fx += v0 * dht10 * hu10 + v1 * dht11 * hu10 + v2 * dht10 * hu11 + v3 * dht11 * hu11;
      *fy += v0 * ht10 * dhu10 + v1 * ht11 * dhu10 + v2 * ht10 * dhu11 + v3 * ht11 * dhu11;
      *fxy += v0 * dht10 * dhu10 + v1 * dht11 * dhu10 + v2 * dht10 * dhu11 + v3 * dht11 * dhu11;
      return;
   }
}

// This subroutine makes the copy of the spline model.
//
// Inputs:
//     C   -   spline interpolant
//
// Outputs:
//     CC  -   spline copy
// ALGLIB Project: Copyright 29.06.2007 by Sergey Bochkanov
// API: void spline2dcopy(const spline2dinterpolant &c, spline2dinterpolant &cc, const xparams _xparams = xdefault);
void spline2dcopy(spline2dinterpolant *c, spline2dinterpolant *cc, ae_state *_state) {
   ae_int_t tblsize;
   SetObj(spline2dinterpolant, cc);
   ae_assert(c->stype == -1 || c->stype == -3, "Spline2DCopy: incorrect C (incorrect parameter C.SType)", _state);
   cc->n = c->n;
   cc->m = c->m;
   cc->d = c->d;
   cc->stype = c->stype;
   tblsize = -1;
   if (c->stype == -3) {
      tblsize = 4 * c->n * c->m * c->d;
   }
   if (c->stype == -1) {
      tblsize = c->n * c->m * c->d;
   }
   ae_assert(tblsize > 0, "Spline2DCopy: internal error", _state);
   ae_vector_set_length(&cc->x, cc->n, _state);
   ae_vector_set_length(&cc->y, cc->m, _state);
   ae_vector_set_length(&cc->f, tblsize, _state);
   ae_v_move(cc->x.xR, 1, c->x.xR, 1, cc->n);
   ae_v_move(cc->y.xR, 1, c->y.xR, 1, cc->m);
   ae_v_move(cc->f.xR, 1, c->f.xR, 1, tblsize);
}

// Bicubic spline resampling
//
// Inputs:
//     A           -   function values at the old grid,
//                     array[0..OldHeight-1, 0..OldWidth-1]
//     OldHeight   -   old grid height, OldHeight>1
//     OldWidth    -   old grid width, OldWidth>1
//     NewHeight   -   new grid height, NewHeight>1
//     NewWidth    -   new grid width, NewWidth>1
//
// Outputs:
//     B           -   function values at the new grid,
//                     array[0..NewHeight-1, 0..NewWidth-1]
// ALGLIB Routine: Copyright 15 May, 2007 by Sergey Bochkanov
// API: void spline2dresamplebicubic(const real_2d_array &a, const ae_int_t oldheight, const ae_int_t oldwidth, real_2d_array &b, const ae_int_t newheight, const ae_int_t newwidth, const xparams _xparams = xdefault);
void spline2dresamplebicubic(RMatrix *a, ae_int_t oldheight, ae_int_t oldwidth, RMatrix *b, ae_int_t newheight, ae_int_t newwidth, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t mw;
   ae_int_t mh;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(_state, &_frame_block);
   SetMatrix(b);
   NewMatrix(buf, 0, 0, DT_REAL, _state);
   NewVector(x, 0, DT_REAL, _state);
   NewVector(y, 0, DT_REAL, _state);
   NewObj(spline1dinterpolant, c, _state);
   ae_assert(oldwidth > 1 && oldheight > 1, "Spline2DResampleBicubic: width/height less than 1", _state);
   ae_assert(newwidth > 1 && newheight > 1, "Spline2DResampleBicubic: width/height less than 1", _state);
// Prepare
   mw = maxint(oldwidth, newwidth, _state);
   mh = maxint(oldheight, newheight, _state);
   ae_matrix_set_length(b, newheight, newwidth, _state);
   ae_matrix_set_length(&buf, oldheight, newwidth, _state);
   ae_vector_set_length(&x, maxint(mw, mh, _state), _state);
   ae_vector_set_length(&y, maxint(mw, mh, _state), _state);
// Horizontal interpolation
   for (i = 0; i < oldheight; i++) {
   // Fill X, Y
      for (j = 0; j < oldwidth; j++) {
         x.xR[j] = (double)j / (oldwidth - 1);
         y.xR[j] = a->xyR[i][j];
      }
   // Interpolate and place result into temporary matrix
      spline1dbuildcubic(&x, &y, oldwidth, 0, 0.0, 0, 0.0, &c, _state);
      for (j = 0; j < newwidth; j++) {
         buf.xyR[i][j] = spline1dcalc(&c, (double)j / (newwidth - 1), _state);
      }
   }
// Vertical interpolation
   for (j = 0; j < newwidth; j++) {
   // Fill X, Y
      for (i = 0; i < oldheight; i++) {
         x.xR[i] = (double)i / (oldheight - 1);
         y.xR[i] = buf.xyR[i][j];
      }
   // Interpolate and place result into B
      spline1dbuildcubic(&x, &y, oldheight, 0, 0.0, 0, 0.0, &c, _state);
      for (i = 0; i < newheight; i++) {
         b->xyR[i][j] = spline1dcalc(&c, (double)i / (newheight - 1), _state);
      }
   }
   ae_frame_leave(_state);
}

// Bilinear spline resampling
//
// Inputs:
//     A           -   function values at the old grid,
//                     array[0..OldHeight-1, 0..OldWidth-1]
//     OldHeight   -   old grid height, OldHeight>1
//     OldWidth    -   old grid width, OldWidth>1
//     NewHeight   -   new grid height, NewHeight>1
//     NewWidth    -   new grid width, NewWidth>1
//
// Outputs:
//     B           -   function values at the new grid,
//                     array[0..NewHeight-1, 0..NewWidth-1]
// ALGLIB Routine: Copyright 09.07.2007 by Sergey Bochkanov
// API: void spline2dresamplebilinear(const real_2d_array &a, const ae_int_t oldheight, const ae_int_t oldwidth, real_2d_array &b, const ae_int_t newheight, const ae_int_t newwidth, const xparams _xparams = xdefault);
void spline2dresamplebilinear(RMatrix *a, ae_int_t oldheight, ae_int_t oldwidth, RMatrix *b, ae_int_t newheight, ae_int_t newwidth, ae_state *_state) {
   ae_int_t l;
   ae_int_t c;
   double t;
   double u;
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_assert(oldwidth > 1 && oldheight > 1, "Spline2DResampleBilinear: width/height less than 1", _state);
   ae_assert(newwidth > 1 && newheight > 1, "Spline2DResampleBilinear: width/height less than 1", _state);
   ae_matrix_set_length(b, newheight, newwidth, _state);
   for (i = 0; i < newheight; i++) {
      for (j = 0; j < newwidth; j++) {
         l = i * (oldheight - 1) / (newheight - 1);
         if (l == oldheight - 1) {
            l = oldheight - 2;
         }
         u = (double)i / (newheight - 1) * (oldheight - 1) - l;
         c = j * (oldwidth - 1) / (newwidth - 1);
         if (c == oldwidth - 1) {
            c = oldwidth - 2;
         }
         t = (double)(j * (oldwidth - 1)) / (newwidth - 1) - c;
         b->xyR[i][j] = (1 - t) * (1 - u) * a->xyR[l][c] + t * (1 - u) * a->xyR[l][c + 1] + t * u * a->xyR[l + 1][c + 1] + (1 - t) * u * a->xyR[l + 1][c];
      }
   }
}

// This subroutine builds bilinear vector-valued spline.
//
// Inputs:
//     X   -   spline abscissas, array[0..N-1]
//     Y   -   spline ordinates, array[0..M-1]
//     F   -   function values, array[0..M*N*D-1]:
//             * first D elements store D values at (X[0],Y[0])
//             * next D elements store D values at (X[1],Y[0])
//             * general form - D function values at (X[i],Y[j]) are stored
//               at F[D*(J*N+I)...D*(J*N+I)+D-1].
//     M,N -   grid size, M >= 2, N >= 2
//     D   -   vector dimension, D >= 1
//
// Outputs:
//     C   -   spline interpolant
// ALGLIB Project: Copyright 16.04.2012 by Sergey Bochkanov
// API: void spline2dbuildbilinearv(const real_1d_array &x, const ae_int_t n, const real_1d_array &y, const ae_int_t m, const real_1d_array &f, const ae_int_t d, spline2dinterpolant &c, const xparams _xparams = xdefault);
void spline2dbuildbilinearv(RVector *x, ae_int_t n, RVector *y, ae_int_t m, RVector *f, ae_int_t d, spline2dinterpolant *c, ae_state *_state) {
   double t;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t i0;
   SetObj(spline2dinterpolant, c);
   ae_assert(n >= 2, "Spline2DBuildBilinearV: N is less then 2", _state);
   ae_assert(m >= 2, "Spline2DBuildBilinearV: M is less then 2", _state);
   ae_assert(d >= 1, "Spline2DBuildBilinearV: invalid argument D (D<1)", _state);
   ae_assert(x->cnt >= n && y->cnt >= m, "Spline2DBuildBilinearV: length of X or Y is too short (Length(X/Y)<N/M)", _state);
   ae_assert(isfinitevector(x, n, _state) && isfinitevector(y, m, _state), "Spline2DBuildBilinearV: X or Y contains NaN or Infinite value", _state);
   k = n * m * d;
   ae_assert(f->cnt >= k, "Spline2DBuildBilinearV: length of F is too short (Length(F)<N*M*D)", _state);
   ae_assert(isfinitevector(f, k, _state), "Spline2DBuildBilinearV: F contains NaN or Infinite value", _state);
// Fill interpolant
   c->n = n;
   c->m = m;
   c->d = d;
   c->stype = -1;
   ae_vector_set_length(&c->x, c->n, _state);
   ae_vector_set_length(&c->y, c->m, _state);
   ae_vector_set_length(&c->f, k, _state);
   for (i = 0; i < c->n; i++) {
      c->x.xR[i] = x->xR[i];
   }
   for (i = 0; i < c->m; i++) {
      c->y.xR[i] = y->xR[i];
   }
   for (i = 0; i < k; i++) {
      c->f.xR[i] = f->xR[i];
   }
// Sort points
   for (j = 0; j < c->n; j++) {
      k = j;
      for (i = j + 1; i < c->n; i++) {
         if (c->x.xR[i] < c->x.xR[k]) {
            k = i;
         }
      }
      if (k != j) {
         for (i = 0; i < c->m; i++) {
            for (i0 = 0; i0 < c->d; i0++) {
               t = c->f.xR[c->d * (i * c->n + j) + i0];
               c->f.xR[c->d * (i * c->n + j) + i0] = c->f.xR[c->d * (i * c->n + k) + i0];
               c->f.xR[c->d * (i * c->n + k) + i0] = t;
            }
         }
         t = c->x.xR[j];
         c->x.xR[j] = c->x.xR[k];
         c->x.xR[k] = t;
      }
   }
   for (i = 0; i < c->m; i++) {
      k = i;
      for (j = i + 1; j < c->m; j++) {
         if (c->y.xR[j] < c->y.xR[k]) {
            k = j;
         }
      }
      if (k != i) {
         for (j = 0; j < c->n; j++) {
            for (i0 = 0; i0 < c->d; i0++) {
               t = c->f.xR[c->d * (i * c->n + j) + i0];
               c->f.xR[c->d * (i * c->n + j) + i0] = c->f.xR[c->d * (k * c->n + j) + i0];
               c->f.xR[c->d * (k * c->n + j) + i0] = t;
            }
         }
         t = c->y.xR[i];
         c->y.xR[i] = c->y.xR[k];
         c->y.xR[k] = t;
      }
   }
}

// Internal subroutine.
// Calculation of the first derivatives and the cross-derivative.
static void spline2d_bicubiccalcderivatives(RMatrix *a, RVector *x, RVector *y, ae_int_t m, ae_int_t n, RMatrix *dx, RMatrix *dy, RMatrix *dxy, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double s;
   double ds;
   double d2s;
   ae_frame_make(_state, &_frame_block);
   SetMatrix(dx);
   SetMatrix(dy);
   SetMatrix(dxy);
   NewVector(xt, 0, DT_REAL, _state);
   NewVector(ft, 0, DT_REAL, _state);
   NewObj(spline1dinterpolant, c, _state);
   ae_matrix_set_length(dx, m, n, _state);
   ae_matrix_set_length(dy, m, n, _state);
   ae_matrix_set_length(dxy, m, n, _state);
// dF/dX
   ae_vector_set_length(&xt, n, _state);
   ae_vector_set_length(&ft, n, _state);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         xt.xR[j] = x->xR[j];
         ft.xR[j] = a->xyR[i][j];
      }
      spline1dbuildcubic(&xt, &ft, n, 0, 0.0, 0, 0.0, &c, _state);
      for (j = 0; j < n; j++) {
         spline1ddiff(&c, x->xR[j], &s, &ds, &d2s, _state);
         dx->xyR[i][j] = ds;
      }
   }
// dF/dY
   ae_vector_set_length(&xt, m, _state);
   ae_vector_set_length(&ft, m, _state);
   for (j = 0; j < n; j++) {
      for (i = 0; i < m; i++) {
         xt.xR[i] = y->xR[i];
         ft.xR[i] = a->xyR[i][j];
      }
      spline1dbuildcubic(&xt, &ft, m, 0, 0.0, 0, 0.0, &c, _state);
      for (i = 0; i < m; i++) {
         spline1ddiff(&c, y->xR[i], &s, &ds, &d2s, _state);
         dy->xyR[i][j] = ds;
      }
   }
// d2F/dXdY
   ae_vector_set_length(&xt, n, _state);
   ae_vector_set_length(&ft, n, _state);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         xt.xR[j] = x->xR[j];
         ft.xR[j] = dy->xyR[i][j];
      }
      spline1dbuildcubic(&xt, &ft, n, 0, 0.0, 0, 0.0, &c, _state);
      for (j = 0; j < n; j++) {
         spline1ddiff(&c, x->xR[j], &s, &ds, &d2s, _state);
         dxy->xyR[i][j] = ds;
      }
   }
   ae_frame_leave(_state);
}

// This subroutine builds bicubic vector-valued spline.
//
// Inputs:
//     X   -   spline abscissas, array[0..N-1]
//     Y   -   spline ordinates, array[0..M-1]
//     F   -   function values, array[0..M*N*D-1]:
//             * first D elements store D values at (X[0],Y[0])
//             * next D elements store D values at (X[1],Y[0])
//             * general form - D function values at (X[i],Y[j]) are stored
//               at F[D*(J*N+I)...D*(J*N+I)+D-1].
//     M,N -   grid size, M >= 2, N >= 2
//     D   -   vector dimension, D >= 1
//
// Outputs:
//     C   -   spline interpolant
// ALGLIB Project: Copyright 16.04.2012 by Sergey Bochkanov
// API: void spline2dbuildbicubicv(const real_1d_array &x, const ae_int_t n, const real_1d_array &y, const ae_int_t m, const real_1d_array &f, const ae_int_t d, spline2dinterpolant &c, const xparams _xparams = xdefault);
void spline2dbuildbicubicv(RVector *x, ae_int_t n, RVector *y, ae_int_t m, RVector *f, ae_int_t d, spline2dinterpolant *c, ae_state *_state) {
   ae_frame _frame_block;
   double t;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t di;
   ae_frame_make(_state, &_frame_block);
   DupVector(f, _state);
   SetObj(spline2dinterpolant, c);
   NewMatrix(tf, 0, 0, DT_REAL, _state);
   NewMatrix(dx, 0, 0, DT_REAL, _state);
   NewMatrix(dy, 0, 0, DT_REAL, _state);
   NewMatrix(dxy, 0, 0, DT_REAL, _state);
   ae_assert(n >= 2, "Spline2DBuildBicubicV: N is less than 2", _state);
   ae_assert(m >= 2, "Spline2DBuildBicubicV: M is less than 2", _state);
   ae_assert(d >= 1, "Spline2DBuildBicubicV: invalid argument D (D<1)", _state);
   ae_assert(x->cnt >= n && y->cnt >= m, "Spline2DBuildBicubicV: length of X or Y is too short (Length(X/Y)<N/M)", _state);
   ae_assert(isfinitevector(x, n, _state) && isfinitevector(y, m, _state), "Spline2DBuildBicubicV: X or Y contains NaN or Infinite value", _state);
   k = n * m * d;
   ae_assert(f->cnt >= k, "Spline2DBuildBicubicV: length of F is too short (Length(F)<N*M*D)", _state);
   ae_assert(isfinitevector(f, k, _state), "Spline2DBuildBicubicV: F contains NaN or Infinite value", _state);
// Fill interpolant:
//  F[0]...F[N*M*D-1]:
//      f(i,j) table. f(0,0), f(0, 1), f(0,2) and so on...
//  F[N*M*D]...F[2*N*M*D-1]:
//      df(i,j)/dx table.
//  F[2*N*M*D]...F[3*N*M*D-1]:
//      df(i,j)/dy table.
//  F[3*N*M*D]...F[4*N*M*D-1]:
//      d2f(i,j)/dxdy table.
   c->d = d;
   c->n = n;
   c->m = m;
   c->stype = -3;
   k *= 4;
   ae_vector_set_length(&c->x, c->n, _state);
   ae_vector_set_length(&c->y, c->m, _state);
   ae_vector_set_length(&c->f, k, _state);
   ae_matrix_set_length(&tf, c->m, c->n, _state);
   for (i = 0; i < c->n; i++) {
      c->x.xR[i] = x->xR[i];
   }
   for (i = 0; i < c->m; i++) {
      c->y.xR[i] = y->xR[i];
   }
// Sort points
   for (j = 0; j < c->n; j++) {
      k = j;
      for (i = j + 1; i < c->n; i++) {
         if (c->x.xR[i] < c->x.xR[k]) {
            k = i;
         }
      }
      if (k != j) {
         for (i = 0; i < c->m; i++) {
            for (di = 0; di < c->d; di++) {
               t = f->xR[c->d * (i * c->n + j) + di];
               f->xR[c->d * (i * c->n + j) + di] = f->xR[c->d * (i * c->n + k) + di];
               f->xR[c->d * (i * c->n + k) + di] = t;
            }
         }
         t = c->x.xR[j];
         c->x.xR[j] = c->x.xR[k];
         c->x.xR[k] = t;
      }
   }
   for (i = 0; i < c->m; i++) {
      k = i;
      for (j = i + 1; j < c->m; j++) {
         if (c->y.xR[j] < c->y.xR[k]) {
            k = j;
         }
      }
      if (k != i) {
         for (j = 0; j < c->n; j++) {
            for (di = 0; di < c->d; di++) {
               t = f->xR[c->d * (i * c->n + j) + di];
               f->xR[c->d * (i * c->n + j) + di] = f->xR[c->d * (k * c->n + j) + di];
               f->xR[c->d * (k * c->n + j) + di] = t;
            }
         }
         t = c->y.xR[i];
         c->y.xR[i] = c->y.xR[k];
         c->y.xR[k] = t;
      }
   }
   for (di = 0; di < c->d; di++) {
      for (i = 0; i < c->m; i++) {
         for (j = 0; j < c->n; j++) {
            tf.xyR[i][j] = f->xR[c->d * (i * c->n + j) + di];
         }
      }
      spline2d_bicubiccalcderivatives(&tf, &c->x, &c->y, c->m, c->n, &dx, &dy, &dxy, _state);
      for (i = 0; i < c->m; i++) {
         for (j = 0; j < c->n; j++) {
            k = c->d * (i * c->n + j) + di;
            c->f.xR[k] = tf.xyR[i][j];
            c->f.xR[c->n * c->m * c->d + k] = dx.xyR[i][j];
            c->f.xR[2 * c->n * c->m * c->d + k] = dy.xyR[i][j];
            c->f.xR[3 * c->n * c->m * c->d + k] = dxy.xyR[i][j];
         }
      }
   }
   ae_frame_leave(_state);
}

// This subroutine was deprecated in ALGLIB 3.6.0
//
// We recommend you to switch  to  Spline2DBuildBilinearV(),  which  is  more
// flexible and accepts its arguments in more convenient order.
// ALGLIB Project: Copyright 05.07.2007 by Sergey Bochkanov
// API: void spline2dbuildbilinear(const real_1d_array &x, const real_1d_array &y, const real_2d_array &f, const ae_int_t m, const ae_int_t n, spline2dinterpolant &c, const xparams _xparams = xdefault);
void spline2dbuildbilinear(RVector *x, RVector *y, RMatrix *f, ae_int_t m, ae_int_t n, spline2dinterpolant *c, ae_state *_state) {
   double t;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   SetObj(spline2dinterpolant, c);
   ae_assert(n >= 2, "Spline2DBuildBilinear: N<2", _state);
   ae_assert(m >= 2, "Spline2DBuildBilinear: M<2", _state);
   ae_assert(x->cnt >= n && y->cnt >= m, "Spline2DBuildBilinear: length of X or Y is too short (Length(X/Y)<N/M)", _state);
   ae_assert(isfinitevector(x, n, _state) && isfinitevector(y, m, _state), "Spline2DBuildBilinear: X or Y contains NaN or Infinite value", _state);
   ae_assert(f->rows >= m && f->cols >= n, "Spline2DBuildBilinear: size of F is too small (rows(F)<M or cols(F)<N)", _state);
   ae_assert(apservisfinitematrix(f, m, n, _state), "Spline2DBuildBilinear: F contains NaN or Infinite value", _state);
// Fill interpolant
   c->n = n;
   c->m = m;
   c->d = 1;
   c->stype = -1;
   ae_vector_set_length(&c->x, c->n, _state);
   ae_vector_set_length(&c->y, c->m, _state);
   ae_vector_set_length(&c->f, c->n * c->m, _state);
   for (i = 0; i < c->n; i++) {
      c->x.xR[i] = x->xR[i];
   }
   for (i = 0; i < c->m; i++) {
      c->y.xR[i] = y->xR[i];
   }
   for (i = 0; i < c->m; i++) {
      for (j = 0; j < c->n; j++) {
         c->f.xR[i * c->n + j] = f->xyR[i][j];
      }
   }
// Sort points
   for (j = 0; j < c->n; j++) {
      k = j;
      for (i = j + 1; i < c->n; i++) {
         if (c->x.xR[i] < c->x.xR[k]) {
            k = i;
         }
      }
      if (k != j) {
         for (i = 0; i < c->m; i++) {
            t = c->f.xR[i * c->n + j];
            c->f.xR[i * c->n + j] = c->f.xR[i * c->n + k];
            c->f.xR[i * c->n + k] = t;
         }
         t = c->x.xR[j];
         c->x.xR[j] = c->x.xR[k];
         c->x.xR[k] = t;
      }
   }
   for (i = 0; i < c->m; i++) {
      k = i;
      for (j = i + 1; j < c->m; j++) {
         if (c->y.xR[j] < c->y.xR[k]) {
            k = j;
         }
      }
      if (k != i) {
         for (j = 0; j < c->n; j++) {
            t = c->f.xR[i * c->n + j];
            c->f.xR[i * c->n + j] = c->f.xR[k * c->n + j];
            c->f.xR[k * c->n + j] = t;
         }
         t = c->y.xR[i];
         c->y.xR[i] = c->y.xR[k];
         c->y.xR[k] = t;
      }
   }
}

// This subroutine was deprecated in ALGLIB 3.6.0
//
// We recommend you to switch  to  Spline2DBuildBicubicV(),  which  is  more
// flexible and accepts its arguments in more convenient order.
// ALGLIB Project: Copyright 05.07.2007 by Sergey Bochkanov
// API: void spline2dbuildbicubic(const real_1d_array &x, const real_1d_array &y, const real_2d_array &f, const ae_int_t m, const ae_int_t n, spline2dinterpolant &c, const xparams _xparams = xdefault);
void spline2dbuildbicubic(RVector *x, RVector *y, RMatrix *f, ae_int_t m, ae_int_t n, spline2dinterpolant *c, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t sfx;
   ae_int_t sfy;
   ae_int_t sfxy;
   double t;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_frame_make(_state, &_frame_block);
   DupMatrix(f, _state);
   SetObj(spline2dinterpolant, c);
   NewMatrix(dx, 0, 0, DT_REAL, _state);
   NewMatrix(dy, 0, 0, DT_REAL, _state);
   NewMatrix(dxy, 0, 0, DT_REAL, _state);
   ae_assert(n >= 2, "Spline2DBuildBicubicSpline: N<2", _state);
   ae_assert(m >= 2, "Spline2DBuildBicubicSpline: M<2", _state);
   ae_assert(x->cnt >= n && y->cnt >= m, "Spline2DBuildBicubic: length of X or Y is too short (Length(X/Y)<N/M)", _state);
   ae_assert(isfinitevector(x, n, _state) && isfinitevector(y, m, _state), "Spline2DBuildBicubic: X or Y contains NaN or Infinite value", _state);
   ae_assert(f->rows >= m && f->cols >= n, "Spline2DBuildBicubic: size of F is too small (rows(F)<M or cols(F)<N)", _state);
   ae_assert(apservisfinitematrix(f, m, n, _state), "Spline2DBuildBicubic: F contains NaN or Infinite value", _state);
// Fill interpolant:
//  F[0]...F[N*M-1]:
//      f(i,j) table. f(0,0), f(0, 1), f(0,2) and so on...
//  F[N*M]...F[2*N*M-1]:
//      df(i,j)/dx table.
//  F[2*N*M]...F[3*N*M-1]:
//      df(i,j)/dy table.
//  F[3*N*M]...F[4*N*M-1]:
//      d2f(i,j)/dxdy table.
   c->d = 1;
   c->n = n;
   c->m = m;
   c->stype = -3;
   sfx = c->n * c->m;
   sfy = 2 * c->n * c->m;
   sfxy = 3 * c->n * c->m;
   ae_vector_set_length(&c->x, c->n, _state);
   ae_vector_set_length(&c->y, c->m, _state);
   ae_vector_set_length(&c->f, 4 * c->n * c->m, _state);
   for (i = 0; i < c->n; i++) {
      c->x.xR[i] = x->xR[i];
   }
   for (i = 0; i < c->m; i++) {
      c->y.xR[i] = y->xR[i];
   }
// Sort points
   for (j = 0; j < c->n; j++) {
      k = j;
      for (i = j + 1; i < c->n; i++) {
         if (c->x.xR[i] < c->x.xR[k]) {
            k = i;
         }
      }
      if (k != j) {
         for (i = 0; i < c->m; i++) {
            t = f->xyR[i][j];
            f->xyR[i][j] = f->xyR[i][k];
            f->xyR[i][k] = t;
         }
         t = c->x.xR[j];
         c->x.xR[j] = c->x.xR[k];
         c->x.xR[k] = t;
      }
   }
   for (i = 0; i < c->m; i++) {
      k = i;
      for (j = i + 1; j < c->m; j++) {
         if (c->y.xR[j] < c->y.xR[k]) {
            k = j;
         }
      }
      if (k != i) {
         for (j = 0; j < c->n; j++) {
            t = f->xyR[i][j];
            f->xyR[i][j] = f->xyR[k][j];
            f->xyR[k][j] = t;
         }
         t = c->y.xR[i];
         c->y.xR[i] = c->y.xR[k];
         c->y.xR[k] = t;
      }
   }
   spline2d_bicubiccalcderivatives(f, &c->x, &c->y, c->m, c->n, &dx, &dy, &dxy, _state);
   for (i = 0; i < c->m; i++) {
      for (j = 0; j < c->n; j++) {
         k = i * c->n + j;
         c->f.xR[k] = f->xyR[i][j];
         c->f.xR[sfx + k] = dx.xyR[i][j];
         c->f.xR[sfy + k] = dy.xyR[i][j];
         c->f.xR[sfxy + k] = dxy.xyR[i][j];
      }
   }
   ae_frame_leave(_state);
}

// This subroutine performs linear transformation of the spline argument.
//
// Inputs:
//     C       -   spline interpolant
//     AX, BX  -   transformation coefficients: x = A*t + B
//     AY, BY  -   transformation coefficients: y = A*u + B
// Result:
//     C   -   transformed spline
// ALGLIB Project: Copyright 30.06.2007 by Sergey Bochkanov
// API: void spline2dlintransxy(const spline2dinterpolant &c, const double ax, const double bx, const double ay, const double by, const xparams _xparams = xdefault);
void spline2dlintransxy(spline2dinterpolant *c, double ax, double bx, double ay, double by, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_frame_make(_state, &_frame_block);
   NewVector(x, 0, DT_REAL, _state);
   NewVector(y, 0, DT_REAL, _state);
   NewVector(f, 0, DT_REAL, _state);
   NewVector(v, 0, DT_REAL, _state);
   ae_assert(c->stype == -3 || c->stype == -1, "Spline2DLinTransXY: incorrect C (incorrect parameter C.SType)", _state);
   ae_assert(ae_isfinite(ax, _state), "Spline2DLinTransXY: AX is infinite or NaN", _state);
   ae_assert(ae_isfinite(bx, _state), "Spline2DLinTransXY: BX is infinite or NaN", _state);
   ae_assert(ae_isfinite(ay, _state), "Spline2DLinTransXY: AY is infinite or NaN", _state);
   ae_assert(ae_isfinite(by, _state), "Spline2DLinTransXY: BY is infinite or NaN", _state);
   ae_vector_set_length(&x, c->n, _state);
   ae_vector_set_length(&y, c->m, _state);
   ae_vector_set_length(&f, c->m * c->n * c->d, _state);
   for (j = 0; j < c->n; j++) {
      x.xR[j] = c->x.xR[j];
   }
   for (i = 0; i < c->m; i++) {
      y.xR[i] = c->y.xR[i];
   }
   for (i = 0; i < c->m; i++) {
      for (j = 0; j < c->n; j++) {
         for (k = 0; k < c->d; k++) {
            f.xR[c->d * (i * c->n + j) + k] = c->f.xR[c->d * (i * c->n + j) + k];
         }
      }
   }
// Handle different combinations of AX/AY
   if (ax == 0.0 && ay != 0.0) {
      for (i = 0; i < c->m; i++) {
         spline2dcalcvbuf(c, bx, y.xR[i], &v, _state);
         y.xR[i] = (y.xR[i] - by) / ay;
         for (j = 0; j < c->n; j++) {
            for (k = 0; k < c->d; k++) {
               f.xR[c->d * (i * c->n + j) + k] = v.xR[k];
            }
         }
      }
   }
   if (ax != 0.0 && ay == 0.0) {
      for (j = 0; j < c->n; j++) {
         spline2dcalcvbuf(c, x.xR[j], by, &v, _state);
         x.xR[j] = (x.xR[j] - bx) / ax;
         for (i = 0; i < c->m; i++) {
            for (k = 0; k < c->d; k++) {
               f.xR[c->d * (i * c->n + j) + k] = v.xR[k];
            }
         }
      }
   }
   if (ax != 0.0 && ay != 0.0) {
      for (j = 0; j < c->n; j++) {
         x.xR[j] = (x.xR[j] - bx) / ax;
      }
      for (i = 0; i < c->m; i++) {
         y.xR[i] = (y.xR[i] - by) / ay;
      }
   }
   if (ax == 0.0 && ay == 0.0) {
      spline2dcalcvbuf(c, bx, by, &v, _state);
      for (i = 0; i < c->m; i++) {
         for (j = 0; j < c->n; j++) {
            for (k = 0; k < c->d; k++) {
               f.xR[c->d * (i * c->n + j) + k] = v.xR[k];
            }
         }
      }
   }
// Rebuild spline
   if (c->stype == -3) {
      spline2dbuildbicubicv(&x, c->n, &y, c->m, &f, c->d, c, _state);
   }
   if (c->stype == -1) {
      spline2dbuildbilinearv(&x, c->n, &y, c->m, &f, c->d, c, _state);
   }
   ae_frame_leave(_state);
}

// This subroutine performs linear transformation of the spline.
//
// Inputs:
//     C   -   spline interpolant.
//     A, B-   transformation coefficients: S2(x,y) = A*S(x,y) + B
//
// Outputs:
//     C   -   transformed spline
// ALGLIB Project: Copyright 30.06.2007 by Sergey Bochkanov
// API: void spline2dlintransf(const spline2dinterpolant &c, const double a, const double b, const xparams _xparams = xdefault);
void spline2dlintransf(spline2dinterpolant *c, double a, double b, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(_state, &_frame_block);
   NewVector(x, 0, DT_REAL, _state);
   NewVector(y, 0, DT_REAL, _state);
   NewVector(f, 0, DT_REAL, _state);
   ae_assert(c->stype == -3 || c->stype == -1, "Spline2DLinTransF: incorrect C (incorrect parameter C.SType)", _state);
   ae_vector_set_length(&x, c->n, _state);
   ae_vector_set_length(&y, c->m, _state);
   ae_vector_set_length(&f, c->m * c->n * c->d, _state);
   for (j = 0; j < c->n; j++) {
      x.xR[j] = c->x.xR[j];
   }
   for (i = 0; i < c->m; i++) {
      y.xR[i] = c->y.xR[i];
   }
   for (i = 0; i < c->m * c->n * c->d; i++) {
      f.xR[i] = a * c->f.xR[i] + b;
   }
   if (c->stype == -3) {
      spline2dbuildbicubicv(&x, c->n, &y, c->m, &f, c->d, c, _state);
   }
   if (c->stype == -1) {
      spline2dbuildbilinearv(&x, c->n, &y, c->m, &f, c->d, c, _state);
   }
   ae_frame_leave(_state);
}

// This subroutine unpacks two-dimensional spline into the coefficients table
//
// Inputs:
//     C   -   spline interpolant.
//
// Result:
//     M, N-   grid size (x-axis and y-axis)
//     D   -   number of components
//     Tbl -   coefficients table, unpacked format,
//             D - components: [0..(N-1)*(M-1)*D-1, 0..19].
//             For T=0..D-1 (component index), I = 0...N-2 (x index),
//             J=0..M-2 (y index):
//                 K :=  T + I*D + J*D*(N-1)
//
//                 K-th row stores decomposition for T-th component of the
//                 vector-valued function
//
//                 Tbl[K,0] = X[i]
//                 Tbl[K,1] = X[i+1]
//                 Tbl[K,2] = Y[j]
//                 Tbl[K,3] = Y[j+1]
//                 Tbl[K,4] = C00
//                 Tbl[K,5] = C01
//                 Tbl[K,6] = C02
//                 Tbl[K,7] = C03
//                 Tbl[K,8] = C10
//                 Tbl[K,9] = C11
//                 ...
//                 Tbl[K,19] = C33
//             On each grid square spline is equals to:
//                 S(x) = SUM(c[i,j]*(t^i)*(u^j), i=0..3, j=0..3)
//                 t = x-x[j]
//                 u = y-y[i]
// ALGLIB Project: Copyright 16.04.2012 by Sergey Bochkanov
// API: void spline2dunpackv(const spline2dinterpolant &c, ae_int_t &m, ae_int_t &n, ae_int_t &d, real_2d_array &tbl, const xparams _xparams = xdefault);
void spline2dunpackv(spline2dinterpolant *c, ae_int_t *m, ae_int_t *n, ae_int_t *d, RMatrix *tbl, ae_state *_state) {
   ae_int_t k;
   ae_int_t p;
   ae_int_t ci;
   ae_int_t cj;
   ae_int_t s1;
   ae_int_t s2;
   ae_int_t s3;
   ae_int_t s4;
   ae_int_t sfx;
   ae_int_t sfy;
   ae_int_t sfxy;
   double y1;
   double y2;
   double y3;
   double y4;
   double dt;
   double du;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k0;
   *m = 0;
   *n = 0;
   *d = 0;
   SetMatrix(tbl);
   ae_assert(c->stype == -3 || c->stype == -1, "Spline2DUnpackV: incorrect C (incorrect parameter C.SType)", _state);
   *n = c->n;
   *m = c->m;
   *d = c->d;
   ae_matrix_set_length(tbl, (*n - 1) * (*m - 1) * (*d), 20, _state);
   sfx = *n * (*m) * (*d);
   sfy = 2 * (*n) * (*m) * (*d);
   sfxy = 3 * (*n) * (*m) * (*d);
   for (i = 0; i < *m - 1; i++) {
      for (j = 0; j < *n - 1; j++) {
         for (k = 0; k < *d; k++) {
            p = *d * (i * (*n - 1) + j) + k;
            tbl->xyR[p][0] = c->x.xR[j];
            tbl->xyR[p][1] = c->x.xR[j + 1];
            tbl->xyR[p][2] = c->y.xR[i];
            tbl->xyR[p][3] = c->y.xR[i + 1];
            dt = 1 / (tbl->xyR[p][1] - tbl->xyR[p][0]);
            du = 1 / (tbl->xyR[p][3] - tbl->xyR[p][2]);
         // Bilinear interpolation
            if (c->stype == -1) {
               for (k0 = 4; k0 <= 19; k0++) {
                  tbl->xyR[p][k0] = 0.0;
               }
               y1 = c->f.xR[*d * (*n * i + j) + k];
               y2 = c->f.xR[*d * (*n * i + (j + 1)) + k];
               y3 = c->f.xR[*d * (*n * (i + 1) + (j + 1)) + k];
               y4 = c->f.xR[*d * (*n * (i + 1) + j) + k];
               tbl->xyR[p][4] = y1;
               tbl->xyR[p][4 + 1 * 4 + 0] = y2 - y1;
               tbl->xyR[p][4 + 0 * 4 + 1] = y4 - y1;
               tbl->xyR[p][4 + 1 * 4 + 1] = y3 - y2 - y4 + y1;
            }
         // Bicubic interpolation
            if (c->stype == -3) {
               s1 = *d * (*n * i + j) + k;
               s2 = *d * (*n * i + (j + 1)) + k;
               s3 = *d * (*n * (i + 1) + (j + 1)) + k;
               s4 = *d * (*n * (i + 1) + j) + k;
               tbl->xyR[p][4 + 0 * 4 + 0] = c->f.xR[s1];
               tbl->xyR[p][4 + 0 * 4 + 1] = c->f.xR[sfy + s1] / du;
               tbl->xyR[p][4 + 0 * 4 + 2] = -3 * c->f.xR[s1] + 3 * c->f.xR[s4] - 2 * c->f.xR[sfy + s1] / du - c->f.xR[sfy + s4] / du;
               tbl->xyR[p][4 + 0 * 4 + 3] = 2 * c->f.xR[s1] - 2 * c->f.xR[s4] + c->f.xR[sfy + s1] / du + c->f.xR[sfy + s4] / du;
               tbl->xyR[p][4 + 1 * 4 + 0] = c->f.xR[sfx + s1] / dt;
               tbl->xyR[p][4 + 1 * 4 + 1] = c->f.xR[sfxy + s1] / (dt * du);
               tbl->xyR[p][4 + 1 * 4 + 2] = -3 * c->f.xR[sfx + s1] / dt + 3 * c->f.xR[sfx + s4] / dt - 2 * c->f.xR[sfxy + s1] / (dt * du) - c->f.xR[sfxy + s4] / (dt * du);
               tbl->xyR[p][4 + 1 * 4 + 3] = 2 * c->f.xR[sfx + s1] / dt - 2 * c->f.xR[sfx + s4] / dt + c->f.xR[sfxy + s1] / (dt * du) + c->f.xR[sfxy + s4] / (dt * du);
               tbl->xyR[p][4 + 2 * 4 + 0] = -3 * c->f.xR[s1] + 3 * c->f.xR[s2] - 2 * c->f.xR[sfx + s1] / dt - c->f.xR[sfx + s2] / dt;
               tbl->xyR[p][4 + 2 * 4 + 1] = -3 * c->f.xR[sfy + s1] / du + 3 * c->f.xR[sfy + s2] / du - 2 * c->f.xR[sfxy + s1] / (dt * du) - c->f.xR[sfxy + s2] / (dt * du);
               tbl->xyR[p][4 + 2 * 4 + 2] = 9 * c->f.xR[s1] - 9 * c->f.xR[s2] + 9 * c->f.xR[s3] - 9 * c->f.xR[s4] + 6 * c->f.xR[sfx + s1] / dt + 3 * c->f.xR[sfx + s2] / dt - 3 * c->f.xR[sfx + s3] / dt - 6 * c->f.xR[sfx + s4] / dt + 6 * c->f.xR[sfy + s1] / du - 6 * c->f.xR[sfy + s2] / du - 3 * c->f.xR[sfy + s3] / du + 3 * c->f.xR[sfy + s4] / du + 4 * c->f.xR[sfxy + s1] / (dt * du) + 2 * c->f.xR[sfxy + s2] / (dt * du) + c->f.xR[sfxy + s3] / (dt * du) + 2 * c->f.xR[sfxy + s4] / (dt * du);
               tbl->xyR[p][4 + 2 * 4 + 3] = -6 * c->f.xR[s1] + 6 * c->f.xR[s2] - 6 * c->f.xR[s3] + 6 * c->f.xR[s4] - 4 * c->f.xR[sfx + s1] / dt - 2 * c->f.xR[sfx + s2] / dt + 2 * c->f.xR[sfx + s3] / dt + 4 * c->f.xR[sfx + s4] / dt - 3 * c->f.xR[sfy + s1] / du + 3 * c->f.xR[sfy + s2] / du + 3 * c->f.xR[sfy + s3] / du - 3 * c->f.xR[sfy + s4] / du - 2 * c->f.xR[sfxy + s1] / (dt * du) - c->f.xR[sfxy + s2] / (dt * du) - c->f.xR[sfxy + s3] / (dt * du) - 2 * c->f.xR[sfxy + s4] / (dt * du);
               tbl->xyR[p][4 + 3 * 4 + 0] = 2 * c->f.xR[s1] - 2 * c->f.xR[s2] + c->f.xR[sfx + s1] / dt + c->f.xR[sfx + s2] / dt;
               tbl->xyR[p][4 + 3 * 4 + 1] = 2 * c->f.xR[sfy + s1] / du - 2 * c->f.xR[sfy + s2] / du + c->f.xR[sfxy + s1] / (dt * du) + c->f.xR[sfxy + s2] / (dt * du);
               tbl->xyR[p][4 + 3 * 4 + 2] = -6 * c->f.xR[s1] + 6 * c->f.xR[s2] - 6 * c->f.xR[s3] + 6 * c->f.xR[s4] - 3 * c->f.xR[sfx + s1] / dt - 3 * c->f.xR[sfx + s2] / dt + 3 * c->f.xR[sfx + s3] / dt + 3 * c->f.xR[sfx + s4] / dt - 4 * c->f.xR[sfy + s1] / du + 4 * c->f.xR[sfy + s2] / du + 2 * c->f.xR[sfy + s3] / du - 2 * c->f.xR[sfy + s4] / du - 2 * c->f.xR[sfxy + s1] / (dt * du) - 2 * c->f.xR[sfxy + s2] / (dt * du) - c->f.xR[sfxy + s3] / (dt * du) - c->f.xR[sfxy + s4] / (dt * du);
               tbl->xyR[p][4 + 3 * 4 + 3] = 4 * c->f.xR[s1] - 4 * c->f.xR[s2] + 4 * c->f.xR[s3] - 4 * c->f.xR[s4] + 2 * c->f.xR[sfx + s1] / dt + 2 * c->f.xR[sfx + s2] / dt - 2 * c->f.xR[sfx + s3] / dt - 2 * c->f.xR[sfx + s4] / dt + 2 * c->f.xR[sfy + s1] / du - 2 * c->f.xR[sfy + s2] / du - 2 * c->f.xR[sfy + s3] / du + 2 * c->f.xR[sfy + s4] / du + c->f.xR[sfxy + s1] / (dt * du) + c->f.xR[sfxy + s2] / (dt * du) + c->f.xR[sfxy + s3] / (dt * du) + c->f.xR[sfxy + s4] / (dt * du);
            }
         // Rescale Cij
            for (ci = 0; ci <= 3; ci++) {
               for (cj = 0; cj <= 3; cj++) {
                  tbl->xyR[p][4 + ci * 4 + cj] *= ae_pow(dt, (double)ci, _state) * ae_pow(du, (double)cj, _state);
               }
            }
         }
      }
   }
}

// This subroutine was deprecated in ALGLIB 3.6.0
//
// We recommend you to switch  to  Spline2DUnpackV(),  which is more flexible
// and accepts its arguments in more convenient order.
// ALGLIB Project: Copyright 29.06.2007 by Sergey Bochkanov
// API: void spline2dunpack(const spline2dinterpolant &c, ae_int_t &m, ae_int_t &n, real_2d_array &tbl, const xparams _xparams = xdefault);
void spline2dunpack(spline2dinterpolant *c, ae_int_t *m, ae_int_t *n, RMatrix *tbl, ae_state *_state) {
   ae_int_t k;
   ae_int_t p;
   ae_int_t ci;
   ae_int_t cj;
   ae_int_t s1;
   ae_int_t s2;
   ae_int_t s3;
   ae_int_t s4;
   ae_int_t sfx;
   ae_int_t sfy;
   ae_int_t sfxy;
   double y1;
   double y2;
   double y3;
   double y4;
   double dt;
   double du;
   ae_int_t i;
   ae_int_t j;
   *m = 0;
   *n = 0;
   SetMatrix(tbl);
   ae_assert(c->stype == -3 || c->stype == -1, "Spline2DUnpack: incorrect C (incorrect parameter C.SType)", _state);
   if (c->d != 1) {
      *n = 0;
      *m = 0;
      return;
   }
   *n = c->n;
   *m = c->m;
   ae_matrix_set_length(tbl, (*n - 1) * (*m - 1), 20, _state);
   sfx = *n * (*m);
   sfy = 2 * (*n) * (*m);
   sfxy = 3 * (*n) * (*m);
// Fill
   for (i = 0; i < *m - 1; i++) {
      for (j = 0; j < *n - 1; j++) {
         p = i * (*n - 1) + j;
         tbl->xyR[p][0] = c->x.xR[j];
         tbl->xyR[p][1] = c->x.xR[j + 1];
         tbl->xyR[p][2] = c->y.xR[i];
         tbl->xyR[p][3] = c->y.xR[i + 1];
         dt = 1 / (tbl->xyR[p][1] - tbl->xyR[p][0]);
         du = 1 / (tbl->xyR[p][3] - tbl->xyR[p][2]);
      // Bilinear interpolation
         if (c->stype == -1) {
            for (k = 4; k <= 19; k++) {
               tbl->xyR[p][k] = 0.0;
            }
            y1 = c->f.xR[*n * i + j];
            y2 = c->f.xR[*n * i + (j + 1)];
            y3 = c->f.xR[*n * (i + 1) + (j + 1)];
            y4 = c->f.xR[*n * (i + 1) + j];
            tbl->xyR[p][4] = y1;
            tbl->xyR[p][4 + 1 * 4 + 0] = y2 - y1;
            tbl->xyR[p][4 + 0 * 4 + 1] = y4 - y1;
            tbl->xyR[p][4 + 1 * 4 + 1] = y3 - y2 - y4 + y1;
         }
      // Bicubic interpolation
         if (c->stype == -3) {
            s1 = *n * i + j;
            s2 = *n * i + (j + 1);
            s3 = *n * (i + 1) + (j + 1);
            s4 = *n * (i + 1) + j;
            tbl->xyR[p][4 + 0 * 4 + 0] = c->f.xR[s1];
            tbl->xyR[p][4 + 0 * 4 + 1] = c->f.xR[sfy + s1] / du;
            tbl->xyR[p][4 + 0 * 4 + 2] = -3 * c->f.xR[s1] + 3 * c->f.xR[s4] - 2 * c->f.xR[sfy + s1] / du - c->f.xR[sfy + s4] / du;
            tbl->xyR[p][4 + 0 * 4 + 3] = 2 * c->f.xR[s1] - 2 * c->f.xR[s4] + c->f.xR[sfy + s1] / du + c->f.xR[sfy + s4] / du;
            tbl->xyR[p][4 + 1 * 4 + 0] = c->f.xR[sfx + s1] / dt;
            tbl->xyR[p][4 + 1 * 4 + 1] = c->f.xR[sfxy + s1] / (dt * du);
            tbl->xyR[p][4 + 1 * 4 + 2] = -3 * c->f.xR[sfx + s1] / dt + 3 * c->f.xR[sfx + s4] / dt - 2 * c->f.xR[sfxy + s1] / (dt * du) - c->f.xR[sfxy + s4] / (dt * du);
            tbl->xyR[p][4 + 1 * 4 + 3] = 2 * c->f.xR[sfx + s1] / dt - 2 * c->f.xR[sfx + s4] / dt + c->f.xR[sfxy + s1] / (dt * du) + c->f.xR[sfxy + s4] / (dt * du);
            tbl->xyR[p][4 + 2 * 4 + 0] = -3 * c->f.xR[s1] + 3 * c->f.xR[s2] - 2 * c->f.xR[sfx + s1] / dt - c->f.xR[sfx + s2] / dt;
            tbl->xyR[p][4 + 2 * 4 + 1] = -3 * c->f.xR[sfy + s1] / du + 3 * c->f.xR[sfy + s2] / du - 2 * c->f.xR[sfxy + s1] / (dt * du) - c->f.xR[sfxy + s2] / (dt * du);
            tbl->xyR[p][4 + 2 * 4 + 2] = 9 * c->f.xR[s1] - 9 * c->f.xR[s2] + 9 * c->f.xR[s3] - 9 * c->f.xR[s4] + 6 * c->f.xR[sfx + s1] / dt + 3 * c->f.xR[sfx + s2] / dt - 3 * c->f.xR[sfx + s3] / dt - 6 * c->f.xR[sfx + s4] / dt + 6 * c->f.xR[sfy + s1] / du - 6 * c->f.xR[sfy + s2] / du - 3 * c->f.xR[sfy + s3] / du + 3 * c->f.xR[sfy + s4] / du + 4 * c->f.xR[sfxy + s1] / (dt * du) + 2 * c->f.xR[sfxy + s2] / (dt * du) + c->f.xR[sfxy + s3] / (dt * du) + 2 * c->f.xR[sfxy + s4] / (dt * du);
            tbl->xyR[p][4 + 2 * 4 + 3] = -6 * c->f.xR[s1] + 6 * c->f.xR[s2] - 6 * c->f.xR[s3] + 6 * c->f.xR[s4] - 4 * c->f.xR[sfx + s1] / dt - 2 * c->f.xR[sfx + s2] / dt + 2 * c->f.xR[sfx + s3] / dt + 4 * c->f.xR[sfx + s4] / dt - 3 * c->f.xR[sfy + s1] / du + 3 * c->f.xR[sfy + s2] / du + 3 * c->f.xR[sfy + s3] / du - 3 * c->f.xR[sfy + s4] / du - 2 * c->f.xR[sfxy + s1] / (dt * du) - c->f.xR[sfxy + s2] / (dt * du) - c->f.xR[sfxy + s3] / (dt * du) - 2 * c->f.xR[sfxy + s4] / (dt * du);
            tbl->xyR[p][4 + 3 * 4 + 0] = 2 * c->f.xR[s1] - 2 * c->f.xR[s2] + c->f.xR[sfx + s1] / dt + c->f.xR[sfx + s2] / dt;
            tbl->xyR[p][4 + 3 * 4 + 1] = 2 * c->f.xR[sfy + s1] / du - 2 * c->f.xR[sfy + s2] / du + c->f.xR[sfxy + s1] / (dt * du) + c->f.xR[sfxy + s2] / (dt * du);
            tbl->xyR[p][4 + 3 * 4 + 2] = -6 * c->f.xR[s1] + 6 * c->f.xR[s2] - 6 * c->f.xR[s3] + 6 * c->f.xR[s4] - 3 * c->f.xR[sfx + s1] / dt - 3 * c->f.xR[sfx + s2] / dt + 3 * c->f.xR[sfx + s3] / dt + 3 * c->f.xR[sfx + s4] / dt - 4 * c->f.xR[sfy + s1] / du + 4 * c->f.xR[sfy + s2] / du + 2 * c->f.xR[sfy + s3] / du - 2 * c->f.xR[sfy + s4] / du - 2 * c->f.xR[sfxy + s1] / (dt * du) - 2 * c->f.xR[sfxy + s2] / (dt * du) - c->f.xR[sfxy + s3] / (dt * du) - c->f.xR[sfxy + s4] / (dt * du);
            tbl->xyR[p][4 + 3 * 4 + 3] = 4 * c->f.xR[s1] - 4 * c->f.xR[s2] + 4 * c->f.xR[s3] - 4 * c->f.xR[s4] + 2 * c->f.xR[sfx + s1] / dt + 2 * c->f.xR[sfx + s2] / dt - 2 * c->f.xR[sfx + s3] / dt - 2 * c->f.xR[sfx + s4] / dt + 2 * c->f.xR[sfy + s1] / du - 2 * c->f.xR[sfy + s2] / du - 2 * c->f.xR[sfy + s3] / du + 2 * c->f.xR[sfy + s4] / du + c->f.xR[sfxy + s1] / (dt * du) + c->f.xR[sfxy + s2] / (dt * du) + c->f.xR[sfxy + s3] / (dt * du) + c->f.xR[sfxy + s4] / (dt * du);
         }
      // Rescale Cij
         for (ci = 0; ci <= 3; ci++) {
            for (cj = 0; cj <= 3; cj++) {
               tbl->xyR[p][4 + ci * 4 + cj] *= ae_pow(dt, (double)ci, _state) * ae_pow(du, (double)cj, _state);
            }
         }
      }
   }
}

// This subroutine creates least squares solver used to  fit  2D  splines  to
// irregularly sampled (scattered) data.
//
// Solver object is used to perform spline fits as follows:
// * solver object is created with spline2dbuildercreate() function
// * dataset is added with spline2dbuildersetpoints() function
// * fit area is chosen:
//   * spline2dbuildersetarea()     - for user-defined area
//   * spline2dbuildersetareaauto() - for automatically chosen area
// * number of grid nodes is chosen with spline2dbuildersetgrid()
// * prior term is chosen with one of the following functions:
//   * spline2dbuildersetlinterm()   to set linear prior
//   * spline2dbuildersetconstterm() to set constant prior
//   * spline2dbuildersetzeroterm()  to set zero prior
//   * spline2dbuildersetuserterm()  to set user-defined constant prior
// * solver algorithm is chosen with either:
//   * spline2dbuildersetalgoblocklls() - BlockLLS algorithm, medium-scale problems
//   * spline2dbuildersetalgofastddm()  - FastDDM algorithm, large-scale problems
// * finally, fitting itself is performed with spline2dfit() function.
//
// Most of the steps above can be omitted,  solver  is  configured with  good
// defaults. The minimum is to call:
// * spline2dbuildercreate() to create solver object
// * spline2dbuildersetpoints() to specify dataset
// * spline2dbuildersetgrid() to tell how many nodes you need
// * spline2dfit() to perform fit
//
// Inputs:
//     D   -   positive number, number of Y-components: D=1 for simple scalar
//             fit, D>1 for vector-valued spline fitting.
//
// Outputs:
//     S   -   solver object
// ALGLIB Project: Copyright 29.01.2018 by Sergey Bochkanov
// API: void spline2dbuildercreate(const ae_int_t d, spline2dbuilder &state, const xparams _xparams = xdefault);
void spline2dbuildercreate(ae_int_t d, spline2dbuilder *state, ae_state *_state) {
   SetObj(spline2dbuilder, state);
   ae_assert(d >= 1, "Spline2DBuilderCreate: D <= 0", _state);
// NOTES:
//
// 1. Prior term is set to linear one (good default option)
// 2. Solver is set to BlockLLS - good enough for small-scale problems.
// 3. Refinement rounds: 5; enough to get good convergence.
   state->priorterm = 1;
   state->priortermval = 0.0;
   state->areatype = 0;
   state->gridtype = 0;
   state->smoothing = 0.0;
   state->nlayers = 0;
   state->solvertype = 1;
   state->npoints = 0;
   state->d = d;
   state->sx = 1.0;
   state->sy = 1.0;
   state->lsqrcnt = 5;
// Algorithm settings
   state->adddegreeoffreedom = true;
   state->maxcoresize = 16;
   state->interfacesize = 5;
}

// This function sets constant prior term (model is a sum of  bicubic  spline
// and global prior, which can be linear, constant, user-defined  constant or
// zero).
//
// Constant prior term is determined by least squares fitting.
//
// Inputs:
//     S       -   spline builder
//     V       -   value for user-defined prior
// ALGLIB: Copyright 01.02.2018 by Sergey Bochkanov
// API: void spline2dbuildersetuserterm(const spline2dbuilder &state, const double v, const xparams _xparams = xdefault);
void spline2dbuildersetuserterm(spline2dbuilder *state, double v, ae_state *_state) {
   ae_assert(ae_isfinite(v, _state), "Spline2DBuilderSetUserTerm: infinite/NAN value passed", _state);
   state->priorterm = 0;
   state->priortermval = v;
}

// This function sets linear prior term (model is a sum of bicubic spline and
// global  prior,  which  can  be  linear, constant, user-defined constant or
// zero).
//
// Linear prior term is determined by least squares fitting.
//
// Inputs:
//     S       -   spline builder
// ALGLIB: Copyright 01.02.2018 by Sergey Bochkanov
// API: void spline2dbuildersetlinterm(const spline2dbuilder &state, const xparams _xparams = xdefault);
void spline2dbuildersetlinterm(spline2dbuilder *state, ae_state *_state) {
   state->priorterm = 1;
}

// This function sets constant prior term (model is a sum of  bicubic  spline
// and global prior, which can be linear, constant, user-defined  constant or
// zero).
//
// Constant prior term is determined by least squares fitting.
//
// Inputs:
//     S       -   spline builder
// ALGLIB: Copyright 01.02.2018 by Sergey Bochkanov
// API: void spline2dbuildersetconstterm(const spline2dbuilder &state, const xparams _xparams = xdefault);
void spline2dbuildersetconstterm(spline2dbuilder *state, ae_state *_state) {
   state->priorterm = 2;
}

// This function sets zero prior term (model is a sum of bicubic  spline  and
// global  prior,  which  can  be  linear, constant, user-defined constant or
// zero).
//
// Inputs:
//     S       -   spline builder
// ALGLIB: Copyright 01.02.2018 by Sergey Bochkanov
// API: void spline2dbuildersetzeroterm(const spline2dbuilder &state, const xparams _xparams = xdefault);
void spline2dbuildersetzeroterm(spline2dbuilder *state, ae_state *_state) {
   state->priorterm = 3;
}

// This function adds dataset to the builder object.
//
// This function overrides results of the previous calls, i.e. multiple calls
// of this function will result in only the last set being added.
//
// Inputs:
//     S       -   spline 2D builder object
//     XY      -   points, array[N,2+D]. One  row  corresponds to  one  point
//                 in the dataset. First 2  elements  are  coordinates,  next
//                 D  elements are function values. Array may  be larger than
//                 specified, in  this  case  only leading [N,NX+NY] elements
//                 will be used.
//     N       -   number of points in the dataset
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
// API: void spline2dbuildersetpoints(const spline2dbuilder &state, const real_2d_array &xy, const ae_int_t n, const xparams _xparams = xdefault);
void spline2dbuildersetpoints(spline2dbuilder *state, RMatrix *xy, ae_int_t n, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t ew;
   ae_assert(n > 0, "Spline2DBuilderSetPoints: N<0", _state);
   ae_assert(xy->rows >= n, "Spline2DBuilderSetPoints: Rows(XY)<N", _state);
   ae_assert(xy->cols >= 2 + state->d, "Spline2DBuilderSetPoints: Cols(XY)<NX+NY", _state);
   ae_assert(apservisfinitematrix(xy, n, 2 + state->d, _state), "Spline2DBuilderSetPoints: XY contains infinite or NaN values!", _state);
   state->npoints = n;
   ew = 2 + state->d;
   rvectorsetlengthatleast(&state->xy, n * ew, _state);
   for (i = 0; i < n; i++) {
      for (j = 0; j < ew; j++) {
         state->xy.xR[i * ew + j] = xy->xyR[i][j];
      }
   }
}

// This function sets area where 2D spline interpolant is built. "Auto" means
// that area extent is determined automatically from dataset extent.
//
// Inputs:
//     S       -   spline 2D builder object
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
// API: void spline2dbuildersetareaauto(const spline2dbuilder &state, const xparams _xparams = xdefault);
void spline2dbuildersetareaauto(spline2dbuilder *state, ae_state *_state) {
   state->areatype = 0;
}

// This  function  sets  area  where  2D  spline  interpolant  is   built  to
// user-defined one: [XA,XB]*[YA,YB]
//
// Inputs:
//     S       -   spline 2D builder object
//     XA,XB   -   spatial extent in the first (X) dimension, XA<XB
//     YA,YB   -   spatial extent in the second (Y) dimension, YA<YB
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
// API: void spline2dbuildersetarea(const spline2dbuilder &state, const double xa, const double xb, const double ya, const double yb, const xparams _xparams = xdefault);
void spline2dbuildersetarea(spline2dbuilder *state, double xa, double xb, double ya, double yb, ae_state *_state) {
   ae_assert(ae_isfinite(xa, _state), "Spline2DBuilderSetArea: XA is not finite", _state);
   ae_assert(ae_isfinite(xb, _state), "Spline2DBuilderSetArea: XB is not finite", _state);
   ae_assert(ae_isfinite(ya, _state), "Spline2DBuilderSetArea: YA is not finite", _state);
   ae_assert(ae_isfinite(yb, _state), "Spline2DBuilderSetArea: YB is not finite", _state);
   ae_assert(xa < xb, "Spline2DBuilderSetArea: XA >= XB", _state);
   ae_assert(ya < yb, "Spline2DBuilderSetArea: YA >= YB", _state);
   state->areatype = 1;
   state->xa = xa;
   state->xb = xb;
   state->ya = ya;
   state->yb = yb;
}

// This  function  sets  nodes  count  for  2D spline interpolant. Fitting is
// performed on area defined with one of the "setarea"  functions;  this  one
// sets number of nodes placed upon the fitting area.
//
// Inputs:
//     S       -   spline 2D builder object
//     KX      -   nodes count for the first (X) dimension; fitting  interval
//                 [XA,XB] is separated into KX-1 subintervals, with KX nodes
//                 created at the boundaries.
//     KY      -   nodes count for the first (Y) dimension; fitting  interval
//                 [YA,YB] is separated into KY-1 subintervals, with KY nodes
//                 created at the boundaries.
//
// NOTE: at  least  4  nodes  is  created in each dimension, so KX and KY are
//       silently increased if needed.
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
// API: void spline2dbuildersetgrid(const spline2dbuilder &state, const ae_int_t kx, const ae_int_t ky, const xparams _xparams = xdefault);
void spline2dbuildersetgrid(spline2dbuilder *state, ae_int_t kx, ae_int_t ky, ae_state *_state) {
   ae_assert(kx > 0, "Spline2DBuilderSetGridSizePrecisely: KX <= 0", _state);
   ae_assert(ky > 0, "Spline2DBuilderSetGridSizePrecisely: KY <= 0", _state);
   state->gridtype = 1;
   state->kx = maxint(kx, 4, _state);
   state->ky = maxint(ky, 4, _state);
}

// This  function  allows  you to choose least squares solver used to perform
// fitting. This function sets solver algorithm to "FastDDM", which  performs
// fast parallel fitting by splitting problem into smaller chunks and merging
// results together.
//
// This solver is optimized for large-scale problems, starting  from  256x256
// grids, and up to 10000x10000 grids. Of course, it will  work  for  smaller
// grids too.
//
// More detailed description of the algorithm is given below:
// * algorithm generates hierarchy  of  nested  grids,  ranging  from  ~16x16
//   (topmost "layer" of the model) to ~KX*KY one (final layer). Upper layers
//   model global behavior of the function, lower layers are  used  to  model
//   fine details. Moving from layer to layer doubles grid density.
// * fitting  is  started  from  topmost  layer, subsequent layers are fitted
//   using residuals from previous ones.
// * user may choose to skip generation of upper layers and generate  only  a
//   few bottom ones, which  will  result  in  much  better  performance  and
//   parallelization efficiency, at the cost of algorithm inability to "patch"
//   large holes in the dataset.
// * every layer is regularized using progressively increasing regularization
//   coefficient; thus, increasing  LambdaV  penalizes  fine  details  first,
//   leaving lower frequencies almost intact for a while.
// * after fitting is done, all layers are merged together into  one  bicubic
//   spline
//
// IMPORTANT: regularization coefficient used by  this  solver  is  different
//            from the one used by  BlockLLS.  Latter  utilizes  nonlinearity
//            penalty,  which  is  global  in  nature  (large  regularization
//            results in global linear trend being  extracted);  this  solver
//            uses another, localized form of penalty, which is suitable  for
//            parallel processing.
//
// Notes on memory and performance:
// * memory requirements: most memory is consumed  during  modeling   of  the
//   higher layers; ~[512*NPoints] bytes is required for a  model  with  full
//   hierarchy of grids being generated. However, if you skip a  few  topmost
//   layers, you will get nearly constant (wrt. points count and  grid  size)
//   memory consumption.
// * serial running time: O(K*K)+O(NPoints) for a KxK grid
// * parallelism potential: good. You may get  nearly  linear  speed-up  when
//   performing fitting with just a few layers. Adding more layers results in
//   model becoming more global, which somewhat  reduces  efficiency  of  the
//   parallel code.
//
// Inputs:
//     S       -   spline 2D builder object
//     NLayers -   number of layers in the model:
//                 * NLayers >= 1 means that up  to  chosen  number  of  bottom
//                   layers is fitted
//                 * NLayers=0 means that maximum number of layers is  chosen
//                   (according to current grid size)
//                 * NLayers <= -1 means that up to |NLayers| topmost layers is
//                   skipped
//                 Recommendations:
//                 * good "default" value is 2 layers
//                 * you may need  more  layers,  if  your  dataset  is  very
//                   irregular and you want to "patch"  large  holes.  For  a
//                   grid step H (equal to AreaWidth/GridSize) you may expect
//                   that last layer reproduces variations at distance H (and
//                   can patch holes that wide); that higher  layers  operate
//                   at distances 2*H, 4*H, 8*H and so on.
//                 * good value for "bullletproof" mode is  NLayers=0,  which
//                   results in complete hierarchy of layers being generated.
//     LambdaV -   regularization coefficient, chosen in such a way  that  it
//                 penalizes bottom layers (fine details) first.
//                 LambdaV >= 0, zero value means that no penalty is applied.
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
// API: void spline2dbuildersetalgofastddm(const spline2dbuilder &state, const ae_int_t nlayers, const double lambdav, const xparams _xparams = xdefault);
void spline2dbuildersetalgofastddm(spline2dbuilder *state, ae_int_t nlayers, double lambdav, ae_state *_state) {
   ae_assert(ae_isfinite(lambdav, _state), "Spline2DBuilderSetAlgoFastDDM: LambdaV is not finite value", _state);
   ae_assert(lambdav >= 0.0, "Spline2DBuilderSetAlgoFastDDM: LambdaV<0", _state);
   state->solvertype = 3;
   state->nlayers = nlayers;
   state->smoothing = lambdav;
}

// This  function  allows  you to choose least squares solver used to perform
// fitting. This function sets solver algorithm to "BlockLLS", which performs
// least squares fitting  with  fast  sparse  direct  solver,  with  optional
// nonsmoothness penalty being applied.
//
// Nonlinearity penalty has the following form:
//
//                           [                                            ]
//     P() ~ Lambda* integral[ (d2S/dx2)^2 + 2*(d2S/dxdy)^2 + (d2S/dy2)^2 ]dxdy
//                           [                                            ]
//
// here integral is calculated over entire grid, and "~" means "proportional"
// because integral is normalized after calcilation. Extremely  large  values
// of Lambda result in linear fit being performed.
//
// NOTE: this algorithm is the most robust and controllable one,  but  it  is
//       limited by 512x512 grids and (say) up to 1.000.000 points.  However,
//       ALGLIB has one more  spline  solver:  FastDDM  algorithm,  which  is
//       intended for really large-scale problems (in 10M-100M range). FastDDM
//       algorithm also has better parallelism properties.
//
// More information on BlockLLS solver:
// * memory requirements: ~[32*K^3+256*NPoints]  bytes  for  KxK  grid   with
//   NPoints-sized dataset
// * serial running time: O(K^4+NPoints)
// * parallelism potential: limited. You may get some sublinear gain when
//   working with large grids (K's in 256..512 range)
//
// Inputs:
//     S       -   spline 2D builder object
//     LambdaNS-   non-negative value:
//                 * positive value means that some smoothing is applied
//                 * zero value means  that  no  smoothing  is  applied,  and
//                   corresponding entries of design matrix  are  numerically
//                   zero and dropped from consideration.
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
// API: void spline2dbuildersetalgoblocklls(const spline2dbuilder &state, const double lambdans, const xparams _xparams = xdefault);
void spline2dbuildersetalgoblocklls(spline2dbuilder *state, double lambdans, ae_state *_state) {
   ae_assert(ae_isfinite(lambdans, _state), "Spline2DBuilderSetAlgoBlockLLS: LambdaNS is not finite value", _state);
   ae_assert(lambdans >= 0.0, "Spline2DBuilderSetAlgoBlockLLS: LambdaNS<0", _state);
   state->solvertype = 1;
   state->smoothing = lambdans;
}

// This  function  allows  you to choose least squares solver used to perform
// fitting. This function sets solver algorithm to "NaiveLLS".
//
// IMPORTANT: NaiveLLS is NOT intended to be used in  real  life  code!  This
//            algorithm solves problem by generated dense (K^2)x(K^2+NPoints)
//            matrix and solves  linear  least  squares  problem  with  dense
//            solver.
//
//            It is here just  to  test  BlockLLS  against  reference  solver
//            (and maybe for someone trying to compare well optimized  solver
//            against straightforward approach to the LLS problem).
//
// More information on naive LLS solver:
// * memory requirements: ~[8*K^4+256*NPoints] bytes for KxK grid.
// * serial running time: O(K^6+NPoints) for KxK grid
// * when compared with BlockLLS,  NaiveLLS  has ~K  larger memory demand and
//   ~K^2  larger running time.
//
// Inputs:
//     S       -   spline 2D builder object
//     LambdaNS-   nonsmoothness penalty
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
// API: void spline2dbuildersetalgonaivells(const spline2dbuilder &state, const double lambdans, const xparams _xparams = xdefault);
void spline2dbuildersetalgonaivells(spline2dbuilder *state, double lambdans, ae_state *_state) {
   ae_assert(ae_isfinite(lambdans, _state), "Spline2DBuilderSetAlgoBlockLLS: LambdaNS is not finite value", _state);
   ae_assert(lambdans >= 0.0, "Spline2DBuilderSetAlgoBlockLLS: LambdaNS<0", _state);
   state->solvertype = 2;
   state->smoothing = lambdans;
}

// This  is  convenience  function  for band block storage format; it returns
// offset of KX*KX-sized block (I,J) in a compressed 2D array.
//
// For specific offset=OFFSET,
// block (I,J) will be stored in entries BlockMatrix[OFFSET:OFFSET+KX-1,0:KX-1]
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static ae_int_t spline2d_getcelloffset(ae_int_t kx, ae_int_t ky, ae_int_t blockbandwidth, ae_int_t i, ae_int_t j, ae_state *_state) {
   ae_int_t result;
   ae_assert(i >= 0 && i < ky, "Spline2DFit: GetCellOffset() integrity error", _state);
   ae_assert(j >= 0 && j < ky, "Spline2DFit: GetCellOffset() integrity error", _state);
   ae_assert(j >= i && j <= i + blockbandwidth, "Spline2DFit: GetCellOffset() integrity error", _state);
   result = j * (blockbandwidth + 1) * kx;
   result += (blockbandwidth - (j - i)) * kx;
   return result;
}

// This  is  convenience  function  for band block storage format; it  copies
// cell (I,J) from compressed format to uncompressed general matrix, at desired
// position.
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_copycellto(ae_int_t kx, ae_int_t ky, ae_int_t blockbandwidth, RMatrix *blockata, ae_int_t i, ae_int_t j, RMatrix *dst, ae_int_t dst0, ae_int_t dst1, ae_state *_state) {
   ae_int_t celloffset;
   ae_int_t idx0;
   ae_int_t idx1;
   celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, i, j, _state);
   for (idx0 = 0; idx0 < kx; idx0++) {
      for (idx1 = 0; idx1 < kx; idx1++) {
         dst->xyR[dst0 + idx0][dst1 + idx1] = blockata->xyR[celloffset + idx0][idx1];
      }
   }
}

// This  is  convenience  function  for band block storage format; it
// truncates all elements of  cell (I,J) which are less than Eps in magnitude.
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_flushtozerocell(ae_int_t kx, ae_int_t ky, ae_int_t blockbandwidth, RMatrix *blockata, ae_int_t i, ae_int_t j, double eps, ae_state *_state) {
   ae_int_t celloffset;
   ae_int_t idx0;
   ae_int_t idx1;
   double eps2;
   double v;
   celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, i, j, _state);
   eps2 = eps * eps;
   for (idx0 = 0; idx0 < kx; idx0++) {
      for (idx1 = 0; idx1 < kx; idx1++) {
         v = blockata->xyR[celloffset + idx0][idx1];
         if (v * v < eps2) {
            blockata->xyR[celloffset + idx0][idx1] = 0.0;
         }
      }
   }
}

// This function generates squared design matrix stored in block band format.
//
// We use adaptation of block skyline storage format, with
// TOWERSIZE*KX skyline bands (towers) stored sequentially;
// here TOWERSIZE=(BlockBandwidth+1)*KX. So, we have KY
// "towers", stored one below other, in BlockATA matrix.
// Every "tower" is a sequence of BlockBandwidth+1 cells,
// each of them being KX*KX in size.
//
// Inputs:
//     AH      -   sparse matrix, [KX*KY,ARows] in size. "Horizontal" version
//                 of design matrix, cols [0,NPoints] contain values of basis
//                 functions at dataset  points.  Other  cols  are  used  for
//                 nonlinearity penalty and other stuff like that.
//     KY0, KY1-   subset of output matrix bands to process; on entry it MUST
//                 be set to 0 and KY respectively.
//     KX, KY  -   grid size
//     BlockATA-   array[KY*(BlockBandwidth+1)*KX,KX],  preallocated  storage
//                 for output matrix in compressed block band format
//     MXATA   -   on entry MUST be zero
//
// Outputs:
//     BlockATA-   AH*AH', stored in compressed block band format
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_blockllsgenerateata(sparsematrix *ah, ae_int_t ky0, ae_int_t ky1, ae_int_t kx, ae_int_t ky, RMatrix *blockata, sreal *mxata, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t blockbandwidth;
   double avgrowlen;
   double cellcost;
   double totalcost;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i0;
   ae_int_t i1;
   ae_int_t j0;
   ae_int_t j1;
   ae_int_t celloffset;
   double v;
   ae_int_t srci;
   ae_int_t srcj;
   ae_int_t idxi;
   ae_int_t idxj;
   ae_int_t endi;
   ae_int_t endj;
   ae_frame_make(_state, &_frame_block);
   NewObj(sreal, tmpmxata, _state);
   ae_assert(mxata->val >= 0.0, "BlockLLSGenerateATA: integrity check failed", _state);
   blockbandwidth = 3;
// Determine problem cost, perform recursive subdivision
// (with optional parallelization)
   avgrowlen = (double)ah->ridx.xZ[kx * ky] / (kx * ky);
   cellcost = rmul3((double)kx, (double)(1 + 2 * blockbandwidth), avgrowlen, _state);
   totalcost = rmul3((double)(ky1 - ky0), (double)(1 + 2 * blockbandwidth), cellcost, _state);
// Parallelism was tried if: ky1 - ky0 >= 2 && totalcost > smpactivationlevel(_state)
   if (ky1 - ky0 >= 2) {
   // Split X: X*A = (X1 X2)^T*A
      j = (ky1 - ky0) / 2;
      spline2d_blockllsgenerateata(ah, ky0, ky0 + j, kx, ky, blockata, &tmpmxata, _state);
      spline2d_blockllsgenerateata(ah, ky0 + j, ky1, kx, ky, blockata, mxata, _state);
      mxata->val = maxreal(mxata->val, tmpmxata.val, _state);
      ae_frame_leave(_state);
      return;
   }
// Splitting in Y-dimension is done, fill I1-th "tower"
   ae_assert(ky1 == ky0 + 1, "BlockLLSGenerateATA: integrity check failed", _state);
   i1 = ky0;
   for (j1 = i1; j1 < ky && j1 <= i1 + blockbandwidth; j1++) {
      celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, i1, j1, _state);
   // Clear cell (I1,J1)
      for (i0 = 0; i0 < kx; i0++) {
         for (j0 = 0; j0 < kx; j0++) {
            blockata->xyR[celloffset + i0][j0] = 0.0;
         }
      }
   // Initialize cell internals
      for (i0 = 0; i0 < kx; i0++) {
         for (j0 = 0; j0 < kx; j0++) {
            if (ae_iabs(i0 - j0, _state) <= blockbandwidth) {
            // Nodes are close enough, calculate product of columns I and J of A.
               v = 0.0;
               i = i1 * kx + i0;
               j = j1 * kx + j0;
               srci = ah->ridx.xZ[i];
               srcj = ah->ridx.xZ[j];
               endi = ah->ridx.xZ[i + 1];
               endj = ah->ridx.xZ[j + 1];
               while (true) {
                  if (srci >= endi || srcj >= endj) {
                     break;
                  }
                  idxi = ah->idx.xZ[srci];
                  idxj = ah->idx.xZ[srcj];
                  if (idxi == idxj) {
                     v += ah->vals.xR[srci] * ah->vals.xR[srcj];
                     srci++;
                     srcj++;
                     continue;
                  }
                  if (idxi < idxj) {
                     srci++;
                  } else {
                     srcj++;
                  }
               }
               blockata->xyR[celloffset + i0][j0] = v;
               mxata->val = maxreal(mxata->val, ae_fabs(v, _state), _state);
            }
         }
      }
   }
   ae_frame_leave(_state);
}

// This function performs Cholesky decomposition of squared design matrix
// stored in block band format.
//
// Inputs:
//     BlockATA        -   array[KY*(BlockBandwidth+1)*KX,KX], matrix in compressed
//                         block band format
//     KX, KY          -   grid size
//     TrsmBuf2,
//     CholBuf2,
//     CholBuf1        -   buffers; reused by this function on subsequent calls,
//                         automatically preallocated on the first call
//
// Outputs:
//     BlockATA-   Cholesky factor, in compressed block band format
//
// Result:
//     True on success, False on Cholesky failure
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static bool spline2d_blockllscholesky(RMatrix *blockata, ae_int_t kx, ae_int_t ky, RMatrix *trsmbuf2, RMatrix *cholbuf2, RVector *cholbuf1, ae_state *_state) {
   ae_int_t blockbandwidth;
   ae_int_t blockidx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t celloffset;
   ae_int_t celloffset1;
   bool result;
   blockbandwidth = 3;
   rmatrixsetlengthatleast(trsmbuf2, (blockbandwidth + 1) * kx, (blockbandwidth + 1) * kx, _state);
   rmatrixsetlengthatleast(cholbuf2, kx, kx, _state);
   rvectorsetlengthatleast(cholbuf1, kx, _state);
   result = true;
   for (blockidx = 0; blockidx < ky; blockidx++) {
   // TRSM for TRAIL*TRAIL block matrix before current cell;
   // here TRAIL=MinInt(BlockIdx,BlockBandwidth).
      for (i = 0; i < minint(blockidx, blockbandwidth, _state); i++) {
         for (j = i; j < minint(blockidx, blockbandwidth, _state); j++) {
            spline2d_copycellto(kx, ky, blockbandwidth, blockata, maxint(blockidx - blockbandwidth, 0, _state) + i, maxint(blockidx - blockbandwidth, 0, _state) + j, trsmbuf2, i * kx, j * kx, _state);
         }
      }
      celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, maxint(blockidx - blockbandwidth, 0, _state), blockidx, _state);
      rmatrixlefttrsm(minint(blockidx, blockbandwidth, _state) * kx, kx, trsmbuf2, 0, 0, true, false, 1, blockata, celloffset, 0, _state);
   // SYRK for diagonal cell: MaxInt(BlockIdx-BlockBandwidth,0)
   // cells above diagonal one are used for update.
      celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, maxint(blockidx - blockbandwidth, 0, _state), blockidx, _state);
      celloffset1 = spline2d_getcelloffset(kx, ky, blockbandwidth, blockidx, blockidx, _state);
      rmatrixsyrk(kx, minint(blockidx, blockbandwidth, _state) * kx, -1.0, blockata, celloffset, 0, 1, 1.0, blockata, celloffset1, 0, true, _state);
   // Factorize diagonal cell
      celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, blockidx, blockidx, _state);
      rmatrixcopy(kx, kx, blockata, celloffset, 0, cholbuf2, 0, 0, _state);
      if (!spdmatrixcholeskyrec(cholbuf2, 0, kx, true, cholbuf1, _state)) {
         result = false;
         return result;
      }
      rmatrixcopy(kx, kx, cholbuf2, 0, 0, blockata, celloffset, 0, _state);
   // PERFORMANCE TWEAK: drop nearly-denormals from last "tower".
   //
   // Sparse matrices like these may produce denormal numbers on
   // sparse datasets, with significant (10x!) performance penalty
   // on Intel chips. In order to avoid it, we manually truncate
   // small enough numbers.
   //
   // We use 1.0E-50 as clipping level (not really denormal, but
   // such small numbers are not actually important anyway).
      for (i = maxint(blockidx - blockbandwidth, 0, _state); i <= blockidx; i++) {
         spline2d_flushtozerocell(kx, ky, blockbandwidth, blockata, i, blockidx, 1.0E-50, _state);
      }
   }
   return result;
}

// This function performs TRSV on upper triangular Cholesky factor U, solving
// either U*x=b or U'*x=b.
//
// Inputs:
//     BlockATA        -   array[KY*(BlockBandwidth+1)*KX,KX], matrix U
//                         in compressed block band format
//     KX, KY          -   grid size
//     TransU          -   whether to transpose U or not
//     B               -   array[KX*KY], on entry - stores right part B
//
// Outputs:
//     B               -   replaced by X
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_blockllstrsv(RMatrix *blockata, ae_int_t kx, ae_int_t ky, bool transu, RVector *b, ae_state *_state) {
   ae_int_t blockbandwidth;
   ae_int_t blockidx;
   ae_int_t blockidx1;
   ae_int_t celloffset;
   blockbandwidth = 3;
   if (!transu) {
   // Solve U*x=b
      for (blockidx = ky - 1; blockidx >= 0; blockidx--) {
         for (blockidx1 = 1; blockidx1 < ky - blockidx && blockidx1 <= blockbandwidth; blockidx1++) {
            celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, blockidx, blockidx + blockidx1, _state);
            rmatrixgemv(kx, kx, -1.0, blockata, celloffset, 0, 0, b, (blockidx + blockidx1) * kx, 1.0, b, blockidx * kx, _state);
         }
         celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, blockidx, blockidx, _state);
         rmatrixtrsv(kx, blockata, celloffset, 0, true, false, 0, b, blockidx * kx, _state);
      }
   } else {
   // Solve U'*x=b
      for (blockidx = 0; blockidx < ky; blockidx++) {
         celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, blockidx, blockidx, _state);
         rmatrixtrsv(kx, blockata, celloffset, 0, true, false, 1, b, blockidx * kx, _state);
         for (blockidx1 = 1; blockidx1 < ky - blockidx && blockidx1 <= blockbandwidth; blockidx1++) {
            celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, blockidx, blockidx + blockidx1, _state);
            rmatrixgemv(kx, kx, -1.0, blockata, celloffset, 0, 1, b, blockidx * kx, 1.0, b, (blockidx + blockidx1) * kx, _state);
         }
      }
   }
}

// This function performs matrix-vector product of design matrix and dense
// vector.
//
// Inputs:
//     A       -   design matrix, (a.nrows) X (a.kx*a.ky);
//                 some fields of A are used for temporaries,
//                 so it is non-constant.
//     X       -   array[A.KX*A.KY]
//
//
// Outputs:
//     Y       -   product, array[A.NRows], automatically allocated
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_xdesignmv(spline2dxdesignmatrix *a, RVector *x, RVector *y, ae_state *_state) {
   ae_int_t bidx;
   ae_int_t i;
   ae_int_t cnt;
   double v;
   ae_int_t baseidx;
   ae_int_t outidx;
   ae_int_t batchsize;
   ae_int_t kx;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t nzwidth;
   nzwidth = 4;
   ae_assert(a->blockwidth == nzwidth, "Spline2DFit: integrity check failed", _state);
   ae_assert(x->cnt >= a->kx * a->ky, "Spline2DFit: integrity check failed", _state);
// Prepare
   rvectorsetlengthatleast(y, a->nrows, _state);
   rvectorsetlengthatleast(&a->tmp0, nzwidth * nzwidth, _state);
   rvectorsetlengthatleast(&a->tmp1, a->maxbatch, _state);
   kx = a->kx;
   outidx = 0;
// Process dense part
   for (bidx = 0; bidx < a->ndensebatches; bidx++) {
      if (a->batches.xZ[bidx + 1] - a->batches.xZ[bidx] > 0) {
         batchsize = a->batches.xZ[bidx + 1] - a->batches.xZ[bidx];
         baseidx = a->batchbases.xZ[bidx];
         for (k1 = 0; k1 < nzwidth; k1++) {
            for (k0 = 0; k0 < nzwidth; k0++) {
               a->tmp0.xR[k1 * nzwidth + k0] = x->xR[baseidx + k1 * kx + k0];
            }
         }
         rmatrixgemv(batchsize, nzwidth * nzwidth, 1.0, &a->vals, a->batches.xZ[bidx], 0, 0, &a->tmp0, 0, 0.0, &a->tmp1, 0, _state);
         for (i = 0; i < batchsize; i++) {
            y->xR[outidx + i] = a->tmp1.xR[i];
         }
         outidx += batchsize;
      }
   }
   ae_assert(outidx == a->ndenserows, "Spline2DFit: integrity check failed", _state);
// Process regularizer
   v = a->lambdareg;
   cnt = a->kx * a->ky;
   for (i = 0; i < cnt; i++) {
      y->xR[outidx + i] = v * x->xR[i];
   }
   outidx += cnt;
// Post-check
   ae_assert(outidx == a->nrows, "Spline2DFit: integrity check failed", _state);
}

// This function performs matrix-vector product of transposed design matrix and dense
// vector.
//
// Inputs:
//     A       -   design matrix, (a.nrows) X (a.kx*a.ky);
//                 some fields of A are used for temporaries,
//                 so it is non-constant.
//     X       -   array[A.NRows]
//
//
// Outputs:
//     Y       -   product, array[A.KX*A.KY], automatically allocated
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_xdesignmtv(spline2dxdesignmatrix *a, RVector *x, RVector *y, ae_state *_state) {
   ae_int_t bidx;
   ae_int_t i;
   ae_int_t cnt;
   double v;
   ae_int_t baseidx;
   ae_int_t inidx;
   ae_int_t batchsize;
   ae_int_t kx;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t nzwidth;
   nzwidth = 4;
   ae_assert(a->blockwidth == nzwidth, "Spline2DFit: integrity check failed", _state);
   ae_assert(x->cnt >= a->nrows, "Spline2DFit: integrity check failed", _state);
// Prepare
   rvectorsetlengthatleast(y, a->kx * a->ky, _state);
   rvectorsetlengthatleast(&a->tmp0, nzwidth * nzwidth, _state);
   rvectorsetlengthatleast(&a->tmp1, a->maxbatch, _state);
   kx = a->kx;
   inidx = 0;
   cnt = a->kx * a->ky;
   for (i = 0; i < cnt; i++) {
      y->xR[i] = 0.0;
   }
// Process dense part
   for (bidx = 0; bidx < a->ndensebatches; bidx++) {
      if (a->batches.xZ[bidx + 1] - a->batches.xZ[bidx] > 0) {
         batchsize = a->batches.xZ[bidx + 1] - a->batches.xZ[bidx];
         baseidx = a->batchbases.xZ[bidx];
         for (i = 0; i < batchsize; i++) {
            a->tmp1.xR[i] = x->xR[inidx + i];
         }
         rmatrixgemv(nzwidth * nzwidth, batchsize, 1.0, &a->vals, a->batches.xZ[bidx], 0, 1, &a->tmp1, 0, 0.0, &a->tmp0, 0, _state);
         for (k1 = 0; k1 < nzwidth; k1++) {
            for (k0 = 0; k0 < nzwidth; k0++) {
               y->xR[baseidx + k1 * kx + k0] += a->tmp0.xR[k1 * nzwidth + k0];
            }
         }
         inidx += batchsize;
      }
   }
   ae_assert(inidx == a->ndenserows, "Spline2DFit: integrity check failed", _state);
// Process regularizer
   v = a->lambdareg;
   cnt = a->kx * a->ky;
   for (i = 0; i < cnt; i++) {
      y->xR[i] += v * x->xR[inidx + i];
   }
   inidx += cnt;
// Post-check
   ae_assert(inidx == a->nrows, "Spline2DFit: integrity check failed", _state);
}

// This function generates squared design matrix stored in block band format.
//
// We  use  an   adaptation   of   block   skyline   storage   format,   with
// TOWERSIZE*KX   skyline    bands   (towers)   stored   sequentially;   here
// TOWERSIZE=(BlockBandwidth+1)*KX. So, we have KY "towers", stored one below
// other, in BlockATA matrix. Every "tower" is a sequence of BlockBandwidth+1
// cells, each of them being KX*KX in size.
//
// Inputs:
//     A       -   design matrix; some of its fields are used for temporaries
//     BlockATA-   array[KY*(BlockBandwidth+1)*KX,KX],  preallocated  storage
//                 for output matrix in compressed block band format
//
// Outputs:
//     BlockATA-   AH*AH', stored in compressed block band format
//     MXATA   -   max(|AH*AH'|), elementwise
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_xdesignblockata(spline2dxdesignmatrix *a, RMatrix *blockata, double *mxata, ae_state *_state) {
   ae_int_t blockbandwidth;
   ae_int_t nzwidth;
   ae_int_t kx;
   ae_int_t ky;
   ae_int_t i0;
   ae_int_t i1;
   ae_int_t j0;
   ae_int_t j1;
   ae_int_t celloffset;
   ae_int_t bidx;
   ae_int_t baseidx;
   ae_int_t batchsize;
   ae_int_t offs0;
   ae_int_t offs1;
   double v;
   blockbandwidth = 3;
   nzwidth = 4;
   kx = a->kx;
   ky = a->ky;
   ae_assert(a->blockwidth == nzwidth, "Spline2DFit: integrity check failed", _state);
   rmatrixsetlengthatleast(&a->tmp2, nzwidth * nzwidth, nzwidth * nzwidth, _state);
// Initial zero-fill:
// * zero-fill ALL elements of BlockATA
// * zero-fill ALL elements of Tmp2
//
// Filling ALL elements, including unused ones, is essential for the
// purposes of calculating max(BlockATA).
   for (i1 = 0; i1 < ky; i1++) {
      for (i0 = i1; i0 < ky && i0 <= i1 + blockbandwidth; i0++) {
         celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, i1, i0, _state);
         for (j1 = 0; j1 < kx; j1++) {
            for (j0 = 0; j0 < kx; j0++) {
               blockata->xyR[celloffset + j1][j0] = 0.0;
            }
         }
      }
   }
   for (j1 = 0; j1 < nzwidth * nzwidth; j1++) {
      for (j0 = 0; j0 < nzwidth * nzwidth; j0++) {
         a->tmp2.xyR[j1][j0] = 0.0;
      }
   }
// Process dense part of A
   for (bidx = 0; bidx < a->ndensebatches; bidx++) {
      if (a->batches.xZ[bidx + 1] - a->batches.xZ[bidx] > 0) {
      // Generate 16x16 U = BATCH'*BATCH and add it to ATA.
      //
      // NOTE: it is essential that lower triangle of Tmp2 is
      //       filled by zeros.
         batchsize = a->batches.xZ[bidx + 1] - a->batches.xZ[bidx];
         rmatrixsyrk(nzwidth * nzwidth, batchsize, 1.0, &a->vals, a->batches.xZ[bidx], 0, 2, 0.0, &a->tmp2, 0, 0, true, _state);
         baseidx = a->batchbases.xZ[bidx];
         for (i1 = 0; i1 < nzwidth; i1++) {
            for (j1 = i1; j1 < nzwidth; j1++) {
               celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, baseidx / kx + i1, baseidx / kx + j1, _state);
               offs0 = baseidx % kx;
               offs1 = baseidx % kx;
               for (i0 = 0; i0 < nzwidth; i0++) {
                  for (j0 = 0; j0 < nzwidth; j0++) {
                     v = a->tmp2.xyR[i1 * nzwidth + i0][j1 * nzwidth + j0];
                     blockata->xyR[celloffset + offs1 + i0][offs0 + j0] += v;
                  }
               }
            }
         }
      }
   }
// Process regularizer term
   for (i1 = 0; i1 < ky; i1++) {
      celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, i1, i1, _state);
      for (j1 = 0; j1 < kx; j1++) {
         blockata->xyR[celloffset + j1][j1] += sqr(a->lambdareg, _state);
      }
   }
// Calculate max(ATA)
//
// NOTE: here we rely on zero initialization of unused parts of
//       BlockATA and Tmp2.
   *mxata = 0.0;
   for (i1 = 0; i1 < ky; i1++) {
      for (i0 = i1; i0 < ky && i0 <= i1 + blockbandwidth; i0++) {
         celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, i1, i0, _state);
         for (j1 = 0; j1 < kx; j1++) {
            for (j0 = 0; j0 < kx; j0++) {
               *mxata = maxreal(*mxata, ae_fabs(blockata->xyR[celloffset + j1][j0], _state), _state);
            }
         }
      }
   }
}

// This function performs fitting with  BlockLLS solver.  Internal  function,
// never use it directly.
//
// IMPORTANT: performance  and  memory  requirements  of  this  function  are
//            asymmetric w.r.t. KX and KY: it has
//            * O(KY*KX^2) memory requirements
//            * O(KY*KX^3) running time
//            Thus, if you have large KY and small KX,  simple  transposition
//            of your dataset may give you great speedup.
//
// Inputs:
//     AV      -   sparse matrix, [ARows,KX*KY] in size.  "Vertical"  version
//                 of design matrix, rows [0,NPoints) contain values of basis
//                 functions at dataset  points.  Other  rows  are  used  for
//                 nonlinearity penalty and other stuff like that.
//     AH      -   transpose(AV), "horizontal" version of AV
//     ARows   -   rows count
//     XY      -   array[NPoints*(2+D)], dataset
//     KX, KY  -   grid size
//     NPoints -   points count
//     D       -   number of components in vector-valued spline, D >= 1
//     LSQRCnt -   number of iterations, non-zero:
//                 * LSQRCnt>0 means that specified amount of  preconditioned
//                   LSQR  iterations  will  be  performed  to solve problem;
//                   usually  we  need  2..5  its.  Recommended option - best
//                   convergence and stability/quality.
//                 * LSQRCnt<0 means that instead of LSQR  we  use  iterative
//                   refinement on normal equations. Again, 2..5 its is enough.
//     Z       -   possibly preallocated buffer for solution
//     Rep     -   report structure; fields which are not set by this function
//                 are left intact
//     TSS     -   total sum of squares; used to calculate R2
//
//
// Outputs:
//     XY      -   destroyed in process
//     Z       -   array[KX*KY*D], filled by solution; KX*KY coefficients
//                 corresponding to each of D dimensions are stored contiguously.
//     Rep         -   following fields are set:
//                     * Rep.RMSError
//                     * Rep.AvgError
//                     * Rep.MaxError
//                     * Rep.R2
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_blockllsfit(spline2dxdesignmatrix *xdesign, ae_int_t lsqrcnt, RVector *z, spline2dfitreport *rep, double tss, spline2dblockllsbuf *buf, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t blockbandwidth;
   ae_int_t d;
   ae_int_t i;
   ae_int_t j;
   double lambdachol;
   double v;
   ae_int_t celloffset;
   ae_int_t i0;
   ae_int_t i1;
   double rss;
   ae_int_t arows;
   ae_int_t bw2;
   ae_int_t kx;
   ae_int_t ky;
   ae_frame_make(_state, &_frame_block);
   NewObj(sreal, mxata, _state);
   ae_assert(xdesign->blockwidth == 4, "Spline2DFit: integrity check failed", _state);
   blockbandwidth = 3;
   d = xdesign->d;
   arows = xdesign->nrows;
   kx = xdesign->kx;
   ky = xdesign->ky;
   bw2 = xdesign->blockwidth * xdesign->blockwidth;
// Initial values for Z/Residuals
   rvectorsetlengthatleast(z, kx * ky * d, _state);
   for (i = 0; i < kx * ky * d; i++) {
      z->xR[i] = 0.0;
   }
// Create and factorize design matrix. Add regularizer if
// factorization failed (happens sometimes with zero
// smoothing and sparsely populated datasets).
//
// The algorithm below is refactoring of NaiveLLS algorithm,
// which uses sparsity properties and compressed block storage.
//
// Problem sparsity pattern results in block-band-diagonal
// matrix (block matrix with limited bandwidth, equal to 3
// for bicubic splines). Thus, we have KY*KY blocks, each
// of them is KX*KX in size. Design matrix is stored in
// large NROWS*KX matrix, with NROWS=(BlockBandwidth+1)*KY*KX.
//
// We use adaptation of block skyline storage format, with
// TOWERSIZE*KX skyline bands (towers) stored sequentially;
// here TOWERSIZE=(BlockBandwidth+1)*KX. So, we have KY
// "towers", stored one below other, in BlockATA matrix.
// Every "tower" is a sequence of BlockBandwidth+1 cells,
// each of them being KX*KX in size.
   lambdachol = spline2d_cholreg;
   rmatrixsetlengthatleast(&buf->blockata, (blockbandwidth + 1) * ky * kx, kx, _state);
   while (true) {
   // Parallel generation of squared design matrix.
      spline2d_xdesignblockata(xdesign, &buf->blockata, &mxata.val, _state);
   // Regularization
      v = coalesce(mxata.val, 1.0, _state) * lambdachol;
      for (i1 = 0; i1 < ky; i1++) {
         celloffset = spline2d_getcelloffset(kx, ky, blockbandwidth, i1, i1, _state);
         for (i0 = 0; i0 < kx; i0++) {
            buf->blockata.xyR[celloffset + i0][i0] += v;
         }
      }
   // Try Cholesky factorization.
      if (!spline2d_blockllscholesky(&buf->blockata, kx, ky, &buf->trsmbuf2, &buf->cholbuf2, &buf->cholbuf1, _state)) {
      // Factorization failed, increase regularizer and repeat
         lambdachol = coalesce(10 * lambdachol, 1.0E-12, _state);
         continue;
      }
      break;
   }
// Solve
   rss = 0.0;
   rep->rmserror = 0.0;
   rep->avgerror = 0.0;
   rep->maxerror = 0.0;
   ae_assert(lsqrcnt > 0, "Spline2DFit: integrity failure", _state);
   rvectorsetlengthatleast(&buf->tmp0, arows, _state);
   rvectorsetlengthatleast(&buf->tmp1, kx * ky, _state);
   linlsqrcreatebuf(arows, kx * ky, &buf->solver, _state);
   for (j = 0; j < d; j++) {
   // Preconditioned LSQR:
   //
   // use Cholesky factor U of squared design matrix A'*A to
   // transform min|A*x-b| to min|[A*inv(U)]*y-b| with y=U*x.
   //
   // Preconditioned problem is solved with LSQR solver, which
   // gives superior results than normal equations.
      for (i = 0; i < arows; i++) {
         if (i < xdesign->npoints) {
            buf->tmp0.xR[i] = xdesign->vals.xyR[i][bw2 + j];
         } else {
            buf->tmp0.xR[i] = 0.0;
         }
      }
      linlsqrrestart(&buf->solver, _state);
      linlsqrsetb(&buf->solver, &buf->tmp0, _state);
      linlsqrsetcond(&buf->solver, 1.0E-14, 1.0E-14, lsqrcnt, _state);
      while (linlsqriteration(&buf->solver, _state)) {
         if (buf->solver.needmv) {
         // Use Cholesky factorization of the system matrix
         // as preconditioner: solve TRSV(U,Solver.X)
            for (i = 0; i < kx * ky; i++) {
               buf->tmp1.xR[i] = buf->solver.x.xR[i];
            }
            spline2d_blockllstrsv(&buf->blockata, kx, ky, false, &buf->tmp1, _state);
         // After preconditioning is done, multiply by A
            spline2d_xdesignmv(xdesign, &buf->tmp1, &buf->solver.mv, _state);
         }
         if (buf->solver.needmtv) {
         // Multiply by design matrix A
            spline2d_xdesignmtv(xdesign, &buf->solver.x, &buf->solver.mtv, _state);
         // Multiply by preconditioner: solve TRSV(U',A*Solver.X)
            spline2d_blockllstrsv(&buf->blockata, kx, ky, true, &buf->solver.mtv, _state);
         }
      }
   // Get results and post-multiply by preconditioner to get
   // original variables.
      linlsqrresults(&buf->solver, &buf->tmp1, &buf->solverrep, _state);
      spline2d_blockllstrsv(&buf->blockata, kx, ky, false, &buf->tmp1, _state);
      for (i = 0; i < kx * ky; i++) {
         z->xR[kx * ky * j + i] = buf->tmp1.xR[i];
      }
   // Calculate model values
      spline2d_xdesignmv(xdesign, &buf->tmp1, &buf->tmp0, _state);
      for (i = 0; i < xdesign->npoints; i++) {
         v = xdesign->vals.xyR[i][bw2 + j] - buf->tmp0.xR[i];
         rss += v * v;
         rep->rmserror += sqr(v, _state);
         rep->avgerror += ae_fabs(v, _state);
         rep->maxerror = maxreal(rep->maxerror, ae_fabs(v, _state), _state);
      }
   }
   rep->rmserror = ae_sqrt(rep->rmserror / coalesce((double)(xdesign->npoints * d), 1.0, _state), _state);
   rep->avgerror /= coalesce((double)(xdesign->npoints * d), 1.0, _state);
   rep->r2 = 1.0 - rss / coalesce(tss, 1.0, _state);
   ae_frame_leave(_state);
}

// This function generates design matrix for the problem (in fact, two design
// matrices are generated: "vertical" one and transposed (horizontal) one.
//
// Inputs:
//     XY          -   array[NPoints*(2+D)]; dataset after scaling  in  such
//                     way that grid step is equal to 1.0 in both dimensions.
//     NPoints     -   dataset size, NPoints >= 1
//     KX, KY      -   grid size, KX,KY >= 4
//     Smoothing   -   nonlinearity penalty coefficient, >= 0
//     LambdaReg   -   regularization coefficient, >= 0
//     Basis1      -   basis spline, expected to be non-zero only at [-2,+2]
//     AV, AH      -   possibly preallocated buffers
//
// Outputs:
//     AV          -   sparse matrix[ARows,KX*KY]; design matrix
//     AH          -   transpose of AV
//     ARows       -   number of rows in design matrix
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_generatedesignmatrix(RVector *xy, ae_int_t npoints, ae_int_t d, ae_int_t kx, ae_int_t ky, double smoothing, double lambdareg, spline1dinterpolant *basis1, sparsematrix *av, sparsematrix *ah, ae_int_t *arows, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t nzwidth;
   ae_int_t nzshift;
   ae_int_t ew;
   ae_int_t i;
   ae_int_t j0;
   ae_int_t j1;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t dstidx;
   double v;
   double v0;
   double v1;
   double v2;
   double w0;
   double w1;
   double w2;
   ae_frame_make(_state, &_frame_block);
   *arows = 0;
   NewVector(crx, 0, DT_INT, _state);
   NewVector(cry, 0, DT_INT, _state);
   NewVector(nrs, 0, DT_INT, _state);
   NewMatrix(d2x, 0, 0, DT_REAL, _state);
   NewMatrix(d2y, 0, 0, DT_REAL, _state);
   NewMatrix(dxy, 0, 0, DT_REAL, _state);
   nzwidth = 4;
   nzshift = 1;
   ae_assert(npoints > 0, "Spline2DFit: integrity check failed", _state);
   ae_assert(kx >= nzwidth, "Spline2DFit: integrity check failed", _state);
   ae_assert(ky >= nzwidth, "Spline2DFit: integrity check failed", _state);
   ew = 2 + d;
// Determine canonical rectangle for every point. Every point of the dataset is
// influenced by at most NZWidth*NZWidth basis functions, which form NZWidth*NZWidth
// canonical rectangle.
//
// Thus, we have (KX-NZWidth+1)*(KY-NZWidth+1) overlapping canonical rectangles.
// Assigning every point to its rectangle simplifies creation of sparse basis
// matrix at the next steps.
   ae_vector_set_length(&crx, npoints, _state);
   ae_vector_set_length(&cry, npoints, _state);
   for (i = 0; i < npoints; i++) {
      crx.xZ[i] = iboundval(ifloor(xy->xR[i * ew + 0], _state) - nzshift, 0, kx - nzwidth, _state);
      cry.xZ[i] = iboundval(ifloor(xy->xR[i * ew + 1], _state) - nzshift, 0, ky - nzwidth, _state);
   }
// Create vertical and horizontal design matrices
   *arows = npoints + kx * ky;
   if (smoothing != 0.0) {
      ae_assert(smoothing > 0.0, "Spline2DFit: integrity check failed", _state);
      *arows += 3 * (kx - 2) * (ky - 2);
   }
   ae_vector_set_length(&nrs, *arows, _state);
   dstidx = 0;
   for (i = 0; i < npoints; i++) {
      nrs.xZ[dstidx + i] = nzwidth * nzwidth;
   }
   dstidx += npoints;
   for (i = 0; i < kx * ky; i++) {
      nrs.xZ[dstidx + i] = 1;
   }
   dstidx += kx * ky;
   if (smoothing != 0.0) {
      for (i = 0; i < 3 * (kx - 2) * (ky - 2); i++) {
         nrs.xZ[dstidx + i] = 3 * 3;
      }
      dstidx += 3 * (kx - 2) * (ky - 2);
   }
   ae_assert(dstidx == (*arows), "Spline2DFit: integrity check failed", _state);
   sparsecreatecrs(*arows, kx * ky, &nrs, av, _state);
   dstidx = 0;
   for (i = 0; i < npoints; i++) {
      for (j1 = 0; j1 < nzwidth; j1++) {
         for (j0 = 0; j0 < nzwidth; j0++) {
            v0 = spline1dcalc(basis1, xy->xR[i * ew + 0] - (crx.xZ[i] + j0), _state);
            v1 = spline1dcalc(basis1, xy->xR[i * ew + 1] - (cry.xZ[i] + j1), _state);
            sparseset(av, dstidx + i, (cry.xZ[i] + j1) * kx + (crx.xZ[i] + j0), v0 * v1, _state);
         }
      }
   }
   dstidx += npoints;
   for (i = 0; i < kx * ky; i++) {
      sparseset(av, dstidx + i, i, lambdareg, _state);
   }
   dstidx += kx * ky;
   if (smoothing != 0.0) {
   // Smoothing is applied. Because all grid nodes are same,
   // we apply same smoothing kernel, which is calculated only
   // once at the beginning of design matrix generation.
      ae_matrix_set_length(&d2x, 3, 3, _state);
      ae_matrix_set_length(&d2y, 3, 3, _state);
      ae_matrix_set_length(&dxy, 3, 3, _state);
      for (j1 = 0; j1 <= 2; j1++) {
         for (j0 = 0; j0 <= 2; j0++) {
            d2x.xyR[j0][j1] = 0.0;
            d2y.xyR[j0][j1] = 0.0;
            dxy.xyR[j0][j1] = 0.0;
         }
      }
      for (k1 = 0; k1 <= 2; k1++) {
         for (k0 = 0; k0 <= 2; k0++) {
            spline1ddiff(basis1, (double)-(k0 - 1), &v0, &v1, &v2, _state);
            spline1ddiff(basis1, (double)-(k1 - 1), &w0, &w1, &w2, _state);
            d2x.xyR[k0][k1] += v2 * w0;
            d2y.xyR[k0][k1] += w2 * v0;
            dxy.xyR[k0][k1] += v1 * w1;
         }
      }
   // Now, kernel is ready - apply it to all inner nodes of the grid.
      for (j1 = 1; j1 < ky - 1; j1++) {
         for (j0 = 1; j0 < kx - 1; j0++) {
         // d2F/dx2 term
            v = smoothing;
            for (k1 = -1; k1 <= 1; k1++) {
               for (k0 = -1; k0 <= 1; k0++) {
                  sparseset(av, dstidx, (j1 + k1) * kx + (j0 + k0), v * d2x.xyR[1 + k0][1 + k1], _state);
               }
            }
            dstidx++;
         // d2F/dy2 term
            v = smoothing;
            for (k1 = -1; k1 <= 1; k1++) {
               for (k0 = -1; k0 <= 1; k0++) {
                  sparseset(av, dstidx, (j1 + k1) * kx + (j0 + k0), v * d2y.xyR[1 + k0][1 + k1], _state);
               }
            }
            dstidx++;
         // 2*d2F/dxdy term
            v = ae_sqrt(2.0, _state) * smoothing;
            for (k1 = -1; k1 <= 1; k1++) {
               for (k0 = -1; k0 <= 1; k0++) {
                  sparseset(av, dstidx, (j1 + k1) * kx + (j0 + k0), v * dxy.xyR[1 + k0][1 + k1], _state);
               }
            }
            dstidx++;
         }
      }
   }
   ae_assert(dstidx == (*arows), "Spline2DFit: integrity check failed", _state);
   sparsecopy(av, ah, _state);
   sparsetransposecrs(ah, _state);
   ae_frame_leave(_state);
}

// This function updates table of spline values/derivatives using coefficients
// for a layer of basis functions.
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_updatesplinetable(RVector *z, ae_int_t kx, ae_int_t ky, ae_int_t d, spline1dinterpolant *basis1, ae_int_t bfrad, RVector *ftbl, ae_int_t m, ae_int_t n, ae_int_t scalexy, ae_state *_state) {
   ae_int_t k;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t j;
   ae_int_t j0;
   ae_int_t j1;
   ae_int_t j0a;
   ae_int_t j0b;
   ae_int_t j1a;
   ae_int_t j1b;
   double v;
   double v0;
   double v1;
   double v01;
   double v11;
   double rdummy;
   ae_int_t dstidx;
   ae_int_t sfx;
   ae_int_t sfy;
   ae_int_t sfxy;
   double invscalexy;
   ae_assert(n == (kx - 1) * scalexy + 1, "Spline2DFit.UpdateSplineTable: integrity check failed", _state);
   ae_assert(m == (ky - 1) * scalexy + 1, "Spline2DFit.UpdateSplineTable: integrity check failed", _state);
   invscalexy = 1.0 / scalexy;
   sfx = n * m * d;
   sfy = 2 * n * m * d;
   sfxy = 3 * n * m * d;
   for (k = 0; k < kx * ky; k++) {
      k0 = k % kx;
      k1 = k / kx;
      j0a = iboundval(k0 * scalexy - (bfrad * scalexy - 1), 0, n - 1, _state);
      j0b = iboundval(k0 * scalexy + (bfrad * scalexy - 1), 0, n - 1, _state);
      j1a = iboundval(k1 * scalexy - (bfrad * scalexy - 1), 0, m - 1, _state);
      j1b = iboundval(k1 * scalexy + (bfrad * scalexy - 1), 0, m - 1, _state);
      for (j1 = j1a; j1 <= j1b; j1++) {
         spline1ddiff(basis1, (j1 - k1 * scalexy) * invscalexy, &v1, &v11, &rdummy, _state);
         v11 *= invscalexy;
         for (j0 = j0a; j0 <= j0b; j0++) {
            spline1ddiff(basis1, (j0 - k0 * scalexy) * invscalexy, &v0, &v01, &rdummy, _state);
            v01 *= invscalexy;
            for (j = 0; j < d; j++) {
               dstidx = d * (j1 * n + j0) + j;
               v = z->xR[j * kx * ky + k];
               ftbl->xR[dstidx] += v0 * v1 * v;
               ftbl->xR[sfx + dstidx] += v01 * v1 * v;
               ftbl->xR[sfy + dstidx] += v0 * v11 * v;
               ftbl->xR[sfxy + dstidx] += v01 * v11 * v;
            }
         }
      }
   }
}

// This function performs fitting with  BlockLLS solver.  Internal  function,
// never use it directly.
//
// Inputs:
//     XY      -   dataset, array[NPoints,2+D]
//     XYIndex -   dataset index, see ReorderDatasetAndBuildIndex() for more info
//     KX0, KX1-   X-indices of basis functions to select and fit;
//                 range [KX0,KX1) is processed
//     KXTotal -   total number of indexes in the entire grid
//     KY0, KY1-   Y-indices of basis functions to select and fit;
//                 range [KY0,KY1) is processed
//     KYTotal -   total number of indexes in the entire grid
//     D       -   number of components in vector-valued spline, D >= 1
//     LambdaReg-  regularization coefficient
//     LambdaNS-   nonlinearity penalty, exactly zero value is specially handled
//                 (entire set of rows is not added to the matrix)
//     Basis1  -   single-dimensional B-spline
//
//
// Outputs:
//     A       -   design matrix
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_xdesigngenerate(RVector *xy, ZVector *xyindex, ae_int_t kx0, ae_int_t kx1, ae_int_t kxtotal, ae_int_t ky0, ae_int_t ky1, ae_int_t kytotal, ae_int_t d, double lambdareg, double lambdans, spline1dinterpolant *basis1, spline2dxdesignmatrix *a, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t entrywidth;
   ae_int_t i;
   ae_int_t j;
   ae_int_t j0;
   ae_int_t j1;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t kx;
   ae_int_t ky;
   ae_int_t rowsdone;
   ae_int_t batchesdone;
   ae_int_t pt0;
   ae_int_t pt1;
   ae_int_t base0;
   ae_int_t base1;
   ae_int_t baseidx;
   ae_int_t nzshift;
   ae_int_t nzwidth;
   double v;
   double v0;
   double v1;
   double v2;
   double w0;
   double w1;
   double w2;
   ae_frame_make(_state, &_frame_block);
   NewMatrix(d2x, 0, 0, DT_REAL, _state);
   NewMatrix(d2y, 0, 0, DT_REAL, _state);
   NewMatrix(dxy, 0, 0, DT_REAL, _state);
   nzshift = 1;
   nzwidth = 4;
   entrywidth = 2 + d;
   kx = kx1 - kx0;
   ky = ky1 - ky0;
   a->lambdareg = lambdareg;
   a->blockwidth = 4;
   a->kx = kx;
   a->ky = ky;
   a->d = d;
   a->npoints = 0;
   a->ndenserows = 0;
   a->ndensebatches = 0;
   a->maxbatch = 0;
   for (j1 = ky0; j1 < ky1 - 1; j1++) {
      for (j0 = kx0; j0 < kx1 - 1; j0++) {
         i = xyindex->xZ[j1 * (kxtotal - 1) + j0 + 1] - xyindex->xZ[j1 * (kxtotal - 1) + j0];
         a->npoints += i;
         a->ndenserows += i;
         a->ndensebatches++;
         a->maxbatch = maxint(a->maxbatch, i, _state);
      }
   }
   if (lambdans != 0.0) {
      ae_assert(lambdans >= 0.0, "Spline2DFit: integrity check failed", _state);
      a->ndenserows += 3 * (kx - 2) * (ky - 2);
      a->ndensebatches += (kx - 2) * (ky - 2);
      a->maxbatch = maxint(a->maxbatch, 3, _state);
   }
   a->nrows = a->ndenserows + kx * ky;
   rmatrixsetlengthatleast(&a->vals, a->ndenserows, a->blockwidth * a->blockwidth + d, _state);
   ivectorsetlengthatleast(&a->batches, a->ndensebatches + 1, _state);
   ivectorsetlengthatleast(&a->batchbases, a->ndensebatches, _state);
// Setup output counters
   batchesdone = 0;
   rowsdone = 0;
// Generate rows corresponding to dataset points
   ae_assert(kx >= nzwidth, "Spline2DFit: integrity check failed", _state);
   ae_assert(ky >= nzwidth, "Spline2DFit: integrity check failed", _state);
   rvectorsetlengthatleast(&a->tmp0, nzwidth, _state);
   rvectorsetlengthatleast(&a->tmp1, nzwidth, _state);
   a->batches.xZ[batchesdone] = 0;
   for (j1 = ky0; j1 < ky1 - 1; j1++) {
      for (j0 = kx0; j0 < kx1 - 1; j0++) {
         pt0 = xyindex->xZ[j1 * (kxtotal - 1) + j0];
         pt1 = xyindex->xZ[j1 * (kxtotal - 1) + j0 + 1];
         base0 = iboundval(j0 - kx0 - nzshift, 0, kx - nzwidth, _state);
         base1 = iboundval(j1 - ky0 - nzshift, 0, ky - nzwidth, _state);
         baseidx = base1 * kx + base0;
         a->batchbases.xZ[batchesdone] = baseidx;
         for (i = pt0; i < pt1; i++) {
            for (k0 = 0; k0 < nzwidth; k0++) {
               a->tmp0.xR[k0] = spline1dcalc(basis1, xy->xR[i * entrywidth + 0] - (base0 + kx0 + k0), _state);
            }
            for (k1 = 0; k1 < nzwidth; k1++) {
               a->tmp1.xR[k1] = spline1dcalc(basis1, xy->xR[i * entrywidth + 1] - (base1 + ky0 + k1), _state);
            }
            for (k1 = 0; k1 < nzwidth; k1++) {
               for (k0 = 0; k0 < nzwidth; k0++) {
                  a->vals.xyR[rowsdone][k1 * nzwidth + k0] = a->tmp0.xR[k0] * a->tmp1.xR[k1];
               }
            }
            for (j = 0; j < d; j++) {
               a->vals.xyR[rowsdone][nzwidth * nzwidth + j] = xy->xR[i * entrywidth + 2 + j];
            }
            rowsdone++;
         }
         batchesdone++;
         a->batches.xZ[batchesdone] = rowsdone;
      }
   }
// Generate rows corresponding to nonlinearity penalty
   if (lambdans > 0.0) {
   // Smoothing is applied. Because all grid nodes are same,
   // we apply same smoothing kernel, which is calculated only
   // once at the beginning of design matrix generation.
      ae_matrix_set_length(&d2x, 3, 3, _state);
      ae_matrix_set_length(&d2y, 3, 3, _state);
      ae_matrix_set_length(&dxy, 3, 3, _state);
      for (j1 = 0; j1 <= 2; j1++) {
         for (j0 = 0; j0 <= 2; j0++) {
            d2x.xyR[j0][j1] = 0.0;
            d2y.xyR[j0][j1] = 0.0;
            dxy.xyR[j0][j1] = 0.0;
         }
      }
      for (k1 = 0; k1 <= 2; k1++) {
         for (k0 = 0; k0 <= 2; k0++) {
            spline1ddiff(basis1, (double)-(k0 - 1), &v0, &v1, &v2, _state);
            spline1ddiff(basis1, (double)-(k1 - 1), &w0, &w1, &w2, _state);
            d2x.xyR[k0][k1] += v2 * w0;
            d2y.xyR[k0][k1] += w2 * v0;
            dxy.xyR[k0][k1] += v1 * w1;
         }
      }
   // Now, kernel is ready - apply it to all inner nodes of the grid.
      for (j1 = 1; j1 < ky - 1; j1++) {
         for (j0 = 1; j0 < kx - 1; j0++) {
            base0 = imax2(j0 - 2, 0, _state);
            base1 = imax2(j1 - 2, 0, _state);
            baseidx = base1 * kx + base0;
            a->batchbases.xZ[batchesdone] = baseidx;
         // d2F/dx2 term
            v = lambdans;
            for (j = 0; j < nzwidth * nzwidth + d; j++) {
               a->vals.xyR[rowsdone][j] = 0.0;
            }
            for (k1 = j1 - 1; k1 <= j1 + 1; k1++) {
               for (k0 = j0 - 1; k0 <= j0 + 1; k0++) {
                  a->vals.xyR[rowsdone][nzwidth * (k1 - base1) + (k0 - base0)] = v * d2x.xyR[1 + (k0 - j0)][1 + (k1 - j1)];
               }
            }
            rowsdone++;
         // d2F/dy2 term
            v = lambdans;
            for (j = 0; j < nzwidth * nzwidth + d; j++) {
               a->vals.xyR[rowsdone][j] = 0.0;
            }
            for (k1 = j1 - 1; k1 <= j1 + 1; k1++) {
               for (k0 = j0 - 1; k0 <= j0 + 1; k0++) {
                  a->vals.xyR[rowsdone][nzwidth * (k1 - base1) + (k0 - base0)] = v * d2y.xyR[1 + (k0 - j0)][1 + (k1 - j1)];
               }
            }
            rowsdone++;
         // 2*d2F/dxdy term
            v = ae_sqrt(2.0, _state) * lambdans;
            for (j = 0; j < nzwidth * nzwidth + d; j++) {
               a->vals.xyR[rowsdone][j] = 0.0;
            }
            for (k1 = j1 - 1; k1 <= j1 + 1; k1++) {
               for (k0 = j0 - 1; k0 <= j0 + 1; k0++) {
                  a->vals.xyR[rowsdone][nzwidth * (k1 - base1) + (k0 - base0)] = v * dxy.xyR[1 + (k0 - j0)][1 + (k1 - j1)];
               }
            }
            rowsdone++;
            batchesdone++;
            a->batches.xZ[batchesdone] = rowsdone;
         }
      }
   }
// Integrity post-check
   ae_assert(batchesdone == a->ndensebatches, "Spline2DFit: integrity check failed", _state);
   ae_assert(rowsdone == a->ndenserows, "Spline2DFit: integrity check failed", _state);
   ae_frame_leave(_state);
}

// Recursive fitting function for FastDDM algorithm.
//
// Works with KX*KY grid, with KX=BasecaseX*TilesCountX+1 and KY=BasecaseY*TilesCountY+1,
// which is partitioned into TilesCountX*TilesCountY tiles, each having size
// BasecaseX*BasecaseY.
//
// This function processes tiles in range [TileX0,TileX1)x[TileY0,TileY1) and
// recursively divides this range until we move down to single tile, which
// is processed with BlockLLS solver.
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_fastddmfitlayer(RVector *xy, ae_int_t d, ae_int_t scalexy, ZVector *xyindex, ae_int_t basecasex, ae_int_t tilex0, ae_int_t tilex1, ae_int_t tilescountx, ae_int_t basecasey, ae_int_t tiley0, ae_int_t tiley1, ae_int_t tilescounty, ae_int_t maxcoresize, ae_int_t interfacesize, ae_int_t lsqrcnt, double lambdareg, spline1dinterpolant *basis1, ae_shared_pool *pool, spline2dinterpolant *spline, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t kx;
   ae_int_t ky;
   ae_int_t i;
   ae_int_t j;
   ae_int_t j0;
   ae_int_t j1;
   ae_int_t bfrad;
   ae_int_t xa;
   ae_int_t xb;
   ae_int_t ya;
   ae_int_t yb;
   ae_int_t tile0;
   ae_int_t tile1;
   ae_int_t tilesize0;
   ae_int_t tilesize1;
   ae_int_t sfx;
   ae_int_t sfy;
   ae_int_t sfxy;
   double dummytss;
   double invscalexy;
   ae_int_t cnt0;
   ae_int_t cnt1;
   ae_int_t offs;
   double vs;
   double vsx;
   double vsy;
   double vsxy;
   ae_frame_make(_state, &_frame_block);
   RefObj(spline2dfastddmbuf, buf, _state);
// Dataset metrics and fast integrity checks;
// no code with side effects is allowed before parallel split.
   bfrad = 2;
   invscalexy = 1.0 / scalexy;
   kx = basecasex * tilescountx + 1;
   ky = basecasey * tilescounty + 1;
// Parallelism; because this function is intended for
// large-scale problems, we always try to:
// * invoke parallel execution mode
// * activate spawn support
// Parallelism was tried if: true
   if (imax2(tiley1 - tiley0, tilex1 - tilex0, _state) >= 2) {
      if (tiley1 - tiley0 > tilex1 - tilex0) {
      // Split problem in Y dimension
      //
      // NOTE: recursive calls to FastDDMFitLayer() compute
      //       residuals in the inner cells defined by XYIndex[],
      //       but we still have to compute residuals for cells
      //       BETWEEN two recursive subdivisions of the task.
         tiledsplit(tiley1 - tiley0, 1, &j0, &j1, _state);
         spline2d_fastddmfitlayer(xy, d, scalexy, xyindex, basecasex, tilex0, tilex1, tilescountx, basecasey, tiley0, tiley0 + j0, tilescounty, maxcoresize, interfacesize, lsqrcnt, lambdareg, basis1, pool, spline, _state);
         spline2d_fastddmfitlayer(xy, d, scalexy, xyindex, basecasex, tilex0, tilex1, tilescountx, basecasey, tiley0 + j0, tiley1, tilescounty, maxcoresize, interfacesize, lsqrcnt, lambdareg, basis1, pool, spline, _state);
      } else {
      // Split problem in X dimension
      //
      // NOTE: recursive calls to FastDDMFitLayer() compute
      //       residuals in the inner cells defined by XYIndex[],
      //       but we still have to compute residuals for cells
      //       BETWEEN two recursive subdivisions of the task.
         tiledsplit(tilex1 - tilex0, 1, &j0, &j1, _state);
         spline2d_fastddmfitlayer(xy, d, scalexy, xyindex, basecasex, tilex0, tilex0 + j0, tilescountx, basecasey, tiley0, tiley1, tilescounty, maxcoresize, interfacesize, lsqrcnt, lambdareg, basis1, pool, spline, _state);
         spline2d_fastddmfitlayer(xy, d, scalexy, xyindex, basecasex, tilex0 + j0, tilex1, tilescountx, basecasey, tiley0, tiley1, tilescounty, maxcoresize, interfacesize, lsqrcnt, lambdareg, basis1, pool, spline, _state);
      }
      ae_frame_leave(_state);
      return;
   }
   ae_assert(tiley0 == tiley1 - 1, "Spline2DFit.FastDDMFitLayer: integrity check failed", _state);
   ae_assert(tilex0 == tilex1 - 1, "Spline2DFit.FastDDMFitLayer: integrity check failed", _state);
   tile1 = tiley0;
   tile0 = tilex0;
// Retrieve temporaries
   ae_shared_pool_retrieve(pool, &_buf, _state);
// Analyze dataset
   xa = iboundval(tile0 * basecasex - interfacesize, 0, kx, _state);
   xb = iboundval((tile0 + 1) * basecasex + interfacesize, 0, kx, _state);
   ya = iboundval(tile1 * basecasey - interfacesize, 0, ky, _state);
   yb = iboundval((tile1 + 1) * basecasey + interfacesize, 0, ky, _state);
   tilesize0 = xb - xa;
   tilesize1 = yb - ya;
// Solve current chunk with BlockLLS
   dummytss = 1.0;
   spline2d_xdesigngenerate(xy, xyindex, xa, xb, kx, ya, yb, ky, d, lambdareg, 0.0, basis1, &buf->xdesignmatrix, _state);
   spline2d_blockllsfit(&buf->xdesignmatrix, lsqrcnt, &buf->tmpz, &buf->dummyrep, dummytss, &buf->blockllsbuf, _state);
   buf->localmodel.d = d;
   buf->localmodel.m = tilesize1;
   buf->localmodel.n = tilesize0;
   buf->localmodel.stype = -3;
   rvectorsetlengthatleast(&buf->localmodel.x, tilesize0, _state);
   rvectorsetlengthatleast(&buf->localmodel.y, tilesize1, _state);
   rvectorsetlengthatleast(&buf->localmodel.f, tilesize0 * tilesize1 * d * 4, _state);
   for (i = 0; i < tilesize0; i++) {
      buf->localmodel.x.xR[i] = (double)(xa + i);
   }
   for (i = 0; i < tilesize1; i++) {
      buf->localmodel.y.xR[i] = (double)(ya + i);
   }
   for (i = 0; i < tilesize0 * tilesize1 * d * 4; i++) {
      buf->localmodel.f.xR[i] = 0.0;
   }
   spline2d_updatesplinetable(&buf->tmpz, tilesize0, tilesize1, d, basis1, bfrad, &buf->localmodel.f, tilesize1, tilesize0, 1, _state);
// Transform local spline to original coordinates
   sfx = buf->localmodel.n * buf->localmodel.m * d;
   sfy = 2 * buf->localmodel.n * buf->localmodel.m * d;
   sfxy = 3 * buf->localmodel.n * buf->localmodel.m * d;
   for (i = 0; i < tilesize0; i++) {
      buf->localmodel.x.xR[i] *= scalexy;
   }
   for (i = 0; i < tilesize1; i++) {
      buf->localmodel.y.xR[i] *= scalexy;
   }
   for (i = 0; i < tilesize0 * tilesize1 * d; i++) {
      buf->localmodel.f.xR[sfx + i] *= invscalexy;
      buf->localmodel.f.xR[sfy + i] *= invscalexy;
      buf->localmodel.f.xR[sfxy + i] *= invscalexy * invscalexy;
   }
// Output results; for inner and topmost/leftmost tiles we output only BasecaseX*BasecaseY
// inner elements; for rightmost/bottom ones we also output one column/row of the interface
// part.
//
// Such complexity is explained by the fact that area size (by design) is not evenly divisible
// by the tile size; it is divisible with remainder=1, and we expect that interface size is
// at least 1, so we can fill the missing rightmost/bottom elements of Z by the interface
// values.
   ae_assert(interfacesize >= 1, "Spline2DFit: integrity check failed", _state);
   sfx = spline->n * spline->m * d;
   sfy = 2 * spline->n * spline->m * d;
   sfxy = 3 * spline->n * spline->m * d;
   cnt0 = basecasex * scalexy;
   cnt1 = basecasey * scalexy;
   if (tile0 == tilescountx - 1) {
      inc(&cnt0, _state);
   }
   if (tile1 == tilescounty - 1) {
      inc(&cnt1, _state);
   }
   offs = d * (spline->n * tile1 * basecasey * scalexy + tile0 * basecasex * scalexy);
   for (j1 = 0; j1 < cnt1; j1++) {
      for (j0 = 0; j0 < cnt0; j0++) {
         for (j = 0; j < d; j++) {
            spline2ddiffvi(&buf->localmodel, (double)(tile0 * basecasex * scalexy + j0), (double)(tile1 * basecasey * scalexy + j1), j, &vs, &vsx, &vsy, &vsxy, _state);
            spline->f.xR[offs + d * (spline->n * j1 + j0) + j] += vs;
            spline->f.xR[sfx + offs + d * (spline->n * j1 + j0) + j] += vsx;
            spline->f.xR[sfy + offs + d * (spline->n * j1 + j0) + j] += vsy;
            spline->f.xR[sfxy + offs + d * (spline->n * j1 + j0) + j] += vsxy;
         }
      }
   }
// Recycle temporaries
   ae_shared_pool_recycle(pool, &_buf, _state);
   ae_frame_leave(_state);
}

// Recursive workhorse for ComputeResidualsFromScratch.
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_computeresidualsfromscratchrec(RVector *xy, RVector *yraw, ae_int_t pt0, ae_int_t pt1, ae_int_t chunksize, ae_int_t d, ae_int_t scalexy, spline2dinterpolant *spline, ae_shared_pool *pool, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t xew;
   ae_frame_make(_state, &_frame_block);
   RefObj(srealarray, pbuf, _state);
   xew = 2 + d;
// Parallelism
   if (pt1 - pt0 > chunksize) {
      tiledsplit(pt1 - pt0, chunksize, &i, &j, _state);
      spline2d_computeresidualsfromscratchrec(xy, yraw, pt0, pt0 + i, chunksize, d, scalexy, spline, pool, _state);
      spline2d_computeresidualsfromscratchrec(xy, yraw, pt0 + i, pt1, chunksize, d, scalexy, spline, pool, _state);
      ae_frame_leave(_state);
      return;
   }
// Serial execution
   ae_shared_pool_retrieve(pool, &_pbuf, _state);
   for (i = pt0; i < pt1; i++) {
      spline2dcalcvbuf(spline, xy->xR[i * xew + 0] * scalexy, xy->xR[i * xew + 1] * scalexy, &pbuf->val, _state);
      for (j = 0; j < d; j++) {
         xy->xR[i * xew + 2 + j] = yraw->xR[i * d + j] - pbuf->val.xR[j];
      }
   }
   ae_shared_pool_recycle(pool, &_pbuf, _state);
   ae_frame_leave(_state);
}

// This function computes residuals for dataset XY[], using array of original
// values YRaw[], and loads residuals to XY.
//
// Processing is performed in parallel manner.
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_computeresidualsfromscratch(RVector *xy, RVector *yraw, ae_int_t npoints, ae_int_t d, ae_int_t scalexy, spline2dinterpolant *spline, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t chunksize;
   double pointcost;
   ae_frame_make(_state, &_frame_block);
   NewObj(srealarray, seed, _state);
   NewObj(ae_shared_pool, pool, _state);
// Setting up
   chunksize = 1000;
   pointcost = 100.0;
// Parallelism was tried if: npoints * pointcost > smpactivationlevel(_state)
   ae_shared_pool_set_seed(&pool, &seed, sizeof(seed), srealarray_init, srealarray_copy, srealarray_free, _state);
// Call compute workhorse
   spline2d_computeresidualsfromscratchrec(xy, yraw, 0, npoints, chunksize, d, scalexy, spline, &pool, _state);
   ae_frame_leave(_state);
}

// Recurrent divide-and-conquer indexing function
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_reorderdatasetandbuildindexrec(RVector *xy, ae_int_t d, RVector *shadow, ae_int_t ns, ZVector *cidx, ae_int_t pt0, ae_int_t pt1, ZVector *xyindex, ae_int_t idx0, ae_int_t idx1, bool rootcall, ae_state *_state) {
   ae_int_t entrywidth;
   ae_int_t idxmid;
   ae_int_t wrk0;
   ae_int_t wrk1;
   double efficiency;
   double cost;
// Efficiency - performance of the code when compared with that
// of linear algebra code.
   entrywidth = 2 + d;
   efficiency = 0.1;
   cost = d * (pt1 - pt0 + 1) * ae_log((double)(idx1 - idx0 + 1), _state) / ae_log(2.0, _state) / efficiency;
// Parallelism
// Parallelism was tried if: ((rootcall && pt1 - pt0 > 10000) && idx1 - idx0 >= 2) && cost > smpactivationlevel(_state)
// Store left bound to XYIndex
   xyindex->xZ[idx0] = pt0;
// Quick exit strategies
   if (idx1 <= idx0 + 1) {
      return;
   }
   if (pt0 == pt1) {
      for (idxmid = idx0 + 1; idxmid < idx1; idxmid++) {
         xyindex->xZ[idxmid] = pt1;
      }
      return;
   }
// Select middle element
   idxmid = idx0 + (idx1 - idx0) / 2;
   ae_assert(idx0 < idxmid && idxmid < idx1, "Spline2D: integrity check failed", _state);
   wrk0 = pt0;
   wrk1 = pt1 - 1;
   while (true) {
      while (wrk0 < pt1 && cidx->xZ[wrk0] < idxmid) {
         wrk0++;
      }
      while (wrk1 >= pt0 && cidx->xZ[wrk1] >= idxmid) {
         wrk1--;
      }
      if (wrk1 <= wrk0) {
         break;
      }
      swapentries(xy, wrk0, wrk1, entrywidth, _state);
      if (ns > 0) {
         swapentries(shadow, wrk0, wrk1, ns, _state);
      }
      swapelementsi(cidx, wrk0, wrk1, _state);
   }
   spline2d_reorderdatasetandbuildindexrec(xy, d, shadow, ns, cidx, pt0, wrk0, xyindex, idx0, idxmid, false, _state);
   spline2d_reorderdatasetandbuildindexrec(xy, d, shadow, ns, cidx, wrk0, pt1, xyindex, idxmid, idx1, false, _state);
}

// This function reorders dataset and builds index:
// * it is assumed that all points have X in [0,KX-1], Y in [0,KY-1]
// * area is divided into (KX-1)*(KY-1) cells
// * all points are reordered in such way that points in same cell are stored
//   contiguously
// * dataset index, array[(KX-1)*(KY-1)+1], is generated. Points of cell I
//   now have indexes XYIndex[I]..XYIndex[I+1]-1;
//
// Inputs:
//     XY              -   array[NPoints*(2+D)], dataset
//     KX, KY, D       -   grid size and dimensionality of the outputs
//     Shadow          -   shadow array[NPoints*NS], which is sorted together
//                         with XY; if NS=0, it is not referenced at all.
//     NS              -   entry width of shadow array
//     BufI            -   possibly preallocated temporary buffer; resized if
//                         needed.
//
// Outputs:
//     XY              -   reordered
//     XYIndex         -   array[(KX-1)*(KY-1)+1], dataset index
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_reorderdatasetandbuildindex(RVector *xy, ae_int_t npoints, ae_int_t d, RVector *shadow, ae_int_t ns, ae_int_t kx, ae_int_t ky, ZVector *xyindex, ZVector *bufi, ae_state *_state) {
   ae_int_t i;
   ae_int_t i0;
   ae_int_t i1;
   ae_int_t entrywidth;
// Set up
   ae_assert(kx >= 2, "Spline2DFit.ReorderDatasetAndBuildIndex: integrity check failed", _state);
   ae_assert(ky >= 2, "Spline2DFit.ReorderDatasetAndBuildIndex: integrity check failed", _state);
   entrywidth = 2 + d;
   ivectorsetlengthatleast(xyindex, (kx - 1) * (ky - 1) + 1, _state);
   ivectorsetlengthatleast(bufi, npoints, _state);
   for (i = 0; i < npoints; i++) {
      i0 = iboundval(ifloor(xy->xR[i * entrywidth + 0], _state), 0, kx - 2, _state);
      i1 = iboundval(ifloor(xy->xR[i * entrywidth + 1], _state), 0, ky - 2, _state);
      bufi->xZ[i] = i1 * (kx - 1) + i0;
   }
// Reorder
   spline2d_reorderdatasetandbuildindexrec(xy, d, shadow, ns, bufi, 0, npoints, xyindex, 0, (kx - 1) * (ky - 1), true, _state);
   xyindex->xZ[(kx - 1) * (ky - 1)] = npoints;
}

// Recurrent divide-and-conquer indexing function
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_expandindexrows(RVector *xy, ae_int_t d, RVector *shadow, ae_int_t ns, ZVector *cidx, ae_int_t pt0, ae_int_t pt1, ZVector *xyindexprev, ae_int_t row0, ae_int_t row1, ZVector *xyindexnew, ae_int_t kxnew, ae_int_t kynew, bool rootcall, ae_state *_state) {
   ae_int_t i;
   ae_int_t entrywidth;
   ae_int_t kxprev;
   double v;
   ae_int_t i0;
   ae_int_t i1;
   double efficiency;
   double cost;
   ae_int_t rowmid;
   kxprev = (kxnew + 1) / 2;
   entrywidth = 2 + d;
   efficiency = 0.1;
   cost = d * (pt1 - pt0 + 1) * (ae_log((double)kxnew, _state) / ae_log(2.0, _state)) / efficiency;
   ae_assert(xyindexprev->xZ[row0 * (kxprev - 1) + 0] == pt0, "Spline2DFit.ExpandIndexRows: integrity check failed", _state);
   ae_assert(xyindexprev->xZ[row1 * (kxprev - 1) + 0] == pt1, "Spline2DFit.ExpandIndexRows: integrity check failed", _state);
// Parallelism
// Parallelism was tried if: ((rootcall && pt1 - pt0 > 10000) && row1 - row0 >= 2) && cost > smpactivationlevel(_state)
// Partition
   if (row1 - row0 >= 2) {
      tiledsplit(row1 - row0, 1, &i0, &i1, _state);
      rowmid = row0 + i0;
      spline2d_expandindexrows(xy, d, shadow, ns, cidx, pt0, xyindexprev->xZ[rowmid * (kxprev - 1) + 0], xyindexprev, row0, rowmid, xyindexnew, kxnew, kynew, false, _state);
      spline2d_expandindexrows(xy, d, shadow, ns, cidx, xyindexprev->xZ[rowmid * (kxprev - 1) + 0], pt1, xyindexprev, rowmid, row1, xyindexnew, kxnew, kynew, false, _state);
      return;
   }
// Serial execution
   for (i = pt0; i < pt1; i++) {
      v = 2 * xy->xR[i * entrywidth + 0];
      xy->xR[i * entrywidth + 0] = v;
      i0 = iboundval(ifloor(v, _state), 0, kxnew - 2, _state);
      v = 2 * xy->xR[i * entrywidth + 1];
      xy->xR[i * entrywidth + 1] = v;
      i1 = iboundval(ifloor(v, _state), 0, kynew - 2, _state);
      cidx->xZ[i] = i1 * (kxnew - 1) + i0;
   }
   spline2d_reorderdatasetandbuildindexrec(xy, d, shadow, ns, cidx, pt0, pt1, xyindexnew, 2 * row0 * (kxnew - 1) + 0, 2 * row1 * (kxnew - 1) + 0, false, _state);
}

// This function multiplies all points in dataset by 2.0 and rebuilds  index,
// given previous index built for KX_prev=(KX-1)/2 and KY_prev=(KY-1)/2
//
// Inputs:
//     XY              -   array[NPoints*(2+D)], dataset BEFORE scaling
//     NPoints, D      -   dataset size and dimensionality of the outputs
//     Shadow          -   shadow array[NPoints*NS], which is sorted together
//                         with XY; if NS=0, it is not referenced at all.
//     NS              -   entry width of shadow array
//     KX, KY          -   new grid dimensionality
//     XYIndex         -   index built for previous values of KX and KY
//     BufI            -   possibly preallocated temporary buffer; resized if
//                         needed.
//
// Outputs:
//     XY              -   reordered and multiplied by 2.0
//     XYIndex         -   array[(KX-1)*(KY-1)+1], dataset index
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_rescaledatasetandrefineindex(RVector *xy, ae_int_t npoints, ae_int_t d, RVector *shadow, ae_int_t ns, ae_int_t kx, ae_int_t ky, ZVector *xyindex, ZVector *bufi, ae_state *_state) {
   ae_frame _frame_block;
   ae_frame_make(_state, &_frame_block);
   NewVector(xyindexprev, 0, DT_INT, _state);
// Set up
   ae_assert(kx >= 2, "Spline2DFit.RescaleDataset2AndRefineIndex: integrity check failed", _state);
   ae_assert(ky >= 2, "Spline2DFit.RescaleDataset2AndRefineIndex: integrity check failed", _state);
   ae_assert((kx - 1) % 2 == 0, "Spline2DFit.RescaleDataset2AndRefineIndex: integrity check failed", _state);
   ae_assert((ky - 1) % 2 == 0, "Spline2DFit.RescaleDataset2AndRefineIndex: integrity check failed", _state);
   ae_swap_vectors(xyindex, &xyindexprev);
   ivectorsetlengthatleast(xyindex, (kx - 1) * (ky - 1) + 1, _state);
   ivectorsetlengthatleast(bufi, npoints, _state);
// Refine
   spline2d_expandindexrows(xy, d, shadow, ns, bufi, 0, npoints, &xyindexprev, 0, (ky + 1) / 2 - 1, xyindex, kx, ky, true, _state);
   xyindex->xZ[(kx - 1) * (ky - 1)] = npoints;
// Integrity check
   ae_frame_leave(_state);
}

// This function performs fitting with FastDDM solver.
// Internal function, never use it directly.
//
// Inputs:
//     XY          -   array[NPoints*(2+D)], dataset; destroyed in process
//     KX, KY      -   grid size
//     TileSize    -   tile size
//     InterfaceSize-  interface size
//     NPoints     -   points count
//     D           -   number of components in vector-valued spline, D >= 1
//     LSQRCnt     -   number of iterations, non-zero:
//                     * LSQRCnt>0 means that specified amount of  preconditioned
//                       LSQR  iterations  will  be  performed  to solve problem;
//                       usually  we  need  2..5  its.  Recommended option - best
//                       convergence and stability/quality.
//                     * LSQRCnt<0 means that instead of LSQR  we  use  iterative
//                       refinement on normal equations. Again, 2..5 its is enough.
//     Basis1      -   basis spline, expected to be non-zero only at [-2,+2]
//     Z           -   possibly preallocated buffer for solution
//     Residuals   -   possibly preallocated buffer for residuals at dataset points
//     Rep         -   report structure; fields which are not set by this function
//                     are left intact
//     TSS         -   total sum of squares; used to calculate R2
//
//
// Outputs:
//     XY          -   destroyed in process
//     Z           -   array[KX*KY*D], filled by solution; KX*KY coefficients
//                     corresponding to each of D dimensions are stored contiguously.
//     Rep         -   following fields are set:
//                     * Rep.RMSError
//                     * Rep.AvgError
//                     * Rep.MaxError
//                     * Rep.R2
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_fastddmfit(RVector *xy, ae_int_t npoints, ae_int_t d, ae_int_t kx, ae_int_t ky, ae_int_t basecasex, ae_int_t basecasey, ae_int_t maxcoresize, ae_int_t interfacesize, ae_int_t nlayers, double smoothing, ae_int_t lsqrcnt, spline1dinterpolant *basis1, spline2dinterpolant *spline, spline2dfitreport *rep, double tss, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t nzwidth;
   ae_int_t xew;
   ae_int_t ntotallayers;
   ae_int_t scaleidx;
   ae_int_t scalexy;
   double invscalexy;
   ae_int_t kxcur;
   ae_int_t kycur;
   ae_int_t tilescount0;
   ae_int_t tilescount1;
   double v;
   double rss;
   ae_frame_make(_state, &_frame_block);
   NewVector(yraw, 0, DT_REAL, _state);
   NewVector(xyindex, 0, DT_INT, _state);
   NewVector(tmp0, 0, DT_REAL, _state);
   NewVector(bufi, 0, DT_INT, _state);
   NewObj(spline2dfastddmbuf, seed, _state);
   NewObj(ae_shared_pool, pool, _state);
   NewObj(spline2dxdesignmatrix, xdesignmatrix, _state);
   NewObj(spline2dblockllsbuf, blockllsbuf, _state);
   NewObj(spline2dfitreport, dummyrep, _state);
// Dataset metrics and integrity checks
   nzwidth = 4;
   xew = 2 + d;
   ae_assert(maxcoresize >= 2, "Spline2DFit: integrity check failed", _state);
   ae_assert(interfacesize >= 1, "Spline2DFit: integrity check failed", _state);
   ae_assert(kx >= nzwidth, "Spline2DFit: integrity check failed", _state);
   ae_assert(ky >= nzwidth, "Spline2DFit: integrity check failed", _state);
// Verify consistency of the grid size (KX,KY) with basecase sizes.
// Determine full number of layers.
   ae_assert(basecasex <= maxcoresize, "Spline2DFit: integrity error", _state);
   ae_assert(basecasey <= maxcoresize, "Spline2DFit: integrity error", _state);
   ntotallayers = 1;
   scalexy = 1;
   kxcur = kx;
   kycur = ky;
   while (kxcur > basecasex + 1 && kycur > basecasey + 1) {
      ae_assert(kxcur % 2 == 1, "Spline2DFit: integrity error", _state);
      ae_assert(kycur % 2 == 1, "Spline2DFit: integrity error", _state);
      kxcur = (kxcur - 1) / 2 + 1;
      kycur = (kycur - 1) / 2 + 1;
      scalexy *= 2;
      inc(&ntotallayers, _state);
   }
   invscalexy = 1.0 / scalexy;
   ae_assert((kxcur <= maxcoresize + 1 && kxcur == basecasex + 1) || kxcur % basecasex == 1, "Spline2DFit: integrity error", _state);
   ae_assert((kycur <= maxcoresize + 1 && kycur == basecasey + 1) || kycur % basecasey == 1, "Spline2DFit: integrity error", _state);
   ae_assert(kxcur == basecasex + 1 || kycur == basecasey + 1, "Spline2DFit: integrity error", _state);
// Initial scaling of dataset.
// Store original target values to YRaw.
   rvectorsetlengthatleast(&yraw, npoints * d, _state);
   for (i = 0; i < npoints; i++) {
      xy->xR[xew * i + 0] *= invscalexy;
      xy->xR[xew * i + 1] *= invscalexy;
      for (j = 0; j < d; j++) {
         yraw.xR[i * d + j] = xy->xR[xew * i + 2 + j];
      }
   }
   kxcur = (kx - 1) / scalexy + 1;
   kycur = (ky - 1) / scalexy + 1;
// Build initial dataset index; area is divided into (KXCur-1)*(KYCur-1)
// cells, with contiguous storage of points in the same cell.
// Iterate over different scales
   ae_shared_pool_set_seed(&pool, &seed, sizeof(seed), spline2dfastddmbuf_init, spline2dfastddmbuf_copy, spline2dfastddmbuf_free, _state);
   spline2d_reorderdatasetandbuildindex(xy, npoints, d, &yraw, d, kxcur, kycur, &xyindex, &bufi, _state);
   for (scaleidx = ntotallayers - 1; scaleidx >= 0; scaleidx--) {
      if ((nlayers > 0 && scaleidx < nlayers) || (nlayers <= 0 && scaleidx < imax2(ntotallayers + nlayers, 1, _state))) {
      // Fit current layer
         ae_assert(kxcur % basecasex == 1, "Spline2DFit: integrity error", _state);
         ae_assert(kycur % basecasey == 1, "Spline2DFit: integrity error", _state);
         tilescount0 = kxcur / basecasex;
         tilescount1 = kycur / basecasey;
         spline2d_fastddmfitlayer(xy, d, scalexy, &xyindex, basecasex, 0, tilescount0, tilescount0, basecasey, 0, tilescount1, tilescount1, maxcoresize, interfacesize, lsqrcnt, spline2d_lambdaregfastddm + smoothing * ae_pow(spline2d_lambdadecay, (double)scaleidx, _state), basis1, &pool, spline, _state);
      // Compute residuals and update XY
         spline2d_computeresidualsfromscratch(xy, &yraw, npoints, d, scalexy, spline, _state);
      }
   // Move to the next level
      if (scaleidx != 0) {
      // Transform dataset (multply everything by 2.0) and refine grid.
         kxcur = 2 * kxcur - 1;
         kycur = 2 * kycur - 1;
         scalexy /= 2;
         invscalexy = 1.0 / scalexy;
         spline2d_rescaledatasetandrefineindex(xy, npoints, d, &yraw, d, kxcur, kycur, &xyindex, &bufi, _state);
      // Clear temporaries from previous round.
      //
      // We have to do it because upper layer of the multilevel spline
      // needs more memory then subsequent layers, and we want to free
      // this memory as soon as possible.
         ae_shared_pool_clear_recycled(&pool, true, _state);
      }
   }
// Post-check
   ae_assert(kxcur == kx, "Spline2DFit: integrity check failed", _state);
   ae_assert(kycur == ky, "Spline2DFit: integrity check failed", _state);
   ae_assert(scalexy == 1, "Spline2DFit: integrity check failed", _state);
// Report
   rep->rmserror = 0.0;
   rep->avgerror = 0.0;
   rep->maxerror = 0.0;
   rss = 0.0;
   for (i = 0; i < npoints; i++) {
      for (j = 0; j < d; j++) {
         v = xy->xR[i * xew + 2 + j];
         rss += v * v;
         rep->rmserror += sqr(v, _state);
         rep->avgerror += ae_fabs(v, _state);
         rep->maxerror = maxreal(rep->maxerror, ae_fabs(v, _state), _state);
      }
   }
   rep->rmserror = ae_sqrt(rep->rmserror / coalesce((double)(npoints * d), 1.0, _state), _state);
   rep->avgerror /= coalesce((double)(npoints * d), 1.0, _state);
   rep->r2 = 1.0 - rss / coalesce(tss, 1.0, _state);
   ae_frame_leave(_state);
}

// This function performs fitting with  NaiveLLS solver.  Internal  function,
// never use it directly.
//
// Inputs:
//     AV      -   sparse matrix, [ARows,KX*KY] in size.  "Vertical"  version
//                 of design matrix, rows [0,NPoints] contain values of basis
//                 functions at dataset  points.  Other  rows  are  used  for
//                 nonlinearity penalty and other stuff like that.
//     AH      -   transpose(AV), "horizontal" version of AV
//     ARows   -   rows count
//     XY      -   array[NPoints*(2+D)], dataset
//     KX, KY  -   grid size
//     NPoints -   points count
//     D       -   number of components in vector-valued spline, D >= 1
//     LSQRCnt -   number of iterations, non-zero:
//                 * LSQRCnt>0 means that specified amount of  preconditioned
//                   LSQR  iterations  will  be  performed  to solve problem;
//                   usually  we  need  2..5  its.  Recommended option - best
//                   convergence and stability/quality.
//                 * LSQRCnt<0 means that instead of LSQR  we  use  iterative
//                   refinement on normal equations. Again, 2..5 its is enough.
//     Z       -   possibly preallocated buffer for solution
//     Rep     -   report structure; fields which are not set by this function
//                 are left intact
//     TSS     -   total sum of squares; used to calculate R2
//
//
// Outputs:
//     XY      -   destroyed in process
//     Z       -   array[KX*KY*D], filled by solution; KX*KY coefficients
//                 corresponding to each of D dimensions are stored contiguously.
//     Rep     -   following fields are set:
//                     * Rep.RMSError
//                     * Rep.AvgError
//                     * Rep.MaxError
//                     * Rep.R2
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
static void spline2d_naivellsfit(sparsematrix *av, sparsematrix *ah, ae_int_t arows, RVector *xy, ae_int_t kx, ae_int_t ky, ae_int_t npoints, ae_int_t d, ae_int_t lsqrcnt, RVector *z, spline2dfitreport *rep, double tss, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t ew;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i0;
   ae_int_t i1;
   ae_int_t j0;
   ae_int_t j1;
   double v;
   ae_int_t blockbandwidth;
   double lambdareg;
   ae_int_t srci;
   ae_int_t srcj;
   ae_int_t idxi;
   ae_int_t idxj;
   ae_int_t endi;
   ae_int_t endj;
   ae_int_t rfsidx;
   double mxata;
   double rss;
   ae_frame_make(_state, &_frame_block);
   NewMatrix(ata, 0, 0, DT_REAL, _state);
   NewVector(tmp0, 0, DT_REAL, _state);
   NewVector(tmp1, 0, DT_REAL, _state);
   NewObj(linlsqrstate, solver, _state);
   NewObj(linlsqrreport, solverrep, _state);
   blockbandwidth = 3;
   ew = 2 + d;
// Initial values for Z/Residuals
   rvectorsetlengthatleast(z, kx * ky * d, _state);
   for (i = 0; i < kx * ky * d; i++) {
      z->xR[i] = 0.0;
   }
// Create and factorize design matrix.
//
// Add regularizer if factorization failed (happens sometimes
// with zero smoothing and sparsely populated datasets).
   lambdareg = spline2d_cholreg;
   rmatrixsetlengthatleast(&ata, kx * ky, kx * ky, _state);
   while (true) {
      mxata = 0.0;
      for (i = 0; i < kx * ky; i++) {
         for (j = i; j < kx * ky; j++) {
         // Initialize by zero
            ata.xyR[i][j] = 0.0;
         // Determine grid nodes corresponding to I and J;
         // skip if too far away
            i0 = i % kx;
            i1 = i / kx;
            j0 = j % kx;
            j1 = j / kx;
            if (ae_iabs(i0 - j0, _state) > blockbandwidth || ae_iabs(i1 - j1, _state) > blockbandwidth) {
               continue;
            }
         // Nodes are close enough, calculate product of columns I and J of A.
            v = 0.0;
            srci = ah->ridx.xZ[i];
            srcj = ah->ridx.xZ[j];
            endi = ah->ridx.xZ[i + 1];
            endj = ah->ridx.xZ[j + 1];
            while (true) {
               if (srci >= endi || srcj >= endj) {
                  break;
               }
               idxi = ah->idx.xZ[srci];
               idxj = ah->idx.xZ[srcj];
               if (idxi == idxj) {
                  v += ah->vals.xR[srci] * ah->vals.xR[srcj];
                  srci++;
                  srcj++;
                  continue;
               }
               if (idxi < idxj) {
                  srci++;
               } else {
                  srcj++;
               }
            }
            ata.xyR[i][j] = v;
            mxata = maxreal(mxata, ae_fabs(v, _state), _state);
         }
      }
      v = coalesce(mxata, 1.0, _state) * lambdareg;
      for (i = 0; i < kx * ky; i++) {
         ata.xyR[i][i] += v;
      }
      if (spdmatrixcholesky(&ata, kx * ky, true, _state)) {
      // Success!
         break;
      }
   // Factorization failed, increase regularizer and repeat
      lambdareg = coalesce(10 * lambdareg, 1.0E-12, _state);
   }
// Solve
//
// NOTE: we expect that Z is zero-filled, and we treat it
//       like initial approximation to solution.
   rvectorsetlengthatleast(&tmp0, arows, _state);
   rvectorsetlengthatleast(&tmp1, kx * ky, _state);
   if (lsqrcnt > 0) {
      linlsqrcreate(arows, kx * ky, &solver, _state);
   }
   for (j = 0; j < d; j++) {
      ae_assert(lsqrcnt != 0, "Spline2DFit: integrity failure", _state);
      if (lsqrcnt > 0) {
      // Preconditioned LSQR:
      //
      // use Cholesky factor U of squared design matrix A'*A to
      // transform min|A*x-b| to min|[A*inv(U)]*y-b| with y=U*x.
      //
      // Preconditioned problem is solved with LSQR solver, which
      // gives superior results than normal equations.
         linlsqrcreate(arows, kx * ky, &solver, _state);
         for (i = 0; i < arows; i++) {
            if (i < npoints) {
               tmp0.xR[i] = xy->xR[i * ew + 2 + j];
            } else {
               tmp0.xR[i] = 0.0;
            }
         }
         linlsqrsetb(&solver, &tmp0, _state);
         linlsqrsetcond(&solver, 1.0E-14, 1.0E-14, lsqrcnt, _state);
         while (linlsqriteration(&solver, _state)) {
            if (solver.needmv) {
            // Use Cholesky factorization of the system matrix
            // as preconditioner: solve TRSV(U,Solver.X)
               for (i = 0; i < kx * ky; i++) {
                  tmp1.xR[i] = solver.x.xR[i];
               }
               rmatrixtrsv(kx * ky, &ata, 0, 0, true, false, 0, &tmp1, 0, _state);
            // After preconditioning is done, multiply by A
               sparsemv(av, &tmp1, &solver.mv, _state);
            }
            if (solver.needmtv) {
            // Multiply by design matrix A
               sparsemv(ah, &solver.x, &solver.mtv, _state);
            // Multiply by preconditioner: solve TRSV(U',A*Solver.X)
               rmatrixtrsv(kx * ky, &ata, 0, 0, true, false, 1, &solver.mtv, 0, _state);
            }
         }
         linlsqrresults(&solver, &tmp1, &solverrep, _state);
         rmatrixtrsv(kx * ky, &ata, 0, 0, true, false, 0, &tmp1, 0, _state);
         for (i = 0; i < kx * ky; i++) {
            z->xR[kx * ky * j + i] = tmp1.xR[i];
         }
      // Calculate model values
         sparsemv(av, &tmp1, &tmp0, _state);
         for (i = 0; i < npoints; i++) {
            xy->xR[i * ew + 2 + j] -= tmp0.xR[i];
         }
      } else {
      // Iterative refinement, inferior to LSQR
      //
      // For each dimension D:
      // * fetch current estimate for solution from Z to Tmp1
      // * calculate residual r for current estimate, store in Tmp0
      // * calculate product of residual and design matrix A'*r, store it in Tmp1
      // * Cholesky solver
      // * update current estimate
         for (rfsidx = 1; rfsidx <= -lsqrcnt; rfsidx++) {
            for (i = 0; i < kx * ky; i++) {
               tmp1.xR[i] = z->xR[kx * ky * j + i];
            }
            sparsemv(av, &tmp1, &tmp0, _state);
            for (i = 0; i < arows; i++) {
               if (i < npoints) {
                  v = xy->xR[i * ew + 2 + j];
               } else {
                  v = 0.0;
               }
               tmp0.xR[i] = v - tmp0.xR[i];
            }
            sparsemv(ah, &tmp0, &tmp1, _state);
            rmatrixtrsv(kx * ky, &ata, 0, 0, true, false, 1, &tmp1, 0, _state);
            rmatrixtrsv(kx * ky, &ata, 0, 0, true, false, 0, &tmp1, 0, _state);
            for (i = 0; i < kx * ky; i++) {
               z->xR[kx * ky * j + i] += tmp1.xR[i];
            }
         }
      // Calculate model values
         for (i = 0; i < kx * ky; i++) {
            tmp1.xR[i] = z->xR[kx * ky * j + i];
         }
         sparsemv(av, &tmp1, &tmp0, _state);
         for (i = 0; i < npoints; i++) {
            xy->xR[i * ew + 2 + j] -= tmp0.xR[i];
         }
      }
   }
// Generate report
   rep->rmserror = 0.0;
   rep->avgerror = 0.0;
   rep->maxerror = 0.0;
   rss = 0.0;
   for (i = 0; i < npoints; i++) {
      for (j = 0; j < d; j++) {
         v = xy->xR[i * ew + 2 + j];
         rss += v * v;
         rep->rmserror += sqr(v, _state);
         rep->avgerror += ae_fabs(v, _state);
         rep->maxerror = maxreal(rep->maxerror, ae_fabs(v, _state), _state);
      }
   }
   rep->rmserror = ae_sqrt(rep->rmserror / coalesce((double)(npoints * d), 1.0, _state), _state);
   rep->avgerror /= coalesce((double)(npoints * d), 1.0, _state);
   rep->r2 = 1.0 - rss / coalesce(tss, 1.0, _state);
   ae_frame_leave(_state);
}

// This function fits bicubic spline to current dataset, using current  area/
// grid and current LLS solver.
//
// Inputs:
//     State   -   spline 2D builder object
//
// Outputs:
//     S       -   2D spline, fit result
//     Rep     -   fitting report, which provides some additional info  about
//                 errors, R2 coefficient and so on.
// ALGLIB: Copyright 05.02.2018 by Sergey Bochkanov
// API: void spline2dfit(const spline2dbuilder &state, spline2dinterpolant &s, spline2dfitreport &rep, const xparams _xparams = xdefault);
void spline2dfit(spline2dbuilder *state, spline2dinterpolant *s, spline2dfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   double xa;
   double xb;
   double ya;
   double yb;
   double xaraw;
   double xbraw;
   double yaraw;
   double ybraw;
   ae_int_t kx;
   ae_int_t ky;
   double hx;
   double hy;
   double invhx;
   double invhy;
   ae_int_t gridexpansion;
   ae_int_t nzwidth;
   ae_int_t bfrad;
   ae_int_t npoints;
   ae_int_t d;
   ae_int_t ew;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_int_t k0;
   ae_int_t k1;
   double vx;
   double vy;
   ae_int_t arows;
   ae_int_t acopied;
   ae_int_t basecasex;
   ae_int_t basecasey;
   double eps;
   ae_int_t sfx;
   ae_int_t sfy;
   ae_int_t sfxy;
   double tss;
   ae_int_t dstidx;
   ae_frame_make(_state, &_frame_block);
   SetObj(spline2dinterpolant, s);
   SetObj(spline2dfitreport, rep);
   NewVector(xywork, 0, DT_REAL, _state);
   NewMatrix(vterm, 0, 0, DT_REAL, _state);
   NewVector(tmpx, 0, DT_REAL, _state);
   NewVector(tmpy, 0, DT_REAL, _state);
   NewVector(tmp0, 0, DT_REAL, _state);
   NewVector(tmp1, 0, DT_REAL, _state);
   NewVector(meany, 0, DT_REAL, _state);
   NewVector(xyindex, 0, DT_INT, _state);
   NewVector(tmpi, 0, DT_INT, _state);
   NewObj(spline1dinterpolant, basis1, _state);
   NewObj(sparsematrix, av, _state);
   NewObj(sparsematrix, ah, _state);
   NewObj(spline2dxdesignmatrix, xdesignmatrix, _state);
   NewVector(z, 0, DT_REAL, _state);
   NewObj(spline2dblockllsbuf, blockllsbuf, _state);
   nzwidth = 4;
   bfrad = 2;
   npoints = state->npoints;
   d = state->d;
   ew = 2 + d;
// Integrity checks
   ae_assert(state->sx == 1.0, "Spline2DFit: integrity error", _state);
   ae_assert(state->sy == 1.0, "Spline2DFit: integrity error", _state);
// Determine actual area size and grid step
//
// NOTE: initialize vars by zeros in order to avoid spurious
//       compiler warnings.
   xa = 0.0;
   xb = 0.0;
   ya = 0.0;
   yb = 0.0;
   if (state->areatype == 0) {
      if (npoints > 0) {
         xa = state->xy.xR[0];
         xb = state->xy.xR[0];
         ya = state->xy.xR[1];
         yb = state->xy.xR[1];
         for (i = 1; i < npoints; i++) {
            xa = minreal(xa, state->xy.xR[i * ew + 0], _state);
            xb = maxreal(xb, state->xy.xR[i * ew + 0], _state);
            ya = minreal(ya, state->xy.xR[i * ew + 1], _state);
            yb = maxreal(yb, state->xy.xR[i * ew + 1], _state);
         }
      } else {
         xa = -1.0;
         xb = 1.0;
         ya = -1.0;
         yb = 1.0;
      }
   } else {
      if (state->areatype == 1) {
         xa = state->xa;
         xb = state->xb;
         ya = state->ya;
         yb = state->yb;
      } else {
         ae_assert(false, "Assertion failed", _state);
      }
   }
   if (xa == xb) {
      v = xa;
      if (v >= 0.0) {
         xa = v / 2 - 1;
         xb = v * 2 + 1;
      } else {
         xa = v * 2 - 1;
         xb = v / 2 + 1;
      }
   }
   if (ya == yb) {
      v = ya;
      if (v >= 0.0) {
         ya = v / 2 - 1;
         yb = v * 2 + 1;
      } else {
         ya = v * 2 - 1;
         yb = v / 2 + 1;
      }
   }
   ae_assert(xa < xb, "Spline2DFit: integrity error", _state);
   ae_assert(ya < yb, "Spline2DFit: integrity error", _state);
   kx = 0;
   ky = 0;
   if (state->gridtype == 0) {
      kx = 4;
      ky = 4;
   } else {
      if (state->gridtype == 1) {
         kx = state->kx;
         ky = state->ky;
      } else {
         ae_assert(false, "Assertion failed", _state);
      }
   }
   ae_assert(kx > 0, "Spline2DFit: integrity error", _state);
   ae_assert(ky > 0, "Spline2DFit: integrity error", _state);
   basecasex = -1;
   basecasey = -1;
   if (state->solvertype == 3) {
   // Large-scale solver with special requirements to grid size.
      kx = maxint(kx, nzwidth, _state);
      ky = maxint(ky, nzwidth, _state);
      k = 1;
      while (imin2(kx, ky, _state) > state->maxcoresize + 1) {
         kx = idivup(kx - 1, 2, _state) + 1;
         ky = idivup(ky - 1, 2, _state) + 1;
         k++;
      }
      basecasex = kx - 1;
      k0 = 1;
      while (kx > state->maxcoresize + 1) {
         basecasex = idivup(kx - 1, 2, _state);
         kx = basecasex + 1;
         k0++;
      }
      while (k0 > 1) {
         kx = (kx - 1) * 2 + 1;
         k0--;
      }
      basecasey = ky - 1;
      k1 = 1;
      while (ky > state->maxcoresize + 1) {
         basecasey = idivup(ky - 1, 2, _state);
         ky = basecasey + 1;
         k1++;
      }
      while (k1 > 1) {
         ky = (ky - 1) * 2 + 1;
         k1--;
      }
      while (k > 1) {
         kx = (kx - 1) * 2 + 1;
         ky = (ky - 1) * 2 + 1;
         k--;
      }
   // Grid is NOT expanded. We have very strict requirements on
   // grid size, and we do not want to overcomplicate it by
   // playing with grid size in order to add one more degree of
   // freedom. It is not relevant for such large tasks.
      gridexpansion = 0;
   } else {
   // Medium-scale solvers which are tolerant to grid size.
      kx = maxint(kx, nzwidth, _state);
      ky = maxint(ky, nzwidth, _state);
   // Grid is expanded by 1 in order to add one more effective degree
   // of freedom to the spline. Having additional nodes outside of the
   // area allows us to emulate changes in the derivative at the bound
   // without having specialized "boundary" version of the basis function.
      if (state->adddegreeoffreedom) {
         gridexpansion = 1;
      } else {
         gridexpansion = 0;
      }
   }
   hx = coalesce(xb - xa, 1.0, _state) / (kx - 1);
   hy = coalesce(yb - ya, 1.0, _state) / (ky - 1);
   invhx = 1 / hx;
   invhy = 1 / hy;
// We determined "raw" grid size. Now perform a grid correction according
// to current grid expansion size.
   xaraw = xa;
   yaraw = ya;
   xbraw = xb;
   ybraw = yb;
   xa -= hx * gridexpansion;
   ya -= hy * gridexpansion;
   xb += hx * gridexpansion;
   yb += hy * gridexpansion;
   kx += 2 * gridexpansion;
   ky += 2 * gridexpansion;
// Create output spline using transformed (unit-scale)
// coordinates, fill by zero values
   s->d = d;
   s->n = kx;
   s->m = ky;
   s->stype = -3;
   sfx = s->n * s->m * d;
   sfy = 2 * s->n * s->m * d;
   sfxy = 3 * s->n * s->m * d;
   ae_vector_set_length(&s->x, s->n, _state);
   ae_vector_set_length(&s->y, s->m, _state);
   ae_vector_set_length(&s->f, 4 * s->n * s->m * d, _state);
   for (i = 0; i < s->n; i++) {
      s->x.xR[i] = (double)i;
   }
   for (i = 0; i < s->m; i++) {
      s->y.xR[i] = (double)i;
   }
   for (i = 0; i < 4 * s->n * s->m * d; i++) {
      s->f.xR[i] = 0.0;
   }
// Create local copy of dataset (only points in the grid are copied;
// we allow small step out of the grid, by Eps*H, in order to deal
// with numerical rounding errors).
//
// An additional copy of Y-values is created at columns beyond 2+J;
// it is preserved during all transformations. This copy is used
// to calculate error-related metrics.
//
// Calculate mean(Y), TSS
   ae_vector_set_length(&meany, d, _state);
   for (j = 0; j < d; j++) {
      meany.xR[j] = 0.0;
   }
   rvectorsetlengthatleast(&xywork, npoints * ew, _state);
   acopied = 0;
   eps = 1.0E-6;
   for (i = 0; i < npoints; i++) {
      vx = state->xy.xR[i * ew + 0];
      vy = state->xy.xR[i * ew + 1];
      if (((xaraw - eps * hx <= vx && vx <= xbraw + eps * hx) && yaraw - eps * hy <= vy) && vy <= ybraw + eps * hy) {
         xywork.xR[acopied * ew + 0] = (vx - xa) * invhx;
         xywork.xR[acopied * ew + 1] = (vy - ya) * invhy;
         for (j = 0; j < d; j++) {
            v = state->xy.xR[i * ew + 2 + j];
            xywork.xR[acopied * ew + 2 + j] = v;
            meany.xR[j] += v;
         }
         acopied++;
      }
   }
   npoints = acopied;
   for (j = 0; j < d; j++) {
      meany.xR[j] /= coalesce((double)npoints, 1.0, _state);
   }
   tss = 0.0;
   for (i = 0; i < npoints; i++) {
      for (j = 0; j < d; j++) {
         tss += sqr(xywork.xR[i * ew + 2 + j] - meany.xR[j], _state);
      }
   }
   tss = coalesce(tss, 1.0, _state);
// Handle prior term.
// Modify output spline.
// Quick exit if dataset is empty.
   buildpriorterm1(&xywork, npoints, 2, d, state->priorterm, state->priortermval, &vterm, _state);
   if (npoints == 0) {
   // Quick exit
      for (k = 0; k < s->n * s->m; k++) {
         k0 = k % s->n;
         k1 = k / s->n;
         for (j = 0; j < d; j++) {
            dstidx = d * (k1 * s->n + k0) + j;
            s->f.xR[dstidx] += vterm.xyR[j][0] * s->x.xR[k0] + vterm.xyR[j][1] * s->y.xR[k1] + vterm.xyR[j][2];
            s->f.xR[sfx + dstidx] += vterm.xyR[j][0];
            s->f.xR[sfy + dstidx] += vterm.xyR[j][1];
         }
      }
      for (i = 0; i < s->n; i++) {
         s->x.xR[i] = s->x.xR[i] * hx + xa;
      }
      for (i = 0; i < s->m; i++) {
         s->y.xR[i] = s->y.xR[i] * hy + ya;
      }
      for (i = 0; i < s->n * s->m * d; i++) {
         s->f.xR[sfx + i] *= invhx;
         s->f.xR[sfy + i] *= invhy;
         s->f.xR[sfxy + i] *= invhx * invhy;
      }
      rep->rmserror = 0.0;
      rep->avgerror = 0.0;
      rep->maxerror = 0.0;
      rep->r2 = 1.0;
      ae_frame_leave(_state);
      return;
   }
// Build 1D compact basis function
// Generate design matrix
   ae_vector_set_length(&tmpx, 7, _state);
   ae_vector_set_length(&tmpy, 7, _state);
   tmpx.xR[0] = -3.0;
   tmpx.xR[1] = -2.0;
   tmpx.xR[2] = -1.0;
   tmpx.xR[3] = 0.0;
   tmpx.xR[4] = 1.0;
   tmpx.xR[5] = 2.0;
   tmpx.xR[6] = 3.0;
   tmpy.xR[0] = 0.0;
   tmpy.xR[1] = 0.0;
   tmpy.xR[2] = 1.0 / 12.0;
   tmpy.xR[3] = 2.0 / 6.0;
   tmpy.xR[4] = 1.0 / 12.0;
   tmpy.xR[5] = 0.0;
   tmpy.xR[6] = 0.0;
   spline1dbuildcubic(&tmpx, &tmpy, tmpx.cnt, 2, 0.0, 2, 0.0, &basis1, _state);
// Solve.
// Update spline.
   if (state->solvertype == 1) {
   // BlockLLS
      spline2d_reorderdatasetandbuildindex(&xywork, npoints, d, &tmp0, 0, kx, ky, &xyindex, &tmpi, _state);
      spline2d_xdesigngenerate(&xywork, &xyindex, 0, kx, kx, 0, ky, ky, d, spline2d_lambdaregblocklls, state->smoothing, &basis1, &xdesignmatrix, _state);
      spline2d_blockllsfit(&xdesignmatrix, state->lsqrcnt, &z, rep, tss, &blockllsbuf, _state);
      spline2d_updatesplinetable(&z, kx, ky, d, &basis1, bfrad, &s->f, s->m, s->n, 1, _state);
   } else {
      if (state->solvertype == 2) {
      // NaiveLLS, reference implementation
         spline2d_generatedesignmatrix(&xywork, npoints, d, kx, ky, state->smoothing, spline2d_lambdaregblocklls, &basis1, &av, &ah, &arows, _state);
         spline2d_naivellsfit(&av, &ah, arows, &xywork, kx, ky, npoints, d, state->lsqrcnt, &z, rep, tss, _state);
         spline2d_updatesplinetable(&z, kx, ky, d, &basis1, bfrad, &s->f, s->m, s->n, 1, _state);
      } else {
         if (state->solvertype == 3) {
         // FastDDM method
            ae_assert(basecasex > 0, "Spline2DFit: integrity error", _state);
            ae_assert(basecasey > 0, "Spline2DFit: integrity error", _state);
            spline2d_fastddmfit(&xywork, npoints, d, kx, ky, basecasex, basecasey, state->maxcoresize, state->interfacesize, state->nlayers, state->smoothing, state->lsqrcnt, &basis1, s, rep, tss, _state);
         } else {
            ae_assert(false, "Spline2DFit: integrity error", _state);
         }
      }
   }
// Append prior term.
// Transform spline to original coordinates
   for (k = 0; k < s->n * s->m; k++) {
      k0 = k % s->n;
      k1 = k / s->n;
      for (j = 0; j < d; j++) {
         dstidx = d * (k1 * s->n + k0) + j;
         s->f.xR[dstidx] += vterm.xyR[j][0] * s->x.xR[k0] + vterm.xyR[j][1] * s->y.xR[k1] + vterm.xyR[j][2];
         s->f.xR[sfx + dstidx] += vterm.xyR[j][0];
         s->f.xR[sfy + dstidx] += vterm.xyR[j][1];
      }
   }
   for (i = 0; i < s->n; i++) {
      s->x.xR[i] = s->x.xR[i] * hx + xa;
   }
   for (i = 0; i < s->m; i++) {
      s->y.xR[i] = s->y.xR[i] * hy + ya;
   }
   for (i = 0; i < s->n * s->m * d; i++) {
      s->f.xR[sfx + i] *= invhx;
      s->f.xR[sfy + i] *= invhy;
      s->f.xR[sfxy + i] *= invhx * invhy;
   }
   ae_frame_leave(_state);
}

// Serializer: allocation
// ALGLIB: Copyright 28.02.2018 by Sergey Bochkanov
void spline2dalloc(ae_serializer *s, spline2dinterpolant *spline, ae_state *_state) {
// Header
   ae_serializer_alloc_entry(s);
// Data
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   allocrealarray(s, &spline->x, -1, _state);
   allocrealarray(s, &spline->y, -1, _state);
   allocrealarray(s, &spline->f, -1, _state);
}

// Serializer: serialization
// These functions serialize a data structure to a C++ string or stream.
// * serialization can be freely moved across 32-bit and 64-bit systems,
//   and different byte orders. For example, you can serialize a string
//   on a SPARC and unserialize it on an x86.
// * ALGLIB++ serialization is compatible with serialization in ALGLIB,
//   in both directions.
// Important properties of s_out:
// * it contains alphanumeric characters, dots, underscores, minus signs
// * these symbols are grouped into words, which are separated by spaces
//   and Windows-style (CR+LF) newlines
// ALGLIB: Copyright 28.02.2018 by Sergey Bochkanov
// API: void spline2dserialize(spline2dinterpolant &obj, std::string &s_out);
// API: void spline2dserialize(spline2dinterpolant &obj, std::ostream &s_out);
void spline2dserialize(ae_serializer *s, spline2dinterpolant *spline, ae_state *_state) {
// Header
   ae_serializer_serialize_int(s, getspline2dserializationcode(_state), _state);
// Data
   ae_serializer_serialize_int(s, spline->stype, _state);
   ae_serializer_serialize_int(s, spline->n, _state);
   ae_serializer_serialize_int(s, spline->m, _state);
   ae_serializer_serialize_int(s, spline->d, _state);
   serializerealarray(s, &spline->x, -1, _state);
   serializerealarray(s, &spline->y, -1, _state);
   serializerealarray(s, &spline->f, -1, _state);
}

// Serializer: unserialization
// These functions unserialize a data structure from a C++ string or stream.
// Important properties of s_in:
// * any combination of spaces, tabs, Windows or Unix stype newlines can
//   be used as separators, so as to allow flexible reformatting of the
//   stream or string from text or XML files.
// * But you should not insert separators into the middle of the "words"
//   nor you should change case of letters.
// ALGLIB: Copyright 28.02.2018 by Sergey Bochkanov
// API: void spline2dunserialize(const std::string &s_in, spline2dinterpolant &obj);
// API: void spline2dunserialize(const std::istream &s_in, spline2dinterpolant &obj);
void spline2dunserialize(ae_serializer *s, spline2dinterpolant *spline, ae_state *_state) {
   ae_int_t scode;
   SetObj(spline2dinterpolant, spline);
// Header
   ae_serializer_unserialize_int(s, &scode, _state);
   ae_assert(scode == getspline2dserializationcode(_state), "Spline2DUnserialize: stream header corrupted", _state);
// Data
   ae_serializer_unserialize_int(s, &spline->stype, _state);
   ae_serializer_unserialize_int(s, &spline->n, _state);
   ae_serializer_unserialize_int(s, &spline->m, _state);
   ae_serializer_unserialize_int(s, &spline->d, _state);
   unserializerealarray(s, &spline->x, _state);
   unserializerealarray(s, &spline->y, _state);
   unserializerealarray(s, &spline->f, _state);
}

void spline2dinterpolant_init(void *_p, ae_state *_state, bool make_automatic) {
   spline2dinterpolant *p = (spline2dinterpolant *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->x, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->y, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->f, 0, DT_REAL, _state, make_automatic);
}

void spline2dinterpolant_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   spline2dinterpolant *dst = (spline2dinterpolant *)_dst;
   spline2dinterpolant *src = (spline2dinterpolant *)_src;
   dst->stype = src->stype;
   dst->n = src->n;
   dst->m = src->m;
   dst->d = src->d;
   ae_vector_copy(&dst->x, &src->x, _state, make_automatic);
   ae_vector_copy(&dst->y, &src->y, _state, make_automatic);
   ae_vector_copy(&dst->f, &src->f, _state, make_automatic);
}

void spline2dinterpolant_free(void *_p, bool make_automatic) {
   spline2dinterpolant *p = (spline2dinterpolant *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->x, make_automatic);
   ae_vector_free(&p->y, make_automatic);
   ae_vector_free(&p->f, make_automatic);
}

void spline2dbuilder_init(void *_p, ae_state *_state, bool make_automatic) {
   spline2dbuilder *p = (spline2dbuilder *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->xy, 0, DT_REAL, _state, make_automatic);
}

void spline2dbuilder_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   spline2dbuilder *dst = (spline2dbuilder *)_dst;
   spline2dbuilder *src = (spline2dbuilder *)_src;
   dst->priorterm = src->priorterm;
   dst->priortermval = src->priortermval;
   dst->areatype = src->areatype;
   dst->xa = src->xa;
   dst->xb = src->xb;
   dst->ya = src->ya;
   dst->yb = src->yb;
   dst->gridtype = src->gridtype;
   dst->kx = src->kx;
   dst->ky = src->ky;
   dst->smoothing = src->smoothing;
   dst->nlayers = src->nlayers;
   dst->solvertype = src->solvertype;
   dst->lambdabase = src->lambdabase;
   ae_vector_copy(&dst->xy, &src->xy, _state, make_automatic);
   dst->npoints = src->npoints;
   dst->d = src->d;
   dst->sx = src->sx;
   dst->sy = src->sy;
   dst->adddegreeoffreedom = src->adddegreeoffreedom;
   dst->interfacesize = src->interfacesize;
   dst->lsqrcnt = src->lsqrcnt;
   dst->maxcoresize = src->maxcoresize;
}

void spline2dbuilder_free(void *_p, bool make_automatic) {
   spline2dbuilder *p = (spline2dbuilder *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->xy, make_automatic);
}

void spline2dfitreport_init(void *_p, ae_state *_state, bool make_automatic) {
   spline2dfitreport *p = (spline2dfitreport *)_p;
   ae_touch_ptr((void *)p);
}

void spline2dfitreport_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   spline2dfitreport *dst = (spline2dfitreport *)_dst;
   spline2dfitreport *src = (spline2dfitreport *)_src;
   dst->rmserror = src->rmserror;
   dst->avgerror = src->avgerror;
   dst->maxerror = src->maxerror;
   dst->r2 = src->r2;
}

void spline2dfitreport_free(void *_p, bool make_automatic) {
   spline2dfitreport *p = (spline2dfitreport *)_p;
   ae_touch_ptr((void *)p);
}

void spline2dxdesignmatrix_init(void *_p, ae_state *_state, bool make_automatic) {
   spline2dxdesignmatrix *p = (spline2dxdesignmatrix *)_p;
   ae_touch_ptr((void *)p);
   ae_matrix_init(&p->vals, 0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->batches, 0, DT_INT, _state, make_automatic);
   ae_vector_init(&p->batchbases, 0, DT_INT, _state, make_automatic);
   ae_vector_init(&p->tmp0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tmp1, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->tmp2, 0, 0, DT_REAL, _state, make_automatic);
}

void spline2dxdesignmatrix_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   spline2dxdesignmatrix *dst = (spline2dxdesignmatrix *)_dst;
   spline2dxdesignmatrix *src = (spline2dxdesignmatrix *)_src;
   dst->blockwidth = src->blockwidth;
   dst->kx = src->kx;
   dst->ky = src->ky;
   dst->npoints = src->npoints;
   dst->nrows = src->nrows;
   dst->ndenserows = src->ndenserows;
   dst->ndensebatches = src->ndensebatches;
   dst->d = src->d;
   dst->maxbatch = src->maxbatch;
   ae_matrix_copy(&dst->vals, &src->vals, _state, make_automatic);
   ae_vector_copy(&dst->batches, &src->batches, _state, make_automatic);
   ae_vector_copy(&dst->batchbases, &src->batchbases, _state, make_automatic);
   dst->lambdareg = src->lambdareg;
   ae_vector_copy(&dst->tmp0, &src->tmp0, _state, make_automatic);
   ae_vector_copy(&dst->tmp1, &src->tmp1, _state, make_automatic);
   ae_matrix_copy(&dst->tmp2, &src->tmp2, _state, make_automatic);
}

void spline2dxdesignmatrix_free(void *_p, bool make_automatic) {
   spline2dxdesignmatrix *p = (spline2dxdesignmatrix *)_p;
   ae_touch_ptr((void *)p);
   ae_matrix_free(&p->vals, make_automatic);
   ae_vector_free(&p->batches, make_automatic);
   ae_vector_free(&p->batchbases, make_automatic);
   ae_vector_free(&p->tmp0, make_automatic);
   ae_vector_free(&p->tmp1, make_automatic);
   ae_matrix_free(&p->tmp2, make_automatic);
}

void spline2dblockllsbuf_init(void *_p, ae_state *_state, bool make_automatic) {
   spline2dblockllsbuf *p = (spline2dblockllsbuf *)_p;
   ae_touch_ptr((void *)p);
   linlsqrstate_init(&p->solver, _state, make_automatic);
   linlsqrreport_init(&p->solverrep, _state, make_automatic);
   ae_matrix_init(&p->blockata, 0, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->trsmbuf2, 0, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->cholbuf2, 0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->cholbuf1, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tmp0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tmp1, 0, DT_REAL, _state, make_automatic);
}

void spline2dblockllsbuf_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   spline2dblockllsbuf *dst = (spline2dblockllsbuf *)_dst;
   spline2dblockllsbuf *src = (spline2dblockllsbuf *)_src;
   linlsqrstate_copy(&dst->solver, &src->solver, _state, make_automatic);
   linlsqrreport_copy(&dst->solverrep, &src->solverrep, _state, make_automatic);
   ae_matrix_copy(&dst->blockata, &src->blockata, _state, make_automatic);
   ae_matrix_copy(&dst->trsmbuf2, &src->trsmbuf2, _state, make_automatic);
   ae_matrix_copy(&dst->cholbuf2, &src->cholbuf2, _state, make_automatic);
   ae_vector_copy(&dst->cholbuf1, &src->cholbuf1, _state, make_automatic);
   ae_vector_copy(&dst->tmp0, &src->tmp0, _state, make_automatic);
   ae_vector_copy(&dst->tmp1, &src->tmp1, _state, make_automatic);
}

void spline2dblockllsbuf_free(void *_p, bool make_automatic) {
   spline2dblockllsbuf *p = (spline2dblockllsbuf *)_p;
   ae_touch_ptr((void *)p);
   linlsqrstate_free(&p->solver, make_automatic);
   linlsqrreport_free(&p->solverrep, make_automatic);
   ae_matrix_free(&p->blockata, make_automatic);
   ae_matrix_free(&p->trsmbuf2, make_automatic);
   ae_matrix_free(&p->cholbuf2, make_automatic);
   ae_vector_free(&p->cholbuf1, make_automatic);
   ae_vector_free(&p->tmp0, make_automatic);
   ae_vector_free(&p->tmp1, make_automatic);
}

void spline2dfastddmbuf_init(void *_p, ae_state *_state, bool make_automatic) {
   spline2dfastddmbuf *p = (spline2dfastddmbuf *)_p;
   ae_touch_ptr((void *)p);
   spline2dxdesignmatrix_init(&p->xdesignmatrix, _state, make_automatic);
   ae_vector_init(&p->tmp0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tmpz, 0, DT_REAL, _state, make_automatic);
   spline2dfitreport_init(&p->dummyrep, _state, make_automatic);
   spline2dinterpolant_init(&p->localmodel, _state, make_automatic);
   spline2dblockllsbuf_init(&p->blockllsbuf, _state, make_automatic);
}

void spline2dfastddmbuf_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   spline2dfastddmbuf *dst = (spline2dfastddmbuf *)_dst;
   spline2dfastddmbuf *src = (spline2dfastddmbuf *)_src;
   spline2dxdesignmatrix_copy(&dst->xdesignmatrix, &src->xdesignmatrix, _state, make_automatic);
   ae_vector_copy(&dst->tmp0, &src->tmp0, _state, make_automatic);
   ae_vector_copy(&dst->tmpz, &src->tmpz, _state, make_automatic);
   spline2dfitreport_copy(&dst->dummyrep, &src->dummyrep, _state, make_automatic);
   spline2dinterpolant_copy(&dst->localmodel, &src->localmodel, _state, make_automatic);
   spline2dblockllsbuf_copy(&dst->blockllsbuf, &src->blockllsbuf, _state, make_automatic);
}

void spline2dfastddmbuf_free(void *_p, bool make_automatic) {
   spline2dfastddmbuf *p = (spline2dfastddmbuf *)_p;
   ae_touch_ptr((void *)p);
   spline2dxdesignmatrix_free(&p->xdesignmatrix, make_automatic);
   ae_vector_free(&p->tmp0, make_automatic);
   ae_vector_free(&p->tmpz, make_automatic);
   spline2dfitreport_free(&p->dummyrep, make_automatic);
   spline2dinterpolant_free(&p->localmodel, make_automatic);
   spline2dblockllsbuf_free(&p->blockllsbuf, make_automatic);
}
} // end of namespace alglib_impl

namespace alglib {
// 2-dimensional spline inteprolant
DefClass(spline2dinterpolant, )

// Nonlinear least squares solver used to fit 2D splines to data
DefClass(spline2dbuilder, )

// Spline 2D fitting report:
//     rmserror        RMS error
//     avgerror        average error
//     maxerror        maximum error
//     r2              coefficient of determination,  R-squared, 1-RSS/TSS
DefClass(spline2dfitreport, DecVal(rmserror) DecVal(avgerror) DecVal(maxerror) DecVal(r2))

void spline2dserialize(spline2dinterpolant &obj, std::string &s_out) {
   alglib_impl::ae_int_t ssize;
   alglib_impl::ae_state state; alglib_impl::ae_state_init(&state);
   TryCatch(state, )
   NewSerializer(serializer);
   alglib_impl::ae_serializer_alloc_start(&serializer);
   alglib_impl::spline2dalloc(&serializer, obj.c_ptr(), &state);
   ssize = alglib_impl::ae_serializer_get_alloc_size(&serializer);
   s_out.clear();
   s_out.reserve((size_t)(ssize + 1));
   alglib_impl::ae_serializer_sstart_str(&serializer, &s_out);
   alglib_impl::spline2dserialize(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_stop(&serializer, &state);
   alglib_impl::ae_assert(s_out.length() <= (size_t)ssize, "ALGLIB: serialization integrity error", &state);
   alglib_impl::ae_state_clear(&state);
}
void spline2dserialize(spline2dinterpolant &obj, std::ostream &s_out) {
   alglib_impl::ae_state state; alglib_impl::ae_state_init(&state);
   TryCatch(state, )
   NewSerializer(serializer);
   alglib_impl::ae_serializer_alloc_start(&serializer);
   alglib_impl::spline2dalloc(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_get_alloc_size(&serializer); // not actually needed, but we have to ask
   alglib_impl::ae_serializer_sstart_stream(&serializer, &s_out);
   alglib_impl::spline2dserialize(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_stop(&serializer, &state);
   alglib_impl::ae_state_clear(&state);
}

void spline2dunserialize(const std::string &s_in, spline2dinterpolant &obj) {
   alglib_impl::ae_state state; alglib_impl::ae_state_init(&state);
   TryCatch(state, )
   NewSerializer(serializer);
   alglib_impl::ae_serializer_ustart_str(&serializer, &s_in);
   alglib_impl::spline2dunserialize(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_stop(&serializer, &state);
   alglib_impl::ae_state_clear(&state);
}
void spline2dunserialize(const std::istream &s_in, spline2dinterpolant &obj) {
   alglib_impl::ae_state state; alglib_impl::ae_state_init(&state);
   TryCatch(state, )
   NewSerializer(serializer);
   alglib_impl::ae_serializer_ustart_stream(&serializer, &s_in);
   alglib_impl::spline2dunserialize(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_stop(&serializer, &state);
   alglib_impl::ae_state_clear(&state);
}

double spline2dcalc(const spline2dinterpolant &c, const double x, const double y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::spline2dcalc(ConstT(spline2dinterpolant, c), x, y, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

void spline2dcalcvbuf(const spline2dinterpolant &c, const double x, const double y, real_1d_array &f, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dcalcvbuf(ConstT(spline2dinterpolant, c), x, y, ConstT(ae_vector, f), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dcalcv(const spline2dinterpolant &c, const double x, const double y, real_1d_array &f, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dcalcv(ConstT(spline2dinterpolant, c), x, y, ConstT(ae_vector, f), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

double spline2dcalcvi(const spline2dinterpolant &c, const double x, const double y, const ae_int_t i, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::spline2dcalcvi(ConstT(spline2dinterpolant, c), x, y, i, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

void spline2ddiff(const spline2dinterpolant &c, const double x, const double y, double &f, double &fx, double &fy, double &fxy, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2ddiff(ConstT(spline2dinterpolant, c), x, y, &f, &fx, &fy, &fxy, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2ddiffvi(const spline2dinterpolant &c, const double x, const double y, const ae_int_t i, double &f, double &fx, double &fy, double &fxy, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2ddiffvi(ConstT(spline2dinterpolant, c), x, y, i, &f, &fx, &fy, &fxy, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dcopy(const spline2dinterpolant &c, spline2dinterpolant &cc, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dcopy(ConstT(spline2dinterpolant, c), ConstT(spline2dinterpolant, cc), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dresamplebicubic(const real_2d_array &a, const ae_int_t oldheight, const ae_int_t oldwidth, real_2d_array &b, const ae_int_t newheight, const ae_int_t newwidth, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dresamplebicubic(ConstT(ae_matrix, a), oldheight, oldwidth, ConstT(ae_matrix, b), newheight, newwidth, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dresamplebilinear(const real_2d_array &a, const ae_int_t oldheight, const ae_int_t oldwidth, real_2d_array &b, const ae_int_t newheight, const ae_int_t newwidth, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dresamplebilinear(ConstT(ae_matrix, a), oldheight, oldwidth, ConstT(ae_matrix, b), newheight, newwidth, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildbilinearv(const real_1d_array &x, const ae_int_t n, const real_1d_array &y, const ae_int_t m, const real_1d_array &f, const ae_int_t d, spline2dinterpolant &c, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildbilinearv(ConstT(ae_vector, x), n, ConstT(ae_vector, y), m, ConstT(ae_vector, f), d, ConstT(spline2dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildbicubicv(const real_1d_array &x, const ae_int_t n, const real_1d_array &y, const ae_int_t m, const real_1d_array &f, const ae_int_t d, spline2dinterpolant &c, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildbicubicv(ConstT(ae_vector, x), n, ConstT(ae_vector, y), m, ConstT(ae_vector, f), d, ConstT(spline2dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildbilinear(const real_1d_array &x, const real_1d_array &y, const real_2d_array &f, const ae_int_t m, const ae_int_t n, spline2dinterpolant &c, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildbilinear(ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_matrix, f), m, n, ConstT(spline2dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildbicubic(const real_1d_array &x, const real_1d_array &y, const real_2d_array &f, const ae_int_t m, const ae_int_t n, spline2dinterpolant &c, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildbicubic(ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_matrix, f), m, n, ConstT(spline2dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dlintransxy(const spline2dinterpolant &c, const double ax, const double bx, const double ay, const double by, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dlintransxy(ConstT(spline2dinterpolant, c), ax, bx, ay, by, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dlintransf(const spline2dinterpolant &c, const double a, const double b, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dlintransf(ConstT(spline2dinterpolant, c), a, b, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dunpackv(const spline2dinterpolant &c, ae_int_t &m, ae_int_t &n, ae_int_t &d, real_2d_array &tbl, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dunpackv(ConstT(spline2dinterpolant, c), &m, &n, &d, ConstT(ae_matrix, tbl), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dunpack(const spline2dinterpolant &c, ae_int_t &m, ae_int_t &n, real_2d_array &tbl, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dunpack(ConstT(spline2dinterpolant, c), &m, &n, ConstT(ae_matrix, tbl), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildercreate(const ae_int_t d, spline2dbuilder &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildercreate(d, ConstT(spline2dbuilder, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildersetuserterm(const spline2dbuilder &state, const double v, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildersetuserterm(ConstT(spline2dbuilder, state), v, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildersetlinterm(const spline2dbuilder &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildersetlinterm(ConstT(spline2dbuilder, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildersetconstterm(const spline2dbuilder &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildersetconstterm(ConstT(spline2dbuilder, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildersetzeroterm(const spline2dbuilder &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildersetzeroterm(ConstT(spline2dbuilder, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildersetpoints(const spline2dbuilder &state, const real_2d_array &xy, const ae_int_t n, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildersetpoints(ConstT(spline2dbuilder, state), ConstT(ae_matrix, xy), n, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildersetareaauto(const spline2dbuilder &state, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildersetareaauto(ConstT(spline2dbuilder, state), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildersetarea(const spline2dbuilder &state, const double xa, const double xb, const double ya, const double yb, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildersetarea(ConstT(spline2dbuilder, state), xa, xb, ya, yb, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildersetgrid(const spline2dbuilder &state, const ae_int_t kx, const ae_int_t ky, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildersetgrid(ConstT(spline2dbuilder, state), kx, ky, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildersetalgofastddm(const spline2dbuilder &state, const ae_int_t nlayers, const double lambdav, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildersetalgofastddm(ConstT(spline2dbuilder, state), nlayers, lambdav, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildersetalgoblocklls(const spline2dbuilder &state, const double lambdans, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildersetalgoblocklls(ConstT(spline2dbuilder, state), lambdans, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dbuildersetalgonaivells(const spline2dbuilder &state, const double lambdans, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dbuildersetalgonaivells(ConstT(spline2dbuilder, state), lambdans, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline2dfit(const spline2dbuilder &state, spline2dinterpolant &s, spline2dfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline2dfit(ConstT(spline2dbuilder, state), ConstT(spline2dinterpolant, s), ConstT(spline2dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
} // end of namespace alglib

// === RBFV2 Package ===
// Depends on: (AlgLibMisc) NEARESTNEIGHBOR
// Depends on: LSFIT
namespace alglib_impl {
static const double rbfv2_defaultlambdareg = 1.0E-6;
static const double rbfv2_defaultsupportr = 0.10;
static const ae_int_t rbfv2_defaultmaxits = 400;
static const ae_int_t rbfv2_defaultbf = 1;
static const ae_int_t rbfv2_maxnodesize = 6;
static const double rbfv2_complexitymultiplier = 100.0;

// This function creates RBF  model  for  a  scalar (NY=1)  or  vector (NY>1)
// function in a NX-dimensional space (NX=2 or NX=3).
//
// Inputs:
//     NX      -   dimension of the space, NX=2 or NX=3
//     NY      -   function dimension, NY >= 1
//
// Outputs:
//     S       -   RBF model (initially equals to zero)
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
void rbfv2create(ae_int_t nx, ae_int_t ny, rbfv2model *s, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   SetObj(rbfv2model, s);
   ae_assert(nx >= 1, "RBFCreate: NX<1", _state);
   ae_assert(ny >= 1, "RBFCreate: NY<1", _state);
// Serializable parameters
   s->nx = nx;
   s->ny = ny;
   s->bf = 0;
   s->nh = 0;
   ae_matrix_set_length(&s->v, ny, nx + 1, _state);
   for (i = 0; i < ny; i++) {
      for (j = 0; j <= nx; j++) {
         s->v.xyR[i][j] = 0.0;
      }
   }
// Non-serializable parameters
   s->lambdareg = rbfv2_defaultlambdareg;
   s->maxits = rbfv2_defaultmaxits;
   s->supportr = rbfv2_defaultsupportr;
   s->basisfunction = rbfv2_defaultbf;
}

// Reallocates calcBuf if necessary, reuses previously allocated space if
// possible.
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static void rbfv2_allocatecalcbuffer(rbfv2model *s, rbfv2calcbuffer *buf, ae_state *_state) {
   if (buf->x.cnt < s->nx) {
      ae_vector_set_length(&buf->x, s->nx, _state);
   }
   if (buf->curboxmin.cnt < s->nx) {
      ae_vector_set_length(&buf->curboxmin, s->nx, _state);
   }
   if (buf->curboxmax.cnt < s->nx) {
      ae_vector_set_length(&buf->curboxmax, s->nx, _state);
   }
   if (buf->x123.cnt < s->nx) {
      ae_vector_set_length(&buf->x123, s->nx, _state);
   }
   if (buf->y123.cnt < s->ny) {
      ae_vector_set_length(&buf->y123, s->ny, _state);
   }
}

// This function creates buffer  structure  which  can  be  used  to  perform
// parallel  RBF  model  evaluations  (with  one  RBF  model  instance  being
// used from multiple threads, as long as  different  threads  use  different
// instances of buffer).
//
// This buffer object can be used with  rbftscalcbuf()  function  (here  "ts"
// stands for "thread-safe", "buf" is a suffix which denotes  function  which
// reuses previously allocated output space).
//
// How to use it:
// * create RBF model structure with rbfcreate()
// * load data, tune parameters
// * call rbfbuildmodel()
// * call rbfcreatecalcbuffer(), once per thread working with RBF model  (you
//   should call this function only AFTER call to rbfbuildmodel(), see  below
//   for more information)
// * call rbftscalcbuf() from different threads,  with  each  thread  working
//   with its own copy of buffer object.
//
// Inputs:
//     S           -   RBF model
//
// Outputs:
//     Buf         -   external buffer.
//
//
// IMPORTANT: buffer object should be used only with  RBF model object  which
//            was used to initialize buffer. Any attempt to use buffer   with
//            different object is dangerous - you may  get  memory  violation
//            error because sizes of internal arrays do not fit to dimensions
//            of RBF structure.
//
// IMPORTANT: you  should  call  this function only for model which was built
//            with rbfbuildmodel() function, after successful  invocation  of
//            rbfbuildmodel().  Sizes   of   some   internal  structures  are
//            determined only after model is built, so buffer object  created
//            before model  construction  stage  will  be  useless  (and  any
//            attempt to use it will result in exception).
// ALGLIB: Copyright 02.04.2016 by Sergey Bochkanov
void rbfv2createcalcbuffer(rbfv2model *s, rbfv2calcbuffer *buf, ae_state *_state) {
   SetObj(rbfv2calcbuffer, buf);
   rbfv2_allocatecalcbuffer(s, buf, _state);
}

// Recurrent tree conversion
//
//     CurTree         -   tree to convert
//     N, NX, NY       -   dataset metrics
//     NodeOffset      -   offset of current tree node, 0 for root
//     NodesBase       -   a value which is added to intra-tree node indexes;
//                         although this tree is stored in separate array, it
//                         is intended to be stored in the larger tree,  with
//                         localNodes being moved to offset NodesBase.
//     SplitsBase      -   similarly, offset of localSplits in the final tree
//     CWBase          -   similarly, offset of localCW in the final tree
static void rbfv2_converttreerec(kdtree *curtree, ae_int_t n, ae_int_t nx, ae_int_t ny, ae_int_t nodeoffset, ae_int_t nodesbase, ae_int_t splitsbase, ae_int_t cwbase, ZVector *localnodes, ae_int_t *localnodessize, RVector *localsplits, ae_int_t *localsplitssize, RVector *localcw, ae_int_t *localcwsize, RMatrix *xybuf, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t nodetype;
   ae_int_t cnt;
   ae_int_t d;
   double s;
   ae_int_t nodele;
   ae_int_t nodege;
   ae_int_t oldnodessize;
   kdtreeexplorenodetype(curtree, nodeoffset, &nodetype, _state);
// Leaf node
   if (nodetype == 0) {
      kdtreeexploreleaf(curtree, nodeoffset, xybuf, &cnt, _state);
      ae_assert(localnodes->cnt >= *localnodessize + 2, "ConvertTreeRec: integrity check failed", _state);
      ae_assert(localcw->cnt >= *localcwsize + cnt * (nx + ny), "ConvertTreeRec: integrity check failed", _state);
      localnodes->xZ[*localnodessize + 0] = cnt;
      localnodes->xZ[*localnodessize + 1] = cwbase + (*localcwsize);
      *localnodessize += 2;
      for (i = 0; i < cnt; i++) {
         for (j = 0; j < nx + ny; j++) {
            localcw->xR[*localcwsize + i * (nx + ny) + j] = xybuf->xyR[i][j];
         }
      }
      *localcwsize += cnt * (nx + ny);
      return;
   }
// Split node
   if (nodetype == 1) {
      kdtreeexploresplit(curtree, nodeoffset, &d, &s, &nodele, &nodege, _state);
      ae_assert(localnodes->cnt >= *localnodessize + rbfv2_maxnodesize, "ConvertTreeRec: integrity check failed", _state);
      ae_assert(localsplits->cnt >= *localsplitssize + 1, "ConvertTreeRec: integrity check failed", _state);
      oldnodessize = *localnodessize;
      localnodes->xZ[*localnodessize + 0] = 0;
      localnodes->xZ[*localnodessize + 1] = d;
      localnodes->xZ[*localnodessize + 2] = splitsbase + (*localsplitssize);
      localnodes->xZ[*localnodessize + 3] = -1;
      localnodes->xZ[*localnodessize + 4] = -1;
      *localnodessize += 5;
      localsplits->xR[*localsplitssize + 0] = s;
      ++*localsplitssize;
      localnodes->xZ[oldnodessize + 3] = nodesbase + (*localnodessize);
      rbfv2_converttreerec(curtree, n, nx, ny, nodele, nodesbase, splitsbase, cwbase, localnodes, localnodessize, localsplits, localsplitssize, localcw, localcwsize, xybuf, _state);
      localnodes->xZ[oldnodessize + 4] = nodesbase + (*localnodessize);
      rbfv2_converttreerec(curtree, n, nx, ny, nodege, nodesbase, splitsbase, cwbase, localnodes, localnodessize, localsplits, localsplitssize, localcw, localcwsize, xybuf, _state);
      return;
   }
// Integrity error
   ae_assert(false, "ConvertTreeRec: integrity check failed", _state);
}

// Extracts structure (and XY-values too) from  kd-tree  built  for  a  small
// subset of points and appends it to multi-tree.
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static void rbfv2_convertandappendtree(kdtree *curtree, ae_int_t n, ae_int_t nx, ae_int_t ny, ZVector *kdnodes, RVector *kdsplits, RVector *cw, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t nodesbase;
   ae_int_t splitsbase;
   ae_int_t cwbase;
   ae_int_t localnodessize;
   ae_int_t localsplitssize;
   ae_int_t localcwsize;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   NewVector(localnodes, 0, DT_INT, _state);
   NewVector(localsplits, 0, DT_REAL, _state);
   NewVector(localcw, 0, DT_REAL, _state);
   NewMatrix(xybuf, 0, 0, DT_REAL, _state);
// Calculate base offsets
   nodesbase = kdnodes->cnt;
   splitsbase = kdsplits->cnt;
   cwbase = cw->cnt;
// Prepare local copy of tree
   ae_vector_set_length(&localnodes, n * rbfv2_maxnodesize, _state);
   ae_vector_set_length(&localsplits, n, _state);
   ae_vector_set_length(&localcw, (nx + ny) * n, _state);
   localnodessize = 0;
   localsplitssize = 0;
   localcwsize = 0;
   rbfv2_converttreerec(curtree, n, nx, ny, 0, nodesbase, splitsbase, cwbase, &localnodes, &localnodessize, &localsplits, &localsplitssize, &localcw, &localcwsize, &xybuf, _state);
// Append to multi-tree
   ivectorresize(kdnodes, kdnodes->cnt + localnodessize, _state);
   rvectorresize(kdsplits, kdsplits->cnt + localsplitssize, _state);
   rvectorresize(cw, cw->cnt + localcwsize, _state);
   for (i = 0; i < localnodessize; i++) {
      kdnodes->xZ[nodesbase + i] = localnodes.xZ[i];
   }
   for (i = 0; i < localsplitssize; i++) {
      kdsplits->xR[splitsbase + i] = localsplits.xR[i];
   }
   for (i = 0; i < localcwsize; i++) {
      cw->xR[cwbase + i] = localcw.xR[i];
   }
   ae_frame_leave(_state);
}

// Returns far radius for basis function type
double rbfv2farradius(ae_int_t bf, ae_state *_state) {
   double result;
   result = 1.0;
   if (bf == 0) {
      result = 5.0;
   }
   if (bf == 1) {
      result = 3.0;
   }
   return result;
}

// Returns near radius for basis function type
double rbfv2nearradius(ae_int_t bf, ae_state *_state) {
   double result;
   result = 1.0;
   if (bf == 0) {
      result = 3.0;
   }
   if (bf == 1) {
      result = 3.0;
   }
   return result;
}

// Returns basis function value.
// Assumes that D2 >= 0
double rbfv2basisfunc(ae_int_t bf, double d2, ae_state *_state) {
   double v;
   double result;
   result = 0.0;
   if (bf == 0) {
      result = ae_exp(-d2, _state);
      return result;
   }
   if (bf == 1) {
   // if D2<3:
   //     Exp(1)*Exp(-D2)*Exp(-1/(1-D2/9))
   // else:
   //     0
      v = 1 - d2 / 9;
      if (v <= 0.0) {
         result = 0.0;
         return result;
      }
      result = 2.718281828459045 * ae_exp(-d2, _state) * ae_exp(-1 / v, _state);
      return result;
   }
   ae_assert(false, "RBFV2BasisFunc: unknown BF type", _state);
   return result;
}

// Returns basis function value, first and second derivatives
// Assumes that D2 >= 0
void rbfv2basisfuncdiff2(ae_int_t bf, double d2, double *f, double *df, double *d2f, ae_state *_state) {
   double v;
   *f = 0;
   *df = 0;
   *d2f = 0;
   if (bf == 0) {
      *f = ae_exp(-d2, _state);
      *df = -*f;
      *d2f = *f;
      return;
   }
   if (bf == 1) {
   // if D2<3:
   //       F = Exp(1)*Exp(-D2)*Exp(-1/(1-D2/9))
   //      dF =  -F * [pow(D2/9-1,-2)/9 + 1]
   //     d2F = -dF * [pow(D2/9-1,-2)/9 + 1] + F*(2/81)*pow(D2/9-1,-3)
   // else:
   //     0
      v = 1 - d2 / 9;
      if (v <= 0.0) {
         *f = 0.0;
         *df = 0.0;
         *d2f = 0.0;
         return;
      }
      *f = ae_exp(1.0, _state) * ae_exp(-d2, _state) * ae_exp(-1 / v, _state);
      *df = -*f * (1 / (9 * v * v) + 1);
      *d2f = -*df * (1 / (9 * v * v) + 1) + *f * (2.0 / 81.0) / (v * v * v);
      return;
   }
   ae_assert(false, "RBFV2BasisFuncDiff2: unknown BF type", _state);
}

// This function performs partial calculation of  hierarchical  model:  given
// evaluation point X and partially computed value Y, it updates Y by  values
// computed using part of multi-tree given by RootIdx.
//
// Inputs:
//     S       -   V2 model
//     Buf     -   calc-buffer, this function uses following fields:
//                 * Buf.CurBoxMin - should be set by caller
//                 * Buf.CurBoxMax - should be set by caller
//                 * Buf.CurDist2  - squared distance from X to current bounding box,
//                   should be set by caller
//     RootIdx -   offset of partial kd-tree
//     InvR2   -   1/R^2, where R is basis function radius
//     QueryR2 -   squared query radius, usually it is (R*FarRadius(BasisFunction))^2
//     X       -   evaluation point, array[NX]
//     Y       -   partial value, array[NY]
//
// Outputs:
//     Y       -   updated partial value
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static void rbfv2_partialcalcrec(rbfv2model *s, rbfv2calcbuffer *buf, ae_int_t rootidx, double invr2, double queryr2, RVector *x, RVector *y, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   double ptdist2;
   double v;
   double v0;
   double v1;
   ae_int_t cwoffs;
   ae_int_t cwcnt;
   ae_int_t itemoffs;
   double arg;
   double val;
   ae_int_t d;
   double split;
   ae_int_t childle;
   ae_int_t childge;
   ae_int_t childoffs;
   bool updatemin;
   double prevdist2;
   double t1;
   ae_int_t nx;
   ae_int_t ny;
   nx = s->nx;
   ny = s->ny;
// Helps to avoid spurious warnings
   val = 0.0;
// Leaf node.
   if (s->kdnodes.xZ[rootidx] > 0) {
      cwcnt = s->kdnodes.xZ[rootidx + 0];
      cwoffs = s->kdnodes.xZ[rootidx + 1];
      for (i = 0; i < cwcnt; i++) {
      // Calculate distance
         itemoffs = cwoffs + i * (nx + ny);
         ptdist2 = 0.0;
         for (j = 0; j < nx; j++) {
            v = s->cw.xR[itemoffs + j] - x->xR[j];
            ptdist2 += v * v;
         }
      // Skip points if distance too large
         if (ptdist2 >= queryr2) {
            continue;
         }
      // Update Y
         arg = ptdist2 * invr2;
         if (s->bf == 0) {
            val = ae_exp(-arg, _state);
         } else {
            if (s->bf == 1) {
               val = rbfv2basisfunc(s->bf, arg, _state);
            } else {
               ae_assert(false, "PartialCalcRec: integrity check failed", _state);
            }
         }
         itemoffs += nx;
         for (j = 0; j < ny; j++) {
            y->xR[j] += val * s->cw.xR[itemoffs + j];
         }
      }
      return;
   }
// Simple split
   if (s->kdnodes.xZ[rootidx] == 0) {
   // Load:
   // * D      dimension to split
   // * Split  split position
   // * ChildLE, ChildGE - indexes of childs
      d = s->kdnodes.xZ[rootidx + 1];
      split = s->kdsplits.xR[s->kdnodes.xZ[rootidx + 2]];
      childle = s->kdnodes.xZ[rootidx + 3];
      childge = s->kdnodes.xZ[rootidx + 4];
   // Navigate through childs
      for (i = 0; i <= 1; i++) {
      // Select child to process:
      // * ChildOffs      current child offset in Nodes[]
      // * UpdateMin      whether minimum or maximum value
      //                  of bounding box is changed on update
         updatemin = i != 0;
         if (i == 0) {
            childoffs = childle;
         } else {
            childoffs = childge;
         }
      // Update bounding box and current distance
         prevdist2 = buf->curdist2;
         t1 = x->xR[d];
         if (updatemin) {
            v = buf->curboxmin.xR[d];
            if (t1 <= split) {
               v0 = v - t1;
               if (v0 < 0) {
                  v0 = 0.0;
               }
               v1 = split - t1;
               buf->curdist2 -= v0 * v0 - v1 * v1;
            }
            buf->curboxmin.xR[d] = split;
         } else {
            v = buf->curboxmax.xR[d];
            if (t1 >= split) {
               v0 = t1 - v;
               if (v0 < 0) {
                  v0 = 0.0;
               }
               v1 = t1 - split;
               buf->curdist2 -= v0 * v0 - v1 * v1;
            }
            buf->curboxmax.xR[d] = split;
         }
      // Decide: to dive into cell or not to dive
         if (buf->curdist2 < queryr2) {
            rbfv2_partialcalcrec(s, buf, childoffs, invr2, queryr2, x, y, _state);
         }
      // Restore bounding box and distance
         if (updatemin) {
            buf->curboxmin.xR[d] = v;
         } else {
            buf->curboxmax.xR[d] = v;
         }
         buf->curdist2 = prevdist2;
      }
      return;
   }
// Integrity failure
   ae_assert(false, "PartialCalcRec: integrity check failed", _state);
}

// This function performs same operation as partialcalcrec(), but  for entire
// row of the grid. "Row" is a set of nodes (x0,x1,x2,x3) which share x1..x3,
// but have different x0's. (note: for 2D/3D problems x2..x3 are zero).
//
// Row is given by:
// * central point XC, which is located at the center of the row, and used to
//   perform kd-tree requests
// * set of x0 coordinates stored in RX array (array may be unordered, but it
//   is expected that spread of x0  is  no  more  than  R;  function  may  be
//   inefficient for larger spreads).
// * set of YFlag values stored in RF
//
// Inputs:
//     S       -   V2 model
//     Buf     -   calc-buffer, this function uses following fields:
//                 * Buf.CurBoxMin - should be set by caller
//                 * Buf.CurBoxMax - should be set by caller
//                 * Buf.CurDist2  - squared distance from X to current bounding box,
//                   should be set by caller
//     RootIdx -   offset of partial kd-tree
//     InvR2   -   1/R^2, where R is basis function radius
//     RQuery2 -   squared query radius, usually it is (R*FarRadius(BasisFunction)+0.5*RowWidth)^2,
//                 where RowWidth is its spatial  extent  (after  scaling  of
//                 variables). This radius is used to perform  initial  query
//                 for neighbors of CX.
//     RFar2   -   squared far radius; far radius is used to perform actual
//                 filtering of results of query made with RQuery2.
//     CX      -   central point, array[NX], used for queries
//     RX      -   x0 coordinates, array[RowSize]
//     RF      -   sparsity flags, array[RowSize]
//     RowSize -   row size in elements
//     RY      -   input partial value, array[NY]
//
// Outputs:
//     RY      -   updated partial value (function adds its results to RY)
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static void rbfv2_partialrowcalcrec(rbfv2model *s, rbfv2calcbuffer *buf, ae_int_t rootidx, double invr2, double rquery2, double rfar2, RVector *cx, RVector *rx, BVector *rf, ae_int_t rowsize, RVector *ry, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t i0;
   ae_int_t i1;
   double partialptdist2;
   double ptdist2;
   double v;
   double v0;
   double v1;
   ae_int_t cwoffs;
   ae_int_t cwcnt;
   ae_int_t itemoffs;
   ae_int_t woffs;
   double val;
   ae_int_t d;
   double split;
   ae_int_t childle;
   ae_int_t childge;
   ae_int_t childoffs;
   bool updatemin;
   double prevdist2;
   double t1;
   ae_int_t nx;
   ae_int_t ny;
   nx = s->nx;
   ny = s->ny;
// Leaf node.
   if (s->kdnodes.xZ[rootidx] > 0) {
      cwcnt = s->kdnodes.xZ[rootidx + 0];
      cwoffs = s->kdnodes.xZ[rootidx + 1];
      for (i0 = 0; i0 < cwcnt; i0++) {
      // Calculate partial distance (components from 1 to NX-1)
         itemoffs = cwoffs + i0 * (nx + ny);
         partialptdist2 = 0.0;
         for (j = 1; j < nx; j++) {
            v = s->cw.xR[itemoffs + j] - cx->xR[j];
            partialptdist2 += v * v;
         }
      // Process each element of the row
         for (i1 = 0; i1 < rowsize; i1++) {
            if (rf->xB[i1]) {
            // Calculate distance
               v = s->cw.xR[itemoffs] - rx->xR[i1];
               ptdist2 = partialptdist2 + v * v;
            // Skip points if distance too large
               if (ptdist2 >= rfar2) {
                  continue;
               }
            // Update Y
               val = rbfv2basisfunc(s->bf, ptdist2 * invr2, _state);
               woffs = itemoffs + nx;
               for (j = 0; j < ny; j++) {
                  ry->xR[j + i1 * ny] += val * s->cw.xR[woffs + j];
               }
            }
         }
      }
      return;
   }
// Simple split
   if (s->kdnodes.xZ[rootidx] == 0) {
   // Load:
   // * D      dimension to split
   // * Split  split position
   // * ChildLE, ChildGE - indexes of childs
      d = s->kdnodes.xZ[rootidx + 1];
      split = s->kdsplits.xR[s->kdnodes.xZ[rootidx + 2]];
      childle = s->kdnodes.xZ[rootidx + 3];
      childge = s->kdnodes.xZ[rootidx + 4];
   // Navigate through childs
      for (i = 0; i <= 1; i++) {
      // Select child to process:
      // * ChildOffs      current child offset in Nodes[]
      // * UpdateMin      whether minimum or maximum value
      //                  of bounding box is changed on update
         updatemin = i != 0;
         if (i == 0) {
            childoffs = childle;
         } else {
            childoffs = childge;
         }
      // Update bounding box and current distance
         prevdist2 = buf->curdist2;
         t1 = cx->xR[d];
         if (updatemin) {
            v = buf->curboxmin.xR[d];
            if (t1 <= split) {
               v0 = v - t1;
               if (v0 < 0) {
                  v0 = 0.0;
               }
               v1 = split - t1;
               buf->curdist2 -= v0 * v0 - v1 * v1;
            }
            buf->curboxmin.xR[d] = split;
         } else {
            v = buf->curboxmax.xR[d];
            if (t1 >= split) {
               v0 = t1 - v;
               if (v0 < 0) {
                  v0 = 0.0;
               }
               v1 = t1 - split;
               buf->curdist2 -= v0 * v0 - v1 * v1;
            }
            buf->curboxmax.xR[d] = split;
         }
      // Decide: to dive into cell or not to dive
         if (buf->curdist2 < rquery2) {
            rbfv2_partialrowcalcrec(s, buf, childoffs, invr2, rquery2, rfar2, cx, rx, rf, rowsize, ry, _state);
         }
      // Restore bounding box and distance
         if (updatemin) {
            buf->curboxmin.xR[d] = v;
         } else {
            buf->curboxmax.xR[d] = v;
         }
         buf->curdist2 = prevdist2;
      }
      return;
   }
// Integrity failure
   ae_assert(false, "PartialCalcRec: integrity check failed", _state);
}

// This function prepares partial query
//
// Inputs:
//     X       -   query point
//     kdBoxMin, kdBoxMax - current bounding box
//     NX      -   problem size
//     Buf     -   preallocated buffer; this function just loads data, but
//                 does not allocate place for them.
//     Cnt     -   counter variable which is set to zery by this function, as
//                 convenience, and to remember about necessity to zero counter
//                 prior to calling partialqueryrec().
//
// Outputs:
//     Buf     -   calc-buffer:
//                 * Buf.CurBoxMin - current box
//                 * Buf.CurBoxMax - current box
//                 * Buf.CurDist2  - squared distance from X to current box
//     Cnt     -   set to zero
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static void rbfv2_preparepartialquery(RVector *x, RVector *kdboxmin, RVector *kdboxmax, ae_int_t nx, rbfv2calcbuffer *buf, ae_int_t *cnt, ae_state *_state) {
   ae_int_t j;
   *cnt = 0;
   buf->curdist2 = 0.0;
   for (j = 0; j < nx; j++) {
      buf->curboxmin.xR[j] = kdboxmin->xR[j];
      buf->curboxmax.xR[j] = kdboxmax->xR[j];
      if (x->xR[j] < buf->curboxmin.xR[j]) {
         buf->curdist2 += sqr(buf->curboxmin.xR[j] - x->xR[j], _state);
      } else {
         if (x->xR[j] > buf->curboxmax.xR[j]) {
            buf->curdist2 += sqr(x->xR[j] - buf->curboxmax.xR[j], _state);
         }
      }
   }
}

// This function performs partial (for just one subtree of multi-tree)  query
// for neighbors located in R-sphere around X. It returns  squared  distances
// from X to points and offsets in S.CW[] array for points being found.
//
// Inputs:
//     kdNodes, kdSplits, CW, NX, NY - corresponding fields of V2 model
//     Buf     -   calc-buffer, this function uses following fields:
//                 * Buf.CurBoxMin - should be set by caller
//                 * Buf.CurBoxMax - should be set by caller
//                 * Buf.CurDist2  - squared distance from X to current
//                   bounding box, should be set by caller
//                 You may use preparepartialquery() function to initialize
//                 these fields.
//     RootIdx -   offset of partial kd-tree
//     QueryR2 -   squared query radius
//     X       -   array[NX], point being queried
//     R2      -   preallocated output buffer; it is caller's responsibility
//                 to make sure that R2 has enough space.
//     Offs    -   preallocated output buffer; it is caller's responsibility
//                 to make sure that Offs has enough space.
//     K       -   MUST BE ZERO ON INITIAL CALL. This variable is incremented,
//                 not set. So, any no-zero value will result in the incorrect
//                 points count being returned.
//
// Outputs:
//     R2      -   squared distances in first K elements
//     Offs    -   offsets in S.CW in first K elements
//     K       -   points count
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static void rbfv2_partialqueryrec(ZVector *kdnodes, RVector *kdsplits, RVector *cw, ae_int_t nx, ae_int_t ny, rbfv2calcbuffer *buf, ae_int_t rootidx, double queryr2, RVector *x, RVector *r2, ZVector *offs, ae_int_t *k, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   double ptdist2;
   double v;
   ae_int_t cwoffs;
   ae_int_t cwcnt;
   ae_int_t itemoffs;
   ae_int_t d;
   double split;
   ae_int_t childle;
   ae_int_t childge;
   ae_int_t childoffs;
   bool updatemin;
   double prevdist2;
   double t1;
// Leaf node.
   if (kdnodes->xZ[rootidx] > 0) {
      cwcnt = kdnodes->xZ[rootidx + 0];
      cwoffs = kdnodes->xZ[rootidx + 1];
      for (i = 0; i < cwcnt; i++) {
      // Calculate distance
         itemoffs = cwoffs + i * (nx + ny);
         ptdist2 = 0.0;
         for (j = 0; j < nx; j++) {
            v = cw->xR[itemoffs + j] - x->xR[j];
            ptdist2 += v * v;
         }
      // Skip points if distance too large
         if (ptdist2 >= queryr2) {
            continue;
         }
      // Output
         r2->xR[*k] = ptdist2;
         offs->xZ[*k] = itemoffs;
         ++*k;
      }
      return;
   }
// Simple split
   if (kdnodes->xZ[rootidx] == 0) {
   // Load:
   // * D      dimension to split
   // * Split  split position
   // * ChildLE, ChildGE - indexes of childs
      d = kdnodes->xZ[rootidx + 1];
      split = kdsplits->xR[kdnodes->xZ[rootidx + 2]];
      childle = kdnodes->xZ[rootidx + 3];
      childge = kdnodes->xZ[rootidx + 4];
   // Navigate through childs
      for (i = 0; i <= 1; i++) {
      // Select child to process:
      // * ChildOffs      current child offset in Nodes[]
      // * UpdateMin      whether minimum or maximum value
      //                  of bounding box is changed on update
         updatemin = i != 0;
         if (i == 0) {
            childoffs = childle;
         } else {
            childoffs = childge;
         }
      // Update bounding box and current distance
         prevdist2 = buf->curdist2;
         t1 = x->xR[d];
         if (updatemin) {
            v = buf->curboxmin.xR[d];
            if (t1 <= split) {
               buf->curdist2 -= sqr(maxreal(v - t1, 0.0, _state), _state) - sqr(split - t1, _state);
            }
            buf->curboxmin.xR[d] = split;
         } else {
            v = buf->curboxmax.xR[d];
            if (t1 >= split) {
               buf->curdist2 -= sqr(maxreal(t1 - v, 0.0, _state), _state) - sqr(t1 - split, _state);
            }
            buf->curboxmax.xR[d] = split;
         }
      // Decide: to dive into cell or not to dive
         if (buf->curdist2 < queryr2) {
            rbfv2_partialqueryrec(kdnodes, kdsplits, cw, nx, ny, buf, childoffs, queryr2, x, r2, offs, k, _state);
         }
      // Restore bounding box and distance
         if (updatemin) {
            buf->curboxmin.xR[d] = v;
         } else {
            buf->curboxmax.xR[d] = v;
         }
         buf->curdist2 = prevdist2;
      }
      return;
   }
// Integrity failure
   ae_assert(false, "PartialQueryRec: integrity check failed", _state);
}

// This function performs  partial  (for  just  one  subtree  of  multi-tree)
// counting of neighbors located in R-sphere around X.
//
// This function does not guarantee consistency of results with other partial
// queries, it should be used only to get approximate estimates (well, we  do
// not  use   approximate   algorithms,  but  rounding  errors  may  give  us
// inconsistent results in just-at-the-boundary cases).
//
// Inputs:
//     kdNodes, kdSplits, CW, NX, NY - corresponding fields of V2 model
//     Buf     -   calc-buffer, this function uses following fields:
//                 * Buf.CurBoxMin - should be set by caller
//                 * Buf.CurBoxMax - should be set by caller
//                 * Buf.CurDist2  - squared distance from X to current
//                   bounding box, should be set by caller
//                 You may use preparepartialquery() function to initialize
//                 these fields.
//     RootIdx -   offset of partial kd-tree
//     QueryR2 -   squared query radius
//     X       -   array[NX], point being queried
//
// Result:
//     points count
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static ae_int_t rbfv2_partialcountrec(ZVector *kdnodes, RVector *kdsplits, RVector *cw, ae_int_t nx, ae_int_t ny, rbfv2calcbuffer *buf, ae_int_t rootidx, double queryr2, RVector *x, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   double ptdist2;
   double v;
   ae_int_t cwoffs;
   ae_int_t cwcnt;
   ae_int_t itemoffs;
   ae_int_t d;
   double split;
   ae_int_t childle;
   ae_int_t childge;
   ae_int_t childoffs;
   bool updatemin;
   double prevdist2;
   double t1;
   ae_int_t result;
   result = 0;
// Leaf node.
   if (kdnodes->xZ[rootidx] > 0) {
      cwcnt = kdnodes->xZ[rootidx + 0];
      cwoffs = kdnodes->xZ[rootidx + 1];
      for (i = 0; i < cwcnt; i++) {
      // Calculate distance
         itemoffs = cwoffs + i * (nx + ny);
         ptdist2 = 0.0;
         for (j = 0; j < nx; j++) {
            v = cw->xR[itemoffs + j] - x->xR[j];
            ptdist2 += v * v;
         }
      // Skip points if distance too large
         if (ptdist2 >= queryr2) {
            continue;
         }
      // Output
         result++;
      }
      return result;
   }
// Simple split
   if (kdnodes->xZ[rootidx] == 0) {
   // Load:
   // * D      dimension to split
   // * Split  split position
   // * ChildLE, ChildGE - indexes of childs
      d = kdnodes->xZ[rootidx + 1];
      split = kdsplits->xR[kdnodes->xZ[rootidx + 2]];
      childle = kdnodes->xZ[rootidx + 3];
      childge = kdnodes->xZ[rootidx + 4];
   // Navigate through childs
      for (i = 0; i <= 1; i++) {
      // Select child to process:
      // * ChildOffs      current child offset in Nodes[]
      // * UpdateMin      whether minimum or maximum value
      //                  of bounding box is changed on update
         updatemin = i != 0;
         if (i == 0) {
            childoffs = childle;
         } else {
            childoffs = childge;
         }
      // Update bounding box and current distance
         prevdist2 = buf->curdist2;
         t1 = x->xR[d];
         if (updatemin) {
            v = buf->curboxmin.xR[d];
            if (t1 <= split) {
               buf->curdist2 -= sqr(maxreal(v - t1, 0.0, _state), _state) - sqr(split - t1, _state);
            }
            buf->curboxmin.xR[d] = split;
         } else {
            v = buf->curboxmax.xR[d];
            if (t1 >= split) {
               buf->curdist2 -= sqr(maxreal(t1 - v, 0.0, _state), _state) - sqr(t1 - split, _state);
            }
            buf->curboxmax.xR[d] = split;
         }
      // Decide: to dive into cell or not to dive
         if (buf->curdist2 < queryr2) {
            result += rbfv2_partialcountrec(kdnodes, kdsplits, cw, nx, ny, buf, childoffs, queryr2, x, _state);
         }
      // Restore bounding box and distance
         if (updatemin) {
            buf->curboxmin.xR[d] = v;
         } else {
            buf->curboxmax.xR[d] = v;
         }
         buf->curdist2 = prevdist2;
      }
      return result;
   }
// Integrity failure
   ae_assert(false, "PartialCountRec: integrity check failed", _state);
   return result;
}

// This function performs partial (for just one subtree of multi-tree) unpack
// for RBF model. It appends center coordinates,  weights  and  per-dimension
// radii (according to current scaling) to preallocated output array.
//
// Inputs:
//     kdNodes, kdSplits, CW, S, NX, NY - corresponding fields of V2 model
//     RootIdx -   offset of partial kd-tree
//     R       -   radius for current partial tree
//     XWR     -   preallocated output buffer; it is caller's responsibility
//                 to make sure that XWR has enough space. First K rows are
//                 already occupied.
//     K       -   number of already occupied rows in XWR.
//
// Outputs:
//     XWR     -   updated XWR
//     K       -   updated rows count
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static void rbfv2_partialunpackrec(ZVector *kdnodes, RVector *kdsplits, RVector *cw, RVector *s, ae_int_t nx, ae_int_t ny, ae_int_t rootidx, double r, RMatrix *xwr, ae_int_t *k, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t childle;
   ae_int_t childge;
   ae_int_t itemoffs;
   ae_int_t cwoffs;
   ae_int_t cwcnt;
// Leaf node.
   if (kdnodes->xZ[rootidx] > 0) {
      cwcnt = kdnodes->xZ[rootidx + 0];
      cwoffs = kdnodes->xZ[rootidx + 1];
      for (i = 0; i < cwcnt; i++) {
         itemoffs = cwoffs + i * (nx + ny);
         for (j = 0; j < nx + ny; j++) {
            xwr->xyR[*k][j] = cw->xR[itemoffs + j];
         }
         for (j = 0; j < nx; j++) {
            xwr->xyR[*k][j] *= s->xR[j];
         }
         for (j = 0; j < nx; j++) {
            xwr->xyR[*k][nx + ny + j] = r * s->xR[j];
         }
         ++*k;
      }
      return;
   }
// Simple split
   if (kdnodes->xZ[rootidx] == 0) {
   // Load:
   // * ChildLE, ChildGE - indexes of childs
      childle = kdnodes->xZ[rootidx + 3];
      childge = kdnodes->xZ[rootidx + 4];
   // Process both parts of split
      rbfv2_partialunpackrec(kdnodes, kdsplits, cw, s, nx, ny, childle, r, xwr, k, _state);
      rbfv2_partialunpackrec(kdnodes, kdsplits, cw, s, nx, ny, childge, r, xwr, k, _state);
      return;
   }
// Integrity failure
   ae_assert(false, "PartialUnpackRec: integrity check failed", _state);
}

// This function returns size of design matrix row for evaluation point X0,
// given:
// * query radius multiplier (either RBFV2NearRadius() or RBFV2FarRadius())
// * hierarchy level: value in [0,NH) for single-level model, or negative
//   value for multilevel model (all levels of hierarchy in single matrix,
//   like one used by nonnegative RBF)
//
// Inputs:
//     kdNodes, kdSplits, CW, Ri, kdRoots, kdBoxMin, kdBoxMax, NX, NY, NH - corresponding fields of V2 model
//     Level   -   value in [0,NH) for single-level design matrix, negative
//                 value for multilevel design matrix
//     RCoeff  -   radius coefficient, either RBFV2NearRadius() or RBFV2FarRadius()
//     X0      -   query point
//     CalcBuf -   buffer for PreparePartialQuery(), allocated by caller
//
// Result:
//     row size
// ALGLIB: Copyright 28.09.2016 by Sergey Bochkanov
static ae_int_t rbfv2_designmatrixrowsize(ZVector *kdnodes, RVector *kdsplits, RVector *cw, RVector *ri, ZVector *kdroots, RVector *kdboxmin, RVector *kdboxmax, ae_int_t nx, ae_int_t ny, ae_int_t nh, ae_int_t level, double rcoeff, RVector *x0, rbfv2calcbuffer *calcbuf, ae_state *_state) {
   ae_int_t dummy;
   ae_int_t levelidx;
   ae_int_t level0;
   ae_int_t level1;
   double curradius2;
   ae_int_t result;
   ae_assert(nh > 0, "DesignMatrixRowSize: integrity failure", _state);
   if (level >= 0) {
      level0 = level;
      level1 = level;
   } else {
      level0 = 0;
      level1 = nh - 1;
   }
   result = 0;
   for (levelidx = level0; levelidx <= level1; levelidx++) {
      curradius2 = sqr(ri->xR[levelidx] * rcoeff, _state);
      rbfv2_preparepartialquery(x0, kdboxmin, kdboxmax, nx, calcbuf, &dummy, _state);
      result += rbfv2_partialcountrec(kdnodes, kdsplits, cw, nx, ny, calcbuf, kdroots->xZ[levelidx], curradius2, x0, _state);
   }
   return result;
}

// This function generates design matrix row for evaluation point X0, given:
// * query radius multiplier (either RBFV2NearRadius() or RBFV2FarRadius())
// * hierarchy level: value in [0,NH) for single-level model, or negative
//   value for multilevel model (all levels of hierarchy in single matrix,
//   like one used by nonnegative RBF)
//
// Inputs:
//     kdNodes, kdSplits, CW, Ri, kdRoots, kdBoxMin, kdBoxMax, NX, NY, NH - corresponding fields of V2 model
//
//     CWRange -   internal array[NH+1] used by RBF construction function,
//                 stores ranges of CW occupied by NH trees.
//     Level   -   value in [0,NH) for single-level design matrix, negative
//                 value for multilevel design matrix
//     BF      -   basis function type
//     RCoeff  -   radius coefficient, either RBFV2NearRadius() or RBFV2FarRadius()
//     RowsPerPoint-equal to:
//                 * 1 for unpenalized regression model
//                 * 1+NX for basic form of nonsmoothness penalty
//     Penalty -   nonsmoothness penalty coefficient
//
//     X0      -   query point
//
//     CalcBuf -   buffer for PreparePartialQuery(), allocated by caller
//     R2      -   preallocated temporary buffer, size is at least NPoints;
//                 it is caller's responsibility to make sure that R2 has enough space.
//     Offs    -   preallocated temporary buffer; size is at least NPoints;
//                 it is caller's responsibility to make sure that Offs has enough space.
//     K       -   MUST BE ZERO ON INITIAL CALL. This variable is incremented,
//                 not set. So, any no-zero value will result in the incorrect
//                 points count being returned.
//     RowIdx  -   preallocated array, at least RowSize elements
//     RowVal  -   preallocated array, at least RowSize*RowsPerPoint elements
//
// Result:
//     RowIdx  -   RowSize elements are filled with column indexes of non-zero
//                 design matrix entries
//     RowVal  -   RowSize*RowsPerPoint elements are filled with design matrix
//                 values, with column RowIdx[0] being stored in first RowsPerPoint
//                 elements of RowVal, column RowIdx[1] being stored in next
//                 RowsPerPoint elements, and so on.
//
//                 First element in contiguous set of RowsPerPoint elements
//                 corresponds to
//
//     RowSize -   number of columns per row
// ALGLIB: Copyright 28.09.2016 by Sergey Bochkanov
static void rbfv2_designmatrixgeneraterow(ZVector *kdnodes, RVector *kdsplits, RVector *cw, RVector *ri, ZVector *kdroots, RVector *kdboxmin, RVector *kdboxmax, ZVector *cwrange, ae_int_t nx, ae_int_t ny, ae_int_t nh, ae_int_t level, ae_int_t bf, double rcoeff, ae_int_t rowsperpoint, double penalty, RVector *x0, rbfv2calcbuffer *calcbuf, RVector *tmpr2, ZVector *tmpoffs, ZVector *rowidx, RVector *rowval, ae_int_t *rowsize, ae_state *_state) {
   ae_int_t j;
   ae_int_t k;
   ae_int_t cnt;
   ae_int_t levelidx;
   ae_int_t level0;
   ae_int_t level1;
   double invri2;
   double curradius2;
   double val;
   double dval;
   double d2val;
   *rowsize = 0;
   ae_assert(nh > 0, "DesignMatrixGenerateRow: integrity failure (a)", _state);
   ae_assert(rowsperpoint == 1 || rowsperpoint == 1 + nx, "DesignMatrixGenerateRow: integrity failure (b)", _state);
   if (level >= 0) {
      level0 = level;
      level1 = level;
   } else {
      level0 = 0;
      level1 = nh - 1;
   }
   *rowsize = 0;
   for (levelidx = level0; levelidx <= level1; levelidx++) {
      curradius2 = sqr(ri->xR[levelidx] * rcoeff, _state);
      invri2 = 1 / sqr(ri->xR[levelidx], _state);
      rbfv2_preparepartialquery(x0, kdboxmin, kdboxmax, nx, calcbuf, &cnt, _state);
      rbfv2_partialqueryrec(kdnodes, kdsplits, cw, nx, ny, calcbuf, kdroots->xZ[levelidx], curradius2, x0, tmpr2, tmpoffs, &cnt, _state);
      ae_assert(tmpr2->cnt >= cnt, "DesignMatrixRowSize: integrity failure (c)", _state);
      ae_assert(tmpoffs->cnt >= cnt, "DesignMatrixRowSize: integrity failure (d)", _state);
      ae_assert(rowidx->cnt >= *rowsize + cnt, "DesignMatrixRowSize: integrity failure (e)", _state);
      ae_assert(rowval->cnt >= rowsperpoint * (*rowsize + cnt), "DesignMatrixRowSize: integrity failure (f)", _state);
      for (j = 0; j < cnt; j++) {
      // Generate element corresponding to fitting error.
      // Store derivative information which may be required later.
         ae_assert((tmpoffs->xZ[j] - cwrange->xZ[level0]) % (nx + ny) == 0, "DesignMatrixRowSize: integrity failure (g)", _state);
         rbfv2basisfuncdiff2(bf, tmpr2->xR[j] * invri2, &val, &dval, &d2val, _state);
         rowidx->xZ[*rowsize + j] = (tmpoffs->xZ[j] - cwrange->xZ[level0]) / (nx + ny);
         rowval->xR[(*rowsize + j) * rowsperpoint + 0] = val;
         if (rowsperpoint == 1) {
            continue;
         }
      // Generate elements corresponding to nonsmoothness penalty
         ae_assert(rowsperpoint == 1 + nx, "DesignMatrixRowSize: integrity failure (h)", _state);
         for (k = 0; k < nx; k++) {
            rowval->xR[(*rowsize + j) * rowsperpoint + 1 + k] = penalty * (dval * 2 * invri2 + d2val * sqr(2 * (x0->xR[k] - cw->xR[tmpoffs->xZ[j] + k]) * invri2, _state));
         }
      }
   // Update columns counter
      *rowsize += cnt;
   }
}

static bool rbfv2_rbfv2buildlinearmodel(RMatrix *x, RMatrix *y, ae_int_t n, ae_int_t nx, ae_int_t ny, ae_int_t modeltype, RMatrix *v, ae_state *_state) {
   ae_frame _frame_block;
   double scaling;
   double mn;
   double mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t info;
   bool result;
   ae_frame_make(_state, &_frame_block);
   SetMatrix(v);
   NewVector(tmpy, 0, DT_REAL, _state);
   NewMatrix(a, 0, 0, DT_REAL, _state);
   NewVector(shifting, 0, DT_REAL, _state);
   NewVector(c, 0, DT_REAL, _state);
   NewObj(lsfitreport, rep, _state);
   ae_assert(n >= 0, "BuildLinearModel: N<0", _state);
   ae_assert(nx > 0, "BuildLinearModel: NX <= 0", _state);
   ae_assert(ny > 0, "BuildLinearModel: NY <= 0", _state);
// Handle degenerate case (N=0)
   result = true;
   ae_matrix_set_length(v, ny, nx + 1, _state);
   if (n == 0) {
      for (j = 0; j <= nx; j++) {
         for (i = 0; i < ny; i++) {
            v->xyR[i][j] = 0.0;
         }
      }
      ae_frame_leave(_state);
      return result;
   }
// Allocate temporaries
   ae_vector_set_length(&tmpy, n, _state);
// General linear model.
   if (modeltype == 1) {
   // Calculate scaling/shifting, transform variables, prepare LLS problem
      ae_matrix_set_length(&a, n, nx + 1, _state);
      ae_vector_set_length(&shifting, nx, _state);
      scaling = 0.0;
      for (i = 0; i < nx; i++) {
         mn = x->xyR[0][i];
         mx = mn;
         for (j = 1; j < n; j++) {
            if (mn > x->xyR[j][i]) {
               mn = x->xyR[j][i];
            }
            if (mx < x->xyR[j][i]) {
               mx = x->xyR[j][i];
            }
         }
         scaling = maxreal(scaling, mx - mn, _state);
         shifting.xR[i] = 0.5 * (mx + mn);
      }
      if (scaling == 0.0) {
         scaling = 1.0;
      } else {
         scaling *= 0.5;
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < nx; j++) {
            a.xyR[i][j] = (x->xyR[i][j] - shifting.xR[j]) / scaling;
         }
      }
      for (i = 0; i < n; i++) {
         a.xyR[i][nx] = 1.0;
      }
   // Solve linear system in transformed variables, make backward
      for (i = 0; i < ny; i++) {
         for (j = 0; j < n; j++) {
            tmpy.xR[j] = y->xyR[j][i];
         }
         lsfitlinear(&tmpy, &a, n, nx + 1, &info, &c, &rep, _state);
         if (info <= 0) {
            result = false;
            ae_frame_leave(_state);
            return result;
         }
         for (j = 0; j < nx; j++) {
            v->xyR[i][j] = c.xR[j] / scaling;
         }
         v->xyR[i][nx] = c.xR[nx];
         for (j = 0; j < nx; j++) {
            v->xyR[i][nx] -= shifting.xR[j] * v->xyR[i][j];
         }
         for (j = 0; j < n; j++) {
            for (k = 0; k < nx; k++) {
               y->xyR[j][i] -= x->xyR[j][k] * v->xyR[i][k];
            }
            y->xyR[j][i] -= v->xyR[i][nx];
         }
      }
      ae_frame_leave(_state);
      return result;
   }
// Constant model, very simple
   if (modeltype == 2) {
      for (i = 0; i < ny; i++) {
         for (j = 0; j <= nx; j++) {
            v->xyR[i][j] = 0.0;
         }
         for (j = 0; j < n; j++) {
            v->xyR[i][nx] += y->xyR[j][i];
         }
         if (n > 0) {
            v->xyR[i][nx] /= n;
         }
         for (j = 0; j < n; j++) {
            y->xyR[j][i] -= v->xyR[i][nx];
         }
      }
      ae_frame_leave(_state);
      return result;
   }
// Zero model
   ae_assert(modeltype == 3, "BuildLinearModel: unknown model type", _state);
   for (i = 0; i < ny; i++) {
      for (j = 0; j <= nx; j++) {
         v->xyR[i][j] = 0.0;
      }
   }
   ae_frame_leave(_state);
   return result;
}

// This function fills RBF model by zeros.
// ALGLIB: Copyright 17.11.2018 by Sergey Bochkanov
static void rbfv2_zerofill(rbfv2model *s, ae_int_t nx, ae_int_t ny, ae_int_t bf, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   s->bf = bf;
   s->nh = 0;
   ae_vector_set_length(&s->ri, 0, _state);
   ae_vector_set_length(&s->s, 0, _state);
   ae_vector_set_length(&s->kdroots, 0, _state);
   ae_vector_set_length(&s->kdnodes, 0, _state);
   ae_vector_set_length(&s->kdsplits, 0, _state);
   ae_vector_set_length(&s->kdboxmin, 0, _state);
   ae_vector_set_length(&s->kdboxmax, 0, _state);
   ae_vector_set_length(&s->cw, 0, _state);
   ae_matrix_set_length(&s->v, ny, nx + 1, _state);
   for (i = 0; i < ny; i++) {
      for (j = 0; j <= nx; j++) {
         s->v.xyR[i][j] = 0.0;
      }
   }
}

// This   function  builds hierarchical RBF model.
//
// Inputs:
//     X       -   array[N,S.NX], X-values
//     Y       -   array[N,S.NY], Y-values
//     ScaleVec-   array[S.NX], vector of per-dimension scales
//     N       -   points count
//     ATerm   -   linear term type, 1 for linear, 2 for constant, 3 for zero.
//     NH      -   hierarchy height
//     RBase   -   base RBF radius
//     BF      -   basis function type: 0 for Gaussian, 1 for compact
//     LambdaNS-   non-smoothness penalty coefficient. Exactly zero value means
//                 that no penalty is applied, and even system matrix does not
//                 contain penalty-related rows. Value of 1 means
//     S       -   RBF model, initialized by RBFCreate() call.
//     progress10000- variable used for progress reports, it is regularly set
//                 to the current progress multiplied by 10000, in order to
//                 get value in [0,10000] range. The rationale for such scaling
//                 is that it allows us to use integer type to store progress,
//                 which has less potential for non-atomic corruption on unprotected
//                 reads from another threads.
//                 You can read this variable from some other thread to get
//                 estimate of the current progress.
//                 Initial value of this variable is ignored, it is written by
//                 this function, but not read.
//     terminationrequest - variable used for termination requests; its initial
//                 value must be False, and you can set it to True from some
//                 other thread. This routine regularly checks this variable
//                 and will terminate model construction shortly upon discovering
//                 that termination was requested.
//
// Outputs:
//     S       -   updated model (for rep.terminationtype>0, unchanged otherwise)
//     Rep     -   report:
//                 * Rep.TerminationType:
//                   * -5 - non-distinct basis function centers were detected,
//                          interpolation aborted
//                   * -4 - nonconvergence of the internal SVD solver
//                   *  1 - successful termination
//                   *  8 terminated by user via rbfrequesttermination()
//                 Fields are used for debugging purposes:
//                 * Rep.IterationsCount - iterations count of the LSQR solver
//                 * Rep.NMV - number of matrix-vector products
//                 * Rep.ARows - rows count for the system matrix
//                 * Rep.ACols - columns count for the system matrix
//                 * Rep.ANNZ - number of significantly non-zero elements
//                   (elements above some algorithm-determined threshold)
//
// NOTE:  failure  to  build  model will leave current state of the structure
// unchanged.
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
void rbfv2buildhierarchical(RMatrix *x, RMatrix *y, ae_int_t n, RVector *scalevec, ae_int_t aterm, ae_int_t nh, double rbase, double lambdans, rbfv2model *s, ae_int_t *progress10000, bool *terminationrequest, rbfv2report *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t bf;
   ae_int_t rowsperpoint;
   ae_int_t curn;
   ae_int_t nbasis;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t k2;
   ae_int_t levelidx;
   ae_int_t offsi;
   ae_int_t offsj;
   double val;
   double criticalr;
   ae_int_t cnt;
   double avgdiagata;
   double sumrowsize;
   double rprogress;
   ae_int_t maxits;
   double penalty;
   ae_frame_make(_state, &_frame_block);
   SetObj(rbfv2report, rep);
   NewMatrix(rhs, 0, 0, DT_REAL, _state);
   NewMatrix(residualy, 0, 0, DT_REAL, _state);
   NewMatrix(v, 0, 0, DT_REAL, _state);
   NewVector(hidx, 0, DT_INT, _state);
   NewVector(xr, 0, DT_REAL, _state);
   NewVector(ri, 0, DT_REAL, _state);
   NewVector(kdroots, 0, DT_INT, _state);
   NewVector(kdnodes, 0, DT_INT, _state);
   NewVector(kdsplits, 0, DT_REAL, _state);
   NewVector(kdboxmin, 0, DT_REAL, _state);
   NewVector(kdboxmax, 0, DT_REAL, _state);
   NewVector(cw, 0, DT_REAL, _state);
   NewVector(cwrange, 0, DT_INT, _state);
   NewMatrix(curxy, 0, 0, DT_REAL, _state);
   NewObj(kdtree, curtree, _state);
   NewObj(kdtree, globaltree, _state);
   NewVector(x0, 0, DT_REAL, _state);
   NewVector(x1, 0, DT_REAL, _state);
   NewVector(tags, 0, DT_INT, _state);
   NewVector(dist, 0, DT_REAL, _state);
   NewVector(nncnt, 0, DT_INT, _state);
   NewVector(rowsizes, 0, DT_INT, _state);
   NewVector(diagata, 0, DT_REAL, _state);
   NewVector(prec, 0, DT_REAL, _state);
   NewVector(tmpx, 0, DT_REAL, _state);
   NewVector(avgrowsize, 0, DT_REAL, _state);
   NewObj(linlsqrstate, linstate, _state);
   NewObj(linlsqrreport, lsqrrep, _state);
   NewObj(sparsematrix, sparseacrs, _state);
   NewVector(densew1, 0, DT_REAL, _state);
   NewVector(denseb1, 0, DT_REAL, _state);
   NewObj(rbfv2calcbuffer, calcbuf, _state);
   NewVector(vr2, 0, DT_REAL, _state);
   NewVector(voffs, 0, DT_INT, _state);
   NewVector(rowindexes, 0, DT_INT, _state);
   NewVector(rowvals, 0, DT_REAL, _state);
   ae_assert(s->nx > 0, "RBFV2BuildHierarchical: incorrect NX", _state);
   ae_assert(s->ny > 0, "RBFV2BuildHierarchical: incorrect NY", _state);
   ae_assert(lambdans >= 0.0, "RBFV2BuildHierarchical: incorrect LambdaNS", _state);
   for (j = 0; j < s->nx; j++) {
      ae_assert(scalevec->xR[j] > 0.0, "RBFV2BuildHierarchical: incorrect ScaleVec", _state);
   }
   nx = s->nx;
   ny = s->ny;
   bf = s->basisfunction;
   ae_assert(bf == 0 || bf == 1, "RBFV2BuildHierarchical: incorrect BF", _state);
// Clean up communication and report fields
   *progress10000 = 0;
   rep->maxerror = 0.0;
   rep->rmserror = 0.0;
// Quick exit when we have no points
   if (n == 0) {
      rbfv2_zerofill(s, nx, ny, bf, _state);
      rep->terminationtype = 1;
      *progress10000 = 10000;
      ae_frame_leave(_state);
      return;
   }
// First model in a sequence - linear model.
// Residuals from linear regression are stored in the ResidualY variable
// (used later to build RBF models).
   ae_matrix_set_length(&residualy, n, ny, _state);
   for (i = 0; i < n; i++) {
      for (j = 0; j < ny; j++) {
         residualy.xyR[i][j] = y->xyR[i][j];
      }
   }
   if (!rbfv2_rbfv2buildlinearmodel(x, &residualy, n, nx, ny, aterm, &v, _state)) {
      rbfv2_zerofill(s, nx, ny, bf, _state);
      rep->terminationtype = -5;
      *progress10000 = 10000;
      ae_frame_leave(_state);
      return;
   }
// Handle special case: multilayer model with NLayers=0.
// Quick exit.
   if (nh == 0) {
      rep->terminationtype = 1;
      rbfv2_zerofill(s, nx, ny, bf, _state);
      for (i = 0; i < ny; i++) {
         for (j = 0; j <= nx; j++) {
            s->v.xyR[i][j] = v.xyR[i][j];
         }
      }
      rep->maxerror = 0.0;
      rep->rmserror = 0.0;
      for (i = 0; i < n; i++) {
         for (j = 0; j < ny; j++) {
            rep->maxerror = maxreal(rep->maxerror, ae_fabs(residualy.xyR[i][j], _state), _state);
            rep->rmserror += sqr(residualy.xyR[i][j], _state);
         }
      }
      rep->rmserror = ae_sqrt(rep->rmserror / (n * ny), _state);
      *progress10000 = 10000;
      ae_frame_leave(_state);
      return;
   }
// Penalty coefficient is set to LambdaNS*RBase^2.
//
// We use such normalization because VALUES of radial basis
// functions have roughly unit magnitude, but their DERIVATIVES
// are (roughly) inversely proportional to the radius. Thus,
// without additional scaling, regularization coefficient
// looses invariancy w.r.t. scaling of variables.
   if (lambdans == 0.0) {
      rowsperpoint = 1;
   } else {
   // NOTE: simplified penalty function is used, which does not provide rotation invariance
      rowsperpoint = 1 + nx;
   }
   penalty = lambdans * sqr(rbase, _state);
// Prepare temporary structures
   ae_matrix_set_length(&rhs, n * rowsperpoint, ny, _state);
   ae_matrix_set_length(&curxy, n, nx + ny, _state);
   ae_vector_set_length(&x0, nx, _state);
   ae_vector_set_length(&x1, nx, _state);
   ae_vector_set_length(&tags, n, _state);
   ae_vector_set_length(&dist, n, _state);
   ae_vector_set_length(&vr2, n, _state);
   ae_vector_set_length(&voffs, n, _state);
   ae_vector_set_length(&nncnt, n, _state);
   ae_vector_set_length(&rowsizes, n * rowsperpoint, _state);
   ae_vector_set_length(&denseb1, n * rowsperpoint, _state);
   for (i = 0; i < n * rowsperpoint; i++) {
      for (j = 0; j < ny; j++) {
         rhs.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < nx; j++) {
         curxy.xyR[i][j] = x->xyR[i][j] / scalevec->xR[j];
      }
      for (j = 0; j < ny; j++) {
         rhs.xyR[i * rowsperpoint][j] = residualy.xyR[i][j];
      }
      tags.xZ[i] = i;
   }
   kdtreebuildtagged(&curxy, &tags, n, nx, 0, 2, &globaltree, _state);
// Generate sequence of layer radii.
// Prepare assignment of different levels to points.
   ae_assert(n > 0, "RBFV2BuildHierarchical: integrity check failed", _state);
   ae_vector_set_length(&ri, nh, _state);
   for (levelidx = 0; levelidx < nh; levelidx++) {
      ri.xR[levelidx] = rbase * ae_pow(2.0, (double)-levelidx, _state);
   }
   ae_vector_set_length(&hidx, n, _state);
   ae_vector_set_length(&xr, n, _state);
   for (i = 0; i < n; i++) {
      hidx.xZ[i] = nh;
      xr.xR[i] = maxrealnumber;
      ae_assert(xr.xR[i] > ri.xR[0], "RBFV2BuildHierarchical: integrity check failed", _state);
   }
   for (levelidx = 0; levelidx < nh; levelidx++) {
   // Scan dataset points, for each such point that distance to nearest
   // "support" point is larger than SupportR*Ri[LevelIdx] we:
   // * set distance of current point to 0 (it is support now) and update HIdx
   // * perform R-NN request with radius SupportR*Ri[LevelIdx]
   // * for each point in request update its distance
      criticalr = s->supportr * ri.xR[levelidx];
      for (i = 0; i < n; i++) {
         if (xr.xR[i] > criticalr) {
         // Mark point as support
            ae_assert(hidx.xZ[i] == nh, "RBFV2BuildHierarchical: integrity check failed", _state);
            hidx.xZ[i] = levelidx;
            xr.xR[i] = 0.0;
         // Update neighbors
            for (j = 0; j < nx; j++) {
               x0.xR[j] = x->xyR[i][j] / scalevec->xR[j];
            }
            k = kdtreequeryrnn(&globaltree, &x0, criticalr, true, _state);
            kdtreequeryresultstags(&globaltree, &tags, _state);
            kdtreequeryresultsdistances(&globaltree, &dist, _state);
            for (j = 0; j < k; j++) {
               xr.xR[tags.xZ[j]] = minreal(xr.xR[tags.xZ[j]], dist.xR[j], _state);
            }
         }
      }
   }
// Build multitree (with zero weights) according to hierarchy.
//
// NOTE: this code assumes that during every iteration kdNodes,
//       kdSplits and CW have size which EXACTLY fits their
//       contents, and that these variables are resized at each
//       iteration when we add new hierarchical model.
   ae_vector_set_length(&kdroots, nh + 1, _state);
   ae_vector_set_length(&kdnodes, 0, _state);
   ae_vector_set_length(&kdsplits, 0, _state);
   ae_vector_set_length(&kdboxmin, nx, _state);
   ae_vector_set_length(&kdboxmax, nx, _state);
   ae_vector_set_length(&cw, 0, _state);
   ae_vector_set_length(&cwrange, nh + 1, _state);
   kdtreeexplorebox(&globaltree, &kdboxmin, &kdboxmax, _state);
   cwrange.xZ[0] = 0;
   for (levelidx = 0; levelidx < nh; levelidx++) {
   // Prepare radius and root offset
      kdroots.xZ[levelidx] = kdnodes.cnt;
   // Generate LevelIdx-th tree and append to multi-tree
      curn = 0;
      for (i = 0; i < n; i++) {
         if (hidx.xZ[i] <= levelidx) {
            for (j = 0; j < nx; j++) {
               curxy.xyR[curn][j] = x->xyR[i][j] / scalevec->xR[j];
            }
            for (j = 0; j < ny; j++) {
               curxy.xyR[curn][nx + j] = 0.0;
            }
            inc(&curn, _state);
         }
      }
      ae_assert(curn > 0, "RBFV2BuildHierarchical: integrity check failed", _state);
      kdtreebuild(&curxy, curn, nx, ny, 2, &curtree, _state);
      rbfv2_convertandappendtree(&curtree, curn, nx, ny, &kdnodes, &kdsplits, &cw, _state);
   // Fill entry of CWRange (we assume that length of CW exactly fits its actual size)
      cwrange.xZ[levelidx + 1] = cw.cnt;
   }
   kdroots.xZ[nh] = kdnodes.cnt;
// Prepare buffer and scaled dataset
   rbfv2_allocatecalcbuffer(s, &calcbuf, _state);
   for (i = 0; i < n; i++) {
      for (j = 0; j < nx; j++) {
         curxy.xyR[i][j] = x->xyR[i][j] / scalevec->xR[j];
      }
   }
// Calculate average row sizes for each layer; these values are used
// for smooth progress reporting (it adds some overhead, but in most
// cases - insignificant one).
   rvectorsetlengthatleast(&avgrowsize, nh, _state);
   sumrowsize = 0.0;
   for (levelidx = 0; levelidx < nh; levelidx++) {
      cnt = 0;
      for (i = 0; i < n; i++) {
         for (j = 0; j < nx; j++) {
            x0.xR[j] = curxy.xyR[i][j];
         }
         cnt += rbfv2_designmatrixrowsize(&kdnodes, &kdsplits, &cw, &ri, &kdroots, &kdboxmin, &kdboxmax, nx, ny, nh, levelidx, rbfv2nearradius(bf, _state), &x0, &calcbuf, _state);
      }
      avgrowsize.xR[levelidx] = coalesce((double)cnt, 1.0, _state) / coalesce((double)n, 1.0, _state);
      sumrowsize += avgrowsize.xR[levelidx];
   }
// Build unconstrained model with LSQR solver, applied layer by layer
   for (levelidx = 0; levelidx < nh; levelidx++) {
   // Generate A - matrix of basis functions (near radius is used)
   //
   // NOTE: AvgDiagATA is average value of diagonal element of A^T*A.
   //       It is used to calculate value of Tikhonov regularization
   //       coefficient.
      nbasis = (cwrange.xZ[levelidx + 1] - cwrange.xZ[levelidx]) / (nx + ny);
      ae_assert(cwrange.xZ[levelidx + 1] - cwrange.xZ[levelidx] == nbasis * (nx + ny), "Assertion failed", _state);
      for (i = 0; i < n; i++) {
         for (j = 0; j < nx; j++) {
            x0.xR[j] = curxy.xyR[i][j];
         }
         cnt = rbfv2_designmatrixrowsize(&kdnodes, &kdsplits, &cw, &ri, &kdroots, &kdboxmin, &kdboxmax, nx, ny, nh, levelidx, rbfv2nearradius(bf, _state), &x0, &calcbuf, _state);
         nncnt.xZ[i] = cnt;
         for (j = 0; j < rowsperpoint; j++) {
            rowsizes.xZ[i * rowsperpoint + j] = cnt;
         }
      }
      ivectorsetlengthatleast(&rowindexes, nbasis, _state);
      rvectorsetlengthatleast(&rowvals, nbasis * rowsperpoint, _state);
      rvectorsetlengthatleast(&diagata, nbasis, _state);
      sparsecreatecrsbuf(n * rowsperpoint, nbasis, &rowsizes, &sparseacrs, _state);
      avgdiagata = 0.0;
      for (j = 0; j < nbasis; j++) {
         diagata.xR[j] = 0.0;
      }
      for (i = 0; i < n; i++) {
      // Fill design matrix row, diagonal of A^T*A
         for (j = 0; j < nx; j++) {
            x0.xR[j] = curxy.xyR[i][j];
         }
         rbfv2_designmatrixgeneraterow(&kdnodes, &kdsplits, &cw, &ri, &kdroots, &kdboxmin, &kdboxmax, &cwrange, nx, ny, nh, levelidx, bf, rbfv2nearradius(bf, _state), rowsperpoint, penalty, &x0, &calcbuf, &vr2, &voffs, &rowindexes, &rowvals, &cnt, _state);
         ae_assert(cnt == nncnt.xZ[i], "RBFV2BuildHierarchical: integrity check failed", _state);
         for (k = 0; k < rowsperpoint; k++) {
            for (j = 0; j < cnt; j++) {
               val = rowvals.xR[j * rowsperpoint + k];
               sparseset(&sparseacrs, i * rowsperpoint + k, rowindexes.xZ[j], val, _state);
               avgdiagata += sqr(val, _state);
               diagata.xR[rowindexes.xZ[j]] += sqr(val, _state);
            }
         }
      // Handle possible termination requests
         if (*terminationrequest) {
         // Request for termination was submitted, terminate immediately
            rbfv2_zerofill(s, nx, ny, bf, _state);
            rep->terminationtype = 8;
            *progress10000 = 10000;
            ae_frame_leave(_state);
            return;
         }
      }
      avgdiagata /= nbasis;
      rvectorsetlengthatleast(&prec, nbasis, _state);
      for (j = 0; j < nbasis; j++) {
         prec.xR[j] = 1 / coalesce(ae_sqrt(diagata.xR[j], _state), 1.0, _state);
      }
   // solve
      maxits = coalescei(s->maxits, rbfv2_defaultmaxits, _state);
      rvectorsetlengthatleast(&tmpx, nbasis, _state);
      linlsqrcreate(n * rowsperpoint, nbasis, &linstate, _state);
      linlsqrsetcond(&linstate, 0.0, 0.0, maxits, _state);
      linlsqrsetlambdai(&linstate, ae_sqrt(s->lambdareg * avgdiagata, _state), _state);
      for (j = 0; j < ny; j++) {
         for (i = 0; i < n * rowsperpoint; i++) {
            denseb1.xR[i] = rhs.xyR[i][j];
         }
         linlsqrsetb(&linstate, &denseb1, _state);
         linlsqrrestart(&linstate, _state);
         linlsqrsetxrep(&linstate, true, _state);
         while (linlsqriteration(&linstate, _state)) {
            if (*terminationrequest) {
            // Request for termination was submitted, terminate immediately
               rbfv2_zerofill(s, nx, ny, bf, _state);
               rep->terminationtype = 8;
               *progress10000 = 10000;
               ae_frame_leave(_state);
               return;
            }
            if (linstate.needmv) {
               for (i = 0; i < nbasis; i++) {
                  tmpx.xR[i] = prec.xR[i] * linstate.x.xR[i];
               }
               sparsemv(&sparseacrs, &tmpx, &linstate.mv, _state);
               continue;
            }
            if (linstate.needmtv) {
               sparsemtv(&sparseacrs, &linstate.x, &linstate.mtv, _state);
               for (i = 0; i < nbasis; i++) {
                  linstate.mtv.xR[i] *= prec.xR[i];
               }
               continue;
            }
            if (linstate.xupdated) {
               rprogress = 0.0;
               for (i = 0; i < levelidx; i++) {
                  rprogress += maxits * ny * avgrowsize.xR[i];
               }
               rprogress += (linlsqrpeekiterationscount(&linstate, _state) + j * maxits) * avgrowsize.xR[levelidx];
               rprogress /= sumrowsize * maxits * ny;
               rprogress *= 10000;
               rprogress = maxreal(rprogress, 0.0, _state);
               rprogress = minreal(rprogress, 10000.0, _state);
               ae_assert(*progress10000 <= iround(rprogress, _state) + 1, "HRBF: integrity check failed (progress indicator) even after +1 safeguard correction", _state);
               *progress10000 = iround(rprogress, _state);
               continue;
            }
            ae_assert(false, "HRBF: unexpected request from LSQR solver", _state);
         }
         linlsqrresults(&linstate, &densew1, &lsqrrep, _state);
         ae_assert(lsqrrep.terminationtype > 0, "RBFV2BuildHierarchical: integrity check failed", _state);
         for (i = 0; i < nbasis; i++) {
            densew1.xR[i] *= prec.xR[i];
         }
         for (i = 0; i < nbasis; i++) {
            offsi = cwrange.xZ[levelidx] + (nx + ny) * i;
            cw.xR[offsi + nx + j] = densew1.xR[i];
         }
      }
   // Update residuals (far radius is used)
      for (i = 0; i < n; i++) {
         for (j = 0; j < nx; j++) {
            x0.xR[j] = curxy.xyR[i][j];
         }
         rbfv2_designmatrixgeneraterow(&kdnodes, &kdsplits, &cw, &ri, &kdroots, &kdboxmin, &kdboxmax, &cwrange, nx, ny, nh, levelidx, bf, rbfv2farradius(bf, _state), rowsperpoint, penalty, &x0, &calcbuf, &vr2, &voffs, &rowindexes, &rowvals, &cnt, _state);
         for (j = 0; j < cnt; j++) {
            offsj = cwrange.xZ[levelidx] + (nx + ny) * rowindexes.xZ[j] + nx;
            for (k = 0; k < rowsperpoint; k++) {
               val = rowvals.xR[j * rowsperpoint + k];
               for (k2 = 0; k2 < ny; k2++) {
                  rhs.xyR[i * rowsperpoint + k][k2] -= val * cw.xR[offsj + k2];
               }
            }
         }
      }
   }
// Model is built.
//
// Copy local variables by swapping, global ones (ScaleVec) are copied
// explicitly.
   s->bf = bf;
   s->nh = nh;
   ae_swap_vectors(&s->ri, &ri);
   ae_swap_vectors(&s->kdroots, &kdroots);
   ae_swap_vectors(&s->kdnodes, &kdnodes);
   ae_swap_vectors(&s->kdsplits, &kdsplits);
   ae_swap_vectors(&s->kdboxmin, &kdboxmin);
   ae_swap_vectors(&s->kdboxmax, &kdboxmax);
   ae_swap_vectors(&s->cw, &cw);
   ae_swap_matrices(&s->v, &v);
   ae_vector_set_length(&s->s, nx, _state);
   for (i = 0; i < nx; i++) {
      s->s.xR[i] = scalevec->xR[i];
   }
   rep->terminationtype = 1;
// Calculate maximum and RMS errors
   rep->maxerror = 0.0;
   rep->rmserror = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < ny; j++) {
         rep->maxerror = maxreal(rep->maxerror, ae_fabs(rhs.xyR[i * rowsperpoint][j], _state), _state);
         rep->rmserror += sqr(rhs.xyR[i * rowsperpoint][j], _state);
      }
   }
   rep->rmserror = ae_sqrt(rep->rmserror / (n * ny), _state);
// Update progress reports
   *progress10000 = 10000;
   ae_frame_leave(_state);
}

// This function calculates values of the RBF model at the given point, using
// external  buffer  object  (internal  temporaries  of  RBF  model  are  not
// modified).
//
// This function allows to use same RBF model object  in  different  threads,
// assuming  that  different   threads  use  different  instances  of  buffer
// structure.
//
// Inputs:
//     S       -   RBF model, may be shared between different threads
//     Buf     -   buffer object created for this particular instance of  RBF
//                 model with rbfcreatecalcbuffer().
//     X       -   coordinates, array[NX].
//                 X may have more than NX elements, in this case only
//                 leading NX will be used.
//     Y       -   possibly preallocated array
//
// Outputs:
//     Y       -   function value, array[NY]. Y is not reallocated when it
//                 is larger than NY.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
void rbfv2tscalcbuf(rbfv2model *s, rbfv2calcbuffer *buf, RVector *x, RVector *y, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t levelidx;
   double rcur;
   double rquery2;
   double invrc2;
   ae_int_t nx;
   ae_int_t ny;
   ae_assert(x->cnt >= s->nx, "RBFCalcBuf: Length(X)<NX", _state);
   ae_assert(isfinitevector(x, s->nx, _state), "RBFCalcBuf: X contains infinite or NaN values", _state);
   nx = s->nx;
   ny = s->ny;
// Handle linear term
   if (y->cnt < ny) {
      ae_vector_set_length(y, ny, _state);
   }
   for (i = 0; i < ny; i++) {
      y->xR[i] = s->v.xyR[i][nx];
      for (j = 0; j < nx; j++) {
         y->xR[i] += s->v.xyR[i][j] * x->xR[j];
      }
   }
   if (s->nh == 0) {
      return;
   }
// Handle nonlinear term
   rbfv2_allocatecalcbuffer(s, buf, _state);
   for (j = 0; j < nx; j++) {
      buf->x.xR[j] = x->xR[j] / s->s.xR[j];
   }
   for (levelidx = 0; levelidx < s->nh; levelidx++) {
   // Prepare fields of Buf required by PartialCalcRec()
      buf->curdist2 = 0.0;
      for (j = 0; j < nx; j++) {
         buf->curboxmin.xR[j] = s->kdboxmin.xR[j];
         buf->curboxmax.xR[j] = s->kdboxmax.xR[j];
         if (buf->x.xR[j] < buf->curboxmin.xR[j]) {
            buf->curdist2 += sqr(buf->curboxmin.xR[j] - buf->x.xR[j], _state);
         } else {
            if (buf->x.xR[j] > buf->curboxmax.xR[j]) {
               buf->curdist2 += sqr(buf->x.xR[j] - buf->curboxmax.xR[j], _state);
            }
         }
      }
   // Call PartialCalcRec()
      rcur = s->ri.xR[levelidx];
      invrc2 = 1 / (rcur * rcur);
      rquery2 = sqr(rcur * rbfv2farradius(s->bf, _state), _state);
      rbfv2_partialcalcrec(s, buf, s->kdroots.xZ[levelidx], invrc2, rquery2, &buf->x, y, _state);
   }
}

// This function calculates values of the RBF model at the given point.
//
// Same as RBFCalc(), but does not reallocate Y when in is large enough to
// store function values.
//
// Inputs:
//     S       -   RBF model
//     X       -   coordinates, array[NX].
//                 X may have more than NX elements, in this case only
//                 leading NX will be used.
//     Y       -   possibly preallocated array
//
// Outputs:
//     Y       -   function value, array[NY]. Y is not reallocated when it
//                 is larger than NY.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
void rbfv2calcbuf(rbfv2model *s, RVector *x, RVector *y, ae_state *_state) {
   rbfv2tscalcbuf(s, &s->calcbuf, x, y, _state);
}

// This function calculates values of the RBF model in the given point.
//
// This function should be used when we have NY=1 (scalar function) and  NX=1
// (1-dimensional space).
//
// This function returns 0.0 when:
// * model is not initialized
// * NX != 1
//  *NY != 1
//
// Inputs:
//     S       -   RBF model
//     X0      -   X-coordinate, finite number
//
// Result:
//     value of the model or 0.0 (as defined above)
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
double rbfv2calc1(rbfv2model *s, double x0, ae_state *_state) {
   double result;
   ae_assert(ae_isfinite(x0, _state), "RBFCalc1: invalid value for X0 (X0 is Inf)!", _state);
   if (s->ny != 1 || s->nx != 1) {
      result = 0.0;
      return result;
   }
   result = s->v.xyR[0][0] * x0 - s->v.xyR[0][1];
   if (s->nh == 0) {
      return result;
   }
   rbfv2_allocatecalcbuffer(s, &s->calcbuf, _state);
   s->calcbuf.x123.xR[0] = x0;
   rbfv2tscalcbuf(s, &s->calcbuf, &s->calcbuf.x123, &s->calcbuf.y123, _state);
   result = s->calcbuf.y123.xR[0];
   return result;
}

// This function calculates values of the RBF model in the given point.
//
// This function should be used when we have NY=1 (scalar function) and  NX=2
// (2-dimensional space). If you have 3-dimensional space, use RBFCalc3(). If
// you have general situation (NX-dimensional space, NY-dimensional function)
// you should use general, less efficient implementation RBFCalc().
//
// If  you  want  to  calculate  function  values  many times, consider using
// RBFGridCalc2(), which is far more efficient than many subsequent calls  to
// RBFCalc2().
//
// This function returns 0.0 when:
// * model is not initialized
// * NX != 2
//  *NY != 1
//
// Inputs:
//     S       -   RBF model
//     X0      -   first coordinate, finite number
//     X1      -   second coordinate, finite number
//
// Result:
//     value of the model or 0.0 (as defined above)
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
double rbfv2calc2(rbfv2model *s, double x0, double x1, ae_state *_state) {
   double result;
   ae_assert(ae_isfinite(x0, _state), "RBFCalc2: invalid value for X0 (X0 is Inf)!", _state);
   ae_assert(ae_isfinite(x1, _state), "RBFCalc2: invalid value for X1 (X1 is Inf)!", _state);
   if (s->ny != 1 || s->nx != 2) {
      result = 0.0;
      return result;
   }
   result = s->v.xyR[0][0] * x0 + s->v.xyR[0][1] * x1 + s->v.xyR[0][2];
   if (s->nh == 0) {
      return result;
   }
   rbfv2_allocatecalcbuffer(s, &s->calcbuf, _state);
   s->calcbuf.x123.xR[0] = x0;
   s->calcbuf.x123.xR[1] = x1;
   rbfv2tscalcbuf(s, &s->calcbuf, &s->calcbuf.x123, &s->calcbuf.y123, _state);
   result = s->calcbuf.y123.xR[0];
   return result;
}

// This function calculates values of the RBF model in the given point.
//
// This function should be used when we have NY=1 (scalar function) and  NX=3
// (3-dimensional space). If you have 2-dimensional space, use RBFCalc2(). If
// you have general situation (NX-dimensional space, NY-dimensional function)
// you should use general, less efficient implementation RBFCalc().
//
// This function returns 0.0 when:
// * model is not initialized
// * NX != 3
//  *NY != 1
//
// Inputs:
//     S       -   RBF model
//     X0      -   first coordinate, finite number
//     X1      -   second coordinate, finite number
//     X2      -   third coordinate, finite number
//
// Result:
//     value of the model or 0.0 (as defined above)
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
double rbfv2calc3(rbfv2model *s, double x0, double x1, double x2, ae_state *_state) {
   double result;
   ae_assert(ae_isfinite(x0, _state), "RBFCalc3: invalid value for X0 (X0 is Inf or NaN)!", _state);
   ae_assert(ae_isfinite(x1, _state), "RBFCalc3: invalid value for X1 (X1 is Inf or NaN)!", _state);
   ae_assert(ae_isfinite(x2, _state), "RBFCalc3: invalid value for X2 (X2 is Inf or NaN)!", _state);
   if (s->ny != 1 || s->nx != 3) {
      result = 0.0;
      return result;
   }
   result = s->v.xyR[0][0] * x0 + s->v.xyR[0][1] * x1 + s->v.xyR[0][2] * x2 + s->v.xyR[0][3];
   if (s->nh == 0) {
      return result;
   }
   rbfv2_allocatecalcbuffer(s, &s->calcbuf, _state);
   s->calcbuf.x123.xR[0] = x0;
   s->calcbuf.x123.xR[1] = x1;
   s->calcbuf.x123.xR[2] = x2;
   rbfv2tscalcbuf(s, &s->calcbuf, &s->calcbuf.x123, &s->calcbuf.y123, _state);
   result = s->calcbuf.y123.xR[0];
   return result;
}

void rbfv2partialgridcalcrec(rbfv2model *s, RVector *x0, ae_int_t n0, RVector *x1, ae_int_t n1, RVector *x2, ae_int_t n2, RVector *x3, ae_int_t n3, ZVector *blocks0, ae_int_t block0a, ae_int_t block0b, ZVector *blocks1, ae_int_t block1a, ae_int_t block1b, ZVector *blocks2, ae_int_t block2a, ae_int_t block2b, ZVector *blocks3, ae_int_t block3a, ae_int_t block3b, BVector *flagy, bool sparsey, ae_int_t levelidx, double avgfuncpernode, ae_shared_pool *bufpool, RVector *y, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t k;
   ae_int_t l;
   ae_int_t blkidx;
   ae_int_t blkcnt;
   ae_int_t nodeidx;
   ae_int_t nodescnt;
   ae_int_t rowidx;
   ae_int_t rowscnt;
   ae_int_t i0;
   ae_int_t i1;
   ae_int_t i2;
   ae_int_t i3;
   ae_int_t j0;
   ae_int_t j1;
   ae_int_t j2;
   ae_int_t j3;
   double rcur;
   double invrc2;
   double rquery2;
   double rfar2;
   ae_int_t dstoffs;
   ae_int_t srcoffs;
   ae_int_t dummy;
   double rowwidth;
   double maxrowwidth;
   double problemcost;
   ae_int_t maxbs;
   ae_int_t midpoint;
   bool emptyrow;
   ae_frame_make(_state, &_frame_block);
   RefObj(rbfv2gridcalcbuffer, buf, _state);
   nx = s->nx;
   ny = s->ny;
// Integrity checks
   ae_assert(s->nx == 2 || s->nx == 3, "RBFV2PartialGridCalcRec: integrity check failed", _state);
// Try to split large problem
   problemcost = s->ny * 2 * (avgfuncpernode + 1);
   problemcost *= blocks0->xZ[block0b] - blocks0->xZ[block0a];
   problemcost *= blocks1->xZ[block1b] - blocks1->xZ[block1a];
   problemcost *= blocks2->xZ[block2b] - blocks2->xZ[block2a];
   problemcost *= blocks3->xZ[block3b] - blocks3->xZ[block3a];
   maxbs = 0;
   maxbs = maxint(maxbs, block0b - block0a, _state);
   maxbs = maxint(maxbs, block1b - block1a, _state);
   maxbs = maxint(maxbs, block2b - block2a, _state);
   maxbs = maxint(maxbs, block3b - block3a, _state);
// Parallelism was tried if: problemcost * rbfv2_complexitymultiplier >= smpactivationlevel(_state)
   if (problemcost * rbfv2_complexitymultiplier >= spawnlevel(_state) && maxbs >= 2) {
      if (block0b - block0a == maxbs) {
         midpoint = block0a + maxbs / 2;
         rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, block0a, midpoint, blocks1, block1a, block1b, blocks2, block2a, block2b, blocks3, block3a, block3b, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _state);
         rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, midpoint, block0b, blocks1, block1a, block1b, blocks2, block2a, block2b, blocks3, block3a, block3b, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _state);
         ae_frame_leave(_state);
         return;
      }
      if (block1b - block1a == maxbs) {
         midpoint = block1a + maxbs / 2;
         rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, block0a, block0b, blocks1, block1a, midpoint, blocks2, block2a, block2b, blocks3, block3a, block3b, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _state);
         rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, block0a, block0b, blocks1, midpoint, block1b, blocks2, block2a, block2b, blocks3, block3a, block3b, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _state);
         ae_frame_leave(_state);
         return;
      }
      if (block2b - block2a == maxbs) {
         midpoint = block2a + maxbs / 2;
         rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, block0a, block0b, blocks1, block1a, block1b, blocks2, block2a, midpoint, blocks3, block3a, block3b, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _state);
         rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, block0a, block0b, blocks1, block1a, block1b, blocks2, midpoint, block2b, blocks3, block3a, block3b, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _state);
         ae_frame_leave(_state);
         return;
      }
      if (block3b - block3a == maxbs) {
         midpoint = block3a + maxbs / 2;
         rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, block0a, block0b, blocks1, block1a, block1b, blocks2, block2a, block2b, blocks3, block3a, midpoint, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _state);
         rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, blocks0, block0a, block0b, blocks1, block1a, block1b, blocks2, block2a, block2b, blocks3, midpoint, block3b, flagy, sparsey, levelidx, avgfuncpernode, bufpool, y, _state);
         ae_frame_leave(_state);
         return;
      }
      ae_assert(false, "RBFV2PartialGridCalcRec: integrity check failed", _state);
   }
// Retrieve buffer object from pool (it will be returned later)
   ae_shared_pool_retrieve(bufpool, &_buf, _state);
// Calculate RBF model
   ae_assert(nx <= 4, "RBFV2PartialGridCalcRec: integrity check failed", _state);
   ae_vector_set_length(&buf->tx, 4, _state);
   ae_vector_set_length(&buf->cx, 4, _state);
   ae_vector_set_length(&buf->ty, ny, _state);
   rcur = s->ri.xR[levelidx];
   invrc2 = 1 / (rcur * rcur);
   blkcnt = (block3b - block3a) * (block2b - block2a) * (block1b - block1a) * (block0b - block0a);
   for (blkidx = 0; blkidx < blkcnt; blkidx++) {
   // Select block (I0,I1,I2,I3).
   //
   // NOTE: for problems with NX<4 corresponding I_? are zero.
      k = blkidx;
      i0 = block0a + k % (block0b - block0a);
      k /= block0b - block0a;
      i1 = block1a + k % (block1b - block1a);
      k /= block1b - block1a;
      i2 = block2a + k % (block2b - block2a);
      k /= block2b - block2a;
      i3 = block3a + k % (block3b - block3a);
      k /= block3b - block3a;
      ae_assert(k == 0, "RBFV2PartialGridCalcRec: integrity check failed", _state);
   // We partitioned grid into blocks and selected block with
   // index (I0,I1,I2,I3). This block is a 4D cube (some dimensions
   // may be zero) of nodes with indexes (J0,J1,J2,J3), which is
   // further partitioned into a set of rows, each row corresponding
   // to indexes J1...J3 being fixed.
   //
   // We process block row by row, and each row may be handled
   // by either "generic" (nodes are processed separately) or
   // batch algorithm (that's the reason to use rows, after all).
   //
   //
   // Process nodes of the block
      rowscnt = (blocks3->xZ[i3 + 1] - blocks3->xZ[i3]) * (blocks2->xZ[i2 + 1] - blocks2->xZ[i2]) * (blocks1->xZ[i1 + 1] - blocks1->xZ[i1]);
      for (rowidx = 0; rowidx < rowscnt; rowidx++) {
      // Find out node indexes (*,J1,J2,J3).
      //
      // NOTE: for problems with NX<4 corresponding J_? are zero.
         k = rowidx;
         j1 = blocks1->xZ[i1] + k % (blocks1->xZ[i1 + 1] - blocks1->xZ[i1]);
         k /= blocks1->xZ[i1 + 1] - blocks1->xZ[i1];
         j2 = blocks2->xZ[i2] + k % (blocks2->xZ[i2 + 1] - blocks2->xZ[i2]);
         k /= blocks2->xZ[i2 + 1] - blocks2->xZ[i2];
         j3 = blocks3->xZ[i3] + k % (blocks3->xZ[i3 + 1] - blocks3->xZ[i3]);
         k /= blocks3->xZ[i3 + 1] - blocks3->xZ[i3];
         ae_assert(k == 0, "RBFV2PartialGridCalcRec: integrity check failed", _state);
      // Analyze row, skip completely empty rows
         nodescnt = blocks0->xZ[i0 + 1] - blocks0->xZ[i0];
         srcoffs = blocks0->xZ[i0] + (j1 + (j2 + j3 * n2) * n1) * n0;
         emptyrow = true;
         for (nodeidx = 0; nodeidx < nodescnt; nodeidx++) {
            emptyrow = emptyrow && (sparsey && !flagy->xB[srcoffs + nodeidx]);
         }
         if (emptyrow) {
            continue;
         }
      // Process row - use either "batch" (rowsize>1) or "generic"
      // (row size is 1) algorithm.
      //
      // NOTE: "generic" version may also be used as fallback code for
      //       situations when we do not want to use batch code.
         maxrowwidth = 0.5 * rbfv2nearradius(s->bf, _state) * rcur * s->s.xR[0];
         rowwidth = x0->xR[blocks0->xZ[i0 + 1] - 1] - x0->xR[blocks0->xZ[i0]];
         if (nodescnt > 1 && rowwidth <= maxrowwidth) {
         // "Batch" code which processes entire row at once, saving
         // some time in kd-tree search code.
            rquery2 = sqr(rcur * rbfv2farradius(s->bf, _state) + 0.5 * rowwidth / s->s.xR[0], _state);
            rfar2 = sqr(rcur * rbfv2farradius(s->bf, _state), _state);
            j0 = blocks0->xZ[i0];
            if (nx > 0) {
               buf->cx.xR[0] = (x0->xR[j0] + 0.5 * rowwidth) / s->s.xR[0];
            }
            if (nx > 1) {
               buf->cx.xR[1] = x1->xR[j1] / s->s.xR[1];
            }
            if (nx > 2) {
               buf->cx.xR[2] = x2->xR[j2] / s->s.xR[2];
            }
            if (nx > 3) {
               buf->cx.xR[3] = x3->xR[j3] / s->s.xR[3];
            }
            srcoffs = j0 + (j1 + (j2 + j3 * n2) * n1) * n0;
            dstoffs = ny * srcoffs;
            rvectorsetlengthatleast(&buf->rx, nodescnt, _state);
            bvectorsetlengthatleast(&buf->rf, nodescnt, _state);
            rvectorsetlengthatleast(&buf->ry, nodescnt * ny, _state);
            for (nodeidx = 0; nodeidx < nodescnt; nodeidx++) {
               buf->rx.xR[nodeidx] = x0->xR[j0 + nodeidx] / s->s.xR[0];
               buf->rf.xB[nodeidx] = !sparsey || flagy->xB[srcoffs + nodeidx];
            }
            for (k = 0; k < nodescnt * ny; k++) {
               buf->ry.xR[k] = 0.0;
            }
            rbfv2_preparepartialquery(&buf->cx, &s->kdboxmin, &s->kdboxmax, nx, &buf->calcbuf, &dummy, _state);
            rbfv2_partialrowcalcrec(s, &buf->calcbuf, s->kdroots.xZ[levelidx], invrc2, rquery2, rfar2, &buf->cx, &buf->rx, &buf->rf, nodescnt, &buf->ry, _state);
            for (k = 0; k < nodescnt * ny; k++) {
               y->xR[dstoffs + k] += buf->ry.xR[k];
            }
         } else {
         // "Generic" code. Although we usually move here
         // only when NodesCnt=1, we still use a loop on
         // NodeIdx just to be able to use this branch as
         // fallback code without any modifications.
            rquery2 = sqr(rcur * rbfv2farradius(s->bf, _state), _state);
            for (nodeidx = 0; nodeidx < nodescnt; nodeidx++) {
            // Prepare TX - current point
               j0 = blocks0->xZ[i0] + nodeidx;
               if (nx > 0) {
                  buf->tx.xR[0] = x0->xR[j0] / s->s.xR[0];
               }
               if (nx > 1) {
                  buf->tx.xR[1] = x1->xR[j1] / s->s.xR[1];
               }
               if (nx > 2) {
                  buf->tx.xR[2] = x2->xR[j2] / s->s.xR[2];
               }
               if (nx > 3) {
                  buf->tx.xR[3] = x3->xR[j3] / s->s.xR[3];
               }
            // Evaluate and add to Y
               srcoffs = j0 + (j1 + (j2 + j3 * n2) * n1) * n0;
               dstoffs = ny * srcoffs;
               for (l = 0; l < ny; l++) {
                  buf->ty.xR[l] = 0.0;
               }
               if (!sparsey || flagy->xB[srcoffs]) {
                  rbfv2_preparepartialquery(&buf->tx, &s->kdboxmin, &s->kdboxmax, nx, &buf->calcbuf, &dummy, _state);
                  rbfv2_partialcalcrec(s, &buf->calcbuf, s->kdroots.xZ[levelidx], invrc2, rquery2, &buf->tx, &buf->ty, _state);
               }
               for (l = 0; l < ny; l++) {
                  y->xR[dstoffs + l] += buf->ty.xR[l];
               }
            }
         }
      }
   }
// Recycle buffer object back to pool
   ae_shared_pool_recycle(bufpool, &_buf, _state);
   ae_frame_leave(_state);
}

// This function is used to perform gridded calculation  for  2D,  3D  or  4D
// problems. It accepts parameters X0...X3 and counters N0...N3. If RBF model
// has dimensionality less than 4, corresponding arrays should  contain  just
// one element equal to zero, and corresponding N's should be equal to 1.
//
// NOTE: array Y should be preallocated by caller.
// ALGLIB: Copyright 12.07.2016 by Sergey Bochkanov
void rbfv2gridcalcvx(rbfv2model *s, RVector *x0, ae_int_t n0, RVector *x1, ae_int_t n1, RVector *x2, ae_int_t n2, RVector *x3, ae_int_t n3, BVector *flagy, bool sparsey, RVector *y, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t dstoffs;
   ae_int_t dummy;
   ae_int_t rowidx;
   ae_int_t rowcnt;
   double v;
   double rcur;
   ae_int_t levelidx;
   double searchradius2;
   ae_int_t ntrials;
   double avgfuncpernode;
   ae_int_t blockscnt0;
   ae_int_t blockscnt1;
   ae_int_t blockscnt2;
   ae_int_t blockscnt3;
   double blockwidth0;
   double blockwidth1;
   double blockwidth2;
   double blockwidth3;
   ae_int_t maxblocksize;
   ae_frame_make(_state, &_frame_block);
   NewVector(tx, 0, DT_REAL, _state);
   NewVector(ty, 0, DT_REAL, _state);
   NewVector(z, 0, DT_REAL, _state);
   NewObj(rbfv2gridcalcbuffer, bufseedv2, _state);
   NewObj(ae_shared_pool, bufpool, _state);
   NewObj(hqrndstate, rs, _state);
   NewVector(blocks0, 0, DT_INT, _state);
   NewVector(blocks1, 0, DT_INT, _state);
   NewVector(blocks2, 0, DT_INT, _state);
   NewVector(blocks3, 0, DT_INT, _state);
   nx = s->nx;
   ny = s->ny;
   hqrndseed(532, 54734, &rs, _state);
// Perform integrity checks
   ae_assert(s->nx == 2 || s->nx == 3, "RBFGridCalcVX: integrity check failed", _state);
   ae_assert(s->nx >= 4 || ((x3->cnt >= 1 && x3->xR[0] == 0.0) && n3 == 1), "RBFGridCalcVX: integrity check failed", _state);
   ae_assert(s->nx >= 3 || ((x2->cnt >= 1 && x2->xR[0] == 0.0) && n2 == 1), "RBFGridCalcVX: integrity check failed", _state);
   ae_assert(s->nx >= 2 || ((x1->cnt >= 1 && x1->xR[0] == 0.0) && n1 == 1), "RBFGridCalcVX: integrity check failed", _state);
// Allocate arrays
   ae_assert(s->nx <= 4, "RBFGridCalcVX: integrity check failed", _state);
   ae_vector_set_length(&z, ny, _state);
   ae_vector_set_length(&tx, 4, _state);
   ae_vector_set_length(&ty, ny, _state);
// Calculate linear term
   rowcnt = n1 * n2 * n3;
   for (rowidx = 0; rowidx < rowcnt; rowidx++) {
   // Calculate TX - current position
      k = rowidx;
      tx.xR[0] = 0.0;
      tx.xR[1] = x1->xR[k % n1];
      k /= n1;
      tx.xR[2] = x2->xR[k % n2];
      k /= n2;
      tx.xR[3] = x3->xR[k % n3];
      k /= n3;
      ae_assert(k == 0, "RBFGridCalcVX: integrity check failed", _state);
      for (j = 0; j < ny; j++) {
         v = s->v.xyR[j][nx];
         for (k = 1; k < nx; k++) {
            v += tx.xR[k] * s->v.xyR[j][k];
         }
         z.xR[j] = v;
      }
      for (i = 0; i < n0; i++) {
         dstoffs = ny * (rowidx * n0 + i);
         if (sparsey && !flagy->xB[rowidx * n0 + i]) {
            for (j = 0; j < ny; j++) {
               y->xR[j + dstoffs] = 0.0;
            }
            continue;
         }
         v = x0->xR[i];
         for (j = 0; j < ny; j++) {
            y->xR[j + dstoffs] = z.xR[j] + v * s->v.xyR[j][0];
         }
      }
   }
   if (s->nh == 0) {
      ae_frame_leave(_state);
      return;
   }
// Process RBF terms, layer by layer
   for (levelidx = 0; levelidx < s->nh; levelidx++) {
      rcur = s->ri.xR[levelidx];
      blockwidth0 = 1.0;
      blockwidth1 = 1.0;
      blockwidth2 = 1.0;
      blockwidth3 = 1.0;
      if (nx >= 1) {
         blockwidth0 = rcur * s->s.xR[0];
      }
      if (nx >= 2) {
         blockwidth1 = rcur * s->s.xR[1];
      }
      if (nx >= 3) {
         blockwidth2 = rcur * s->s.xR[2];
      }
      if (nx >= 4) {
         blockwidth3 = rcur * s->s.xR[3];
      }
      maxblocksize = 8;
   // Group grid nodes into blocks according to current radius
      ae_vector_set_length(&blocks0, n0 + 1, _state);
      blockscnt0 = 0;
      blocks0.xZ[0] = 0;
      for (i = 1; i < n0; i++) {
         if (x0->xR[i] - x0->xR[blocks0.xZ[blockscnt0]] > blockwidth0 || i - blocks0.xZ[blockscnt0] >= maxblocksize) {
            inc(&blockscnt0, _state);
            blocks0.xZ[blockscnt0] = i;
         }
      }
      inc(&blockscnt0, _state);
      blocks0.xZ[blockscnt0] = n0;
      ae_vector_set_length(&blocks1, n1 + 1, _state);
      blockscnt1 = 0;
      blocks1.xZ[0] = 0;
      for (i = 1; i < n1; i++) {
         if (x1->xR[i] - x1->xR[blocks1.xZ[blockscnt1]] > blockwidth1 || i - blocks1.xZ[blockscnt1] >= maxblocksize) {
            inc(&blockscnt1, _state);
            blocks1.xZ[blockscnt1] = i;
         }
      }
      inc(&blockscnt1, _state);
      blocks1.xZ[blockscnt1] = n1;
      ae_vector_set_length(&blocks2, n2 + 1, _state);
      blockscnt2 = 0;
      blocks2.xZ[0] = 0;
      for (i = 1; i < n2; i++) {
         if (x2->xR[i] - x2->xR[blocks2.xZ[blockscnt2]] > blockwidth2 || i - blocks2.xZ[blockscnt2] >= maxblocksize) {
            inc(&blockscnt2, _state);
            blocks2.xZ[blockscnt2] = i;
         }
      }
      inc(&blockscnt2, _state);
      blocks2.xZ[blockscnt2] = n2;
      ae_vector_set_length(&blocks3, n3 + 1, _state);
      blockscnt3 = 0;
      blocks3.xZ[0] = 0;
      for (i = 1; i < n3; i++) {
         if (x3->xR[i] - x3->xR[blocks3.xZ[blockscnt3]] > blockwidth3 || i - blocks3.xZ[blockscnt3] >= maxblocksize) {
            inc(&blockscnt3, _state);
            blocks3.xZ[blockscnt3] = i;
         }
      }
      inc(&blockscnt3, _state);
      blocks3.xZ[blockscnt3] = n3;
   // Prepare seed for shared pool
      rbfv2_allocatecalcbuffer(s, &bufseedv2.calcbuf, _state);
      ae_shared_pool_set_seed(&bufpool, &bufseedv2, sizeof(bufseedv2), rbfv2gridcalcbuffer_init, rbfv2gridcalcbuffer_copy, rbfv2gridcalcbuffer_free, _state);
   // Determine average number of neighbor per node
      searchradius2 = sqr(rcur * rbfv2farradius(s->bf, _state), _state);
      ntrials = 100;
      avgfuncpernode = 0.0;
      for (i = 0; i < ntrials; i++) {
         tx.xR[0] = x0->xR[hqrnduniformi(&rs, n0, _state)];
         tx.xR[1] = x1->xR[hqrnduniformi(&rs, n1, _state)];
         tx.xR[2] = x2->xR[hqrnduniformi(&rs, n2, _state)];
         tx.xR[3] = x3->xR[hqrnduniformi(&rs, n3, _state)];
         rbfv2_preparepartialquery(&tx, &s->kdboxmin, &s->kdboxmax, nx, &bufseedv2.calcbuf, &dummy, _state);
         avgfuncpernode += (double)rbfv2_partialcountrec(&s->kdnodes, &s->kdsplits, &s->cw, nx, ny, &bufseedv2.calcbuf, s->kdroots.xZ[levelidx], searchradius2, &tx, _state) / ntrials;
      }
   // Perform calculation in multithreaded mode
      rbfv2partialgridcalcrec(s, x0, n0, x1, n1, x2, n2, x3, n3, &blocks0, 0, blockscnt0, &blocks1, 0, blockscnt1, &blocks2, 0, blockscnt2, &blocks3, 0, blockscnt3, flagy, sparsey, levelidx, avgfuncpernode, &bufpool, y, _state);
   }
   ae_frame_leave(_state);
}

// This function calculates values of the RBF model at the regular grid.
//
// Grid have N0*N1 points, with Point[I,J] = (X0[I], X1[J])
//
// This function returns 0.0 when:
// * model is not initialized
// * NX != 2
//  *NY != 1
//
// Inputs:
//     S       -   RBF model
//     X0      -   array of grid nodes, first coordinates, array[N0]
//     N0      -   grid size (number of nodes) in the first dimension
//     X1      -   array of grid nodes, second coordinates, array[N1]
//     N1      -   grid size (number of nodes) in the second dimension
//
// Outputs:
//     Y       -   function values, array[N0,N1]. Y is out-variable and
//                 is reallocated by this function.
//
// NOTE: as a special exception, this function supports unordered  arrays  X0
//       and X1. However, future versions may be  more  efficient  for  X0/X1
//       ordered by ascending.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
void rbfv2gridcalc2(rbfv2model *s, RVector *x0, ae_int_t n0, RVector *x1, ae_int_t n1, RMatrix *y, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(_state, &_frame_block);
   SetMatrix(y);
   NewVector(cpx0, 0, DT_REAL, _state);
   NewVector(cpx1, 0, DT_REAL, _state);
   NewVector(dummyx2, 0, DT_REAL, _state);
   NewVector(dummyx3, 0, DT_REAL, _state);
   NewVector(dummyflag, 0, DT_BOOL, _state);
   NewVector(p01, 0, DT_INT, _state);
   NewVector(p11, 0, DT_INT, _state);
   NewVector(p2, 0, DT_INT, _state);
   NewVector(vy, 0, DT_REAL, _state);
   ae_assert(n0 > 0, "RBFGridCalc2: invalid value for N0 (N0 <= 0)!", _state);
   ae_assert(n1 > 0, "RBFGridCalc2: invalid value for N1 (N1 <= 0)!", _state);
   ae_assert(x0->cnt >= n0, "RBFGridCalc2: Length(X0)<N0", _state);
   ae_assert(x1->cnt >= n1, "RBFGridCalc2: Length(X1)<N1", _state);
   ae_assert(isfinitevector(x0, n0, _state), "RBFGridCalc2: X0 contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(x1, n1, _state), "RBFGridCalc2: X1 contains infinite or NaN values!", _state);
   ae_matrix_set_length(y, n0, n1, _state);
   for (i = 0; i < n0; i++) {
      for (j = 0; j < n1; j++) {
         y->xyR[i][j] = 0.0;
      }
   }
   if (s->ny != 1 || s->nx != 2) {
      ae_frame_leave(_state);
      return;
   }
// create and sort arrays
   ae_vector_set_length(&cpx0, n0, _state);
   for (i = 0; i < n0; i++) {
      cpx0.xR[i] = x0->xR[i];
   }
   tagsort(&cpx0, n0, &p01, &p2, _state);
   ae_vector_set_length(&cpx1, n1, _state);
   for (i = 0; i < n1; i++) {
      cpx1.xR[i] = x1->xR[i];
   }
   tagsort(&cpx1, n1, &p11, &p2, _state);
   ae_vector_set_length(&dummyx2, 1, _state);
   dummyx2.xR[0] = 0.0;
   ae_vector_set_length(&dummyx3, 1, _state);
   dummyx3.xR[0] = 0.0;
   ae_vector_set_length(&vy, n0 * n1, _state);
   rbfv2gridcalcvx(s, &cpx0, n0, &cpx1, n1, &dummyx2, 1, &dummyx3, 1, &dummyflag, false, &vy, _state);
   for (i = 0; i < n0; i++) {
      for (j = 0; j < n1; j++) {
         y->xyR[i][j] = vy.xR[i + j * n0];
      }
   }
   ae_frame_leave(_state);
}

// This function "unpacks" RBF model by extracting its coefficients.
//
// Inputs:
//     S       -   RBF model
//
// Outputs:
//     NX      -   dimensionality of argument
//     NY      -   dimensionality of the target function
//     XWR     -   model information, array[NC,NX+NY+1].
//                 One row of the array corresponds to one basis function:
//                 * first NX columns  - coordinates of the center
//                 * next NY columns   - weights, one per dimension of the
//                                       function being modelled
//                 * last NX columns   - radii, per dimension
//     NC      -   number of the centers
//     V       -   polynomial  term , array[NY,NX+1]. One row per one
//                 dimension of the function being modelled. First NX
//                 elements are linear coefficients, V[NX] is equal to the
//                 constant part.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
void rbfv2unpack(rbfv2model *s, ae_int_t *nx, ae_int_t *ny, RMatrix *xwr, ae_int_t *nc, RMatrix *v, ae_state *_state) {
   ae_int_t i;
   ae_int_t ncactual;
   *nx = 0;
   *ny = 0;
   SetMatrix(xwr);
   *nc = 0;
   SetMatrix(v);
   *nx = s->nx;
   *ny = s->ny;
   *nc = 0;
// Fill V
   ae_matrix_set_length(v, s->ny, s->nx + 1, _state);
   for (i = 0; i < s->ny; i++) {
      ae_v_move(v->xyR[i], 1, s->v.xyR[i], 1, s->nx + 1);
   }
// Fill XWR
   ae_assert(s->cw.cnt % (s->nx + s->ny) == 0, "RBFV2Unpack: integrity error", _state);
   *nc = s->cw.cnt / (s->nx + s->ny);
   ncactual = 0;
   if (*nc > 0) {
      ae_matrix_set_length(xwr, *nc, s->nx + s->ny + s->nx, _state);
      for (i = 0; i < s->nh; i++) {
         rbfv2_partialunpackrec(&s->kdnodes, &s->kdsplits, &s->cw, &s->s, s->nx, s->ny, s->kdroots.xZ[i], s->ri.xR[i], xwr, &ncactual, _state);
      }
   }
   ae_assert(*nc == ncactual, "RBFV2Unpack: integrity error", _state);
}

// Serializer: allocation
// ALGLIB: Copyright 02.02.2012 by Sergey Bochkanov
void rbfv2alloc(ae_serializer *s, rbfv2model *model, ae_state *_state) {
// Data
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   ae_serializer_alloc_entry(s);
   allocrealarray(s, &model->ri, -1, _state);
   allocrealarray(s, &model->s, -1, _state);
   allocintegerarray(s, &model->kdroots, -1, _state);
   allocintegerarray(s, &model->kdnodes, -1, _state);
   allocrealarray(s, &model->kdsplits, -1, _state);
   allocrealarray(s, &model->kdboxmin, -1, _state);
   allocrealarray(s, &model->kdboxmax, -1, _state);
   allocrealarray(s, &model->cw, -1, _state);
   allocrealmatrix(s, &model->v, -1, -1, _state);
}

// Serializer: serialization
// ALGLIB: Copyright 02.02.2012 by Sergey Bochkanov
void rbfv2serialize(ae_serializer *s, rbfv2model *model, ae_state *_state) {
// Data
   ae_serializer_serialize_int(s, model->nx, _state);
   ae_serializer_serialize_int(s, model->ny, _state);
   ae_serializer_serialize_int(s, model->nh, _state);
   ae_serializer_serialize_int(s, model->bf, _state);
   serializerealarray(s, &model->ri, -1, _state);
   serializerealarray(s, &model->s, -1, _state);
   serializeintegerarray(s, &model->kdroots, -1, _state);
   serializeintegerarray(s, &model->kdnodes, -1, _state);
   serializerealarray(s, &model->kdsplits, -1, _state);
   serializerealarray(s, &model->kdboxmin, -1, _state);
   serializerealarray(s, &model->kdboxmax, -1, _state);
   serializerealarray(s, &model->cw, -1, _state);
   serializerealmatrix(s, &model->v, -1, -1, _state);
}

// Serializer: unserialization
// ALGLIB: Copyright 02.02.2012 by Sergey Bochkanov
void rbfv2unserialize(ae_serializer *s, rbfv2model *model, ae_state *_state) {
   ae_int_t nx;
   ae_int_t ny;
   SetObj(rbfv2model, model);
// Unserialize primary model parameters, initialize model.
//
// It is necessary to call RBFCreate() because some internal fields
// which are NOT unserialized will need initialization.
   ae_serializer_unserialize_int(s, &nx, _state);
   ae_serializer_unserialize_int(s, &ny, _state);
   rbfv2create(nx, ny, model, _state);
   ae_serializer_unserialize_int(s, &model->nh, _state);
   ae_serializer_unserialize_int(s, &model->bf, _state);
   unserializerealarray(s, &model->ri, _state);
   unserializerealarray(s, &model->s, _state);
   unserializeintegerarray(s, &model->kdroots, _state);
   unserializeintegerarray(s, &model->kdnodes, _state);
   unserializerealarray(s, &model->kdsplits, _state);
   unserializerealarray(s, &model->kdboxmin, _state);
   unserializerealarray(s, &model->kdboxmax, _state);
   unserializerealarray(s, &model->cw, _state);
   unserializerealmatrix(s, &model->v, _state);
}

void rbfv2calcbuffer_init(void *_p, ae_state *_state, bool make_automatic) {
   rbfv2calcbuffer *p = (rbfv2calcbuffer *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->x, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->curboxmin, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->curboxmax, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->x123, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->y123, 0, DT_REAL, _state, make_automatic);
}

void rbfv2calcbuffer_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   rbfv2calcbuffer *dst = (rbfv2calcbuffer *)_dst;
   rbfv2calcbuffer *src = (rbfv2calcbuffer *)_src;
   ae_vector_copy(&dst->x, &src->x, _state, make_automatic);
   ae_vector_copy(&dst->curboxmin, &src->curboxmin, _state, make_automatic);
   ae_vector_copy(&dst->curboxmax, &src->curboxmax, _state, make_automatic);
   dst->curdist2 = src->curdist2;
   ae_vector_copy(&dst->x123, &src->x123, _state, make_automatic);
   ae_vector_copy(&dst->y123, &src->y123, _state, make_automatic);
}

void rbfv2calcbuffer_free(void *_p, bool make_automatic) {
   rbfv2calcbuffer *p = (rbfv2calcbuffer *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->x, make_automatic);
   ae_vector_free(&p->curboxmin, make_automatic);
   ae_vector_free(&p->curboxmax, make_automatic);
   ae_vector_free(&p->x123, make_automatic);
   ae_vector_free(&p->y123, make_automatic);
}

void rbfv2model_init(void *_p, ae_state *_state, bool make_automatic) {
   rbfv2model *p = (rbfv2model *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->ri, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->s, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->kdroots, 0, DT_INT, _state, make_automatic);
   ae_vector_init(&p->kdnodes, 0, DT_INT, _state, make_automatic);
   ae_vector_init(&p->kdsplits, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->kdboxmin, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->kdboxmax, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->cw, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->v, 0, 0, DT_REAL, _state, make_automatic);
   rbfv2calcbuffer_init(&p->calcbuf, _state, make_automatic);
}

void rbfv2model_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   rbfv2model *dst = (rbfv2model *)_dst;
   rbfv2model *src = (rbfv2model *)_src;
   dst->ny = src->ny;
   dst->nx = src->nx;
   dst->bf = src->bf;
   dst->nh = src->nh;
   ae_vector_copy(&dst->ri, &src->ri, _state, make_automatic);
   ae_vector_copy(&dst->s, &src->s, _state, make_automatic);
   ae_vector_copy(&dst->kdroots, &src->kdroots, _state, make_automatic);
   ae_vector_copy(&dst->kdnodes, &src->kdnodes, _state, make_automatic);
   ae_vector_copy(&dst->kdsplits, &src->kdsplits, _state, make_automatic);
   ae_vector_copy(&dst->kdboxmin, &src->kdboxmin, _state, make_automatic);
   ae_vector_copy(&dst->kdboxmax, &src->kdboxmax, _state, make_automatic);
   ae_vector_copy(&dst->cw, &src->cw, _state, make_automatic);
   ae_matrix_copy(&dst->v, &src->v, _state, make_automatic);
   dst->lambdareg = src->lambdareg;
   dst->maxits = src->maxits;
   dst->supportr = src->supportr;
   dst->basisfunction = src->basisfunction;
   rbfv2calcbuffer_copy(&dst->calcbuf, &src->calcbuf, _state, make_automatic);
}

void rbfv2model_free(void *_p, bool make_automatic) {
   rbfv2model *p = (rbfv2model *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->ri, make_automatic);
   ae_vector_free(&p->s, make_automatic);
   ae_vector_free(&p->kdroots, make_automatic);
   ae_vector_free(&p->kdnodes, make_automatic);
   ae_vector_free(&p->kdsplits, make_automatic);
   ae_vector_free(&p->kdboxmin, make_automatic);
   ae_vector_free(&p->kdboxmax, make_automatic);
   ae_vector_free(&p->cw, make_automatic);
   ae_matrix_free(&p->v, make_automatic);
   rbfv2calcbuffer_free(&p->calcbuf, make_automatic);
}

void rbfv2gridcalcbuffer_init(void *_p, ae_state *_state, bool make_automatic) {
   rbfv2gridcalcbuffer *p = (rbfv2gridcalcbuffer *)_p;
   ae_touch_ptr((void *)p);
   rbfv2calcbuffer_init(&p->calcbuf, _state, make_automatic);
   ae_vector_init(&p->cx, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->rx, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->ry, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->tx, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->ty, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->rf, 0, DT_BOOL, _state, make_automatic);
}

void rbfv2gridcalcbuffer_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   rbfv2gridcalcbuffer *dst = (rbfv2gridcalcbuffer *)_dst;
   rbfv2gridcalcbuffer *src = (rbfv2gridcalcbuffer *)_src;
   rbfv2calcbuffer_copy(&dst->calcbuf, &src->calcbuf, _state, make_automatic);
   ae_vector_copy(&dst->cx, &src->cx, _state, make_automatic);
   ae_vector_copy(&dst->rx, &src->rx, _state, make_automatic);
   ae_vector_copy(&dst->ry, &src->ry, _state, make_automatic);
   ae_vector_copy(&dst->tx, &src->tx, _state, make_automatic);
   ae_vector_copy(&dst->ty, &src->ty, _state, make_automatic);
   ae_vector_copy(&dst->rf, &src->rf, _state, make_automatic);
}

void rbfv2gridcalcbuffer_free(void *_p, bool make_automatic) {
   rbfv2gridcalcbuffer *p = (rbfv2gridcalcbuffer *)_p;
   ae_touch_ptr((void *)p);
   rbfv2calcbuffer_free(&p->calcbuf, make_automatic);
   ae_vector_free(&p->cx, make_automatic);
   ae_vector_free(&p->rx, make_automatic);
   ae_vector_free(&p->ry, make_automatic);
   ae_vector_free(&p->tx, make_automatic);
   ae_vector_free(&p->ty, make_automatic);
   ae_vector_free(&p->rf, make_automatic);
}

void rbfv2report_init(void *_p, ae_state *_state, bool make_automatic) {
   rbfv2report *p = (rbfv2report *)_p;
   ae_touch_ptr((void *)p);
}

void rbfv2report_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   rbfv2report *dst = (rbfv2report *)_dst;
   rbfv2report *src = (rbfv2report *)_src;
   dst->terminationtype = src->terminationtype;
   dst->maxerror = src->maxerror;
   dst->rmserror = src->rmserror;
}

void rbfv2report_free(void *_p, bool make_automatic) {
   rbfv2report *p = (rbfv2report *)_p;
   ae_touch_ptr((void *)p);
}
} // end of namespace alglib_impl

// === SPLINE3D Package ===
// Depends on: SPLINE1D
namespace alglib_impl {
// This subroutine calculates the value of the trilinear(or tricubic;possible
// will be later) spline  at the given point X(and its derivatives; possible
// will be later).
//
// Inputs:
//     C       -   spline interpolant.
//     X, Y, Z -   point
//
// Outputs:
//     F   -   S(x,y,z)
//     FX  -   dS(x,y,z)/dX
//     FY  -   dS(x,y,z)/dY
//     FXY -   d2S(x,y,z)/dXdY
// ALGLIB Project: Copyright 26.04.2012 by Sergey Bochkanov
static void spline3d_spline3ddiff(spline3dinterpolant *c, double x, double y, double z, double *f, double *fx, double *fy, double *fxy, ae_state *_state) {
   double xd;
   double yd;
   double zd;
   double c0;
   double c1;
   double c2;
   double c3;
   ae_int_t ix;
   ae_int_t iy;
   ae_int_t iz;
   ae_int_t l;
   ae_int_t r;
   ae_int_t h;
   *f = 0;
   *fx = 0;
   *fy = 0;
   *fxy = 0;
   ae_assert(c->stype == -1 || c->stype == -3, "Spline3DDiff: incorrect C (incorrect parameter C.SType)", _state);
   ae_assert(ae_isfinite(x, _state) && ae_isfinite(y, _state), "Spline3DDiff: X or Y contains NaN or Infinite value", _state);
// Prepare F, dF/dX, dF/dY, d2F/dXdY
   *f = 0.0;
   *fx = 0.0;
   *fy = 0.0;
   *fxy = 0.0;
   if (c->d != 1) {
      return;
   }
// Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
   l = 0;
   r = c->n - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->x.xR[h] >= x) {
         r = h;
      } else {
         l = h;
      }
   }
   ix = l;
// Binary search in the [ y[0], ..., y[n-2] ] (y[n-1] is not included)
   l = 0;
   r = c->m - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->y.xR[h] >= y) {
         r = h;
      } else {
         l = h;
      }
   }
   iy = l;
// Binary search in the [ z[0], ..., z[n-2] ] (z[n-1] is not included)
   l = 0;
   r = c->l - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->z.xR[h] >= z) {
         r = h;
      } else {
         l = h;
      }
   }
   iz = l;
   xd = (x - c->x.xR[ix]) / (c->x.xR[ix + 1] - c->x.xR[ix]);
   yd = (y - c->y.xR[iy]) / (c->y.xR[iy + 1] - c->y.xR[iy]);
   zd = (z - c->z.xR[iz]) / (c->z.xR[iz + 1] - c->z.xR[iz]);
// Trilinear interpolation
   if (c->stype == -1) {
      c0 = c->f.xR[c->n * (c->m * iz + iy) + ix] * (1 - xd) + c->f.xR[c->n * (c->m * iz + iy) + (ix + 1)] * xd;
      c1 = c->f.xR[c->n * (c->m * iz + (iy + 1)) + ix] * (1 - xd) + c->f.xR[c->n * (c->m * iz + (iy + 1)) + (ix + 1)] * xd;
      c2 = c->f.xR[c->n * (c->m * (iz + 1) + iy) + ix] * (1 - xd) + c->f.xR[c->n * (c->m * (iz + 1) + iy) + (ix + 1)] * xd;
      c3 = c->f.xR[c->n * (c->m * (iz + 1) + (iy + 1)) + ix] * (1 - xd) + c->f.xR[c->n * (c->m * (iz + 1) + (iy + 1)) + (ix + 1)] * xd;
      c0 = c0 * (1 - yd) + c1 * yd;
      c1 = c2 * (1 - yd) + c3 * yd;
      *f = c0 * (1 - zd) + c1 * zd;
   }
}

// This subroutine calculates bilinear or bicubic vector-valued spline at the
// given point (X,Y,Z).
//
// Inputs:
//     C   -   spline interpolant.
//     X, Y,
//     Z   -   point
//     F   -   output buffer, possibly preallocated array. In case array size
//             is large enough to store result, it is not reallocated.  Array
//             which is too short will be reallocated
//
// Outputs:
//     F   -   array[D] (or larger) which stores function values
// ALGLIB Project: Copyright 26.04.2012 by Sergey Bochkanov
// API: void spline3dcalcvbuf(const spline3dinterpolant &c, const double x, const double y, const double z, real_1d_array &f, const xparams _xparams = xdefault);
void spline3dcalcvbuf(spline3dinterpolant *c, double x, double y, double z, RVector *f, ae_state *_state) {
   double xd;
   double yd;
   double zd;
   double c0;
   double c1;
   double c2;
   double c3;
   ae_int_t ix;
   ae_int_t iy;
   ae_int_t iz;
   ae_int_t l;
   ae_int_t r;
   ae_int_t h;
   ae_int_t i;
   ae_assert(c->stype == -1 || c->stype == -3, "Spline3DCalcVBuf: incorrect C (incorrect parameter C.SType)", _state);
   ae_assert((ae_isfinite(x, _state) && ae_isfinite(y, _state)) && ae_isfinite(z, _state), "Spline3DCalcVBuf: X, Y or Z contains NaN/Infinite", _state);
   rvectorsetlengthatleast(f, c->d, _state);
// Binary search in the [ x[0], ..., x[n-2] ] (x[n-1] is not included)
   l = 0;
   r = c->n - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->x.xR[h] >= x) {
         r = h;
      } else {
         l = h;
      }
   }
   ix = l;
// Binary search in the [ y[0], ..., y[n-2] ] (y[n-1] is not included)
   l = 0;
   r = c->m - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->y.xR[h] >= y) {
         r = h;
      } else {
         l = h;
      }
   }
   iy = l;
// Binary search in the [ z[0], ..., z[n-2] ] (z[n-1] is not included)
   l = 0;
   r = c->l - 1;
   while (l != r - 1) {
      h = (l + r) / 2;
      if (c->z.xR[h] >= z) {
         r = h;
      } else {
         l = h;
      }
   }
   iz = l;
   xd = (x - c->x.xR[ix]) / (c->x.xR[ix + 1] - c->x.xR[ix]);
   yd = (y - c->y.xR[iy]) / (c->y.xR[iy + 1] - c->y.xR[iy]);
   zd = (z - c->z.xR[iz]) / (c->z.xR[iz + 1] - c->z.xR[iz]);
   for (i = 0; i < c->d; i++) {
   // Trilinear interpolation
      if (c->stype == -1) {
         c0 = c->f.xR[c->d * (c->n * (c->m * iz + iy) + ix) + i] * (1 - xd) + c->f.xR[c->d * (c->n * (c->m * iz + iy) + (ix + 1)) + i] * xd;
         c1 = c->f.xR[c->d * (c->n * (c->m * iz + (iy + 1)) + ix) + i] * (1 - xd) + c->f.xR[c->d * (c->n * (c->m * iz + (iy + 1)) + (ix + 1)) + i] * xd;
         c2 = c->f.xR[c->d * (c->n * (c->m * (iz + 1) + iy) + ix) + i] * (1 - xd) + c->f.xR[c->d * (c->n * (c->m * (iz + 1) + iy) + (ix + 1)) + i] * xd;
         c3 = c->f.xR[c->d * (c->n * (c->m * (iz + 1) + (iy + 1)) + ix) + i] * (1 - xd) + c->f.xR[c->d * (c->n * (c->m * (iz + 1) + (iy + 1)) + (ix + 1)) + i] * xd;
         c0 = c0 * (1 - yd) + c1 * yd;
         c1 = c2 * (1 - yd) + c3 * yd;
         f->xR[i] = c0 * (1 - zd) + c1 * zd;
      }
   }
}

// This subroutine calculates trilinear or tricubic vector-valued spline at the
// given point (X,Y,Z).
//
// Inputs:
//     C   -   spline interpolant.
//     X, Y,
//     Z   -   point
//
// Outputs:
//     F   -   array[D] which stores function values.  F is out-parameter and
//             it  is  reallocated  after  call to this function. In case you
//             want  to    reuse  previously  allocated  F,   you   may   use
//             Spline2DCalcVBuf(),  which  reallocates  F only when it is too
//             small.
// ALGLIB Project: Copyright 26.04.2012 by Sergey Bochkanov
// API: void spline3dcalcv(const spline3dinterpolant &c, const double x, const double y, const double z, real_1d_array &f, const xparams _xparams = xdefault);
void spline3dcalcv(spline3dinterpolant *c, double x, double y, double z, RVector *f, ae_state *_state) {
   SetVector(f);
   ae_assert(c->stype == -1 || c->stype == -3, "Spline3DCalcV: incorrect C (incorrect parameter C.SType)", _state);
   ae_assert((ae_isfinite(x, _state) && ae_isfinite(y, _state)) && ae_isfinite(z, _state), "Spline3DCalcV: X=NaN/Infinite, Y=NaN/Infinite or Z=NaN/Infinite", _state);
   ae_vector_set_length(f, c->d, _state);
   spline3dcalcvbuf(c, x, y, z, f, _state);
}

// This subroutine calculates the value of the trilinear or tricubic spline at
// the given point (X,Y,Z).
//
// Inputs:
//     C   -   coefficients table.
//             Built by BuildBilinearSpline or BuildBicubicSpline.
//     X, Y,
//     Z   -   point
//
// Result:
//     S(x,y,z)
// ALGLIB Project: Copyright 26.04.2012 by Sergey Bochkanov
// API: double spline3dcalc(const spline3dinterpolant &c, const double x, const double y, const double z, const xparams _xparams = xdefault);
double spline3dcalc(spline3dinterpolant *c, double x, double y, double z, ae_state *_state) {
   double v;
   double vx;
   double vy;
   double vxy;
   double result;
   ae_assert(c->stype == -1 || c->stype == -3, "Spline3DCalc: incorrect C (incorrect parameter C.SType)", _state);
   ae_assert((ae_isfinite(x, _state) && ae_isfinite(y, _state)) && ae_isfinite(z, _state), "Spline3DCalc: X=NaN/Infinite, Y=NaN/Infinite or Z=NaN/Infinite", _state);
   if (c->d != 1) {
      result = 0.0;
      return result;
   }
   spline3d_spline3ddiff(c, x, y, z, &v, &vx, &vy, &vxy, _state);
   result = v;
   return result;
}

// Trilinear spline resampling
//
// Inputs:
//     A           -   array[0..OldXCount*OldYCount*OldZCount-1], function
//                     values at the old grid, :
//                         A[0]        x=0,y=0,z=0
//                         A[1]        x=1,y=0,z=0
//                         A[..]       ...
//                         A[..]       x=oldxcount-1,y=0,z=0
//                         A[..]       x=0,y=1,z=0
//                         A[..]       ...
//                         ...
//     OldZCount   -   old Z-count, OldZCount>1
//     OldYCount   -   old Y-count, OldYCount>1
//     OldXCount   -   old X-count, OldXCount>1
//     NewZCount   -   new Z-count, NewZCount>1
//     NewYCount   -   new Y-count, NewYCount>1
//     NewXCount   -   new X-count, NewXCount>1
//
// Outputs:
//     B           -   array[0..NewXCount*NewYCount*NewZCount-1], function
//                     values at the new grid:
//                         B[0]        x=0,y=0,z=0
//                         B[1]        x=1,y=0,z=0
//                         B[..]       ...
//                         B[..]       x=newxcount-1,y=0,z=0
//                         B[..]       x=0,y=1,z=0
//                         B[..]       ...
//                         ...
// ALGLIB Routine: Copyright 26.04.2012 by Sergey Bochkanov
// API: void spline3dresampletrilinear(const real_1d_array &a, const ae_int_t oldzcount, const ae_int_t oldycount, const ae_int_t oldxcount, const ae_int_t newzcount, const ae_int_t newycount, const ae_int_t newxcount, real_1d_array &b, const xparams _xparams = xdefault);
void spline3dresampletrilinear(RVector *a, ae_int_t oldzcount, ae_int_t oldycount, ae_int_t oldxcount, ae_int_t newzcount, ae_int_t newycount, ae_int_t newxcount, RVector *b, ae_state *_state) {
   double xd;
   double yd;
   double zd;
   double c0;
   double c1;
   double c2;
   double c3;
   ae_int_t ix;
   ae_int_t iy;
   ae_int_t iz;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   SetVector(b);
   ae_assert((oldycount > 1 && oldzcount > 1) && oldxcount > 1, "Spline3DResampleTrilinear: length/width/height less than 1", _state);
   ae_assert((newycount > 1 && newzcount > 1) && newxcount > 1, "Spline3DResampleTrilinear: length/width/height less than 1", _state);
   ae_assert(a->cnt >= oldycount * oldzcount * oldxcount, "Spline3DResampleTrilinear: length/width/height less than 1", _state);
   ae_vector_set_length(b, newxcount * newycount * newzcount, _state);
   for (i = 0; i < newxcount; i++) {
      for (j = 0; j < newycount; j++) {
         for (k = 0; k < newzcount; k++) {
            ix = i * (oldxcount - 1) / (newxcount - 1);
            if (ix == oldxcount - 1) {
               ix = oldxcount - 2;
            }
            xd = (double)(i * (oldxcount - 1)) / (newxcount - 1) - ix;
            iy = j * (oldycount - 1) / (newycount - 1);
            if (iy == oldycount - 1) {
               iy = oldycount - 2;
            }
            yd = (double)(j * (oldycount - 1)) / (newycount - 1) - iy;
            iz = k * (oldzcount - 1) / (newzcount - 1);
            if (iz == oldzcount - 1) {
               iz = oldzcount - 2;
            }
            zd = (double)(k * (oldzcount - 1)) / (newzcount - 1) - iz;
            c0 = a->xR[oldxcount * (oldycount * iz + iy) + ix] * (1 - xd) + a->xR[oldxcount * (oldycount * iz + iy) + (ix + 1)] * xd;
            c1 = a->xR[oldxcount * (oldycount * iz + (iy + 1)) + ix] * (1 - xd) + a->xR[oldxcount * (oldycount * iz + (iy + 1)) + (ix + 1)] * xd;
            c2 = a->xR[oldxcount * (oldycount * (iz + 1) + iy) + ix] * (1 - xd) + a->xR[oldxcount * (oldycount * (iz + 1) + iy) + (ix + 1)] * xd;
            c3 = a->xR[oldxcount * (oldycount * (iz + 1) + (iy + 1)) + ix] * (1 - xd) + a->xR[oldxcount * (oldycount * (iz + 1) + (iy + 1)) + (ix + 1)] * xd;
            c0 = c0 * (1 - yd) + c1 * yd;
            c1 = c2 * (1 - yd) + c3 * yd;
            b->xR[newxcount * (newycount * k + j) + i] = c0 * (1 - zd) + c1 * zd;
         }
      }
   }
}

// This subroutine builds trilinear vector-valued spline.
//
// Inputs:
//     X   -   spline abscissas,  array[0..N-1]
//     Y   -   spline ordinates,  array[0..M-1]
//     Z   -   spline applicates, array[0..L-1]
//     F   -   function values, array[0..M*N*L*D-1]:
//             * first D elements store D values at (X[0],Y[0],Z[0])
//             * next D elements store D values at (X[1],Y[0],Z[0])
//             * next D elements store D values at (X[2],Y[0],Z[0])
//             * ...
//             * next D elements store D values at (X[0],Y[1],Z[0])
//             * next D elements store D values at (X[1],Y[1],Z[0])
//             * next D elements store D values at (X[2],Y[1],Z[0])
//             * ...
//             * next D elements store D values at (X[0],Y[0],Z[1])
//             * next D elements store D values at (X[1],Y[0],Z[1])
//             * next D elements store D values at (X[2],Y[0],Z[1])
//             * ...
//             * general form - D function values at (X[i],Y[j]) are stored
//               at F[D*(N*(M*K+J)+I)...D*(N*(M*K+J)+I)+D-1].
//     M,N,
//     L   -   grid size, M >= 2, N >= 2, L >= 2
//     D   -   vector dimension, D >= 1
//
// Outputs:
//     C   -   spline interpolant
// ALGLIB Project: Copyright 26.04.2012 by Sergey Bochkanov
// API: void spline3dbuildtrilinearv(const real_1d_array &x, const ae_int_t n, const real_1d_array &y, const ae_int_t m, const real_1d_array &z, const ae_int_t l, const real_1d_array &f, const ae_int_t d, spline3dinterpolant &c, const xparams _xparams = xdefault);
void spline3dbuildtrilinearv(RVector *x, ae_int_t n, RVector *y, ae_int_t m, RVector *z, ae_int_t l, RVector *f, ae_int_t d, spline3dinterpolant *c, ae_state *_state) {
   double t;
   ae_int_t tblsize;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t i0;
   ae_int_t j0;
   SetObj(spline3dinterpolant, c);
   ae_assert(m >= 2, "Spline3DBuildTrilinearV: M<2", _state);
   ae_assert(n >= 2, "Spline3DBuildTrilinearV: N<2", _state);
   ae_assert(l >= 2, "Spline3DBuildTrilinearV: L<2", _state);
   ae_assert(d >= 1, "Spline3DBuildTrilinearV: D<1", _state);
   ae_assert((x->cnt >= n && y->cnt >= m) && z->cnt >= l, "Spline3DBuildTrilinearV: length of X, Y or Z is too short (Length(X/Y/Z)<N/M/L)", _state);
   ae_assert((isfinitevector(x, n, _state) && isfinitevector(y, m, _state)) && isfinitevector(z, l, _state), "Spline3DBuildTrilinearV: X, Y or Z contains NaN or Infinite value", _state);
   tblsize = n * m * l * d;
   ae_assert(f->cnt >= tblsize, "Spline3DBuildTrilinearV: length of F is too short (Length(F)<N*M*L*D)", _state);
   ae_assert(isfinitevector(f, tblsize, _state), "Spline3DBuildTrilinearV: F contains NaN or Infinite value", _state);
// Fill interpolant
   c->k = 1;
   c->n = n;
   c->m = m;
   c->l = l;
   c->d = d;
   c->stype = -1;
   ae_vector_set_length(&c->x, c->n, _state);
   ae_vector_set_length(&c->y, c->m, _state);
   ae_vector_set_length(&c->z, c->l, _state);
   ae_vector_set_length(&c->f, tblsize, _state);
   for (i = 0; i < c->n; i++) {
      c->x.xR[i] = x->xR[i];
   }
   for (i = 0; i < c->m; i++) {
      c->y.xR[i] = y->xR[i];
   }
   for (i = 0; i < c->l; i++) {
      c->z.xR[i] = z->xR[i];
   }
   for (i = 0; i < tblsize; i++) {
      c->f.xR[i] = f->xR[i];
   }
// Sort points:
//  * sort x;
//  * sort y;
//  * sort z.
   for (j = 0; j < c->n; j++) {
      k = j;
      for (i = j + 1; i < c->n; i++) {
         if (c->x.xR[i] < c->x.xR[k]) {
            k = i;
         }
      }
      if (k != j) {
         for (i = 0; i < c->m; i++) {
            for (j0 = 0; j0 < c->l; j0++) {
               for (i0 = 0; i0 < c->d; i0++) {
                  t = c->f.xR[c->d * (c->n * (c->m * j0 + i) + j) + i0];
                  c->f.xR[c->d * (c->n * (c->m * j0 + i) + j) + i0] = c->f.xR[c->d * (c->n * (c->m * j0 + i) + k) + i0];
                  c->f.xR[c->d * (c->n * (c->m * j0 + i) + k) + i0] = t;
               }
            }
         }
         t = c->x.xR[j];
         c->x.xR[j] = c->x.xR[k];
         c->x.xR[k] = t;
      }
   }
   for (i = 0; i < c->m; i++) {
      k = i;
      for (j = i + 1; j < c->m; j++) {
         if (c->y.xR[j] < c->y.xR[k]) {
            k = j;
         }
      }
      if (k != i) {
         for (j = 0; j < c->n; j++) {
            for (j0 = 0; j0 < c->l; j0++) {
               for (i0 = 0; i0 < c->d; i0++) {
                  t = c->f.xR[c->d * (c->n * (c->m * j0 + i) + j) + i0];
                  c->f.xR[c->d * (c->n * (c->m * j0 + i) + j) + i0] = c->f.xR[c->d * (c->n * (c->m * j0 + k) + j) + i0];
                  c->f.xR[c->d * (c->n * (c->m * j0 + k) + j) + i0] = t;
               }
            }
         }
         t = c->y.xR[i];
         c->y.xR[i] = c->y.xR[k];
         c->y.xR[k] = t;
      }
   }
   for (k = 0; k < c->l; k++) {
      i = k;
      for (j = i + 1; j < c->l; j++) {
         if (c->z.xR[j] < c->z.xR[i]) {
            i = j;
         }
      }
      if (i != k) {
         for (j = 0; j < c->m; j++) {
            for (j0 = 0; j0 < c->n; j0++) {
               for (i0 = 0; i0 < c->d; i0++) {
                  t = c->f.xR[c->d * (c->n * (c->m * k + j) + j0) + i0];
                  c->f.xR[c->d * (c->n * (c->m * k + j) + j0) + i0] = c->f.xR[c->d * (c->n * (c->m * i + j) + j0) + i0];
                  c->f.xR[c->d * (c->n * (c->m * i + j) + j0) + i0] = t;
               }
            }
         }
         t = c->z.xR[k];
         c->z.xR[k] = c->z.xR[i];
         c->z.xR[i] = t;
      }
   }
}

// This subroutine performs linear transformation of the spline argument.
//
// Inputs:
//     C       -   spline interpolant
//     AX, BX  -   transformation coefficients: x = A*u + B
//     AY, BY  -   transformation coefficients: y = A*v + B
//     AZ, BZ  -   transformation coefficients: z = A*w + B
//
// Outputs:
//     C   -   transformed spline
// ALGLIB Project: Copyright 26.04.2012 by Sergey Bochkanov
// API: void spline3dlintransxyz(const spline3dinterpolant &c, const double ax, const double bx, const double ay, const double by, const double az, const double bz, const xparams _xparams = xdefault);
void spline3dlintransxyz(spline3dinterpolant *c, double ax, double bx, double ay, double by, double az, double bz, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t di;
   ae_frame_make(_state, &_frame_block);
   NewVector(x, 0, DT_REAL, _state);
   NewVector(y, 0, DT_REAL, _state);
   NewVector(z, 0, DT_REAL, _state);
   NewVector(f, 0, DT_REAL, _state);
   NewVector(v, 0, DT_REAL, _state);
   ae_assert(c->stype == -3 || c->stype == -1, "Spline3DLinTransXYZ: incorrect C (incorrect parameter C.SType)", _state);
   ae_vector_set_length(&x, c->n, _state);
   ae_vector_set_length(&y, c->m, _state);
   ae_vector_set_length(&z, c->l, _state);
   ae_vector_set_length(&f, c->m * c->n * c->l * c->d, _state);
   for (j = 0; j < c->n; j++) {
      x.xR[j] = c->x.xR[j];
   }
   for (i = 0; i < c->m; i++) {
      y.xR[i] = c->y.xR[i];
   }
   for (i = 0; i < c->l; i++) {
      z.xR[i] = c->z.xR[i];
   }
// Handle different combinations of zero/nonzero AX/AY/AZ
   if ((ax != 0.0 && ay != 0.0) && az != 0.0) {
      ae_v_move(f.xR, 1, c->f.xR, 1, c->m * c->n * c->l * c->d);
   }
   if ((ax == 0.0 && ay != 0.0) && az != 0.0) {
      for (i = 0; i < c->m; i++) {
         for (j = 0; j < c->l; j++) {
            spline3dcalcv(c, bx, y.xR[i], z.xR[j], &v, _state);
            for (k = 0; k < c->n; k++) {
               for (di = 0; di < c->d; di++) {
                  f.xR[c->d * (c->n * (c->m * j + i) + k) + di] = v.xR[di];
               }
            }
         }
      }
      ax = 1.0;
      bx = 0.0;
   }
   if ((ax != 0.0 && ay == 0.0) && az != 0.0) {
      for (i = 0; i < c->n; i++) {
         for (j = 0; j < c->l; j++) {
            spline3dcalcv(c, x.xR[i], by, z.xR[j], &v, _state);
            for (k = 0; k < c->m; k++) {
               for (di = 0; di < c->d; di++) {
                  f.xR[c->d * (c->n * (c->m * j + k) + i) + di] = v.xR[di];
               }
            }
         }
      }
      ay = 1.0;
      by = 0.0;
   }
   if ((ax != 0.0 && ay != 0.0) && az == 0.0) {
      for (i = 0; i < c->n; i++) {
         for (j = 0; j < c->m; j++) {
            spline3dcalcv(c, x.xR[i], y.xR[j], bz, &v, _state);
            for (k = 0; k < c->l; k++) {
               for (di = 0; di < c->d; di++) {
                  f.xR[c->d * (c->n * (c->m * k + j) + i) + di] = v.xR[di];
               }
            }
         }
      }
      az = 1.0;
      bz = 0.0;
   }
   if ((ax == 0.0 && ay == 0.0) && az != 0.0) {
      for (i = 0; i < c->l; i++) {
         spline3dcalcv(c, bx, by, z.xR[i], &v, _state);
         for (k = 0; k < c->m; k++) {
            for (j = 0; j < c->n; j++) {
               for (di = 0; di < c->d; di++) {
                  f.xR[c->d * (c->n * (c->m * i + k) + j) + di] = v.xR[di];
               }
            }
         }
      }
      ax = 1.0;
      bx = 0.0;
      ay = 1.0;
      by = 0.0;
   }
   if ((ax == 0.0 && ay != 0.0) && az == 0.0) {
      for (i = 0; i < c->m; i++) {
         spline3dcalcv(c, bx, y.xR[i], bz, &v, _state);
         for (k = 0; k < c->l; k++) {
            for (j = 0; j < c->n; j++) {
               for (di = 0; di < c->d; di++) {
                  f.xR[c->d * (c->n * (c->m * k + i) + j) + di] = v.xR[di];
               }
            }
         }
      }
      ax = 1.0;
      bx = 0.0;
      az = 1.0;
      bz = 0.0;
   }
   if ((ax != 0.0 && ay == 0.0) && az == 0.0) {
      for (i = 0; i < c->n; i++) {
         spline3dcalcv(c, x.xR[i], by, bz, &v, _state);
         for (k = 0; k < c->l; k++) {
            for (j = 0; j < c->m; j++) {
               for (di = 0; di < c->d; di++) {
                  f.xR[c->d * (c->n * (c->m * k + j) + i) + di] = v.xR[di];
               }
            }
         }
      }
      ay = 1.0;
      by = 0.0;
      az = 1.0;
      bz = 0.0;
   }
   if ((ax == 0.0 && ay == 0.0) && az == 0.0) {
      spline3dcalcv(c, bx, by, bz, &v, _state);
      for (k = 0; k < c->l; k++) {
         for (j = 0; j < c->m; j++) {
            for (i = 0; i < c->n; i++) {
               for (di = 0; di < c->d; di++) {
                  f.xR[c->d * (c->n * (c->m * k + j) + i) + di] = v.xR[di];
               }
            }
         }
      }
      ax = 1.0;
      bx = 0.0;
      ay = 1.0;
      by = 0.0;
      az = 1.0;
      bz = 0.0;
   }
// General case: AX != 0, AY != 0, AZ != 0
// Unpack, scale and pack again.
   for (i = 0; i < c->n; i++) {
      x.xR[i] = (x.xR[i] - bx) / ax;
   }
   for (i = 0; i < c->m; i++) {
      y.xR[i] = (y.xR[i] - by) / ay;
   }
   for (i = 0; i < c->l; i++) {
      z.xR[i] = (z.xR[i] - bz) / az;
   }
   if (c->stype == -1) {
      spline3dbuildtrilinearv(&x, c->n, &y, c->m, &z, c->l, &f, c->d, c, _state);
   }
   ae_frame_leave(_state);
}

// This subroutine performs linear transformation of the spline.
//
// Inputs:
//     C   -   spline interpolant.
//     A, B-   transformation coefficients: S2(x,y) = A*S(x,y,z) + B
//
// Outputs:
//     C   -   transformed spline
// ALGLIB Project: Copyright 26.04.2012 by Sergey Bochkanov
// API: void spline3dlintransf(const spline3dinterpolant &c, const double a, const double b, const xparams _xparams = xdefault);
void spline3dlintransf(spline3dinterpolant *c, double a, double b, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(_state, &_frame_block);
   NewVector(x, 0, DT_REAL, _state);
   NewVector(y, 0, DT_REAL, _state);
   NewVector(z, 0, DT_REAL, _state);
   NewVector(f, 0, DT_REAL, _state);
   ae_assert(c->stype == -3 || c->stype == -1, "Spline3DLinTransF: incorrect C (incorrect parameter C.SType)", _state);
   ae_vector_set_length(&x, c->n, _state);
   ae_vector_set_length(&y, c->m, _state);
   ae_vector_set_length(&z, c->l, _state);
   ae_vector_set_length(&f, c->m * c->n * c->l * c->d, _state);
   for (j = 0; j < c->n; j++) {
      x.xR[j] = c->x.xR[j];
   }
   for (i = 0; i < c->m; i++) {
      y.xR[i] = c->y.xR[i];
   }
   for (i = 0; i < c->l; i++) {
      z.xR[i] = c->z.xR[i];
   }
   for (i = 0; i < c->m * c->n * c->l * c->d; i++) {
      f.xR[i] = a * c->f.xR[i] + b;
   }
   if (c->stype == -1) {
      spline3dbuildtrilinearv(&x, c->n, &y, c->m, &z, c->l, &f, c->d, c, _state);
   }
   ae_frame_leave(_state);
}

// This subroutine makes the copy of the spline model.
//
// Inputs:
//     C   -   spline interpolant
//
// Outputs:
//     CC  -   spline copy
// ALGLIB Project: Copyright 26.04.2012 by Sergey Bochkanov
void spline3dcopy(spline3dinterpolant *c, spline3dinterpolant *cc, ae_state *_state) {
   ae_int_t tblsize;
   SetObj(spline3dinterpolant, cc);
   ae_assert(c->k == 1 || c->k == 3, "Spline3DCopy: incorrect C (incorrect parameter C.K)", _state);
   cc->k = c->k;
   cc->n = c->n;
   cc->m = c->m;
   cc->l = c->l;
   cc->d = c->d;
   tblsize = c->n * c->m * c->l * c->d;
   cc->stype = c->stype;
   ae_vector_set_length(&cc->x, cc->n, _state);
   ae_vector_set_length(&cc->y, cc->m, _state);
   ae_vector_set_length(&cc->z, cc->l, _state);
   ae_vector_set_length(&cc->f, tblsize, _state);
   ae_v_move(cc->x.xR, 1, c->x.xR, 1, cc->n);
   ae_v_move(cc->y.xR, 1, c->y.xR, 1, cc->m);
   ae_v_move(cc->z.xR, 1, c->z.xR, 1, cc->l);
   ae_v_move(cc->f.xR, 1, c->f.xR, 1, tblsize);
}

// This subroutine unpacks tri-dimensional spline into the coefficients table
//
// Inputs:
//     C   -   spline interpolant.
//
// Result:
//     N   -   grid size (X)
//     M   -   grid size (Y)
//     L   -   grid size (Z)
//     D   -   number of components
//     SType-  spline type. Currently, only one spline type is supported:
//             trilinear spline, as indicated by SType=1.
//     Tbl -   spline coefficients: [0..(N-1)*(M-1)*(L-1)*D-1, 0..13].
//             For T=0..D-1 (component index), I = 0...N-2 (x index),
//             J=0..M-2 (y index), K=0..L-2 (z index):
//                 Q := T + I*D + J*D*(N-1) + K*D*(N-1)*(M-1),
//
//                 Q-th row stores decomposition for T-th component of the
//                 vector-valued function
//
//                 Tbl[Q,0] = X[i]
//                 Tbl[Q,1] = X[i+1]
//                 Tbl[Q,2] = Y[j]
//                 Tbl[Q,3] = Y[j+1]
//                 Tbl[Q,4] = Z[k]
//                 Tbl[Q,5] = Z[k+1]
//
//                 Tbl[Q,6] = C000
//                 Tbl[Q,7] = C100
//                 Tbl[Q,8] = C010
//                 Tbl[Q,9] = C110
//                 Tbl[Q,10]= C001
//                 Tbl[Q,11]= C101
//                 Tbl[Q,12]= C011
//                 Tbl[Q,13]= C111
//             On each grid square spline is equals to:
//                 S(x) = SUM(c[i,j,k]*(x^i)*(y^j)*(z^k), i=0..1, j=0..1, k=0..1)
//                 t = x-x[j]
//                 u = y-y[i]
//                 v = z-z[k]
//
//             NOTE: format of Tbl is given for SType=1. Future versions of
//                   ALGLIB can use different formats for different values of
//                   SType.
// ALGLIB Project: Copyright 26.04.2012 by Sergey Bochkanov
// API: void spline3dunpackv(const spline3dinterpolant &c, ae_int_t &n, ae_int_t &m, ae_int_t &l, ae_int_t &d, ae_int_t &stype, real_2d_array &tbl, const xparams _xparams = xdefault);
void spline3dunpackv(spline3dinterpolant *c, ae_int_t *n, ae_int_t *m, ae_int_t *l, ae_int_t *d, ae_int_t *stype, RMatrix *tbl, ae_state *_state) {
   ae_int_t p;
   ae_int_t ci;
   ae_int_t cj;
   ae_int_t ck;
   double du;
   double dv;
   double dw;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t di;
   ae_int_t i0;
   *n = 0;
   *m = 0;
   *l = 0;
   *d = 0;
   *stype = 0;
   SetMatrix(tbl);
   ae_assert(c->stype == -1, "Spline3DUnpackV: incorrect C (incorrect parameter C.SType)", _state);
   *n = c->n;
   *m = c->m;
   *l = c->l;
   *d = c->d;
   *stype = ae_iabs(c->stype, _state);
   ae_matrix_set_length(tbl, (*n - 1) * (*m - 1) * (*l - 1) * (*d), 14, _state);
// Fill
   for (i = 0; i < *n - 1; i++) {
      for (j = 0; j < *m - 1; j++) {
         for (k = 0; k < *l - 1; k++) {
            for (di = 0; di < *d; di++) {
               p = *d * ((*n - 1) * ((*m - 1) * k + j) + i) + di;
               tbl->xyR[p][0] = c->x.xR[i];
               tbl->xyR[p][1] = c->x.xR[i + 1];
               tbl->xyR[p][2] = c->y.xR[j];
               tbl->xyR[p][3] = c->y.xR[j + 1];
               tbl->xyR[p][4] = c->z.xR[k];
               tbl->xyR[p][5] = c->z.xR[k + 1];
               du = 1 / (tbl->xyR[p][1] - tbl->xyR[p][0]);
               dv = 1 / (tbl->xyR[p][3] - tbl->xyR[p][2]);
               dw = 1 / (tbl->xyR[p][5] - tbl->xyR[p][4]);
            // Trilinear interpolation
               if (c->stype == -1) {
                  for (i0 = 6; i0 <= 13; i0++) {
                     tbl->xyR[p][i0] = 0.0;
                  }
                  tbl->xyR[p][6 + 2 * (2 * 0 + 0) + 0] = c->f.xR[*d * (*n * (*m * k + j) + i) + di];
                  tbl->xyR[p][6 + 2 * (2 * 0 + 0) + 1] = c->f.xR[*d * (*n * (*m * k + j) + (i + 1)) + di] - c->f.xR[*d * (*n * (*m * k + j) + i) + di];
                  tbl->xyR[p][6 + 2 * (2 * 0 + 1) + 0] = c->f.xR[*d * (*n * (*m * k + (j + 1)) + i) + di] - c->f.xR[*d * (*n * (*m * k + j) + i) + di];
                  tbl->xyR[p][6 + 2 * (2 * 0 + 1) + 1] = c->f.xR[*d * (*n * (*m * k + (j + 1)) + (i + 1)) + di] - c->f.xR[*d * (*n * (*m * k + (j + 1)) + i) + di] - c->f.xR[*d * (*n * (*m * k + j) + (i + 1)) + di] + c->f.xR[*d * (*n * (*m * k + j) + i) + di];
                  tbl->xyR[p][6 + 2 * (2 * 1 + 0) + 0] = c->f.xR[*d * (*n * (*m * (k + 1) + j) + i) + di] - c->f.xR[*d * (*n * (*m * k + j) + i) + di];
                  tbl->xyR[p][6 + 2 * (2 * 1 + 0) + 1] = c->f.xR[*d * (*n * (*m * (k + 1) + j) + (i + 1)) + di] - c->f.xR[*d * (*n * (*m * (k + 1) + j) + i) + di] - c->f.xR[*d * (*n * (*m * k + j) + (i + 1)) + di] + c->f.xR[*d * (*n * (*m * k + j) + i) + di];
                  tbl->xyR[p][6 + 2 * (2 * 1 + 1) + 0] = c->f.xR[*d * (*n * (*m * (k + 1) + (j + 1)) + i) + di] - c->f.xR[*d * (*n * (*m * (k + 1) + j) + i) + di] - c->f.xR[*d * (*n * (*m * k + (j + 1)) + i) + di] + c->f.xR[*d * (*n * (*m * k + j) + i) + di];
                  tbl->xyR[p][6 + 2 * (2 * 1 + 1) + 1] = c->f.xR[*d * (*n * (*m * (k + 1) + (j + 1)) + (i + 1)) + di] - c->f.xR[*d * (*n * (*m * (k + 1) + (j + 1)) + i) + di] - c->f.xR[*d * (*n * (*m * (k + 1) + j) + (i + 1)) + di] + c->f.xR[*d * (*n * (*m * (k + 1) + j) + i) + di] - c->f.xR[*d * (*n * (*m * k + (j + 1)) + (i + 1)) + di] + c->f.xR[*d * (*n * (*m * k + (j + 1)) + i) + di] + c->f.xR[*d * (*n * (*m * k + j) + (i + 1)) + di] - c->f.xR[*d * (*n * (*m * k + j) + i) + di];
               }
            // Rescale Cij
               for (ci = 0; ci <= 1; ci++) {
                  for (cj = 0; cj <= 1; cj++) {
                     for (ck = 0; ck <= 1; ck++) {
                        tbl->xyR[p][6 + 2 * (2 * ck + cj) + ci] *= ae_pow(du, (double)ci, _state) * ae_pow(dv, (double)cj, _state) * ae_pow(dw, (double)ck, _state);
                     }
                  }
               }
            }
         }
      }
   }
}

void spline3dinterpolant_init(void *_p, ae_state *_state, bool make_automatic) {
   spline3dinterpolant *p = (spline3dinterpolant *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_init(&p->x, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->y, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->z, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->f, 0, DT_REAL, _state, make_automatic);
}

void spline3dinterpolant_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   spline3dinterpolant *dst = (spline3dinterpolant *)_dst;
   spline3dinterpolant *src = (spline3dinterpolant *)_src;
   dst->k = src->k;
   dst->stype = src->stype;
   dst->n = src->n;
   dst->m = src->m;
   dst->l = src->l;
   dst->d = src->d;
   ae_vector_copy(&dst->x, &src->x, _state, make_automatic);
   ae_vector_copy(&dst->y, &src->y, _state, make_automatic);
   ae_vector_copy(&dst->z, &src->z, _state, make_automatic);
   ae_vector_copy(&dst->f, &src->f, _state, make_automatic);
}

void spline3dinterpolant_free(void *_p, bool make_automatic) {
   spline3dinterpolant *p = (spline3dinterpolant *)_p;
   ae_touch_ptr((void *)p);
   ae_vector_free(&p->x, make_automatic);
   ae_vector_free(&p->y, make_automatic);
   ae_vector_free(&p->z, make_automatic);
   ae_vector_free(&p->f, make_automatic);
}
} // end of namespace alglib_impl

namespace alglib {
// 3-dimensional spline inteprolant
DefClass(spline3dinterpolant, )

void spline3dcalcvbuf(const spline3dinterpolant &c, const double x, const double y, const double z, real_1d_array &f, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline3dcalcvbuf(ConstT(spline3dinterpolant, c), x, y, z, ConstT(ae_vector, f), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline3dcalcv(const spline3dinterpolant &c, const double x, const double y, const double z, real_1d_array &f, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline3dcalcv(ConstT(spline3dinterpolant, c), x, y, z, ConstT(ae_vector, f), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

double spline3dcalc(const spline3dinterpolant &c, const double x, const double y, const double z, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::spline3dcalc(ConstT(spline3dinterpolant, c), x, y, z, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

void spline3dresampletrilinear(const real_1d_array &a, const ae_int_t oldzcount, const ae_int_t oldycount, const ae_int_t oldxcount, const ae_int_t newzcount, const ae_int_t newycount, const ae_int_t newxcount, real_1d_array &b, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline3dresampletrilinear(ConstT(ae_vector, a), oldzcount, oldycount, oldxcount, newzcount, newycount, newxcount, ConstT(ae_vector, b), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline3dbuildtrilinearv(const real_1d_array &x, const ae_int_t n, const real_1d_array &y, const ae_int_t m, const real_1d_array &z, const ae_int_t l, const real_1d_array &f, const ae_int_t d, spline3dinterpolant &c, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline3dbuildtrilinearv(ConstT(ae_vector, x), n, ConstT(ae_vector, y), m, ConstT(ae_vector, z), l, ConstT(ae_vector, f), d, ConstT(spline3dinterpolant, c), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline3dlintransxyz(const spline3dinterpolant &c, const double ax, const double bx, const double ay, const double by, const double az, const double bz, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline3dlintransxyz(ConstT(spline3dinterpolant, c), ax, bx, ay, by, az, bz, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline3dlintransf(const spline3dinterpolant &c, const double a, const double b, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline3dlintransf(ConstT(spline3dinterpolant, c), a, b, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline3dunpackv(const spline3dinterpolant &c, ae_int_t &n, ae_int_t &m, ae_int_t &l, ae_int_t &d, ae_int_t &stype, real_2d_array &tbl, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline3dunpackv(ConstT(spline3dinterpolant, c), &n, &m, &l, &d, &stype, ConstT(ae_matrix, tbl), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
} // end of namespace alglib

// === INTCOMP Package ===
// Depends on: SPLINE1D, FITSPHERE
namespace alglib_impl {
// This function is left for backward compatibility.
// Use fitspherex() instead.
// ALGLIB: Copyright 14.04.2017 by Sergey Bochkanov
// API: void nsfitspherex(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, const ae_int_t problemtype, const double epsx, const ae_int_t aulits, const double penalty, real_1d_array &cx, double &rlo, double &rhi, const xparams _xparams = xdefault);
void nsfitspherex(RMatrix *xy, ae_int_t npoints, ae_int_t nx, ae_int_t problemtype, double epsx, ae_int_t aulits, double penalty, RVector *cx, double *rlo, double *rhi, ae_state *_state) {
   SetVector(cx);
   *rlo = 0;
   *rhi = 0;
   fitspherex(xy, npoints, nx, problemtype, epsx, aulits, penalty, cx, rlo, rhi, _state);
}

// This function is left for backward compatibility.
// Use fitspheremc() instead.
// ALGLIB: Copyright 14.04.2017 by Sergey Bochkanov
// API: void nsfitspheremcc(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, real_1d_array &cx, double &rhi, const xparams _xparams = xdefault);
void nsfitspheremcc(RMatrix *xy, ae_int_t npoints, ae_int_t nx, RVector *cx, double *rhi, ae_state *_state) {
   double dummy;
   SetVector(cx);
   *rhi = 0;
   nsfitspherex(xy, npoints, nx, 1, 0.0, 0, 0.0, cx, &dummy, rhi, _state);
}

// This function is left for backward compatibility.
// Use fitspheremi() instead.
// ALGLIB: Copyright 14.04.2017 by Sergey Bochkanov
// API: void nsfitspheremic(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, real_1d_array &cx, double &rlo, const xparams _xparams = xdefault);
void nsfitspheremic(RMatrix *xy, ae_int_t npoints, ae_int_t nx, RVector *cx, double *rlo, ae_state *_state) {
   double dummy;
   SetVector(cx);
   *rlo = 0;
   nsfitspherex(xy, npoints, nx, 2, 0.0, 0, 0.0, cx, rlo, &dummy, _state);
}

// This function is left for backward compatibility.
// Use fitspheremz() instead.
// ALGLIB: Copyright 14.04.2017 by Sergey Bochkanov
// API: void nsfitspheremzc(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, real_1d_array &cx, double &rlo, double &rhi, const xparams _xparams = xdefault);
void nsfitspheremzc(RMatrix *xy, ae_int_t npoints, ae_int_t nx, RVector *cx, double *rlo, double *rhi, ae_state *_state) {
   SetVector(cx);
   *rlo = 0;
   *rhi = 0;
   nsfitspherex(xy, npoints, nx, 3, 0.0, 0, 0.0, cx, rlo, rhi, _state);
}

// This function is an obsolete and deprecated version of fitting by
// penalized cubic spline.
//
// It was superseded by spline1dfit(), which is an orders of magnitude faster
// and more memory-efficient implementation.
//
// Do NOT use this function in the new code!
// ALGLIB Project: Copyright 19.10.2010 by Sergey Bochkanov
// API: void spline1dfitpenalizedw(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const ae_int_t n, const ae_int_t m, const double rho, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams = xdefault);
// API: void spline1dfitpenalizedw(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const ae_int_t m, const double rho, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams = xdefault);
void spline1dfitpenalizedw(RVector *x, RVector *y, RVector *w, ae_int_t n, ae_int_t m, double rho, ae_int_t *info, spline1dinterpolant *s, spline1dfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t b;
   double v;
   double relcnt;
   double xa;
   double xb;
   double sa;
   double sb;
   double pdecay;
   double tdecay;
   double fdmax;
   double admax;
   double fa;
   double ga;
   double fb;
   double gb;
   double lambdav;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   DupVector(w, _state);
   *info = 0;
   SetObj(spline1dinterpolant, s);
   SetObj(spline1dfitreport, rep);
   NewVector(xoriginal, 0, DT_REAL, _state);
   NewVector(yoriginal, 0, DT_REAL, _state);
   NewMatrix(fmatrix, 0, 0, DT_REAL, _state);
   NewVector(fcolumn, 0, DT_REAL, _state);
   NewVector(y2, 0, DT_REAL, _state);
   NewVector(w2, 0, DT_REAL, _state);
   NewVector(xc, 0, DT_REAL, _state);
   NewVector(yc, 0, DT_REAL, _state);
   NewVector(dc, 0, DT_INT, _state);
   NewMatrix(amatrix, 0, 0, DT_REAL, _state);
   NewMatrix(d2matrix, 0, 0, DT_REAL, _state);
   NewVector(bx, 0, DT_REAL, _state);
   NewVector(by, 0, DT_REAL, _state);
   NewVector(bd1, 0, DT_REAL, _state);
   NewVector(bd2, 0, DT_REAL, _state);
   NewVector(tx, 0, DT_REAL, _state);
   NewVector(ty, 0, DT_REAL, _state);
   NewVector(td, 0, DT_REAL, _state);
   NewObj(spline1dinterpolant, bs, _state);
   NewMatrix(nmatrix, 0, 0, DT_REAL, _state);
   NewVector(rightpart, 0, DT_REAL, _state);
   NewObj(fblslincgstate, cgstate, _state);
   NewVector(c, 0, DT_REAL, _state);
   NewVector(tmp0, 0, DT_REAL, _state);
   ae_assert(n >= 1, "Spline1DFitPenalizedW: N<1!", _state);
   ae_assert(m >= 4, "Spline1DFitPenalizedW: M<4!", _state);
   ae_assert(x->cnt >= n, "Spline1DFitPenalizedW: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DFitPenalizedW: Length(Y)<N!", _state);
   ae_assert(w->cnt >= n, "Spline1DFitPenalizedW: Length(W)<N!", _state);
   ae_assert(isfinitevector(x, n, _state), "Spline1DFitPenalizedW: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "Spline1DFitPenalizedW: Y contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(w, n, _state), "Spline1DFitPenalizedW: Y contains infinite or NAN values!", _state);
   ae_assert(ae_isfinite(rho, _state), "Spline1DFitPenalizedW: Rho is infinite!", _state);
// Prepare LambdaV
   v = -ae_log(machineepsilon, _state) / ae_log(10.0, _state);
   if (rho < -v) {
      rho = -v;
   }
   if (rho > v) {
      rho = v;
   }
   lambdav = ae_pow(10.0, rho, _state);
// Sort X, Y, W
   heapsortdpoints(x, y, w, n, _state);
// Scale X, Y, XC, YC
   lsfitscalexy(x, y, w, n, &xc, &yc, &dc, 0, &xa, &xb, &sa, &sb, &xoriginal, &yoriginal, _state);
// Allocate space
   ae_matrix_set_length(&fmatrix, n, m, _state);
   ae_matrix_set_length(&amatrix, m, m, _state);
   ae_matrix_set_length(&d2matrix, m, m, _state);
   ae_vector_set_length(&bx, m, _state);
   ae_vector_set_length(&by, m, _state);
   ae_vector_set_length(&fcolumn, n, _state);
   ae_matrix_set_length(&nmatrix, m, m, _state);
   ae_vector_set_length(&rightpart, m, _state);
   ae_vector_set_length(&tmp0, maxint(m, n, _state), _state);
   ae_vector_set_length(&c, m, _state);
// Fill:
// * FMatrix by values of basis functions
// * TmpAMatrix by second derivatives of I-th function at J-th point
// * CMatrix by constraints
   fdmax = 0.0;
   for (b = 0; b < m; b++) {
   // Prepare I-th basis function
      for (j = 0; j < m; j++) {
         bx.xR[j] = (double)(2 * j) / (m - 1) - 1;
         by.xR[j] = 0.0;
      }
      by.xR[b] = 1.0;
      spline1dgriddiff2cubic(&bx, &by, m, 2, 0.0, 2, 0.0, &bd1, &bd2, _state);
      spline1dbuildcubic(&bx, &by, m, 2, 0.0, 2, 0.0, &bs, _state);
   // Calculate B-th column of FMatrix
   // Update FDMax (maximum column norm)
      spline1dconvcubic(&bx, &by, m, 2, 0.0, 2, 0.0, x, n, &fcolumn, _state);
      ae_v_move(&fmatrix.xyR[0][b], fmatrix.stride, fcolumn.xR, 1, n);
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += sqr(w->xR[i] * fcolumn.xR[i], _state);
      }
      fdmax = maxreal(fdmax, v, _state);
   // Fill temporary with second derivatives of basis function
      ae_v_move(d2matrix.xyR[b], 1, bd2.xR, 1, m);
   }
// * calculate penalty matrix A
// * calculate max of diagonal elements of A
// * calculate PDecay - coefficient before penalty matrix
   for (i = 0; i < m; i++) {
      for (j = i; j < m; j++) {
      // calculate integral(B_i''*B_j'') where B_i and B_j are
      // i-th and j-th basis splines.
      // B_i and B_j are piecewise linear functions.
         v = 0.0;
         for (b = 0; b < m - 1; b++) {
            fa = d2matrix.xyR[i][b];
            fb = d2matrix.xyR[i][b + 1];
            ga = d2matrix.xyR[j][b];
            gb = d2matrix.xyR[j][b + 1];
            v += (bx.xR[b + 1] - bx.xR[b]) * (fa * ga + (fa * (gb - ga) + ga * (fb - fa)) / 2 + (fb - fa) * (gb - ga) / 3);
         }
         amatrix.xyR[i][j] = v;
         amatrix.xyR[j][i] = v;
      }
   }
   admax = 0.0;
   for (i = 0; i < m; i++) {
      admax = maxreal(admax, ae_fabs(amatrix.xyR[i][i], _state), _state);
   }
   pdecay = lambdav * fdmax / admax;
// Calculate TDecay for Tikhonov regularization
   tdecay = fdmax * (1 + pdecay) * 10 * machineepsilon;
// Prepare system
//
// NOTE: FMatrix is spoiled during this process
   for (i = 0; i < n; i++) {
      v = w->xR[i];
      ae_v_muld(fmatrix.xyR[i], 1, m, v);
   }
   rmatrixgemm(m, m, n, 1.0, &fmatrix, 0, 0, 1, &fmatrix, 0, 0, 0, 0.0, &nmatrix, 0, 0, _state);
   for (i = 0; i < m; i++) {
      for (j = 0; j < m; j++) {
         nmatrix.xyR[i][j] += pdecay * amatrix.xyR[i][j];
      }
   }
   for (i = 0; i < m; i++) {
      nmatrix.xyR[i][i] += tdecay;
   }
   for (i = 0; i < m; i++) {
      rightpart.xR[i] = 0.0;
   }
   for (i = 0; i < n; i++) {
      v = y->xR[i] * w->xR[i];
      ae_v_addd(rightpart.xR, 1, fmatrix.xyR[i], 1, m, v);
   }
// Solve system
   if (!spdmatrixcholesky(&nmatrix, m, true, _state)) {
      *info = -4;
      ae_frame_leave(_state);
      return;
   }
   fblscholeskysolve(&nmatrix, 1.0, m, true, &rightpart, &tmp0, _state);
   ae_v_move(c.xR, 1, rightpart.xR, 1, m);
// add nodes to force linearity outside of the fitting interval
   spline1dgriddiffcubic(&bx, &c, m, 2, 0.0, 2, 0.0, &bd1, _state);
   ae_vector_set_length(&tx, m + 2, _state);
   ae_vector_set_length(&ty, m + 2, _state);
   ae_vector_set_length(&td, m + 2, _state);
   ae_v_move(&tx.xR[1], 1, bx.xR, 1, m);
   ae_v_move(&ty.xR[1], 1, rightpart.xR, 1, m);
   ae_v_move(&td.xR[1], 1, bd1.xR, 1, m);
   tx.xR[0] = tx.xR[1] - (tx.xR[2] - tx.xR[1]);
   ty.xR[0] = ty.xR[1] - td.xR[1] * (tx.xR[2] - tx.xR[1]);
   td.xR[0] = td.xR[1];
   tx.xR[m + 1] = tx.xR[m] + (tx.xR[m] - tx.xR[m - 1]);
   ty.xR[m + 1] = ty.xR[m] + td.xR[m] * (tx.xR[m] - tx.xR[m - 1]);
   td.xR[m + 1] = td.xR[m];
   spline1dbuildhermite(&tx, &ty, &td, m + 2, s, _state);
   spline1dlintransx(s, 2 / (xb - xa), -(xa + xb) / (xb - xa), _state);
   spline1dlintransy(s, sb - sa, sa, _state);
   *info = 1;
// Fill report
   rep->rmserror = 0.0;
   rep->avgerror = 0.0;
   rep->avgrelerror = 0.0;
   rep->maxerror = 0.0;
   relcnt = 0.0;
   spline1dconvcubic(&bx, &rightpart, m, 2, 0.0, 2, 0.0, x, n, &fcolumn, _state);
   for (i = 0; i < n; i++) {
      v = (sb - sa) * fcolumn.xR[i] + sa;
      rep->rmserror += sqr(v - yoriginal.xR[i], _state);
      rep->avgerror += ae_fabs(v - yoriginal.xR[i], _state);
      if (yoriginal.xR[i] != 0.0) {
         rep->avgrelerror += ae_fabs(v - yoriginal.xR[i], _state) / ae_fabs(yoriginal.xR[i], _state);
         relcnt++;
      }
      rep->maxerror = maxreal(rep->maxerror, ae_fabs(v - yoriginal.xR[i], _state), _state);
   }
   rep->rmserror = ae_sqrt(rep->rmserror / n, _state);
   rep->avgerror /= n;
   if (relcnt != 0.0) {
      rep->avgrelerror /= relcnt;
   }
   ae_frame_leave(_state);
}

// This function is an obsolete and deprecated version of fitting by
// penalized cubic spline.
//
// It was superseded by spline1dfit(), which is an orders of magnitude faster
// and more memory-efficient implementation.
//
// Do NOT use this function in the new code!
// ALGLIB Project: Copyright 18.08.2009 by Sergey Bochkanov
// API: void spline1dfitpenalized(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t m, const double rho, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams = xdefault);
// API: void spline1dfitpenalized(const real_1d_array &x, const real_1d_array &y, const ae_int_t m, const double rho, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams = xdefault);
void spline1dfitpenalized(RVector *x, RVector *y, ae_int_t n, ae_int_t m, double rho, ae_int_t *info, spline1dinterpolant *s, spline1dfitreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   DupVector(x, _state);
   DupVector(y, _state);
   *info = 0;
   SetObj(spline1dinterpolant, s);
   SetObj(spline1dfitreport, rep);
   NewVector(w, 0, DT_REAL, _state);
   ae_assert(n >= 1, "Spline1DFitPenalized: N<1!", _state);
   ae_assert(m >= 4, "Spline1DFitPenalized: M<4!", _state);
   ae_assert(x->cnt >= n, "Spline1DFitPenalized: Length(X)<N!", _state);
   ae_assert(y->cnt >= n, "Spline1DFitPenalized: Length(Y)<N!", _state);
   ae_assert(isfinitevector(x, n, _state), "Spline1DFitPenalized: X contains infinite or NAN values!", _state);
   ae_assert(isfinitevector(y, n, _state), "Spline1DFitPenalized: Y contains infinite or NAN values!", _state);
   ae_assert(ae_isfinite(rho, _state), "Spline1DFitPenalized: Rho is infinite!", _state);
   ae_vector_set_length(&w, n, _state);
   for (i = 0; i < n; i++) {
      w.xR[i] = 1.0;
   }
   spline1dfitpenalizedw(x, y, &w, n, m, rho, info, s, rep, _state);
   ae_frame_leave(_state);
}
} // end of namespace alglib_impl

namespace alglib {
void nsfitspherex(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, const ae_int_t problemtype, const double epsx, const ae_int_t aulits, const double penalty, real_1d_array &cx, double &rlo, double &rhi, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::nsfitspherex(ConstT(ae_matrix, xy), npoints, nx, problemtype, epsx, aulits, penalty, ConstT(ae_vector, cx), &rlo, &rhi, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void nsfitspheremcc(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, real_1d_array &cx, double &rhi, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::nsfitspheremcc(ConstT(ae_matrix, xy), npoints, nx, ConstT(ae_vector, cx), &rhi, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void nsfitspheremic(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, real_1d_array &cx, double &rlo, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::nsfitspheremic(ConstT(ae_matrix, xy), npoints, nx, ConstT(ae_vector, cx), &rlo, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void nsfitspheremzc(const real_2d_array &xy, const ae_int_t npoints, const ae_int_t nx, real_1d_array &cx, double &rlo, double &rhi, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::nsfitspheremzc(ConstT(ae_matrix, xy), npoints, nx, ConstT(ae_vector, cx), &rlo, &rhi, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void spline1dfitpenalizedw(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const ae_int_t n, const ae_int_t m, const double rho, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dfitpenalizedw(ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_vector, w), n, m, rho, &info, ConstT(spline1dinterpolant, s), ConstT(spline1dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dfitpenalizedw(const real_1d_array &x, const real_1d_array &y, const real_1d_array &w, const ae_int_t m, const double rho, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams) {
   if (x.length() != y.length() || x.length() != w.length()) ThrowError("Error while calling 'spline1dfitpenalizedw': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dfitpenalizedw(ConstT(ae_vector, x), ConstT(ae_vector, y), ConstT(ae_vector, w), n, m, rho, &info, ConstT(spline1dinterpolant, s), ConstT(spline1dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void spline1dfitpenalized(const real_1d_array &x, const real_1d_array &y, const ae_int_t n, const ae_int_t m, const double rho, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dfitpenalized(ConstT(ae_vector, x), ConstT(ae_vector, y), n, m, rho, &info, ConstT(spline1dinterpolant, s), ConstT(spline1dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void spline1dfitpenalized(const real_1d_array &x, const real_1d_array &y, const ae_int_t m, const double rho, ae_int_t &info, spline1dinterpolant &s, spline1dfitreport &rep, const xparams _xparams) {
   if (x.length() != y.length()) ThrowError("Error while calling 'spline1dfitpenalized': looks like one of arguments has wrong size");
   ae_int_t n = x.length();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::spline1dfitpenalized(ConstT(ae_vector, x), ConstT(ae_vector, y), n, m, rho, &info, ConstT(spline1dinterpolant, s), ConstT(spline1dfitreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif
} // end of namespace alglib

// === RBF Package ===
// Depends on: RBFV1, RBFV2
namespace alglib_impl {
static const double rbf_eps = 1.0E-6;
static const double rbf_rbffarradius = 6.0;
static const ae_int_t rbf_rbffirstversion = 0;
static const ae_int_t rbf_rbfversion2 = 2;

// Initialize empty model
// ALGLIB: Copyright 12.05.2016 by Sergey Bochkanov
static void rbf_rbfpreparenonserializablefields(rbfmodel *s, ae_state *_state) {
   s->n = 0;
   s->hasscale = false;
   s->radvalue = 1.0;
   s->radzvalue = 5.0;
   s->nlayers = 0;
   s->lambdav = 0.0;
   s->aterm = 1;
   s->algorithmtype = 0;
   s->epsort = rbf_eps;
   s->epserr = rbf_eps;
   s->maxits = 0;
   s->nnmaxits = 100;
}

// Initialize V1 model (skip initialization for NX=1 or NX>3)
// ALGLIB: Copyright 12.05.2016 by Sergey Bochkanov
static void rbf_initializev1(ae_int_t nx, ae_int_t ny, rbfv1model *s, ae_state *_state) {
   SetObj(rbfv1model, s);
   if (nx == 2 || nx == 3) {
      rbfv1create(nx, ny, s, _state);
   }
}

// Initialize V2 model
// ALGLIB: Copyright 12.05.2016 by Sergey Bochkanov
static void rbf_initializev2(ae_int_t nx, ae_int_t ny, rbfv2model *s, ae_state *_state) {
   SetObj(rbfv2model, s);
   rbfv2create(nx, ny, s, _state);
}

// Cleans report fields
// ALGLIB: Copyright 16.06.2016 by Sergey Bochkanov
static void rbf_clearreportfields(rbfreport *rep, ae_state *_state) {
   rep->rmserror = _state->v_nan;
   rep->maxerror = _state->v_nan;
   rep->arows = 0;
   rep->acols = 0;
   rep->annz = 0;
   rep->iterationscount = 0;
   rep->nmv = 0;
   rep->terminationtype = 0;
}

// This function creates RBF  model  for  a  scalar (NY=1)  or  vector (NY>1)
// function in a NX-dimensional space (NX >= 1).
//
// Newly created model is empty. It can be used for interpolation right after
// creation, but it just returns zeros. You have to add points to the  model,
// tune interpolation settings, and then  call  model  construction  function
// rbfbuildmodel() which will update model according to your specification.
//
// USAGE:
// 1. User creates model with rbfcreate()
// 2. User adds dataset with rbfsetpoints() (points do NOT have to  be  on  a
//    regular grid) or rbfsetpointsandscales().
// 3. (OPTIONAL) User chooses polynomial term by calling:
//    * rbflinterm() to set linear term
//    * rbfconstterm() to set constant term
//    * rbfzeroterm() to set zero term
//    By default, linear term is used.
// 4. User tweaks algorithm properties with  rbfsetalgohierarchical()  method
//    (or chooses one of the legacy algorithms - QNN  (rbfsetalgoqnn)  or  ML
//    (rbfsetalgomultilayer)).
// 5. User calls rbfbuildmodel() function which rebuilds model  according  to
//    the specification
// 6. User may call rbfcalc() to calculate model value at the specified point,
//    rbfgridcalc() to  calculate   model  values at the points of the regular
//    grid. User may extract model coefficients with rbfunpack() call.
//
// IMPORTANT: we recommend you to use latest model construction  algorithm  -
//            hierarchical RBFs, which is activated by rbfsetalgohierarchical()
//            function. This algorithm is the fastest one, and  most  memory-
//            efficient.
//            However,  it  is  incompatible  with older versions  of  ALGLIB
//            (pre-3.11). So, if you serialize hierarchical model,  you  will
//            be unable to load it in pre-3.11 ALGLIB. Other model types (QNN
//            and RBF-ML) are still backward-compatible.
//
// Inputs:
//     NX      -   dimension of the space, NX >= 1
//     NY      -   function dimension, NY >= 1
//
// Outputs:
//     S       -   RBF model (initially equals to zero)
//
// NOTE 1: memory requirements. RBF models require amount of memory  which is
//         proportional  to the number of data points. Some additional memory
//         is allocated during model construction, but most of this memory is
//         freed after model coefficients  are  calculated.  Amount  of  this
//         additional memory depends on model  construction  algorithm  being
//         used.
//
// NOTE 2: prior to ALGLIB version 3.11, RBF models supported  only  NX=2  or
//         NX=3. Any  attempt  to  create  single-dimensional  or  more  than
//         3-dimensional RBF model resulted in exception.
//
//         ALGLIB 3.11 supports any NX>0, but models created with  NX != 2  and
//         NX != 3 are incompatible with (a) older versions of ALGLIB, (b)  old
//         model construction algorithms (QNN or RBF-ML).
//
//         So, if you create a model with NX=2 or NX=3,  then,  depending  on
//         specific  model construction algorithm being chosen, you will (QNN
//         and RBF-ML) or will not (HierarchicalRBF) get backward compatibility
//         with older versions of ALGLIB. You have a choice here.
//
//         However, if you create a model with NX neither 2 nor 3,  you  have
//         no backward compatibility from the start, and you  are  forced  to
//         use hierarchical RBFs and ALGLIB 3.11 or later.
// ALGLIB: Copyright 13.12.2011, 20.06.2016 by Sergey Bochkanov
// API: void rbfcreate(const ae_int_t nx, const ae_int_t ny, rbfmodel &s, const xparams _xparams = xdefault);
void rbfcreate(ae_int_t nx, ae_int_t ny, rbfmodel *s, ae_state *_state) {
   SetObj(rbfmodel, s);
   ae_assert(nx >= 1, "RBFCreate: NX<1", _state);
   ae_assert(ny >= 1, "RBFCreate: NY<1", _state);
   s->nx = nx;
   s->ny = ny;
   rbf_rbfpreparenonserializablefields(s, _state);
// Select default model version according to NX.
//
// The idea is that when we call this function with NX=2 or NX=3, backward
// compatible dummy (zero) V1 model is created, so serialization produces
// model which are compatible with pre-3.11 ALGLIB.
   rbf_initializev1(nx, ny, &s->model1, _state);
   rbf_initializev2(nx, ny, &s->model2, _state);
   if (nx == 2 || nx == 3) {
      s->modelversion = 1;
   } else {
      s->modelversion = 2;
   }
// Report fields
   s->progress10000 = 0;
   s->terminationrequest = false;
}

// This function creates buffer  structure  which  can  be  used  to  perform
// parallel  RBF  model  evaluations  (with  one  RBF  model  instance  being
// used from multiple threads, as long as  different  threads  use  different
// instances of buffer).
//
// This buffer object can be used with  rbftscalcbuf()  function  (here  "ts"
// stands for "thread-safe", "buf" is a suffix which denotes  function  which
// reuses previously allocated output space).
//
// How to use it:
// * create RBF model structure with rbfcreate()
// * load data, tune parameters
// * call rbfbuildmodel()
// * call rbfcreatecalcbuffer(), once per thread working with RBF model  (you
//   should call this function only AFTER call to rbfbuildmodel(), see  below
//   for more information)
// * call rbftscalcbuf() from different threads,  with  each  thread  working
//   with its own copy of buffer object.
//
// Inputs:
//     S           -   RBF model
//
// Outputs:
//     Buf         -   external buffer.
//
//
// IMPORTANT: buffer object should be used only with  RBF model object  which
//            was used to initialize buffer. Any attempt to use buffer   with
//            different object is dangerous - you may  get  memory  violation
//            error because sizes of internal arrays do not fit to dimensions
//            of RBF structure.
//
// IMPORTANT: you  should  call  this function only for model which was built
//            with rbfbuildmodel() function, after successful  invocation  of
//            rbfbuildmodel().  Sizes   of   some   internal  structures  are
//            determined only after model is built, so buffer object  created
//            before model  construction  stage  will  be  useless  (and  any
//            attempt to use it will result in exception).
// ALGLIB: Copyright 02.04.2016 by Sergey Bochkanov
// API: void rbfcreatecalcbuffer(const rbfmodel &s, rbfcalcbuffer &buf, const xparams _xparams = xdefault);
void rbfcreatecalcbuffer(rbfmodel *s, rbfcalcbuffer *buf, ae_state *_state) {
   SetObj(rbfcalcbuffer, buf);
   if (s->modelversion == 1) {
      buf->modelversion = 1;
      rbfv1createcalcbuffer(&s->model1, &buf->bufv1, _state);
      return;
   }
   if (s->modelversion == 2) {
      buf->modelversion = 2;
      rbfv2createcalcbuffer(&s->model2, &buf->bufv2, _state);
      return;
   }
   ae_assert(false, "RBFCreateCalcBuffer: integrity check failed", _state);
}

// This function adds dataset.
//
// This function overrides results of the previous calls, i.e. multiple calls
// of this function will result in only the last set being added.
//
// IMPORTANT: ALGLIB version 3.11 and later allows you to specify  a  set  of
//            per-dimension scales. Interpolation radii are multiplied by the
//            scale vector. It may be useful if you have mixed spatio-temporal
//            data (say, a set of 3D slices recorded at different times).
//            You should call rbfsetpointsandscales() function  to  use  this
//            feature.
//
// Inputs:
//     S       -   RBF model, initialized by rbfcreate() call.
//     XY      -   points, array[N,NX+NY]. One row corresponds to  one  point
//                 in the dataset. First NX elements  are  coordinates,  next
//                 NY elements are function values. Array may  be larger than
//                 specified, in  this  case  only leading [N,NX+NY] elements
//                 will be used.
//     N       -   number of points in the dataset
//
// After you've added dataset and (optionally) tuned algorithm  settings  you
// should call rbfbuildmodel() in order to build a model for you.
//
// NOTE: dataset added by this function is not saved during model serialization.
//       MODEL ITSELF is serialized, but data used to build it are not.
//
//       So, if you 1) add dataset to  empty  RBF  model,  2)  serialize  and
//       unserialize it, then you will get an empty RBF model with no dataset
//       being attached.
//
//       From the other side, if you call rbfbuildmodel() between (1) and (2),
//       then after (2) you will get your fully constructed RBF model  -  but
//       again with no dataset attached, so subsequent calls to rbfbuildmodel()
//       will produce empty model.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: void rbfsetpoints(const rbfmodel &s, const real_2d_array &xy, const ae_int_t n, const xparams _xparams = xdefault);
// API: void rbfsetpoints(const rbfmodel &s, const real_2d_array &xy, const xparams _xparams = xdefault);
void rbfsetpoints(rbfmodel *s, RMatrix *xy, ae_int_t n, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   ae_assert(n > 0, "RBFSetPoints: N<0", _state);
   ae_assert(xy->rows >= n, "RBFSetPoints: Rows(XY)<N", _state);
   ae_assert(xy->cols >= s->nx + s->ny, "RBFSetPoints: Cols(XY)<NX+NY", _state);
   ae_assert(apservisfinitematrix(xy, n, s->nx + s->ny, _state), "RBFSetPoints: XY contains infinite or NaN values!", _state);
   s->n = n;
   s->hasscale = false;
   ae_matrix_set_length(&s->x, s->n, s->nx, _state);
   ae_matrix_set_length(&s->y, s->n, s->ny, _state);
   for (i = 0; i < s->n; i++) {
      for (j = 0; j < s->nx; j++) {
         s->x.xyR[i][j] = xy->xyR[i][j];
      }
      for (j = 0; j < s->ny; j++) {
         s->y.xyR[i][j] = xy->xyR[i][j + s->nx];
      }
   }
}

// This function adds dataset and a vector of per-dimension scales.
//
// It may be useful if you have mixed spatio-temporal data - say, a set of 3D
// slices recorded at different times. Such data typically require  different
// RBF radii for spatial and temporal dimensions. ALGLIB solves this  problem
// by specifying single RBF radius, which is (optionally) multiplied  by  the
// scale vector.
//
// This function overrides results of the previous calls, i.e. multiple calls
// of this function will result in only the last set being added.
//
// IMPORTANT: only HierarchicalRBF algorithm can work with scaled points. So,
//            using this function results in RBF models which can be used  in
//            ALGLIB 3.11 or later. Previous versions of the library will  be
//            unable  to unserialize models produced by HierarchicalRBF algo.
//
//            Any attempt to use this function with RBF-ML or QNN  algorithms
//            will result  in  -3  error  code   being   returned  (incorrect
//            algorithm).
//
// Inputs:
//     R       -   RBF model, initialized by rbfcreate() call.
//     XY      -   points, array[N,NX+NY]. One row corresponds to  one  point
//                 in the dataset. First NX elements  are  coordinates,  next
//                 NY elements are function values. Array may  be larger than
//                 specified, in  this  case  only leading [N,NX+NY] elements
//                 will be used.
//     N       -   number of points in the dataset
//     S       -   array[NX], scale vector, S[i]>0.
//
// After you've added dataset and (optionally) tuned algorithm  settings  you
// should call rbfbuildmodel() in order to build a model for you.
//
// NOTE: dataset added by this function is not saved during model serialization.
//       MODEL ITSELF is serialized, but data used to build it are not.
//
//       So, if you 1) add dataset to  empty  RBF  model,  2)  serialize  and
//       unserialize it, then you will get an empty RBF model with no dataset
//       being attached.
//
//       From the other side, if you call rbfbuildmodel() between (1) and (2),
//       then after (2) you will get your fully constructed RBF model  -  but
//       again with no dataset attached, so subsequent calls to rbfbuildmodel()
//       will produce empty model.
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
// API: void rbfsetpointsandscales(const rbfmodel &r, const real_2d_array &xy, const ae_int_t n, const real_1d_array &s, const xparams _xparams = xdefault);
// API: void rbfsetpointsandscales(const rbfmodel &r, const real_2d_array &xy, const real_1d_array &s, const xparams _xparams = xdefault);
void rbfsetpointsandscales(rbfmodel *r, RMatrix *xy, ae_int_t n, RVector *s, ae_state *_state) {
   ae_int_t i;
   ae_int_t j;
   ae_assert(n > 0, "RBFSetPointsAndScales: N<0", _state);
   ae_assert(xy->rows >= n, "RBFSetPointsAndScales: Rows(XY)<N", _state);
   ae_assert(xy->cols >= r->nx + r->ny, "RBFSetPointsAndScales: Cols(XY)<NX+NY", _state);
   ae_assert(s->cnt >= r->nx, "RBFSetPointsAndScales: Length(S)<NX", _state);
   r->n = n;
   r->hasscale = true;
   ae_matrix_set_length(&r->x, r->n, r->nx, _state);
   ae_matrix_set_length(&r->y, r->n, r->ny, _state);
   for (i = 0; i < r->n; i++) {
      for (j = 0; j < r->nx; j++) {
         r->x.xyR[i][j] = xy->xyR[i][j];
      }
      for (j = 0; j < r->ny; j++) {
         r->y.xyR[i][j] = xy->xyR[i][j + r->nx];
      }
   }
   ae_vector_set_length(&r->s, r->nx, _state);
   for (i = 0; i < r->nx; i++) {
      ae_assert(ae_isfinite(s->xR[i], _state), "RBFSetPointsAndScales: S[i] is not finite number", _state);
      ae_assert(s->xR[i] > 0.0, "RBFSetPointsAndScales: S[i] <= 0", _state);
      r->s.xR[i] = s->xR[i];
   }
}

// DEPRECATED:since version 3.11 ALGLIB includes new RBF  model  construction
//            algorithm, Hierarchical  RBF.  This  algorithm  is  faster  and
//            requires less memory than QNN and RBF-ML. It is especially good
//            for large-scale interpolation problems. So, we recommend you to
//            consider Hierarchical RBF as default option.
//
// This  function  sets  RBF interpolation algorithm. ALGLIB supports several
// RBF algorithms with different properties.
//
// This algorithm is called RBF-QNN and  it  is  good  for  point  sets  with
// following properties:
// a) all points are distinct
// b) all points are well separated.
// c) points  distribution  is  approximately  uniform.  There is no "contour
//    lines", clusters of points, or other small-scale structures.
//
// Algorithm description:
// 1) interpolation centers are allocated to data points
// 2) interpolation radii are calculated as distances to the  nearest centers
//    times Q coefficient (where Q is a value from [0.75,1.50]).
// 3) after  performing (2) radii are transformed in order to avoid situation
//    when single outlier has very large radius and  influences  many  points
//    across all dataset. Transformation has following form:
//        new_r[i] = min(r[i],Z*median(r[]))
//    where r[i] is I-th radius, median()  is a median  radius across  entire
//    dataset, Z is user-specified value which controls amount  of  deviation
//    from median radius.
//
// When (a) is violated,  we  will  be unable to build RBF model. When (b) or
// (c) are violated, model will be built, but interpolation quality  will  be
// low. See http://www.alglib.net/interpolation/ for more information on this
// subject.
//
// This algorithm is used by default.
//
// Additional Q parameter controls smoothness properties of the RBF basis:
// * Q<0.75 will give perfectly conditioned basis,  but  terrible  smoothness
//   properties (RBF interpolant will have sharp peaks around function values)
// * Q around 1.0 gives good balance between smoothness and condition number
// * Q>1.5 will lead to badly conditioned systems and slow convergence of the
//   underlying linear solver (although smoothness will be very good)
// * Q>2.0 will effectively make optimizer useless because it won't  converge
//   within reasonable amount of iterations. It is possible to set such large
//   Q, but it is advised not to do so.
//
// Inputs:
//     S       -   RBF model, initialized by RBFCreate() call
//     Q       -   Q parameter, Q>0, recommended value - 1.0
//     Z       -   Z parameter, Z>0, recommended value - 5.0
//
// NOTE: this   function  has   some   serialization-related  subtleties.  We
//       recommend you to study serialization examples from ALGLIB  Reference
//       Manual if you want to perform serialization of your models.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: void rbfsetalgoqnn(const rbfmodel &s, const double q, const double z, const xparams _xparams = xdefault);
// API: void rbfsetalgoqnn(const rbfmodel &s, const xparams _xparams = xdefault);
void rbfsetalgoqnn(rbfmodel *s, double q, double z, ae_state *_state) {
   ae_assert(ae_isfinite(q, _state), "RBFSetAlgoQNN: Q is infinite or NAN", _state);
   ae_assert(q > 0.0, "RBFSetAlgoQNN: Q <= 0", _state);
   ae_assert(ae_isfinite(z, _state), "RBFSetAlgoQNN: Z is infinite or NAN", _state);
   ae_assert(z > 0.0, "RBFSetAlgoQNN: Z <= 0", _state);
   s->radvalue = q;
   s->radzvalue = z;
   s->algorithmtype = 1;
}

// DEPRECATED:since version 3.11 ALGLIB includes new RBF  model  construction
//            algorithm, Hierarchical  RBF.  This  algorithm  is  faster  and
//            requires less memory than QNN and RBF-ML. It is especially good
//            for large-scale interpolation problems. So, we recommend you to
//            consider Hierarchical RBF as default option.
//
// This  function  sets  RBF interpolation algorithm. ALGLIB supports several
// RBF algorithms with different properties.
//
// This  algorithm is called RBF-ML. It builds  multilayer  RBF  model,  i.e.
// model with subsequently decreasing  radii,  which  allows  us  to  combine
// smoothness (due to  large radii of  the first layers) with  exactness (due
// to small radii of the last layers) and fast convergence.
//
// Internally RBF-ML uses many different  means  of acceleration, from sparse
// matrices  to  KD-trees,  which  results in algorithm whose working time is
// roughly proportional to N*log(N)*Density*RBase^2*NLayers,  where  N  is  a
// number of points, Density is an average density if points per unit of  the
// interpolation space, RBase is an initial radius, NLayers is  a  number  of
// layers.
//
// RBF-ML is good for following kinds of interpolation problems:
// 1. "exact" problems (perfect fit) with well separated points
// 2. least squares problems with arbitrary distribution of points (algorithm
//    gives  perfect  fit  where it is possible, and resorts to least squares
//    fit in the hard areas).
// 3. noisy problems where  we  want  to  apply  some  controlled  amount  of
//    smoothing.
//
// Inputs:
//     S       -   RBF model, initialized by RBFCreate() call
//     RBase   -   RBase parameter, RBase>0
//     NLayers -   NLayers parameter, NLayers>0, recommended value  to  start
//                 with - about 5.
//     LambdaV -   regularization value, can be useful when  solving  problem
//                 in the least squares sense.  Optimal  lambda  is  problem-
//                 dependent and require trial and error. In our  experience,
//                 good lambda can be as large as 0.1, and you can use  0.001
//                 as initial guess.
//                 Default  value  - 0.01, which is used when LambdaV is  not
//                 given.  You  can  specify  zero  value,  but  it  is   not
//                 recommended to do so.
//
// TUNING ALGORITHM
//
// In order to use this algorithm you have to choose three parameters:
// * initial radius RBase
// * number of layers in the model NLayers
// * regularization coefficient LambdaV
//
// Initial radius is easy to choose - you can pick any number  several  times
// larger  than  the  average  distance between points. Algorithm won't break
// down if you choose radius which is too large (model construction time will
// increase, but model will be built correctly).
//
// Choose such number of layers that RLast=RBase/2^(NLayers-1)  (radius  used
// by  the  last  layer)  will  be  smaller than the typical distance between
// points.  In  case  model  error  is  too large, you can increase number of
// layers.  Having  more  layers  will make model construction and evaluation
// proportionally slower, but it will allow you to have model which precisely
// fits your data. From the other side, if you want to  suppress  noise,  you
// can DECREASE number of layers to make your model less flexible.
//
// Regularization coefficient LambdaV controls smoothness of  the  individual
// models built for each layer. We recommend you to use default value in case
// you don't want to tune this parameter,  because  having  non-zero  LambdaV
// accelerates and stabilizes internal iterative algorithm. In case you  want
// to suppress noise you can use  LambdaV  as  additional  parameter  (larger
// value = more smoothness) to tune.
//
// TYPICAL ERRORS
//
// 1. Using  initial  radius  which is too large. Memory requirements  of the
//    RBF-ML are roughly proportional to N*Density*RBase^2 (where Density  is
//    an average density of points per unit of the interpolation  space).  In
//    the extreme case of the very large RBase we will need O(N^2)  units  of
//    memory - and many layers in order to decrease radius to some reasonably
//    small value.
//
// 2. Using too small number of layers - RBF models with large radius are not
//    flexible enough to reproduce small variations in the  target  function.
//    You  need  many  layers  with  different radii, from large to small, in
//    order to have good model.
//
// 3. Using  initial  radius  which  is  too  small.  You will get model with
//    "holes" in the areas which are too far away from interpolation centers.
//    However, algorithm will work correctly (and quickly) in this case.
//
// 4. Using too many layers - you will get too large and too slow model. This
//    model  will  perfectly  reproduce  your function, but maybe you will be
//    able to achieve similar results with less layers (and less memory).
// ALGLIB: Copyright 02.03.2012 by Sergey Bochkanov
// API: void rbfsetalgomultilayer(const rbfmodel &s, const double rbase, const ae_int_t nlayers, const double lambdav, const xparams _xparams = xdefault);
// API: void rbfsetalgomultilayer(const rbfmodel &s, const double rbase, const ae_int_t nlayers, const xparams _xparams = xdefault);
void rbfsetalgomultilayer(rbfmodel *s, double rbase, ae_int_t nlayers, double lambdav, ae_state *_state) {
   ae_assert(ae_isfinite(rbase, _state), "RBFSetAlgoMultiLayer: RBase is infinite or NaN", _state);
   ae_assert(rbase > 0.0, "RBFSetAlgoMultiLayer: RBase <= 0", _state);
   ae_assert(nlayers >= 0, "RBFSetAlgoMultiLayer: NLayers<0", _state);
   ae_assert(ae_isfinite(lambdav, _state), "RBFSetAlgoMultiLayer: LambdaV is infinite or NAN", _state);
   ae_assert(lambdav >= 0.0, "RBFSetAlgoMultiLayer: LambdaV<0", _state);
   s->radvalue = rbase;
   s->nlayers = nlayers;
   s->algorithmtype = 2;
   s->lambdav = lambdav;
}

// This  function  sets  RBF interpolation algorithm. ALGLIB supports several
// RBF algorithms with different properties.
//
// This  algorithm is called Hierarchical RBF. It  similar  to  its  previous
// incarnation, RBF-ML, i.e.  it  also  builds  a  sequence  of  models  with
// decreasing radii. However, it uses more economical way of  building  upper
// layers (ones with large radii), which results in faster model construction
// and evaluation, as well as smaller memory footprint during construction.
//
// This algorithm has following important features:
// * ability to handle millions of points
// * controllable smoothing via nonlinearity penalization
// * support for NX-dimensional models with NX=1 or NX>3 (unlike QNN or RBF-ML)
// * support for specification of per-dimensional  radii  via  scale  vector,
//   which is set by means of rbfsetpointsandscales() function. This  feature
//   is useful if you solve  spatio-temporal  interpolation  problems,  where
//   different radii are required for spatial and temporal dimensions.
//
// Running times are roughly proportional to:
// * N*log(N)*NLayers - for model construction
// * N*NLayers - for model evaluation
// You may see that running time does not depend on search radius  or  points
// density, just on number of layers in the hierarchy.
//
// IMPORTANT: this model construction algorithm was introduced in ALGLIB 3.11
//            and  produces  models  which  are  INCOMPATIBLE  with  previous
//            versions of ALGLIB. You can  not  unserialize  models  produced
//            with this function in ALGLIB 3.10 or earlier.
//
// Inputs:
//     S       -   RBF model, initialized by rbfcreate() call
//     RBase   -   RBase parameter, RBase>0
//     NLayers -   NLayers parameter, NLayers>0, recommended value  to  start
//                 with - about 5.
//     LambdaNS- >= 0, nonlinearity penalty coefficient, negative values are
//                 not allowed. This parameter adds controllable smoothing to
//                 the problem, which may reduce noise. Specification of non-
//                 zero lambda means that in addition to fitting error solver
//                 will  also  minimize   LambdaNS*|S''(x)|^2  (appropriately
//                 generalized to multiple dimensions.
//
//                 Specification of exactly zero value means that no  penalty
//                 is added  (we  do  not  even  evaluate  matrix  of  second
//                 derivatives which is necessary for smoothing).
//
//                 Calculation of nonlinearity penalty is costly - it results
//                 in  several-fold  increase  of  model  construction  time.
//                 Evaluation time remains the same.
//
//                 Optimal  lambda  is  problem-dependent and requires  trial
//                 and  error.  Good  value to  start  from  is  1e-5...1e-6,
//                 which corresponds to slightly noticeable smoothing  of the
//                 function.  Value  1e-2  usually  means  that  quite  heavy
//                 smoothing is applied.
//
// TUNING ALGORITHM
//
// In order to use this algorithm you have to choose three parameters:
// * initial radius RBase
// * number of layers in the model NLayers
// * penalty coefficient LambdaNS
//
// Initial radius is easy to choose - you can pick any number  several  times
// larger  than  the  average  distance between points. Algorithm won't break
// down if you choose radius which is too large (model construction time will
// increase, but model will be built correctly).
//
// Choose such number of layers that RLast=RBase/2^(NLayers-1)  (radius  used
// by  the  last  layer)  will  be  smaller than the typical distance between
// points.  In  case  model  error  is  too large, you can increase number of
// layers.  Having  more  layers  will make model construction and evaluation
// proportionally slower, but it will allow you to have model which precisely
// fits your data. From the other side, if you want to  suppress  noise,  you
// can DECREASE number of layers to make your model less flexible (or specify
// non-zero LambdaNS).
//
// TYPICAL ERRORS
//
// 1. Using too small number of layers - RBF models with large radius are not
//    flexible enough to reproduce small variations in the  target  function.
//    You  need  many  layers  with  different radii, from large to small, in
//    order to have good model.
//
// 2. Using  initial  radius  which  is  too  small.  You will get model with
//    "holes" in the areas which are too far away from interpolation centers.
//    However, algorithm will work correctly (and quickly) in this case.
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
// API: void rbfsetalgohierarchical(const rbfmodel &s, const double rbase, const ae_int_t nlayers, const double lambdans, const xparams _xparams = xdefault);
void rbfsetalgohierarchical(rbfmodel *s, double rbase, ae_int_t nlayers, double lambdans, ae_state *_state) {
   ae_assert(ae_isfinite(rbase, _state), "RBFSetAlgoHierarchical: RBase is infinite or NaN", _state);
   ae_assert(rbase > 0.0, "RBFSetAlgoHierarchical: RBase <= 0", _state);
   ae_assert(nlayers >= 0, "RBFSetAlgoHierarchical: NLayers<0", _state);
   ae_assert(ae_isfinite(lambdans, _state) && lambdans >= 0.0, "RBFSetAlgoHierarchical: LambdaNS<0 or infinite", _state);
   s->radvalue = rbase;
   s->nlayers = nlayers;
   s->algorithmtype = 3;
   s->lambdav = lambdans;
}

// This function sets linear term (model is a sum of radial  basis  functions
// plus linear polynomial). This function won't have effect until  next  call
// to RBFBuildModel().
//
// Inputs:
//     S       -   RBF model, initialized by RBFCreate() call
//
// NOTE: this   function  has   some   serialization-related  subtleties.  We
//       recommend you to study serialization examples from ALGLIB  Reference
//       Manual if you want to perform serialization of your models.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: void rbfsetlinterm(const rbfmodel &s, const xparams _xparams = xdefault);
void rbfsetlinterm(rbfmodel *s, ae_state *_state) {
   s->aterm = 1;
}

// This function sets constant term (model is a sum of radial basis functions
// plus constant).  This  function  won't  have  effect  until  next  call to
// RBFBuildModel().
//
// Inputs:
//     S       -   RBF model, initialized by RBFCreate() call
//
// NOTE: this   function  has   some   serialization-related  subtleties.  We
//       recommend you to study serialization examples from ALGLIB  Reference
//       Manual if you want to perform serialization of your models.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: void rbfsetconstterm(const rbfmodel &s, const xparams _xparams = xdefault);
void rbfsetconstterm(rbfmodel *s, ae_state *_state) {
   s->aterm = 2;
}

// This  function  sets  zero  term (model is a sum of radial basis functions
// without polynomial term). This function won't have effect until next  call
// to RBFBuildModel().
//
// Inputs:
//     S       -   RBF model, initialized by RBFCreate() call
//
// NOTE: this   function  has   some   serialization-related  subtleties.  We
//       recommend you to study serialization examples from ALGLIB  Reference
//       Manual if you want to perform serialization of your models.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: void rbfsetzeroterm(const rbfmodel &s, const xparams _xparams = xdefault);
void rbfsetzeroterm(rbfmodel *s, ae_state *_state) {
   s->aterm = 3;
}

// This function sets basis function type, which can be:
// * 0 for classic Gaussian
// * 1 for fast and compact bell-like basis function, which  becomes  exactly
//   zero at distance equal to 3*R (default option).
//
// Inputs:
//     S       -   RBF model, initialized by RBFCreate() call
//     BF      -   basis function type:
//                 * 0 - classic Gaussian
//                 * 1 - fast and compact one
// ALGLIB: Copyright 01.02.2017 by Sergey Bochkanov
// API: void rbfsetv2bf(const rbfmodel &s, const ae_int_t bf, const xparams _xparams = xdefault);
void rbfsetv2bf(rbfmodel *s, ae_int_t bf, ae_state *_state) {
   ae_assert(bf == 0 || bf == 1, "RBFSetV2Its: BF != 0 and BF != 1", _state);
   s->model2.basisfunction = bf;
}

// This function sets stopping criteria of the underlying linear  solver  for
// hierarchical (version 2) RBF constructor.
//
// Inputs:
//     S       -   RBF model, initialized by RBFCreate() call
//     MaxIts  -   this criterion will stop algorithm after MaxIts iterations.
//                 Typically a few hundreds iterations is required,  with 400
//                 being a good default value to start experimentation.
//                 Zero value means that default value will be selected.
// ALGLIB: Copyright 01.02.2017 by Sergey Bochkanov
// API: void rbfsetv2its(const rbfmodel &s, const ae_int_t maxits, const xparams _xparams = xdefault);
void rbfsetv2its(rbfmodel *s, ae_int_t maxits, ae_state *_state) {
   ae_assert(maxits >= 0, "RBFSetV2Its: MaxIts is negative", _state);
   s->model2.maxits = maxits;
}

// This function sets support radius parameter  of  hierarchical  (version 2)
// RBF constructor.
//
// Hierarchical RBF model achieves great speed-up  by removing from the model
// excessive (too dense) nodes. Say, if you have RBF radius equal to 1 meter,
// and two nodes are just 1 millimeter apart, you  may  remove  one  of  them
// without reducing model quality.
//
// Support radius parameter is used to justify which points need removal, and
// which do not. If two points are less than  SUPPORT_R*CUR_RADIUS  units  of
// distance apart, one of them is removed from the model. The larger  support
// radius  is, the faster model  construction  AND  evaluation are.  However,
// too large values result in "bumpy" models.
//
// Inputs:
//     S       -   RBF model, initialized by RBFCreate() call
//     R       -   support radius coefficient, >= 0.
//                 Recommended values are [0.1,0.4] range, with 0.1 being
//                 default value.
// ALGLIB: Copyright 01.02.2017 by Sergey Bochkanov
// API: void rbfsetv2supportr(const rbfmodel &s, const double r, const xparams _xparams = xdefault);
void rbfsetv2supportr(rbfmodel *s, double r, ae_state *_state) {
   ae_assert(ae_isfinite(r, _state), "RBFSetV2SupportR: R is not finite", _state);
   ae_assert(r >= 0.0, "RBFSetV2SupportR: R<0", _state);
   s->model2.supportr = r;
}

// This function sets stopping criteria of the underlying linear solver.
//
// Inputs:
//     S       -   RBF model, initialized by RBFCreate() call
//     EpsOrt  -   orthogonality stopping criterion, EpsOrt >= 0. Algorithm will
//                 stop when ||A'*r|| <= EpsOrt where A' is a transpose of  the
//                 system matrix, r is a residual vector.
//                 Recommended value of EpsOrt is equal to 1E-6.
//                 This criterion will stop algorithm when we have "bad fit"
//                 situation, i.e. when we should stop in a point with large,
//                 nonzero residual.
//     EpsErr  -   residual stopping  criterion.  Algorithm  will  stop  when
//                 ||r|| <= EpsErr*||b||, where r is a residual vector, b is  a
//                 right part of the system (function values).
//                 Recommended value of EpsErr is equal to 1E-3 or 1E-6.
//                 This  criterion  will  stop  algorithm  in  a  "good  fit"
//                 situation when we have near-zero residual near the desired
//                 solution.
//     MaxIts  -   this criterion will stop algorithm after MaxIts iterations.
//                 It should be used for debugging purposes only!
//                 Zero MaxIts means that no limit is placed on the number of
//                 iterations.
//
// We  recommend  to  set  moderate  non-zero  values   EpsOrt   and   EpsErr
// simultaneously. Values equal to 10E-6 are good to start with. In case  you
// need high performance and do not need high precision ,  you  may  decrease
// EpsErr down to 0.001. However, we do not recommend decreasing EpsOrt.
//
// As for MaxIts, we recommend to leave it zero unless you know what you do.
//
// NOTE: this   function  has   some   serialization-related  subtleties.  We
//       recommend you to study serialization examples from ALGLIB  Reference
//       Manual if you want to perform serialization of your models.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
void rbfsetcond(rbfmodel *s, double epsort, double epserr, ae_int_t maxits, ae_state *_state) {
   ae_assert(ae_isfinite(epsort, _state) && epsort >= 0.0, "RBFSetCond: EpsOrt is negative, INF or NAN", _state);
   ae_assert(ae_isfinite(epserr, _state) && epserr >= 0.0, "RBFSetCond: EpsB is negative, INF or NAN", _state);
   ae_assert(maxits >= 0, "RBFSetCond: MaxIts is negative", _state);
   if ((epsort == 0.0 && epserr == 0.0) && maxits == 0) {
      s->epsort = rbf_eps;
      s->epserr = rbf_eps;
      s->maxits = 0;
   } else {
      s->epsort = epsort;
      s->epserr = epserr;
      s->maxits = maxits;
   }
}

// This   function  builds  RBF  model  and  returns  report  (contains  some
// information which can be used for evaluation of the algorithm properties).
//
// Call to this function modifies RBF model by calculating its centers/radii/
// weights  and  saving  them  into  RBFModel  structure.  Initially RBFModel
// contain zero coefficients, but after call to this function  we  will  have
// coefficients which were calculated in order to fit our dataset.
//
// After you called this function you can call RBFCalc(),  RBFGridCalc()  and
// other model calculation functions.
//
// Inputs:
//     S       -   RBF model, initialized by RBFCreate() call
//     Rep     -   report:
//                 * Rep.TerminationType:
//                   * -5 - non-distinct basis function centers were detected,
//                          interpolation  aborted;  only  QNN  returns  this
//                          error   code, other  algorithms  can  handle non-
//                          distinct nodes.
//                   * -4 - nonconvergence of the internal SVD solver
//                   * -3   incorrect model construction algorithm was chosen:
//                          QNN or RBF-ML, combined with one of the incompatible
//                          features - NX=1 or NX>3; points with per-dimension
//                          scales.
//                   *  1 - successful termination
//                   *  8 - a termination request was submitted via
//                          rbfrequesttermination() function.
//
//                 Fields which are set only by modern RBF solvers (hierarchical
//                 or nonnegative; older solvers like QNN and ML initialize these
//                 fields by NANs):
//                 * rep.rmserror - root-mean-square error at nodes
//                 * rep.maxerror - maximum error at nodes
//
//                 Fields are used for debugging purposes:
//                 * Rep.IterationsCount - iterations count of the LSQR solver
//                 * Rep.NMV - number of matrix-vector products
//                 * Rep.ARows - rows count for the system matrix
//                 * Rep.ACols - columns count for the system matrix
//                 * Rep.ANNZ - number of significantly non-zero elements
//                   (elements above some algorithm-determined threshold)
//
// NOTE:  failure  to  build  model will leave current state of the structure
// unchanged.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: void rbfbuildmodel(const rbfmodel &s, rbfreport &rep, const xparams _xparams = xdefault);
void rbfbuildmodel(rbfmodel *s, rbfreport *rep, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t curalgorithmtype;
   ae_frame_make(_state, &_frame_block);
   SetObj(rbfreport, rep);
   NewObj(rbfv1report, rep1, _state);
   NewObj(rbfv2report, rep2, _state);
   NewMatrix(x3, 0, 0, DT_REAL, _state);
   NewVector(scalevec, 0, DT_REAL, _state);
// Clean fields prior to processing
   rbf_clearreportfields(rep, _state);
   s->progress10000 = 0;
   s->terminationrequest = false;
// Autoselect algorithm
   if (s->algorithmtype == 0) {
      if ((s->nx < 2 || s->nx > 3) || s->hasscale) {
         curalgorithmtype = 3;
      } else {
         curalgorithmtype = 1;
      }
   } else {
      curalgorithmtype = s->algorithmtype;
   }
// Algorithms which generate V1 models
   if (curalgorithmtype == 1 || curalgorithmtype == 2) {
   // Perform compatibility checks
      if ((s->nx < 2 || s->nx > 3) || s->hasscale) {
         rep->terminationtype = -3;
         ae_frame_leave(_state);
         return;
      }
   // Try to build model.
   //
   // NOTE: due to historical reasons RBFV1BuildModel() accepts points
   //       cast to 3-dimensional space, even if they are really 2-dimensional.
   //       So, for 2D data we have to explicitly convert them to 3D.
      if (s->nx == 2) {
      // Convert data to 3D
         rmatrixsetlengthatleast(&x3, s->n, 3, _state);
         for (i = 0; i < s->n; i++) {
            x3.xyR[i][0] = s->x.xyR[i][0];
            x3.xyR[i][1] = s->x.xyR[i][1];
            x3.xyR[i][2] = 0.0;
         }
         rbfv1buildmodel(&x3, &s->y, s->n, s->aterm, curalgorithmtype, s->nlayers, s->radvalue, s->radzvalue, s->lambdav, s->epsort, s->epserr, s->maxits, &s->model1, &rep1, _state);
      } else {
      // Work with raw data
         rbfv1buildmodel(&s->x, &s->y, s->n, s->aterm, curalgorithmtype, s->nlayers, s->radvalue, s->radzvalue, s->lambdav, s->epsort, s->epserr, s->maxits, &s->model1, &rep1, _state);
      }
      s->modelversion = 1;
   // Convert report fields
      rep->arows = rep1.arows;
      rep->acols = rep1.acols;
      rep->annz = rep1.annz;
      rep->iterationscount = rep1.iterationscount;
      rep->nmv = rep1.nmv;
      rep->terminationtype = rep1.terminationtype;
   // Done
      ae_frame_leave(_state);
      return;
   }
// Algorithms which generate V2 models
   if (curalgorithmtype == 3) {
   // Prepare scale vector - use unit values or user supplied ones
      ae_vector_set_length(&scalevec, s->nx, _state);
      for (i = 0; i < s->nx; i++) {
         if (s->hasscale) {
            scalevec.xR[i] = s->s.xR[i];
         } else {
            scalevec.xR[i] = 1.0;
         }
      }
   // Build model
      rbfv2buildhierarchical(&s->x, &s->y, s->n, &scalevec, s->aterm, s->nlayers, s->radvalue, s->lambdav, &s->model2, &s->progress10000, &s->terminationrequest, &rep2, _state);
      s->modelversion = 2;
   // Convert report fields
      rep->terminationtype = rep2.terminationtype;
      rep->rmserror = rep2.rmserror;
      rep->maxerror = rep2.maxerror;
   // Done
      ae_frame_leave(_state);
      return;
   }
// Critical error
   ae_assert(false, "RBFBuildModel: integrity check failure", _state);
   ae_frame_leave(_state);
}

// This function calculates values of the RBF model in the given point.
//
// IMPORTANT: this function works only with modern  (hierarchical)  RBFs.  It
//            can not be used with legacy (version 1) RBFs because older  RBF
//            code does not support 1-dimensional models.
//
// This function should be used when we have NY=1 (scalar function) and  NX=1
// (1-dimensional space). If you have 3-dimensional space, use rbfcalc3(). If
// you  have  2-dimensional  space,  use  rbfcalc3().  If  you  have  general
// situation (NX-dimensional space, NY-dimensional function)  you  should use
// generic rbfcalc().
//
// If you want to perform parallel model evaluation  from  multiple  threads,
// use rbftscalcbuf() with per-thread buffer object.
//
// This function returns 0.0 when:
// * model is not initialized
// * NX != 1
// * NY != 1
//
// Inputs:
//     S       -   RBF model
//     X0      -   X-coordinate, finite number
//
// Result:
//     value of the model or 0.0 (as defined above)
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: double rbfcalc1(const rbfmodel &s, const double x0, const xparams _xparams = xdefault);
double rbfcalc1(rbfmodel *s, double x0, ae_state *_state) {
   double result;
   ae_assert(ae_isfinite(x0, _state), "RBFCalc1: invalid value for X0 (X0 is Inf)!", _state);
   result = 0.0;
   if (s->ny != 1 || s->nx != 1) {
      return result;
   }
   if (s->modelversion == 1) {
      result = 0.0;
      return result;
   }
   if (s->modelversion == 2) {
      result = rbfv2calc1(&s->model2, x0, _state);
      return result;
   }
   ae_assert(false, "RBFCalc1: integrity check failed", _state);
   return result;
}

// This function calculates values of the RBF model in the given point.
//
// This function should be used when we have NY=1 (scalar function) and  NX=2
// (2-dimensional space). If you have 3-dimensional space, use rbfcalc3(). If
// you have general situation (NX-dimensional space, NY-dimensional function)
// you should use generic rbfcalc().
//
// If  you  want  to  calculate  function  values  many times, consider using
// rbfgridcalc2v(), which is far more efficient than many subsequent calls to
// rbfcalc2().
//
// If you want to perform parallel model evaluation  from  multiple  threads,
// use rbftscalcbuf() with per-thread buffer object.
//
// This function returns 0.0 when:
// * model is not initialized
// * NX != 2
//  *NY != 1
//
// Inputs:
//     S       -   RBF model
//     X0      -   first coordinate, finite number
//     X1      -   second coordinate, finite number
//
// Result:
//     value of the model or 0.0 (as defined above)
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: double rbfcalc2(const rbfmodel &s, const double x0, const double x1, const xparams _xparams = xdefault);
double rbfcalc2(rbfmodel *s, double x0, double x1, ae_state *_state) {
   double result;
   ae_assert(ae_isfinite(x0, _state), "RBFCalc2: invalid value for X0 (X0 is Inf)!", _state);
   ae_assert(ae_isfinite(x1, _state), "RBFCalc2: invalid value for X1 (X1 is Inf)!", _state);
   result = 0.0;
   if (s->ny != 1 || s->nx != 2) {
      return result;
   }
   if (s->modelversion == 1) {
      result = rbfv1calc2(&s->model1, x0, x1, _state);
      return result;
   }
   if (s->modelversion == 2) {
      result = rbfv2calc2(&s->model2, x0, x1, _state);
      return result;
   }
   ae_assert(false, "RBFCalc2: integrity check failed", _state);
   return result;
}

// This function calculates value of the RBF model in the given point.
//
// This function should be used when we have NY=1 (scalar function) and  NX=3
// (3-dimensional space). If you have 2-dimensional space, use rbfcalc2(). If
// you have general situation (NX-dimensional space, NY-dimensional function)
// you should use generic rbfcalc().
//
// If  you  want  to  calculate  function  values  many times, consider using
// rbfgridcalc3v(), which is far more efficient than many subsequent calls to
// rbfcalc3().
//
// If you want to perform parallel model evaluation  from  multiple  threads,
// use rbftscalcbuf() with per-thread buffer object.
//
// This function returns 0.0 when:
// * model is not initialized
// * NX != 3
//  *NY != 1
//
// Inputs:
//     S       -   RBF model
//     X0      -   first coordinate, finite number
//     X1      -   second coordinate, finite number
//     X2      -   third coordinate, finite number
//
// Result:
//     value of the model or 0.0 (as defined above)
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: double rbfcalc3(const rbfmodel &s, const double x0, const double x1, const double x2, const xparams _xparams = xdefault);
double rbfcalc3(rbfmodel *s, double x0, double x1, double x2, ae_state *_state) {
   double result;
   ae_assert(ae_isfinite(x0, _state), "RBFCalc3: invalid value for X0 (X0 is Inf or NaN)!", _state);
   ae_assert(ae_isfinite(x1, _state), "RBFCalc3: invalid value for X1 (X1 is Inf or NaN)!", _state);
   ae_assert(ae_isfinite(x2, _state), "RBFCalc3: invalid value for X2 (X2 is Inf or NaN)!", _state);
   result = 0.0;
   if (s->ny != 1 || s->nx != 3) {
      return result;
   }
   if (s->modelversion == 1) {
      result = rbfv1calc3(&s->model1, x0, x1, x2, _state);
      return result;
   }
   if (s->modelversion == 2) {
      result = rbfv2calc3(&s->model2, x0, x1, x2, _state);
      return result;
   }
   ae_assert(false, "RBFCalc3: integrity check failed", _state);
   return result;
}

// This function calculates values of the RBF model at the given point, using
// external  buffer  object  (internal  temporaries  of  RBF  model  are  not
// modified).
//
// This function allows to use same RBF model object  in  different  threads,
// assuming  that  different   threads  use  different  instances  of  buffer
// structure.
//
// Inputs:
//     S       -   RBF model, may be shared between different threads
//     Buf     -   buffer object created for this particular instance of  RBF
//                 model with rbfcreatecalcbuffer().
//     X       -   coordinates, array[NX].
//                 X may have more than NX elements, in this case only
//                 leading NX will be used.
//     Y       -   possibly preallocated array
//
// Outputs:
//     Y       -   function value, array[NY]. Y is not reallocated when it
//                 is larger than NY.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: void rbftscalcbuf(const rbfmodel &s, const rbfcalcbuffer &buf, const real_1d_array &x, real_1d_array &y, const xparams _xparams = xdefault);
void rbftscalcbuf(rbfmodel *s, rbfcalcbuffer *buf, RVector *x, RVector *y, ae_state *_state) {
   ae_int_t i;
   ae_assert(x->cnt >= s->nx, "RBFCalcBuf: Length(X)<NX", _state);
   ae_assert(isfinitevector(x, s->nx, _state), "RBFCalcBuf: X contains infinite or NaN values", _state);
   ae_assert(s->modelversion == buf->modelversion, "RBFCalcBuf: buffer object is not compatible with RBF model", _state);
   if (y->cnt < s->ny) {
      ae_vector_set_length(y, s->ny, _state);
   }
   for (i = 0; i < s->ny; i++) {
      y->xR[i] = 0.0;
   }
   if (s->modelversion == 1) {
      rbfv1tscalcbuf(&s->model1, &buf->bufv1, x, y, _state);
      return;
   }
   if (s->modelversion == 2) {
      rbfv2tscalcbuf(&s->model2, &buf->bufv2, x, y, _state);
      return;
   }
   ae_assert(false, "RBFTsCalcBuf: integrity check failed", _state);
}

// This function calculates values of the RBF model at the given point.
//
// Same as rbfcalc(), but does not reallocate Y when in is large enough to
// store function values.
//
// If you want to perform parallel model evaluation  from  multiple  threads,
// use rbftscalcbuf() with per-thread buffer object.
//
// Inputs:
//     S       -   RBF model
//     X       -   coordinates, array[NX].
//                 X may have more than NX elements, in this case only
//                 leading NX will be used.
//     Y       -   possibly preallocated array
//
// Outputs:
//     Y       -   function value, array[NY]. Y is not reallocated when it
//                 is larger than NY.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: void rbfcalcbuf(const rbfmodel &s, const real_1d_array &x, real_1d_array &y, const xparams _xparams = xdefault);
void rbfcalcbuf(rbfmodel *s, RVector *x, RVector *y, ae_state *_state) {
   ae_int_t i;
   ae_assert(x->cnt >= s->nx, "RBFCalcBuf: Length(X)<NX", _state);
   ae_assert(isfinitevector(x, s->nx, _state), "RBFCalcBuf: X contains infinite or NaN values", _state);
   if (y->cnt < s->ny) {
      ae_vector_set_length(y, s->ny, _state);
   }
   for (i = 0; i < s->ny; i++) {
      y->xR[i] = 0.0;
   }
   if (s->modelversion == 1) {
      rbfv1calcbuf(&s->model1, x, y, _state);
      return;
   }
   if (s->modelversion == 2) {
      rbfv2calcbuf(&s->model2, x, y, _state);
      return;
   }
   ae_assert(false, "RBFCalcBuf: integrity check failed", _state);
}

// This function calculates values of the RBF model at the given point.
//
// This is general function which can be used for arbitrary NX (dimension  of
// the space of arguments) and NY (dimension of the function itself). However
// when  you  have  NY=1  you  may  find more convenient to use rbfcalc2() or
// rbfcalc3().
//
// If you want to perform parallel model evaluation  from  multiple  threads,
// use rbftscalcbuf() with per-thread buffer object.
//
// This function returns 0.0 when model is not initialized.
//
// Inputs:
//     S       -   RBF model
//     X       -   coordinates, array[NX].
//                 X may have more than NX elements, in this case only
//                 leading NX will be used.
//
// Outputs:
//     Y       -   function value, array[NY]. Y is out-parameter and
//                 reallocated after call to this function. In case you  want
//                 to reuse previously allocated Y, you may use RBFCalcBuf(),
//                 which reallocates Y only when it is too small.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: void rbfcalc(const rbfmodel &s, const real_1d_array &x, real_1d_array &y, const xparams _xparams = xdefault);
void rbfcalc(rbfmodel *s, RVector *x, RVector *y, ae_state *_state) {
   SetVector(y);
   ae_assert(x->cnt >= s->nx, "RBFCalc: Length(X)<NX", _state);
   ae_assert(isfinitevector(x, s->nx, _state), "RBFCalc: X contains infinite or NaN values", _state);
   rbfcalcbuf(s, x, y, _state);
}

// This is legacy function for gridded calculation of RBF model.
//
// It is superseded by rbfgridcalc2v() and  rbfgridcalc2vsubset()  functions.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: void rbfgridcalc2(const rbfmodel &s, const real_1d_array &x0, const ae_int_t n0, const real_1d_array &x1, const ae_int_t n1, real_2d_array &y, const xparams _xparams = xdefault);
void rbfgridcalc2(rbfmodel *s, RVector *x0, ae_int_t n0, RVector *x1, ae_int_t n1, RMatrix *y, ae_state *_state) {
   ae_frame _frame_block;
   ae_frame_make(_state, &_frame_block);
   SetMatrix(y);
   NewVector(cpx0, 0, DT_REAL, _state);
   NewVector(cpx1, 0, DT_REAL, _state);
   NewVector(p01, 0, DT_INT, _state);
   NewVector(p11, 0, DT_INT, _state);
   NewVector(p2, 0, DT_INT, _state);
   ae_assert(n0 > 0, "RBFGridCalc2: invalid value for N0 (N0 <= 0)!", _state);
   ae_assert(n1 > 0, "RBFGridCalc2: invalid value for N1 (N1 <= 0)!", _state);
   ae_assert(x0->cnt >= n0, "RBFGridCalc2: Length(X0)<N0", _state);
   ae_assert(x1->cnt >= n1, "RBFGridCalc2: Length(X1)<N1", _state);
   ae_assert(isfinitevector(x0, n0, _state), "RBFGridCalc2: X0 contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(x1, n1, _state), "RBFGridCalc2: X1 contains infinite or NaN values!", _state);
   if (s->modelversion == 1) {
      rbfv1gridcalc2(&s->model1, x0, n0, x1, n1, y, _state);
      ae_frame_leave(_state);
      return;
   }
   if (s->modelversion == 2) {
      rbfv2gridcalc2(&s->model2, x0, n0, x1, n1, y, _state);
      ae_frame_leave(_state);
      return;
   }
   ae_assert(false, "RBFGridCalc2: integrity check failed", _state);
   ae_frame_leave(_state);
}

// This function, depending on SparseY, acts as RBFGridCalc2V (SparseY=False)
// or RBFGridCalc2VSubset (SparseY=True) function.  See  comments  for  these
// functions for more information
// ALGLIB: Copyright 04.03.2016 by Sergey Bochkanov
void rbfgridcalc2vx(rbfmodel *s, RVector *x0, ae_int_t n0, RVector *x1, ae_int_t n1, BVector *flagy, bool sparsey, RVector *y, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t ylen;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   ae_int_t dstoffs;
   ae_frame_make(_state, &_frame_block);
   NewObj(hqrndstate, rs, _state);
   NewVector(dummyx2, 0, DT_REAL, _state);
   NewVector(dummyx3, 0, DT_REAL, _state);
   NewVector(tx, 0, DT_REAL, _state);
   NewVector(ty, 0, DT_REAL, _state);
   NewObj(rbfcalcbuffer, calcbuf, _state);
   ae_assert(n0 > 0, "RBFGridCalc2VX: invalid value for N0 (N0 <= 0)!", _state);
   ae_assert(n1 > 0, "RBFGridCalc2VX: invalid value for N1 (N1 <= 0)!", _state);
   ae_assert(x0->cnt >= n0, "RBFGridCalc2VX: Length(X0)<N0", _state);
   ae_assert(x1->cnt >= n1, "RBFGridCalc2VX: Length(X1)<N1", _state);
   ae_assert(isfinitevector(x0, n0, _state), "RBFGridCalc2VX: X0 contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(x1, n1, _state), "RBFGridCalc2VX: X1 contains infinite or NaN values!", _state);
   for (i = 0; i < n0 - 1; i++) {
      ae_assert(x0->xR[i] <= x0->xR[i + 1], "RBFGridCalc2VX: X0 is not ordered by ascending", _state);
   }
   for (i = 0; i < n1 - 1; i++) {
      ae_assert(x1->xR[i] <= x1->xR[i + 1], "RBFGridCalc2VX: X1 is not ordered by ascending", _state);
   }
// Prepare local variables
   nx = s->nx;
   ny = s->ny;
   hqrndseed(325, 46345, &rs, _state);
// Prepare output array
   ylen = ny * n0 * n1;
   ae_vector_set_length(y, ylen, _state);
   for (i = 0; i < ylen; i++) {
      y->xR[i] = 0.0;
   }
   if (s->nx != 2) {
      ae_frame_leave(_state);
      return;
   }
// Process V2 model
   if (s->modelversion == 2) {
      ae_vector_set_length(&dummyx2, 1, _state);
      dummyx2.xR[0] = 0.0;
      ae_vector_set_length(&dummyx3, 1, _state);
      dummyx3.xR[0] = 0.0;
      rbfv2gridcalcvx(&s->model2, x0, n0, x1, n1, &dummyx2, 1, &dummyx3, 1, flagy, sparsey, y, _state);
      ae_frame_leave(_state);
      return;
   }
// Reference code for V1 models
   if (s->modelversion == 1) {
      ae_vector_set_length(&tx, nx, _state);
      rbfcreatecalcbuffer(s, &calcbuf, _state);
      for (i = 0; i < n0; i++) {
         for (j = 0; j < n1; j++) {
            k = i + j * n0;
            dstoffs = ny * k;
            if (sparsey && !flagy->xB[k]) {
               for (l = 0; l < ny; l++) {
                  y->xR[l + dstoffs] = 0.0;
               }
               continue;
            }
            tx.xR[0] = x0->xR[i];
            tx.xR[1] = x1->xR[j];
            rbftscalcbuf(s, &calcbuf, &tx, &ty, _state);
            for (l = 0; l < ny; l++) {
               y->xR[l + dstoffs] = ty.xR[l];
            }
         }
      }
      ae_frame_leave(_state);
      return;
   }
// Unknown model
   ae_assert(false, "RBFGradCalc3VX: integrity check failed", _state);
   ae_frame_leave(_state);
}

// This function calculates values of the RBF  model  at  the  regular  grid,
// which  has  N0*N1 points, with Point[I,J] = (X0[I], X1[J]).  Vector-valued
// RBF models are supported.
//
// This function returns 0.0 when:
// * model is not initialized
// * NX != 2
//
// NOTE: Parallel  processing  is  implemented only for modern (hierarchical)
//       RBFs. Legacy version 1 RBFs (created  by  QNN  or  RBF-ML) are still
//       processed serially.
//
// Inputs:
//     S       -   RBF model, used in read-only mode, can be  shared  between
//                 multiple   invocations  of  this  function  from  multiple
//                 threads.
//
//     X0      -   array of grid nodes, first coordinates, array[N0].
//                 Must be ordered by ascending. Exception is generated
//                 if the array is not correctly ordered.
//     N0      -   grid size (number of nodes) in the first dimension
//
//     X1      -   array of grid nodes, second coordinates, array[N1]
//                 Must be ordered by ascending. Exception is generated
//                 if the array is not correctly ordered.
//     N1      -   grid size (number of nodes) in the second dimension
//
// Outputs:
//     Y       -   function values, array[NY*N0*N1], where NY is a  number of
//                 "output" vector values (this  function   supports  vector-
//                 valued RBF models). Y is out-variable and  is  reallocated
//                 by this function.
//                 Y[K+NY*(I0+I1*N0)]=F_k(X0[I0],X1[I1]), for:
//                 *  K=0...NY-1
//                 * I0=0...N0-1
//                 * I1=0...N1-1
//
// NOTE: this function supports weakly ordered grid nodes, i.e. you may  have
//       X[i]=X[i+1] for some i. It does  not  provide  you  any  performance
//       benefits  due  to   duplication  of  points,  just  convenience  and
//       flexibility.
//
// NOTE: this  function  is  re-entrant,  i.e.  you  may  use  same  rbfmodel
//       structure in multiple threads calling  this function  for  different
//       grids.
//
// NOTE: if you need function values on some subset  of  regular  grid, which
//       may be described as "several compact and  dense  islands",  you  may
//       use rbfgridcalc2vsubset().
// ALGLIB: Copyright 27.01.2017 by Sergey Bochkanov
// API: void rbfgridcalc2v(const rbfmodel &s, const real_1d_array &x0, const ae_int_t n0, const real_1d_array &x1, const ae_int_t n1, real_1d_array &y, const xparams _xparams = xdefault);
void rbfgridcalc2v(rbfmodel *s, RVector *x0, ae_int_t n0, RVector *x1, ae_int_t n1, RVector *y, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   SetVector(y);
   NewVector(dummy, 0, DT_BOOL, _state);
   ae_assert(n0 > 0, "RBFGridCalc2V: invalid value for N0 (N0 <= 0)!", _state);
   ae_assert(n1 > 0, "RBFGridCalc2V: invalid value for N1 (N1 <= 0)!", _state);
   ae_assert(x0->cnt >= n0, "RBFGridCalc2V: Length(X0)<N0", _state);
   ae_assert(x1->cnt >= n1, "RBFGridCalc2V: Length(X1)<N1", _state);
   ae_assert(isfinitevector(x0, n0, _state), "RBFGridCalc2V: X0 contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(x1, n1, _state), "RBFGridCalc2V: X1 contains infinite or NaN values!", _state);
   for (i = 0; i < n0 - 1; i++) {
      ae_assert(x0->xR[i] <= x0->xR[i + 1], "RBFGridCalc2V: X0 is not ordered by ascending", _state);
   }
   for (i = 0; i < n1 - 1; i++) {
      ae_assert(x1->xR[i] <= x1->xR[i + 1], "RBFGridCalc2V: X1 is not ordered by ascending", _state);
   }
   rbfgridcalc2vx(s, x0, n0, x1, n1, &dummy, false, y, _state);
   ae_frame_leave(_state);
}

// This function calculates values of the RBF model at some subset of regular
// grid:
// * grid has N0*N1 points, with Point[I,J] = (X0[I], X1[J])
// * only values at some subset of this grid are required
// Vector-valued RBF models are supported.
//
// This function returns 0.0 when:
// * model is not initialized
// * NX != 2
//
// NOTE: Parallel  processing  is  implemented only for modern (hierarchical)
//       RBFs. Legacy version 1 RBFs (created  by  QNN  or  RBF-ML) are still
//       processed serially.
//
// Inputs:
//     S       -   RBF model, used in read-only mode, can be  shared  between
//                 multiple   invocations  of  this  function  from  multiple
//                 threads.
//
//     X0      -   array of grid nodes, first coordinates, array[N0].
//                 Must be ordered by ascending. Exception is generated
//                 if the array is not correctly ordered.
//     N0      -   grid size (number of nodes) in the first dimension
//
//     X1      -   array of grid nodes, second coordinates, array[N1]
//                 Must be ordered by ascending. Exception is generated
//                 if the array is not correctly ordered.
//     N1      -   grid size (number of nodes) in the second dimension
//
//     FlagY   -   array[N0*N1]:
//                 * Y[I0+I1*N0] corresponds to node (X0[I0],X1[I1])
//                 * it is a "bitmap" array which contains  False  for  nodes
//                   which are NOT calculated, and True for nodes  which  are
//                   required.
//
// Outputs:
//     Y       -   function values, array[NY*N0*N1*N2], where NY is a  number
//                 of "output" vector values (this function  supports vector-
//                 valued RBF models):
//                 * Y[K+NY*(I0+I1*N0)]=F_k(X0[I0],X1[I1]),
//                   for K=0...NY-1, I0=0...N0-1, I1=0...N1-1.
//                 * elements of Y[] which correspond  to  FlagY[]=True   are
//                   loaded by model values (which may be  exactly  zero  for
//                   some nodes).
//                 * elements of Y[] which correspond to FlagY[]=False MAY be
//                   initialized by zeros OR may be calculated. This function
//                   processes  grid  as  a  hierarchy  of  nested blocks and
//                   micro-rows. If just one element of micro-row is required,
//                   entire micro-row (up to 8 nodes in the current  version,
//                   but no promises) is calculated.
//
// NOTE: this function supports weakly ordered grid nodes, i.e. you may  have
//       X[i]=X[i+1] for some i. It does  not  provide  you  any  performance
//       benefits  due  to   duplication  of  points,  just  convenience  and
//       flexibility.
//
// NOTE: this  function  is  re-entrant,  i.e.  you  may  use  same  rbfmodel
//       structure in multiple threads calling  this function  for  different
//       grids.
// ALGLIB: Copyright 04.03.2016 by Sergey Bochkanov
// API: void rbfgridcalc2vsubset(const rbfmodel &s, const real_1d_array &x0, const ae_int_t n0, const real_1d_array &x1, const ae_int_t n1, const boolean_1d_array &flagy, real_1d_array &y, const xparams _xparams = xdefault);
void rbfgridcalc2vsubset(rbfmodel *s, RVector *x0, ae_int_t n0, RVector *x1, ae_int_t n1, BVector *flagy, RVector *y, ae_state *_state) {
   ae_int_t i;
   SetVector(y);
   ae_assert(n0 > 0, "RBFGridCalc2VSubset: invalid value for N0 (N0 <= 0)!", _state);
   ae_assert(n1 > 0, "RBFGridCalc2VSubset: invalid value for N1 (N1 <= 0)!", _state);
   ae_assert(x0->cnt >= n0, "RBFGridCalc2VSubset: Length(X0)<N0", _state);
   ae_assert(x1->cnt >= n1, "RBFGridCalc2VSubset: Length(X1)<N1", _state);
   ae_assert(flagy->cnt >= n0 * n1, "RBFGridCalc2VSubset: Length(FlagY)<N0*N1*N2", _state);
   ae_assert(isfinitevector(x0, n0, _state), "RBFGridCalc2VSubset: X0 contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(x1, n1, _state), "RBFGridCalc2VSubset: X1 contains infinite or NaN values!", _state);
   for (i = 0; i < n0 - 1; i++) {
      ae_assert(x0->xR[i] <= x0->xR[i + 1], "RBFGridCalc2VSubset: X0 is not ordered by ascending", _state);
   }
   for (i = 0; i < n1 - 1; i++) {
      ae_assert(x1->xR[i] <= x1->xR[i + 1], "RBFGridCalc2VSubset: X1 is not ordered by ascending", _state);
   }
   rbfgridcalc2vx(s, x0, n0, x1, n1, flagy, true, y, _state);
}

// This function, depending on SparseY, acts as RBFGridCalc3V (SparseY=False)
// or RBFGridCalc3VSubset (SparseY=True) function.  See  comments  for  these
// functions for more information
// ALGLIB: Copyright 04.03.2016 by Sergey Bochkanov
void rbfgridcalc3vx(rbfmodel *s, RVector *x0, ae_int_t n0, RVector *x1, ae_int_t n1, RVector *x2, ae_int_t n2, BVector *flagy, bool sparsey, RVector *y, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t ylen;
   ae_int_t nx;
   ae_int_t ny;
   double rmax;
   ae_int_t blockscnt0;
   ae_int_t blockscnt1;
   ae_int_t blockscnt2;
   double blockwidth;
   double searchradius;
   double avgfuncpernode;
   ae_int_t ntrials;
   ae_int_t maxblocksize;
   ae_frame_make(_state, &_frame_block);
   NewVector(blocks0, 0, DT_INT, _state);
   NewVector(blocks1, 0, DT_INT, _state);
   NewVector(blocks2, 0, DT_INT, _state);
   NewObj(gridcalc3v1buf, bufseedv1, _state);
   NewObj(ae_shared_pool, bufpool, _state);
   NewObj(hqrndstate, rs, _state);
   NewVector(dummyx3, 0, DT_REAL, _state);
   ae_assert(n0 > 0, "RBFGridCalc3V: invalid value for N0 (N0 <= 0)!", _state);
   ae_assert(n1 > 0, "RBFGridCalc3V: invalid value for N1 (N1 <= 0)!", _state);
   ae_assert(n2 > 0, "RBFGridCalc3V: invalid value for N2 (N2 <= 0)!", _state);
   ae_assert(x0->cnt >= n0, "RBFGridCalc3V: Length(X0)<N0", _state);
   ae_assert(x1->cnt >= n1, "RBFGridCalc3V: Length(X1)<N1", _state);
   ae_assert(x2->cnt >= n2, "RBFGridCalc3V: Length(X2)<N2", _state);
   ae_assert(isfinitevector(x0, n0, _state), "RBFGridCalc3V: X0 contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(x1, n1, _state), "RBFGridCalc3V: X1 contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(x2, n2, _state), "RBFGridCalc3V: X2 contains infinite or NaN values!", _state);
   for (i = 0; i < n0 - 1; i++) {
      ae_assert(x0->xR[i] <= x0->xR[i + 1], "RBFGridCalc3V: X0 is not ordered by ascending", _state);
   }
   for (i = 0; i < n1 - 1; i++) {
      ae_assert(x1->xR[i] <= x1->xR[i + 1], "RBFGridCalc3V: X1 is not ordered by ascending", _state);
   }
   for (i = 0; i < n2 - 1; i++) {
      ae_assert(x2->xR[i] <= x2->xR[i + 1], "RBFGridCalc3V: X2 is not ordered by ascending", _state);
   }
// Prepare local variables
   nx = s->nx;
   ny = s->ny;
   hqrndseed(325, 46345, &rs, _state);
// Prepare output array
   ylen = ny * n0 * n1 * n2;
   ae_vector_set_length(y, ylen, _state);
   for (i = 0; i < ylen; i++) {
      y->xR[i] = 0.0;
   }
   if (s->nx != 3) {
      ae_frame_leave(_state);
      return;
   }
// Process V1 model
   if (s->modelversion == 1) {
   // Fast exit for models without centers
      if (s->model1.nc == 0) {
         ae_frame_leave(_state);
         return;
      }
   // Prepare seed, create shared pool of temporary buffers
      ae_vector_set_length(&bufseedv1.cx, nx, _state);
      ae_vector_set_length(&bufseedv1.tx, nx, _state);
      ae_vector_set_length(&bufseedv1.ty, ny, _state);
      ae_vector_set_length(&bufseedv1.expbuf0, n0, _state);
      ae_vector_set_length(&bufseedv1.expbuf1, n1, _state);
      ae_vector_set_length(&bufseedv1.expbuf2, n2, _state);
      kdtreecreaterequestbuffer(&s->model1.tree, &bufseedv1.requestbuf, _state);
      ae_shared_pool_set_seed(&bufpool, &bufseedv1, sizeof(bufseedv1), gridcalc3v1buf_init, gridcalc3v1buf_copy, gridcalc3v1buf_free, _state);
   // Analyze input grid:
   // * analyze average number of basis functions per grid node
   // * partition grid in into blocks
      rmax = s->model1.rmax;
      blockwidth = 2 * rmax;
      maxblocksize = 8;
      searchradius = rmax * rbf_rbffarradius + 0.5 * ae_sqrt((double)s->nx, _state) * blockwidth;
      ntrials = 100;
      avgfuncpernode = 0.0;
      for (i = 0; i < ntrials; i++) {
         bufseedv1.tx.xR[0] = x0->xR[hqrnduniformi(&rs, n0, _state)];
         bufseedv1.tx.xR[1] = x1->xR[hqrnduniformi(&rs, n1, _state)];
         bufseedv1.tx.xR[2] = x2->xR[hqrnduniformi(&rs, n2, _state)];
         avgfuncpernode += (double)kdtreetsqueryrnn(&s->model1.tree, &bufseedv1.requestbuf, &bufseedv1.tx, searchradius, true, _state) / ntrials;
      }
      ae_vector_set_length(&blocks0, n0 + 1, _state);
      blockscnt0 = 0;
      blocks0.xZ[0] = 0;
      for (i = 1; i < n0; i++) {
         if (x0->xR[i] - x0->xR[blocks0.xZ[blockscnt0]] > blockwidth || i - blocks0.xZ[blockscnt0] >= maxblocksize) {
            inc(&blockscnt0, _state);
            blocks0.xZ[blockscnt0] = i;
         }
      }
      inc(&blockscnt0, _state);
      blocks0.xZ[blockscnt0] = n0;
      ae_vector_set_length(&blocks1, n1 + 1, _state);
      blockscnt1 = 0;
      blocks1.xZ[0] = 0;
      for (i = 1; i < n1; i++) {
         if (x1->xR[i] - x1->xR[blocks1.xZ[blockscnt1]] > blockwidth || i - blocks1.xZ[blockscnt1] >= maxblocksize) {
            inc(&blockscnt1, _state);
            blocks1.xZ[blockscnt1] = i;
         }
      }
      inc(&blockscnt1, _state);
      blocks1.xZ[blockscnt1] = n1;
      ae_vector_set_length(&blocks2, n2 + 1, _state);
      blockscnt2 = 0;
      blocks2.xZ[0] = 0;
      for (i = 1; i < n2; i++) {
         if (x2->xR[i] - x2->xR[blocks2.xZ[blockscnt2]] > blockwidth || i - blocks2.xZ[blockscnt2] >= maxblocksize) {
            inc(&blockscnt2, _state);
            blocks2.xZ[blockscnt2] = i;
         }
      }
      inc(&blockscnt2, _state);
      blocks2.xZ[blockscnt2] = n2;
   // Perform calculation in multithreaded mode
      rbfv1gridcalc3vrec(&s->model1, x0, n0, x1, n1, x2, n2, &blocks0, 0, blockscnt0, &blocks1, 0, blockscnt1, &blocks2, 0, blockscnt2, flagy, sparsey, searchradius, avgfuncpernode, &bufpool, y, _state);
   // Done
      ae_frame_leave(_state);
      return;
   }
// Process V2 model
   if (s->modelversion == 2) {
      ae_vector_set_length(&dummyx3, 1, _state);
      dummyx3.xR[0] = 0.0;
      rbfv2gridcalcvx(&s->model2, x0, n0, x1, n1, x2, n2, &dummyx3, 1, flagy, sparsey, y, _state);
      ae_frame_leave(_state);
      return;
   }
// Unknown model
   ae_assert(false, "RBFGradCalc3VX: integrity check failed", _state);
   ae_frame_leave(_state);
}

// This function calculates values of the RBF  model  at  the  regular  grid,
// which  has  N0*N1*N2  points,  with  Point[I,J,K] = (X0[I], X1[J], X2[K]).
// Vector-valued RBF models are supported.
//
// This function returns 0.0 when:
// * model is not initialized
// * NX != 3
//
// NOTE: Parallel  processing  is  implemented only for modern (hierarchical)
//       RBFs. Legacy version 1 RBFs (created  by  QNN  or  RBF-ML) are still
//       processed serially.
//
// Inputs:
//     S       -   RBF model, used in read-only mode, can be  shared  between
//                 multiple   invocations  of  this  function  from  multiple
//                 threads.
//
//     X0      -   array of grid nodes, first coordinates, array[N0].
//                 Must be ordered by ascending. Exception is generated
//                 if the array is not correctly ordered.
//     N0      -   grid size (number of nodes) in the first dimension
//
//     X1      -   array of grid nodes, second coordinates, array[N1]
//                 Must be ordered by ascending. Exception is generated
//                 if the array is not correctly ordered.
//     N1      -   grid size (number of nodes) in the second dimension
//
//     X2      -   array of grid nodes, third coordinates, array[N2]
//                 Must be ordered by ascending. Exception is generated
//                 if the array is not correctly ordered.
//     N2      -   grid size (number of nodes) in the third dimension
//
// Outputs:
//     Y       -   function values, array[NY*N0*N1*N2], where NY is a  number
//                 of "output" vector values (this function  supports vector-
//                 valued RBF models). Y is out-variable and  is  reallocated
//                 by this function.
//                 Y[K+NY*(I0+I1*N0+I2*N0*N1)]=F_k(X0[I0],X1[I1],X2[I2]), for:
//                 *  K=0...NY-1
//                 * I0=0...N0-1
//                 * I1=0...N1-1
//                 * I2=0...N2-1
//
// NOTE: this function supports weakly ordered grid nodes, i.e. you may  have
//       X[i]=X[i+1] for some i. It does  not  provide  you  any  performance
//       benefits  due  to   duplication  of  points,  just  convenience  and
//       flexibility.
//
// NOTE: this  function  is  re-entrant,  i.e.  you  may  use  same  rbfmodel
//       structure in multiple threads calling  this function  for  different
//       grids.
//
// NOTE: if you need function values on some subset  of  regular  grid, which
//       may be described as "several compact and  dense  islands",  you  may
//       use rbfgridcalc3vsubset().
// ALGLIB: Copyright 04.03.2016 by Sergey Bochkanov
// API: void rbfgridcalc3v(const rbfmodel &s, const real_1d_array &x0, const ae_int_t n0, const real_1d_array &x1, const ae_int_t n1, const real_1d_array &x2, const ae_int_t n2, real_1d_array &y, const xparams _xparams = xdefault);
void rbfgridcalc3v(rbfmodel *s, RVector *x0, ae_int_t n0, RVector *x1, ae_int_t n1, RVector *x2, ae_int_t n2, RVector *y, ae_state *_state) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(_state, &_frame_block);
   SetVector(y);
   NewVector(dummy, 0, DT_BOOL, _state);
   ae_assert(n0 > 0, "RBFGridCalc3V: invalid value for N0 (N0 <= 0)!", _state);
   ae_assert(n1 > 0, "RBFGridCalc3V: invalid value for N1 (N1 <= 0)!", _state);
   ae_assert(n2 > 0, "RBFGridCalc3V: invalid value for N2 (N2 <= 0)!", _state);
   ae_assert(x0->cnt >= n0, "RBFGridCalc3V: Length(X0)<N0", _state);
   ae_assert(x1->cnt >= n1, "RBFGridCalc3V: Length(X1)<N1", _state);
   ae_assert(x2->cnt >= n2, "RBFGridCalc3V: Length(X2)<N2", _state);
   ae_assert(isfinitevector(x0, n0, _state), "RBFGridCalc3V: X0 contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(x1, n1, _state), "RBFGridCalc3V: X1 contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(x2, n2, _state), "RBFGridCalc3V: X2 contains infinite or NaN values!", _state);
   for (i = 0; i < n0 - 1; i++) {
      ae_assert(x0->xR[i] <= x0->xR[i + 1], "RBFGridCalc3V: X0 is not ordered by ascending", _state);
   }
   for (i = 0; i < n1 - 1; i++) {
      ae_assert(x1->xR[i] <= x1->xR[i + 1], "RBFGridCalc3V: X1 is not ordered by ascending", _state);
   }
   for (i = 0; i < n2 - 1; i++) {
      ae_assert(x2->xR[i] <= x2->xR[i + 1], "RBFGridCalc3V: X2 is not ordered by ascending", _state);
   }
   rbfgridcalc3vx(s, x0, n0, x1, n1, x2, n2, &dummy, false, y, _state);
   ae_frame_leave(_state);
}

// This function calculates values of the RBF model at some subset of regular
// grid:
// * grid has N0*N1*N2 points, with Point[I,J,K] = (X0[I], X1[J], X2[K])
// * only values at some subset of this grid are required
// Vector-valued RBF models are supported.
//
// This function returns 0.0 when:
// * model is not initialized
// * NX != 3
//
// NOTE: Parallel  processing  is  implemented only for modern (hierarchical)
//       RBFs. Legacy version 1 RBFs (created  by  QNN  or  RBF-ML) are still
//       processed serially.
//
// Inputs:
//     S       -   RBF model, used in read-only mode, can be  shared  between
//                 multiple   invocations  of  this  function  from  multiple
//                 threads.
//
//     X0      -   array of grid nodes, first coordinates, array[N0].
//                 Must be ordered by ascending. Exception is generated
//                 if the array is not correctly ordered.
//     N0      -   grid size (number of nodes) in the first dimension
//
//     X1      -   array of grid nodes, second coordinates, array[N1]
//                 Must be ordered by ascending. Exception is generated
//                 if the array is not correctly ordered.
//     N1      -   grid size (number of nodes) in the second dimension
//
//     X2      -   array of grid nodes, third coordinates, array[N2]
//                 Must be ordered by ascending. Exception is generated
//                 if the array is not correctly ordered.
//     N2      -   grid size (number of nodes) in the third dimension
//
//     FlagY   -   array[N0*N1*N2]:
//                 * Y[I0+I1*N0+I2*N0*N1] corresponds to node (X0[I0],X1[I1],X2[I2])
//                 * it is a "bitmap" array which contains  False  for  nodes
//                   which are NOT calculated, and True for nodes  which  are
//                   required.
//
// Outputs:
//     Y       -   function values, array[NY*N0*N1*N2], where NY is a  number
//                 of "output" vector values (this function  supports vector-
//                 valued RBF models):
//                 * Y[K+NY*(I0+I1*N0+I2*N0*N1)]=F_k(X0[I0],X1[I1],X2[I2]),
//                   for K=0...NY-1, I0=0...N0-1, I1=0...N1-1, I2=0...N2-1.
//                 * elements of Y[] which correspond  to  FlagY[]=True   are
//                   loaded by model values (which may be  exactly  zero  for
//                   some nodes).
//                 * elements of Y[] which correspond to FlagY[]=False MAY be
//                   initialized by zeros OR may be calculated. This function
//                   processes  grid  as  a  hierarchy  of  nested blocks and
//                   micro-rows. If just one element of micro-row is required,
//                   entire micro-row (up to 8 nodes in the current  version,
//                   but no promises) is calculated.
//
// NOTE: this function supports weakly ordered grid nodes, i.e. you may  have
//       X[i]=X[i+1] for some i. It does  not  provide  you  any  performance
//       benefits  due  to   duplication  of  points,  just  convenience  and
//       flexibility.
//
// NOTE: this  function  is  re-entrant,  i.e.  you  may  use  same  rbfmodel
//       structure in multiple threads calling  this function  for  different
//       grids.
// ALGLIB: Copyright 04.03.2016 by Sergey Bochkanov
// API: void rbfgridcalc3vsubset(const rbfmodel &s, const real_1d_array &x0, const ae_int_t n0, const real_1d_array &x1, const ae_int_t n1, const real_1d_array &x2, const ae_int_t n2, const boolean_1d_array &flagy, real_1d_array &y, const xparams _xparams = xdefault);
void rbfgridcalc3vsubset(rbfmodel *s, RVector *x0, ae_int_t n0, RVector *x1, ae_int_t n1, RVector *x2, ae_int_t n2, BVector *flagy, RVector *y, ae_state *_state) {
   ae_int_t i;
   SetVector(y);
   ae_assert(n0 > 0, "RBFGridCalc3VSubset: invalid value for N0 (N0 <= 0)!", _state);
   ae_assert(n1 > 0, "RBFGridCalc3VSubset: invalid value for N1 (N1 <= 0)!", _state);
   ae_assert(n2 > 0, "RBFGridCalc3VSubset: invalid value for N2 (N2 <= 0)!", _state);
   ae_assert(x0->cnt >= n0, "RBFGridCalc3VSubset: Length(X0)<N0", _state);
   ae_assert(x1->cnt >= n1, "RBFGridCalc3VSubset: Length(X1)<N1", _state);
   ae_assert(x2->cnt >= n2, "RBFGridCalc3VSubset: Length(X2)<N2", _state);
   ae_assert(flagy->cnt >= n0 * n1 * n2, "RBFGridCalc3VSubset: Length(FlagY)<N0*N1*N2", _state);
   ae_assert(isfinitevector(x0, n0, _state), "RBFGridCalc3VSubset: X0 contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(x1, n1, _state), "RBFGridCalc3VSubset: X1 contains infinite or NaN values!", _state);
   ae_assert(isfinitevector(x2, n2, _state), "RBFGridCalc3VSubset: X2 contains infinite or NaN values!", _state);
   for (i = 0; i < n0 - 1; i++) {
      ae_assert(x0->xR[i] <= x0->xR[i + 1], "RBFGridCalc3VSubset: X0 is not ordered by ascending", _state);
   }
   for (i = 0; i < n1 - 1; i++) {
      ae_assert(x1->xR[i] <= x1->xR[i + 1], "RBFGridCalc3VSubset: X1 is not ordered by ascending", _state);
   }
   for (i = 0; i < n2 - 1; i++) {
      ae_assert(x2->xR[i] <= x2->xR[i + 1], "RBFGridCalc3VSubset: X2 is not ordered by ascending", _state);
   }
   rbfgridcalc3vx(s, x0, n0, x1, n1, x2, n2, flagy, true, y, _state);
}

// This function "unpacks" RBF model by extracting its coefficients.
//
// Inputs:
//     S       -   RBF model
//
// Outputs:
//     NX      -   dimensionality of argument
//     NY      -   dimensionality of the target function
//     XWR     -   model information, array[NC,NX+NY+1].
//                 One row of the array corresponds to one basis function:
//                 * first NX columns  - coordinates of the center
//                 * next NY columns   - weights, one per dimension of the
//                                       function being modelled
//                 For ModelVersion=1:
//                 * last column       - radius, same for all dimensions of
//                                       the function being modelled
//                 For ModelVersion=2:
//                 * last NX columns   - radii, one per dimension
//     NC      -   number of the centers
//     V       -   polynomial  term , array[NY,NX+1]. One row per one
//                 dimension of the function being modelled. First NX
//                 elements are linear coefficients, V[NX] is equal to the
//                 constant part.
//     ModelVersion-version of the RBF model:
//                 * 1 - for models created by QNN and RBF-ML algorithms,
//                   compatible with ALGLIB 3.10 or earlier.
//                 * 2 - for models created by HierarchicalRBF, requires
//                   ALGLIB 3.11 or later
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
// API: void rbfunpack(const rbfmodel &s, ae_int_t &nx, ae_int_t &ny, real_2d_array &xwr, ae_int_t &nc, real_2d_array &v, ae_int_t &modelversion, const xparams _xparams = xdefault);
void rbfunpack(rbfmodel *s, ae_int_t *nx, ae_int_t *ny, RMatrix *xwr, ae_int_t *nc, RMatrix *v, ae_int_t *modelversion, ae_state *_state) {
   *nx = 0;
   *ny = 0;
   SetMatrix(xwr);
   *nc = 0;
   SetMatrix(v);
   *modelversion = 0;
   if (s->modelversion == 1) {
      *modelversion = 1;
      rbfv1unpack(&s->model1, nx, ny, xwr, nc, v, _state);
      return;
   }
   if (s->modelversion == 2) {
      *modelversion = 2;
      rbfv2unpack(&s->model2, nx, ny, xwr, nc, v, _state);
      return;
   }
   ae_assert(false, "RBFUnpack: integrity check failure", _state);
}

// This function returns model version.
//
// Inputs:
//     S       -   RBF model
//
// Result:
//     * 1 - for models created by QNN and RBF-ML algorithms,
//       compatible with ALGLIB 3.10 or earlier.
//     * 2 - for models created by HierarchicalRBF, requires
//       ALGLIB 3.11 or later
// ALGLIB: Copyright 06.07.2016 by Sergey Bochkanov
// API: ae_int_t rbfgetmodelversion(const rbfmodel &s, const xparams _xparams = xdefault);
ae_int_t rbfgetmodelversion(rbfmodel *s, ae_state *_state) {
   ae_int_t result;
   result = s->modelversion;
   return result;
}

// This function is used to peek into hierarchical RBF  construction  process
// from  some  other  thread  and  get current progress indicator. It returns
// value in [0,1].
//
// IMPORTANT: only HRBFs (hierarchical RBFs) support  peeking  into  progress
//            indicator. Legacy RBF-ML and RBF-QNN do  not  support  it.  You
//            will always get 0 value.
//
// Inputs:
//     S           -   RBF model object
//
// Result:
//     progress value, in [0,1]
// ALGLIB: Copyright 17.11.2018 by Sergey Bochkanov
// API: double rbfpeekprogress(const rbfmodel &s, const xparams _xparams = xdefault);
double rbfpeekprogress(rbfmodel *s, ae_state *_state) {
   double result;
   result = (double)s->progress10000 / 10000.0;
   return result;
}

// This function  is  used  to  submit  a  request  for  termination  of  the
// hierarchical RBF construction process from some other thread.  As  result,
// RBF construction is terminated smoothly (with proper deallocation  of  all
// necessary resources) and resultant model is filled by zeros.
//
// A rep.terminationtype=8 will be returned upon receiving such request.
//
// IMPORTANT: only  HRBFs  (hierarchical  RBFs) support termination requests.
//            Legacy RBF-ML and RBF-QNN do not  support  it.  An  attempt  to
//            terminate their construction will be ignored.
//
// IMPORTANT: termination request flag is cleared when the model construction
//            starts. Thus, any pre-construction termination requests will be
//            silently ignored - only ones submitted AFTER  construction  has
//            actually began will be handled.
//
// Inputs:
//     S           -   RBF model object
// ALGLIB: Copyright 17.11.2018 by Sergey Bochkanov
// API: void rbfrequesttermination(const rbfmodel &s, const xparams _xparams = xdefault);
void rbfrequesttermination(rbfmodel *s, ae_state *_state) {
   s->terminationrequest = true;
}

// Serializer: allocation
// ALGLIB: Copyright 02.02.2012 by Sergey Bochkanov
void rbfalloc(ae_serializer *s, rbfmodel *model, ae_state *_state) {
// Header
   ae_serializer_alloc_entry(s);
// V1 model
   if (model->modelversion == 1) {
   // Header
      ae_serializer_alloc_entry(s);
      rbfv1alloc(s, &model->model1, _state);
      return;
   }
// V2 model
   if (model->modelversion == 2) {
   // Header
      ae_serializer_alloc_entry(s);
      rbfv2alloc(s, &model->model2, _state);
      return;
   }
   ae_assert(false, "Assertion failed", _state);
}

// Serializer: serialization
// These functions serialize a data structure to a C++ string or stream.
// * serialization can be freely moved across 32-bit and 64-bit systems,
//   and different byte orders. For example, you can serialize a string
//   on a SPARC and unserialize it on an x86.
// * ALGLIB++ serialization is compatible with serialization in ALGLIB,
//   in both directions.
// Important properties of s_out:
// * it contains alphanumeric characters, dots, underscores, minus signs
// * these symbols are grouped into words, which are separated by spaces
//   and Windows-style (CR+LF) newlines
// ALGLIB: Copyright 02.02.2012 by Sergey Bochkanov
// API: void rbfserialize(rbfmodel &obj, std::string &s_out);
// API: void rbfserialize(rbfmodel &obj, std::ostream &s_out);
void rbfserialize(ae_serializer *s, rbfmodel *model, ae_state *_state) {
// Header
   ae_serializer_serialize_int(s, getrbfserializationcode(_state), _state);
// V1 model
   if (model->modelversion == 1) {
      ae_serializer_serialize_int(s, rbf_rbffirstversion, _state);
      rbfv1serialize(s, &model->model1, _state);
      return;
   }
// V2 model
   if (model->modelversion == 2) {
   // Header
      ae_serializer_serialize_int(s, rbf_rbfversion2, _state);
      rbfv2serialize(s, &model->model2, _state);
      return;
   }
   ae_assert(false, "Assertion failed", _state);
}

// Serializer: unserialization
// These functions unserialize a data structure from a C++ string or stream.
// Important properties of s_in:
// * any combination of spaces, tabs, Windows or Unix stype newlines can
//   be used as separators, so as to allow flexible reformatting of the
//   stream or string from text or XML files.
// * But you should not insert separators into the middle of the "words"
//   nor you should change case of letters.
// ALGLIB: Copyright 02.02.2012 by Sergey Bochkanov
// API: void rbfunserialize(const std::string &s_in, rbfmodel &obj);
// API: void rbfunserialize(const std::istream &s_in, rbfmodel &obj);
void rbfunserialize(ae_serializer *s, rbfmodel *model, ae_state *_state) {
   ae_int_t i0;
   ae_int_t i1;
   SetObj(rbfmodel, model);
   rbf_rbfpreparenonserializablefields(model, _state);
// Header
   ae_serializer_unserialize_int(s, &i0, _state);
   ae_assert(i0 == getrbfserializationcode(_state), "RBFUnserialize: stream header corrupted", _state);
   ae_serializer_unserialize_int(s, &i1, _state);
   ae_assert(i1 == rbf_rbffirstversion || i1 == rbf_rbfversion2, "RBFUnserialize: stream header corrupted", _state);
// V1 model
   if (i1 == rbf_rbffirstversion) {
      rbfv1unserialize(s, &model->model1, _state);
      model->modelversion = 1;
      model->ny = model->model1.ny;
      model->nx = model->model1.nx;
      rbf_initializev2(model->nx, model->ny, &model->model2, _state);
      return;
   }
// V2 model
   if (i1 == rbf_rbfversion2) {
      rbfv2unserialize(s, &model->model2, _state);
      model->modelversion = 2;
      model->ny = model->model2.ny;
      model->nx = model->model2.nx;
      rbf_initializev1(model->nx, model->ny, &model->model1, _state);
      return;
   }
   ae_assert(false, "Assertion failed", _state);
}

void rbfcalcbuffer_init(void *_p, ae_state *_state, bool make_automatic) {
   rbfcalcbuffer *p = (rbfcalcbuffer *)_p;
   ae_touch_ptr((void *)p);
   rbfv1calcbuffer_init(&p->bufv1, _state, make_automatic);
   rbfv2calcbuffer_init(&p->bufv2, _state, make_automatic);
}

void rbfcalcbuffer_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   rbfcalcbuffer *dst = (rbfcalcbuffer *)_dst;
   rbfcalcbuffer *src = (rbfcalcbuffer *)_src;
   dst->modelversion = src->modelversion;
   rbfv1calcbuffer_copy(&dst->bufv1, &src->bufv1, _state, make_automatic);
   rbfv2calcbuffer_copy(&dst->bufv2, &src->bufv2, _state, make_automatic);
}

void rbfcalcbuffer_free(void *_p, bool make_automatic) {
   rbfcalcbuffer *p = (rbfcalcbuffer *)_p;
   ae_touch_ptr((void *)p);
   rbfv1calcbuffer_free(&p->bufv1, make_automatic);
   rbfv2calcbuffer_free(&p->bufv2, make_automatic);
}

void rbfmodel_init(void *_p, ae_state *_state, bool make_automatic) {
   rbfmodel *p = (rbfmodel *)_p;
   ae_touch_ptr((void *)p);
   rbfv1model_init(&p->model1, _state, make_automatic);
   rbfv2model_init(&p->model2, _state, make_automatic);
   ae_matrix_init(&p->x, 0, 0, DT_REAL, _state, make_automatic);
   ae_matrix_init(&p->y, 0, 0, DT_REAL, _state, make_automatic);
   ae_vector_init(&p->s, 0, DT_REAL, _state, make_automatic);
}

void rbfmodel_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   rbfmodel *dst = (rbfmodel *)_dst;
   rbfmodel *src = (rbfmodel *)_src;
   dst->nx = src->nx;
   dst->ny = src->ny;
   dst->modelversion = src->modelversion;
   rbfv1model_copy(&dst->model1, &src->model1, _state, make_automatic);
   rbfv2model_copy(&dst->model2, &src->model2, _state, make_automatic);
   dst->lambdav = src->lambdav;
   dst->radvalue = src->radvalue;
   dst->radzvalue = src->radzvalue;
   dst->nlayers = src->nlayers;
   dst->aterm = src->aterm;
   dst->algorithmtype = src->algorithmtype;
   dst->epsort = src->epsort;
   dst->epserr = src->epserr;
   dst->maxits = src->maxits;
   dst->nnmaxits = src->nnmaxits;
   dst->n = src->n;
   ae_matrix_copy(&dst->x, &src->x, _state, make_automatic);
   ae_matrix_copy(&dst->y, &src->y, _state, make_automatic);
   dst->hasscale = src->hasscale;
   ae_vector_copy(&dst->s, &src->s, _state, make_automatic);
   dst->progress10000 = src->progress10000;
   dst->terminationrequest = src->terminationrequest;
}

void rbfmodel_free(void *_p, bool make_automatic) {
   rbfmodel *p = (rbfmodel *)_p;
   ae_touch_ptr((void *)p);
   rbfv1model_free(&p->model1, make_automatic);
   rbfv2model_free(&p->model2, make_automatic);
   ae_matrix_free(&p->x, make_automatic);
   ae_matrix_free(&p->y, make_automatic);
   ae_vector_free(&p->s, make_automatic);
}

void rbfreport_init(void *_p, ae_state *_state, bool make_automatic) {
   rbfreport *p = (rbfreport *)_p;
   ae_touch_ptr((void *)p);
}

void rbfreport_copy(void *_dst, void *_src, ae_state *_state, bool make_automatic) {
   rbfreport *dst = (rbfreport *)_dst;
   rbfreport *src = (rbfreport *)_src;
   dst->rmserror = src->rmserror;
   dst->maxerror = src->maxerror;
   dst->arows = src->arows;
   dst->acols = src->acols;
   dst->annz = src->annz;
   dst->iterationscount = src->iterationscount;
   dst->nmv = src->nmv;
   dst->terminationtype = src->terminationtype;
}

void rbfreport_free(void *_p, bool make_automatic) {
   rbfreport *p = (rbfreport *)_p;
   ae_touch_ptr((void *)p);
}
} // end of namespace alglib_impl

namespace alglib {
// Buffer object which is used to perform nearest neighbor  requests  in  the
// multithreaded mode (multiple threads working with same KD-tree object).
//
// This object should be created with KDTreeCreateBuffer().
DefClass(rbfcalcbuffer, )

// RBF model.
//
// Never try to directly work with fields of this object - always use  ALGLIB
// functions to use this object.
DefClass(rbfmodel, )

// RBF solution report:
// * TerminationType   -   termination type, positive values - success,
//                         non-positive - failure.
//
// Fields which are set by modern RBF solvers (hierarchical):
// * RMSError          -   root-mean-square error; NAN for old solvers (ML, QNN)
// * MaxError          -   maximum error; NAN for old solvers (ML, QNN)
DefClass(rbfreport, DecVal(rmserror) DecVal(maxerror) DecVal(arows) DecVal(acols) DecVal(annz) DecVal(iterationscount) DecVal(nmv) DecVal(terminationtype))

void rbfserialize(rbfmodel &obj, std::string &s_out) {
   alglib_impl::ae_int_t ssize;
   alglib_impl::ae_state state; alglib_impl::ae_state_init(&state);
   TryCatch(state, )
   NewSerializer(serializer);
   alglib_impl::ae_serializer_alloc_start(&serializer);
   alglib_impl::rbfalloc(&serializer, obj.c_ptr(), &state);
   ssize = alglib_impl::ae_serializer_get_alloc_size(&serializer);
   s_out.clear();
   s_out.reserve((size_t)(ssize + 1));
   alglib_impl::ae_serializer_sstart_str(&serializer, &s_out);
   alglib_impl::rbfserialize(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_stop(&serializer, &state);
   alglib_impl::ae_assert(s_out.length() <= (size_t)ssize, "ALGLIB: serialization integrity error", &state);
   alglib_impl::ae_state_clear(&state);
}
void rbfserialize(rbfmodel &obj, std::ostream &s_out) {
   alglib_impl::ae_state state; alglib_impl::ae_state_init(&state);
   TryCatch(state, )
   NewSerializer(serializer);
   alglib_impl::ae_serializer_alloc_start(&serializer);
   alglib_impl::rbfalloc(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_get_alloc_size(&serializer); // not actually needed, but we have to ask
   alglib_impl::ae_serializer_sstart_stream(&serializer, &s_out);
   alglib_impl::rbfserialize(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_stop(&serializer, &state);
   alglib_impl::ae_state_clear(&state);
}

void rbfunserialize(const std::string &s_in, rbfmodel &obj) {
   alglib_impl::ae_state state; alglib_impl::ae_state_init(&state);
   TryCatch(state, )
   NewSerializer(serializer);
   alglib_impl::ae_serializer_ustart_str(&serializer, &s_in);
   alglib_impl::rbfunserialize(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_stop(&serializer, &state);
   alglib_impl::ae_state_clear(&state);
}
void rbfunserialize(const std::istream &s_in, rbfmodel &obj) {
   alglib_impl::ae_state state; alglib_impl::ae_state_init(&state);
   TryCatch(state, )
   NewSerializer(serializer);
   alglib_impl::ae_serializer_ustart_stream(&serializer, &s_in);
   alglib_impl::rbfunserialize(&serializer, obj.c_ptr(), &state);
   alglib_impl::ae_serializer_stop(&serializer, &state);
   alglib_impl::ae_state_clear(&state);
}

void rbfcreate(const ae_int_t nx, const ae_int_t ny, rbfmodel &s, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfcreate(nx, ny, ConstT(rbfmodel, s), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfcreatecalcbuffer(const rbfmodel &s, rbfcalcbuffer &buf, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfcreatecalcbuffer(ConstT(rbfmodel, s), ConstT(rbfcalcbuffer, buf), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfsetpoints(const rbfmodel &s, const real_2d_array &xy, const ae_int_t n, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetpoints(ConstT(rbfmodel, s), ConstT(ae_matrix, xy), n, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void rbfsetpoints(const rbfmodel &s, const real_2d_array &xy, const xparams _xparams) {
   ae_int_t n = xy.rows();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetpoints(ConstT(rbfmodel, s), ConstT(ae_matrix, xy), n, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void rbfsetpointsandscales(const rbfmodel &r, const real_2d_array &xy, const ae_int_t n, const real_1d_array &s, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetpointsandscales(ConstT(rbfmodel, r), ConstT(ae_matrix, xy), n, ConstT(ae_vector, s), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void rbfsetpointsandscales(const rbfmodel &r, const real_2d_array &xy, const real_1d_array &s, const xparams _xparams) {
   ae_int_t n = xy.rows();
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetpointsandscales(ConstT(rbfmodel, r), ConstT(ae_matrix, xy), n, ConstT(ae_vector, s), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void rbfsetalgoqnn(const rbfmodel &s, const double q, const double z, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetalgoqnn(ConstT(rbfmodel, s), q, z, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void rbfsetalgoqnn(const rbfmodel &s, const xparams _xparams) {
   double q = 1.0;
   double z = 5.0;
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetalgoqnn(ConstT(rbfmodel, s), q, z, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void rbfsetalgomultilayer(const rbfmodel &s, const double rbase, const ae_int_t nlayers, const double lambdav, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetalgomultilayer(ConstT(rbfmodel, s), rbase, nlayers, lambdav, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#if !defined AE_NO_EXCEPTIONS
void rbfsetalgomultilayer(const rbfmodel &s, const double rbase, const ae_int_t nlayers, const xparams _xparams) {
   double lambdav = 0.01;
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetalgomultilayer(ConstT(rbfmodel, s), rbase, nlayers, lambdav, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
#endif

void rbfsetalgohierarchical(const rbfmodel &s, const double rbase, const ae_int_t nlayers, const double lambdans, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetalgohierarchical(ConstT(rbfmodel, s), rbase, nlayers, lambdans, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfsetlinterm(const rbfmodel &s, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetlinterm(ConstT(rbfmodel, s), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfsetconstterm(const rbfmodel &s, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetconstterm(ConstT(rbfmodel, s), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfsetzeroterm(const rbfmodel &s, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetzeroterm(ConstT(rbfmodel, s), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfsetv2bf(const rbfmodel &s, const ae_int_t bf, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetv2bf(ConstT(rbfmodel, s), bf, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfsetv2its(const rbfmodel &s, const ae_int_t maxits, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetv2its(ConstT(rbfmodel, s), maxits, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfsetv2supportr(const rbfmodel &s, const double r, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfsetv2supportr(ConstT(rbfmodel, s), r, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfbuildmodel(const rbfmodel &s, rbfreport &rep, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfbuildmodel(ConstT(rbfmodel, s), ConstT(rbfreport, rep), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

double rbfcalc1(const rbfmodel &s, const double x0, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::rbfcalc1(ConstT(rbfmodel, s), x0, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

double rbfcalc2(const rbfmodel &s, const double x0, const double x1, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::rbfcalc2(ConstT(rbfmodel, s), x0, x1, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

double rbfcalc3(const rbfmodel &s, const double x0, const double x1, const double x2, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::rbfcalc3(ConstT(rbfmodel, s), x0, x1, x2, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

void rbftscalcbuf(const rbfmodel &s, const rbfcalcbuffer &buf, const real_1d_array &x, real_1d_array &y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbftscalcbuf(ConstT(rbfmodel, s), ConstT(rbfcalcbuffer, buf), ConstT(ae_vector, x), ConstT(ae_vector, y), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfcalcbuf(const rbfmodel &s, const real_1d_array &x, real_1d_array &y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfcalcbuf(ConstT(rbfmodel, s), ConstT(ae_vector, x), ConstT(ae_vector, y), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfcalc(const rbfmodel &s, const real_1d_array &x, real_1d_array &y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfcalc(ConstT(rbfmodel, s), ConstT(ae_vector, x), ConstT(ae_vector, y), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfgridcalc2(const rbfmodel &s, const real_1d_array &x0, const ae_int_t n0, const real_1d_array &x1, const ae_int_t n1, real_2d_array &y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfgridcalc2(ConstT(rbfmodel, s), ConstT(ae_vector, x0), n0, ConstT(ae_vector, x1), n1, ConstT(ae_matrix, y), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfgridcalc2v(const rbfmodel &s, const real_1d_array &x0, const ae_int_t n0, const real_1d_array &x1, const ae_int_t n1, real_1d_array &y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfgridcalc2v(ConstT(rbfmodel, s), ConstT(ae_vector, x0), n0, ConstT(ae_vector, x1), n1, ConstT(ae_vector, y), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfgridcalc2vsubset(const rbfmodel &s, const real_1d_array &x0, const ae_int_t n0, const real_1d_array &x1, const ae_int_t n1, const boolean_1d_array &flagy, real_1d_array &y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfgridcalc2vsubset(ConstT(rbfmodel, s), ConstT(ae_vector, x0), n0, ConstT(ae_vector, x1), n1, ConstT(ae_vector, flagy), ConstT(ae_vector, y), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfgridcalc3v(const rbfmodel &s, const real_1d_array &x0, const ae_int_t n0, const real_1d_array &x1, const ae_int_t n1, const real_1d_array &x2, const ae_int_t n2, real_1d_array &y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfgridcalc3v(ConstT(rbfmodel, s), ConstT(ae_vector, x0), n0, ConstT(ae_vector, x1), n1, ConstT(ae_vector, x2), n2, ConstT(ae_vector, y), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfgridcalc3vsubset(const rbfmodel &s, const real_1d_array &x0, const ae_int_t n0, const real_1d_array &x1, const ae_int_t n1, const real_1d_array &x2, const ae_int_t n2, const boolean_1d_array &flagy, real_1d_array &y, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfgridcalc3vsubset(ConstT(rbfmodel, s), ConstT(ae_vector, x0), n0, ConstT(ae_vector, x1), n1, ConstT(ae_vector, x2), n2, ConstT(ae_vector, flagy), ConstT(ae_vector, y), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

void rbfunpack(const rbfmodel &s, ae_int_t &nx, ae_int_t &ny, real_2d_array &xwr, ae_int_t &nc, real_2d_array &v, ae_int_t &modelversion, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfunpack(ConstT(rbfmodel, s), &nx, &ny, ConstT(ae_matrix, xwr), &nc, ConstT(ae_matrix, v), &modelversion, &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}

ae_int_t rbfgetmodelversion(const rbfmodel &s, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::ae_int_t Z = alglib_impl::rbfgetmodelversion(ConstT(rbfmodel, s), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return Z;
}

double rbfpeekprogress(const rbfmodel &s, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, 0.0)
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   double D = alglib_impl::rbfpeekprogress(ConstT(rbfmodel, s), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
   return D;
}

void rbfrequesttermination(const rbfmodel &s, const xparams _xparams) {
   alglib_impl::ae_state _alglib_env_state; alglib_impl::ae_state_init(&_alglib_env_state);
   TryCatch(_alglib_env_state, )
   if (_xparams.flags != 0x0)
      ae_state_set_flags(&_alglib_env_state, _xparams.flags);
   alglib_impl::rbfrequesttermination(ConstT(rbfmodel, s), &_alglib_env_state);
   alglib_impl::ae_state_clear(&_alglib_env_state);
}
} // end of namespace alglib
