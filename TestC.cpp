#include <time.h>
#define InAlgLib
#include "DataAnalysis.h"
#include "DiffEquations.h"
#include "FastTransforms.h"
#include "Interpolation.h"

const bool silent = true;
using namespace alglib_impl;

// Test the relative error in A with respect to B, with the absolute error scaled with respect to Scale, if |B| < Scale.
inline static bool RelNear(double A, double B, double Tiny, double Scale) { return NearAtR(A, B, Tiny * rmax2(fabs(B), Scale)); }

// === ablasf testing unit ===
bool testablasf() {
   return true;
}

// === hqrnd testing unit ===
// Function for test HQRNDContinuous function
static bool hqrndcontinuoustest() {
   ae_frame _frame_block;
   ae_int_t nb;
   ae_int_t samplesize;
   ae_int_t xp;
   ae_int_t i;
   ae_int_t j;
   double v;
   double sigma;
   double sigmamax;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(sample, 0, DT_REAL);
   NewVector(bins, 0, DT_INT);
   NewVector(binbounds, 0, DT_REAL);
   NewObj(hqrndstate, state);
   Ok = true;
// Test for sample size equal to 1
   ae_vector_set_length(&sample, 1);
   sample.xR[0] = randomreal();
   hqrndrandomize(&state);
   Ok = Ok && hqrndcontinuous(&state, &sample, 1) == sample.xR[0];
// Test for larger samples
   xp = 100000;
   sigmamax = 10.0;
   for (samplesize = 2; samplesize <= 5; samplesize++) {
   // 1. Generate random sample with SampleSize points
   // 2. Generate NB == 3*(SampleSize-1) bins, with bounds as prescribed by (BinBounds[I],BinBounds[I+1]).
   //    Bin bounds are generated in such a way that value can fall into any bin with same probability
   // 3. Generate many random values
   // 4. Calculate number of values which fall into each bin
   // 5. Bins[I] should have binomial distribution with mean XP/NB and
   //    variance XP*(1/NB)*(1-1/NB)
      nb = 3 * (samplesize - 1);
      sigma = sqrt(xp * (1.0 / nb) * (1 - 1.0 / nb));
      ae_vector_set_length(&sample, samplesize);
      sample.xR[0] = randommid();
      for (i = 0; i < samplesize - 1; i++) {
         sample.xR[i + 1] = sample.xR[i] + 0.1 + randomreal();
      }
      ae_vector_set_length(&bins, nb);
      ae_vector_set_length(&binbounds, nb + 1);
      for (i = 0; i < samplesize - 1; i++) {
         bins.xZ[3 * i] = 0;
         bins.xZ[3 * i + 1] = 0;
         bins.xZ[3 * i + 2] = 0;
         binbounds.xR[3 * i] = sample.xR[i];
         binbounds.xR[3 * i + 1] = sample.xR[i] + (sample.xR[i + 1] - sample.xR[i]) / 3;
         binbounds.xR[3 * i + 2] = sample.xR[i] + (sample.xR[i + 1] - sample.xR[i]) * 2 / 3;
      }
      binbounds.xR[nb] = sample.xR[samplesize - 1];
      hqrndrandomize(&state);
      for (i = 0; i < xp; i++) {
         v = hqrndcontinuous(&state, &sample, samplesize);
         for (j = 0; j < nb; j++) {
            if (v > binbounds.xR[j] && v < binbounds.xR[j + 1]) {
               bins.xZ[j]++;
               break;
            }
         }
      }
      for (i = 0; i < nb; i++) {
         Ok = Ok && NearAtR(bins.xZ[i], (double)xp / nb, sigma * sigmamax);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Function for test HQRNDDiscrete function
static bool hqrnddiscretetest() {
   ae_frame _frame_block;
   double sigma;
   double sigmathreshold;
   double tsample;
   double max;
   double min;
   ae_int_t i;
   ae_int_t j;
   ae_int_t s1;
   ae_int_t s2;
   ae_int_t binscount;
   ae_int_t xp;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(sample, 0, DT_REAL);
   NewVector(nn, 0, DT_INT);
   NewObj(hqrndstate, state);
// We test that all values from discrete sample are generated with same probability.
// To do this, we generate random values many times, then we calculate actual probabilities
// and compare them with theoretical ones.
   max = 100.0;
   min = -100.0;
   xp = 100000;
   sigmathreshold = 10.0;
   for (binscount = 1; binscount <= 5; binscount++) {
      sigma = sqrt(xp * (1.0 / binscount) * (1 - 1.0 / binscount));
      ae_vector_set_length(&nn, binscount);
      for (i = 0; i < binscount; i++) {
         nn.xZ[i] = 0;
      }
      ae_vector_set_length(&sample, binscount);
      sample.xR[0] = (max - min) * randomreal() + min;
      for (i = 1; i < binscount; i++) {
         sample.xR[i] = sample.xR[i - 1] + max * randomreal() + 0.001;
      }
      s1 = 1 + randominteger(32000);
      s2 = 1 + randominteger(32000);
      hqrndseed(s1, s2, &state);
      for (i = 0; i < xp; i++) {
         tsample = hqrnddiscrete(&state, &sample, binscount);
         for (j = 0; j < binscount; j++) {
            if (tsample == sample.xR[j]) {
               nn.xZ[j]++;
               break;
            }
         }
      }
      for (i = 0; i < binscount; i++) {
         if (nn.xZ[i] < (double)xp / binscount - sigmathreshold * sigma || nn.xZ[i] > (double)xp / binscount + sigmathreshold * sigma) {
            if (!silent) {
               printf("HQRNDDiscreteTest: Failed\n");
               printf("* nn[%0d] = %0d, xp/BinsCount = %0.5f, C*sigma = %0.5f\n", (int)i, (int)nn.xZ[i], (double)xp / binscount, sigmathreshold * sigma);
            }
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
      if (!silent) {
         printf("HQRNDDiscreteTest: Ok\n");
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

static void testhqrndunit_calculatemv(RVector *x, ae_int_t n, double *mean, double *means, double *stddev, double *stddevs) {
   ae_int_t i;
   double v1;
   double v2;
   double variance;
   *mean = 0;
   *means = 0;
   *stddev = 0;
   *stddevs = 0;
   *mean = 0.0;
   *means = 1.0;
   *stddev = 0.0;
   *stddevs = 1.0;
   variance = 0.0;
   if (n <= 1) {
      return;
   }
// Mean
   for (i = 0; i < n; i++) {
      *mean += x->xR[i];
   }
   *mean /= n;
// Variance (using corrected two-pass algorithm)
   if (n != 1) {
      v1 = 0.0;
      for (i = 0; i < n; i++) {
         v1 += sqr(x->xR[i] - (*mean));
      }
      v2 = 0.0;
      for (i = 0; i < n; i++) {
         v2 += x->xR[i] - (*mean);
      }
      v2 = sqr(v2) / n;
      variance = (v1 - v2) / (n - 1);
      if (variance < 0.0) {
         variance = 0.0;
      }
      *stddev = sqrt(variance);
   }
// Errors
   *means = *stddev / sqrt(n);
   *stddevs = *stddev * sqrt(2.0) / sqrt(n - 1);
}

// Unsets HQRNDState structure
static void testhqrndunit_unsetstate(hqrndstate *state) {
   state->s1 = 0;
   state->s2 = 0;
   state->magicv = 0;
}

bool testhqrnd() {
   ae_frame _frame_block;
   bool Ok;
   ae_int_t samplesize;
   double sigmathreshold;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t pass;
   ae_int_t s1;
   ae_int_t s2;
   ae_int_t i1;
   ae_int_t i2;
   double r1;
   double r2;
   ae_int_t am;
   ae_int_t an;
   double mean;
   double means;
   double stddev;
   double stddevs;
   double lambdav;
   bool seedOk;
   bool urOk;
   double ursigmaerr;
   bool uiOk;
   double uisigmaerr;
   bool normOk;
   double normsigmaerr;
   bool unit2Ok;
   bool expOk;
   double expsigmaerr;
   bool discreteOk;
   bool continuousOk;
   ae_frame_make(&_frame_block);
   if (!silent) printf("Random Number Generator Test Breakdown\n");
   NewVector(x, 0, DT_REAL);
   NewVector(dx, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(bins, 0, DT_INT);
   NewObj(hqrndstate, state);
   Ok = true;
   sigmathreshold = 7.0;
   samplesize = 100000 + randominteger(100);
   passcount = 50;
   seedOk = true;
   urOk = true;
   uiOk = true;
   normOk = true;
   expOk = true;
   unit2Ok = true;
   ae_vector_set_length(&x, samplesize);
// Test seed errors
   for (pass = 1; pass <= passcount; pass++) {
      s1 = 1 + randominteger(32000);
      s2 = 1 + randominteger(32000);
      testhqrndunit_unsetstate(&state);
      hqrndseed(s1, s2, &state);
      i1 = hqrnduniformi(&state, 100);
      testhqrndunit_unsetstate(&state);
      hqrndseed(s1, s2, &state);
      i2 = hqrnduniformi(&state, 100);
      seedOk = seedOk && i1 == i2;
      testhqrndunit_unsetstate(&state);
      hqrndseed(s1, s2, &state);
      r1 = hqrnduniformr(&state);
      testhqrndunit_unsetstate(&state);
      hqrndseed(s1, s2, &state);
      r2 = hqrnduniformr(&state);
      seedOk = seedOk && r1 == r2;
//    seedOk = seedOk && NearAtR(r1, r2, machineepsilon);
   }
// Test HQRNDRandomize() and real uniform generator
   testhqrndunit_unsetstate(&state);
   hqrndrandomize(&state);
   ursigmaerr = 0.0;
   for (i = 0; i < samplesize; i++) {
      x.xR[i] = hqrnduniformr(&state);
   }
   for (i = 0; i < samplesize; i++) {
      urOk = urOk && x.xR[i] > 0.0 && x.xR[i] < 1.0;
   }
   testhqrndunit_calculatemv(&x, samplesize, &mean, &means, &stddev, &stddevs);
   if (means != 0.0) {
      ursigmaerr = rmax2(ursigmaerr, fabs((mean - 0.5) / means));
   } else {
      urOk = false;
   }
   if (stddevs != 0.0) {
      ursigmaerr = rmax2(ursigmaerr, fabs((stddev - sqrt(1.0 / 12.0)) / stddevs));
   } else {
      urOk = false;
   }
   urOk = urOk && ursigmaerr <= sigmathreshold;
// Test HQRNDRandomize() and integer uniform
   testhqrndunit_unsetstate(&state);
   hqrndrandomize(&state);
   uisigmaerr = 0.0;
   for (n = 2; n <= 10; n++) {
      for (i = 0; i < samplesize; i++) {
         x.xR[i] = (double)hqrnduniformi(&state, n);
      }
      for (i = 0; i < samplesize; i++) {
         uiOk = uiOk && x.xR[i] >= 0.0 && x.xR[i] < n;
      }
      testhqrndunit_calculatemv(&x, samplesize, &mean, &means, &stddev, &stddevs);
      if (means != 0.0) {
         uisigmaerr = rmax2(uisigmaerr, fabs((mean - 0.5 * (n - 1)) / means));
      } else {
         uiOk = false;
      }
      if (stddevs != 0.0) {
         uisigmaerr = rmax2(uisigmaerr, fabs((stddev - sqrt((sqr(n) - 1) / 12)) / stddevs));
      } else {
         uiOk = false;
      }
   }
   uiOk = uiOk && uisigmaerr <= sigmathreshold;
// Special 'close-to-limit' test on uniformity of integers
// (straightforward implementation like 'RND mod N' will return
// non-uniform numbers for N == 2/3*LIMIT)
   testhqrndunit_unsetstate(&state);
   hqrndrandomize(&state);
   uisigmaerr = 0.0;
   n = 1431655708;
   for (i = 0; i < samplesize; i++) {
      x.xR[i] = (double)hqrnduniformi(&state, n);
   }
   for (i = 0; i < samplesize; i++) {
      uiOk = uiOk && x.xR[i] >= 0.0 && x.xR[i] < n;
   }
   testhqrndunit_calculatemv(&x, samplesize, &mean, &means, &stddev, &stddevs);
   if (means != 0.0) {
      uisigmaerr = rmax2(uisigmaerr, fabs((mean - 0.5 * (n - 1)) / means));
   } else {
      uiOk = false;
   }
   if (stddevs != 0.0) {
      uisigmaerr = rmax2(uisigmaerr, fabs((stddev - sqrt((sqr(n) - 1) / 12)) / stddevs));
   } else {
      uiOk = false;
   }
   uiOk = uiOk && uisigmaerr <= sigmathreshold;
// Test normal
   testhqrndunit_unsetstate(&state);
   hqrndrandomize(&state);
   i = 0;
   while (i < samplesize) {
      hqrndnormal2(&state, &r1, &r2);
      x.xR[i] = r1;
      if (i + 1 < samplesize) {
         x.xR[i + 1] = r2;
      }
      i += 2;
   }
   normsigmaerr = 0.0;
   testhqrndunit_calculatemv(&x, samplesize, &mean, &means, &stddev, &stddevs);
   if (means != 0.0) {
      normsigmaerr = rmax2(normsigmaerr, fabs((mean - 0) / means));
   } else {
      normOk = false;
   }
   if (stddevs != 0.0) {
      normsigmaerr = rmax2(normsigmaerr, fabs((stddev - 1) / stddevs));
   } else {
      normOk = false;
   }
   normOk = normOk && normsigmaerr <= sigmathreshold;
   ae_vector_set_length(&x, 0);
   hqrndnormalv(&state, samplesize, &x);
   normOk = normOk && x.cnt == samplesize;
   normOk = normOk && isfinitevector(&x, samplesize);
   if (normOk) {
   // Check mean/sigma of the distribution
      testhqrndunit_calculatemv(&x, samplesize, &mean, &means, &stddev, &stddevs);
      normOk = normOk && means != 0.0;
      normOk = normOk && stddevs != 0.0;
      normsigmaerr = 0.0;
      normsigmaerr = rmax2(normsigmaerr, fabs((mean - 0.0) / coalesce(means, 1.0)));
      normsigmaerr = rmax2(normsigmaerr, fabs((stddev - 1.0) / coalesce(stddevs, 1.0)));
      normOk = normOk && normsigmaerr <= sigmathreshold;
   // Check that subsequent differences are normally distributed too
      ae_vector_set_length(&dx, samplesize - 1);
      for (i = 0; i < samplesize - 1; i++) {
         dx.xR[i] = x.xR[i + 1] - x.xR[i];
      }
      testhqrndunit_calculatemv(&dx, samplesize - 1, &mean, &means, &stddev, &stddevs);
      normOk = normOk && means != 0.0;
      normOk = normOk && stddevs != 0.0;
      normsigmaerr = 0.0;
      normsigmaerr = rmax2(normsigmaerr, fabs((mean - 0.0) / coalesce(means, 1.0)));
      normsigmaerr = rmax2(normsigmaerr, fabs((stddev - sqrt(2.0)) / coalesce(stddevs, 1.0)));
      normOk = normOk && normsigmaerr <= sigmathreshold;
   }
   am = 1 + randominteger(iround(sqrt(samplesize)));
   an = 1 + samplesize / am;
   hqrndnormalm(&state, am, an, &a);
   normOk = normOk && a.rows == am;
   normOk = normOk && a.cols == an;
   normOk = normOk && apservisfinitematrix(&a, am, an);
   ae_vector_set_length(&x, am * an);
   for (i = 0; i < am; i++) {
      for (j = 0; j < an; j++) {
         x.xR[i * an + j] = a.xyR[i][j];
      }
   }
   testhqrndunit_calculatemv(&x, am * an, &mean, &means, &stddev, &stddevs);
   normOk = normOk && means != 0.0;
   normOk = normOk && stddevs != 0.0;
   normsigmaerr = 0.0;
   normsigmaerr = rmax2(normsigmaerr, fabs((mean - 0.0) / coalesce(means, 1.0)));
   normsigmaerr = rmax2(normsigmaerr, fabs((stddev - 1.0) / coalesce(stddevs, 1.0)));
   normOk = normOk && normsigmaerr <= sigmathreshold;
// Test unit2
   testhqrndunit_unsetstate(&state);
   hqrndrandomize(&state);
   n = 1000000;
   ae_vector_set_length(&bins, 10);
   for (i = 0; i < bins.cnt; i++) {
      bins.xZ[i] = 0;
   }
   for (pass = 0; pass < n; pass++) {
      hqrndunit2(&state, &r1, &r2);
      unit2Ok = unit2Ok && NearAtR(r1 * r1 + r2 * r2, 1.0, 100.0 * machineepsilon);
      k = ifloor((atan2(r1, r2) + pi) / (2 * pi) * bins.cnt);
      if (k < 0) {
         k = 0;
      }
      if (k >= bins.cnt) {
         k = bins.cnt - 1;
      }
      bins.xZ[k]++;
   }
   for (i = 0; i < bins.cnt; i++) {
      unit2Ok = unit2Ok && (double)bins.xZ[i] >= 0.9 * n / bins.cnt && (double)bins.xZ[i] <= 1.1 * n / bins.cnt;
   }
// Test exponential
   testhqrndunit_unsetstate(&state);
   hqrndrandomize(&state);
   expsigmaerr = 0.0;
   lambdav = 2 + 5.0 * randomreal();
   for (i = 0; i < samplesize; i++) {
      x.xR[i] = hqrndexponential(&state, lambdav);
   }
   for (i = 0; i < samplesize; i++) {
      uiOk = uiOk && x.xR[i] >= 0.0;
   }
   testhqrndunit_calculatemv(&x, samplesize, &mean, &means, &stddev, &stddevs);
   if (means != 0.0) {
      expsigmaerr = rmax2(expsigmaerr, fabs((mean - 1.0 / lambdav) / means));
   } else {
      expOk = false;
   }
   if (stddevs != 0.0) {
      expsigmaerr = rmax2(expsigmaerr, fabs((stddev - 1.0 / lambdav) / stddevs));
   } else {
      expOk = false;
   }
   expOk = expOk && expsigmaerr <= sigmathreshold;
// Discrete/Continuous tests
   discreteOk = hqrnddiscretetest();
   continuousOk = hqrndcontinuoustest();
// The final report.
   Ok = seedOk && urOk && uiOk && normOk && unit2Ok && expOk && discreteOk && continuousOk;
   if (!Ok || !silent) {
      printf("Random Number Generator Tests\n");
      printf("SEED Test:                                %s\n", seedOk? "Ok": "Failed");
      printf("Uniform Continuous:                       %s\n", urOk? "Ok": "Failed");
      printf("Uniform Integer:                          %s\n", uiOk? "Ok": "Failed");
      printf("Normal:                                   %s\n", normOk? "Ok": "Failed");
      printf("Unit 2:                                   %s\n", unit2Ok? "Ok": "Failed");
      printf("Exponential:                              %s\n", expOk? "Ok": "Failed");
      printf("Discrete:                                 %s\n", discreteOk? "Ok": "Failed");
      printf("Continuous:                               %s\n", continuousOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === ablas testing unit ===
// Internal subroutine.
// Triangular matrix inversion
//
//   -- LAPACK routine (version 3.0) --
//      Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//      Courant Institute, Argonne National Lab, and Rice University
//      February 29, 1992
static bool testablasunit_internalrmatrixtrinverse(RMatrix *a, ae_int_t n, bool isupper, bool isunittriangular) {
   ae_frame _frame_block;
   bool nounit;
   ae_int_t i;
   ae_int_t j;
   double v;
   double ajj;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(t, 0, DT_REAL);
   Ok = true;
   ae_vector_set_length(&t, n);
// Test the input parameters.
   nounit = !isunittriangular;
   if (isupper) {
   // Compute inverse of upper triangular matrix.
      for (j = 0; j < n; j++) {
         if (nounit) {
            if (a->xyR[j][j] == 0.0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            a->xyR[j][j] = 1 / a->xyR[j][j];
            ajj = -a->xyR[j][j];
         } else {
            ajj = -1.0;
         }
      // Compute elements 1:j-1 of j-th column.
         if (j > 0) {
            ae_v_move(t.xR, 1, &a->xyR[0][j], a->stride, j);
            for (i = 0; i < j; i++) {
               if (i < j - 1) {
                  v = ae_v_dotproduct(&a->xyR[i][i + 1], 1, &t.xR[i + 1], 1, j - i - 1);
               } else {
                  v = 0.0;
               }
               if (nounit) {
                  a->xyR[i][j] = v + a->xyR[i][i] * t.xR[i];
               } else {
                  a->xyR[i][j] = v + t.xR[i];
               }
            }
            ae_v_muld(&a->xyR[0][j], a->stride, j, ajj);
         }
      }
   } else {
   // Compute inverse of lower triangular matrix.
      for (j = n - 1; j >= 0; j--) {
         if (nounit) {
            if (a->xyR[j][j] == 0.0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            a->xyR[j][j] = 1 / a->xyR[j][j];
            ajj = -a->xyR[j][j];
         } else {
            ajj = -1.0;
         }
         if (j < n - 1) {
         // Compute elements j+1:n of j-th column.
            ae_v_move(&t.xR[j + 1], 1, &a->xyR[j + 1][j], a->stride, n - j - 1);
            for (i = j + 1; i < n; i++) {
               if (i > j + 1) {
                  v = ae_v_dotproduct(&a->xyR[i][j + 1], 1, &t.xR[j + 1], 1, i - j - 1);
               } else {
                  v = 0.0;
               }
               if (nounit) {
                  a->xyR[i][j] = v + a->xyR[i][i] * t.xR[i];
               } else {
                  a->xyR[i][j] = v + t.xR[i];
               }
            }
            ae_v_muld(&a->xyR[j + 1][j], a->stride, n - j - 1, ajj);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Internal subroutine.
// Triangular matrix inversion
//
//   -- LAPACK routine (version 3.0) --
//      Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//      Courant Institute, Argonne National Lab, and Rice University
//      February 29, 1992
static bool testablasunit_internalcmatrixtrinverse(CMatrix *a, ae_int_t n, bool isupper, bool isunittriangular) {
   ae_frame _frame_block;
   bool nounit;
   ae_int_t i;
   ae_int_t j;
   complex v;
   complex ajj;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(t, 0, DT_COMPLEX);
   Ok = true;
   ae_vector_set_length(&t, n);
// Test the input parameters.
   nounit = !isunittriangular;
   if (isupper) {
   // Compute inverse of upper triangular matrix.
      for (j = 0; j < n; j++) {
         if (nounit) {
            if (ae_c_eq_d(a->xyC[j][j], 0.0)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            a->xyC[j][j] = ae_c_d_div(1, a->xyC[j][j]);
            ajj = ae_c_neg(a->xyC[j][j]);
         } else {
            ajj = complex_from_i(-1);
         }
      // Compute elements 1:j-1 of j-th column.
         if (j > 0) {
            ae_v_cmove(t.xC, 1, &a->xyC[0][j], a->stride, "N", j);
            for (i = 0; i < j; i++) {
               if (i + 1 < j) {
                  v = ae_v_cdotproduct(&a->xyC[i][i + 1], 1, "N", &t.xC[i + 1], 1, "N", j - i - 1);
               } else {
                  v = complex_from_i(0);
               }
               if (nounit) {
                  a->xyC[i][j] = ae_c_add(v, ae_c_mul(a->xyC[i][i], t.xC[i]));
               } else {
                  a->xyC[i][j] = ae_c_add(v, t.xC[i]);
               }
            }
            ae_v_cmulc(&a->xyC[0][j], a->stride, j, ajj);
         }
      }
   } else {
   // Compute inverse of lower triangular matrix.
      for (j = n - 1; j >= 0; j--) {
         if (nounit) {
            if (ae_c_eq_d(a->xyC[j][j], 0.0)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            a->xyC[j][j] = ae_c_d_div(1, a->xyC[j][j]);
            ajj = ae_c_neg(a->xyC[j][j]);
         } else {
            ajj = complex_from_i(-1);
         }
         if (j + 1 < n) {
         // Compute elements j+1:n of j-th column.
            ae_v_cmove(&t.xC[j + 1], 1, &a->xyC[j + 1][j], a->stride, "N", n - j - 1);
            for (i = j + 1; i < n; i++) {
               if (i > j + 1) {
                  v = ae_v_cdotproduct(&a->xyC[i][j + 1], 1, "N", &t.xC[j + 1], 1, "N", i - j - 1);
               } else {
                  v = complex_from_i(0);
               }
               if (nounit) {
                  a->xyC[i][j] = ae_c_add(v, ae_c_mul(a->xyC[i][i], t.xC[i]));
               } else {
                  a->xyC[i][j] = ae_c_add(v, t.xC[i]);
               }
            }
            ae_v_cmulc(&a->xyC[j + 1][j], a->stride, n - j - 1, ajj);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Reference implementation
// ALGLIB Routine: Copyright 15.12.2009 by Sergey Bochkanov
static void testablasunit_refrmatrixrighttrsm(ae_int_t m, ae_int_t n, RMatrix *a, ae_int_t i1, ae_int_t j1, bool isupper, bool isunit, ae_int_t optype, RMatrix *x, ae_int_t i2, ae_int_t j2) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double vr;
   bool rupper;
   ae_frame_make(&_frame_block);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewVector(tx, 0, DT_REAL);
   if (n * m == 0) {
      ae_frame_leave();
      return;
   }
   ae_matrix_set_length(&a1, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a1.xyR[i][j] = 0.0;
      }
   }
   if (isupper) {
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            a1.xyR[i][j] = a->xyR[i1 + i][j1 + j];
         }
      }
   } else {
      for (i = 0; i < n; i++) {
         for (j = 0; j <= i; j++) {
            a1.xyR[i][j] = a->xyR[i1 + i][j1 + j];
         }
      }
   }
   rupper = isupper;
   if (isunit) {
      for (i = 0; i < n; i++) {
         a1.xyR[i][i] = 1.0;
      }
   }
   ae_matrix_set_length(&a2, n, n);
   if (optype == 0) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a2.xyR[i][j] = a1.xyR[i][j];
         }
      }
   }
   if (optype == 1) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a2.xyR[i][j] = a1.xyR[j][i];
         }
      }
      rupper = !rupper;
   }
   testablasunit_internalrmatrixtrinverse(&a2, n, rupper, false);
   ae_vector_set_length(&tx, n);
   for (i = 0; i < m; i++) {
      ae_v_move(tx.xR, 1, &x->xyR[i2 + i][j2], 1, n);
      for (j = 0; j < n; j++) {
         vr = ae_v_dotproduct(tx.xR, 1, &a2.xyR[0][j], a2.stride, n);
         x->xyR[i2 + i][j2 + j] = vr;
      }
   }
   ae_frame_leave();
}

// Reference implementation
// ALGLIB Routine: Copyright 15.12.2009 by Sergey Bochkanov
static void testablasunit_refcmatrixrighttrsm(ae_int_t m, ae_int_t n, CMatrix *a, ae_int_t i1, ae_int_t j1, bool isupper, bool isunit, ae_int_t optype, CMatrix *x, ae_int_t i2, ae_int_t j2) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   complex vc;
   bool rupper;
   ae_frame_make(&_frame_block);
   NewMatrix(a1, 0, 0, DT_COMPLEX);
   NewMatrix(a2, 0, 0, DT_COMPLEX);
   NewVector(tx, 0, DT_COMPLEX);
   if (n * m == 0) {
      ae_frame_leave();
      return;
   }
   ae_matrix_set_length(&a1, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a1.xyC[i][j] = complex_from_i(0);
      }
   }
   if (isupper) {
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            a1.xyC[i][j] = a->xyC[i1 + i][j1 + j];
         }
      }
   } else {
      for (i = 0; i < n; i++) {
         for (j = 0; j <= i; j++) {
            a1.xyC[i][j] = a->xyC[i1 + i][j1 + j];
         }
      }
   }
   rupper = isupper;
   if (isunit) {
      for (i = 0; i < n; i++) {
         a1.xyC[i][i] = complex_from_i(1);
      }
   }
   ae_matrix_set_length(&a2, n, n);
   if (optype == 0) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a2.xyC[i][j] = a1.xyC[i][j];
         }
      }
   }
   if (optype == 1) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a2.xyC[i][j] = a1.xyC[j][i];
         }
      }
      rupper = !rupper;
   }
   if (optype == 2) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a2.xyC[i][j] = conj(a1.xyC[j][i]);
         }
      }
      rupper = !rupper;
   }
   testablasunit_internalcmatrixtrinverse(&a2, n, rupper, false);
   ae_vector_set_length(&tx, n);
   for (i = 0; i < m; i++) {
      ae_v_cmove(tx.xC, 1, &x->xyC[i2 + i][j2], 1, "N", n);
      for (j = 0; j < n; j++) {
         vc = ae_v_cdotproduct(tx.xC, 1, "N", &a2.xyC[0][j], a2.stride, "N", n);
         x->xyC[i2 + i][j2 + j] = vc;
      }
   }
   ae_frame_leave();
}

// Reference implementation
// ALGLIB Routine: Copyright 15.12.2009 by Sergey Bochkanov
static void testablasunit_refrmatrixlefttrsm(ae_int_t m, ae_int_t n, RMatrix *a, ae_int_t i1, ae_int_t j1, bool isupper, bool isunit, ae_int_t optype, RMatrix *x, ae_int_t i2, ae_int_t j2) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double vr;
   bool rupper;
   ae_frame_make(&_frame_block);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewVector(tx, 0, DT_REAL);
   if (n * m == 0) {
      ae_frame_leave();
      return;
   }
   ae_matrix_set_length(&a1, m, m);
   for (i = 0; i < m; i++) {
      for (j = 0; j < m; j++) {
         a1.xyR[i][j] = 0.0;
      }
   }
   if (isupper) {
      for (i = 0; i < m; i++) {
         for (j = i; j < m; j++) {
            a1.xyR[i][j] = a->xyR[i1 + i][j1 + j];
         }
      }
   } else {
      for (i = 0; i < m; i++) {
         for (j = 0; j <= i; j++) {
            a1.xyR[i][j] = a->xyR[i1 + i][j1 + j];
         }
      }
   }
   rupper = isupper;
   if (isunit) {
      for (i = 0; i < m; i++) {
         a1.xyR[i][i] = 1.0;
      }
   }
   ae_matrix_set_length(&a2, m, m);
   if (optype == 0) {
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            a2.xyR[i][j] = a1.xyR[i][j];
         }
      }
   }
   if (optype == 1) {
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            a2.xyR[i][j] = a1.xyR[j][i];
         }
      }
      rupper = !rupper;
   }
   testablasunit_internalrmatrixtrinverse(&a2, m, rupper, false);
   ae_vector_set_length(&tx, m);
   for (j = 0; j < n; j++) {
      ae_v_move(tx.xR, 1, &x->xyR[i2][j2 + j], x->stride, m);
      for (i = 0; i < m; i++) {
         vr = ae_v_dotproduct(a2.xyR[i], 1, tx.xR, 1, m);
         x->xyR[i2 + i][j2 + j] = vr;
      }
   }
   ae_frame_leave();
}

// Reference implementation
// ALGLIB Routine: Copyright 15.12.2009 by Sergey Bochkanov
static void testablasunit_refcmatrixlefttrsm(ae_int_t m, ae_int_t n, CMatrix *a, ae_int_t i1, ae_int_t j1, bool isupper, bool isunit, ae_int_t optype, CMatrix *x, ae_int_t i2, ae_int_t j2) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   complex vc;
   bool rupper;
   ae_frame_make(&_frame_block);
   NewMatrix(a1, 0, 0, DT_COMPLEX);
   NewMatrix(a2, 0, 0, DT_COMPLEX);
   NewVector(tx, 0, DT_COMPLEX);
   if (n * m == 0) {
      ae_frame_leave();
      return;
   }
   ae_matrix_set_length(&a1, m, m);
   for (i = 0; i < m; i++) {
      for (j = 0; j < m; j++) {
         a1.xyC[i][j] = complex_from_i(0);
      }
   }
   if (isupper) {
      for (i = 0; i < m; i++) {
         for (j = i; j < m; j++) {
            a1.xyC[i][j] = a->xyC[i1 + i][j1 + j];
         }
      }
   } else {
      for (i = 0; i < m; i++) {
         for (j = 0; j <= i; j++) {
            a1.xyC[i][j] = a->xyC[i1 + i][j1 + j];
         }
      }
   }
   rupper = isupper;
   if (isunit) {
      for (i = 0; i < m; i++) {
         a1.xyC[i][i] = complex_from_i(1);
      }
   }
   ae_matrix_set_length(&a2, m, m);
   if (optype == 0) {
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            a2.xyC[i][j] = a1.xyC[i][j];
         }
      }
   }
   if (optype == 1) {
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            a2.xyC[i][j] = a1.xyC[j][i];
         }
      }
      rupper = !rupper;
   }
   if (optype == 2) {
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            a2.xyC[i][j] = conj(a1.xyC[j][i]);
         }
      }
      rupper = !rupper;
   }
   testablasunit_internalcmatrixtrinverse(&a2, m, rupper, false);
   ae_vector_set_length(&tx, m);
   for (j = 0; j < n; j++) {
      ae_v_cmove(tx.xC, 1, &x->xyC[i2][j2 + j], x->stride, "N", m);
      for (i = 0; i < m; i++) {
         vc = ae_v_cdotproduct(a2.xyC[i], 1, "N", tx.xC, 1, "N", m);
         x->xyC[i2 + i][j2 + j] = vc;
      }
   }
   ae_frame_leave();
}

// ?Matrix????TRSM tests
//
// Returns False for passed test, True - for failed
static bool testablasunit_testtrsm(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t optype;
   ae_int_t uppertype;
   ae_int_t unittype;
   ae_int_t xoffsi;
   ae_int_t xoffsj;
   ae_int_t aoffsitype;
   ae_int_t aoffsjtype;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   double threshold;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewMatrix(refrxl, 0, 0, DT_REAL);
   NewMatrix(refrxr, 0, 0, DT_REAL);
   NewMatrix(refca, 0, 0, DT_COMPLEX);
   NewMatrix(refcxl, 0, 0, DT_COMPLEX);
   NewMatrix(refcxr, 0, 0, DT_COMPLEX);
   NewMatrix(ra, 0, 0, DT_REAL);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewMatrix(rxr1, 0, 0, DT_REAL);
   NewMatrix(rxl1, 0, 0, DT_REAL);
   NewMatrix(cxr1, 0, 0, DT_COMPLEX);
   NewMatrix(cxl1, 0, 0, DT_COMPLEX);
   NewMatrix(rxr2, 0, 0, DT_REAL);
   NewMatrix(rxl2, 0, 0, DT_REAL);
   NewMatrix(cxr2, 0, 0, DT_COMPLEX);
   NewMatrix(cxl2, 0, 0, DT_COMPLEX);
   threshold = sqr(maxn) * 100.0 * machineepsilon;
   Ok = true;
   for (mx = minn; mx <= maxn; mx++) {
   // Select random M/N in [1,MX] such that max(M,N) == MX
      m = 1 + randominteger(mx);
      n = 1 + randominteger(mx);
      if (randombool()) {
         m = mx;
      } else {
         n = mx;
      }
   // Initialize RefRA/RefCA by random matrices whose upper
   // and lower triangle submatrices are non-degenerate
   // well-conditioned matrices.
   //
   // Matrix size is 2Mx2M (four copies of same MxM matrix
   // to test different offsets)
      ae_matrix_set_length(&refra, 2 * m, 2 * m);
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            refra.xyR[i][j] = 0.1 * randommid();
         }
      }
      for (i = 0; i < m; i++) {
         refra.xyR[i][i] = (2 * randominteger(1) - 1) * (2 * m + randomreal());
      }
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            refra.xyR[i + m][j] = refra.xyR[i][j];
            refra.xyR[i][j + m] = refra.xyR[i][j];
            refra.xyR[i + m][j + m] = refra.xyR[i][j];
         }
      }
      ae_matrix_set_length(&refca, 2 * m, 2 * m);
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            refca.xyC[i][j] = complex_from_d(0.1 * randommid(), 0.1 * randommid());
         }
      }
      for (i = 0; i < m; i++) {
         refca.xyC[i][i] = complex_from_d((2 * randominteger(2) - 1) * (2 * m + randomreal()), (2 * randominteger(2) - 1) * (2 * m + randomreal()));
      }
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            refca.xyC[i + m][j] = refca.xyC[i][j];
            refca.xyC[i][j + m] = refca.xyC[i][j];
            refca.xyC[i + m][j + m] = refca.xyC[i][j];
         }
      }
   // Generate random XL/XR.
   //
   // XR is NxM matrix (matrix for 'Right' subroutines)
   // XL is MxN matrix (matrix for 'Left' subroutines)
      ae_matrix_set_length(&refrxr, n, m);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            refrxr.xyR[i][j] = randommid();
         }
      }
      ae_matrix_set_length(&refrxl, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            refrxl.xyR[i][j] = randommid();
         }
      }
      ae_matrix_set_length(&refcxr, n, m);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            refcxr.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
      ae_matrix_set_length(&refcxl, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            refcxl.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
   // test different types of operations, offsets, and so on...
   //
   // to avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      ae_matrix_set_length(&ra, 2 * m, 2 * m);
      ae_matrix_set_length(&rxr1, n, m);
      ae_matrix_set_length(&rxr2, n, m);
      ae_matrix_set_length(&rxl1, m, n);
      ae_matrix_set_length(&rxl2, m, n);
      ae_matrix_set_length(&ca, 2 * m, 2 * m);
      ae_matrix_set_length(&cxr1, n, m);
      ae_matrix_set_length(&cxr2, n, m);
      ae_matrix_set_length(&cxl1, m, n);
      ae_matrix_set_length(&cxl2, m, n);
      optype = randominteger(3);
      uppertype = randominteger(2);
      unittype = randominteger(2);
      xoffsi = randominteger(2);
      xoffsj = randominteger(2);
      aoffsitype = randominteger(2);
      aoffsjtype = randominteger(2);
      aoffsi = m * aoffsitype;
      aoffsj = m * aoffsjtype;
   // copy A, XR, XL (fill unused parts with random garbage)
      for (i = 0; i < 2 * m; i++) {
         for (j = 0; j < 2 * m; j++) {
            if (i >= aoffsi && i < aoffsi + m && j >= aoffsj && j < aoffsj + m) {
               ca.xyC[i][j] = refca.xyC[i][j];
               ra.xyR[i][j] = refra.xyR[i][j];
            } else {
               ca.xyC[i][j] = complex_from_d(randomreal());
               ra.xyR[i][j] = randomreal();
            }
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            if (i >= xoffsi && j >= xoffsj) {
               cxr1.xyC[i][j] = refcxr.xyC[i][j];
               cxr2.xyC[i][j] = refcxr.xyC[i][j];
               rxr1.xyR[i][j] = refrxr.xyR[i][j];
               rxr2.xyR[i][j] = refrxr.xyR[i][j];
            } else {
               cxr1.xyC[i][j] = complex_from_d(randomreal());
               cxr2.xyC[i][j] = cxr1.xyC[i][j];
               rxr1.xyR[i][j] = randomreal();
               rxr2.xyR[i][j] = rxr1.xyR[i][j];
            }
         }
      }
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            if (i >= xoffsi && j >= xoffsj) {
               cxl1.xyC[i][j] = refcxl.xyC[i][j];
               cxl2.xyC[i][j] = refcxl.xyC[i][j];
               rxl1.xyR[i][j] = refrxl.xyR[i][j];
               rxl2.xyR[i][j] = refrxl.xyR[i][j];
            } else {
               cxl1.xyC[i][j] = complex_from_d(randomreal());
               cxl2.xyC[i][j] = cxl1.xyC[i][j];
               rxl1.xyR[i][j] = randomreal();
               rxl2.xyR[i][j] = rxl1.xyR[i][j];
            }
         }
      }
   // Test CXR
      cmatrixrighttrsm(n - xoffsi, m - xoffsj, &ca, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &cxr1, xoffsi, xoffsj);
      testablasunit_refcmatrixrighttrsm(n - xoffsi, m - xoffsj, &ca, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &cxr2, xoffsi, xoffsj);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtC(cxr1.xyC[i][j], cxr2.xyC[i][j], threshold);
         }
      }
   // Test CXL
      cmatrixlefttrsm(m - xoffsi, n - xoffsj, &ca, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &cxl1, xoffsi, xoffsj);
      testablasunit_refcmatrixlefttrsm(m - xoffsi, n - xoffsj, &ca, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &cxl2, xoffsi, xoffsj);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            Ok = Ok && NearAtC(cxl1.xyC[i][j], cxl2.xyC[i][j], threshold);
         }
      }
      if (optype < 2) {
      // Test RXR
         rmatrixrighttrsm(n - xoffsi, m - xoffsj, &ra, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &rxr1, xoffsi, xoffsj);
         testablasunit_refrmatrixrighttrsm(n - xoffsi, m - xoffsj, &ra, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &rxr2, xoffsi, xoffsj);
         for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
               Ok = Ok && NearAtR(rxr1.xyR[i][j], rxr2.xyR[i][j], threshold);
            }
         }
      // Test RXL
         rmatrixlefttrsm(m - xoffsi, n - xoffsj, &ra, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &rxl1, xoffsi, xoffsj);
         testablasunit_refrmatrixlefttrsm(m - xoffsi, n - xoffsj, &ra, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &rxl2, xoffsi, xoffsj);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               Ok = Ok && NearAtR(rxl1.xyR[i][j], rxl2.xyR[i][j], threshold);
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Reference SYRK subroutine.
// ALGLIB Routine: Copyright 16.12.2009 by Sergey Bochkanov
static void testablasunit_refrmatrixsyrk(ae_int_t n, ae_int_t k, double alpha, RMatrix *a, ae_int_t ia, ae_int_t ja, ae_int_t optypea, double beta, RMatrix *c, ae_int_t ic, ae_int_t jc, bool isupper) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double vr;
   ae_frame_make(&_frame_block);
   NewMatrix(ae, 0, 0, DT_REAL);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (isupper? j >= i: j <= i) {
            if (beta == 0.0) {
               c->xyR[i + ic][j + jc] = 0.0;
            } else {
               c->xyR[i + ic][j + jc] *= beta;
            }
         }
      }
   }
   if (alpha == 0.0) {
      ae_frame_leave();
      return;
   }
   if (n * k > 0) {
      ae_matrix_set_length(&ae, n, k);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < k; j++) {
         if (optypea == 0) {
            ae.xyR[i][j] = a->xyR[ia + i][ja + j];
         }
         if (optypea == 1) {
            ae.xyR[i][j] = a->xyR[ia + j][ja + i];
         }
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         vr = 0.0;
         if (k > 0) {
            vr = ae_v_dotproduct(ae.xyR[i], 1, ae.xyR[j], 1, k);
         }
         vr *= alpha;
         if (isupper && j >= i) {
            c->xyR[ic + i][jc + j] += vr;
         }
         if (!isupper && j <= i) {
            c->xyR[ic + i][jc + j] += vr;
         }
      }
   }
   ae_frame_leave();
}

// Reference SYRK subroutine.
// ALGLIB Routine: Copyright 16.12.2009 by Sergey Bochkanov
static void testablasunit_refcmatrixherk(ae_int_t n, ae_int_t k, double alpha, CMatrix *a, ae_int_t ia, ae_int_t ja, ae_int_t optypea, double beta, CMatrix *c, ae_int_t ic, ae_int_t jc, bool isupper) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   complex vc;
   ae_frame_make(&_frame_block);
   NewMatrix(ae, 0, 0, DT_COMPLEX);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (isupper? j >= i: j <= i) {
            if (beta == 0.0) {
               c->xyC[i + ic][j + jc] = complex_from_i(0);
            } else {
               c->xyC[i + ic][j + jc] = ae_c_mul_d(c->xyC[i + ic][j + jc], beta);
            }
         }
      }
   }
   if (alpha == 0.0) {
      ae_frame_leave();
      return;
   }
   if (n * k > 0) {
      ae_matrix_set_length(&ae, n, k);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < k; j++) {
         if (optypea == 0) {
            ae.xyC[i][j] = a->xyC[ia + i][ja + j];
         }
         if (optypea == 2) {
            ae.xyC[i][j] = conj(a->xyC[ia + j][ja + i]);
         }
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         vc = complex_from_i(0);
         if (k > 0) {
            vc = ae_v_cdotproduct(ae.xyC[i], 1, "N", ae.xyC[j], 1, "Conj", k);
         }
         vc = ae_c_mul_d(vc, alpha);
         if (isupper && j >= i) {
            c->xyC[ic + i][jc + j] = ae_c_add(vc, c->xyC[ic + i][jc + j]);
         }
         if (!isupper && j <= i) {
            c->xyC[ic + i][jc + j] = ae_c_add(vc, c->xyC[ic + i][jc + j]);
         }
      }
   }
   ae_frame_leave();
}

// SYRK tests
//
// Returns False for passed test, True - for failed
static bool testablasunit_testsyrk(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t k;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t uppertype;
   ae_int_t xoffsi;
   ae_int_t xoffsj;
   ae_int_t aoffsitype;
   ae_int_t aoffsjtype;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t alphatype;
   ae_int_t betatype;
   double alpha;
   double beta;
   double threshold;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewMatrix(refrc, 0, 0, DT_REAL);
   NewMatrix(refca, 0, 0, DT_COMPLEX);
   NewMatrix(refcc, 0, 0, DT_COMPLEX);
   NewMatrix(ra1, 0, 0, DT_REAL);
   NewMatrix(ra2, 0, 0, DT_REAL);
   NewMatrix(ca1, 0, 0, DT_COMPLEX);
   NewMatrix(ca2, 0, 0, DT_COMPLEX);
   NewMatrix(rc, 0, 0, DT_REAL);
   NewMatrix(rct, 0, 0, DT_REAL);
   NewMatrix(cc, 0, 0, DT_COMPLEX);
   NewMatrix(cct, 0, 0, DT_COMPLEX);
   threshold = maxn * 100.0 * machineepsilon;
   Ok = true;
   for (mx = minn; mx <= maxn; mx++) {
   // Select random M/N in [1,MX] such that max(M,N) == MX
      k = 1 + randominteger(mx);
      n = 1 + randominteger(mx);
      if (randombool()) {
         k = mx;
      } else {
         n = mx;
      }
   // Initialize RefRA/RefCA by random Hermitian matrices,
   // RefRC/RefCC by random matrices
   //
   // RA/CA size is 2Nx2N (four copies of same NxN matrix
   // to test different offsets)
      ae_matrix_set_length(&refra, 2 * n, 2 * n);
      ae_matrix_set_length(&refca, 2 * n, 2 * n);
      for (i = 0; i < n; i++) {
         refra.xyR[i][i] = randommid();
         refca.xyC[i][i] = complex_from_d(randommid());
         for (j = i + 1; j < n; j++) {
            refra.xyR[i][j] = randommid();
            refca.xyC[i][j] = complex_from_d(randommid(), randommid());
            refra.xyR[j][i] = refra.xyR[i][j];
            refca.xyC[j][i] = conj(refca.xyC[i][j]);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            refra.xyR[i + n][j] = refra.xyR[i][j];
            refra.xyR[i][j + n] = refra.xyR[i][j];
            refra.xyR[i + n][j + n] = refra.xyR[i][j];
            refca.xyC[i + n][j] = refca.xyC[i][j];
            refca.xyC[i][j + n] = refca.xyC[i][j];
            refca.xyC[i + n][j + n] = refca.xyC[i][j];
         }
      }
      ae_matrix_set_length(&refrc, n, k);
      ae_matrix_set_length(&refcc, n, k);
      for (i = 0; i < n; i++) {
         for (j = 0; j < k; j++) {
            refrc.xyR[i][j] = randommid();
            refcc.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
   // test different types of operations, offsets, and so on...
   //
   // to avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      ae_matrix_set_length(&ra1, 2 * n, 2 * n);
      ae_matrix_set_length(&ra2, 2 * n, 2 * n);
      ae_matrix_set_length(&ca1, 2 * n, 2 * n);
      ae_matrix_set_length(&ca2, 2 * n, 2 * n);
      ae_matrix_set_length(&rc, n, k);
      ae_matrix_set_length(&rct, k, n);
      ae_matrix_set_length(&cc, n, k);
      ae_matrix_set_length(&cct, k, n);
      uppertype = randominteger(2);
      xoffsi = randominteger(2);
      xoffsj = randominteger(2);
      aoffsitype = randominteger(2);
      aoffsjtype = randominteger(2);
      alphatype = randominteger(2);
      betatype = randominteger(2);
      aoffsi = n * aoffsitype;
      aoffsj = n * aoffsjtype;
      alpha = alphatype * randommid();
      beta = betatype * randommid();
   // copy A, C (fill unused parts with random garbage)
      for (i = 0; i < 2 * n; i++) {
         for (j = 0; j < 2 * n; j++) {
            if (i >= aoffsi && i < aoffsi + n && j >= aoffsj && j < aoffsj + n) {
               ca1.xyC[i][j] = refca.xyC[i][j];
               ca2.xyC[i][j] = refca.xyC[i][j];
               ra1.xyR[i][j] = refra.xyR[i][j];
               ra2.xyR[i][j] = refra.xyR[i][j];
            } else {
               ca1.xyC[i][j] = complex_from_d(randomreal());
               ca2.xyC[i][j] = ca1.xyC[i][j];
               ra1.xyR[i][j] = randomreal();
               ra2.xyR[i][j] = ra1.xyR[i][j];
            }
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < k; j++) {
            if (i >= xoffsi && j >= xoffsj) {
               rc.xyR[i][j] = refrc.xyR[i][j];
               rct.xyR[j][i] = refrc.xyR[i][j];
               cc.xyC[i][j] = refcc.xyC[i][j];
               cct.xyC[j][i] = refcc.xyC[i][j];
            } else {
               rc.xyR[i][j] = randomreal();
               rct.xyR[j][i] = rc.xyR[i][j];
               cc.xyC[i][j] = complex_from_d(randomreal());
               cct.xyC[j][i] = cc.xyC[i][j]; //(@) Was cct.xyC[j][i] = cct.xyC[j][i];
            }
         }
      }
   // Test complex
   // Only one of transform types is selected and tested
      if (randombool()) {
         cmatrixherk(n - xoffsi, k - xoffsj, alpha, &cc, xoffsi, xoffsj, 0, beta, &ca1, aoffsi, aoffsj, uppertype == 0);
         testablasunit_refcmatrixherk(n - xoffsi, k - xoffsj, alpha, &cc, xoffsi, xoffsj, 0, beta, &ca2, aoffsi, aoffsj, uppertype == 0);
      } else {
         cmatrixherk(n - xoffsi, k - xoffsj, alpha, &cct, xoffsj, xoffsi, 2, beta, &ca1, aoffsi, aoffsj, uppertype == 0);
         testablasunit_refcmatrixherk(n - xoffsi, k - xoffsj, alpha, &cct, xoffsj, xoffsi, 2, beta, &ca2, aoffsi, aoffsj, uppertype == 0);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            Ok = Ok && NearAtC(ca1.xyC[i][j], ca2.xyC[i][j], threshold);
         }
      }
   // Test old version of HERK (named SYRK)
   // Only one of transform types is selected and tested
      if (randombool()) {
         cmatrixsyrk(n - xoffsi, k - xoffsj, alpha, &cc, xoffsi, xoffsj, 0, beta, &ca1, aoffsi, aoffsj, uppertype == 0);
         testablasunit_refcmatrixherk(n - xoffsi, k - xoffsj, alpha, &cc, xoffsi, xoffsj, 0, beta, &ca2, aoffsi, aoffsj, uppertype == 0);
      } else {
         cmatrixsyrk(n - xoffsi, k - xoffsj, alpha, &cct, xoffsj, xoffsi, 2, beta, &ca1, aoffsi, aoffsj, uppertype == 0);
         testablasunit_refcmatrixherk(n - xoffsi, k - xoffsj, alpha, &cct, xoffsj, xoffsi, 2, beta, &ca2, aoffsi, aoffsj, uppertype == 0);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            Ok = Ok && NearAtC(ca1.xyC[i][j], ca2.xyC[i][j], threshold);
         }
      }
   // Test real
   // Only one of transform types is selected and tested
      if (randombool()) {
         rmatrixsyrk(n - xoffsi, k - xoffsj, alpha, &rc, xoffsi, xoffsj, 0, beta, &ra1, aoffsi, aoffsj, uppertype == 0);
         testablasunit_refrmatrixsyrk(n - xoffsi, k - xoffsj, alpha, &rc, xoffsi, xoffsj, 0, beta, &ra2, aoffsi, aoffsj, uppertype == 0);
      } else {
         rmatrixsyrk(n - xoffsi, k - xoffsj, alpha, &rct, xoffsj, xoffsi, 1, beta, &ra1, aoffsi, aoffsj, uppertype == 0);
         testablasunit_refrmatrixsyrk(n - xoffsi, k - xoffsj, alpha, &rct, xoffsj, xoffsi, 1, beta, &ra2, aoffsi, aoffsj, uppertype == 0);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            Ok = Ok && NearAtR(ra1.xyR[i][j], ra2.xyR[i][j], threshold);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Reference GEMM,
// ALGLIB subroutine
static void testablasunit_refrmatrixgemm(ae_int_t m, ae_int_t n, ae_int_t k, double alpha, RMatrix *a, ae_int_t ia, ae_int_t ja, ae_int_t optypea, RMatrix *b, ae_int_t ib, ae_int_t jb, ae_int_t optypeb, double beta, RMatrix *c, ae_int_t ic, ae_int_t jc) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double vc;
   ae_frame_make(&_frame_block);
   NewMatrix(ae, 0, 0, DT_REAL);
   NewMatrix(be, 0, 0, DT_REAL);
   ae_matrix_set_length(&ae, m, k);
   for (i = 0; i < m; i++) {
      for (j = 0; j < k; j++) {
         if (optypea == 0) {
            ae.xyR[i][j] = a->xyR[ia + i][ja + j];
         }
         if (optypea == 1) {
            ae.xyR[i][j] = a->xyR[ia + j][ja + i];
         }
      }
   }
   ae_matrix_set_length(&be, k, n);
   for (i = 0; i < k; i++) {
      for (j = 0; j < n; j++) {
         if (optypeb == 0) {
            be.xyR[i][j] = b->xyR[ib + i][jb + j];
         }
         if (optypeb == 1) {
            be.xyR[i][j] = b->xyR[ib + j][jb + i];
         }
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         vc = ae_v_dotproduct(ae.xyR[i], 1, &be.xyR[0][j], be.stride, k);
         vc *= alpha;
         if (beta != 0.0) {
            vc += beta * c->xyR[ic + i][jc + j];
         }
         c->xyR[ic + i][jc + j] = vc;
      }
   }
   ae_frame_leave();
}

// Reference GEMM,
// ALGLIB subroutine
static void testablasunit_refcmatrixgemm(ae_int_t m, ae_int_t n, ae_int_t k, complex alpha, CMatrix *a, ae_int_t ia, ae_int_t ja, ae_int_t optypea, CMatrix *b, ae_int_t ib, ae_int_t jb, ae_int_t optypeb, complex beta, CMatrix *c, ae_int_t ic, ae_int_t jc) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   complex vc;
   ae_frame_make(&_frame_block);
   NewMatrix(ae, 0, 0, DT_COMPLEX);
   NewMatrix(be, 0, 0, DT_COMPLEX);
   ae_matrix_set_length(&ae, m, k);
   for (i = 0; i < m; i++) {
      for (j = 0; j < k; j++) {
         if (optypea == 0) {
            ae.xyC[i][j] = a->xyC[ia + i][ja + j];
         }
         if (optypea == 1) {
            ae.xyC[i][j] = a->xyC[ia + j][ja + i];
         }
         if (optypea == 2) {
            ae.xyC[i][j] = conj(a->xyC[ia + j][ja + i]);
         }
      }
   }
   ae_matrix_set_length(&be, k, n);
   for (i = 0; i < k; i++) {
      for (j = 0; j < n; j++) {
         if (optypeb == 0) {
            be.xyC[i][j] = b->xyC[ib + i][jb + j];
         }
         if (optypeb == 1) {
            be.xyC[i][j] = b->xyC[ib + j][jb + i];
         }
         if (optypeb == 2) {
            be.xyC[i][j] = conj(b->xyC[ib + j][jb + i]);
         }
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         vc = ae_v_cdotproduct(ae.xyC[i], 1, "N", &be.xyC[0][j], be.stride, "N", k);
         vc = ae_c_mul(alpha, vc);
         if (ae_c_neq_d(beta, 0.0)) {
            vc = ae_c_add(vc, ae_c_mul(beta, c->xyC[ic + i][jc + j]));
         }
         c->xyC[ic + i][jc + j] = vc;
      }
   }
   ae_frame_leave();
}

// GEMM tests
//
// Returns False for passed test, True - for failed
static bool testablasunit_testgemm(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t k;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t aoptype;
   ae_int_t aoptyper;
   ae_int_t boffsi;
   ae_int_t boffsj;
   ae_int_t boptype;
   ae_int_t boptyper;
   ae_int_t coffsi;
   ae_int_t coffsj;
   double alphar;
   double betar;
   complex alphac;
   complex betac;
   double threshold;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewMatrix(refrb, 0, 0, DT_REAL);
   NewMatrix(refrc, 0, 0, DT_REAL);
   NewMatrix(refca, 0, 0, DT_COMPLEX);
   NewMatrix(refcb, 0, 0, DT_COMPLEX);
   NewMatrix(refcc, 0, 0, DT_COMPLEX);
   NewMatrix(rc1, 0, 0, DT_REAL);
   NewMatrix(rc2, 0, 0, DT_REAL);
   NewMatrix(cc1, 0, 0, DT_COMPLEX);
   NewMatrix(cc2, 0, 0, DT_COMPLEX);
   threshold = maxn * 100.0 * machineepsilon;
   Ok = true;
   for (mx = minn; mx <= maxn; mx++) {
   // Select random M/N/K in [1,MX] such that max(M,N,K) == MX
      m = 1 + randominteger(mx);
      n = 1 + randominteger(mx);
      k = 1 + randominteger(mx);
      i = randominteger(3);
      if (i == 0) {
         m = mx;
      }
      if (i == 1) {
         n = mx;
      }
      if (i == 2) {
         k = mx;
      }
   // Initialize A/B/C by random matrices with size (MaxN+1)*(MaxN+1)
      ae_matrix_set_length(&refra, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refrb, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refrc, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refca, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refcb, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refcc, maxn + 1, maxn + 1);
      for (i = 0; i <= maxn; i++) {
         for (j = 0; j <= maxn; j++) {
            refra.xyR[i][j] = randommid();
            refrb.xyR[i][j] = randommid();
            refrc.xyR[i][j] = randommid();
            refca.xyC[i][j] = complex_from_d(randommid(), randommid());
            refcb.xyC[i][j] = complex_from_d(randommid(), randommid());
            refcc.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
   // test different types of operations, offsets, and so on...
   //
   // to avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      ae_matrix_set_length(&rc1, maxn + 1, maxn + 1);
      ae_matrix_set_length(&rc2, maxn + 1, maxn + 1);
      ae_matrix_set_length(&cc1, maxn + 1, maxn + 1);
      ae_matrix_set_length(&cc2, maxn + 1, maxn + 1);
      aoffsi = randominteger(2);
      aoffsj = randominteger(2);
      aoptype = randominteger(3);
      aoptyper = randominteger(2);
      boffsi = randominteger(2);
      boffsj = randominteger(2);
      boptype = randominteger(3);
      boptyper = randominteger(2);
      coffsi = randominteger(2);
      coffsj = randominteger(2);
      alphar = randominteger(2) * randommid();
      betar = randominteger(2) * randommid();
      if (randombool()) {
         alphac = complex_from_d(randommid(), randommid());
      } else {
         alphac = complex_from_i(0);
      }
      if (randombool()) {
         betac = complex_from_d(randommid(), randommid());
      } else {
         betac = complex_from_i(0);
      }
   // copy C
      for (i = 0; i <= maxn; i++) {
         for (j = 0; j <= maxn; j++) {
            rc1.xyR[i][j] = refrc.xyR[i][j];
            rc2.xyR[i][j] = refrc.xyR[i][j];
            cc1.xyC[i][j] = refcc.xyC[i][j];
            cc2.xyC[i][j] = refcc.xyC[i][j];
         }
      }
   // Test complex
      cmatrixgemm(m, n, k, alphac, &refca, aoffsi, aoffsj, aoptype, &refcb, boffsi, boffsj, boptype, betac, &cc1, coffsi, coffsj);
      testablasunit_refcmatrixgemm(m, n, k, alphac, &refca, aoffsi, aoffsj, aoptype, &refcb, boffsi, boffsj, boptype, betac, &cc2, coffsi, coffsj);
      for (i = 0; i <= maxn; i++) {
         for (j = 0; j <= maxn; j++) {
            Ok = Ok && NearAtC(cc1.xyC[i][j], cc2.xyC[i][j], threshold);
         }
      }
   // Test real
      rmatrixgemm(m, n, k, alphar, &refra, aoffsi, aoffsj, aoptyper, &refrb, boffsi, boffsj, boptyper, betar, &rc1, coffsi, coffsj);
      testablasunit_refrmatrixgemm(m, n, k, alphar, &refra, aoffsi, aoffsj, aoptyper, &refrb, boffsi, boffsj, boptyper, betar, &rc2, coffsi, coffsj);
      for (i = 0; i <= maxn; i++) {
         for (j = 0; j <= maxn; j++) {
            Ok = Ok && NearAtR(rc1.xyR[i][j], rc2.xyR[i][j], threshold);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// transpose tests
//
// Returns False for passed test, True - for failed
static bool testablasunit_testtrans(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t boffsi;
   ae_int_t boffsj;
   double v1;
   double v2;
   double threshold;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewMatrix(refrb, 0, 0, DT_REAL);
   NewMatrix(refca, 0, 0, DT_COMPLEX);
   NewMatrix(refcb, 0, 0, DT_COMPLEX);
   Ok = true;
   threshold = 1000.0 * machineepsilon;
   for (mx = minn; mx <= maxn; mx++) {
   // Select random M/N in [1,MX] such that max(M,N) == MX
   // Generate random V1 and V2 which are used to fill
   // RefRB/RefCB with control values.
      m = 1 + randominteger(mx);
      n = 1 + randominteger(mx);
      if (randominteger(2) == 0) {
         m = mx;
      } else {
         n = mx;
      }
      v1 = randomreal();
      v2 = randomreal();
   // Initialize A by random matrix with size (MaxN+1)*(MaxN+1)
   // Fill B with control values
      ae_matrix_set_length(&refra, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refrb, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refca, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refcb, maxn + 1, maxn + 1);
      for (i = 0; i <= maxn; i++) {
         for (j = 0; j <= maxn; j++) {
            refra.xyR[i][j] = randommid();
            refca.xyC[i][j] = complex_from_d(randommid(), randommid());
            refrb.xyR[i][j] = i * v1 + j * v2;
            refcb.xyC[i][j] = complex_from_d(i * v1 + j * v2);
         }
      }
   // test different offsets (zero or one)
   //
   // to avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      aoffsi = randominteger(2);
      aoffsj = randominteger(2);
      boffsi = randominteger(2);
      boffsj = randominteger(2);
      rmatrixtranspose(m, n, &refra, aoffsi, aoffsj, &refrb, boffsi, boffsj);
      for (i = 0; i <= maxn; i++) {
         for (j = 0; j <= maxn; j++) {
            if (i < boffsi || i >= boffsi + n || j < boffsj || j >= boffsj + m) {
               Ok = Ok && NearAtR(refrb.xyR[i][j], v1 * i + v2 * j, threshold);
            } else {
               Ok = Ok && NearAtR(refrb.xyR[i][j], refra.xyR[aoffsi + j - boffsj][aoffsj + i - boffsi], threshold);
            }
         }
      }
      cmatrixtranspose(m, n, &refca, aoffsi, aoffsj, &refcb, boffsi, boffsj);
      for (i = 0; i <= maxn; i++) {
         for (j = 0; j <= maxn; j++) {
            if (i < boffsi || i >= boffsi + n || j < boffsj || j >= boffsj + m) {
               Ok = Ok && NearAtCR(refcb.xyC[i][j], v1 * i + v2 * j, threshold);
            } else {
               Ok = Ok && NearAtC(refcb.xyC[i][j], refca.xyC[aoffsi + j - boffsj][aoffsj + i - boffsi], threshold);
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// rank-1tests
//
// Returns False for passed test, True - for failed
static bool testablasunit_testrank1(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t uoffs;
   ae_int_t voffs;
   double threshold;
   double ralpha;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewMatrix(refrb, 0, 0, DT_REAL);
   NewMatrix(refca, 0, 0, DT_COMPLEX);
   NewMatrix(refcb, 0, 0, DT_COMPLEX);
   NewVector(ru, 0, DT_REAL);
   NewVector(rv, 0, DT_REAL);
   NewVector(cu, 0, DT_COMPLEX);
   NewVector(cv, 0, DT_COMPLEX);
   Ok = true;
   threshold = 1000.0 * machineepsilon;
   for (mx = minn; mx <= maxn; mx++) {
   // Select random M/N in [1,MX] such that max(M,N) == MX
      m = 1 + randominteger(mx);
      n = 1 + randominteger(mx);
      if (randominteger(2) == 0) {
         m = mx;
      } else {
         n = mx;
      }
   // Initialize A by random matrix with size (MaxN+1)*(MaxN+1)
   // Fill B with control values
      ae_matrix_set_length(&refra, maxn + maxn, maxn + maxn);
      ae_matrix_set_length(&refrb, maxn + maxn, maxn + maxn);
      ae_matrix_set_length(&refca, maxn + maxn, maxn + maxn);
      ae_matrix_set_length(&refcb, maxn + maxn, maxn + maxn);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            refrb.xyR[i][j] = randommid();
            refcb.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
      ae_vector_set_length(&ru, 2 * m);
      ae_vector_set_length(&cu, 2 * m);
      for (i = 0; i < 2 * m; i++) {
         ru.xR[i] = randommid();
         cu.xC[i] = complex_from_d(randommid(), randommid());
      }
      ae_vector_set_length(&rv, 2 * n);
      ae_vector_set_length(&cv, 2 * n);
      for (i = 0; i < 2 * n; i++) {
         rv.xR[i] = randommid();
         cv.xC[i] = complex_from_d(randommid(), randommid());
      }
   // Generate random offsets of all operands and random coefficients.
      aoffsi = randominteger(maxn);
      aoffsj = randominteger(maxn);
      uoffs = randominteger(m);
      voffs = randominteger(n);
      ralpha = randomreal() - 0.5;
   // Test CMatrixRank1() and deprecated RMatrixRank1()
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            refca.xyC[i][j] = refcb.xyC[i][j];
         }
      }
      cmatrixrank1(m, n, &refca, aoffsi, aoffsj, &cu, uoffs, &cv, voffs);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            if (i < aoffsi || i >= aoffsi + m || j < aoffsj || j >= aoffsj + n) {
               Ok = Ok && NearAtC(refca.xyC[i][j], refcb.xyC[i][j], threshold);
            } else {
               Ok = Ok && NearAtC(refca.xyC[i][j], ae_c_add(refcb.xyC[i][j], ae_c_mul(cu.xC[i - aoffsi + uoffs], cv.xC[j - aoffsj + voffs])), threshold);
            }
         }
      }
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            refra.xyR[i][j] = refrb.xyR[i][j];
         }
      }
      rmatrixrank1(m, n, &refra, aoffsi, aoffsj, &ru, uoffs, &rv, voffs);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            if (i < aoffsi || i >= aoffsi + m || j < aoffsj || j >= aoffsj + n) {
               Ok = Ok && NearAtR(refra.xyR[i][j], refrb.xyR[i][j], threshold);
            } else {
               Ok = Ok && NearAtR(refra.xyR[i][j], refrb.xyR[i][j] + ru.xR[i - aoffsi + uoffs] * rv.xR[j - aoffsj + voffs], threshold);
            }
         }
      }
   // Test modern RMatrixGER()
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            refra.xyR[i][j] = refrb.xyR[i][j];
         }
      }
      rmatrixger(m, n, &refra, aoffsi, aoffsj, ralpha, &ru, uoffs, &rv, voffs);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            if (i < aoffsi || i >= aoffsi + m || j < aoffsj || j >= aoffsj + n) {
               Ok = Ok && fabs(refra.xyR[i][j] - refrb.xyR[i][j]) == 0.0;
            } else {
               Ok = Ok && NearAtR(refra.xyR[i][j], refrb.xyR[i][j] + ralpha * ru.xR[i - aoffsi + uoffs] * rv.xR[j - aoffsj + voffs], threshold);
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// MV tests
//
// Returns False for passed test, True - for failed
static bool testablasunit_testgemv(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t xoffs;
   ae_int_t yoffs;
   ae_int_t opca;
   ae_int_t opra;
   double threshold;
   double ralpha;
   double rbeta;
   double rv1;
   double rv2;
   complex cv1;
   complex cv2;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewMatrix(refca, 0, 0, DT_COMPLEX);
   NewVector(rx, 0, DT_REAL);
   NewVector(ry, 0, DT_REAL);
   NewVector(cx, 0, DT_COMPLEX);
   NewVector(cy, 0, DT_COMPLEX);
   Ok = true;
   threshold = 1000.0 * machineepsilon;
   for (mx = minn; mx <= maxn; mx++) {
   // Select random M/N in [1,MX] such that max(M,N) == MX
      m = 1 + randominteger(mx);
      n = 1 + randominteger(mx);
      if (randominteger(2) == 0) {
         m = mx;
      } else {
         n = mx;
      }
   // Initialize A by random matrix with size (MaxN+MaxN)*(MaxN+MaxN)
   // Initialize X by random vector with size (MaxN+MaxN)
   // Fill Y by control values
      ae_matrix_set_length(&refra, maxn + maxn, maxn + maxn);
      ae_matrix_set_length(&refca, maxn + maxn, maxn + maxn);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            refra.xyR[i][j] = randommid();
            refca.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
      ae_vector_set_length(&rx, 2 * maxn);
      ae_vector_set_length(&cx, 2 * maxn);
      ae_vector_set_length(&ry, 2 * maxn);
      ae_vector_set_length(&cy, 2 * maxn);
      for (i = 0; i < 2 * maxn; i++) {
         rx.xR[i] = randommid();
         cx.xC[i] = complex_from_d(randommid(), randommid());
      }
   // Select random offsets and operations.
   //
   // To avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      aoffsi = randominteger(maxn);
      aoffsj = randominteger(maxn);
      xoffs = randominteger(maxn);
      yoffs = randominteger(maxn);
      opca = randominteger(3);
      opra = randominteger(2);
      ralpha = (randomreal() - 0.5) * randominteger(2);
      rbeta = (randomreal() - 0.5) * randominteger(2);
   // Test CMatrixMV and deprecated RMatrixMV
      for (i = 0; i < 2 * maxn; i++) {
         cy.xC[i] = complex_from_i(i);
      }
      cmatrixmv(m, n, &refca, aoffsi, aoffsj, opca, &cx, xoffs, &cy, yoffs);
      for (i = 0; i < 2 * maxn; i++) {
         if (i < yoffs || i >= yoffs + m) {
            Ok = Ok && !ae_c_neq_d(cy.xC[i], i);
         } else {
            cv1 = cy.xC[i];
            cv2 = complex_from_d(0.0);
            if (opca == 0) {
               cv2 = ae_v_cdotproduct(&refca.xyC[aoffsi + i - yoffs][aoffsj], 1, "N", &cx.xC[xoffs], 1, "N", n);
            }
            if (opca == 1) {
               cv2 = ae_v_cdotproduct(&refca.xyC[aoffsi][aoffsj + i - yoffs], refca.stride, "N", &cx.xC[xoffs], 1, "N", n);
            }
            if (opca == 2) {
               cv2 = ae_v_cdotproduct(&refca.xyC[aoffsi][aoffsj + i - yoffs], refca.stride, "Conj", &cx.xC[xoffs], 1, "N", n);
            }
            Ok = Ok && NearAtC(cv1, cv2, threshold);
         }
      }
      for (i = 0; i < 2 * maxn; i++) {
         ry.xR[i] = (double)i;
      }
      rmatrixmv(m, n, &refra, aoffsi, aoffsj, opra, &rx, xoffs, &ry, yoffs);
      for (i = 0; i < 2 * maxn; i++) {
         if (i < yoffs || i >= yoffs + m) {
            Ok = Ok && ry.xR[i] == i;
         } else {
            rv1 = ry.xR[i];
            rv2 = 0.0;
            if (opra == 0) {
               rv2 = ae_v_dotproduct(&refra.xyR[aoffsi + i - yoffs][aoffsj], 1, &rx.xR[xoffs], 1, n);
            }
            if (opra == 1) {
               rv2 = ae_v_dotproduct(&refra.xyR[aoffsi][aoffsj + i - yoffs], refra.stride, &rx.xR[xoffs], 1, n);
            }
            Ok = Ok && NearAtR(rv1, rv2, threshold);
         }
      }
   // Test modern RMatrixGEMV()
      for (i = 0; i < 2 * maxn; i++) {
         ry.xR[i] = (double)i;
      }
      rmatrixgemv(m, n, ralpha, &refra, aoffsi, aoffsj, opra, &rx, xoffs, rbeta, &ry, yoffs);
      for (i = 0; i < 2 * maxn; i++) {
         if (i < yoffs || i >= yoffs + m) {
            Ok = Ok && ry.xR[i] == i;
         } else {
            rv1 = ry.xR[i];
            rv2 = 0.0;
            if (opra == 0) {
               rv2 = ae_v_dotproduct(&refra.xyR[aoffsi + i - yoffs][aoffsj], 1, &rx.xR[xoffs], 1, n);
            }
            if (opra == 1) {
               rv2 = ae_v_dotproduct(&refra.xyR[aoffsi][aoffsj + i - yoffs], refra.stride, &rx.xR[xoffs], 1, n);
            }
            rv2 = rbeta * i + ralpha * rv2;
            Ok = Ok && NearAtR(rv1, rv2, threshold);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Reference SYMV,
// ALGLIB subroutine
static void testablasunit_refrmatrixsymv(ae_int_t n, double alpha, RMatrix *a, ae_int_t ia, ae_int_t ja, bool isupper, RVector *x, ae_int_t ix, double beta, RVector *y, ae_int_t iy) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_frame_make(&_frame_block);
   NewMatrix(b, 0, 0, DT_REAL);
// Convert problem to traditional dense GEMV
   ae_matrix_set_length(&b, n, n);
   if (isupper) {
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            b.xyR[i][j] = a->xyR[ia + i][ja + j];
            b.xyR[j][i] = a->xyR[ia + i][ja + j];
         }
      }
   } else {
      for (i = 0; i < n; i++) {
         for (j = 0; j <= i; j++) {
            b.xyR[i][j] = a->xyR[ia + i][ja + j];
            b.xyR[j][i] = a->xyR[ia + i][ja + j];
         }
      }
   }
// Calculate result
   for (i = 0; i < n; i++) {
      v = beta * y->xR[iy + i];
      for (j = 0; j < n; j++) {
         v += alpha * b.xyR[i][j] * x->xR[ix + j];
      }
      y->xR[iy + i] = v;
   }
   ae_frame_leave();
}

// Reference SYVMV,
// ALGLIB subroutine
static double testablasunit_refrmatrixsyvmv(ae_int_t n, RMatrix *a, ae_int_t ia, ae_int_t ja, bool isupper, RVector *x, ae_int_t ix) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double result;
   ae_frame_make(&_frame_block);
   NewMatrix(b, 0, 0, DT_REAL);
// Convert problem to traditional dense GEMV
   ae_matrix_set_length(&b, n, n);
   if (isupper) {
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            b.xyR[i][j] = a->xyR[ia + i][ja + j];
            b.xyR[j][i] = a->xyR[ia + i][ja + j];
         }
      }
   } else {
      for (i = 0; i < n; i++) {
         for (j = 0; j <= i; j++) {
            b.xyR[i][j] = a->xyR[ia + i][ja + j];
            b.xyR[j][i] = a->xyR[ia + i][ja + j];
         }
      }
   }
// Calculate result
   result = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         result += x->xR[ix + i] * b.xyR[i][j] * x->xR[ix + j];
      }
   }
   ae_frame_leave();
   return result;
}

// SYMV/SYVMV tests
static bool testablasunit_testsymv(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t xoffs;
   ae_int_t yoffs;
   bool isuppera;
   double threshold;
   double ralpha;
   double rbeta;
   double rv1;
   double rv2;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewVector(rx, 0, DT_REAL);
   NewVector(ry, 0, DT_REAL);
   NewVector(rz, 0, DT_REAL);
   threshold = 1000.0 * machineepsilon;
   for (n = minn; n <= maxn; n++) {
   // Initialize A by random matrix with size (MaxN+MaxN)*(MaxN+MaxN)
   // Initialize X by random vector with size (MaxN+MaxN)
   // Fill Y by control values
      ae_matrix_set_length(&refra, maxn + maxn, maxn + maxn);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            refra.xyR[i][j] = randommid();
         }
      }
      ae_vector_set_length(&rx, 2 * maxn);
      ae_vector_set_length(&ry, 2 * maxn);
      ae_vector_set_length(&rz, 2 * maxn);
      for (i = 0; i < 2 * maxn; i++) {
         rx.xR[i] = randommid();
      }
   // Select random offsets and operations.
   //
   // To avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      aoffsi = randominteger(maxn);
      aoffsj = randominteger(maxn);
      xoffs = randominteger(maxn);
      yoffs = randominteger(maxn);
      isuppera = randombool();
      ralpha = (randomreal() - 0.5) * randominteger(2);
      rbeta = (randomreal() - 0.5) * randominteger(2);
   // Test RMatrixSYMV()
      for (i = 0; i < 2 * maxn; i++) {
         ry.xR[i] = (double)i;
         rz.xR[i] = (double)i;
      }
      rmatrixsymv(n, ralpha, &refra, aoffsi, aoffsj, isuppera, &rx, xoffs, rbeta, &ry, yoffs);
      testablasunit_refrmatrixsymv(n, ralpha, &refra, aoffsi, aoffsj, isuppera, &rx, xoffs, rbeta, &rz, yoffs);
      for (i = 0; i < 2 * maxn; i++) {
         if (i < yoffs || i >= yoffs + n) {
            Ok = Ok && ry.xR[i] == i;
         } else {
            Ok = Ok && NearAtR(ry.xR[i], rz.xR[i], threshold * rmax3(fabs(ry.xR[i]), fabs(rz.xR[i]), 1.0));
         }
      }
   // Test RMatrixSYVMV()
      rv1 = rmatrixsyvmv(n, &refra, aoffsi, aoffsj, isuppera, &rx, xoffs, &ry);
      rv2 = testablasunit_refrmatrixsyvmv(n, &refra, aoffsi, aoffsj, isuppera, &rx, xoffs);
      Ok = Ok && NearAtR(rv1, rv2, threshold * rmax3(fabs(rv1), fabs(rv2), 1.0));
   }
   ae_frame_leave();
   return Ok;
}

// TRSV tests
static bool testablasunit_testtrsv(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t xoffs;
   bool isuppera;
   bool isunita;
   ae_int_t opa;
   double threshold;
   double v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewMatrix(ea, 0, 0, DT_REAL);
   NewVector(rx, 0, DT_REAL);
   NewVector(ry, 0, DT_REAL);
   for (n = minn; n <= maxn; n++) {
   // Decreased threshold because of ill-conditioning of randomly generated matrices
      threshold = 1.0E-6 * (1 + n);
   // Initialize A by random matrix with size (MaxN+MaxN)*(MaxN+MaxN)
   // Initialize X by sparse random vector with size (MaxN+MaxN) (sparsity is important to test some branches of algorithm)
   // Fill Y by control values
      ae_matrix_set_length(&refra, maxn + maxn, maxn + maxn);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            refra.xyR[i][j] = randommid();
         }
      }
      ae_vector_set_length(&rx, 2 * maxn);
      ae_vector_set_length(&ry, 2 * maxn);
      for (i = 0; i < 2 * maxn; i++) {
         rx.xR[i] = randommid() * randominteger(3);
      }
   // Select random offsets and operations.
   //
   // To avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
   //
   // NOTE: in order to improve conditioning properties we add 10*Identity
   //       to purported diagonal of A
      aoffsi = randominteger(maxn);
      aoffsj = randominteger(maxn);
      xoffs = randominteger(maxn);
      isuppera = randombool();
      isunita = randombool();
      opa = randominteger(2);
      for (i = 0; i < n; i++) {
         refra.xyR[aoffsi + i][aoffsj + i] += 10;
      }
   // Test RMatrixTRSV():
   // * check that elements of RX beyond [XOffs,XOffs+N-1] are unchanged
   // * calculate RX = TRSV(RX)
   // * extract effective A from RefRA to EA == array[N,N]
   // * compare product EA*RX, compare with copy of RX stored in RY
      for (i = 0; i < 2 * maxn; i++) {
         ry.xR[i] = rx.xR[i];
      }
      rmatrixtrsv(n, &refra, aoffsi, aoffsj, isuppera, isunita, opa, &rx, xoffs);
      for (i = 0; i < 2 * maxn; i++) {
         if (i < xoffs || i > xoffs + n - 1) {
            Ok = Ok && rx.xR[i] == ry.xR[i];
         }
      }
      ae_matrix_set_length(&ea, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            v = refra.xyR[aoffsi + i][aoffsj + j];
            if (isuppera? j < i: j > i) {
               v = 0.0;
            }
            if (isunita && i == j) {
               v = 1.0;
            }
            if (opa == 0) {
               ea.xyR[i][j] = v;
            } else {
               ea.xyR[j][i] = v;
            }
         }
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(ea.xyR[i], 1, &rx.xR[xoffs], 1, n);
         Ok = Ok && NearAtR(v, ry.xR[xoffs + i], threshold);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Special test.
static bool testablasunit_spectest() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t pass;
   ae_frame_make(&_frame_block);
   bool Ok = true;
   NewMatrix(emptyr2, 0, 0, DT_REAL);
   NewMatrix(emptyc2, 0, 0, DT_COMPLEX);
   NewMatrix(outputr2, 0, 0, DT_REAL);
   NewMatrix(outputc2, 0, 0, DT_COMPLEX);
// Test that SYRK, GEMM and TRSM does not reference empty argument at all.
//
// In order to perform this test we pass empty (unallocated) matrix
// with large offset; incorrect implementation will crash on such data.
   n = 128 + randominteger(65) - 32;
   ae_matrix_set_length(&outputr2, n, n);
   ae_matrix_set_length(&outputc2, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         outputr2.xyR[i][j] = 0.0;
         outputc2.xyC[i][j] = complex_from_i(0);
      }
   }
   for (pass = 0; pass <= 10; pass++) {
      rmatrixgemm(n, n, 0, 1.0, &emptyr2, 35345, 23453, randominteger(2), &emptyr2, 74764, 26845, randominteger(2), 1.0 + randominteger(2), &outputr2, 0, 0);
      rmatrixgemm(n, n, n, 0.0, &emptyr2, 35345, 23453, randominteger(2), &emptyr2, 74764, 26845, randominteger(2), 1.0 + randominteger(2), &outputr2, 0, 0);
      cmatrixgemm(n, n, 0, complex_from_d(1.0), &emptyc2, 35345, 23453, randominteger(3), &emptyc2, 74764, 26845, randominteger(3), complex_from_d(1.0 + randominteger(2)), &outputc2, 0, 0);
      cmatrixgemm(n, n, n, complex_from_d(0.0), &emptyc2, 35345, 23453, randominteger(3), &emptyc2, 74764, 26845, randominteger(3), complex_from_d(1.0 + randominteger(2)), &outputc2, 0, 0);
      rmatrixsyrk(n, 0, 1.0, &emptyr2, 54674, 34657, 2.0 * randominteger(2), 1.0 + randominteger(2), &outputr2, 0, 0, randombool());
      rmatrixsyrk(n, n, 0.0, &emptyr2, 54674, 34657, 2.0 * randominteger(2), 1.0 + randominteger(2), &outputr2, 0, 0, randombool());
      cmatrixherk(n, 0, 1.0, &emptyc2, 54674, 34657, 2.0 * randominteger(2), 1.0 + randominteger(2), &outputc2, 0, 0, randombool());
      cmatrixherk(n, n, 0.0, &emptyc2, 54674, 34657, 2.0 * randominteger(2), 1.0 + randominteger(2), &outputc2, 0, 0, randombool());
      rmatrixrighttrsm(0, 0, &emptyr2, 63463, 36345, randombool(), randombool(), randominteger(2), &outputr2, 0, 0);
      rmatrixlefttrsm(0, 0, &emptyr2, 63463, 36345, randombool(), randombool(), randominteger(2), &outputr2, 0, 0);
      cmatrixrighttrsm(0, 0, &emptyc2, 63463, 36345, randombool(), randombool(), randominteger(3), &outputc2, 0, 0);
      cmatrixlefttrsm(0, 0, &emptyc2, 63463, 36345, randombool(), randombool(), randominteger(3), &outputc2, 0, 0);
   }
   ae_frame_leave();
   return Ok;
}

// COPY tests
//
// Returns False for passed test, True - for failed
static bool testablasunit_testcopy(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t boffsi;
   ae_int_t boffsj;
   double threshold;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(ra, 0, 0, DT_REAL);
   NewMatrix(rb, 0, 0, DT_REAL);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewMatrix(cb, 0, 0, DT_COMPLEX);
   Ok = true;
   threshold = 1000.0 * machineepsilon;
   for (mx = minn; mx <= maxn; mx++) {
   // Select random M/N in [1,MX] such that max(M,N) == MX
      m = 1 + randominteger(mx);
      n = 1 + randominteger(mx);
      if (randominteger(2) == 0) {
         m = mx;
      } else {
         n = mx;
      }
   // Initialize A by random matrix with size (MaxN+MaxN)*(MaxN+MaxN)
   // Initialize X by random vector with size (MaxN+MaxN)
   // Fill Y by control values
      ae_matrix_set_length(&ra, maxn + maxn, maxn + maxn);
      ae_matrix_set_length(&ca, maxn + maxn, maxn + maxn);
      ae_matrix_set_length(&rb, maxn + maxn, maxn + maxn);
      ae_matrix_set_length(&cb, maxn + maxn, maxn + maxn);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            ra.xyR[i][j] = randommid();
            ca.xyC[i][j] = complex_from_d(randommid(), randommid());
            rb.xyR[i][j] = (double)(1 + 2 * i + 3 * j);
            cb.xyC[i][j] = complex_from_i(1 + 2 * i + 3 * j);
         }
      }
   // test different offsets (zero or one)
   //
   // to avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      aoffsi = randominteger(maxn);
      aoffsj = randominteger(maxn);
      boffsi = randominteger(maxn);
      boffsj = randominteger(maxn);
      cmatrixcopy(m, n, &ca, aoffsi, aoffsj, &cb, boffsi, boffsj);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            if (i < boffsi || i >= boffsi + m || j < boffsj || j >= boffsj + n) {
               Ok = Ok && !ae_c_neq_d(cb.xyC[i][j], 1 + 2 * i + 3 * j);
            } else {
               Ok = Ok && NearAtC(ca.xyC[aoffsi + i - boffsi][aoffsj + j - boffsj], cb.xyC[i][j], threshold);
            }
         }
      }
      rmatrixcopy(m, n, &ra, aoffsi, aoffsj, &rb, boffsi, boffsj);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            if (i < boffsi || i >= boffsi + m || j < boffsj || j >= boffsj + n) {
               Ok = Ok && rb.xyR[i][j] == 1 + 2 * i + 3 * j;
            } else {
               Ok = Ok && NearAtR(ra.xyR[aoffsi + i - boffsi][aoffsj + j - boffsj], rb.xyR[i][j], threshold);
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

static bool testablasunit_testreflections() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t m;
   ae_int_t maxmn;
   double tmp;
   double beta;
   double tau;
   double err;
   double mer;
   double mel;
   double meg;
   ae_int_t pass;
   ae_int_t passcount;
   double threshold;
   ae_int_t tasktype;
   double xscale;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(v, 0, DT_REAL);
   NewVector(work, 0, DT_REAL);
   NewMatrix(h, 0, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   passcount = 10;
   threshold = 100.0 * machineepsilon;
   mer = 0.0;
   mel = 0.0;
   meg = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= 10; n++) {
         for (m = 1; m <= 10; m++) {
         // Task
            n = 1 + randominteger(10);
            m = 1 + randominteger(10);
            maxmn = imax2(m, n);
         // Initialize
            ae_vector_set_length(&x, maxmn + 1);
            ae_vector_set_length(&v, maxmn + 1);
            ae_vector_set_length(&work, maxmn + 1);
            ae_matrix_set_length(&h, maxmn + 1, maxmn + 1);
            ae_matrix_set_length(&a, maxmn + 1, maxmn + 1);
            ae_matrix_set_length(&b, maxmn + 1, maxmn + 1);
            ae_matrix_set_length(&c, maxmn + 1, maxmn + 1);
         // GenerateReflection, three tasks are possible:
         // * random X
         // * zero X
         // * non-zero X[1], all other are zeros
         // * random X, near underflow scale
         // * random X, near overflow scale
            for (tasktype = 0; tasktype <= 4; tasktype++) {
               xscale = 1.0;
               if (tasktype == 0) {
                  for (i = 1; i <= n; i++) {
                     x.xR[i] = randommid();
                  }
               }
               if (tasktype == 1) {
                  for (i = 1; i <= n; i++) {
                     x.xR[i] = 0.0;
                  }
               }
               if (tasktype == 2) {
                  x.xR[1] = randommid();
                  for (i = 2; i <= n; i++) {
                     x.xR[i] = 0.0;
                  }
               }
               if (tasktype == 3) {
                  for (i = 1; i <= n; i++) {
                     x.xR[i] = (randominteger(21) - 10) * minrealnumber;
                  }
                  xscale = 10 * minrealnumber;
               }
               if (tasktype == 4) {
                  for (i = 1; i <= n; i++) {
                     x.xR[i] = randommid() * maxrealnumber;
                  }
                  xscale = maxrealnumber;
               }
               ae_v_move(&v.xR[1], 1, &x.xR[1], 1, n);
               generatereflection(&v, n, &tau);
               beta = v.xR[1];
               v.xR[1] = 1.0;
               for (i = 1; i <= n; i++) {
                  for (j = 1; j <= n; j++) {
                     if (i == j) {
                        h.xyR[i][j] = 1 - tau * v.xR[i] * v.xR[j];
                     } else {
                        h.xyR[i][j] = -tau * v.xR[i] * v.xR[j];
                     }
                  }
               }
               err = 0.0;
               for (i = 1; i <= n; i++) {
                  tmp = ae_v_dotproduct(&h.xyR[i][1], 1, &x.xR[1], 1, n);
                  if (i == 1) {
                     err = rmax2(err, fabs(tmp - beta));
                  } else {
                     err = rmax2(err, fabs(tmp));
                  }
               }
               meg = rmax2(meg, err / xscale);
            }
         // ApplyReflectionFromTheLeft
            for (i = 1; i <= m; i++) {
               x.xR[i] = randommid();
               v.xR[i] = x.xR[i];
            }
            for (i = 1; i <= m; i++) {
               for (j = 1; j <= n; j++) {
                  a.xyR[i][j] = randommid();
                  b.xyR[i][j] = a.xyR[i][j];
               }
            }
            generatereflection(&v, m, &tau);
            beta = v.xR[1];
            v.xR[1] = 1.0;
            applyreflectionfromtheleft(&b, tau, &v, 1, m, 1, n, &work);
            for (i = 1; i <= m; i++) {
               for (j = 1; j <= m; j++) {
                  if (i == j) {
                     h.xyR[i][j] = 1 - tau * v.xR[i] * v.xR[j];
                  } else {
                     h.xyR[i][j] = -tau * v.xR[i] * v.xR[j];
                  }
               }
            }
            for (i = 1; i <= m; i++) {
               for (j = 1; j <= n; j++) {
                  tmp = ae_v_dotproduct(&h.xyR[i][1], 1, &a.xyR[1][j], a.stride, m);
                  c.xyR[i][j] = tmp;
               }
            }
            err = 0.0;
            for (i = 1; i <= m; i++) {
               for (j = 1; j <= n; j++) {
                  err = rmax2(err, fabs(b.xyR[i][j] - c.xyR[i][j]));
               }
            }
            mel = rmax2(mel, err);
         // ApplyReflectionFromTheRight
            for (i = 1; i <= n; i++) {
               x.xR[i] = randommid();
               v.xR[i] = x.xR[i];
            }
            for (i = 1; i <= m; i++) {
               for (j = 1; j <= n; j++) {
                  a.xyR[i][j] = randommid();
                  b.xyR[i][j] = a.xyR[i][j];
               }
            }
            generatereflection(&v, n, &tau);
            beta = v.xR[1];
            v.xR[1] = 1.0;
            applyreflectionfromtheright(&b, tau, &v, 1, m, 1, n, &work);
            for (i = 1; i <= n; i++) {
               for (j = 1; j <= n; j++) {
                  if (i == j) {
                     h.xyR[i][j] = 1 - tau * v.xR[i] * v.xR[j];
                  } else {
                     h.xyR[i][j] = -tau * v.xR[i] * v.xR[j];
                  }
               }
            }
            for (i = 1; i <= m; i++) {
               for (j = 1; j <= n; j++) {
                  tmp = ae_v_dotproduct(&a.xyR[i][1], 1, &h.xyR[1][j], h.stride, n);
                  c.xyR[i][j] = tmp;
               }
            }
            err = 0.0;
            for (i = 1; i <= m; i++) {
               for (j = 1; j <= n; j++) {
                  err = rmax2(err, fabs(b.xyR[i][j] - c.xyR[i][j]));
               }
            }
            mer = rmax2(mer, err);
         }
      }
   }
// Overflow crash test
   ae_vector_set_length(&x, 10 + 1);
   ae_vector_set_length(&v, 10 + 1);
   for (i = 1; i <= 10; i++) {
      v.xR[i] = maxrealnumber * 0.01 * randommid();
   }
   generatereflection(&v, 10, &tau);
// Result
   Ok = Ok && meg <= threshold && mel <= threshold && mer <= threshold;
   ae_frame_leave();
   return Ok;
}

bool testablas() {
   ae_frame _frame_block;
   ae_int_t n0;
   ae_int_t n1;
   bool trsmOk;
   bool syrkOk;
   bool gemmOk;
   bool transOk;
   bool rank1Ok;
   bool gemvOk;
   bool symvOk;
   bool trsvOk;
   bool reflOk;
   bool copyOk;
   bool specOk;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(ra, 0, 0, DT_REAL);
   trsmOk = true;
   syrkOk = true;
   gemmOk = true;
   transOk = true;
   rank1Ok = true;
   gemvOk = true;
   symvOk = true;
   trsvOk = true;
   reflOk = true;
   copyOk = true;
   Ok = true;
   specOk = true;
   specOk = specOk && testablasunit_spectest();
   trsmOk = trsmOk && testablasunit_testtrsm(1, 3 * matrixtilesizea() + 1);
   syrkOk = syrkOk && testablasunit_testsyrk(1, 3 * matrixtilesizea() + 1);
   gemmOk = gemmOk && testablasunit_testgemm(1, 3 * matrixtilesizea() + 1);
   transOk = transOk && testablasunit_testtrans(1, 3 * matrixtilesizea() + 1);
   rank1Ok = rank1Ok && testablasunit_testrank1(1, 3 * matrixtilesizea() + 1);
   gemvOk = gemvOk && testablasunit_testgemv(1, 3 * matrixtilesizea() + 1);
   copyOk = copyOk && testablasunit_testcopy(1, 3 * matrixtilesizea() + 1);
   symvOk = symvOk && testablasunit_testsymv(1, 3 * matrixtilesizea() + 1);
   trsvOk = trsvOk && testablasunit_testtrsv(1, 3 * matrixtilesizea() + 1);
   reflOk = reflOk && testablasunit_testreflections();
   n0 = 6 * matrixtilesizeb();
   n1 = 6 * matrixtilesizeb();
   gemmOk = gemmOk && testablasunit_testgemm(n0, n1);
   trsmOk = trsmOk && testablasunit_testtrsm(n0, n1);
   syrkOk = syrkOk && testablasunit_testsyrk(n0, n1);
// The final report.
   Ok = trsmOk && syrkOk && gemmOk && transOk && rank1Ok && gemvOk && symvOk && trsvOk && reflOk && copyOk && specOk;
   if (!Ok || !silent) {
      printf("ABLAS Tests\n");
      printf("Level 3 Functions:\n");
      printf("* TRSM:                                   %s\n", trsmOk? "Ok": "Failed");
      printf("* SYRK:                                   %s\n", syrkOk? "Ok": "Failed");
      printf("* GEMM:                                   %s\n", gemmOk? "Ok": "Failed");
      printf("Level 2 Functions:\n");
      printf("* Transpose:                              %s\n", transOk? "Ok": "Failed");
      printf("* Rank 1:                                 %s\n", rank1Ok? "Ok": "Failed");
      printf("* GEMV:                                   %s\n", gemvOk? "Ok": "Failed");
      printf("* SYMV/SYVMV:                             %s\n", symvOk? "Ok": "Failed");
      printf("* TRSV:                                   %s\n", trsvOk? "Ok": "Failed");
      printf("* Reflection:                             %s\n", reflOk? "Ok": "Failed");
      printf("* Copy:                                   %s\n", copyOk? "Ok": "Failed");
      printf("Special Tests:                            %s\n", specOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === hblas testing unit ===
bool testhblas() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t i2;
   bool Ok;
   double mverr;
   double threshold;
   complex alpha;
   complex v;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(ua, 0, 0, DT_COMPLEX);
   NewMatrix(la, 0, 0, DT_COMPLEX);
   NewVector(x, 0, DT_COMPLEX);
   NewVector(y1, 0, DT_COMPLEX);
   NewVector(y2, 0, DT_COMPLEX);
   NewVector(y3, 0, DT_COMPLEX);
   mverr = 0.0;
   Ok = true;
   maxn = 10;
   threshold = 1000.0 * machineepsilon;
// Test MV
   for (n = 2; n <= maxn; n++) {
      ae_matrix_set_length(&a, n + 1, n + 1);
      ae_matrix_set_length(&ua, n + 1, n + 1);
      ae_matrix_set_length(&la, n + 1, n + 1);
      ae_vector_set_length(&x, n + 1);
      ae_vector_set_length(&y1, n + 1);
      ae_vector_set_length(&y2, n + 1);
      ae_vector_set_length(&y3, n + 1);
   // fill A, UA, LA
      for (i = 1; i <= n; i++) {
         a.xyC[i][i] = complex_from_d(randommid());
         for (j = i + 1; j <= n; j++) {
            a.xyC[i][j] = complex_from_d(randommid(), randommid());
            a.xyC[j][i] = conj(a.xyC[i][j]);
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= n; j++) {
            ua.xyC[i][j] = complex_from_i(0);
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = i; j <= n; j++) {
            ua.xyC[i][j] = a.xyC[i][j];
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= n; j++) {
            la.xyC[i][j] = complex_from_i(0);
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= i; j++) {
            la.xyC[i][j] = a.xyC[i][j];
         }
      }
   // test on different I1, I2
      for (i1 = 1; i1 <= n; i1++) {
         for (i2 = i1; i2 <= n; i2++) {
         // Fill X, choose Alpha
            for (i = 1; i <= i2 - i1 + 1; i++) {
               x.xC[i] = complex_from_d(randommid(), randommid());
            }
            alpha = complex_from_d(randommid(), randommid());
         // calculate A*x, UA*x, LA*x
            for (i = i1; i <= i2; i++) {
               v = ae_v_cdotproduct(&a.xyC[i][i1], 1, "N", &x.xC[1], 1, "N", i2 - i1 + 1);
               y1.xC[i - i1 + 1] = ae_c_mul(alpha, v);
            }
            hermitianmatrixvectormultiply(&ua, true, i1, i2, &x, alpha, &y2);
            hermitianmatrixvectormultiply(&la, false, i1, i2, &x, alpha, &y3);
         // Calculate error
            ae_v_csub(&y2.xC[1], 1, &y1.xC[1], 1, "N", i2 - i1 + 1);
            v = ae_v_cdotproduct(&y2.xC[1], 1, "N", &y2.xC[1], 1, "Conj", i2 - i1 + 1);
            mverr = rmax2(mverr, sqrt(abscomplex(v)));
            ae_v_csub(&y3.xC[1], 1, &y1.xC[1], 1, "N", i2 - i1 + 1);
            v = ae_v_cdotproduct(&y3.xC[1], 1, "N", &y3.xC[1], 1, "Conj", i2 - i1 + 1);
            mverr = rmax2(mverr, sqrt(abscomplex(v)));
         }
      }
   }
// The final report.
   Ok = mverr <= threshold;
   if (!Ok || !silent) {
      printf("Hermitian BLAS Test\n");
      printf("MV Error:                                 %5.3e\n", mverr);
      printf("Threshold:                                %5.3e\n", threshold);
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === creflections testing unit ===
bool testcreflections() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t m;
   ae_int_t maxmn;
   complex tmp;
   complex beta;
   complex tau;
   double err;
   double mer;
   double mel;
   double meg;
   ae_int_t pass;
   ae_int_t passcount;
   bool Ok;
   double threshold;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_COMPLEX);
   NewVector(v, 0, DT_COMPLEX);
   NewVector(work, 0, DT_COMPLEX);
   NewMatrix(h, 0, 0, DT_COMPLEX);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(b, 0, 0, DT_COMPLEX);
   NewMatrix(c, 0, 0, DT_COMPLEX);
   threshold = 1000.0 * machineepsilon;
   passcount = 1000;
   mer = 0.0;
   mel = 0.0;
   meg = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
   // Task
      n = 1 + randominteger(10);
      m = 1 + randominteger(10);
      maxmn = imax2(m, n);
   // Initialize
      ae_vector_set_length(&x, maxmn + 1);
      ae_vector_set_length(&v, maxmn + 1);
      ae_vector_set_length(&work, maxmn + 1);
      ae_matrix_set_length(&h, maxmn + 1, maxmn + 1);
      ae_matrix_set_length(&a, maxmn + 1, maxmn + 1);
      ae_matrix_set_length(&b, maxmn + 1, maxmn + 1);
      ae_matrix_set_length(&c, maxmn + 1, maxmn + 1);
   // GenerateReflection
      for (i = 1; i <= n; i++) {
         x.xC[i] = complex_from_d(randommid(), randommid());
         v.xC[i] = x.xC[i];
      }
      complexgeneratereflection(&v, n, &tau);
      beta = v.xC[1];
      v.xC[1] = complex_from_i(1);
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= n; j++) {
            if (i == j) {
               h.xyC[i][j] = ae_c_d_sub(1, ae_c_mul(ae_c_mul(tau, v.xC[i]), conj(v.xC[j])));
            } else {
               h.xyC[i][j] = ae_c_neg(ae_c_mul(ae_c_mul(tau, v.xC[i]), conj(v.xC[j])));
            }
         }
      }
      err = 0.0;
      for (i = 1; i <= n; i++) {
         tmp = ae_v_cdotproduct(&h.xyC[1][i], h.stride, "Conj", &x.xC[1], 1, "N", n);
         if (i == 1) {
            err = rmax2(err, abscomplex(ae_c_sub(tmp, beta)));
         } else {
            err = rmax2(err, abscomplex(tmp));
         }
      }
      err = rmax2(err, fabs(beta.y));
      meg = rmax2(meg, err);
   // ApplyReflectionFromTheLeft
      for (i = 1; i <= m; i++) {
         x.xC[i] = complex_from_d(randommid(), randommid());
         v.xC[i] = x.xC[i];
      }
      for (i = 1; i <= m; i++) {
         for (j = 1; j <= n; j++) {
            a.xyC[i][j] = complex_from_d(randommid(), randommid());
            b.xyC[i][j] = a.xyC[i][j];
         }
      }
      complexgeneratereflection(&v, m, &tau);
      beta = v.xC[1];
      v.xC[1] = complex_from_i(1);
      complexapplyreflectionfromtheleft(&b, tau, &v, 1, m, 1, n, &work);
      for (i = 1; i <= m; i++) {
         for (j = 1; j <= m; j++) {
            if (i == j) {
               h.xyC[i][j] = ae_c_d_sub(1, ae_c_mul(ae_c_mul(tau, v.xC[i]), conj(v.xC[j])));
            } else {
               h.xyC[i][j] = ae_c_neg(ae_c_mul(ae_c_mul(tau, v.xC[i]), conj(v.xC[j])));
            }
         }
      }
      for (i = 1; i <= m; i++) {
         for (j = 1; j <= n; j++) {
            tmp = ae_v_cdotproduct(&h.xyC[i][1], 1, "N", &a.xyC[1][j], a.stride, "N", m);
            c.xyC[i][j] = tmp;
         }
      }
      err = 0.0;
      for (i = 1; i <= m; i++) {
         for (j = 1; j <= n; j++) {
            err = rmax2(err, abscomplex(ae_c_sub(b.xyC[i][j], c.xyC[i][j])));
         }
      }
      mel = rmax2(mel, err);
   // ApplyReflectionFromTheRight
      for (i = 1; i <= n; i++) {
         x.xC[i] = complex_from_d(randommid());
         v.xC[i] = x.xC[i];
      }
      for (i = 1; i <= m; i++) {
         for (j = 1; j <= n; j++) {
            a.xyC[i][j] = complex_from_d(randommid());
            b.xyC[i][j] = a.xyC[i][j];
         }
      }
      complexgeneratereflection(&v, n, &tau);
      beta = v.xC[1];
      v.xC[1] = complex_from_i(1);
      complexapplyreflectionfromtheright(&b, tau, &v, 1, m, 1, n, &work);
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= n; j++) {
            if (i == j) {
               h.xyC[i][j] = ae_c_d_sub(1, ae_c_mul(ae_c_mul(tau, v.xC[i]), conj(v.xC[j])));
            } else {
               h.xyC[i][j] = ae_c_neg(ae_c_mul(ae_c_mul(tau, v.xC[i]), conj(v.xC[j])));
            }
         }
      }
      for (i = 1; i <= m; i++) {
         for (j = 1; j <= n; j++) {
            tmp = ae_v_cdotproduct(&a.xyC[i][1], 1, "N", &h.xyC[1][j], h.stride, "N", n);
            c.xyC[i][j] = tmp;
         }
      }
      err = 0.0;
      for (i = 1; i <= m; i++) {
         for (j = 1; j <= n; j++) {
            err = rmax2(err, abscomplex(ae_c_sub(b.xyC[i][j], c.xyC[i][j])));
         }
      }
      mer = rmax2(mer, err);
   }
// Overflow crash test
   ae_vector_set_length(&x, 10 + 1);
   ae_vector_set_length(&v, 10 + 1);
   for (i = 1; i <= 10; i++) {
      v.xC[i] = complex_from_d(maxrealnumber * 0.01 * randommid());
   }
   complexgeneratereflection(&v, 10, &tau);
// The final report.
   Ok = meg <= threshold && mel <= threshold && mer <= threshold;
   if (!Ok || !silent) {
      printf("Complex Reflections Tests\n");
      printf("Generate Error:                           %5.3e\n", meg);
      printf("Apply(L) Error:                           %5.3e\n", mel);
      printf("Apply(R) Error:                           %5.3e\n", mer);
      printf("Threshold:                                %5.3e\n", threshold);
      printf("Overflow Crash Test:                      Ok\n");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === sblas testing unit ===
bool testsblas() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t i2;
   bool Ok;
   double mverr;
   double threshold;
   double alpha;
   double v;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ua, 0, 0, DT_REAL);
   NewMatrix(la, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(y3, 0, DT_REAL);
   mverr = 0.0;
   Ok = true;
   maxn = 10;
   threshold = 1000.0 * machineepsilon;
// Test MV
   for (n = 2; n <= maxn; n++) {
      ae_matrix_set_length(&a, n + 1, n + 1);
      ae_matrix_set_length(&ua, n + 1, n + 1);
      ae_matrix_set_length(&la, n + 1, n + 1);
      ae_vector_set_length(&x, n + 1);
      ae_vector_set_length(&y1, n + 1);
      ae_vector_set_length(&y2, n + 1);
      ae_vector_set_length(&y3, n + 1);
   // fill A, UA, LA
      for (i = 1; i <= n; i++) {
         a.xyR[i][i] = randommid();
         for (j = i + 1; j <= n; j++) {
            a.xyR[i][j] = randommid();
            a.xyR[j][i] = a.xyR[i][j];
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= n; j++) {
            ua.xyR[i][j] = 0.0;
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = i; j <= n; j++) {
            ua.xyR[i][j] = a.xyR[i][j];
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= n; j++) {
            la.xyR[i][j] = 0.0;
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= i; j++) {
            la.xyR[i][j] = a.xyR[i][j];
         }
      }
   // test on different I1, I2
      for (i1 = 1; i1 <= n; i1++) {
         for (i2 = i1; i2 <= n; i2++) {
         // Fill X, choose Alpha
            for (i = 1; i <= i2 - i1 + 1; i++) {
               x.xR[i] = randommid();
            }
            alpha = randommid();
         // calculate A*x, UA*x, LA*x
            for (i = i1; i <= i2; i++) {
               v = ae_v_dotproduct(&a.xyR[i][i1], 1, &x.xR[1], 1, i2 - i1 + 1);
               y1.xR[i - i1 + 1] = alpha * v;
            }
            symmetricmatrixvectormultiply(&ua, true, i1, i2, &x, alpha, &y2);
            symmetricmatrixvectormultiply(&la, false, i1, i2, &x, alpha, &y3);
         // Calculate error
            ae_v_sub(&y2.xR[1], 1, &y1.xR[1], 1, i2 - i1 + 1);
            v = ae_v_dotproduct(&y2.xR[1], 1, &y2.xR[1], 1, i2 - i1 + 1);
            mverr = rmax2(mverr, sqrt(v));
            ae_v_sub(&y3.xR[1], 1, &y1.xR[1], 1, i2 - i1 + 1);
            v = ae_v_dotproduct(&y3.xR[1], 1, &y3.xR[1], 1, i2 - i1 + 1);
            mverr = rmax2(mverr, sqrt(v));
         }
      }
   }
// The final report.
   Ok = mverr <= threshold;
   if (!Ok || !silent) {
      printf("Symmetric BLAS Tests\n");
      printf("MV Error:                                 %5.3e\n", mverr);
      printf("Threshold:                                %5.3e\n", threshold);
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === ortfac testing unit ===
// Diff
static double testortfacunit_rmatrixdiff(RMatrix *a, RMatrix *b, ae_int_t m, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   double result;
   result = 0.0;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         result = rmax2(result, fabs(b->xyR[i][j] - a->xyR[i][j]));
      }
   }
   return result;
}

// Copy
static void testortfacunit_rmatrixmakeacopy(RMatrix *a, ae_int_t m, ae_int_t n, RMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyR[i][j] = a->xyR[i][j];
      }
   }
}

// Copy
static void testortfacunit_cmatrixmakeacopy(CMatrix *a, ae_int_t m, ae_int_t n, CMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyC[i][j] = a->xyC[i][j];
      }
   }
}

// Sparse fill
static void testortfacunit_rmatrixfillsparsea(RMatrix *a, ae_int_t m, ae_int_t n, double sparsity) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         if (randombool(sparsity)) {
            a->xyR[i][j] = 0.0;
         } else {
            a->xyR[i][j] = randommid();
         }
      }
   }
}

// Sparse fill
static void testortfacunit_cmatrixfillsparsea(CMatrix *a, ae_int_t m, ae_int_t n, double sparsity) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         if (randombool(sparsity)) {
            a->xyC[i][j] = complex_from_i(0);
         } else {
            a->xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
   }
}

// Matrix multiplication
static void testortfacunit_internalmatrixmatrixmultiply(RMatrix *a, ae_int_t ai1, ae_int_t ai2, ae_int_t aj1, ae_int_t aj2, bool transa, RMatrix *b, ae_int_t bi1, ae_int_t bi2, ae_int_t bj1, ae_int_t bj2, bool transb, RMatrix *c, ae_int_t ci1, ae_int_t ci2, ae_int_t cj1, ae_int_t cj2) {
   ae_frame _frame_block;
   ae_int_t arows;
   ae_int_t acols;
   ae_int_t brows;
   ae_int_t bcols;
   ae_int_t crows;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   ae_int_t r;
   double v;
   double beta;
   double alpha;
   ae_frame_make(&_frame_block);
   NewVector(work, 0, DT_REAL);
// Pre-setup
   k = imax2(ai2 - ai1 + 1, aj2 - aj1 + 1);
   k = imax2(k, bi2 - bi1 + 1);
   k = imax2(k, bj2 - bj1 + 1);
   ae_vector_set_length(&work, k + 1);
   beta = 0.0;
   alpha = 1.0;
// Setup
   if (!transa) {
      arows = ai2 - ai1 + 1;
      acols = aj2 - aj1 + 1;
   } else {
      arows = aj2 - aj1 + 1;
      acols = ai2 - ai1 + 1;
   }
   if (!transb) {
      brows = bi2 - bi1 + 1;
      bcols = bj2 - bj1 + 1;
   } else {
      brows = bj2 - bj1 + 1;
      bcols = bi2 - bi1 + 1;
   }
   ae_assert(acols == brows, "MatrixMatrixMultiply: incorrect matrix sizes!");
   if (arows <= 0 || acols <= 0 || brows <= 0 || bcols <= 0) {
      ae_frame_leave();
      return;
   }
   crows = arows;
// Test WORK
   i = imax2(arows, acols);
   i = imax2(brows, i);
   i = imax2(i, bcols);
   work.xR[1] = 0.0;
   work.xR[i] = 0.0;
// Prepare C
   if (beta == 0.0) {
      for (i = ci1; i <= ci2; i++) {
         for (j = cj1; j <= cj2; j++) {
            c->xyR[i][j] = 0.0;
         }
      }
   } else {
      for (i = ci1; i <= ci2; i++) {
         ae_v_muld(&c->xyR[i][cj1], 1, cj2 - cj1 + 1, beta);
      }
   }
// A*B
   if (!transa && !transb) {
      for (l = ai1; l <= ai2; l++) {
         for (r = bi1; r <= bi2; r++) {
            v = alpha * a->xyR[l][aj1 + r - bi1];
            k = ci1 + l - ai1;
            ae_v_addd(&c->xyR[k][cj1], 1, &b->xyR[r][bj1], 1, cj2 - cj1 + 1, v);
         }
      }
      ae_frame_leave();
      return;
   }
// A*B'
   if (!transa && transb) {
      if (arows * acols < brows * bcols) {
         for (r = bi1; r <= bi2; r++) {
            for (l = ai1; l <= ai2; l++) {
               v = ae_v_dotproduct(&a->xyR[l][aj1], 1, &b->xyR[r][bj1], 1, aj2 - aj1 + 1);
               c->xyR[ci1 + l - ai1][cj1 + r - bi1] += alpha * v;
            }
         }
         ae_frame_leave();
         return;
      } else {
         for (l = ai1; l <= ai2; l++) {
            for (r = bi1; r <= bi2; r++) {
               v = ae_v_dotproduct(&a->xyR[l][aj1], 1, &b->xyR[r][bj1], 1, aj2 - aj1 + 1);
               c->xyR[ci1 + l - ai1][cj1 + r - bi1] += alpha * v;
            }
         }
         ae_frame_leave();
         return;
      }
   }
// A'*B
   if (transa && !transb) {
      for (l = aj1; l <= aj2; l++) {
         for (r = bi1; r <= bi2; r++) {
            v = alpha * a->xyR[ai1 + r - bi1][l];
            k = ci1 + l - aj1;
            ae_v_addd(&c->xyR[k][cj1], 1, &b->xyR[r][bj1], 1, cj2 - cj1 + 1, v);
         }
      }
      ae_frame_leave();
      return;
   }
// A'*B'
   if (transa && transb) {
      if (arows * acols < brows * bcols) {
         for (r = bi1; r <= bi2; r++) {
            for (i = 1; i <= crows; i++) {
               work.xR[i] = 0.0;
            }
            for (l = ai1; l <= ai2; l++) {
               v = alpha * b->xyR[r][bj1 + l - ai1];
               k = cj1 + r - bi1;
               ae_v_addd(&work.xR[1], 1, &a->xyR[l][aj1], 1, crows, v);
            }
            ae_v_add(&c->xyR[ci1][k], c->stride, &work.xR[1], 1, ci2 - ci1 + 1);
         }
         ae_frame_leave();
         return;
      } else {
         for (l = aj1; l <= aj2; l++) {
            k = ai2 - ai1 + 1;
            ae_v_move(&work.xR[1], 1, &a->xyR[ai1][l], a->stride, k);
            for (r = bi1; r <= bi2; r++) {
               v = ae_v_dotproduct(&work.xR[1], 1, &b->xyR[r][bj1], 1, k);
               c->xyR[ci1 + l - aj1][cj1 + r - bi1] += alpha * v;
            }
         }
         ae_frame_leave();
         return;
      }
   }
   ae_frame_leave();
}

// Problem testing
static bool testortfacunit_testrqrproblem(RMatrix *a, ae_int_t m, ae_int_t n, double threshold) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(b, 0, 0, DT_REAL);
   NewVector(taub, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(r, 0, 0, DT_REAL);
   NewMatrix(q2, 0, 0, DT_REAL);
// Test decompose-and-unpack error
   testortfacunit_rmatrixmakeacopy(a, m, n, &b);
   rmatrixqr(&b, m, n, &taub);
   rmatrixqrunpackq(&b, m, n, &taub, m, &q);
   rmatrixqrunpackr(&b, m, n, &r);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(q.xyR[i], 1, &r.xyR[0][j], r.stride, m);
         Ok = Ok && NearAtR(v, a->xyR[i][j], threshold);
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < imin2(i, n - 1); j++) {
         Ok = Ok && r.xyR[i][j] == 0.0;
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(q.xyR[i], 1, q.xyR[j], 1, m);
         if (i == j) {
            v--;
         }
         Ok = Ok && SmallR(v, threshold);
      }
   }
// Test for other errors
   k = 1 + randominteger(m);
   rmatrixqrunpackq(&b, m, n, &taub, k, &q2);
   for (i = 0; i < m; i++) {
      for (j = 0; j < k; j++) {
         Ok = Ok && NearAtR(q2.xyR[i][j], q.xyR[i][j], 10.0 * machineepsilon);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Problem testing
static bool testortfacunit_testcqrproblem(CMatrix *a, ae_int_t m, ae_int_t n, double threshold) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   complex v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(b, 0, 0, DT_COMPLEX);
   NewVector(taub, 0, DT_COMPLEX);
   NewMatrix(q, 0, 0, DT_COMPLEX);
   NewMatrix(r, 0, 0, DT_COMPLEX);
   NewMatrix(q2, 0, 0, DT_COMPLEX);
// Test decompose-and-unpack error
   testortfacunit_cmatrixmakeacopy(a, m, n, &b);
   cmatrixqr(&b, m, n, &taub);
   cmatrixqrunpackq(&b, m, n, &taub, m, &q);
   cmatrixqrunpackr(&b, m, n, &r);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(q.xyC[i], 1, "N", &r.xyC[0][j], r.stride, "N", m);
         Ok = Ok && NearAtC(v, a->xyC[i][j], threshold);
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < imin2(i, n - 1); j++) {
         Ok = Ok && !ae_c_neq_d(r.xyC[i][j], 0.0);
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < m; j++) {
         v = ae_v_cdotproduct(q.xyC[i], 1, "N", q.xyC[j], 1, "Conj", m);
         if (i == j) {
            v = ae_c_sub_d(v, 1);
         }
         Ok = Ok && SmallC(v, threshold);
      }
   }
// Test for other errors
   k = 1 + randominteger(m);
   cmatrixqrunpackq(&b, m, n, &taub, k, &q2);
   for (i = 0; i < m; i++) {
      for (j = 0; j < k; j++) {
         Ok = Ok && NearAtC(q2.xyC[i][j], q.xyC[i][j], 10.0 * machineepsilon);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Problem testing
static bool testortfacunit_testrlqproblem(RMatrix *a, ae_int_t m, ae_int_t n, double threshold) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(b, 0, 0, DT_REAL);
   NewVector(taub, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(l, 0, 0, DT_REAL);
   NewMatrix(q2, 0, 0, DT_REAL);
// Test decompose-and-unpack error
   testortfacunit_rmatrixmakeacopy(a, m, n, &b);
   rmatrixlq(&b, m, n, &taub);
   rmatrixlqunpackq(&b, m, n, &taub, n, &q);
   rmatrixlqunpackl(&b, m, n, &l);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(l.xyR[i], 1, &q.xyR[0][j], q.stride, n);
         Ok = Ok && NearR(v, a->xyR[i][j], threshold);
      }
   }
   for (i = 0; i < m; i++) {
      for (j = imin2(i, n - 1) + 1; j < n; j++) {
         Ok = Ok && l.xyR[i][j] == 0.0;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(q.xyR[i], 1, q.xyR[j], 1, n);
         if (i == j) {
            v--;
         }
         Ok = Ok && SmallR(v, threshold);
      }
   }
// Test for other errors
   k = 1 + randominteger(n);
   rmatrixlqunpackq(&b, m, n, &taub, k, &q2);
   for (i = 0; i < k; i++) {
      for (j = 0; j < n; j++) {
         Ok = Ok && NearAtR(q2.xyR[i][j], q.xyR[i][j], 10.0 * machineepsilon);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Problem testing
static bool testortfacunit_testclqproblem(CMatrix *a, ae_int_t m, ae_int_t n, double threshold) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   complex v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(b, 0, 0, DT_COMPLEX);
   NewVector(taub, 0, DT_COMPLEX);
   NewMatrix(q, 0, 0, DT_COMPLEX);
   NewMatrix(l, 0, 0, DT_COMPLEX);
   NewMatrix(q2, 0, 0, DT_COMPLEX);
// Test decompose-and-unpack error
   testortfacunit_cmatrixmakeacopy(a, m, n, &b);
   cmatrixlq(&b, m, n, &taub);
   cmatrixlqunpackq(&b, m, n, &taub, n, &q);
   cmatrixlqunpackl(&b, m, n, &l);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(l.xyC[i], 1, "N", &q.xyC[0][j], q.stride, "N", n);
         Ok = Ok && NearC(v, a->xyC[i][j], threshold);
      }
   }
   for (i = 0; i < m; i++) {
      for (j = imin2(i, n - 1) + 1; j < n; j++) {
         Ok = Ok && !ae_c_neq_d(l.xyC[i][j], 0.0);
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(q.xyC[i], 1, "N", q.xyC[j], 1, "Conj", n);
         if (i == j) {
            v = ae_c_sub_d(v, 1);
         }
         Ok = Ok && SmallC(v, threshold);
      }
   }
// Test for other errors
   k = 1 + randominteger(n);
   cmatrixlqunpackq(&b, m, n, &taub, k, &q2);
   for (i = 0; i < k; i++) {
      for (j = 0; j < n; j++) {
         Ok = Ok && NearAtC(q2.xyC[i][j], q.xyC[i][j], 10.0 * machineepsilon);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Problem testing
static bool testortfacunit_testrbdproblem(RMatrix *a, ae_int_t m, ae_int_t n, double threshold) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   bool up;
   double v;
   ae_int_t mtsize;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(t, 0, 0, DT_REAL);
   NewMatrix(pt, 0, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(r, 0, 0, DT_REAL);
   NewMatrix(bd, 0, 0, DT_REAL);
   NewMatrix(x, 0, 0, DT_REAL);
   NewMatrix(r1, 0, 0, DT_REAL);
   NewMatrix(r2, 0, 0, DT_REAL);
   NewVector(taup, 0, DT_REAL);
   NewVector(tauq, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(e, 0, DT_REAL);
// Bidiagonal decomposition error
   testortfacunit_rmatrixmakeacopy(a, m, n, &t);
   rmatrixbd(&t, m, n, &tauq, &taup);
   rmatrixbdunpackq(&t, m, n, &tauq, m, &q);
   rmatrixbdunpackpt(&t, m, n, &taup, n, &pt);
   rmatrixbdunpackdiagonals(&t, m, n, &up, &d, &e);
   ae_matrix_set_length(&bd, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         bd.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < imin2(m, n); i++) {
      bd.xyR[i][i] = d.xR[i];
   }
   if (up) {
      for (i = 0; i < imin2(m, n) - 1; i++) {
         bd.xyR[i][i + 1] = e.xR[i];
      }
   } else {
      for (i = 0; i < imin2(m, n) - 1; i++) {
         bd.xyR[i + 1][i] = e.xR[i];
      }
   }
   ae_matrix_set_length(&r, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(q.xyR[i], 1, &bd.xyR[0][j], bd.stride, m);
         r.xyR[i][j] = v;
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(r.xyR[i], 1, &pt.xyR[0][j], pt.stride, n);
         Ok = Ok && NearAtR(v, a->xyR[i][j], threshold);
      }
   }
// Orthogonality test for Q/PT
   for (i = 0; i < m; i++) {
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&q.xyR[0][i], q.stride, &q.xyR[0][j], q.stride, m);
         if (i == j) {
            Ok = Ok && NearAtR(v, 1, threshold);
         } else {
            Ok = Ok && SmallAtR(v, threshold);
         }
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(pt.xyR[i], 1, pt.xyR[j], 1, n);
         if (i == j) {
            Ok = Ok && NearAtR(v, 1, threshold);
         } else {
            Ok = Ok && SmallAtR(v, threshold);
         }
      }
   }
// Partial unpacking test
   k = 1 + randominteger(m);
   rmatrixbdunpackq(&t, m, n, &tauq, k, &r);
   for (i = 0; i < m; i++) {
      for (j = 0; j < k; j++) {
         Ok = Ok && NearAtR(r.xyR[i][j], q.xyR[i][j], 10.0 * machineepsilon);
      }
   }
   k = 1 + randominteger(n);
   rmatrixbdunpackpt(&t, m, n, &taup, k, &r);
   for (i = 0; i < k; i++) {
      for (j = 0; j < n; j++) {
         Ok = Ok && NearAtR(r.xyR[i][j], pt.xyR[i][j], 10.0 * machineepsilon);
      }
   }
// Multiplication test
   ae_matrix_set_length(&x, imax2(m, n), imax2(m, n));
   ae_matrix_set_length(&r, imax2(m, n), imax2(m, n));
   ae_matrix_set_length(&r1, imax2(m, n), imax2(m, n));
   ae_matrix_set_length(&r2, imax2(m, n), imax2(m, n));
   for (i = 0; i < imax2(m, n); i++) {
      for (j = 0; j < imax2(m, n); j++) {
         x.xyR[i][j] = randommid();
      }
   }
   mtsize = 1 + randominteger(imax2(m, n));
   testortfacunit_rmatrixmakeacopy(&x, mtsize, m, &r);
   testortfacunit_internalmatrixmatrixmultiply(&r, 0, mtsize - 1, 0, m - 1, false, &q, 0, m - 1, 0, m - 1, false, &r1, 0, mtsize - 1, 0, m - 1);
   testortfacunit_rmatrixmakeacopy(&x, mtsize, m, &r2);
   rmatrixbdmultiplybyq(&t, m, n, &tauq, &r2, mtsize, m, true, false);
   Ok = Ok && testortfacunit_rmatrixdiff(&r1, &r2, mtsize, m) <= threshold;
   testortfacunit_rmatrixmakeacopy(&x, mtsize, m, &r);
   testortfacunit_internalmatrixmatrixmultiply(&r, 0, mtsize - 1, 0, m - 1, false, &q, 0, m - 1, 0, m - 1, true, &r1, 0, mtsize - 1, 0, m - 1);
   testortfacunit_rmatrixmakeacopy(&x, mtsize, m, &r2);
   rmatrixbdmultiplybyq(&t, m, n, &tauq, &r2, mtsize, m, true, true);
   Ok = Ok && testortfacunit_rmatrixdiff(&r1, &r2, mtsize, m) <= threshold;
   testortfacunit_rmatrixmakeacopy(&x, m, mtsize, &r);
   testortfacunit_internalmatrixmatrixmultiply(&q, 0, m - 1, 0, m - 1, false, &r, 0, m - 1, 0, mtsize - 1, false, &r1, 0, m - 1, 0, mtsize - 1);
   testortfacunit_rmatrixmakeacopy(&x, m, mtsize, &r2);
   rmatrixbdmultiplybyq(&t, m, n, &tauq, &r2, m, mtsize, false, false);
   Ok = Ok && testortfacunit_rmatrixdiff(&r1, &r2, m, mtsize) <= threshold;
   testortfacunit_rmatrixmakeacopy(&x, m, mtsize, &r);
   testortfacunit_internalmatrixmatrixmultiply(&q, 0, m - 1, 0, m - 1, true, &r, 0, m - 1, 0, mtsize - 1, false, &r1, 0, m - 1, 0, mtsize - 1);
   testortfacunit_rmatrixmakeacopy(&x, m, mtsize, &r2);
   rmatrixbdmultiplybyq(&t, m, n, &tauq, &r2, m, mtsize, false, true);
   Ok = Ok && testortfacunit_rmatrixdiff(&r1, &r2, m, mtsize) <= threshold;
   testortfacunit_rmatrixmakeacopy(&x, mtsize, n, &r);
   testortfacunit_internalmatrixmatrixmultiply(&r, 0, mtsize - 1, 0, n - 1, false, &pt, 0, n - 1, 0, n - 1, true, &r1, 0, mtsize - 1, 0, n - 1);
   testortfacunit_rmatrixmakeacopy(&x, mtsize, n, &r2);
   rmatrixbdmultiplybyp(&t, m, n, &taup, &r2, mtsize, n, true, false);
   Ok = Ok && testortfacunit_rmatrixdiff(&r1, &r2, mtsize, n) <= threshold;
   testortfacunit_rmatrixmakeacopy(&x, mtsize, n, &r);
   testortfacunit_internalmatrixmatrixmultiply(&r, 0, mtsize - 1, 0, n - 1, false, &pt, 0, n - 1, 0, n - 1, false, &r1, 0, mtsize - 1, 0, n - 1);
   testortfacunit_rmatrixmakeacopy(&x, mtsize, n, &r2);
   rmatrixbdmultiplybyp(&t, m, n, &taup, &r2, mtsize, n, true, true);
   Ok = Ok && testortfacunit_rmatrixdiff(&r1, &r2, mtsize, n) <= threshold;
   testortfacunit_rmatrixmakeacopy(&x, n, mtsize, &r);
   testortfacunit_internalmatrixmatrixmultiply(&pt, 0, n - 1, 0, n - 1, true, &r, 0, n - 1, 0, mtsize - 1, false, &r1, 0, n - 1, 0, mtsize - 1);
   testortfacunit_rmatrixmakeacopy(&x, n, mtsize, &r2);
   rmatrixbdmultiplybyp(&t, m, n, &taup, &r2, n, mtsize, false, false);
   Ok = Ok && testortfacunit_rmatrixdiff(&r1, &r2, n, mtsize) <= threshold;
   testortfacunit_rmatrixmakeacopy(&x, n, mtsize, &r);
   testortfacunit_internalmatrixmatrixmultiply(&pt, 0, n - 1, 0, n - 1, false, &r, 0, n - 1, 0, mtsize - 1, false, &r1, 0, n - 1, 0, mtsize - 1);
   testortfacunit_rmatrixmakeacopy(&x, n, mtsize, &r2);
   rmatrixbdmultiplybyp(&t, m, n, &taup, &r2, n, mtsize, false, true);
   Ok = Ok && testortfacunit_rmatrixdiff(&r1, &r2, n, mtsize) <= threshold;
   ae_frame_leave();
   return Ok;
}

// Problem testing
static bool testortfacunit_testrhessproblem(RMatrix *a, ae_int_t n, double threshold) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(b, 0, 0, DT_REAL);
   NewMatrix(h, 0, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(t1, 0, 0, DT_REAL);
   NewMatrix(t2, 0, 0, DT_REAL);
   NewVector(tau, 0, DT_REAL);
   testortfacunit_rmatrixmakeacopy(a, n, n, &b);
// Decomposition
   rmatrixhessenberg(&b, n, &tau);
   rmatrixhessenbergunpackq(&b, n, &tau, &q);
   rmatrixhessenbergunpackh(&b, n, &h);
// Matrix properties
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(&q.xyR[0][i], q.stride, &q.xyR[0][j], q.stride, n);
         if (i == j) {
            v--;
         }
         Ok = Ok && SmallAtR(v, threshold);
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < i - 1; j++) {
         Ok = Ok && h.xyR[i][j] == 0.0;
      }
   }
// Decomposition error
   ae_matrix_set_length(&t1, n, n);
   ae_matrix_set_length(&t2, n, n);
   testortfacunit_internalmatrixmatrixmultiply(&q, 0, n - 1, 0, n - 1, false, &h, 0, n - 1, 0, n - 1, false, &t1, 0, n - 1, 0, n - 1);
   testortfacunit_internalmatrixmatrixmultiply(&t1, 0, n - 1, 0, n - 1, false, &q, 0, n - 1, 0, n - 1, true, &t2, 0, n - 1, 0, n - 1);
   Ok = Ok && testortfacunit_rmatrixdiff(&t2, a, n, n) <= threshold;
   ae_frame_leave();
   return Ok;
}

// Tridiagonal tester
static bool testortfacunit_testrtdproblem(RMatrix *a, ae_int_t n, double threshold) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(ua, 0, 0, DT_REAL);
   NewMatrix(la, 0, 0, DT_REAL);
   NewMatrix(t, 0, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(t2, 0, 0, DT_REAL);
   NewMatrix(t3, 0, 0, DT_REAL);
   NewVector(tau, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(e, 0, DT_REAL);
   ae_matrix_set_length(&ua, n, n);
   ae_matrix_set_length(&la, n, n);
   ae_matrix_set_length(&t, n, n);
   ae_matrix_set_length(&q, n, n);
   ae_matrix_set_length(&t2, n, n);
   ae_matrix_set_length(&t3, n, n);
// fill
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         ua.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = i; j < n; j++) {
         ua.xyR[i][j] = a->xyR[i][j];
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         la.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j <= i; j++) {
         la.xyR[i][j] = a->xyR[i][j];
      }
   }
// Test 2tridiagonal: upper
   smatrixtd(&ua, n, true, &tau, &d, &e);
   smatrixtdunpackq(&ua, n, true, &tau, &q);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         t.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < n; i++) {
      t.xyR[i][i] = d.xR[i];
   }
   for (i = 0; i < n - 1; i++) {
      t.xyR[i][i + 1] = e.xR[i];
      t.xyR[i + 1][i] = e.xR[i];
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(&q.xyR[0][i], q.stride, &a->xyR[0][j], a->stride, n);
         t2.xyR[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(t2.xyR[i], 1, &q.xyR[0][j], q.stride, n);
         t3.xyR[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         Ok = Ok && NearAtR(t3.xyR[i][j], t.xyR[i][j], threshold);
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(q.xyR[i], 1, q.xyR[j], 1, n);
         if (i == j) {
            v--;
         }
         Ok = Ok && SmallAtR(v, threshold);
      }
   }
// Test 2tridiagonal: lower
   smatrixtd(&la, n, false, &tau, &d, &e);
   smatrixtdunpackq(&la, n, false, &tau, &q);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         t.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < n; i++) {
      t.xyR[i][i] = d.xR[i];
   }
   for (i = 0; i < n - 1; i++) {
      t.xyR[i][i + 1] = e.xR[i];
      t.xyR[i + 1][i] = e.xR[i];
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(&q.xyR[0][i], q.stride, &a->xyR[0][j], a->stride, n);
         t2.xyR[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(t2.xyR[i], 1, &q.xyR[0][j], q.stride, n);
         t3.xyR[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         Ok = Ok && NearAtR(t3.xyR[i][j], t.xyR[i][j], threshold);
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(q.xyR[i], 1, q.xyR[j], 1, n);
         if (i == j) {
            v--;
         }
         Ok = Ok && SmallAtR(v, threshold);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Hermitian problem tester
static bool testortfacunit_testctdproblem(CMatrix *a, ae_int_t n, double threshold) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   complex v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(ua, 0, 0, DT_COMPLEX);
   NewMatrix(la, 0, 0, DT_COMPLEX);
   NewMatrix(t, 0, 0, DT_COMPLEX);
   NewMatrix(q, 0, 0, DT_COMPLEX);
   NewMatrix(t2, 0, 0, DT_COMPLEX);
   NewMatrix(t3, 0, 0, DT_COMPLEX);
   NewVector(tau, 0, DT_COMPLEX);
   NewVector(d, 0, DT_REAL);
   NewVector(e, 0, DT_REAL);
   ae_matrix_set_length(&ua, n, n);
   ae_matrix_set_length(&la, n, n);
   ae_matrix_set_length(&t, n, n);
   ae_matrix_set_length(&q, n, n);
   ae_matrix_set_length(&t2, n, n);
   ae_matrix_set_length(&t3, n, n);
// fill
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         ua.xyC[i][j] = complex_from_i(0);
      }
   }
   for (i = 0; i < n; i++) {
      for (j = i; j < n; j++) {
         ua.xyC[i][j] = a->xyC[i][j];
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         la.xyC[i][j] = complex_from_i(0);
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j <= i; j++) {
         la.xyC[i][j] = a->xyC[i][j];
      }
   }
// Test 2tridiagonal: upper
   hmatrixtd(&ua, n, true, &tau, &d, &e);
   hmatrixtdunpackq(&ua, n, true, &tau, &q);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         t.xyC[i][j] = complex_from_i(0);
      }
   }
   for (i = 0; i < n; i++) {
      t.xyC[i][i] = complex_from_d(d.xR[i]);
   }
   for (i = 0; i < n - 1; i++) {
      t.xyC[i][i + 1] = complex_from_d(e.xR[i]);
      t.xyC[i + 1][i] = complex_from_d(e.xR[i]);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(&q.xyC[0][i], q.stride, "Conj", &a->xyC[0][j], a->stride, "N", n);
         t2.xyC[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(t2.xyC[i], 1, "N", &q.xyC[0][j], q.stride, "N", n);
         t3.xyC[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         Ok = Ok && NearAtC(t3.xyC[i][j], t.xyC[i][j], threshold);
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(q.xyC[i], 1, "N", q.xyC[j], 1, "Conj", n);
         if (i == j) {
            v = ae_c_sub_d(v, 1);
         }
         Ok = Ok && SmallAtC(v, threshold);
      }
   }
// Test 2tridiagonal: lower
   hmatrixtd(&la, n, false, &tau, &d, &e);
   hmatrixtdunpackq(&la, n, false, &tau, &q);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         t.xyC[i][j] = complex_from_i(0);
      }
   }
   for (i = 0; i < n; i++) {
      t.xyC[i][i] = complex_from_d(d.xR[i]);
   }
   for (i = 0; i < n - 1; i++) {
      t.xyC[i][i + 1] = complex_from_d(e.xR[i]);
      t.xyC[i + 1][i] = complex_from_d(e.xR[i]);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(&q.xyC[0][i], q.stride, "Conj", &a->xyC[0][j], a->stride, "N", n);
         t2.xyC[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(t2.xyC[i], 1, "N", &q.xyC[0][j], q.stride, "N", n);
         t3.xyC[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         Ok = Ok && NearAtC(t3.xyC[i][j], t.xyC[i][j], threshold);
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(q.xyC[i], 1, "N", q.xyC[j], 1, "Conj", n);
         if (i == j) {
            v = ae_c_sub_d(v, 1);
         }
         Ok = Ok && SmallAtC(v, threshold);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Main unittest subroutine
bool testortfac() {
   ae_frame _frame_block;
   double threshold;
   ae_int_t mx;
   ae_int_t m;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   bool rqrOk;
   bool rlqOk;
   bool cqrOk;
   bool clqOk;
   bool rbdOk;
   bool rhessOk;
   bool rtdOk;
   bool ctdOk;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(ra, 0, 0, DT_REAL);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   Ok = true;
   rqrOk = true;
   rlqOk = true;
   cqrOk = true;
   clqOk = true;
   rbdOk = true;
   rhessOk = true;
   rtdOk = true;
   ctdOk = true;
   threshold = 5.0 * 1000.0 * machineepsilon;
// Medium-scale problems with various sparseness profiles
   for (mx = 1; mx <= 3 * matrixtilesizea() + 1; mx++) {
   // Rectangular factorizations: QR, LQ, bidiagonal
   // Matrix types: zero, dense, sparse
      n = 1 + randominteger(mx);
      m = 1 + randominteger(mx);
      if (randombool()) {
         n = mx;
      } else {
         m = mx;
      }
      ae_matrix_set_length(&ra, m, n);
      ae_matrix_set_length(&ca, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            ra.xyR[i][j] = 0.0;
            ca.xyC[i][j] = complex_from_i(0);
         }
      }
      rqrOk = rqrOk && testortfacunit_testrqrproblem(&ra, m, n, threshold);
      rlqOk = rlqOk && testortfacunit_testrlqproblem(&ra, m, n, threshold);
      cqrOk = cqrOk && testortfacunit_testcqrproblem(&ca, m, n, threshold);
      clqOk = clqOk && testortfacunit_testclqproblem(&ca, m, n, threshold);
      rbdOk = rbdOk && testortfacunit_testrbdproblem(&ra, m, n, threshold);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            ra.xyR[i][j] = randommid();
            ca.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
      rqrOk = rqrOk && testortfacunit_testrqrproblem(&ra, m, n, threshold);
      rlqOk = rlqOk && testortfacunit_testrlqproblem(&ra, m, n, threshold);
      cqrOk = cqrOk && testortfacunit_testcqrproblem(&ca, m, n, threshold);
      clqOk = clqOk && testortfacunit_testclqproblem(&ca, m, n, threshold);
      rbdOk = rbdOk && testortfacunit_testrbdproblem(&ra, m, n, threshold);
      testortfacunit_rmatrixfillsparsea(&ra, m, n, 0.95);
      testortfacunit_cmatrixfillsparsea(&ca, m, n, 0.95);
      rqrOk = rqrOk && testortfacunit_testrqrproblem(&ra, m, n, threshold);
      rlqOk = rlqOk && testortfacunit_testrlqproblem(&ra, m, n, threshold);
      cqrOk = cqrOk && testortfacunit_testcqrproblem(&ca, m, n, threshold);
      clqOk = clqOk && testortfacunit_testclqproblem(&ca, m, n, threshold);
      rbdOk = rbdOk && testortfacunit_testrbdproblem(&ra, m, n, threshold);
   // Square factorizations: Hessenberg, tridiagonal
   // Matrix types: zero, dense, sparse
      ae_matrix_set_length(&ra, mx, mx);
      ae_matrix_set_length(&ca, mx, mx);
      for (i = 0; i < mx; i++) {
         for (j = 0; j < mx; j++) {
            ra.xyR[i][j] = 0.0;
            ca.xyC[i][j] = complex_from_i(0);
         }
      }
      rhessOk = rhessOk && testortfacunit_testrhessproblem(&ra, mx, threshold);
      for (i = 0; i < mx; i++) {
         for (j = 0; j < mx; j++) {
            ra.xyR[i][j] = randommid();
            ca.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
      rhessOk = rhessOk && testortfacunit_testrhessproblem(&ra, mx, threshold);
      testortfacunit_rmatrixfillsparsea(&ra, mx, mx, 0.95);
      testortfacunit_cmatrixfillsparsea(&ca, mx, mx, 0.95);
      rhessOk = rhessOk && testortfacunit_testrhessproblem(&ra, mx, threshold);
   // Symetric factorizations: tridiagonal
   // Matrix types: zero, dense, sparse
      ae_matrix_set_length(&ra, mx, mx);
      ae_matrix_set_length(&ca, mx, mx);
      for (i = 0; i < mx; i++) {
         for (j = 0; j < mx; j++) {
            ra.xyR[i][j] = 0.0;
            ca.xyC[i][j] = complex_from_i(0);
         }
      }
      rtdOk = rtdOk && testortfacunit_testrtdproblem(&ra, mx, threshold);
      ctdOk = ctdOk && testortfacunit_testctdproblem(&ca, mx, threshold);
      for (i = 0; i < mx; i++) {
         for (j = i; j < mx; j++) {
            ra.xyR[i][j] = randommid();
            ca.xyC[i][j] = complex_from_d(randommid(), randommid());
            ra.xyR[j][i] = ra.xyR[i][j];
            ca.xyC[j][i] = conj(ca.xyC[i][j]);
         }
      }
      for (i = 0; i < mx; i++) {
         ca.xyC[i][i] = complex_from_d(randommid());
      }
      rtdOk = rtdOk && testortfacunit_testrtdproblem(&ra, mx, threshold);
      ctdOk = ctdOk && testortfacunit_testctdproblem(&ca, mx, threshold);
      testortfacunit_rmatrixfillsparsea(&ra, mx, mx, 0.95);
      testortfacunit_cmatrixfillsparsea(&ca, mx, mx, 0.95);
      for (i = 0; i < mx; i++) {
         for (j = i; j < mx; j++) {
            ra.xyR[j][i] = ra.xyR[i][j];
            ca.xyC[j][i] = conj(ca.xyC[i][j]);
         }
      }
      for (i = 0; i < mx; i++) {
         ca.xyC[i][i] = complex_from_d(randommid());
      }
      rtdOk = rtdOk && testortfacunit_testrtdproblem(&ra, mx, threshold);
      ctdOk = ctdOk && testortfacunit_testctdproblem(&ca, mx, threshold);
   }
// Large-scale tests
   for (mx = 4 * matrixtilesizeb(); mx <= 4 * matrixtilesizeb(); mx++) {
   // Rectangular factorizations: QR, LQ, bidiagonal
   // Matrix types: dense
      n = 1 + randominteger(mx);
      m = 1 + randominteger(mx);
      if (randombool()) {
         n = mx;
      } else {
         m = mx;
      }
      ae_matrix_set_length(&ra, m, n);
      ae_matrix_set_length(&ca, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            ra.xyR[i][j] = randommid();
            ca.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
      rqrOk = rqrOk && testortfacunit_testrqrproblem(&ra, m, n, threshold);
      rlqOk = rlqOk && testortfacunit_testrlqproblem(&ra, m, n, threshold);
      cqrOk = cqrOk && testortfacunit_testcqrproblem(&ca, m, n, threshold);
      clqOk = clqOk && testortfacunit_testclqproblem(&ca, m, n, threshold);
      rbdOk = rbdOk && testortfacunit_testrbdproblem(&ra, m, n, threshold);
   // Square factorizations: Hessenberg, tridiagonal
   // Matrix types: dense
      ae_matrix_set_length(&ra, mx, mx);
      ae_matrix_set_length(&ca, mx, mx);
      for (i = 0; i < mx; i++) {
         for (j = 0; j < mx; j++) {
            ra.xyR[i][j] = randommid();
            ca.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
      rhessOk = rhessOk && testortfacunit_testrhessproblem(&ra, mx, threshold);
   // Symetric factorizations: tridiagonal
   // Matrix types: dense
      ae_matrix_set_length(&ra, mx, mx);
      ae_matrix_set_length(&ca, mx, mx);
      for (i = 0; i < mx; i++) {
         for (j = i; j < mx; j++) {
            ra.xyR[i][j] = randommid();
            ca.xyC[i][j] = complex_from_d(randommid(), randommid());
            ra.xyR[j][i] = ra.xyR[i][j];
            ca.xyC[j][i] = conj(ca.xyC[i][j]);
         }
      }
      for (i = 0; i < mx; i++) {
         ca.xyC[i][i] = complex_from_d(randommid());
      }
      rtdOk = rtdOk && testortfacunit_testrtdproblem(&ra, mx, threshold);
      ctdOk = ctdOk && testortfacunit_testctdproblem(&ca, mx, threshold);
   }
// The final report.
   Ok = rqrOk && rlqOk && cqrOk && clqOk && rbdOk && rhessOk && rtdOk && ctdOk;
   if (!Ok || !silent) {
      printf("OrtFac Unit Tests\n");
      printf("RQR Errors:                               %s\n", rqrOk? "Ok": "Failed");
      printf("RLQ Errors:                               %s\n", rlqOk? "Ok": "Failed");
      printf("CQR Errors:                               %s\n", cqrOk? "Ok": "Failed");
      printf("CLQ Errors:                               %s\n", clqOk? "Ok": "Failed");
      printf("RBD Errors:                               %s\n", rbdOk? "Ok": "Failed");
      printf("RHESS Errors:                             %s\n", rhessOk? "Ok": "Failed");
      printf("RTD Errors:                               %s\n", rtdOk? "Ok": "Failed");
      printf("CTD Errors:                               %s\n", ctdOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === matgen testing unit ===
static const ae_int_t testmatgenunit_maxsvditerations = 60;

// Unsets 2D array.
static void testmatgenunit_unset2d(RMatrix *a) {
   ae_matrix_set_length(a, 0 + 1, 0 + 1);
   a->xyR[0][0] = randommid();
}

// Unsets 2D array.
static void testmatgenunit_unset2dc(CMatrix *a) {
   ae_matrix_set_length(a, 0 + 1, 0 + 1);
   a->xyC[0][0] = complex_from_d(randommid());
}

// Test whether matrix is SPD
static bool testmatgenunit_isspd(RMatrix *a, ae_int_t n, bool isupper) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double ajj;
   double v;
   bool Ok;
   ae_frame_make(&_frame_block);
   DupMatrix(a);
//     Test the input parameters.
   ae_assert(n >= 0, "Error in SMatrixCholesky: incorrect function arguments");
//     Quick return if possible
   Ok = true;
   if (n <= 0) {
      ae_frame_leave();
      return Ok;
   }
   if (isupper) {
   // Compute the Cholesky factorization A = U'*U.
      for (j = 0; j < n; j++) {
      // Compute U(J,J) and test for non-positive-definiteness.
         v = ae_v_dotproduct(&a->xyR[0][j], a->stride, &a->xyR[0][j], a->stride, j);
         ajj = a->xyR[j][j] - v;
         if (ajj <= 0.0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         ajj = sqrt(ajj);
         a->xyR[j][j] = ajj;
      // Compute elements J+1:N of row J.
         if (j < n - 1) {
            for (i = j + 1; i < n; i++) {
               v = ae_v_dotproduct(&a->xyR[0][i], a->stride, &a->xyR[0][j], a->stride, j);
               a->xyR[j][i] -= v;
            }
            v = 1 / ajj;
            ae_v_muld(&a->xyR[j][j + 1], 1, n - j - 1, v);
         }
      }
   } else {
   // Compute the Cholesky factorization A == L*L'.
      for (j = 0; j < n; j++) {
      // Compute L(J,J) and test for non-positive-definiteness.
         v = ae_v_dotproduct(a->xyR[j], 1, a->xyR[j], 1, j);
         ajj = a->xyR[j][j] - v;
         if (ajj <= 0.0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         ajj = sqrt(ajj);
         a->xyR[j][j] = ajj;
      // Compute elements J+1:N of column J.
         if (j < n - 1) {
            for (i = j + 1; i < n; i++) {
               v = ae_v_dotproduct(a->xyR[i], 1, a->xyR[j], 1, j);
               a->xyR[i][j] -= v;
            }
            v = 1 / ajj;
            ae_v_muld(&a->xyR[j + 1][j], a->stride, n - j - 1, v);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Tests whether A is HPD
static bool testmatgenunit_ishpd(CMatrix *a, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t j;
   double ajj;
   complex v;
   double r;
   ae_int_t i;
   bool Ok;
   ae_frame_make(&_frame_block);
   DupMatrix(a);
   NewVector(t, 0, DT_COMPLEX);
   NewVector(t2, 0, DT_COMPLEX);
   NewVector(t3, 0, DT_COMPLEX);
   NewMatrix(a1, 0, 0, DT_COMPLEX);
   ae_vector_set_length(&t, n);
   ae_vector_set_length(&t2, n);
   ae_vector_set_length(&t3, n);
   Ok = true;
// Compute the Cholesky factorization A = U'*U.
   for (j = 0; j < n; j++) {
   // Compute U(J,J) and test for non-positive-definiteness.
      v = ae_v_cdotproduct(&a->xyC[0][j], a->stride, "Conj", &a->xyC[0][j], a->stride, "N", j);
      ajj = ae_c_sub(a->xyC[j][j], v).x;
      if (ajj <= 0.0) {
         a->xyC[j][j] = complex_from_d(ajj);
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      ajj = sqrt(ajj);
      a->xyC[j][j] = complex_from_d(ajj);
   // Compute elements J+1:N-1 of row J.
      if (j < n - 1) {
         ae_v_cmove(t2.xC, 1, &a->xyC[0][j], a->stride, "Conj", j);
         ae_v_cmove(&t3.xC[j + 1], 1, &a->xyC[j][j + 1], 1, "N", n - j - 1);
         for (i = j + 1; i < n; i++) {
            v = ae_v_cdotproduct(&a->xyC[0][i], a->stride, "N", t2.xC, 1, "N", j);
            t3.xC[i] = ae_c_sub(t3.xC[i], v);
         }
         ae_v_cmove(&a->xyC[j][j + 1], 1, &t3.xC[j + 1], 1, "N", n - j - 1);
         r = 1 / ajj;
         ae_v_cmuld(&a->xyC[j][j + 1], 1, n - j - 1, r);
      }
   }
   ae_frame_leave();
   return Ok;
}

// The function check, that upper triangle from symmetric matrix is equal to
// lower triangle.
static bool testmatgenunit_testeult() {
   ae_frame _frame_block;
   double c;
   double range;
   double eps;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_COMPLEX);
   eps = 2 * machineepsilon;
   range = 100.0 * randommid();
   for (n = 1; n <= 15; n++) {
      c = 900.0 * randomreal() + 100;
   // Generate symmetric matrix and check it
      smatrixrndcond(n, c, &a);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (!NearAtR(a.xyR[i][j], a.xyR[j][i], eps)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
      spdmatrixrndcond(n, c, &a);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (!NearAtR(a.xyR[i][j], a.xyR[j][i], eps)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
      hmatrixrndcond(n, c, &b);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (!NearAtR(b.xyC[i][j].x, b.xyC[j][i].x, eps) || !NearAtR(b.xyC[i][j].y, -b.xyC[j][i].y, eps)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
      hpdmatrixrndcond(n, c, &b);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (!NearAtR(b.xyC[i][j].x, b.xyC[j][i].x, eps) || !NearAtR(b.xyC[i][j].y, -b.xyC[j][i].y, eps)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   // Prepare symmetric matrix with real values
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            a.xyR[i][j] = range * randommid();
         }
      }
      for (i = 0; i < n - 1; i++) {
         for (j = i + 1; j < n; j++) {
            a.xyR[j][i] = a.xyR[i][j];
         }
      }
      smatrixrndmultiply(&a, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (!NearAtR(a.xyR[i][j], a.xyR[j][i], eps)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   // Prepare symmetric matrix with complex values
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            b.xyC[i][j] = complex_from_d(range * randommid(), i == j? 0.0: range * randommid());
         }
      }
      for (i = 0; i < n; i++) {
         for (j = i + 1; j < n; j++) {
            b.xyC[i][j] = complex_from_d(b.xyC[j][i].x, -b.xyC[j][i].y);
         }
      }
      hmatrixrndmultiply(&b, n);
      for (i = 0; i < n; i++) {
         b.xyC[i][i].y = 0.0;
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (!NearAtR(b.xyC[i][j].x, b.xyC[j][i].x, eps) || !NearAtR(b.xyC[i][j].y, -b.xyC[j][i].y, eps)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

static double testmatgenunit_extsign(double a, double b) {
   double result;
   if (b >= 0.0) {
      result = fabs(a);
   } else {
      result = -fabs(a);
   }
   return result;
}

static double testmatgenunit_mymax(double a, double b) {
   double result;
   if (a > b) {
      result = a;
   } else {
      result = b;
   }
   return result;
}

static double testmatgenunit_pythag(double a, double b) {
   double result;
   if (fabs(a) < fabs(b)) {
      result = fabs(b) * sqrt(1 + sqr(a / b));
   } else {
      result = fabs(a) * sqrt(1 + sqr(b / a));
   }
   return result;
}

static bool testmatgenunit_obsoletesvddecomposition(RMatrix *a, ae_int_t m, ae_int_t n, RVector *w, RMatrix *v) {
   ae_frame _frame_block;
   ae_int_t nm;
   ae_int_t minmn;
   ae_int_t l;
   ae_int_t k;
   ae_int_t j;
   ae_int_t jj;
   ae_int_t its;
   ae_int_t i;
   double z;
   double y;
   double x;
   double vscale;
   double s;
   double h;
   double g;
   double f;
   double c;
   double anorm;
   bool flag;
   bool Ok;
   ae_frame_make(&_frame_block);
   SetVector(w);
   SetMatrix(v);
   NewVector(rv1, 0, DT_REAL);
   ae_vector_set_length(&rv1, n + 1);
   ae_vector_set_length(w, n + 1);
   ae_matrix_set_length(v, n + 1, n + 1);
   Ok = true;
   if (m < n) {
      minmn = m;
   } else {
      minmn = n;
   }
   g = 0.0;
   vscale = 0.0;
   anorm = 0.0;
   l = n;
   for (i = 1; i <= n; i++) {
      l = i + 1;
      rv1.xR[i] = vscale * g;
      g = 0.0;
      s = 0.0;
      vscale = 0.0;
      if (i <= m) {
         for (k = i; k <= m; k++) {
            vscale += fabs(a->xyR[k][i]);
         }
         if (vscale != 0.0) {
            for (k = i; k <= m; k++) {
               a->xyR[k][i] /= vscale;
               s += a->xyR[k][i] * a->xyR[k][i];
            }
            f = a->xyR[i][i];
            g = -testmatgenunit_extsign(sqrt(s), f);
            h = f * g - s;
            a->xyR[i][i] = f - g;
            if (i != n) {
               for (j = l; j <= n; j++) {
                  s = 0.0;
                  for (k = i; k <= m; k++) {
                     s += a->xyR[k][i] * a->xyR[k][j];
                  }
                  f = s / h;
                  for (k = i; k <= m; k++) {
                     a->xyR[k][j] += f * a->xyR[k][i];
                  }
               }
            }
            for (k = i; k <= m; k++) {
               a->xyR[k][i] *= vscale;
            }
         }
      }
      w->xR[i] = vscale * g;
      g = 0.0;
      s = 0.0;
      vscale = 0.0;
      if (i <= m && i != n) {
         for (k = l; k <= n; k++) {
            vscale += fabs(a->xyR[i][k]);
         }
         if (vscale != 0.0) {
            for (k = l; k <= n; k++) {
               a->xyR[i][k] /= vscale;
               s += a->xyR[i][k] * a->xyR[i][k];
            }
            f = a->xyR[i][l];
            g = -testmatgenunit_extsign(sqrt(s), f);
            h = f * g - s;
            a->xyR[i][l] = f - g;
            for (k = l; k <= n; k++) {
               rv1.xR[k] = a->xyR[i][k] / h;
            }
            if (i != m) {
               for (j = l; j <= m; j++) {
                  s = 0.0;
                  for (k = l; k <= n; k++) {
                     s += a->xyR[j][k] * a->xyR[i][k];
                  }
                  for (k = l; k <= n; k++) {
                     a->xyR[j][k] += s * rv1.xR[k];
                  }
               }
            }
            for (k = l; k <= n; k++) {
               a->xyR[i][k] *= vscale;
            }
         }
      }
      anorm = testmatgenunit_mymax(anorm, fabs(w->xR[i]) + fabs(rv1.xR[i]));
   }
   for (i = n; i >= 1; i--) {
      if (i < n) {
         if (g != 0.0) {
            for (j = l; j <= n; j++) {
               v->xyR[j][i] = a->xyR[i][j] / a->xyR[i][l] / g;
            }
            for (j = l; j <= n; j++) {
               s = 0.0;
               for (k = l; k <= n; k++) {
                  s += a->xyR[i][k] * v->xyR[k][j];
               }
               for (k = l; k <= n; k++) {
                  v->xyR[k][j] += s * v->xyR[k][i];
               }
            }
         }
         for (j = l; j <= n; j++) {
            v->xyR[i][j] = 0.0;
            v->xyR[j][i] = 0.0;
         }
      }
      v->xyR[i][i] = 1.0;
      g = rv1.xR[i];
      l = i;
   }
   for (i = minmn; i >= 1; i--) {
      l = i + 1;
      g = w->xR[i];
      if (i < n) {
         for (j = l; j <= n; j++) {
            a->xyR[i][j] = 0.0;
         }
      }
      if (g != 0.0) {
         g = 1.0 / g;
         if (i != n) {
            for (j = l; j <= n; j++) {
               s = 0.0;
               for (k = l; k <= m; k++) {
                  s += a->xyR[k][i] * a->xyR[k][j];
               }
               f = s / a->xyR[i][i] * g;
               for (k = i; k <= m; k++) {
                  a->xyR[k][j] += f * a->xyR[k][i];
               }
            }
         }
         for (j = i; j <= m; j++) {
            a->xyR[j][i] *= g;
         }
      } else {
         for (j = i; j <= m; j++) {
            a->xyR[j][i] = 0.0;
         }
      }
      a->xyR[i][i]++;
   }
   nm = 0;
   for (k = n; k >= 1; k--) {
      for (its = 1; its <= testmatgenunit_maxsvditerations; its++) {
         flag = true;
         for (l = k; l >= 1; l--) {
            nm = l - 1;
            if (fabs(rv1.xR[l]) + anorm == anorm) {
               flag = false;
               break;
            }
            if (fabs(w->xR[nm]) + anorm == anorm) {
               break;
            }
         }
         if (flag) {
            c = 0.0;
            s = 1.0;
            for (i = l; i <= k; i++) {
               f = s * rv1.xR[i];
               if (fabs(f) + anorm != anorm) {
                  g = w->xR[i];
                  h = testmatgenunit_pythag(f, g);
                  w->xR[i] = h;
                  h = 1.0 / h;
                  c = g * h;
                  s = -f * h;
                  for (j = 1; j <= m; j++) {
                     y = a->xyR[j][nm];
                     z = a->xyR[j][i];
                     a->xyR[j][nm] = y * c + z * s;
                     a->xyR[j][i] = -y * s + z * c;
                  }
               }
            }
         }
         z = w->xR[k];
         if (l == k) {
            if (z < 0.0) {
               w->xR[k] = -z;
               for (j = 1; j <= n; j++) {
                  v->xyR[j][k] = -v->xyR[j][k];
               }
            }
            break;
         }
         if (its == testmatgenunit_maxsvditerations) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         x = w->xR[l];
         nm = k - 1;
         y = w->xR[nm];
         g = rv1.xR[nm];
         h = rv1.xR[k];
         f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);
         g = testmatgenunit_pythag(f, 1.0);
         f = ((x - z) * (x + z) + h * (y / (f + testmatgenunit_extsign(g, f)) - h)) / x;
         c = 1.0;
         s = 1.0;
         for (j = l; j <= nm; j++) {
            i = j + 1;
            g = rv1.xR[i];
            y = w->xR[i];
            h = s * g;
            g *= c;
            z = testmatgenunit_pythag(f, h);
            rv1.xR[j] = z;
            c = f / z;
            s = h / z;
            f = x * c + g * s;
            g = -x * s + g * c;
            h = y * s;
            y *= c;
            for (jj = 1; jj <= n; jj++) {
               x = v->xyR[jj][j];
               z = v->xyR[jj][i];
               v->xyR[jj][j] = x * c + z * s;
               v->xyR[jj][i] = -x * s + z * c;
            }
            z = testmatgenunit_pythag(f, h);
            w->xR[j] = z;
            if (z != 0.0) {
               z = 1.0 / z;
               c = f * z;
               s = h * z;
            }
            f = c * g + s * y;
            x = -s * g + c * y;
            for (jj = 1; jj <= m; jj++) {
               y = a->xyR[jj][j];
               z = a->xyR[jj][i];
               a->xyR[jj][j] = y * c + z * s;
               a->xyR[jj][i] = -y * s + z * c;
            }
         }
         rv1.xR[l] = 0.0;
         rv1.xR[k] = f;
         w->xR[k] = x;
      }
   }
   ae_frame_leave();
   return Ok;
}

// SVD condition number
static double testmatgenunit_svdcond(RMatrix *a, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double minw;
   double maxw;
   double result;
   ae_frame_make(&_frame_block);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   ae_matrix_set_length(&a1, n + 1, n + 1);
   for (i = 1; i <= n; i++) {
      for (j = 1; j <= n; j++) {
         a1.xyR[i][j] = a->xyR[i - 1][j - 1];
      }
   }
   if (!testmatgenunit_obsoletesvddecomposition(&a1, n, n, &w, &v)) {
      result = 0.0;
      ae_frame_leave();
      return result;
   }
   minw = w.xR[1];
   maxw = w.xR[1];
   for (i = 2; i <= n; i++) {
      if (w.xR[i] < minw) {
         minw = w.xR[i];
      }
      if (w.xR[i] > maxw) {
         maxw = w.xR[i];
      }
   }
   result = maxw / minw;
   ae_frame_leave();
   return result;
}

bool testmatgen() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   ae_int_t passcount;
   bool Ok;
   double cond;
   double threshold;
   double vt;
   complex ct;
   double minw;
   double maxw;
   bool sOk;
   bool hOk;
   bool spdOk;
   bool hpdOk;
   bool rOk;
   bool cOk;
   bool eulOk;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewMatrix(u, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewMatrix(cb, 0, 0, DT_COMPLEX);
   NewMatrix(r1, 0, 0, DT_REAL);
   NewMatrix(r2, 0, 0, DT_REAL);
   NewMatrix(c1, 0, 0, DT_COMPLEX);
   NewMatrix(c2, 0, 0, DT_COMPLEX);
   NewVector(w, 0, DT_REAL);
   rOk = true;
   cOk = true;
   sOk = true;
   hOk = true;
   spdOk = true;
   hpdOk = true;
   eulOk = true;
   Ok = true;
   maxn = 20;
   passcount = 15;
   threshold = 1000.0 * machineepsilon;
// Testing orthogonal
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
         ae_matrix_set_length(&r1, n, 2 * n);
         ae_matrix_set_length(&r2, 2 * n, n);
         ae_matrix_set_length(&c1, n, 2 * n);
         ae_matrix_set_length(&c2, 2 * n, n);
      // Random orthogonal, real
         testmatgenunit_unset2d(&a);
         testmatgenunit_unset2d(&b);
         rmatrixrndorthogonal(n, &a);
         rmatrixrndorthogonal(n, &b);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
            // orthogonality test
               vt = ae_v_dotproduct(a.xyR[i], 1, a.xyR[j], 1, n);
               if (i == j) {
                  rOk = rOk && NearAtR(vt, 1, threshold);
               } else {
                  rOk = rOk && SmallAtR(vt, threshold);
               }
               vt = ae_v_dotproduct(b.xyR[i], 1, b.xyR[j], 1, n);
               if (i == j) {
                  rOk = rOk && NearAtR(vt, 1, threshold);
               } else {
                  rOk = rOk && SmallAtR(vt, threshold);
               }
            // test for difference in A and B
               if (n >= 2) {
                  rOk = rOk && a.xyR[i][j] != b.xyR[i][j];
               }
            }
         }
      // Random orthogonal, complex
         testmatgenunit_unset2dc(&ca);
         testmatgenunit_unset2dc(&cb);
         cmatrixrndorthogonal(n, &ca);
         cmatrixrndorthogonal(n, &cb);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
            // orthogonality test
               ct = ae_v_cdotproduct(ca.xyC[i], 1, "N", ca.xyC[j], 1, "Conj", n);
               if (i == j) {
                  cOk = cOk && NearAtCR(ct, 1.0, threshold);
               } else {
                  cOk = cOk && SmallAtC(ct, threshold);
               }
               ct = ae_v_cdotproduct(cb.xyC[i], 1, "N", cb.xyC[j], 1, "Conj", n);
               if (i == j) {
                  cOk = cOk && NearAtCR(ct, 1.0, threshold);
               } else {
                  cOk = cOk && SmallAtC(ct, threshold);
               }
            // test for difference in A and B
               if (n >= 2) {
                  cOk = cOk && !ae_c_eq(ca.xyC[i][j], cb.xyC[i][j]);
               }
            }
         }
      // From the right real tests:
      // 1. E*Q is orthogonal
      // 2. Q1 != Q2 (routine result is changing)
      // 3. (E E)'*Q = (Q' Q')' (correct handling of non-square matrices)
         testmatgenunit_unset2d(&a);
         testmatgenunit_unset2d(&b);
         ae_matrix_set_length(&a, n, n);
         ae_matrix_set_length(&b, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
               b.xyR[i][j] = 0.0;
            }
            a.xyR[i][i] = 1.0;
            b.xyR[i][i] = 1.0;
         }
         rmatrixrndorthogonalfromtheright(&a, n, n);
         rmatrixrndorthogonalfromtheright(&b, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
            // orthogonality test
               vt = ae_v_dotproduct(a.xyR[i], 1, a.xyR[j], 1, n);
               if (i == j) {
                  rOk = rOk && NearAtR(vt, 1, threshold);
               } else {
                  rOk = rOk && SmallAtR(vt, threshold);
               }
               vt = ae_v_dotproduct(b.xyR[i], 1, b.xyR[j], 1, n);
               if (i == j) {
                  rOk = rOk && NearAtR(vt, 1, threshold);
               } else {
                  rOk = rOk && SmallAtR(vt, threshold);
               }
            // test for difference in A and B
               if (n >= 2) {
                  rOk = rOk && a.xyR[i][j] != b.xyR[i][j];
               }
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               r2.xyR[i][j] = randommid();
               r2.xyR[i + n][j] = r2.xyR[i][j];
            }
         }
         rmatrixrndorthogonalfromtheright(&r2, 2 * n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rOk = rOk && NearAtR(r2.xyR[i + n][j], r2.xyR[i][j], threshold);
            }
         }
      // From the left real tests:
      // 1. Q*E is orthogonal
      // 2. Q1 != Q2 (routine result is changing)
      // 3. Q*(E E) = (Q Q) (correct handling of non-square matrices)
         testmatgenunit_unset2d(&a);
         testmatgenunit_unset2d(&b);
         ae_matrix_set_length(&a, n, n);
         ae_matrix_set_length(&b, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
               b.xyR[i][j] = 0.0;
            }
            a.xyR[i][i] = 1.0;
            b.xyR[i][i] = 1.0;
         }
         rmatrixrndorthogonalfromtheleft(&a, n, n);
         rmatrixrndorthogonalfromtheleft(&b, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
            // orthogonality test
               vt = ae_v_dotproduct(a.xyR[i], 1, a.xyR[j], 1, n);
               if (i == j) {
                  rOk = rOk && NearAtR(vt, 1, threshold);
               } else {
                  rOk = rOk && SmallAtR(vt, threshold);
               }
               vt = ae_v_dotproduct(b.xyR[i], 1, b.xyR[j], 1, n);
               if (i == j) {
                  rOk = rOk && NearAtR(vt, 1, threshold);
               } else {
                  rOk = rOk && SmallAtR(vt, threshold);
               }
            // test for difference in A and B
               if (n >= 2) {
                  rOk = rOk && a.xyR[i][j] != b.xyR[i][j];
               }
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               r1.xyR[i][j] = randommid();
               r1.xyR[i][j + n] = r1.xyR[i][j];
            }
         }
         rmatrixrndorthogonalfromtheleft(&r1, n, 2 * n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rOk = rOk && NearAtR(r1.xyR[i][j], r1.xyR[i][j + n], threshold);
            }
         }
      // From the right complex tests:
      // 1. E*Q is orthogonal
      // 2. Q1 != Q2 (routine result is changing)
      // 3. (E E)'*Q = (Q' Q')' (correct handling of non-square matrices)
         testmatgenunit_unset2dc(&ca);
         testmatgenunit_unset2dc(&cb);
         ae_matrix_set_length(&ca, n, n);
         ae_matrix_set_length(&cb, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               ca.xyC[i][j] = complex_from_i(0);
               cb.xyC[i][j] = complex_from_i(0);
            }
            ca.xyC[i][i] = complex_from_i(1);
            cb.xyC[i][i] = complex_from_i(1);
         }
         cmatrixrndorthogonalfromtheright(&ca, n, n);
         cmatrixrndorthogonalfromtheright(&cb, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
            // orthogonality test
               ct = ae_v_cdotproduct(ca.xyC[i], 1, "N", ca.xyC[j], 1, "Conj", n);
               if (i == j) {
                  cOk = cOk && NearAtCR(ct, 1.0, threshold);
               } else {
                  cOk = cOk && SmallAtC(ct, threshold);
               }
               ct = ae_v_cdotproduct(cb.xyC[i], 1, "N", cb.xyC[j], 1, "Conj", n);
               if (i == j) {
                  cOk = cOk && NearAtCR(ct, 1.0, threshold);
               } else {
                  cOk = cOk && SmallAtC(ct, threshold);
               }
            // test for difference in A and B
               cOk = cOk && !ae_c_eq(ca.xyC[i][j], cb.xyC[i][j]);
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               c2.xyC[i][j] = complex_from_d(randommid());
               c2.xyC[i + n][j] = c2.xyC[i][j];
            }
         }
         cmatrixrndorthogonalfromtheright(&c2, 2 * n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               cOk = cOk && NearAtC(c2.xyC[i + n][j], c2.xyC[i][j], threshold);
            }
         }
      // From the left complex tests:
      // 1. Q*E is orthogonal
      // 2. Q1 != Q2 (routine result is changing)
      // 3. Q*(E E) = (Q Q) (correct handling of non-square matrices)
         testmatgenunit_unset2dc(&ca);
         testmatgenunit_unset2dc(&cb);
         ae_matrix_set_length(&ca, n, n);
         ae_matrix_set_length(&cb, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               ca.xyC[i][j] = complex_from_i(0);
               cb.xyC[i][j] = complex_from_i(0);
            }
            ca.xyC[i][i] = complex_from_i(1);
            cb.xyC[i][i] = complex_from_i(1);
         }
         cmatrixrndorthogonalfromtheleft(&ca, n, n);
         cmatrixrndorthogonalfromtheleft(&cb, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
            // orthogonality test
               ct = ae_v_cdotproduct(ca.xyC[i], 1, "N", ca.xyC[j], 1, "Conj", n);
               if (i == j) {
                  cOk = cOk && NearAtCR(ct, 1.0, threshold);
               } else {
                  cOk = cOk && SmallAtC(ct, threshold);
               }
               ct = ae_v_cdotproduct(cb.xyC[i], 1, "N", cb.xyC[j], 1, "Conj", n);
               if (i == j) {
                  cOk = cOk && NearAtCR(ct, 1.0, threshold);
               } else {
                  cOk = cOk && SmallAtC(ct, threshold);
               }
            // test for difference in A and B
               cOk = cOk && !ae_c_eq(ca.xyC[i][j], cb.xyC[i][j]);
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               c1.xyC[i][j] = complex_from_d(randommid());
               c1.xyC[i][j + n] = c1.xyC[i][j];
            }
         }
         cmatrixrndorthogonalfromtheleft(&c1, n, 2 * n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               cOk = cOk && NearAtC(c1.xyC[i][j], c1.xyC[i][j + n], threshold);
            }
         }
      }
   }
// Testing GCond
   for (n = 2; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
      // real test
         testmatgenunit_unset2d(&a);
         cond = exp(log(1000.0) * randomreal());
         rmatrixrndcond(n, cond, &a);
         ae_matrix_set_length(&b, n + 1, n + 1);
         for (i = 1; i <= n; i++) {
            for (j = 1; j <= n; j++) {
               b.xyR[i][j] = a.xyR[i - 1][j - 1];
            }
         }
         if (testmatgenunit_obsoletesvddecomposition(&b, n, n, &w, &v)) {
            maxw = w.xR[1];
            minw = w.xR[1];
            for (i = 2; i <= n; i++) {
               if (w.xR[i] > maxw) {
                  maxw = w.xR[i];
               }
               if (w.xR[i] < minw) {
                  minw = w.xR[i];
               }
            }
            vt = maxw / minw / cond;
            if (!SmallAtR(log(vt), log(1 + threshold))) {
               rOk = false;
            }
         }
      }
   }
// Symmetric/SPD
// N = 2 .. 30
   for (n = 2; n <= maxn; n++) {
   // SPD matrices
      for (pass = 1; pass <= passcount; pass++) {
      // Generate A
         testmatgenunit_unset2d(&a);
         cond = exp(log(1000.0) * randomreal());
         spdmatrixrndcond(n, cond, &a);
      // test condition number
         spdOk = spdOk && testmatgenunit_svdcond(&a, n) / cond - 1 <= threshold;
      // test SPD
         spdOk = spdOk && testmatgenunit_isspd(&a, n, true);
      // test that A is symmetic
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               spdOk = spdOk && NearAtR(a.xyR[i][j], a.xyR[j][i], threshold);
            }
         }
      // test for difference between A and B (subsequent matrix)
         testmatgenunit_unset2d(&b);
         spdmatrixrndcond(n, cond, &b);
         if (n >= 2) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  spdOk = spdOk && a.xyR[i][j] != b.xyR[i][j];
               }
            }
         }
      }
   // HPD matrices
      for (pass = 1; pass <= passcount; pass++) {
      // Generate A
         testmatgenunit_unset2dc(&ca);
         cond = exp(log(1000.0) * randomreal());
         hpdmatrixrndcond(n, cond, &ca);
      // test HPD
         hpdOk = hpdOk && testmatgenunit_ishpd(&ca, n);
      // test that A is Hermitian
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               hpdOk = hpdOk && NearAtC(ca.xyC[i][j], conj(ca.xyC[j][i]), threshold);
            }
         }
      // test for difference between A and B (subsequent matrix)
         testmatgenunit_unset2dc(&cb);
         hpdmatrixrndcond(n, cond, &cb);
         if (n >= 2) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  hpdOk = hpdOk && !ae_c_eq(ca.xyC[i][j], cb.xyC[i][j]);
               }
            }
         }
      }
   // Symmetric matrices
      for (pass = 1; pass <= passcount; pass++) {
      // test condition number
         testmatgenunit_unset2d(&a);
         cond = exp(log(1000.0) * randomreal());
         smatrixrndcond(n, cond, &a);
         sOk = sOk && testmatgenunit_svdcond(&a, n) / cond - 1 <= threshold;
      // test for difference between A and B
         testmatgenunit_unset2d(&b);
         smatrixrndcond(n, cond, &b);
         if (n >= 2) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  sOk = sOk && a.xyR[i][j] != b.xyR[i][j];
               }
            }
         }
      }
   // Hermitian matrices
      for (pass = 1; pass <= passcount; pass++) {
      // Generate A
         testmatgenunit_unset2dc(&ca);
         cond = exp(log(1000.0) * randomreal());
         hmatrixrndcond(n, cond, &ca);
      // test that A is Hermitian
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               hOk = hOk && NearAtC(ca.xyC[i][j], conj(ca.xyC[j][i]), threshold);
            }
         }
      // test for difference between A and B (subsequent matrix)
         testmatgenunit_unset2dc(&cb);
         hmatrixrndcond(n, cond, &cb);
         if (n >= 2) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  hOk = hOk && !ae_c_eq(ca.xyC[i][j], cb.xyC[i][j]);
               }
            }
         }
      }
   }
// Test for symmetric matrices
   eulOk = testmatgenunit_testeult();
// The final report.
   Ok = rOk && cOk && sOk && spdOk && hOk && hpdOk && eulOk;
   if (!Ok || !silent) {
      printf("Matrix Generator Tests\n");
      printf("Real Test:                                %s\n", rOk? "Ok": "Failed");
      printf("Complex Test:                             %s\n", cOk? "Ok": "Failed");
      printf("Symmetric Test:                           %s\n", sOk? "Ok": "Failed");
      printf("Hermitian Test:                           %s\n", hOk? "Ok": "Failed");
      printf("SPD Test:                                 %s\n", spdOk? "Ok": "Failed");
      printf("HPD Test:                                 %s\n", hpdOk? "Ok": "Failed");
      printf("Test For Symmetric Matrices:              %s\n", eulOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === tsort testing unit ===
// Unsets 1D array.
static void testtsortunit_unset1di(ZVector *a) {
   ae_vector_set_length(a, 0 + 1);
   a->xZ[0] = randominteger(3) - 1;
}

static bool testtsortunit_testsortresults(RVector *asorted, ZVector *p1, ZVector *p2, RVector *aoriginal, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(a2, 0, DT_REAL);
   NewVector(f, 0, DT_INT);
   ae_vector_set_length(&a2, n);
   ae_vector_set_length(&f, n);
// is set ordered?
   for (i = 0; i < n - 1; i++) {
      Ok = Ok && asorted->xR[i] <= asorted->xR[i + 1];
   }
// P1 correctness
   for (i = 0; i < n; i++) {
      Ok = Ok && asorted->xR[i] == aoriginal->xR[p1->xZ[i]];
   }
   for (i = 0; i < n; i++) {
      f.xZ[i] = 0;
   }
   for (i = 0; i < n; i++) {
      f.xZ[p1->xZ[i]]++;
   }
   for (i = 0; i < n; i++) {
      Ok = Ok && f.xZ[i] == 1;
   }
// P2 correctness
   for (i = 0; i < n; i++) {
      a2.xR[i] = aoriginal->xR[i];
   }
   for (i = 0; i < n; i++) {
      if (p2->xZ[i] != i) {
         swapr(&a2.xR[i], &a2.xR[p2->xZ[i]]);
      }
   }
   for (i = 0; i < n; i++) {
      Ok = Ok && asorted->xR[i] == a2.xR[i];
   }
   ae_frame_leave();
   return Ok;
}

// Testing tag sort
bool testtsort() {
   ae_frame _frame_block;
   bool Ok;
   ae_int_t n;
   ae_int_t i;
   ae_int_t m;
   ae_int_t offs;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t maxn;
   bool distinctvals;
   ae_frame_make(&_frame_block);
   NewVector(a, 0, DT_REAL);
   NewVector(a0, 0, DT_REAL);
   NewVector(a1, 0, DT_REAL);
   NewVector(a2, 0, DT_REAL);
   NewVector(a3, 0, DT_REAL);
   NewVector(i1, 0, DT_INT);
   NewVector(i2, 0, DT_INT);
   NewVector(i3, 0, DT_INT);
   NewVector(a4, 0, DT_INT);
   NewVector(a5, 0, DT_INT);
   NewVector(pa4, 0, DT_INT);
   NewVector(ar, 0, DT_REAL);
   NewVector(ar2, 0, DT_REAL);
   NewVector(ai, 0, DT_INT);
   NewVector(p1, 0, DT_INT);
   NewVector(p2, 0, DT_INT);
   NewVector(bufr1, 0, DT_REAL);
   NewVector(bufr2, 0, DT_REAL);
   NewVector(bufi1, 0, DT_INT);
   Ok = true;
   maxn = 100;
   passcount = 10;
// Test tagsort
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
      // Pprobably distinct sort:
      // * generate array of integer random numbers.
      //   Because of birthday paradox, random numbers have to be VERY large
      //   in order to avoid situation when we have distinct values.
      // * sort A0 using TagSort and test sort results
      // * now we can use A0 as reference point and test other functions
         testtsortunit_unset1di(&p1);
         testtsortunit_unset1di(&p2);
         ae_vector_set_length(&a, n);
         ae_vector_set_length(&a0, n);
         ae_vector_set_length(&a1, n);
         ae_vector_set_length(&a2, n);
         ae_vector_set_length(&a3, n);
         ae_vector_set_length(&a4, n);
         ae_vector_set_length(&a5, n);
         ae_vector_set_length(&ar, n);
         ae_vector_set_length(&ar2, n);
         ae_vector_set_length(&ai, n);
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)randominteger(100000000);
            a0.xR[i] = a.xR[i];
            a1.xR[i] = a.xR[i];
            a2.xR[i] = a.xR[i];
            a3.xR[i] = a.xR[i];
            a4.xZ[i] = iround(a.xR[i]);
            a5.xZ[i] = iround(a.xR[i]);
            ar.xR[i] = (double)i;
            ar2.xR[i] = (double)i;
            ai.xZ[i] = i;
         }
         tagsort(&a0, n, &p1, &p2);
         Ok = Ok && testtsortunit_testsortresults(&a0, &p1, &p2, &a, n);
         distinctvals = true;
         for (i = 1; i < n; i++) {
            distinctvals = distinctvals && a0.xR[i] != a0.xR[i - 1];
         }
         if (distinctvals) {
            tagsortfasti(&a1, &ai, &bufr1, &bufi1, n);
            for (i = 0; i < n; i++) {
               Ok = Ok && a1.xR[i] == a0.xR[i] && ai.xZ[i] == p1.xZ[i];
            }
            tagsortfastr(&a2, &ar, &bufr1, &bufr2, n);
            for (i = 0; i < n; i++) {
               Ok = Ok && a2.xR[i] == a0.xR[i] && ar.xR[i] == p1.xZ[i];
            }
            tagsortfast(&a3, &bufr1, n);
            for (i = 0; i < n; i++) {
               Ok = Ok && a3.xR[i] == a0.xR[i];
            }
            tagsortmiddleir(&a4, &ar2, n);
            for (i = 0; i < n; i++) {
               Ok = Ok && a4.xZ[i] == a0.xR[i] && ar2.xR[i] == p1.xZ[i];
            }
            tagsortmiddlei(&a5, n);
            for (i = 0; i < n; i++) {
               Ok = Ok && a5.xZ[i] == a0.xR[i];
            }
         }
      // Non-distinct sort.
      // We test that keys are correctly reordered, but do NOT test order of values.
         testtsortunit_unset1di(&p1);
         testtsortunit_unset1di(&p2);
         ae_vector_set_length(&a, n);
         ae_vector_set_length(&a0, n);
         ae_vector_set_length(&a1, n);
         ae_vector_set_length(&a2, n);
         ae_vector_set_length(&a3, n);
         ae_vector_set_length(&a4, n);
         ae_vector_set_length(&a5, n);
         ae_vector_set_length(&ar, n);
         ae_vector_set_length(&ar2, n);
         ae_vector_set_length(&ai, n);
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)((n - i) / 2);
            a0.xR[i] = a.xR[i];
            a1.xR[i] = a.xR[i];
            a2.xR[i] = a.xR[i];
            a3.xR[i] = a.xR[i];
            a4.xZ[i] = iround(a.xR[i]);
            a5.xZ[i] = iround(a.xR[i]);
            ar.xR[i] = (double)i;
            ar2.xR[i] = (double)i;
            ai.xZ[i] = i;
         }
         tagsort(&a0, n, &p1, &p2);
         Ok = Ok && testtsortunit_testsortresults(&a0, &p1, &p2, &a, n);
         tagsortfasti(&a1, &ai, &bufr1, &bufi1, n);
         for (i = 0; i < n; i++) {
            Ok = Ok && a1.xR[i] == a0.xR[i];
         }
         tagsortfastr(&a2, &ar, &bufr1, &bufr2, n);
         for (i = 0; i < n; i++) {
            Ok = Ok && a2.xR[i] == a0.xR[i];
         }
         tagsortfast(&a3, &bufr1, n);
         for (i = 0; i < n; i++) {
            Ok = Ok && a3.xR[i] == a0.xR[i];
         }
         tagsortmiddleir(&a4, &ar2, n);
         for (i = 0; i < n; i++) {
            Ok = Ok && a4.xZ[i] == a0.xR[i];
         }
         tagsortmiddlei(&a5, n);
         for (i = 0; i < n; i++) {
            Ok = Ok && a5.xZ[i] == a0.xR[i];
         }
      // 'All same' sort
      // We test that keys are correctly reordered, but do NOT test order of values.
         testtsortunit_unset1di(&p1);
         testtsortunit_unset1di(&p2);
         ae_vector_set_length(&a, n);
         ae_vector_set_length(&a0, n);
         ae_vector_set_length(&a1, n);
         ae_vector_set_length(&a2, n);
         ae_vector_set_length(&a3, n);
         ae_vector_set_length(&a4, n);
         ae_vector_set_length(&ar, n);
         ae_vector_set_length(&ar2, n);
         ae_vector_set_length(&ai, n);
         for (i = 0; i < n; i++) {
            a.xR[i] = 0.0;
            a0.xR[i] = a.xR[i];
            a1.xR[i] = a.xR[i];
            a2.xR[i] = a.xR[i];
            a3.xR[i] = a.xR[i];
            a4.xZ[i] = iround(a.xR[i]);
            ar.xR[i] = (double)i;
            ar2.xR[i] = (double)i;
            ai.xZ[i] = i;
         }
         tagsort(&a0, n, &p1, &p2);
         Ok = Ok && testtsortunit_testsortresults(&a0, &p1, &p2, &a, n);
         tagsortfasti(&a1, &ai, &bufr1, &bufi1, n);
         for (i = 0; i < n; i++) {
            Ok = Ok && a1.xR[i] == a0.xR[i];
         }
         tagsortfastr(&a2, &ar, &bufr1, &bufr2, n);
         for (i = 0; i < n; i++) {
            Ok = Ok && a2.xR[i] == a0.xR[i];
         }
         tagsortfast(&a3, &bufr1, n);
         for (i = 0; i < n; i++) {
            Ok = Ok && a3.xR[i] == a0.xR[i];
         }
         tagsortmiddleir(&a4, &ar2, n);
         for (i = 0; i < n; i++) {
            Ok = Ok && a4.xZ[i] == a0.xR[i];
         }
      // 0-1 sort
      // We test that keys are correctly reordered, but do NOT test order of values.
         testtsortunit_unset1di(&p1);
         testtsortunit_unset1di(&p2);
         ae_vector_set_length(&a, n);
         ae_vector_set_length(&a0, n);
         ae_vector_set_length(&a1, n);
         ae_vector_set_length(&a2, n);
         ae_vector_set_length(&a3, n);
         ae_vector_set_length(&a4, n);
         ae_vector_set_length(&ar, n);
         ae_vector_set_length(&ar2, n);
         ae_vector_set_length(&ai, n);
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)randominteger(2);
            a0.xR[i] = a.xR[i];
            a1.xR[i] = a.xR[i];
            a2.xR[i] = a.xR[i];
            a3.xR[i] = a.xR[i];
            a4.xZ[i] = iround(a.xR[i]);
            ar.xR[i] = (double)i;
            ar2.xR[i] = (double)i;
            ai.xZ[i] = i;
         }
         tagsort(&a0, n, &p1, &p2);
         Ok = Ok && testtsortunit_testsortresults(&a0, &p1, &p2, &a, n);
         tagsortfasti(&a1, &ai, &bufr1, &bufi1, n);
         for (i = 0; i < n; i++) {
            Ok = Ok && a1.xR[i] == a0.xR[i];
         }
         tagsortfastr(&a2, &ar, &bufr1, &bufr2, n);
         for (i = 0; i < n; i++) {
            Ok = Ok && a2.xR[i] == a0.xR[i];
         }
         tagsortfast(&a3, &bufr1, n);
         for (i = 0; i < n; i++) {
            Ok = Ok && a3.xR[i] == a0.xR[i];
         }
         tagsortmiddleir(&a4, &ar2, n);
         for (i = 0; i < n; i++) {
            Ok = Ok && a4.xZ[i] == a0.xR[i];
         }
      // Special test for TagSortMiddleIR: sorting in the middle gives same results
      // as sorting in the beginning of the array
         m = 3 * n;
         offs = randominteger(n);
         ae_vector_set_length(&i1, m);
         ae_vector_set_length(&i2, m);
         ae_vector_set_length(&i3, m);
         ae_vector_set_length(&ar, m);
         ae_vector_set_length(&ar2, m);
         for (i = 0; i < m; i++) {
            i1.xZ[i] = randominteger(100000000);
            i2.xZ[i] = i1.xZ[i];
            i3.xZ[i] = i1.xZ[i];
            ar.xR[i] = (double)i;
            ar2.xR[i] = (double)i;
         }
         for (i = 0; i < n; i++) {
            i1.xZ[i] = i1.xZ[offs + i];
            ar.xR[i] = ar.xR[offs + i];
         }
         tagsortmiddleir(&i1, &ar, n);
         for (i = 1; i < n; i++) {
            distinctvals = distinctvals && i1.xZ[i] != i1.xZ[i - 1];
         }
         if (distinctvals) {
            tagsortmiddleir(&i2, &ar2, n, offs);
            for (i = 0; i < n; i++) {
               Ok = Ok && i2.xZ[offs + i] == i1.xZ[i] && ar2.xR[offs + i] == ar.xR[i];
            }
         }
      }
   }
// The final report.
   if (!Ok || !silent) {
      printf("Tag Sort Test\n");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === sparse testing unit ===
struct sparsegenerator {
   ae_int_t n;
   ae_int_t m;
   ae_int_t matkind;
   ae_int_t triangle;
   ae_matrix bufa;
   hqrndstate rs;
   ae_int_t PQ;
};

static void sparsegenerator_init(void *_p, bool make_automatic) {
   sparsegenerator *p = (sparsegenerator *)_p;
   ae_matrix_init(&p->bufa, 0, 0, DT_REAL, make_automatic);
   hqrndstate_init(&p->rs, make_automatic);
}

static void sparsegenerator_copy(void *_dst, void *_src, bool make_automatic) {
   sparsegenerator *dst = (sparsegenerator *)_dst;
   sparsegenerator *src = (sparsegenerator *)_src;
   dst->n = src->n;
   dst->m = src->m;
   dst->matkind = src->matkind;
   dst->triangle = src->triangle;
   ae_matrix_copy(&dst->bufa, &src->bufa, make_automatic);
   hqrndstate_copy(&dst->rs, &src->rs, make_automatic);
   dst->PQ = src->PQ;
}

static void sparsegenerator_free(void *_p, bool make_automatic) {
   sparsegenerator *p = (sparsegenerator *)_p;
   ae_matrix_free(&p->bufa, make_automatic);
   hqrndstate_free(&p->rs, make_automatic);
}

// Function for testing basic SKS functional.
// ALGLIB Project: Copyright 16.01.2014 by Sergey Bochkanov
static bool skstest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nz;
   double pnz;
   ae_int_t i;
   ae_int_t j;
   ae_int_t t0;
   ae_int_t t1;
   double v0;
   double v1;
   ae_int_t uppercnt;
   ae_int_t lowercnt;
   ae_int_t bw;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, s1);
   NewObj(sparsematrix, s2);
   NewObj(sparsematrix, s3);
   NewObj(sparsematrix, s4);
   NewObj(sparsematrix, s5);
   NewObj(sparsematrix, s6);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(wasenumerated, 0, 0, DT_BOOL);
   NewVector(d, 0, DT_INT);
   NewVector(u, 0, DT_INT);
   NewObj(hqrndstate, rs);
   Ok = true;
   hqrndrandomize(&rs);
   for (n = 1; n <= 20; n++) {
      nz = n * n - n;
      while (true) {
      // Generate N*N matrix where probability of non-diagonal element
      // being non-zero is PNZ. We also generate D and U - subdiagonal
      // and superdiagonal profile sizes.
      //
      // Create matrix with either general SKS or banded SKS constructor function
         if (n > 1) {
            pnz = (double)nz / (n * n - n);
         } else {
            pnz = 1.0;
         }
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&u, n);
         ae_matrix_set_length(&a, n, n);
         if (hqrndnormal(&rs) > 0.0) {
         // Test SparseCreateSKS() functionality
            for (i = 0; i < n; i++) {
               d.xZ[i] = 0;
               u.xZ[i] = 0;
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (i == j || hqrnduniformr(&rs) <= pnz) {
                     a.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                     if (j < i) {
                        d.xZ[i] = imax2(d.xZ[i], i - j);
                     } else {
                        u.xZ[j] = imax2(u.xZ[j], j - i);
                     }
                  } else {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
            sparsecreatesks(n, n, &d, &u, &s0);
         } else {
         // Test SparseCreateSKSBand() functionality
            bw = hqrnduniformi(&rs, n + 1);
            for (i = 0; i < n; i++) {
               d.xZ[i] = imin2(bw, i);
               u.xZ[i] = imin2(bw, i);
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (ae_iabs(i - j) <= bw && hqrnduniformr(&rs) <= pnz) {
                     a.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                  } else {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
            sparsecreatesksband(n, n, bw, &s0);
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (a.xyR[i][j] != 0.0) {
                  if (hqrndnormal(&rs) > 0.0) {
                     Ok = Ok && sparserewriteexisting(&s0, i, j, a.xyR[i][j]);
                  } else {
                     sparseset(&s0, i, j, a.xyR[i][j]);
                  }
               }
            }
         }
         uppercnt = 0;
         lowercnt = 0;
         for (i = 0; i < n; i++) {
            uppercnt += u.xZ[i];
            lowercnt += d.xZ[i];
         }
      // Check correctness of SparseExists()
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (i >= j && i - j > d.xZ[i]) {
                  Ok = Ok && !sparseexists(&s0, i, j);
               }
               if (i >= j && i - j <= d.xZ[i]) {
                  Ok = Ok && sparseexists(&s0, i, j);
               }
               if (i <= j && j - i > u.xZ[j]) {
                  Ok = Ok && !sparseexists(&s0, i, j);
               }
               if (i <= j && j - i <= u.xZ[j]) {
                  Ok = Ok && sparseexists(&s0, i, j);
               }
            }
         }
      // Try to call SparseRewriteExisting() for out-of-band elements, make sure that it returns False.
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (i >= j && i - j > d.xZ[i] || i <= j && j - i > u.xZ[j]) {
                  Ok = Ok && !sparserewriteexisting(&s0, i, j, 1.0);
               }
            }
         }
      // Convert to several different formats, check their contents with SparseGet().
         sparsecopy(&s0, &s1);
         sparseconverttocrs(&s1);
         sparsecopytocrs(&s0, &s2);
         sparsecopytocrsbuf(&s0, &s3);
         sparsecopytohash(&s0, &s4);
         sparsecopytohashbuf(&s0, &s5);
         sparsecopy(&s0, &s6);
         sparseconverttohash(&s6);
         Ok = Ok && sparsegetnrows(&s0) == n;
         Ok = Ok && sparsegetncols(&s0) == n;
         Ok = Ok && sparsegetmatrixtype(&s0) == 2;
         Ok = Ok && sparseissks(&s0);
         Ok = Ok && !sparseiscrs(&s0);
         Ok = Ok && !sparseishash(&s0);
         Ok = Ok && !sparseissks(&s1);
         Ok = Ok && sparseiscrs(&s1);
         Ok = Ok && !sparseishash(&s1);
         for (i = 0; i < n; i++) {
            v1 = a.xyR[i][i];
            v0 = sparsegetdiagonal(&s0, i);
            Ok = Ok && v0 == v1;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               v1 = a.xyR[i][j];
               v0 = sparseget(&s0, i, j);
               Ok = Ok && v0 == v1;
               v0 = sparseget(&s1, i, j);
               Ok = Ok && v0 == v1;
               v0 = sparseget(&s2, i, j);
               Ok = Ok && v0 == v1;
               v0 = sparseget(&s3, i, j);
               Ok = Ok && v0 == v1;
               v0 = sparseget(&s4, i, j);
               Ok = Ok && v0 == v1;
               v0 = sparseget(&s5, i, j);
               Ok = Ok && v0 == v1;
               v0 = sparseget(&s6, i, j);
               Ok = Ok && v0 == v1;
            }
         }
      // Check enumeration capabilities:
      // * each element returned by SparseEnumerate() is returned only once
      // * each non-zero element of A was enumerated
         ae_matrix_set_length(&wasenumerated, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               wasenumerated.xyB[i][j] = false;
            }
         }
         t0 = 0;
         t1 = 0;
         while (sparseenumerate(&s0, &t0, &t1, &i, &j, &v0)) {
            Ok = Ok && !wasenumerated.xyB[i][j];
            wasenumerated.xyB[i][j] = true;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (a.xyR[i][j] != 0.0) {
                  Ok = Ok && wasenumerated.xyB[i][j];
               }
            }
         }
      // Check UpperCnt()/LowerCnt()
         Ok = Ok && sparsegetuppercount(&s0) == uppercnt;
         Ok = Ok && sparsegetlowercount(&s0) == lowercnt;
      // Check in-place transposition
         sparsecopy(&s0, &s1);
         sparsetransposesks(&s1);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               v0 = sparseget(&s0, i, j);
               v1 = sparseget(&s1, j, i);
               Ok = Ok && v0 == v1;
            }
         }
      // One more check - matrix is initially created in some other format
      // (CRS or Hash) and converted to SKS later.
         sparsecreate(n, n, 0, &s0);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (a.xyR[i][j] != 0.0) {
                  sparseset(&s0, i, j, a.xyR[i][j]);
               }
            }
         }
         sparsecopy(&s0, &s1);
         sparseconverttosks(&s1);
         sparsecopytosks(&s0, &s2);
         sparsecopytosksbuf(&s0, &s3);
         Ok = Ok && sparseissks(&s1);
         Ok = Ok && !sparseiscrs(&s1);
         Ok = Ok && !sparseishash(&s1);
         Ok = Ok && sparseissks(&s2);
         Ok = Ok && !sparseiscrs(&s2);
         Ok = Ok && !sparseishash(&s2);
         Ok = Ok && sparseissks(&s3);
         Ok = Ok && !sparseiscrs(&s3);
         Ok = Ok && !sparseishash(&s3);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               v1 = a.xyR[i][j];
               v0 = sparseget(&s1, i, j);
               Ok = Ok && v0 == v1;
               v0 = sparseget(&s2, i, j);
               Ok = Ok && v0 == v1;
               v0 = sparseget(&s3, i, j);
               Ok = Ok && v0 == v1;
            }
         }
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ == 0.
         if (nz == 0) {
            break;
         }
         nz = imin2(iround(nz * 0.95), nz - 1);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing CRS-specific functionality.
// ALGLIB Project: Copyright 30.01.2018 by Sergey Bochkanov
static bool crstest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t nz;
   double pnz;
   ae_int_t i;
   ae_int_t j;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, s1);
   NewObj(sparsematrix, s2);
   NewObj(sparsematrix, s3);
   NewObj(sparsematrix, s4);
   hqrndrandomize(&rs);
   for (n = 1; n <= 10; n++) {
      for (m = 1; m <= 10; m++) {
         nz = n * m;
         while (true) {
         // Generate N*N matrix where probability of non-diagonal element
         // being non-zero is PNZ. We also generate D and U - subdiagonal
         // and superdiagonal profile sizes.
         //
         // Create matrix with either general SKS or banded SKS constructor function
            if (n > 1) {
               pnz = (double)nz / (m * n);
            } else {
               pnz = 1.0;
            }
         // Generate random matrix in HASH format (testing SparseExists()
         // during process), copy it to CRS format, compare with original
            sparsecreate(m, n, iround(nz * hqrnduniformr(&rs)), &s0);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  Ok = Ok && !sparseexists(&s0, i, j);
                  if (hqrnduniformr(&rs) <= pnz) {
                     sparseset(&s0, i, j, hqrndnormal(&rs));
                     Ok = Ok && sparseexists(&s0, i, j);
                  }
               }
            }
            sparsecopytocrs(&s0, &s1);
            Ok = Ok && sparseiscrs(&s1);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  Ok = Ok && sparseget(&s0, i, j) == sparseget(&s1, i, j);
                  Ok = Ok && (!sparseexists(&s0, i, j) || sparseexists(&s1, i, j));
                  Ok = Ok && (!sparseexists(&s1, i, j) || sparseexists(&s0, i, j));
               }
            }
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Check transposition
            sparsecopytocrs(&s1, &s2);
            sparsetransposecrs(&s2);
            Ok = Ok && sparseiscrs(&s2);
            Ok = Ok && sparsegetnrows(&s1) == sparsegetncols(&s2);
            Ok = Ok && sparsegetncols(&s1) == sparsegetnrows(&s2);
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  Ok = Ok && sparseget(&s1, i, j) == sparseget(&s2, j, i);
               }
            }
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Check transposition
            sparsecopytransposecrs(&s1, &s3);
            Ok = Ok && sparseiscrs(&s3);
            Ok = Ok && sparsegetnrows(&s1) == sparsegetncols(&s3);
            Ok = Ok && sparsegetncols(&s1) == sparsegetnrows(&s3);
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  Ok = Ok && sparseget(&s1, i, j) == sparseget(&s3, j, i);
               }
            }
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Check transposition
            sparsecopytransposecrs(&s1, &s4);
            Ok = Ok && sparseiscrs(&s4);
            Ok = Ok && sparsegetnrows(&s1) == sparsegetncols(&s4);
            Ok = Ok && sparsegetncols(&s1) == sparsegetnrows(&s4);
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  Ok = Ok && sparseget(&s1, i, j) == sparseget(&s4, j, i);
               }
            }
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Increase problem sparsity and try one more time.
         // Stop after testing NZ == 0.
            if (nz == 0) {
               break;
            }
            nz = imin2(iround(nz * 0.95), nz - 1);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing basic functional
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool basicfunctest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t j1;
   ae_int_t uppercnt;
   ae_int_t lowercnt;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewMatrix(a, 0, 0, DT_REAL);
   n = 10;
   m = 10;
   Ok = true;
   for (i = 1; i < m; i++) {
      for (j = 1; j < n; j++) {
         sparsecreate(i, j, 1, &s);
         ae_matrix_set_length(&a, i, j);
      // Checking for Matrix with hash table type
         uppercnt = 0;
         lowercnt = 0;
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               if (j1 > i1) {
                  uppercnt++;
               }
               if (j1 < i1) {
                  lowercnt++;
               }
               a.xyR[i1][j1] = i1 + j1 + (double)((i + j) * (m + n)) / 2.0;
               a.xyR[i1][j1]++;
               sparseset(&s, i1, j1, i1 + j1 + (double)((i + j) * (m + n)) / 2.0);
               sparseadd(&s, i1, j1, 1.0);
               if (a.xyR[i1][j1] != sparseget(&s, i1, j1)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
         for (i1 = 0; i1 < imin2(i, j); i1++) {
            if (a.xyR[i1][i1] != sparsegetdiagonal(&s, i1)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
         Ok = Ok && sparsegetuppercount(&s) == uppercnt;
         Ok = Ok && sparsegetlowercount(&s) == lowercnt;
      // Checking for Matrix with CRS type
         sparseconverttocrs(&s);
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               if (a.xyR[i1][j1] != sparseget(&s, i1, j1)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
         for (i1 = 0; i1 < imin2(i, j); i1++) {
            if (a.xyR[i1][i1] != sparsegetdiagonal(&s, i1)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
         Ok = Ok && sparsegetuppercount(&s) == uppercnt;
         Ok = Ok && sparsegetlowercount(&s) == lowercnt;
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function initializes sparse matrix generator, which is used to generate
// a set of matrices with sequentially increasing sparsity.
//
// Parameters:
//     M, N        -   matrix size. If M == 0, then matrix is square N*N.
//                     N and M must be small enough to store N*M dense matrix.
//     MatKind     -   matrix properties:
//                     * 0     -   general sparse (no structure)
//                     * 1     -   general sparse, but diagonal is always present and non-zero
//                     * 2     -   diagonally dominant, SPD
//     Triangle    -   triangle being returned:
//                     * +1    -   upper triangle
//                     * -1    -   lower triangle
//                     *  0    -   full matrix is returned
//
// Outputs:
//     G           -   generator
//     A           -   matrix A in dense format
//     SA          -   matrix A in sparse format (hash-table storage)
static void testsparseunit_initgenerator(ae_int_t m, ae_int_t n, ae_int_t matkind, ae_int_t triangle, sparsegenerator *g) {
   SetObj(sparsegenerator, g);
   g->n = n;
   g->m = m;
   g->matkind = matkind;
   g->triangle = triangle;
   hqrndrandomize(&g->rs);
   g->PQ = -1;
}

static bool testsparseunit_generatenext(sparsegenerator *g, RMatrix *da, sparsematrix *sa) {
   AutoS ae_int_t n;
   AutoS ae_int_t m;
   AutoS ae_int_t nz;
   AutoS ae_int_t nzd;
   AutoS double pnz;
   AutoS ae_int_t i;
   AutoS ae_int_t j;
   AutoS double v;
   SetMatrix(da);
   SetObj(sparsematrix, sa);
// Manually threaded two-way signalling.
// Locals are set arbitrarily the first time around and are retained between pauses and subsequent resumes.
// A Spawn occurs when the routine is (re-)started.
// A Pause sends an event signal and waits for a response with data before carrying out the matching Resume.
// An Exit sends an exit signal indicating the end of the process.
   if (g->PQ >= 0) switch (g->PQ) {
      case 0: goto Resume0; case 1: goto Resume1;
      default: goto Exit;
   }
Spawn:
   nz = -919;
   nzd = -909;
   i = 81;
   j = 255;
   pnz = 74;
   v = -788;
   n = g->n;
   if (g->m == 0) {
      m = n;
   } else {
      m = g->m;
   }
   ae_assert(m > 0 && n > 0, "GenerateNext: incorrect N/M");
   if (g->matkind == 0) { // Generate general sparse matrix
      for (nz = n * m; ; nz /= 2) {
      // Generate dense N*N matrix where probability of element
      // being non-zero is PNZ.
         pnz = (double)nz / (n * m);
         ae_matrix_set_length(&g->bufa, m, n);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               if (hqrnduniformr(&g->rs) <= pnz) {
                  g->bufa.xyR[i][j] = hqrnduniformr(&g->rs) - 0.5;
               } else {
                  g->bufa.xyR[i][j] = 0.0;
               }
            }
         }
      // Output matrix and RComm
         ae_matrix_set_length(da, m, n);
         sparsecreate(m, n, iround(pnz * m * n), sa);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               if (j <= i && g->triangle <= 0 || j >= i && g->triangle >= 0) {
                  da->xyR[i][j] = g->bufa.xyR[i][j];
                  sparseset(sa, i, j, g->bufa.xyR[i][j]);
               } else {
                  da->xyR[i][j] = 0.0;
               }
            }
         }
         g->PQ = 0; goto Pause; Resume0:
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ == 0.
         if (nz == 0) {
            break;
         }
      }
   } else if (g->matkind == 1) { // Generate general sparse matrix with non-zero diagonal
      ae_assert(n == m, "GenerateNext: non-square matrix for MatKind == 1");
      for (nz = n * n - n; ; nz /= 2) {
      // Generate dense N*N matrix where probability of non-diagonal element
      // being non-zero is PNZ.
         if (n > 1) {
            pnz = (double)nz / (n * n - n);
         } else {
            pnz = 1.0;
         }
         ae_matrix_set_length(&g->bufa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (i == j) {
                  do {
                     g->bufa.xyR[i][i] = hqrnduniformr(&g->rs) - 0.5;
                  } while (g->bufa.xyR[i][i] == 0.0);
                  g->bufa.xyR[i][i] += 1.5 * sign(g->bufa.xyR[i][i]);
                  continue;
               }
               if (hqrnduniformr(&g->rs) <= pnz) {
                  g->bufa.xyR[i][j] = hqrnduniformr(&g->rs) - 0.5;
               } else {
                  g->bufa.xyR[i][j] = 0.0;
               }
            }
         }
      // Output matrix and RComm
         ae_matrix_set_length(da, n, n);
         sparsecreate(n, n, iround(pnz * (n * n - n) + n), sa);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (j <= i && g->triangle <= 0 || j >= i && g->triangle >= 0) {
                  da->xyR[i][j] = g->bufa.xyR[i][j];
                  sparseset(sa, i, j, g->bufa.xyR[i][j]);
               } else {
                  da->xyR[i][j] = 0.0;
               }
            }
         }
         g->PQ = 1; goto Pause; Resume1:
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ == 0.
         if (nz == 0) {
            break;
         }
      }
   } else ae_assert(false, "Assertion failed");
Exit:
   g->PQ = -1;
   return false;
Pause:
   return true;
}

// Function for testing Level 2 unsymmetric linear algebra functions.
// Additionally it tests SparseGet() for several matrix formats.
// ALGLIB Project: Copyright 20.01.2014 by Sergey Bochkanov
static bool testlevel2unsymmetric() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   double eps;
   double v;
   ae_int_t ix;
   ae_int_t iy;
   double alpha;
   double beta;
   ae_int_t ops;
   ae_int_t opm;
   ae_int_t opn;
   ae_int_t alphakind;
   ae_int_t betakind;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, sa);
   NewObj(sparsegenerator, g);
   NewObj(hqrndstate, rs);
   eps = 10000.0 * machineepsilon;
   Ok = true;
   hqrndrandomize(&rs);
// Test linear algebra functions
   for (m = 1; m <= 20; m++) {
      for (n = 1; n <= 20; n++) {
         for (testsparseunit_initgenerator(m, n, 0, 0, &g); testsparseunit_generatenext(&g, &a, &sa); ) {
         // Convert SA to desired storage format:
         // * to CRS if M != N
         // * with 50% probability to CRS or SKS, if M == N
            if (m != n || hqrnduniformr(&rs) < 0.5) {
               sparsecopytocrs(&sa, &s0);
            } else {
               sparsecopytosks(&sa, &s0);
            }
         // Test SparseGet() for SA and S0 against matrix returned in A
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  Ok = Ok && NearAtR(sparseget(&sa, i, j), a.xyR[i][j], eps);
                  Ok = Ok && NearAtR(sparseget(&s0, i, j), a.xyR[i][j], eps);
               }
            }
         // Test SparseMV
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&x1, n);
            for (j = 0; j < n; j++) {
               x0.xR[j] = hqrnduniformr(&rs) - 0.5;
               x1.xR[j] = x0.xR[j];
            }
            sparsemv(&s0, &x0, &y0);
            Ok = Ok && y0.cnt >= m;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < m; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
               Ok = Ok && NearAtR(v, y0.xR[i], eps);
            }
         // Test SparseMTV
            ae_vector_set_length(&x0, m);
            ae_vector_set_length(&x1, m);
            for (j = 0; j < m; j++) {
               x0.xR[j] = hqrnduniformr(&rs) - 0.5;
               x1.xR[j] = x0.xR[j];
            }
            sparsemtv(&s0, &x0, &y0);
            Ok = Ok && y0.cnt >= n;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (j = 0; j < n; j++) {
               v = ae_v_dotproduct(&a.xyR[0][j], a.stride, x1.xR, 1, m);
               Ok = Ok && NearAtR(v, y0.xR[j], eps);
            }
         // Sparse GEMV
            for (ops = 0; ops <= 1; ops++) {
               for (alphakind = 0; alphakind <= 1; alphakind++) {
                  for (betakind = 0; betakind <= 1; betakind++) {
                  // Prepare inputs for testing
                     ix = hqrnduniformi(&rs, 50);
                     iy = hqrnduniformi(&rs, 50);
                     alpha = alphakind * hqrndnormal(&rs);
                     beta = betakind * hqrndnormal(&rs);
                     if (ops == 0) {
                        opm = m;
                        opn = n;
                     } else {
                        opm = n;
                        opn = m;
                     }
                     ae_vector_set_length(&x0, ix + opn);
                     ae_vector_set_length(&x1, ix + opn);
                     for (j = 0; j < ix + opn; j++) {
                        x0.xR[j] = hqrnduniformr(&rs) - 0.5;
                        x1.xR[j] = x0.xR[j];
                     }
                     ae_vector_set_length(&y0, iy + opm);
                     ae_vector_set_length(&y1, iy + opm);
                     for (j = 0; j < iy + opm; j++) {
                        y0.xR[j] = hqrnduniformr(&rs) - 0.5;
                        y1.xR[j] = y0.xR[j];
                     }
                  // Prepare reference result in Y1
                     for (i = 0; i < opm; i++) {
                        v = 0.0;
                        for (j = 0; j < opn; j++) {
                           if (ops == 0) {
                              v += a.xyR[i][j] * x1.xR[ix + j];
                           } else {
                              v += a.xyR[j][i] * x1.xR[ix + j];
                           }
                        }
                        y1.xR[iy + i] = alpha * v + beta * y1.xR[iy + i];
                     }
                  // Test
                     sparsegemv(&s0, alpha, ops, &x0, ix, beta, &y0, iy);
                     for (j = 0; j < iy + opm; j++) {
                        Ok = Ok && NearAtR(y0.xR[j], y1.xR[j], eps);
                     }
                  }
               }
            }
         // Test SparseMV2
            if (m == n) {
               ae_vector_set_length(&x0, n);
               ae_vector_set_length(&x1, n);
               for (j = 0; j < n; j++) {
                  x0.xR[j] = hqrnduniformr(&rs) - 0.5;
                  x1.xR[j] = x0.xR[j];
               }
               sparsemv2(&s0, &x0, &y0, &y1);
               Ok = Ok && y0.cnt >= n;
               Ok = Ok && y1.cnt >= n;
               if (!Ok) {
                  ae_frame_leave();
                  return Ok;
               }
               for (j = 0; j < n; j++) {
                  v = ae_v_dotproduct(a.xyR[j], 1, x1.xR, 1, n);
                  Ok = Ok && NearAtR(v, y0.xR[j], eps);
                  v = ae_v_dotproduct(&a.xyR[0][j], a.stride, x1.xR, 1, n);
                  Ok = Ok && NearAtR(v, y1.xR[j], eps);
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing Level 3 unsymmetric linear algebra functions.
// Additionally it tests SparseGet() for several matrix formats.
// ALGLIB Project: Copyright 20.01.2014 by Sergey Bochkanov
static bool testlevel3unsymmetric() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t k;
   ae_int_t i;
   ae_int_t j;
   double eps;
   double v;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(x0, 0, 0, DT_REAL);
   NewMatrix(x1, 0, 0, DT_REAL);
   NewMatrix(y0, 0, 0, DT_REAL);
   NewMatrix(y1, 0, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, sa);
   NewObj(sparsegenerator, g);
   NewObj(hqrndstate, rs);
   eps = 10000.0 * machineepsilon;
   Ok = true;
   hqrndrandomize(&rs);
// Test linear algebra functions
   for (m = 1; m <= 20; m++) {
      for (n = 1; n <= 20; n++) {
         for (testsparseunit_initgenerator(m, n, 0, 0, &g); testsparseunit_generatenext(&g, &a, &sa); ) {
         // Choose matrix width K
            k = 1 + hqrnduniformi(&rs, 20);
         // Convert SA to desired storage format:
         // * to CRS if M != N
         // * with 50% probability to CRS or SKS, if M == N
            if (m != n || hqrnduniformr(&rs) < 0.5) {
               sparsecopytocrs(&sa, &s0);
            } else {
               sparsecopytosks(&sa, &s0);
            }
         // Test SparseGet() for SA and S0 against matrix returned in A
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  Ok = Ok && sparseget(&sa, i, j) == a.xyR[i][j];
                  Ok = Ok && sparseget(&s0, i, j) == a.xyR[i][j];
               }
            }
         // Test SparseMV
            ae_matrix_set_length(&x0, n, k);
            ae_matrix_set_length(&x1, n, k);
            for (i = 0; i < n; i++) {
               for (j = 0; j < k; j++) {
                  x0.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                  x1.xyR[i][j] = x0.xyR[i][j];
               }
            }
            sparsemm(&s0, &x0, k, &y0);
            Ok = Ok && y0.rows >= m;
            Ok = Ok && y0.cols >= k;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < k; j++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, &x1.xyR[0][j], x1.stride, n);
                  Ok = Ok && NearAtR(v, y0.xyR[i][j], eps);
               }
            }
         // Test SparseMTM
            ae_matrix_set_length(&x0, m, k);
            ae_matrix_set_length(&x1, m, k);
            for (i = 0; i < m; i++) {
               for (j = 0; j < k; j++) {
                  x0.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                  x1.xyR[i][j] = x0.xyR[i][j];
               }
            }
            sparsemtm(&s0, &x0, k, &y0);
            Ok = Ok && y0.rows >= n;
            Ok = Ok && y0.cols >= k;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < k; j++) {
                  v = ae_v_dotproduct(&a.xyR[0][i], a.stride, &x1.xyR[0][j], x1.stride, m);
                  Ok = Ok && NearAtR(v, y0.xyR[i][j], eps);
               }
            }
         // Test SparseMM2
            if (m == n) {
               ae_matrix_set_length(&x0, n, k);
               ae_matrix_set_length(&x1, n, k);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < k; j++) {
                     x0.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                     x1.xyR[i][j] = x0.xyR[i][j];
                  }
               }
               sparsemm2(&s0, &x0, k, &y0, &y1);
               Ok = Ok && y0.rows >= n;
               Ok = Ok && y0.cols >= k;
               Ok = Ok && y1.rows >= n;
               Ok = Ok && y1.cols >= k;
               if (!Ok) {
                  ae_frame_leave();
                  return Ok;
               }
               for (i = 0; i < n; i++) {
                  for (j = 0; j < k; j++) {
                     v = ae_v_dotproduct(a.xyR[i], 1, &x1.xyR[0][j], x1.stride, n);
                     Ok = Ok && NearAtR(v, y0.xyR[i][j], eps);
                     v = ae_v_dotproduct(&a.xyR[0][i], a.stride, &x1.xyR[0][j], x1.stride, n);
                     Ok = Ok && NearAtR(v, y1.xyR[i][j], eps);
                  }
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing Level 2 symmetric linear algebra functions.
// Additionally it tests SparseGet() for several matrix formats.
// ALGLIB Project: Copyright 20.01.2014 by Sergey Bochkanov
static bool testlevel2symmetric() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   double eps;
   double v;
   double va;
   double vb;
   bool isupper;
   ae_int_t triangletype;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, s1);
   NewObj(sparsematrix, sa);
   NewObj(sparsegenerator, g);
   NewObj(hqrndstate, rs);
   eps = 10000.0 * machineepsilon;
   Ok = true;
   hqrndrandomize(&rs);
// Test linear algebra functions
   for (n = 1; n <= 20; n++) {
      for (triangletype = -1; triangletype <= 1; triangletype++) {
         isupper = hqrnduniformr(&rs) > 0.5;
         if (triangletype < 0) {
            isupper = false;
         }
         if (triangletype > 0) {
            isupper = true;
         }
         for (testsparseunit_initgenerator(n, n, 0, triangletype, &g); testsparseunit_generatenext(&g, &a, &sa); ) {
         // Convert SA to desired storage format:
         // * S0 stores unmodified copy
         // * S1 stores copy with unmodified triangle corresponding
         //   to IsUpper and another triangle being spoiled by random
         //   trash
            sparsecopytohash(&sa, &s1);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper? j < i: j > i) {
                     sparseset(&s1, i, j, hqrnduniformr(&rs));
                  }
               }
            }
            if (hqrnduniformr(&rs) < 0.5) {
               sparsecopytocrs(&sa, &s0);
               sparseconverttocrs(&s1);
            } else {
               sparsecopytosks(&sa, &s0);
               sparseconverttosks(&s1);
            }
         // Test SparseGet() for SA and S0 against matrix returned in A
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  Ok = Ok && NearAtR(sparseget(&sa, i, j), a.xyR[i][j], eps);
                  Ok = Ok && NearAtR(sparseget(&s0, i, j), a.xyR[i][j], eps);
                  Ok = Ok && (j >= i || triangletype != +1 || sparseget(&s0, i, j) == 0.0);
                  Ok = Ok && (j <= i || triangletype != -1 || sparseget(&s0, i, j) == 0.0);
               }
            }
         // Before we proceed with testing, update empty triangle of A
         // with its copy from another part of the matrix.
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper? j < i: j > i) {
                     a.xyR[i][j] = a.xyR[j][i];
                  }
               }
            }
         // Test SparseSMV
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&x1, n);
            for (j = 0; j < n; j++) {
               x0.xR[j] = hqrnduniformr(&rs) - 0.5;
               x1.xR[j] = x0.xR[j];
            }
            sparsesmv(&s0, isupper, &x0, &y0);
            Ok = Ok && y0.cnt >= n;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
               Ok = Ok && NearAtR(v, y0.xR[i], eps);
            }
            sparsesmv(&s1, isupper, &x0, &y1);
            Ok = Ok && y1.cnt >= n;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
               Ok = Ok && NearAtR(v, y1.xR[i], eps);
            }
         // Test SparseVSMV
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&x1, n);
            for (j = 0; j < n; j++) {
               x0.xR[j] = hqrnduniformr(&rs) - 0.5;
               x1.xR[j] = x0.xR[j];
            }
            vb = 0.0;
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  vb += x1.xR[i] * a.xyR[i][j] * x1.xR[j];
               }
            }
            va = sparsevsmv(&s0, isupper, &x0);
            Ok = Ok && NearAtR(va, vb, eps);
            va = sparsevsmv(&s1, isupper, &x0);
            Ok = Ok && NearAtR(va, vb, eps);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing Level 2 symmetric linear algebra functions.
// Additionally it tests SparseGet() for several matrix formats.
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool testlevel3symmetric() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t k;
   ae_int_t i;
   ae_int_t j;
   double eps;
   double v;
   bool isupper;
   ae_int_t triangletype;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(x0, 0, 0, DT_REAL);
   NewMatrix(x1, 0, 0, DT_REAL);
   NewMatrix(y0, 0, 0, DT_REAL);
   NewMatrix(y1, 0, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, s1);
   NewObj(sparsematrix, sa);
   NewObj(sparsegenerator, g);
   NewObj(hqrndstate, rs);
   eps = 10000.0 * machineepsilon;
   Ok = true;
   hqrndrandomize(&rs);
// Test linear algebra functions
   for (n = 1; n <= 20; n++) {
      for (triangletype = -1; triangletype <= 1; triangletype++) {
         isupper = hqrnduniformr(&rs) > 0.5;
         if (triangletype < 0) {
            isupper = false;
         }
         if (triangletype > 0) {
            isupper = true;
         }
         for (testsparseunit_initgenerator(n, n, 0, triangletype, &g); testsparseunit_generatenext(&g, &a, &sa); ) {
         // Choose matrix width K
            k = 1 + hqrnduniformi(&rs, 20);
         // Convert SA to desired storage format:
         // * S0 stores unmodified copy
         // * S1 stores copy with unmodified triangle corresponding
         //   to IsUpper and another triangle being spoiled by random
         //   trash
            sparsecopytohash(&sa, &s1);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper? j < i: j > i) {
                     sparseset(&s1, i, j, hqrnduniformr(&rs));
                  }
               }
            }
            if (hqrnduniformr(&rs) < 0.5) {
               sparsecopytocrs(&sa, &s0);
               sparseconverttocrs(&s1);
            } else {
               sparsecopytosks(&sa, &s0);
               sparseconverttosks(&s1);
            }
         // Test SparseGet() for SA and S0 against matrix returned in A
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  Ok = Ok && NearAtR(sparseget(&sa, i, j), a.xyR[i][j], eps);
                  Ok = Ok && NearAtR(sparseget(&s0, i, j), a.xyR[i][j], eps);
                  Ok = Ok && (j >= i || triangletype != +1 || sparseget(&s0, i, j) == 0.0);
                  Ok = Ok && (j <= i || triangletype != -1 || sparseget(&s0, i, j) == 0.0);
               }
            }
         // Before we proceed with testing, update empty triangle of A
         // with its copy from another part of the matrix.
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper? j < i: j > i) {
                     a.xyR[i][j] = a.xyR[j][i];
                  }
               }
            }
         // Test SparseSMM
            ae_matrix_set_length(&x0, n, k);
            ae_matrix_set_length(&x1, n, k);
            for (i = 0; i < n; i++) {
               for (j = 0; j < k; j++) {
                  x0.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                  x1.xyR[i][j] = x0.xyR[i][j];
               }
            }
            sparsesmm(&s0, isupper, &x0, k, &y0);
            Ok = Ok && y0.rows >= n;
            Ok = Ok && y0.cols >= k;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < k; j++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, &x1.xyR[0][j], x1.stride, n);
                  Ok = Ok && NearAtR(v, y0.xyR[i][j], eps);
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing sparse symmetric permutations
// ALGLIB Project: Copyright 07.10.2020 by Sergey Bochkanov
static bool testsymmetricperm() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t functype;
   ae_int_t i;
   ae_int_t j;
   bool isupper;
   double eps;
   double nzprob;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(da, 0, 0, DT_REAL);
   NewMatrix(db, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewObj(sparsematrix, sb);
   NewVector(ptbl, 0, DT_INT);
   NewVector(pprod, 0, DT_INT);
   eps = 10.0 * machineepsilon;
   Ok = true;
   hqrndrandomize(&rs);
// Try various N and fill factors
   for (n = 1; n <= 20; n++) {
      nzprob = 1.0;
      while (nzprob >= 0.1 / (n * n)) {
      // Generate matrix with desired fill factor, randomly select one triangle,
      // generate random permutation (in table and product form)
         sparsecreate(n, n, 0, &sa);
         ae_matrix_set_length(&da, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (hqrnduniformr(&rs) < nzprob) {
                  da.xyR[i][j] = hqrndnormal(&rs);
                  sparseset(&sa, i, j, da.xyR[i][j]);
               } else {
                  da.xyR[i][j] = 0.0;
               }
            }
         }
         sparseconverttocrs(&sa);
         isupper = hqrndnormal(&rs) > 0.0;
         for (i = 0; i < n; i++) {
            for (j = 0; j <= i; j++) {
               if (isupper) {
                  da.xyR[i][j] = da.xyR[j][i];
               } else {
                  da.xyR[j][i] = da.xyR[i][j];
               }
            }
         }
         ae_vector_set_length(&ptbl, n);
         ae_vector_set_length(&pprod, n);
         for (i = 0; i < n; i++) {
            ptbl.xZ[i] = i;
         }
         for (i = 0; i < n; i++) {
            pprod.xZ[i] = i + hqrnduniformi(&rs, n - i);
            swapi(&ptbl.xZ[i], &ptbl.xZ[pprod.xZ[i]]);
         }
         ae_matrix_set_length(&db, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               db.xyR[ptbl.xZ[i]][ptbl.xZ[j]] = da.xyR[i][j];
            }
         }
      // Select function to test, run and test
         functype = hqrnduniformi(&rs, 2);
         if (functype == 0) {
            sparsesymmpermtblbuf(&sa, isupper, &ptbl, &sb);
         }
         if (functype == 1) {
            sparsesymmpermtbl(&sa, isupper, &ptbl, &sb);
         }
         Ok = Ok && sparseiscrs(&sb);
         Ok = Ok && sparsegetnrows(&sb) == n;
         Ok = Ok && sparsegetncols(&sb) == n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         if (isupper)
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  Ok = Ok && (j < i? sparseget(&sb, i, j) == 0.0: NearAtR(db.xyR[i][j], sparseget(&sb, i, j), eps));
               }
            }
      // Increase sparsity
         nzprob *= 0.75;
      }
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing Level 2 triangular linear algebra functions.
// ALGLIB Project: Copyright 20.01.2014 by Sergey Bochkanov
static bool testlevel2triangular() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t j1;
   double eps;
   double v;
   bool isupper;
   bool isunit;
   ae_int_t optype;
   ae_int_t triangletype;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(ey, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ea, 0, 0, DT_REAL);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, s1);
   NewObj(sparsematrix, sa);
   NewObj(sparsegenerator, g);
   NewObj(hqrndstate, rs);
   eps = 10000.0 * machineepsilon;
   Ok = true;
   hqrndrandomize(&rs);
// Test sparseTRMV
   for (n = 1; n <= 20; n++) {
      for (triangletype = -1; triangletype <= 1; triangletype++) {
         isupper = hqrnduniformr(&rs) > 0.5;
         if (triangletype < 0) {
            isupper = false;
         }
         if (triangletype > 0) {
            isupper = true;
         }
         for (testsparseunit_initgenerator(n, n, 0, triangletype, &g); testsparseunit_generatenext(&g, &a, &sa); ) {
         // Settings (IsUpper was already set, handle the rest)
            isunit = hqrnduniformr(&rs) < 0.5;
            optype = hqrnduniformi(&rs, 2);
         // Convert SA to desired storage format:
         // * S0 stores unmodified copy
         // * S1 stores copy with unmodified triangle corresponding
         //   to IsUpper and another triangle being spoiled by random
         //   trash
            sparsecopytohash(&sa, &s1);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper? j < i: j > i) {
                     sparseset(&s1, i, j, hqrnduniformr(&rs));
                  }
               }
            }
            if (hqrnduniformr(&rs) < 0.5) {
               sparsecopytocrs(&sa, &s0);
               sparseconverttocrs(&s1);
            } else {
               sparsecopytosks(&sa, &s0);
               sparseconverttosks(&s1);
            }
         // Generate "effective A"
            ae_matrix_set_length(&ea, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  ea.xyR[i][j] = 0.0;
               }
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper? j >= i: j <= i) {
                     i1 = i;
                     j1 = j;
                     if (optype == 1) {
                        swapi(&i1, &j1);
                     }
                     ea.xyR[i1][j1] = a.xyR[i][j];
                     if (isunit && i1 == j1) {
                        ea.xyR[i1][j1] = 1.0;
                     }
                  }
               }
            }
         // Test SparseTRMV
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&x1, n);
            for (j = 0; j < n; j++) {
               x0.xR[j] = hqrnduniformr(&rs) - 0.5;
               x1.xR[j] = x0.xR[j];
            }
            sparsetrmv(&s0, isupper, isunit, optype, &x0, &y0);
            Ok = Ok && y0.cnt >= n;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(ea.xyR[i], 1, x1.xR, 1, n);
               Ok = Ok && NearAtR(v, y0.xR[i], eps);
            }
            sparsetrmv(&s0, isupper, isunit, optype, &x0, &y1);
            Ok = Ok && y1.cnt >= n;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(ea.xyR[i], 1, x1.xR, 1, n);
               Ok = Ok && NearAtR(v, y1.xR[i], eps);
            }
         }
      }
   }
// Test sparseTRSV
   for (n = 1; n <= 20; n++) {
      for (triangletype = -1; triangletype <= 1; triangletype++) {
         isupper = hqrnduniformr(&rs) > 0.5;
         if (triangletype == -1) {
            isupper = false;
         }
         if (triangletype == +1) {
            isupper = true;
         }
         for (testsparseunit_initgenerator(n, n, 1, triangletype, &g); testsparseunit_generatenext(&g, &a, &sa); ) {
         // Settings (IsUpper was already set, handle the rest)
            isunit = hqrnduniformr(&rs) < 0.5;
            optype = hqrnduniformi(&rs, 2);
         // Convert SA to desired storage format:
         // * S0 stores unmodified copy
         // * S1 stores copy with unmodified triangle corresponding
         //   to IsUpper and another triangle being spoiled by random
         //   trash
            sparsecopytohash(&sa, &s1);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper? j < i: j > i) {
                     sparseset(&s1, i, j, hqrnduniformr(&rs));
                  }
               }
            }
            if (hqrnduniformr(&rs) < 0.5) {
               sparsecopytocrs(&sa, &s0);
               sparseconverttocrs(&s1);
            } else {
               sparsecopytosks(&sa, &s0);
               sparseconverttosks(&s1);
            }
         // Generate "effective A" and EY = inv(EA)*x0
            ae_matrix_set_length(&ea, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  ea.xyR[i][j] = 0.0;
               }
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper? j >= i: j <= i) {
                     i1 = i;
                     j1 = j;
                     if (optype == 1) {
                        swapi(&i1, &j1);
                     }
                     ea.xyR[i1][j1] = a.xyR[i][j];
                     if (isunit && i1 == j1) {
                        ea.xyR[i1][j1] = 1.0;
                     }
                  }
               }
            }
            ae_vector_set_length(&ey, n);
            for (i = 0; i < n; i++) {
               ey.xR[i] = hqrnduniformr(&rs) - 0.5;
            }
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&x1, n);
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(ea.xyR[i], 1, ey.xR, 1, n);
               x0.xR[i] = v;
               x1.xR[i] = v;
            }
         // Test SparseTRSV
            sparsetrsv(&s0, isupper, isunit, optype, &x0);
            Ok = Ok && x0.cnt >= n;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               Ok = Ok && NearAtR(ey.xR[i], x0.xR[i], eps);
            }
            sparsetrsv(&s1, isupper, isunit, optype, &x1);
            Ok = Ok && x1.cnt >= n;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               Ok = Ok && NearAtR(ey.xR[i], x1.xR[i], eps);
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing basic functional
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool basicfuncrandomtest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t j1;
   ae_int_t mfigure;
   ae_int_t temp;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewMatrix(a, 0, 0, DT_REAL);
   n = 20;
   m = 20;
   mfigure = 10;
   for (i = 1; i < m; i++) {
      for (j = 1; j < n; j++) {
         sparsecreate(i, j, 0, &s);
         ae_matrix_set_length(&a, i, j);
      // Checking for Matrix with hash table type
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               temp = 2.0 * randominteger(mfigure) - mfigure;
               a.xyR[i1][j1] = (double)temp;
               if (randominteger(2) == 0) {
                  sparseset(&s, i1, j1, (double)temp);
                  sparseset(&s, i1, j1, (double)temp);
               } else {
                  sparseadd(&s, i1, j1, (double)temp);
                  sparseadd(&s, i1, j1, 0.0);
               }
               if (a.xyR[i1][j1] != sparseget(&s, i1, j1)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      // Nulling all elements
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               if (randominteger(2) == 0) {
                  sparseset(&s, i1, j1, 0.0);
               } else {
                  sparseadd(&s, i1, j1, -1 * sparseget(&s, i1, j1));
               }
            }
         }
      // Again initialization of the matrix and check new values
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               temp = 2.0 * randominteger(mfigure) - mfigure;
               a.xyR[i1][j1] = (double)temp;
               if (randominteger(2) == 0) {
                  sparseset(&s, i1, j1, (double)temp);
               } else {
                  sparseadd(&s, i1, j1, (double)temp);
               }
               if (a.xyR[i1][j1] != sparseget(&s, i1, j1)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      // Checking for Matrix with CRS type
         sparseconverttocrs(&s);
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               if (a.xyR[i1][j1] != sparseget(&s, i1, j1)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This function creates random sparse matrix with some prescribed pattern.
//
// Inputs:
//     M       -   number of rows
//     N       -   number of columns
//     PKind   -   sparsity pattern:
//                 *-1 = pattern is chosen at random as well as P0/P1
//                 * 0 = matrix with up to P0 non-zero elements at random locations
//                       (however, actual number of non-zero elements can be
//                       less than P0, and in fact can be zero)
//                 * 1 = band matrix with P0 non-zero elements below diagonal
//                       and P1 non-zero element above diagonal
//                 * 2 = matrix with random number of contiguous non-zero
//                       elements in the each row
//     CKind   -   creation type:
//                 *-1 = CKind is chosen at random
//                 * 0 = matrix is created in Hash-Table format and converted
//                       to CRS representation
//                 * 1 = matrix is created in CRS format
//
// Outputs:
//     DA      -   dense representation of A, array[M,N]
//     SA      -   sparse representation of A, in CRS format
//
// ALGLIB Project: Copyright 31.10.2011 by Sergey Bochkanov
static void testsparseunit_createrandom(ae_int_t m, ae_int_t n, ae_int_t pkind, ae_int_t ckind, ae_int_t p0, ae_int_t p1, RMatrix *da, sparsematrix *sa) {
   ae_frame _frame_block;
   ae_int_t maxpkind;
   ae_int_t maxckind;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_frame_make(&_frame_block);
   SetMatrix(da);
   SetObj(sparsematrix, sa);
   NewVector(c0, 0, DT_INT);
   NewVector(c1, 0, DT_INT);
   NewVector(rowsizes, 0, DT_INT);
   maxpkind = 2;
   maxckind = 1;
   ae_assert(m >= 1, "CreateRandom: incorrect parameters");
   ae_assert(n >= 1, "CreateRandom: incorrect parameters");
   ae_assert(pkind >= -1 && pkind <= maxpkind, "CreateRandom: incorrect parameters");
   ae_assert(ckind >= -1 && ckind <= maxckind, "CreateRandom: incorrect parameters");
   if (pkind == -1) {
      pkind = randominteger(maxpkind + 1);
      if (pkind == 0) {
         p0 = randominteger(m * n);
      }
      if (pkind == 1) {
         p0 = randominteger(imin2(m, n));
         p1 = randominteger(imin2(m, n));
      }
   }
   if (ckind == -1) {
      ckind = randominteger(maxckind + 1);
   }
   if (pkind == 0) {
   // Matrix with elements at random locations
      ae_matrix_set_length(da, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            da->xyR[i][j] = 0.0;
         }
      }
      if (ckind == 0) {
      // Create matrix in Hash format, convert to CRS
         sparsecreate(m, n, 1, sa);
         for (k = 0; k < p0; k++) {
            i = randominteger(m);
            j = randominteger(n);
            v = (double)(randominteger(17) - 8) / 8.0;
            if (randombool()) {
               da->xyR[i][j] = v;
               sparseset(sa, i, j, v);
            } else {
               da->xyR[i][j] += v;
               sparseadd(sa, i, j, v);
            }
         }
         sparseconverttocrs(sa);
         ae_frame_leave();
         return;
      }
      if (ckind == 1) {
      // Create matrix in CRS format
         for (k = 0; k < p0; k++) {
            i = randominteger(m);
            j = randominteger(n);
            v = (double)(randominteger(17) - 8) / 8.0;
            da->xyR[i][j] = v;
         }
         ae_vector_set_length(&rowsizes, m);
         for (i = 0; i < m; i++) {
            rowsizes.xZ[i] = 0;
            for (j = 0; j < n; j++) {
               if (da->xyR[i][j] != 0.0) {
                  rowsizes.xZ[i]++;
               }
            }
         }
         sparsecreatecrs(m, n, &rowsizes, sa);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               if (da->xyR[i][j] != 0.0) {
                  sparseset(sa, i, j, da->xyR[i][j]);
               }
            }
         }
         ae_frame_leave();
         return;
      }
      ae_assert(false, "CreateRandom: internal error");
   }
   if (pkind == 1) {
   // Band matrix
      ae_matrix_set_length(da, m, n);
      ae_vector_set_length(&rowsizes, m);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            da->xyR[i][j] = 0.0;
         }
      }
      for (i = 0; i < m; i++) {
         for (j = imax2(i - p0, 0); j <= i + p1 && j < n; j++) {
            do {
               da->xyR[i][j] = (double)(randominteger(17) - 8) / 8.0;
            } while (da->xyR[i][j] == 0.0);
         }
         rowsizes.xZ[i] = imax2(imin2(i + p1, n - 1) - imax2(i - p0, 0) + 1, 0);
      }
      if (ckind == 0) {
         sparsecreate(m, n, 1, sa);
      }
      if (ckind == 1) {
         sparsecreatecrs(m, n, &rowsizes, sa);
      }
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            if (da->xyR[i][j] != 0.0) {
               sparseset(sa, i, j, da->xyR[i][j]);
            }
         }
      }
      sparseconverttocrs(sa);
      ae_frame_leave();
      return;
   }
   if (pkind == 2) {
   // Matrix with one contiguous sequence of non-zero elements per row
      ae_matrix_set_length(da, m, n);
      ae_vector_set_length(&rowsizes, m);
      ae_vector_set_length(&c0, m);
      ae_vector_set_length(&c1, m);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            da->xyR[i][j] = 0.0;
         }
      }
      for (i = 0; i < m; i++) {
         c0.xZ[i] = randominteger(n);
         c1.xZ[i] = c0.xZ[i] + randominteger(n - c0.xZ[i] + 1);
         rowsizes.xZ[i] = c1.xZ[i] - c0.xZ[i];
      }
      for (i = 0; i < m; i++) {
         for (j = c0.xZ[i]; j < c1.xZ[i]; j++) {
            do {
               da->xyR[i][j] = (double)(randominteger(17) - 8) / 8.0;
            } while (da->xyR[i][j] == 0.0);
         }
      }
      if (ckind == 0) {
         sparsecreate(m, n, 1, sa);
      }
      if (ckind == 1) {
         sparsecreatecrs(m, n, &rowsizes, sa);
      }
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            if (da->xyR[i][j] != 0.0) {
               sparseset(sa, i, j, da->xyR[i][j]);
            }
         }
      }
      sparseconverttocrs(sa);
      ae_frame_leave();
      return;
   }
   ae_frame_leave();
}

// Function for testing multyplication matrix with vector
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool linearfunctionstest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t j1;
   double lb;
   double rb;
   double eps;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(ty, 0, DT_REAL);
   NewVector(tyt, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(yt, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(yt0, 0, DT_REAL);
// Accuracy
   eps = 1000.0 * machineepsilon;
// Size of the matrix (m*n)
   n = 10;
   m = 10;
// Left and right borders, limiting matrix values
   lb = -10.0;
   rb = 10.0;
// Test linear algebra functions for:
// a) sparse matrix converted to CRS from Hash-Table
// b) sparse matrix initially created as CRS
   for (i = 1; i < m; i++) {
      for (j = 1; j < n; j++) {
      // Prepare test problem
         testsparseunit_createrandom(i, j, -1, -1, -1, -1, &a, &s);
      // Initialize temporaries
         ae_vector_set_length(&ty, i);
         ae_vector_set_length(&tyt, j);
         for (i1 = 0; i1 < i; i1++) {
            ty.xR[i1] = 0.0;
         }
         for (i1 = 0; i1 < j; i1++) {
            tyt.xR[i1] = 0.0;
         }
         ae_vector_set_length(&x0, j);
         ae_vector_set_length(&x1, i);
         for (i1 = 0; i1 < j; i1++) {
            x0.xR[i1] = (rb - lb) * randomreal() + lb;
         }
         for (i1 = 0; i1 < i; i1++) {
            x1.xR[i1] = (rb - lb) * randomreal() + lb;
         }
      // Consider two cases: square matrix, and non-square matrix
         if (i != j) {
         // Searching true result
            for (i1 = 0; i1 < i; i1++) {
               for (j1 = 0; j1 < j; j1++) {
                  ty.xR[i1] += a.xyR[i1][j1] * x0.xR[j1];
                  tyt.xR[j1] += a.xyR[i1][j1] * x1.xR[i1];
               }
            }
         // Multiplication
            sparsemv(&s, &x0, &y);
            sparsemtv(&s, &x1, &yt);
         // Check for MV-result
            for (i1 = 0; i1 < i; i1++) {
               if (!NearR(y.xR[i1], ty.xR[i1], eps)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         // Check for MTV-result
            for (i1 = 0; i1 < j; i1++) {
               if (!NearR(yt.xR[i1], tyt.xR[i1], eps)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         } else {
         // Searching true result
            for (i1 = 0; i1 < i; i1++) {
               for (j1 = 0; j1 < j; j1++) {
                  ty.xR[i1] += a.xyR[i1][j1] * x0.xR[j1];
                  tyt.xR[j1] += a.xyR[i1][j1] * x0.xR[i1];
               }
            }
            sparsemv(&s, &x0, &y);
            sparsemtv(&s, &x0, &yt);
            sparsemv2(&s, &x0, &y0, &yt0);
         // Check for MV2-result
            for (i1 = 0; i1 < i; i1++) {
               if (!NearR(y0.xR[i1], ty.xR[i1], eps) || !NearR(yt0.xR[i1], tyt.xR[i1], eps)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         // Check for MV- and MTV-result by help MV2
            for (i1 = 0; i1 < i; i1++) {
               if (!NearAtR(y0.xR[i1], y.xR[i1], eps) || !NearAtR(yt0.xR[i1], yt.xR[i1], eps)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Function for testing multyplication for simmetric matrix with vector
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool linearfunctionsstest() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t i;
   ae_int_t i1;
   ae_int_t j1;
   double lb;
   double rb;
   double eps;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(ty, 0, DT_REAL);
   NewVector(tyt, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(yt, 0, DT_REAL);
// Accuracy
   eps = 1000.0 * machineepsilon;
// Size of the matrix (m*m)
   m = 10;
// Left and right borders, limiting matrix values
   lb = -10.0;
   rb = 10.0;
// Test linear algebra functions for:
// a) sparse matrix converted to CRS from Hash-Table
// b) sparse matrix initially created as CRS
   for (i = 1; i < m; i++) {
   // Prepare test problem
      testsparseunit_createrandom(i, i, -1, -1, -1, -1, &a, &s);
   // Initialize temporaries
      ae_vector_set_length(&ty, i);
      ae_vector_set_length(&tyt, i);
      ae_vector_set_length(&x0, i);
      ae_vector_set_length(&x1, i);
      for (i1 = 0; i1 < i; i1++) {
         ty.xR[i1] = 0.0;
         tyt.xR[i1] = 0.0;
         x0.xR[i1] = (rb - lb) * randomreal() + lb;
         x1.xR[i1] = (rb - lb) * randomreal() + lb;
      }
   // Searching true result for upper and lower triangles
   // of the matrix
      for (i1 = 0; i1 < i; i1++) {
         for (j1 = i1; j1 < i; j1++) {
            ty.xR[i1] += a.xyR[i1][j1] * x0.xR[j1];
            if (i1 != j1) {
               ty.xR[j1] += a.xyR[i1][j1] * x0.xR[i1];
            }
         }
      }
      for (i1 = 0; i1 < i; i1++) {
         for (j1 = 0; j1 <= i1; j1++) {
            tyt.xR[i1] += a.xyR[i1][j1] * x1.xR[j1];
            if (i1 != j1) {
               tyt.xR[j1] += a.xyR[i1][j1] * x1.xR[i1];
            }
         }
      }
   // Multiplication
      sparsesmv(&s, true, &x0, &y);
      sparsesmv(&s, false, &x1, &yt);
   // Check for SMV-result
      for (i1 = 0; i1 < i; i1++) {
         if (!NearR(y.xR[i1], ty.xR[i1], eps) || !NearR(yt.xR[i1], tyt.xR[i1], eps)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Function for testing multyplication sparse matrix with nerrow dense matrix
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool linearfunctionsmmtest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t kmax;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t i1;
   ae_int_t j1;
   ae_int_t k1;
   double lb;
   double rb;
   double eps;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(x0, 0, 0, DT_REAL);
   NewMatrix(x1, 0, 0, DT_REAL);
   NewMatrix(ty, 0, 0, DT_REAL);
   NewMatrix(tyt, 0, 0, DT_REAL);
   NewMatrix(y, 0, 0, DT_REAL);
   NewMatrix(yt, 0, 0, DT_REAL);
   NewMatrix(y0, 0, 0, DT_REAL);
   NewMatrix(yt0, 0, 0, DT_REAL);
// Accuracy
   eps = 1000.0 * machineepsilon;
// Size of the matrix (m*n)
   n = 32;
   m = 32;
   kmax = 32;
// Left and right borders, limiting matrix values
   lb = -10.0;
   rb = 10.0;
// Test linear algebra functions for:
// a) sparse matrix converted to CRS from Hash-Table
// b) sparse matrix initially created as CRS
   for (i = 1; i < m; i++) {
      for (j = 1; j < n; j++) {
      // Prepare test problem
         testsparseunit_createrandom(i, j, -1, -1, -1, -1, &a, &s);
         ae_matrix_set_length(&x0, j, kmax);
         ae_matrix_set_length(&x1, i, kmax);
         for (i1 = 0; i1 < j; i1++) {
            for (j1 = 0; j1 < kmax; j1++) {
               x0.xyR[i1][j1] = (rb - lb) * randomreal() + lb;
            }
         }
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < kmax; j1++) {
               x1.xyR[i1][j1] = (rb - lb) * randomreal() + lb;
            }
         }
         ae_matrix_set_length(&ty, i, kmax);
         ae_matrix_set_length(&tyt, j, kmax);
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < kmax; j1++) {
               ty.xyR[i1][j1] = 0.0;
            }
         }
         for (i1 = 0; i1 < j; i1++) {
            for (j1 = 0; j1 < kmax; j1++) {
               tyt.xyR[i1][j1] = 0.0;
            }
         }
         if (i != j) {
            for (i1 = 0; i1 < i; i1++) {
               for (k1 = 0; k1 < kmax; k1++) {
                  for (j1 = 0; j1 < j; j1++) {
                     ty.xyR[i1][k1] += a.xyR[i1][j1] * x0.xyR[j1][k1];
                     tyt.xyR[j1][k1] += a.xyR[i1][j1] * x1.xyR[i1][k1];
                  }
               }
            }
         } else {
            for (i1 = 0; i1 < i; i1++) {
               for (k1 = 0; k1 < kmax; k1++) {
                  for (j1 = 0; j1 < j; j1++) {
                     ty.xyR[i1][k1] += a.xyR[i1][j1] * x0.xyR[j1][k1];
                     tyt.xyR[j1][k1] += a.xyR[i1][j1] * x0.xyR[i1][k1];
                  }
               }
            }
         }
         for (k = 1; k <= kmax; k++) {
         // Consider two cases: square matrix, and non-square matrix
            if (i != j) {
            // Multiplication
               sparsemm(&s, &x0, k, &y);
               sparsemtm(&s, &x1, k, &yt);
            // Check for MM-result
               for (i1 = 0; i1 < i; i1++) {
                  for (j1 = 0; j1 < k; j1++) {
                     if (!NearR(y.xyR[i1][j1], ty.xyR[i1][j1], eps)) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  }
               }
            // Check for MTM-result
               for (i1 = 0; i1 < j; i1++) {
                  for (j1 = 0; j1 < k; j1++) {
                     if (!NearR(yt.xyR[i1][j1], tyt.xyR[i1][j1], eps)) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  }
               }
            } else {
               sparsemm(&s, &x0, k, &y);
               sparsemtm(&s, &x0, k, &yt);
               sparsemm2(&s, &x0, k, &y0, &yt0);
            // Check for MM2-result
               for (i1 = 0; i1 < i; i1++) {
                  for (j1 = 0; j1 < k; j1++) {
                     if (!NearR(y0.xyR[i1][j1], ty.xyR[i1][j1], eps) || !NearR(yt0.xyR[i1][j1], tyt.xyR[i1][j1], eps)) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  }
               }
            // Check for MV- and MTM-result by help MV2
               for (i1 = 0; i1 < i; i1++) {
                  for (j1 = 0; j1 < k; j1++) {
                     if (!NearAtR(y0.xyR[i1][j1], y.xyR[i1][j1], eps) || !NearAtR(yt0.xyR[i1][j1], yt.xyR[i1][j1], eps)) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  }
               }
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Function for testing multyplication for simmetric sparse matrix with narrow
// dense matrix
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool linearfunctionssmmtest() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t k;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t j1;
   ae_int_t k1;
   double lb;
   double rb;
   double eps;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(x0, 0, 0, DT_REAL);
   NewMatrix(x1, 0, 0, DT_REAL);
   NewMatrix(ty, 0, 0, DT_REAL);
   NewMatrix(tyt, 0, 0, DT_REAL);
   NewMatrix(y, 0, 0, DT_REAL);
   NewMatrix(yt, 0, 0, DT_REAL);
// Accuracy
   eps = 1000.0 * machineepsilon;
// Size of the matrix (m*m)
   m = 32;
   k = 32;
// Left and right borders, limiting matrix values
   lb = -10.0;
   rb = 10.0;
// Test linear algebra functions for:
// a) sparse matrix converted to CRS from Hash-Table
// b) sparse matrix initially created as CRS
   for (i = 1; i < m; i++) {
      for (j = 1; j < k; j++) {
      // Prepare test problem
         testsparseunit_createrandom(i, i, -1, -1, -1, -1, &a, &s);
      // Initialize temporaries
         ae_matrix_set_length(&ty, i, j);
         ae_matrix_set_length(&tyt, i, j);
         ae_matrix_set_length(&x0, i, j);
         ae_matrix_set_length(&x1, i, j);
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               ty.xyR[i1][j1] = 0.0;
               tyt.xyR[i1][j1] = 0.0;
               x0.xyR[i1][j1] = (rb - lb) * randomreal() + lb;
               x1.xyR[i1][j1] = (rb - lb) * randomreal() + lb;
            }
         }
      // Searching true result for upper and lower triangles
      // of the matrix
         for (k1 = 0; k1 < j; k1++) {
            for (i1 = 0; i1 < i; i1++) {
               for (j1 = i1; j1 < i; j1++) {
                  ty.xyR[i1][k1] += a.xyR[i1][j1] * x0.xyR[j1][k1];
                  if (i1 != j1) {
                     ty.xyR[j1][k1] += a.xyR[i1][j1] * x0.xyR[i1][k1];
                  }
               }
            }
         }
         for (k1 = 0; k1 < j; k1++) {
            for (i1 = 0; i1 < i; i1++) {
               for (j1 = 0; j1 <= i1; j1++) {
                  tyt.xyR[i1][k1] += a.xyR[i1][j1] * x1.xyR[j1][k1];
                  if (i1 != j1) {
                     tyt.xyR[j1][k1] += a.xyR[i1][j1] * x1.xyR[i1][k1];
                  }
               }
            }
         }
      // Multiplication
         sparsesmm(&s, true, &x0, j, &y);
         sparsesmm(&s, false, &x1, j, &yt);
      // Check for SMM-result
         for (k1 = 0; k1 < j; k1++) {
            for (i1 = 0; i1 < i; i1++) {
               if (!NearR(y.xyR[i1][k1], ty.xyR[i1][k1], eps) || !NearR(yt.xyR[i1][k1], tyt.xyR[i1][k1], eps)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Function for basic test SparseCopy
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool basiccopyfunctest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t j1;
   double a0;
   double a1;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewObj(sparsematrix, ss);
   NewObj(sparsematrix, sss);
   NewVector(ner, 0, DT_INT);
   NewMatrix(a, 0, 0, DT_REAL);
   n = 30;
   m = 30;
   for (i = 1; i < m; i++) {
      for (j = 1; j < n; j++) {
         sparsecreate(i, j, 1, &s);
         ae_matrix_set_length(&a, i, j);
         ae_vector_set_length(&ner, i);
         for (i1 = 0; i1 < i; i1++) {
            if (i1 < j - 2) {
               ner.xZ[i1] = 2;
            } else {
               if (j - 3 < i1 && i1 < j - 1) {
                  ner.xZ[i1] = 1;
               } else {
                  ner.xZ[i1] = 0;
               }
            }
         }
         sparsecreatecrs(i, j, &ner, &sss);
      // Checking for Matrix with hash table type
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               if (j1 > i1 && j1 <= i1 + 2) {
                  a.xyR[i1][j1] = (double)(i1 + j1 + 1);
                  sparseset(&s, i1, j1, a.xyR[i1][j1]);
                  sparseadd(&s, i1, j1, 0.0);
                  sparseset(&sss, i1, j1, a.xyR[i1][j1]);
               } else {
                  a.xyR[i1][j1] = 0.0;
                  sparseset(&s, i1, j1, a.xyR[i1][j1]);
                  sparseadd(&s, i1, j1, 0.0);
               }
            // Check for SparseCreate
               sparsecopy(&s, &ss);
               a0 = sparseget(&s, i1, j1);
               a1 = sparseget(&ss, i1, j1);
               if (a0 != a1) {
                  if (!silent) {
                     printf("BasicCopyFuncTest: Failed\n");
                     printf("* SparseGet: S[%0d,%0d] = %0.5f, SS[%0d,%0d] = %0.5f\n", (int)i1, (int)j1, a0, (int)i1, (int)j1, a1);
                  }
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      // Check for SparseCreateCRS
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               sparsecopy(&sss, &ss);
               a0 = sparseget(&sss, i1, j1);
               a1 = sparseget(&ss, i1, j1);
               if (a0 != a1) {
                  if (!silent) {
                     printf("BasicCopyFuncTest: Failed\n");
                     printf("* SparseGet: S[%0d,%0d] = %0.5f, SS[%0d,%0d] = %0.5f\n", (int)i1, (int)j1, a0, (int)i1, (int)j1, a1);
                  }
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      // Check for Matrix with CRS type
         sparseconverttocrs(&s);
         sparsecopy(&s, &ss);
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               a0 = sparseget(&s, i1, j1);
               a1 = sparseget(&ss, i1, j1);
               if (a0 != a1) {
                  if (!silent) {
                     printf("BasicCopyFuncTest: Failed\n");
                     printf("* SparseGet: S[%0d,%0d] = %0.5f, SS[%0d,%0d] = %0.5f\n", (int)i1, (int)j1, a0, (int)i1, (int)j1, a1);
                  }
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      }
   }
   if (!silent) {
      printf("BasicCopyFuncTest: Ok\n");
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Function for testing SparseCopy
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool copyfunctest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t mtype;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t j1;
   double lb;
   double rb;
   double eps;
   double a0;
   double a1;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewObj(sparsematrix, ss);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(ty, 0, DT_REAL);
   NewVector(tyt, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(yt, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(yt0, 0, DT_REAL);
   NewVector(cpy, 0, DT_REAL);
   NewVector(cpyt, 0, DT_REAL);
   NewVector(cpy0, 0, DT_REAL);
   NewVector(cpyt0, 0, DT_REAL);
// Accuracy
   eps = 1000.0 * machineepsilon;
// Size of the matrix (m*n)
   n = 30;
   m = 30;
// Left and right borders, limiting matrix values
   lb = -10.0;
   rb = 10.0;
// Test linear algebra functions for:
// a) sparse matrix converted to CRS from Hash-Table
// b) sparse matrix initially created as CRS
   for (i = 1; i < m; i++) {
      for (j = 1; j < n; j++) {
         for (mtype = 0; mtype <= 1; mtype++) {
         // Prepare test problem
            testsparseunit_createrandom(i, j, -1, mtype, -1, -1, &a, &s);
            sparsecopy(&s, &ss);
         // Initialize temporaries
            ae_vector_set_length(&ty, i);
            ae_vector_set_length(&tyt, j);
            for (i1 = 0; i1 < i; i1++) {
               ty.xR[i1] = 0.0;
            }
            for (i1 = 0; i1 < j; i1++) {
               tyt.xR[i1] = 0.0;
            }
            ae_vector_set_length(&x0, j);
            ae_vector_set_length(&x1, i);
            for (i1 = 0; i1 < j; i1++) {
               x0.xR[i1] = (rb - lb) * randomreal() + lb;
            }
            for (i1 = 0; i1 < i; i1++) {
               x1.xR[i1] = (rb - lb) * randomreal() + lb;
            }
         // Consider two cases: square matrix, and non-square matrix
            if (i != j) {
            // Searching true result
               for (i1 = 0; i1 < i; i1++) {
                  for (j1 = 0; j1 < j; j1++) {
                     ty.xR[i1] += a.xyR[i1][j1] * x0.xR[j1];
                     tyt.xR[j1] += a.xyR[i1][j1] * x1.xR[i1];
                  }
               }
            // Multiplication
               sparsemv(&s, &x0, &y);
               sparsemtv(&s, &x1, &yt);
               sparsemv(&ss, &x0, &cpy);
               sparsemtv(&ss, &x1, &cpyt);
            // Check for MV-result
               for (i1 = 0; i1 < i; i1++) {
                  if (!NearR(y.xR[i1], ty.xR[i1], eps) || !NearR(cpy.xR[i1], ty.xR[i1], eps) || cpy.xR[i1] - y.xR[i1] != 0.0) {
                     if (!silent) {
                        printf("CopyFuncTest: Failed\n");
                        printf("* RES_MV: Y[%0d] = %0.5f, tY[%0d] = %0.5f, cpY[%0d] = %0.5f\n", (int)i1, y.xR[i1], (int)i1, ty.xR[i1], (int)i1, cpy.xR[i1]);
                     }
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
               }
            // Check for MTV-result
               for (i1 = 0; i1 < j; i1++) {
                  if (!NearR(yt.xR[i1], tyt.xR[i1], eps) || !NearR(cpyt.xR[i1], tyt.xR[i1], eps) || cpyt.xR[i1] - yt.xR[i1] != 0.0) {
                     if (!silent) {
                        printf("CopyFuncTest: Failed\n");
                        printf("* RES_MTV: Yt[%0d] = %0.5f, tYt[%0d] = %0.5f, cpYt[%0d] = %0.5f\n", (int)i1, yt.xR[i1], (int)i1, tyt.xR[i1], (int)i1, cpyt.xR[i1]);
                     }
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
               }
               sparsecopy(&s, &ss);
               for (i1 = 0; i1 < i; i1++) {
                  for (j1 = 0; j1 < j; j1++) {
                     a0 = sparseget(&s, i1, j1);
                     a1 = sparseget(&ss, i1, j1);
                     if (a0 != a1) {
                        if (!silent) {
                           printf("CopyFuncTest: Failed\n");
                           printf("* SparseGet: S[%0d,%0d] = %0.5f, SS[%0d,%0d] = %0.5f\n", (int)i1, (int)j1, a0, (int)i1, (int)j1, a1);
                        }
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  }
               }
            } else {
            // Searching true result
               for (i1 = 0; i1 < i; i1++) {
                  for (j1 = 0; j1 < j; j1++) {
                     ty.xR[i1] += a.xyR[i1][j1] * x0.xR[j1];
                     tyt.xR[j1] += a.xyR[i1][j1] * x0.xR[i1];
                  }
               }
            // Multiplication
               sparsemv(&s, &x0, &y);
               sparsemtv(&s, &x0, &yt);
               sparsemv2(&s, &x0, &y0, &yt0);
               sparsemv(&ss, &x0, &cpy);
               sparsemtv(&ss, &x0, &cpyt);
               sparsemv2(&ss, &x0, &cpy0, &cpyt0);
            // Check for MV2-result
               for (i1 = 0; i1 < i; i1++) {
                  if (!NearR(y0.xR[i1], ty.xR[i1], eps) || !NearR(yt0.xR[i1], tyt.xR[i1], eps) || !NearR(cpy0.xR[i1], ty.xR[i1], eps) || !NearR(cpyt0.xR[i1], tyt.xR[i1], eps) || cpy0.xR[i1] - y0.xR[i1] != 0.0 || cpyt0.xR[i1] - yt0.xR[i1] != 0.0) {
                     if (!silent) {
                        printf("CopyFuncTest: Failed\n");
                        printf("* RES_MV2: Y0[%0d] = %0.5f, tY[%0d] = %0.5f, Yt0[%0d] = %0.5f, tYt[%0d] = %0.5f, cpY0[%0d] = %0.5f, cpYt0[%0d] = %0.5f\n",
                           (int)i1, y0.xR[i1], (int)i1, ty.xR[i1],
                           (int)i1, yt0.xR[i1], (int)i1, tyt.xR[i1],
                           (int)i1, cpy0.xR[i1], (int)i1, cpyt0.xR[i1]
                        );
                     }
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
               }
            // Check for MV- and MTV-result by help MV2
               for (i1 = 0; i1 < i; i1++) {
                  if (!NearAtR(y0.xR[i1], y.xR[i1], eps) || !NearAtR(yt0.xR[i1], yt.xR[i1], eps) || !NearAtR(cpy0.xR[i1], cpy.xR[i1], eps) || !NearAtR(cpyt0.xR[i1], cpyt.xR[i1], eps)) {
                     if (!silent) {
                        printf("CopyFuncTest: Failed\n");
                        printf("* RES_MV_MVT: Y0[%0d] == %0.5f, Y[%0d] == %0.5f\n Yt0[%0d] == %0.5f, Yt[%0d] == %0.5f, cpY0[%0d] == %0.5f, cpY[%0d] == %0.5f, cpYt0[%0d] == %0.5f, cpYt[%0d] == %0.5f\n",
                           (int)i1, y0.xR[i1], (int)i1, y.xR[i1],
                           (int)i1, yt0.xR[i1], (int)i1, yt.xR[i1],
                           (int)i1, cpy0.xR[i1], (int)i1, cpy.xR[i1],
                           (int)i1, cpyt0.xR[i1], (int)i1, cpyt.xR[i1]
                        );
                     }
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
               }
               sparsecopy(&s, &ss);
               for (i1 = 0; i1 < i; i1++) {
                  for (j1 = 0; j1 < j; j1++) {
                     a0 = sparseget(&s, i1, j1);
                     a1 = sparseget(&ss, i1, j1);
                     if (a0 != a1) {
                        if (!silent) {
                           printf("CopyFuncTest: Failed\n");
                           printf("* SparseGet: S[%0d,%0d] = %0.5f, SS[%0d,%0d] = %0.5f\n", (int)i1, (int)j1, a0, (int)i1, (int)j1, a1);
                        }
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  }
               }
            }
         }
      }
   }
   if (!silent) {
      printf("CopyFuncTest: Ok\n");
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This function does test for SparseEnumerate function.
//
// ALGLIB Project: Copyright 14.03.2012 by Sergey Bochkanov
static bool testsparseunit_enumeratetest() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   double r;
   double v;
   ae_int_t ne;
   ae_int_t t0;
   ae_int_t t1;
   ae_int_t counter;
   ae_int_t c;
   ae_int_t hashcrs;
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, spa);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ta, 0, 0, DT_BOOL);
   r = 10.5;
   for (m = 1; m <= 30; m++) {
      for (n = 1; n <= 30; n++) {
         ne = 0;
      // Create matrix with non-zero elements inside the region:
      // 0 <= I < S.M and 0 <= J < S.N
         ae_matrix_set_length(&a, m, n);
         ae_matrix_set_length(&ta, m, n);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
               ta.xyB[i][j] = false;
            }
         }
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               c = randominteger(2);
               if (c == 0) {
                  a.xyR[i][j] = 0.0;
               } else {
                  a.xyR[i][j] = r * randommid();
               // Number of non-zero elements
                  ne++;
               }
            }
         }
         for (hashcrs = 0; hashcrs <= 1; hashcrs++) {
            sparsecreate(m, n, m * n, &spa);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  sparseset(&spa, i, j, a.xyR[i][j]);
               }
            }
            if (hashcrs == 1) {
               sparseconverttocrs(&spa);
            }
            t0 = 0;
            t1 = 0;
            counter = 0;
            while (sparseenumerate(&spa, &t0, &t1, &i, &j, &v)) {
               ta.xyB[i][j] = true;
               counter++;
               if (v != a.xyR[i][j]) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         // Check that all non-zero elements was enumerated
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  if (ta.xyB[i][j] && a.xyR[i][j] == 0.0) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
               }
            }
            if (ne != counter) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This function does test for SparseRewriteExisting function.
//
// ALGLIB Project: Copyright 14.03.2012 by Sergey Bochkanov
static bool testsparseunit_rewriteexistingtest() {
   ae_frame _frame_block;
   double spaval;
   ae_int_t m;
   ae_int_t n;
   ae_int_t c;
   ae_int_t ne;
   ae_int_t nr;
   double r;
   double v;
   ae_int_t hashcrs;
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, spa);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ta, 0, 0, DT_BOOL);
   r = 20.0;
   for (m = 1; m <= 30; m++) {
      for (n = 1; n <= 30; n++) {
         ae_matrix_set_length(&a, m, n);
         ae_matrix_set_length(&ta, m, n);
         for (hashcrs = 0; hashcrs <= 1; hashcrs++) {
            v = r * randommid();
         // Creating and filling of the matrix
            ne = 0;
            sparsecreate(m, n, m * n, &spa);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  c = randominteger(2);
                  if (c == 0) {
                     a.xyR[i][j] = 0.0;
                  }
                  if (c == 1) {
                     do {
                        a.xyR[i][j] = r * randommid();
                     } while (a.xyR[i][j] == 0.0);
                     sparseset(&spa, i, j, a.xyR[i][j]);
                     ne++;
                  }
                  ta.xyB[i][j] = false;
               }
            }
            if (hashcrs == 1) {
               sparseconverttocrs(&spa);
            }
         // Rewrite some elements
            nr = 0;
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  c = randominteger(2);
                  if (c == 1) {
                     ta.xyB[i][j] = sparserewriteexisting(&spa, i, j, v);
                     if (ta.xyB[i][j]) {
                        a.xyR[i][j] = v;
                        nr++;
                     }
                  }
               }
            }
         // Now we have to be sure, that all changes had made correctly
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  if (ta.xyB[i][j]) {
                     spaval = sparseget(&spa, i, j);
                     nr--;
                     if (spaval != v || spaval != a.xyR[i][j]) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  }
               }
            }
            if (nr != 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         // Rewrite all elements
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  ta.xyB[i][j] = sparserewriteexisting(&spa, i, j, v);
                  if (ta.xyB[i][j]) {
                     a.xyR[i][j] = v;
                  }
               }
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  if (ta.xyB[i][j]) {
                     ne--;
                  }
               }
            }
            if (ne != 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  spaval = sparseget(&spa, i, j);
                  if (ta.xyB[i][j]) {
                     if (spaval != v || spaval != a.xyR[i][j]) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  } else {
                     if (spaval != 0.0 || spaval != a.xyR[i][j]) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  }
               }
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Test  for  SparseGetRow/GetCompressedRow  function.   It  creates  random
// dense and sparse matrices;  then  get every  row from  sparse matrix  and
// compares it with every row in dense matrix.
//
// ALGLIB Project: Copyright 23.07.2012 by Sergey Bochkanov
static bool testsparseunit_testgetrow() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t msize;
   ae_int_t nsize;
   ae_int_t nz;
   ae_int_t mtype;
   ae_int_t i;
   ae_int_t j;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(vals, 0, DT_REAL);
   NewVector(mrow, 0, DT_REAL);
   NewVector(colidx, 0, DT_INT);
   NewVector(wasreturned, 0, DT_BOOL);
   msize = 15;
   nsize = 15;
   for (mtype = 1; mtype <= 2; mtype++) {
      for (m = 1; m <= msize; m++) {
         for (n = 1; n <= nsize; n++) {
         // Skip nonrectangular SKS matrices - not supported
            if (mtype == 2 && m != n) {
               continue;
            }
         // Create "reference" and sparse matrices
            ae_matrix_set_length(&a, m, n);
            sparsecreate(m, n, 1, &s);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  if (randominteger(5) == 3) {
                     a.xyR[i][j] = randommid();
                     sparseset(&s, i, j, a.xyR[i][j]);
                  } else {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
         // Choose matrix type to test
            if (mtype == 1) {
               sparseconverttocrs(&s);
            } else {
               sparseconverttosks(&s);
            }
         // Test SparseGetRow()
            for (i = 0; i < m; i++) {
               sparsegetrow(&s, i, &mrow);
               for (j = 0; j < n; j++) {
                  if (mrow.xR[j] != a.xyR[i][j] || mrow.xR[j] != sparseget(&s, i, j)) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
               }
            }
         // Test SparseGetCompressedRow()
            ae_vector_set_length(&wasreturned, n);
            for (i = 0; i < m; i++) {
               sparsegetcompressedrow(&s, i, &colidx, &vals, &nz);
               if (nz < 0 || nz > n) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
               for (j = 0; j < n; j++) {
                  wasreturned.xB[j] = false;
               }
               for (j = 0; j < nz; j++) {
                  if (colidx.xZ[j] < 0 || colidx.xZ[j] > n) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
                  Ok = Ok && (j <= 0 || colidx.xZ[j] > colidx.xZ[j - 1]);
                  Ok = Ok && vals.xR[j] == a.xyR[i][colidx.xZ[j]] && vals.xR[j] == sparseget(&s, i, colidx.xZ[j]);
                  wasreturned.xB[colidx.xZ[j]] = true;
               }
               for (j = 0; j < n; j++) {
                  Ok = Ok && (a.xyR[i][j] == 0.0 || wasreturned.xB[j]);
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test for SparseConvert functions(isn't tested ConvertToCRS function). The
// function  create random  dense and sparse  matrices  in CRS  format. Then
// convert  sparse matrix  to some  format  by CONVERT_TO/COPY_TO  functions,
// then it does  some modification in matrices and compares that marices are
// identical.
//
// NOTE:
//     Result of the function assigned to variable copyOk in unit test.
//
// ALGLIB Project: Copyright 23.07.2012 by Sergey Bochkanov
static bool testsparseunit_testconvertsm() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t msize;
   ae_int_t nsize;
   double tmp;
   ae_int_t i;
   ae_int_t j;
   ae_int_t vartf;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewObj(sparsematrix, cs);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(ner, 0, DT_INT);
   msize = 15;
   nsize = 15;
   for (m = 1; m <= msize; m++) {
      for (n = 1; n <= nsize; n++) {
         for (vartf = 0; vartf <= 2; vartf++) {
            ae_matrix_set_length(&a, m, n);
            ae_vector_set_length(&ner, m);
            for (i = 0; i < m; i++) {
               ner.xZ[i] = 0;
               for (j = 0; j < n; j++) {
                  if (randominteger(5) == 3) {
                     ner.xZ[i]++;
                     a.xyR[i][j] = randommid();
                  } else {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
         // Create sparse matrix
            sparsecreatecrs(m, n, &ner, &s);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  if (a.xyR[i][j] != 0.0) {
                     a.xyR[i][j] = randommid();
                     sparseset(&s, i, j, a.xyR[i][j]);
                  }
               }
            }
         // Set matrix type(we have to be sure that all formats
         // converted correctly)
            i = randominteger(2);
            if (i == 0) {
               sparseconverttohash(&s);
            }
            if (i == 1) {
               sparseconverttocrs(&s);
            }
         // Start test
            if (vartf == 0) {
               sparseconverttohash(&s);
               sparsecopy(&s, &cs);
            }
            if (vartf == 1) {
               sparsecopytohash(&s, &cs);
            }
            if (vartf == 2) {
               sparsecopytocrs(&s, &cs);
            }
         // Change some elements in row
            if (vartf != 2) {
               for (i = 0; i < m; i++) {
                  tmp = randommid();
                  j = randominteger(n);
                  a.xyR[i][j] = tmp;
                  sparseset(&cs, i, j, tmp);
                  tmp = randommid();
                  j = randominteger(n);
                  a.xyR[i][j] += tmp;
                  sparseadd(&cs, i, j, tmp);
               }
            }
         // Check that A is identical to S
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  if (a.xyR[i][j] != sparseget(&cs, i, j)) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
               }
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Test for  check/get  type functions.  The function  create sparse matrix,
// converts it to desired type then check this type.
//
// NOTE:
//     Result of the function assigned to variable basicOk in unit test.
//
// ALGLIB Project: Copyright 23.07.2012 by Sergey Bochkanov
static bool testsparseunit_testgcmatrixtype() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t msize;
   ae_int_t nsize;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewObj(sparsematrix, cs);
   msize = 5;
   nsize = 5;
   for (m = 1; m <= msize; m++) {
      for (n = 1; n <= nsize; n++) {
         sparsecreate(m, n, 1, &s);
         sparseconverttocrs(&s);
         if (sparseishash(&s) || !sparseiscrs(&s) || sparsegetmatrixtype(&s) != 1) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         sparseconverttohash(&s);
         if (!sparseishash(&s) || sparseiscrs(&s) || sparsegetmatrixtype(&s) != 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         sparsecopytocrs(&s, &cs);
         if (sparseishash(&cs) || !sparseiscrs(&cs) || sparsegetmatrixtype(&cs) != 1) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         sparsecopytohash(&cs, &s);
         if (!sparseishash(&s) || sparseiscrs(&s) || sparsegetmatrixtype(&s) != 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

bool testsparse() {
   bool Ok;
   bool basicOk;
   bool linearOk;
   bool basicrndOk;
   bool level2unsymmetricOk;
   bool level2symmetricOk;
   bool level2triangularOk;
   bool level3unsymmetricOk;
   bool level3symmetricOk;
   bool symmetricpermOk;
   bool linearsOk;
   bool linearmmOk;
   bool linearsmmOk;
   bool getrowOk;
   bool copyOk;
   bool basiccopyOk;
   bool enumerateOk;
   bool rewriteexistingOk;
   bool sksOk;
   bool crsOk;
   if (!silent) printf("Sparse Matrix Test Breakdown\n");
   getrowOk = true;
   crsOk = true;
   sksOk = skstest();
   crsOk = crsOk && crstest();
   basicOk = basicfunctest() && testsparseunit_testgcmatrixtype();
   basicrndOk = basicfuncrandomtest();
   linearOk = linearfunctionstest();
   level2unsymmetricOk = testlevel2unsymmetric();
   level2symmetricOk = testlevel2symmetric();
   level2triangularOk = testlevel2triangular();
   level3unsymmetricOk = testlevel3unsymmetric();
   level3symmetricOk = testlevel3symmetric();
   symmetricpermOk = testsymmetricperm();
   linearsOk = linearfunctionsstest();
   linearmmOk = linearfunctionsmmtest();
   linearsmmOk = linearfunctionssmmtest();
   copyOk = copyfunctest() && testsparseunit_testconvertsm();
   basiccopyOk = basiccopyfunctest();
   enumerateOk = testsparseunit_enumeratetest();
   rewriteexistingOk = testsparseunit_rewriteexistingtest();
   getrowOk = getrowOk && testsparseunit_testgetrow();
// The final report.
   Ok = sksOk && crsOk && getrowOk && basicOk && linearOk && basicrndOk && level2unsymmetricOk && level2symmetricOk && level2triangularOk && level3unsymmetricOk && level3symmetricOk && symmetricpermOk && linearsOk && linearmmOk && linearsmmOk && copyOk && basiccopyOk && enumerateOk && rewriteexistingOk;
   if (!Ok || !silent) {
      printf("Sparse Matrix Tests\n");
      printf("* Storage Format Specifics:\n");
      printf("* SKS:                                    %s\n", sksOk? "Ok": "Failed");
      printf("* CRS:                                    %s\n", crsOk? "Ok": "Failed");
      printf("* Operations:\n");
      printf("* GetRow:                                 %s\n", getrowOk? "Ok": "Failed");
      printf("* BLAS:\n");
      printf("* Level 2 General:                        %s\n", level2unsymmetricOk? "Ok": "Failed");
      printf("* Level 2 Symmetric:                      %s\n", level2symmetricOk? "Ok": "Failed");
      printf("* Level 2 Triangular:                     %s\n", level2triangularOk? "Ok": "Failed");
      printf("* Level 3 General:                        %s\n", level3unsymmetricOk? "Ok": "Failed");
      printf("* Level 3 Symmetric:                      %s\n", level3symmetricOk? "Ok": "Failed");
      printf("* Permutations (symmetric):               %s\n", symmetricpermOk? "Ok": "Failed");
      printf("Basic Test:                               %s\n", basicOk? "Ok": "Failed");
      printf("Copy Test:                                %s\n", copyOk? "Ok": "Failed");
      printf("Basic Copy Test:                          %s\n", basiccopyOk? "Ok": "Failed");
      printf("Basic Rnd Test:                           %s\n", basicrndOk? "Ok": "Failed");
      printf("Linear Test:                              %s\n", linearOk? "Ok": "Failed");
      printf("Linear Test For Symmetric Matrices:       %s\n", linearsOk? "Ok": "Failed");
      printf("Linear M x M Test:                        %s\n", linearmmOk? "Ok": "Failed");
      printf("Linear M x M Test For Symmetric Matrices: %s\n", linearsmmOk? "Ok": "Failed");
      printf("Enumerate Test:                           %s\n", enumerateOk? "Ok": "Failed");
      printf("Rewrite Existing Test:                    %s\n", rewriteexistingOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === blas testing unit ===
static void testblasunit_naivematrixmatrixmultiply(RMatrix *a, ae_int_t ai1, ae_int_t ai2, ae_int_t aj1, ae_int_t aj2, bool transa, RMatrix *b, ae_int_t bi1, ae_int_t bi2, ae_int_t bj1, ae_int_t bj2, bool transb, double alpha, RMatrix *c, ae_int_t ci1, ae_int_t ci2, ae_int_t cj1, ae_int_t cj2, double beta) {
   ae_frame _frame_block;
   ae_int_t arows;
   ae_int_t acols;
   ae_int_t brows;
   ae_int_t bcols;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   ae_int_t r;
   double v;
   ae_frame_make(&_frame_block);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
// Setup
   if (!transa) {
      arows = ai2 - ai1 + 1;
      acols = aj2 - aj1 + 1;
   } else {
      arows = aj2 - aj1 + 1;
      acols = ai2 - ai1 + 1;
   }
   if (!transb) {
      brows = bi2 - bi1 + 1;
      bcols = bj2 - bj1 + 1;
   } else {
      brows = bj2 - bj1 + 1;
      bcols = bi2 - bi1 + 1;
   }
   ae_assert(acols == brows, "NaiveMatrixMatrixMultiply: incorrect matrix sizes!");
   if (arows <= 0 || acols <= 0 || brows <= 0 || bcols <= 0) {
      ae_frame_leave();
      return;
   }
   l = arows;
   r = bcols;
   k = acols;
   ae_vector_set_length(&x1, k + 1);
   ae_vector_set_length(&x2, k + 1);
   for (i = 1; i <= l; i++) {
      for (j = 1; j <= r; j++) {
         if (!transa) {
            if (!transb) {
               v = ae_v_dotproduct(&b->xyR[bi1][bj1 + j - 1], b->stride, &a->xyR[ai1 + i - 1][aj1], 1, bi2 - bi1 + 1);
            } else {
               v = ae_v_dotproduct(&b->xyR[bi1 + j - 1][bj1], 1, &a->xyR[ai1 + i - 1][aj1], 1, bj2 - bj1 + 1);
            }
         } else {
            if (!transb) {
               v = ae_v_dotproduct(&b->xyR[bi1][bj1 + j - 1], b->stride, &a->xyR[ai1][aj1 + i - 1], a->stride, bi2 - bi1 + 1);
            } else {
               v = ae_v_dotproduct(&b->xyR[bi1 + j - 1][bj1], 1, &a->xyR[ai1][aj1 + i - 1], a->stride, bj2 - bj1 + 1);
            }
         }
         if (beta == 0.0) {
            c->xyR[ci1 + i - 1][cj1 + j - 1] = alpha * v;
         } else {
            c->xyR[ci1 + i - 1][cj1 + j - 1] = beta * c->xyR[ci1 + i - 1][cj1 + j - 1] + alpha * v;
         }
      }
   }
   ae_frame_leave();
}

bool testblas() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t i;
   ae_int_t i1;
   ae_int_t i2;
   ae_int_t j;
   ae_int_t j1;
   ae_int_t j2;
   ae_int_t l;
   ae_int_t k;
   ae_int_t r;
   ae_int_t i3;
   ae_int_t j3;
   ae_int_t col1;
   ae_int_t col2;
   ae_int_t row1;
   ae_int_t row2;
   double err;
   double e1;
   double e2;
   double e3;
   double v;
   double scl1;
   double scl2;
   double scl3;
   bool was1;
   bool was2;
   bool trans1;
   bool trans2;
   double threshold;
   bool n2Ok;
   bool hsnOk;
   bool amaxOk;
   bool mvOk;
   bool itOk;
   bool ctOk;
   bool mmOk;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewMatrix(c1, 0, 0, DT_REAL);
   NewMatrix(c2, 0, 0, DT_REAL);
   n2Ok = true;
   amaxOk = true;
   hsnOk = true;
   mvOk = true;
   itOk = true;
   ctOk = true;
   mmOk = true;
   Ok = true;
   threshold = 10000.0 * machineepsilon;
// Test Norm2
   passcount = 1000;
   e1 = 0.0;
   e2 = 0.0;
   e3 = 0.0;
   scl2 = 0.5 * maxrealnumber;
   scl3 = 2 * minrealnumber;
   for (pass = 1; pass <= passcount; pass++) {
      n = 1 + randominteger(1000);
      i1 = randominteger(10);
      i2 = n + i1 - 1;
      ae_vector_set_length(&x1, i2 + 1);
      ae_vector_set_length(&x2, i2 + 1);
      for (i = i1; i <= i2; i++) {
         x1.xR[i] = randommid();
      }
      v = 0.0;
      for (i = i1; i <= i2; i++) {
         v += sqr(x1.xR[i]);
      }
      v = sqrt(v);
      e1 = rmax2(e1, fabs(v - vectornorm2(&x1, i1, i2)));
      for (i = i1; i <= i2; i++) {
         x2.xR[i] = scl2 * x1.xR[i];
      }
      e2 = rmax2(e2, fabs(v * scl2 - vectornorm2(&x2, i1, i2)));
      for (i = i1; i <= i2; i++) {
         x2.xR[i] = scl3 * x1.xR[i];
      }
      e3 = rmax2(e3, fabs(v * scl3 - vectornorm2(&x2, i1, i2)));
   }
   e2 /= scl2;
   e3 /= scl3;
   n2Ok = e1 < threshold && e2 < threshold && e3 < threshold;
// Testing VectorAbsMax, Column/Row AbsMax
   ae_vector_set_length(&x1, 5 + 1);
   x1.xR[1] = 2.0;
   x1.xR[2] = 0.2;
   x1.xR[3] = -1.3;
   x1.xR[4] = 0.7;
   x1.xR[5] = -3.0;
   amaxOk = vectoridxabsmax(&x1, 1, 5) == 5 && vectoridxabsmax(&x1, 1, 4) == 1 && vectoridxabsmax(&x1, 2, 4) == 3;
   n = 30;
   ae_vector_set_length(&x1, n + 1);
   ae_matrix_set_length(&a, n + 1, n + 1);
   for (i = 1; i <= n; i++) {
      for (j = 1; j <= n; j++) {
         a.xyR[i][j] = randommid();
      }
   }
   was1 = false;
   was2 = false;
   for (pass = 1; pass <= 1000; pass++) {
      j = 1 + randominteger(n);
      i1 = 1 + randominteger(n);
      i2 = i1 + randominteger(n + 1 - i1);
      ae_v_move(&x1.xR[i1], 1, &a.xyR[i1][j], a.stride, i2 - i1 + 1);
      if (vectoridxabsmax(&x1, i1, i2) != columnidxabsmax(&a, i1, i2, j)) {
         was1 = true;
      }
      i = 1 + randominteger(n);
      j1 = 1 + randominteger(n);
      j2 = j1 + randominteger(n + 1 - j1);
      ae_v_move(&x1.xR[j1], 1, &a.xyR[i][j1], 1, j2 - j1 + 1);
      if (vectoridxabsmax(&x1, j1, j2) != rowidxabsmax(&a, j1, j2, i)) {
         was2 = true;
      }
   }
   amaxOk = amaxOk && !was1 && !was2;
// Testing upper Hessenberg 1-norm
   ae_matrix_set_length(&a, 3 + 1, 3 + 1);
   ae_vector_set_length(&x1, 3 + 1);
   a.xyR[1][1] = 2.0;
   a.xyR[1][2] = 3.0;
   a.xyR[1][3] = 1.0;
   a.xyR[2][1] = 4.0;
   a.xyR[2][2] = -5.0;
   a.xyR[2][3] = 8.0;
   a.xyR[3][1] = 99.0;
   a.xyR[3][2] = 3.0;
   a.xyR[3][3] = 1.0;
   hsnOk = NearAtR(upperhessenberg1norm(&a, 1, 3, 1, 3, &x1), 11.0, threshold);
// Testing MatrixVectorMultiply
   ae_matrix_set_length(&a, 3 + 1, 5 + 1);
   ae_vector_set_length(&x1, 3 + 1);
   ae_vector_set_length(&x2, 2 + 1);
   a.xyR[2][3] = 2.0;
   a.xyR[2][4] = -1.0;
   a.xyR[2][5] = -1.0;
   a.xyR[3][3] = 1.0;
   a.xyR[3][4] = -2.0;
   a.xyR[3][5] = 2.0;
   x1.xR[1] = 1.0;
   x1.xR[2] = 2.0;
   x1.xR[3] = 1.0;
   x2.xR[1] = -1.0;
   x2.xR[2] = -1.0;
   matrixvectormultiply(&a, 2, 3, 3, 5, false, &x1, 1, 3, 1.0, &x2, 1, 2, 1.0);
   matrixvectormultiply(&a, 2, 3, 3, 5, true, &x2, 1, 2, 1.0, &x1, 1, 3, 1.0);
   e1 = fabs(x1.xR[1] + 5) + fabs(x1.xR[2] - 8) + fabs(x1.xR[3] + 1) + fabs(x2.xR[1] + 2) + fabs(x2.xR[2] + 2);
   x1.xR[1] = 1.0;
   x1.xR[2] = 2.0;
   x1.xR[3] = 1.0;
   x2.xR[1] = -1.0;
   x2.xR[2] = -1.0;
   matrixvectormultiply(&a, 2, 3, 3, 5, false, &x1, 1, 3, 1.0, &x2, 1, 2, 0.0);
   matrixvectormultiply(&a, 2, 3, 3, 5, true, &x2, 1, 2, 1.0, &x1, 1, 3, 0.0);
   e2 = fabs(x1.xR[1] + 3) + fabs(x1.xR[2] - 3) + fabs(x1.xR[3] + 1) + fabs(x2.xR[1] + 1) + fabs(x2.xR[2] + 1);
   mvOk = e1 + e2 < threshold;
// testing inplace transpose
   n = 10;
   ae_matrix_set_length(&a, n + 1, n + 1);
   ae_matrix_set_length(&b, n + 1, n + 1);
   ae_vector_set_length(&x1, n);
   for (i = 1; i <= n; i++) {
      for (j = 1; j <= n; j++) {
         a.xyR[i][j] = randomreal();
      }
   }
   passcount = 10000;
   was1 = false;
   for (pass = 1; pass <= passcount; pass++) {
      i1 = 1 + randominteger(n);
      i2 = i1 + randominteger(n - i1 + 1);
      j1 = 1 + randominteger(n - (i2 - i1));
      j2 = j1 + (i2 - i1);
      copymatrix(&a, i1, i2, j1, j2, &b, i1, i2, j1, j2);
      inplacetranspose(&b, i1, i2, j1, j2, &x1);
      for (i = i1; i <= i2; i++) {
         for (j = j1; j <= j2; j++) {
            if (a.xyR[i][j] != b.xyR[i1 + (j - j1)][j1 + (i - i1)]) {
               was1 = true;
            }
         }
      }
   }
   itOk = !was1;
// testing copy and transpose
   n = 10;
   ae_matrix_set_length(&a, n + 1, n + 1);
   ae_matrix_set_length(&b, n + 1, n + 1);
   for (i = 1; i <= n; i++) {
      for (j = 1; j <= n; j++) {
         a.xyR[i][j] = randomreal();
      }
   }
   passcount = 10000;
   was1 = false;
   for (pass = 1; pass <= passcount; pass++) {
      i1 = 1 + randominteger(n);
      i2 = i1 + randominteger(n - i1 + 1);
      j1 = 1 + randominteger(n);
      j2 = j1 + randominteger(n - j1 + 1);
      copyandtranspose(&a, i1, i2, j1, j2, &b, j1, j2, i1, i2);
      for (i = i1; i <= i2; i++) {
         for (j = j1; j <= j2; j++) {
            if (a.xyR[i][j] != b.xyR[j][i]) {
               was1 = true;
            }
         }
      }
   }
   ctOk = !was1;
// Testing MatrixMatrixMultiply
   n = 10;
   ae_matrix_set_length(&a, 2 * n + 1, 2 * n + 1);
   ae_matrix_set_length(&b, 2 * n + 1, 2 * n + 1);
   ae_matrix_set_length(&c1, 2 * n + 1, 2 * n + 1);
   ae_matrix_set_length(&c2, 2 * n + 1, 2 * n + 1);
   ae_vector_set_length(&x1, n + 1);
   ae_vector_set_length(&x2, n + 1);
   for (i = 1; i <= 2 * n; i++) {
      for (j = 1; j <= 2 * n; j++) {
         a.xyR[i][j] = randomreal();
         b.xyR[i][j] = randomreal();
      }
   }
   passcount = 1000;
   was1 = false;
   for (pass = 1; pass <= passcount; pass++) {
      for (i = 1; i <= 2 * n; i++) {
         for (j = 1; j <= 2 * n; j++) {
            c1.xyR[i][j] = 2.1 * i + 3.1 * j;
            c2.xyR[i][j] = c1.xyR[i][j];
         }
      }
      l = 1 + randominteger(n);
      k = 1 + randominteger(n);
      r = 1 + randominteger(n);
      i1 = 1 + randominteger(n);
      j1 = 1 + randominteger(n);
      i2 = 1 + randominteger(n);
      j2 = 1 + randominteger(n);
      i3 = 1 + randominteger(n);
      j3 = 1 + randominteger(n);
      trans1 = randombool();
      trans2 = randombool();
      if (trans1) {
         col1 = l;
         row1 = k;
      } else {
         col1 = k;
         row1 = l;
      }
      if (trans2) {
         col2 = k;
         row2 = r;
      } else {
         col2 = r;
         row2 = k;
      }
      scl1 = randomreal();
      scl2 = randomreal();
      matrixmatrixmultiply(&a, i1, i1 + row1 - 1, j1, j1 + col1 - 1, trans1, &b, i2, i2 + row2 - 1, j2, j2 + col2 - 1, trans2, scl1, &c1, i3, i3 + l - 1, j3, j3 + r - 1, scl2, &x1);
      testblasunit_naivematrixmatrixmultiply(&a, i1, i1 + row1 - 1, j1, j1 + col1 - 1, trans1, &b, i2, i2 + row2 - 1, j2, j2 + col2 - 1, trans2, scl1, &c2, i3, i3 + l - 1, j3, j3 + r - 1, scl2);
      err = 0.0;
      for (i = 1; i <= l; i++) {
         for (j = 1; j <= r; j++) {
            err = rmax2(err, fabs(c1.xyR[i3 + i - 1][j3 + j - 1] - c2.xyR[i3 + i - 1][j3 + j - 1]));
         }
      }
      if (err > threshold) {
         was1 = true;
         break;
      }
   }
   mmOk = !was1;
// The final report.
   Ok = n2Ok && amaxOk && hsnOk && mvOk && itOk && ctOk && mmOk;
   if (!Ok || !silent) {
      printf("BLAS Tests\n");
      printf("Vector Norm 2:                            %s\n", n2Ok? "Ok": "Failed");
      printf("AbsMax (vector/row/column):               %s\n", amaxOk? "Ok": "Failed");
      printf("Upper Hessenberg 1 Norm:                  %s\n", hsnOk? "Ok": "Failed");
      printf("Matrix-Vector Multiply:                   %s\n", mvOk? "Ok": "Failed");
      printf("In-Place Transpose:                       %s\n", itOk? "Ok": "Failed");
      printf("Copy And Transpose:                       %s\n", ctOk? "Ok": "Failed");
      printf("Matrix-Matrix Multiply:                   %s\n", mmOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === evd testing unit ===
// Sparse fill
//
// Sparsity - sparsity level, in [0,1] (0 == dense matrix).
// DiagMAg - magnitude of dense diagonal entries; zero value means that diagonal
// is sparse too, non-zero value means that diagonal is dense
static void testevdunit_rmatrixfillsparsea(RMatrix *a, ae_int_t m, ae_int_t n, double sparsity, double diagmag) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         if (randombool(sparsity)) {
            a->xyR[i][j] = 0.0;
         } else {
            a->xyR[i][j] = randommid();
         }
      }
   }
   if (diagmag > 0.0) {
      for (i = 0; i < imin2(m, n); i++) {
         a->xyR[i][i] = diagmag * randommid();
      }
   }
}

// Sparse fill
//
// Sparsity - sparsity level, in [0,1] (0 == dense matrix).
// DiagMAg - magnitude of dense diagonal entries; zero value means that diagonal
// is sparse too, non-zero value means that diagonal is dense
static void testevdunit_cmatrixfillsparsea(CMatrix *a, ae_int_t m, ae_int_t n, double sparsity, double diagmag) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         if (randombool(sparsity)) {
            a->xyC[i][j] = complex_from_i(0);
         } else {
            a->xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
   }
   if (diagmag > 0.0) {
      for (i = 0; i < imin2(m, n); i++) {
         a->xyC[i][i] = complex_from_d(diagmag * randommid(), diagmag * randommid());
      }
   }
}

// Copies A to AL (lower half) and AU (upper half), filling unused parts by
// random garbage.
static void testevdunit_rmatrixsymmetricsplit(RMatrix *a, ae_int_t n, RMatrix *al, RMatrix *au) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = i + 1; j < n; j++) {
         al->xyR[i][j] = randommid();
         al->xyR[j][i] = a->xyR[i][j];
         au->xyR[i][j] = a->xyR[i][j];
         au->xyR[j][i] = randommid();
      }
      al->xyR[i][i] = a->xyR[i][i];
      au->xyR[i][i] = a->xyR[i][i];
   }
}

// Copies A to AL (lower half) and AU (upper half), filling unused parts by
// random garbage.
static void testevdunit_cmatrixhermitiansplit(CMatrix *a, ae_int_t n, CMatrix *al, CMatrix *au) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = i + 1; j < n; j++) {
         al->xyC[i][j] = complex_from_d(randommid());
         al->xyC[j][i] = conj(a->xyC[i][j]);
         au->xyC[i][j] = a->xyC[i][j];
         au->xyC[j][i] = complex_from_d(randommid());
      }
      al->xyC[i][i] = a->xyC[i][i];
      au->xyC[i][i] = a->xyC[i][i];
   }
}

// Unsets 2D array.
static void testevdunit_unset2d(RMatrix *a) {
   SetMatrix(a);
   if (a->rows * a->cols > 0) {
      ae_matrix_set_length(a, 1, 1);
   }
}

// Unsets 2D array.
static void testevdunit_cunset2d(CMatrix *a) {
   ae_matrix_set_length(a, 0 + 1, 0 + 1);
   a->xyC[0][0] = complex_from_d(randommid());
}

// Unsets 1D array.
static void testevdunit_unset1d(RVector *a) {
   SetVector(a);
   if (a->cnt > 0) {
      ae_vector_set_length(a, 1);
   }
}

// Tests Z*Lambda*Z' against tridiag(D,E).
// Returns relative error.
static double testevdunit_tdtestproduct(RVector *d, RVector *e, ae_int_t n, RMatrix *z, RVector *lambdav) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double mx;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
      // Calculate V = A[i,j], A = Z*Lambda*Z'
         v = 0.0;
         for (k = 0; k < n; k++) {
            v += z->xyR[i][k] * lambdav->xR[k] * z->xyR[j][k];
         }
      // Compare
         if (ae_iabs(i - j) == 0) {
            result = rmax2(result, fabs(v - d->xR[i]));
         }
         if (ae_iabs(i - j) == 1) {
            result = rmax2(result, fabs(v - e->xR[imin2(i, j)]));
         }
         if (ae_iabs(i - j) > 1) {
            result = rmax2(result, fabs(v));
         }
      }
   }
   mx = 0.0;
   for (i = 0; i < n; i++) {
      mx = rmax2(mx, fabs(d->xR[i]));
   }
   for (i = 0; i < n - 1; i++) {
      mx = rmax2(mx, fabs(e->xR[i]));
   }
   if (mx == 0.0) {
      mx = 1.0;
   }
   result /= mx;
   return result;
}

// Tests Z*Lambda*Z' against A
// Returns relative error.
static double testevdunit_testproduct(RMatrix *a, ae_int_t n, RMatrix *z, RVector *lambdav) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double mx;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
      // Calculate V = A[i,j], A = Z*Lambda*Z'
         v = 0.0;
         for (k = 0; k < n; k++) {
            v += z->xyR[i][k] * lambdav->xR[k] * z->xyR[j][k];
         }
      // Compare
         result = rmax2(result, fabs(v - a->xyR[i][j]));
      }
   }
   mx = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         mx = rmax2(mx, fabs(a->xyR[i][j]));
      }
   }
   if (mx == 0.0) {
      mx = 1.0;
   }
   result /= mx;
   return result;
}

// Tests Z*Lambda*Z' against A
// Returns relative error.
static double testevdunit_testcproduct(CMatrix *a, ae_int_t n, CMatrix *z, RVector *lambdav) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   complex v;
   double mx;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
      // Calculate V = A[i,j], A = Z*Lambda*Z'
         v = complex_from_i(0);
         for (k = 0; k < n; k++) {
            v = ae_c_add(v, ae_c_mul(ae_c_mul_d(z->xyC[i][k], lambdav->xR[k]), conj(z->xyC[j][k])));
         }
      // Compare
         result = rmax2(result, abscomplex(ae_c_sub(v, a->xyC[i][j])));
      }
   }
   mx = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         mx = rmax2(mx, abscomplex(a->xyC[i][j]));
      }
   }
   if (mx == 0.0) {
      mx = 1.0;
   }
   result /= mx;
   return result;
}

// Tests Z*Z' against diag(1...1)
// Returns absolute error.
static double testevdunit_testort(RMatrix *z, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   double v;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(&z->xyR[0][i], z->stride, &z->xyR[0][j], z->stride, n);
         if (i == j) {
            v--;
         }
         result = rmax2(result, fabs(v));
      }
   }
   return result;
}

// Tests Z*Z' against diag(1...1)
// Returns absolute error.
static double testevdunit_testcort(CMatrix *z, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   complex v;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(&z->xyC[0][i], z->stride, "N", &z->xyC[0][j], z->stride, "Conj", n);
         if (i == j) {
            v = ae_c_sub_d(v, 1);
         }
         result = rmax2(result, abscomplex(v));
      }
   }
   return result;
}

// Tests SEVD problem
static bool testevdunit_testsevdproblem(RMatrix *a, RMatrix *al, RMatrix *au, ae_int_t n, double threshold, ae_int_t *failc, ae_int_t *runs) {
   ae_frame _frame_block;
   ae_int_t i;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(lambdav, 0, DT_REAL);
   NewVector(lambdaref, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
// Test simple EVD: values and full vectors, lower A
   testevdunit_unset1d(&lambdaref);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevd(al, n, 1, false, &lambdaref, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && testevdunit_testproduct(a, n, &z, &lambdaref) <= threshold;
   Ok = Ok && testevdunit_testort(&z, n) <= threshold;
   for (i = 0; i < n - 1; i++) {
      if (lambdaref.xR[i + 1] < lambdaref.xR[i]) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
// Test simple EVD: values and full vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevd(au, n, 1, true, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && testevdunit_testproduct(a, n, &z, &lambdav) <= threshold;
   Ok = Ok && testevdunit_testort(&z, n) <= threshold;
   for (i = 0; i < n - 1; i++) {
      if (lambdav.xR[i + 1] < lambdav.xR[i]) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
// Test simple EVD: values only, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevd(al, n, 0, false, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (i = 0; i < n; i++) {
      Ok = Ok && NearAtR(lambdav.xR[i], lambdaref.xR[i], threshold);
   }
// Test simple EVD: values only, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevd(au, n, 0, true, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (i = 0; i < n; i++) {
      Ok = Ok && NearAtR(lambdav.xR[i], lambdaref.xR[i], threshold);
   }
   ae_frame_leave();
   return Ok;
}

// Tests SEVD problem
static bool testevdunit_testhevdproblem(CMatrix *a, CMatrix *al, CMatrix *au, ae_int_t n, double threshold, ae_int_t *failc, ae_int_t *runs) {
   ae_frame _frame_block;
   ae_int_t i;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(lambdav, 0, DT_REAL);
   NewVector(lambdaref, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_COMPLEX);
// Test simple EVD: values and full vectors, lower A
   testevdunit_unset1d(&lambdaref);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevd(al, n, 1, false, &lambdaref, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && testevdunit_testcproduct(a, n, &z, &lambdaref) <= threshold;
   Ok = Ok && testevdunit_testcort(&z, n) <= threshold;
   for (i = 0; i < n - 1; i++) {
      if (lambdaref.xR[i + 1] < lambdaref.xR[i]) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
// Test simple EVD: values and full vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevd(au, n, 1, true, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && testevdunit_testcproduct(a, n, &z, &lambdav) <= threshold;
   Ok = Ok && testevdunit_testcort(&z, n) <= threshold;
   for (i = 0; i < n - 1; i++) {
      if (lambdav.xR[i + 1] < lambdav.xR[i]) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
// Test simple EVD: values only, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevd(al, n, 0, false, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (i = 0; i < n; i++) {
      Ok = Ok && NearAtR(lambdav.xR[i], lambdaref.xR[i], threshold);
   }
// Test simple EVD: values only, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevd(au, n, 0, true, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (i = 0; i < n; i++) {
      Ok = Ok && NearAtR(lambdav.xR[i], lambdaref.xR[i], threshold);
   }
   ae_frame_leave();
   return Ok;
}

// Tests EVD problem
//
// DistVals    -   is True, when eigenvalues are distinct. Is False, when we
//                 are solving sparse task with  lots  of  zero  eigenvalues.
//                 In such cases some tests related to the  eigenvectors  are
//                 not performed.
static bool testevdunit_testsevdbiproblem(RMatrix *afull, RMatrix *al, RMatrix *au, ae_int_t n, bool distvals, double threshold, ae_int_t *failc, ae_int_t *runs) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t m;
   ae_int_t i1;
   ae_int_t i2;
   double v;
   double a;
   double b;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(lambdav, 0, DT_REAL);
   NewVector(lambdaref, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewMatrix(zref, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewMatrix(ar, 0, 0, DT_REAL);
   ae_vector_set_length(&lambdaref, n);
   ae_matrix_set_length(&zref, n, n);
   ae_matrix_set_length(&a1, n, n);
   ae_matrix_set_length(&a2, n, n);
// Reference EVD
   ++*runs;
   if (!smatrixevd(afull, n, 1, true, &lambdaref, &zref)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
// Select random interval boundaries.
// If there are non-distinct eigenvalues at the boundaries,
// we move indexes further until values splits. It is done to
// avoid situations where we can't get definite answer.
   i1 = randominteger(n);
   i2 = i1 + randominteger(n - i1);
   while (i1 > 0) {
      if (!NearAtR(lambdaref.xR[i1 - 1], lambdaref.xR[i1], 10 * threshold)) {
         break;
      }
      i1--;
   }
   while (i2 < n - 1) {
      if (!NearAtR(lambdaref.xR[i2 + 1], lambdaref.xR[i2], 10 * threshold)) {
         break;
      }
      i2++;
   }
// Select A, B
   if (i1 > 0) {
      a = 0.5 * (lambdaref.xR[i1] + lambdaref.xR[i1 - 1]);
   } else {
      a = lambdaref.xR[0] - 1;
   }
   if (i2 < n - 1) {
      b = 0.5 * (lambdaref.xR[i2] + lambdaref.xR[i2 + 1]);
   } else {
      b = lambdaref.xR[n - 1] + 1;
   }
// Test interval, no vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdr(al, n, 0, false, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
// Test interval, no vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdr(au, n, 0, true, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
// Test indexes, no vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdi(al, n, 0, false, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
// Test indexes, no vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdi(au, n, 0, true, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
// Test interval, vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdr(al, n, 1, false, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&z.xyR[0][j], z.stride, &zref.xyR[0][i1 + j], zref.stride, n);
         if (v < 0.0) {
            ae_v_muld(&z.xyR[0][j], z.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtR(z.xyR[i][j], zref.xyR[i][i1 + j], threshold);
         }
      }
   }
// Test interval, vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdr(au, n, 1, true, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&z.xyR[0][j], z.stride, &zref.xyR[0][i1 + j], zref.stride, n);
         if (v < 0.0) {
            ae_v_muld(&z.xyR[0][j], z.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtR(z.xyR[i][j], zref.xyR[i][i1 + j], threshold);
         }
      }
   }
// Test indexes, vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdi(al, n, 1, false, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&z.xyR[0][j], z.stride, &zref.xyR[0][i1 + j], zref.stride, n);
         if (v < 0.0) {
            ae_v_muld(&z.xyR[0][j], z.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtR(z.xyR[i][j], zref.xyR[i][i1 + j], threshold);
         }
      }
   }
// Test indexes, vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdi(au, n, 1, true, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&z.xyR[0][j], z.stride, &zref.xyR[0][i1 + j], zref.stride, n);
         if (v < 0.0) {
            ae_v_muld(&z.xyR[0][j], z.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtR(z.xyR[i][j], zref.xyR[i][i1 + j], threshold);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Tests EVD problem
//
// DistVals    -   is True, when eigenvalues are distinct. Is False, when we
//                 are solving sparse task with  lots  of  zero  eigenvalues.
//                 In such cases some tests related to the  eigenvectors  are
//                 not performed.
static bool testevdunit_testhevdbiproblem(CMatrix *afull, CMatrix *al, CMatrix *au, ae_int_t n, bool distvals, double threshold, ae_int_t *failc, ae_int_t *runs) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t m;
   ae_int_t i1;
   ae_int_t i2;
   complex v;
   double a;
   double b;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(lambdav, 0, DT_REAL);
   NewVector(lambdaref, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_COMPLEX);
   NewMatrix(zref, 0, 0, DT_COMPLEX);
   NewMatrix(a1, 0, 0, DT_COMPLEX);
   NewMatrix(a2, 0, 0, DT_COMPLEX);
   NewMatrix(ar, 0, 0, DT_COMPLEX);
   ae_vector_set_length(&lambdaref, n);
   ae_matrix_set_length(&zref, n, n);
   ae_matrix_set_length(&a1, n, n);
   ae_matrix_set_length(&a2, n, n);
// Reference EVD
   ++*runs;
   if (!hmatrixevd(afull, n, 1, true, &lambdaref, &zref)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
// Select random interval boundaries.
// If there are non-distinct eigenvalues at the boundaries,
// we move indexes further until values splits. It is done to
// avoid situations where we can't get definite answer.
   i1 = randominteger(n);
   i2 = i1 + randominteger(n - i1);
   while (i1 > 0) {
      if (!NearAtR(lambdaref.xR[i1 - 1], lambdaref.xR[i1], 10 * threshold)) {
         break;
      }
      i1--;
   }
   while (i2 < n - 1) {
      if (!NearAtR(lambdaref.xR[i2 + 1], lambdaref.xR[i2], 10 * threshold)) {
         break;
      }
      i2++;
   }
// Select A, B
   if (i1 > 0) {
      a = 0.5 * (lambdaref.xR[i1] + lambdaref.xR[i1 - 1]);
   } else {
      a = lambdaref.xR[0] - 1;
   }
   if (i2 < n - 1) {
      b = 0.5 * (lambdaref.xR[i2] + lambdaref.xR[i2 + 1]);
   } else {
      b = lambdaref.xR[n - 1] + 1;
   }
// Test interval, no vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdr(al, n, 0, false, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
// Test interval, no vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdr(au, n, 0, true, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
// Test indexes, no vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdi(al, n, 0, false, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
// Test indexes, no vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdi(au, n, 0, true, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
// Test interval, vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdr(al, n, 1, false, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_cdotproduct(&z.xyC[0][j], z.stride, "N", &zref.xyC[0][i1 + j], zref.stride, "Conj", n);
         v = conj(ae_c_div_d(v, abscomplex(v)));
         ae_v_cmulc(&z.xyC[0][j], z.stride, n, v);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtC(z.xyC[i][j], zref.xyC[i][i1 + j], threshold);
         }
      }
   }
// Test interval, vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdr(au, n, 1, true, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_cdotproduct(&z.xyC[0][j], z.stride, "N", &zref.xyC[0][i1 + j], zref.stride, "Conj", n);
         v = conj(ae_c_div_d(v, abscomplex(v)));
         ae_v_cmulc(&z.xyC[0][j], z.stride, n, v);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtC(z.xyC[i][j], zref.xyC[i][i1 + j], threshold);
         }
      }
   }
// Test indexes, vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdi(al, n, 1, false, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_cdotproduct(&z.xyC[0][j], z.stride, "N", &zref.xyC[0][i1 + j], zref.stride, "Conj", n);
         v = conj(ae_c_div_d(v, abscomplex(v)));
         ae_v_cmulc(&z.xyC[0][j], z.stride, n, v);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtC(z.xyC[i][j], zref.xyC[i][i1 + j], threshold);
         }
      }
   }
// Test indexes, vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdi(au, n, 1, true, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_cdotproduct(&z.xyC[0][j], z.stride, "N", &zref.xyC[0][i1 + j], zref.stride, "Conj", n);
         v = conj(ae_c_div_d(v, abscomplex(v)));
         ae_v_cmulc(&z.xyC[0][j], z.stride, n, v);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtC(z.xyC[i][j], zref.xyC[i][i1 + j], threshold);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Tests EVD problem
static bool testevdunit_testtdevdproblem(RVector *d, RVector *e, ae_int_t n, double threshold) {
   ae_frame _frame_block;
   bool wsucc;
   ae_int_t i;
   ae_int_t j;
   double v;
   double worstseparation;
   double requiredseparation;
   double specialthreshold;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(lambdav, 0, DT_REAL);
   NewVector(ee, 0, DT_REAL);
   NewVector(lambda2, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewMatrix(zref, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   ae_vector_set_length(&lambdav, n);
   ae_vector_set_length(&lambda2, n);
   ae_matrix_set_length(&zref, n, n);
   ae_matrix_set_length(&a1, n, n);
   ae_matrix_set_length(&a2, n, n);
   if (n > 1) {
      ae_vector_set_length(&ee, n - 1);
   }
// Test simple EVD: values and full vectors
   for (i = 0; i < n; i++) {
      lambdav.xR[i] = d->xR[i];
   }
   for (i = 0; i < n - 1; i++) {
      ee.xR[i] = e->xR[i];
   }
   testevdunit_unset2d(&z);
   wsucc = smatrixtdevd(&lambdav, &ee, n, 2, &z);
   if (!wsucc) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && testevdunit_tdtestproduct(d, e, n, &z, &lambdav) <= threshold;
   Ok = Ok && testevdunit_testort(&z, n) <= threshold;
   for (i = 0; i < n - 1; i++) {
      if (lambdav.xR[i + 1] < lambdav.xR[i]) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         zref.xyR[i][j] = z.xyR[i][j];
      }
   }
// Test values only variant
   for (i = 0; i < n; i++) {
      lambda2.xR[i] = d->xR[i];
   }
   for (i = 0; i < n - 1; i++) {
      ee.xR[i] = e->xR[i];
   }
   testevdunit_unset2d(&z);
   wsucc = smatrixtdevd(&lambda2, &ee, n, 0, &z);
   if (!wsucc) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   for (i = 0; i < n; i++) {
      Ok = Ok && NearAtR(lambda2.xR[i], lambdav.xR[i], threshold);
   }
// Test multiplication variant
   for (i = 0; i < n; i++) {
      lambda2.xR[i] = d->xR[i];
   }
   for (i = 0; i < n - 1; i++) {
      ee.xR[i] = e->xR[i];
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a1.xyR[i][j] = randommid();
         a2.xyR[i][j] = a1.xyR[i][j];
      }
   }
   wsucc = smatrixtdevd(&lambda2, &ee, n, 1, &a1);
   if (!wsucc) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   for (i = 0; i < n; i++) {
      Ok = Ok && NearAtR(lambda2.xR[i], lambdav.xR[i], threshold);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(a2.xyR[i], 1, &zref.xyR[0][j], zref.stride, n);
      // next line is a bit complicated because
      // depending on algorithm used we can get either
      // z or -z as eigenvector. so we compare result
      // with both A*ZRef and -A*ZRef
         Ok = Ok && (NearAtR(v, a1.xyR[i][j], threshold) || NearAtR(v, -a1.xyR[i][j], threshold));
      }
   }
// Test first row variant.
//
// NOTE: this test is special because ZNeeded == 3 is ALGLIB-specific feature
//       which is NOT supported by Intel MKL. Thus, MKL-capable version of
//       ALGLIB will use different algorithms for ZNeeded == 3 and for ZNeeded < 3.
//
//       In most cases it is OK, but when problem happened to be degenerate
//       (two close eigenvalues), Z computed by ALGLIB may be different from
//       Z computed by MKL (up to arbitrary rotation), which will lead to
//       failure of the test, because ZNeeded == 2 is used as reference value
//       for ZNeeded == 3.
//
//       That's why this test is performed only for well-separated matrices,
//       and with custom threshold.
   requiredseparation = 1.0E-6;
   specialthreshold = 1.0E-6;
   worstseparation = maxrealnumber;
   for (i = 0; i < n - 1; i++) {
      worstseparation = rmin2(worstseparation, fabs(lambdav.xR[i + 1] - lambdav.xR[i]));
   }
   if (worstseparation > requiredseparation) {
      for (i = 0; i < n; i++) {
         lambda2.xR[i] = d->xR[i];
      }
      for (i = 0; i < n - 1; i++) {
         ee.xR[i] = e->xR[i];
      }
      testevdunit_unset2d(&z);
      wsucc = smatrixtdevd(&lambda2, &ee, n, 3, &z);
      if (!wsucc) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(lambda2.xR[i], lambdav.xR[i], threshold);
      // next line is a bit complicated because
      // depending on algorithm used we can get either
      // z or -z as eigenvector. so we compare result
      // with both z and -z
         Ok = Ok && (NearAtR(z.xyR[0][i], zref.xyR[0][i], specialthreshold) || NearAtR(z.xyR[0][i], -zref.xyR[0][i], specialthreshold));
      }
   }
   ae_frame_leave();
   return Ok;
}

// Tests EVD problem
//
// DistVals    -   is True, when eigenvalues are distinct. Is False, when we
//                 are solving sparse task with  lots  of  zero  eigenvalues.
//                 In such cases some tests related to the  eigenvectors  are
//                 not performed.
static bool testevdunit_testtdevdbiproblem(RVector *d, RVector *e, ae_int_t n, bool distvals, double threshold, ae_int_t *failc, ae_int_t *runs) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t m;
   ae_int_t i1;
   ae_int_t i2;
   double v;
   double a;
   double b;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(lambdav, 0, DT_REAL);
   NewVector(lambdaref, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewMatrix(zref, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewMatrix(ar, 0, 0, DT_REAL);
   ae_vector_set_length(&lambdaref, n);
   ae_matrix_set_length(&zref, n, n);
   ae_matrix_set_length(&a1, n, n);
   ae_matrix_set_length(&a2, n, n);
// Reference EVD
   ae_vector_set_length(&lambdaref, n);
   ae_v_move(lambdaref.xR, 1, d->xR, 1, n);
   ++*runs;
   if (!smatrixtdevd(&lambdaref, e, n, 2, &zref)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
// Select random interval boundaries.
// If there are non-distinct eigenvalues at the boundaries,
// we move indexes further until values splits. It is done to
// avoid situations where we can't get definite answer.
   i1 = randominteger(n);
   i2 = i1 + randominteger(n - i1);
   while (i1 > 0) {
      if (!NearAtR(lambdaref.xR[i1 - 1], lambdaref.xR[i1], 10 * threshold)) {
         break;
      }
      i1--;
   }
   while (i2 < n - 1) {
      if (!NearAtR(lambdaref.xR[i2 + 1], lambdaref.xR[i2], 10 * threshold)) {
         break;
      }
      i2++;
   }
// Test different combinations
// Select A, B
   if (i1 > 0) {
      a = 0.5 * (lambdaref.xR[i1] + lambdaref.xR[i1 - 1]);
   } else {
      a = lambdaref.xR[0] - 1;
   }
   if (i2 < n - 1) {
      b = 0.5 * (lambdaref.xR[i2] + lambdaref.xR[i2 + 1]);
   } else {
      b = lambdaref.xR[n - 1] + 1;
   }
// Test interval, no vectors
   ae_vector_set_length(&lambdav, n);
   for (i = 0; i < n; i++) {
      lambdav.xR[i] = d->xR[i];
   }
   ++*runs;
   if (!smatrixtdevdr(&lambdav, e, n, 0, a, b, &m, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
// Test indexes, no vectors
   ae_vector_set_length(&lambdav, n);
   for (i = 0; i < n; i++) {
      lambdav.xR[i] = d->xR[i];
   }
   ++*runs;
   if (!smatrixtdevdi(&lambdav, e, n, 0, i1, i2, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
// Test interval, transform vectors
   ae_vector_set_length(&lambdav, n);
   for (i = 0; i < n; i++) {
      lambdav.xR[i] = d->xR[i];
   }
   ae_matrix_set_length(&a1, n, n);
   ae_matrix_set_length(&a2, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a1.xyR[i][j] = randommid();
         a2.xyR[i][j] = a1.xyR[i][j];
      }
   }
   ++*runs;
   if (!smatrixtdevdr(&lambdav, e, n, 1, a, b, &m, &a1)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
   if (distvals) {
      ae_matrix_set_length(&ar, n, m);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            v = ae_v_dotproduct(a2.xyR[i], 1, &zref.xyR[0][i1 + j], zref.stride, n);
            ar.xyR[i][j] = v;
         }
      }
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&a1.xyR[0][j], a1.stride, &ar.xyR[0][j], ar.stride, n);
         if (v < 0.0) {
            ae_v_muld(&ar.xyR[0][j], ar.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtR(a1.xyR[i][j], ar.xyR[i][j], threshold);
         }
      }
   }
// Test indexes, transform vectors
   ae_vector_set_length(&lambdav, n);
   for (i = 0; i < n; i++) {
      lambdav.xR[i] = d->xR[i];
   }
   ae_matrix_set_length(&a1, n, n);
   ae_matrix_set_length(&a2, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a1.xyR[i][j] = randommid();
         a2.xyR[i][j] = a1.xyR[i][j];
      }
   }
   ++*runs;
   if (!smatrixtdevdi(&lambdav, e, n, 1, i1, i2, &a1)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
   if (distvals) {
      ae_matrix_set_length(&ar, n, m);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            v = ae_v_dotproduct(a2.xyR[i], 1, &zref.xyR[0][i1 + j], zref.stride, n);
            ar.xyR[i][j] = v;
         }
      }
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&a1.xyR[0][j], a1.stride, &ar.xyR[0][j], ar.stride, n);
         if (v < 0.0) {
            ae_v_muld(&ar.xyR[0][j], ar.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtR(a1.xyR[i][j], ar.xyR[i][j], threshold);
         }
      }
   }
// Test interval, do not transform vectors
   ae_vector_set_length(&lambdav, n);
   for (i = 0; i < n; i++) {
      lambdav.xR[i] = d->xR[i];
   }
   ae_matrix_set_length(&z, 0 + 1, 0 + 1);
   ++*runs;
   if (!smatrixtdevdr(&lambdav, e, n, 2, a, b, &m, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
   if (distvals) {
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&z.xyR[0][j], z.stride, &zref.xyR[0][i1 + j], zref.stride, n);
         if (v < 0.0) {
            ae_v_muld(&z.xyR[0][j], z.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtR(z.xyR[i][j], zref.xyR[i][i1 + j], threshold);
         }
      }
   }
// Test indexes, do not transform vectors
   ae_vector_set_length(&lambdav, n);
   for (i = 0; i < n; i++) {
      lambdav.xR[i] = d->xR[i];
   }
   ae_matrix_set_length(&z, 0 + 1, 0 + 1);
   ++*runs;
   if (!smatrixtdevdi(&lambdav, e, n, 2, i1, i2, &z)) {
      ++*failc;
      ae_frame_leave();
      return Ok;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      Ok = Ok && NearAtR(lambdav.xR[k], lambdaref.xR[i1 + k], threshold);
   }
   if (distvals) {
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&z.xyR[0][j], z.stride, &zref.xyR[0][i1 + j], zref.stride, n);
         if (v < 0.0) {
            ae_v_muld(&z.xyR[0][j], z.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtR(z.xyR[i][j], zref.xyR[i][i1 + j], threshold);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Non-symmetric problem
static bool testevdunit_testnsevdproblem(RMatrix *a, ae_int_t n, double threshold) {
   ae_frame _frame_block;
   double mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t vjob;
   bool needl;
   bool needr;
   double curwr;
   double curwi;
   double vt;
   double vnorm;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(wr0, 0, DT_REAL);
   NewVector(wi0, 0, DT_REAL);
   NewVector(wr1, 0, DT_REAL);
   NewVector(wi1, 0, DT_REAL);
   NewVector(wr0s, 0, DT_REAL);
   NewVector(wi0s, 0, DT_REAL);
   NewVector(wr1s, 0, DT_REAL);
   NewVector(wi1s, 0, DT_REAL);
   NewMatrix(vl, 0, 0, DT_REAL);
   NewMatrix(vr, 0, 0, DT_REAL);
   NewVector(vec1r, 0, DT_REAL);
   NewVector(vec1i, 0, DT_REAL);
   NewVector(vec2r, 0, DT_REAL);
   NewVector(vec2i, 0, DT_REAL);
   NewVector(vec3r, 0, DT_REAL);
   NewVector(vec3i, 0, DT_REAL);
   ae_vector_set_length(&vec1r, n);
   ae_vector_set_length(&vec2r, n);
   ae_vector_set_length(&vec3r, n);
   ae_vector_set_length(&vec1i, n);
   ae_vector_set_length(&vec2i, n);
   ae_vector_set_length(&vec3i, n);
   ae_vector_set_length(&wr0s, n);
   ae_vector_set_length(&wr1s, n);
   ae_vector_set_length(&wi0s, n);
   ae_vector_set_length(&wi1s, n);
   mx = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (!SmallAtR(a->xyR[i][j], mx)) {
            mx = fabs(a->xyR[i][j]);
         }
      }
   }
   if (mx == 0.0) {
      mx = 1.0;
   }
// Load values-only
   if (!rmatrixevd(a, n, 0, &wr0, &wi0, &vl, &vr)) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
// Test different jobs
   for (vjob = 1; vjob <= 3; vjob++) {
      needr = vjob == 1 || vjob == 3;
      needl = vjob == 2 || vjob == 3;
      if (!rmatrixevd(a, n, vjob, &wr1, &wi1, &vl, &vr)) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   // Test values:
   // 1. sort by real part
   // 2. test
      ae_v_move(wr0s.xR, 1, wr0.xR, 1, n);
      ae_v_move(wi0s.xR, 1, wi0.xR, 1, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n - 1 - i; j++) {
            if (wr0s.xR[j] > wr0s.xR[j + 1]) {
               swapr(&wr0s.xR[j], &wr0s.xR[j + 1]);
               swapr(&wi0s.xR[j], &wi0s.xR[j + 1]);
            }
         }
      }
      ae_v_move(wr1s.xR, 1, wr1.xR, 1, n);
      ae_v_move(wi1s.xR, 1, wi1.xR, 1, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n - 1 - i; j++) {
            if (wr1s.xR[j] > wr1s.xR[j + 1]) {
               swapr(&wr1s.xR[j], &wr1s.xR[j + 1]);
               swapr(&wi1s.xR[j], &wi1s.xR[j + 1]);
            }
         }
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(wr0s.xR[i], wr1s.xR[i], threshold);
         Ok = Ok && NearAtR(wi0s.xR[i], wi1s.xR[i], threshold);
      }
   // Test right vectors
      if (needr) {
         k = 0;
         while (k < n) {
            curwr = 0.0;
            curwi = 0.0;
            if (wi1.xR[k] == 0.0) {
               ae_v_move(vec1r.xR, 1, &vr.xyR[0][k], vr.stride, n);
               for (i = 0; i < n; i++) {
                  vec1i.xR[i] = 0.0;
               }
               curwr = wr1.xR[k];
               curwi = 0.0;
            }
            if (wi1.xR[k] > 0.0) {
               ae_v_move(vec1r.xR, 1, &vr.xyR[0][k], vr.stride, n);
               ae_v_move(vec1i.xR, 1, &vr.xyR[0][k + 1], vr.stride, n);
               curwr = wr1.xR[k];
               curwi = wi1.xR[k];
            }
            if (wi1.xR[k] < 0.0) {
               ae_v_move(vec1r.xR, 1, &vr.xyR[0][k - 1], vr.stride, n);
               ae_v_moveneg(vec1i.xR, 1, &vr.xyR[0][k], vr.stride, n);
               curwr = wr1.xR[k];
               curwi = wi1.xR[k];
            }
            vnorm = 0.0;
            for (i = 0; i < n; i++) {
               vt = ae_v_dotproduct(a->xyR[i], 1, vec1r.xR, 1, n);
               vec2r.xR[i] = vt;
               vt = ae_v_dotproduct(a->xyR[i], 1, vec1i.xR, 1, n);
               vec2i.xR[i] = vt;
               vnorm += sqr(vec1r.xR[i]) + sqr(vec1i.xR[i]);
            }
            vnorm = sqrt(vnorm);
            ae_v_moved(vec3r.xR, 1, vec1r.xR, 1, n, curwr);
            ae_v_subd(vec3r.xR, 1, vec1i.xR, 1, n, curwi);
            ae_v_moved(vec3i.xR, 1, vec1r.xR, 1, n, curwi);
            ae_v_addd(vec3i.xR, 1, vec1i.xR, 1, n, curwr);
            Ok = Ok && vnorm >= 1.0E-3 && isfinite(vnorm);
            for (i = 0; i < n; i++) {
               Ok = Ok && NearAtR(vec2r.xR[i], vec3r.xR[i], threshold);
               Ok = Ok && NearAtR(vec2i.xR[i], vec3i.xR[i], threshold);
            }
            k++;
         }
      }
   // Test left vectors
      curwr = 0.0;
      curwi = 0.0;
      if (needl) {
         k = 0;
         while (k < n) {
            if (wi1.xR[k] == 0.0) {
               ae_v_move(vec1r.xR, 1, &vl.xyR[0][k], vl.stride, n);
               for (i = 0; i < n; i++) {
                  vec1i.xR[i] = 0.0;
               }
               curwr = wr1.xR[k];
               curwi = 0.0;
            }
            if (wi1.xR[k] > 0.0) {
               ae_v_move(vec1r.xR, 1, &vl.xyR[0][k], vl.stride, n);
               ae_v_move(vec1i.xR, 1, &vl.xyR[0][k + 1], vl.stride, n);
               curwr = wr1.xR[k];
               curwi = wi1.xR[k];
            }
            if (wi1.xR[k] < 0.0) {
               ae_v_move(vec1r.xR, 1, &vl.xyR[0][k - 1], vl.stride, n);
               ae_v_moveneg(vec1i.xR, 1, &vl.xyR[0][k], vl.stride, n);
               curwr = wr1.xR[k];
               curwi = wi1.xR[k];
            }
            vnorm = 0.0;
            for (j = 0; j < n; j++) {
               vt = ae_v_dotproduct(vec1r.xR, 1, &a->xyR[0][j], a->stride, n);
               vec2r.xR[j] = vt;
               vt = ae_v_dotproduct(vec1i.xR, 1, &a->xyR[0][j], a->stride, n);
               vec2i.xR[j] = -vt;
               vnorm += sqr(vec1r.xR[j]) + sqr(vec1i.xR[j]);
            }
            vnorm = sqrt(vnorm);
            ae_v_moved(vec3r.xR, 1, vec1r.xR, 1, n, curwr);
            ae_v_addd(vec3r.xR, 1, vec1i.xR, 1, n, curwi);
            ae_v_moved(vec3i.xR, 1, vec1r.xR, 1, n, curwi);
            ae_v_addd(vec3i.xR, 1, vec1i.xR, 1, n, -curwr);
            Ok = Ok && vnorm >= 1.0E-3 && isfinite(vnorm);
            for (i = 0; i < n; i++) {
               Ok = Ok && NearAtR(vec2r.xR[i], vec3r.xR[i], threshold);
               Ok = Ok && NearAtR(vec2i.xR[i], vec3i.xR[i], threshold);
            }
            k++;
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Testing EVD subroutines for one N
//
// NOTES:
// * BIThreshold is a threshold for bisection-and-inverse-iteration subroutines.
//   special threshold is needed because these subroutines may have much more
//   larger error than QR-based algorithms.
static void testevdunit_testevdset(ae_int_t n, double threshold, double bithreshold, ae_int_t *failc, ae_int_t *runs, bool *NsOkP, bool *SOkP, bool *HOkP, bool *TdOkP, bool *SbiOkP, bool *HbiOkP, bool *TdbiOkP) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t mkind;
   ae_frame_make(&_frame_block);
   NewMatrix(ra, 0, 0, DT_REAL);
   NewMatrix(ral, 0, 0, DT_REAL);
   NewMatrix(rau, 0, 0, DT_REAL);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewMatrix(cal, 0, 0, DT_COMPLEX);
   NewMatrix(cau, 0, 0, DT_COMPLEX);
   NewVector(d, 0, DT_REAL);
   NewVector(e, 0, DT_REAL);
// Test symmetric problems
   ae_matrix_set_length(&ra, n, n);
   ae_matrix_set_length(&ral, n, n);
   ae_matrix_set_length(&rau, n, n);
   ae_matrix_set_length(&ca, n, n);
   ae_matrix_set_length(&cal, n, n);
   ae_matrix_set_length(&cau, n, n);
// Zero matrices
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         ra.xyR[i][j] = 0.0;
         ca.xyC[i][j] = complex_from_i(0);
      }
   }
   testevdunit_rmatrixsymmetricsplit(&ra, n, &ral, &rau);
   testevdunit_cmatrixhermitiansplit(&ca, n, &cal, &cau);
   *SOkP = *SOkP && testevdunit_testsevdproblem(&ra, &ral, &rau, n, threshold, failc, runs);
   *HOkP = *HOkP && testevdunit_testhevdproblem(&ca, &cal, &cau, n, threshold, failc, runs);
   *SbiOkP = *SbiOkP && testevdunit_testsevdbiproblem(&ra, &ral, &rau, n, false, bithreshold, failc, runs);
   *HbiOkP = *HbiOkP && testevdunit_testhevdbiproblem(&ca, &cal, &cau, n, false, bithreshold, failc, runs);
// Random matrix
   for (i = 0; i < n; i++) {
      for (j = i + 1; j < n; j++) {
         ra.xyR[i][j] = randommid();
         ca.xyC[i][j] = complex_from_d(randommid(), randommid());
         ra.xyR[j][i] = ra.xyR[i][j];
         ca.xyC[j][i] = conj(ca.xyC[i][j]);
      }
      ra.xyR[i][i] = randommid();
      ca.xyC[i][i] = complex_from_d(randommid());
   }
   testevdunit_rmatrixsymmetricsplit(&ra, n, &ral, &rau);
   testevdunit_cmatrixhermitiansplit(&ca, n, &cal, &cau);
   *SOkP = *SOkP && testevdunit_testsevdproblem(&ra, &ral, &rau, n, threshold, failc, runs);
   *HOkP = *HOkP && testevdunit_testhevdproblem(&ca, &cal, &cau, n, threshold, failc, runs);
// Random diagonally dominant matrix with distinct eigenvalues
   for (i = 0; i < n; i++) {
      for (j = i + 1; j < n; j++) {
         ra.xyR[i][j] = 0.1 * randommid() / n;
         ca.xyC[i][j] = complex_from_d(0.1 * randommid() / n, 0.1 * randommid() / n);
         ra.xyR[j][i] = ra.xyR[i][j];
         ca.xyC[j][i] = conj(ca.xyC[i][j]);
      }
      ra.xyR[i][i] = 0.1 * randommid() + i;
      ca.xyC[i][i] = complex_from_d(0.1 * randommid() + i);
   }
   testevdunit_rmatrixsymmetricsplit(&ra, n, &ral, &rau);
   testevdunit_cmatrixhermitiansplit(&ca, n, &cal, &cau);
   *SOkP = *SOkP && testevdunit_testsevdproblem(&ra, &ral, &rau, n, threshold, failc, runs);
   *HOkP = *HOkP && testevdunit_testhevdproblem(&ca, &cal, &cau, n, threshold, failc, runs);
   *SbiOkP = *SbiOkP && testevdunit_testsevdbiproblem(&ra, &ral, &rau, n, true, bithreshold, failc, runs);
   *HbiOkP = *HbiOkP && testevdunit_testhevdbiproblem(&ca, &cal, &cau, n, true, bithreshold, failc, runs);
// Sparse matrices
   testevdunit_rmatrixfillsparsea(&ra, n, n, 0.995, 0.0);
   testevdunit_cmatrixfillsparsea(&ca, n, n, 0.995, 0.0);
   for (i = 0; i < n; i++) {
      for (j = i + 1; j < n; j++) {
         ra.xyR[j][i] = ra.xyR[i][j];
         ca.xyC[j][i] = conj(ca.xyC[i][j]);
      }
      ca.xyC[i][i].y = 0.0;
   }
   testevdunit_rmatrixsymmetricsplit(&ra, n, &ral, &rau);
   testevdunit_cmatrixhermitiansplit(&ca, n, &cal, &cau);
   *SOkP = *SOkP && testevdunit_testsevdproblem(&ra, &ral, &rau, n, threshold, failc, runs);
   *HOkP = *HOkP && testevdunit_testhevdproblem(&ca, &cal, &cau, n, threshold, failc, runs);
   *SbiOkP = *SbiOkP && testevdunit_testsevdbiproblem(&ra, &ral, &rau, n, false, bithreshold, failc, runs);
   *HbiOkP = *HbiOkP && testevdunit_testhevdbiproblem(&ca, &cal, &cau, n, false, bithreshold, failc, runs);
// testing tridiagonal problems
   for (mkind = 0; mkind <= 7; mkind++) {
      ae_vector_set_length(&d, n);
      if (n > 1) {
         ae_vector_set_length(&e, n - 1);
      }
      if (mkind == 0) {
      // Zero matrix
         for (i = 0; i < n; i++) {
            d.xR[i] = 0.0;
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = 0.0;
         }
      }
      if (mkind == 1) {
      // Diagonal matrix
         for (i = 0; i < n; i++) {
            d.xR[i] = randommid();
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = 0.0;
         }
      }
      if (mkind == 2) {
      // Off-diagonal matrix
         for (i = 0; i < n; i++) {
            d.xR[i] = 0.0;
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = randommid();
         }
      }
      if (mkind == 3) {
      // Dense matrix with blocks
         for (i = 0; i < n; i++) {
            d.xR[i] = randommid();
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = randommid();
         }
         j = 1;
         i = 2;
         while (j < n - 1) {
            e.xR[j] = 0.0;
            j += i;
            i++;
         }
      }
      if (mkind == 4) {
      // dense matrix
         for (i = 0; i < n; i++) {
            d.xR[i] = randommid();
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = randommid();
         }
      }
      if (mkind == 5) {
      // Diagonal matrix with distinct eigenvalues
         for (i = 0; i < n; i++) {
            d.xR[i] = 0.1 * randommid() + i;
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = 0.0;
         }
      }
      if (mkind == 6) {
      // Off-diagonal matrix with distinct eigenvalues
         for (i = 0; i < n; i++) {
            d.xR[i] = 0.0;
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = 0.1 * randommid() + i + 1;
         }
      }
      if (mkind == 7) {
      // dense matrix with distinct eigenvalues
         for (i = 0; i < n; i++) {
            d.xR[i] = 0.1 * randommid() + i + 1;
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = 0.1 * randommid();
         }
      }
      *TdOkP = *TdOkP && testevdunit_testtdevdproblem(&d, &e, n, threshold);
      *TdbiOkP = *TdbiOkP && testevdunit_testtdevdbiproblem(&d, &e, n, mkind == 5 || mkind == 6 || mkind == 7, bithreshold, failc, runs);
   }
// Test non-symmetric problems
// Test non-symmetric problems: zero, random, sparse matrices.
   ae_matrix_set_length(&ra, n, n);
   ae_matrix_set_length(&ca, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         ra.xyR[i][j] = 0.0;
         ca.xyC[i][j] = complex_from_i(0);
      }
   }
   *NsOkP = *NsOkP && testevdunit_testnsevdproblem(&ra, n, threshold);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         ra.xyR[i][j] = randommid();
         ca.xyC[i][j] = complex_from_d(randommid(), randommid());
      }
   }
   *NsOkP = *NsOkP && testevdunit_testnsevdproblem(&ra, n, threshold);
   ae_frame_leave();
}

// Testing symmetric mode of subspace iteration solver.
static bool testevdunit_testsisymm() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t smode;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double sgn;
   double decaya;
   bool isupper;
   ae_int_t sformat;
   double v;
   double mx;
   double tollambda;
   double tolvector;
   ae_int_t itscount;
   ae_int_t callcount;
   ae_int_t requestsize;
   ae_int_t requesttype;
   ae_int_t pass;
   ae_int_t cnta;
   ae_int_t cntb;
   ae_int_t cntc;
   double nu;
   double eps;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewVector(diaga, 0, DT_REAL);
   NewMatrix(qa, 0, 0, DT_REAL);
   NewMatrix(densea, 0, 0, DT_REAL);
   NewMatrix(halfa, 0, 0, DT_REAL);
   NewMatrix(ra, 0, 0, DT_REAL);
   NewMatrix(rb, 0, 0, DT_REAL);
   NewMatrix(tmp2, 0, 0, DT_REAL);
   NewObj(sparsematrix, halfsa);
   NewObj(eigsubspacestate, s);
   NewObj(eigsubspacereport, rep);
   NewVector(sw, 0, DT_REAL);
   NewMatrix(sz, 0, 0, DT_REAL);
   NewVector(u, 0, DT_REAL);
   hqrndrandomize(&rs);
// Problem with weakly separated eigenvalues (but not too weak),
// either with alternating sign - or all positive. EPS-based
// stopping condition is used because we can not tell how many
// iterations is required to solve it.
   tollambda = 1.0E-9;
   tolvector = 1.0E-4;
   for (n = 1; n <= 25; n++) {
      for (m = 1; m <= n; m++) {
         for (smode = 0; smode <= 2; smode++) {
         // Generate eigenproblem
            sgn = (double)(2 * hqrnduniformi(&rs, 2) - 1);
            decaya = 1.05;
            ae_vector_set_length(&diaga, n);
            diaga.xR[0] = pow(10.0, hqrndmiduniformr(&rs));
            for (i = 1; i < n; i++) {
               diaga.xR[i] = diaga.xR[i - 1] * sgn / (decaya * (1.0 + 0.01 * hqrnduniformr(&rs)));
            }
            rmatrixrndorthogonal(n, &qa);
            ae_matrix_set_length(&densea, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = 0.0;
                  for (k = 0; k < n; k++) {
                     v += qa.xyR[k][i] * diaga.xR[k] * qa.xyR[k][j];
                  }
                  densea.xyR[i][j] = v;
               }
            }
            isupper = hqrnduniformr(&rs) > 0.5;
            ae_matrix_set_length(&halfa, n, n);
            sparsecreate(n, n, 0, &halfsa);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  halfa.xyR[i][j] = hqrnduniformr(&rs);
                  if (j >= i && isupper) {
                     halfa.xyR[i][j] = densea.xyR[i][j];
                     sparseset(&halfsa, i, j, densea.xyR[i][j]);
                  }
                  if (j <= i && !isupper) {
                     halfa.xyR[i][j] = densea.xyR[i][j];
                     sparseset(&halfsa, i, j, densea.xyR[i][j]);
                  }
               }
            }
            sformat = hqrnduniformi(&rs, 2);
            if (sformat == 0) {
               sparseconverttocrs(&halfsa);
            }
            if (sformat == 1) {
               sparseconverttosks(&halfsa);
            }
         // Solve with eigensolver operating in dense mode
            eigsubspacecreate(n, m, &s);
            eigsubspacesetcond(&s, tollambda / 100, 0);
            if (smode == 0) {
            // Dense mode
               eigsubspacesolvedenses(&s, &halfa, isupper, &sw, &sz, &rep);
            } else {
               if (smode == 1) {
               // Sparse mode
                  eigsubspacesolvesparses(&s, &halfsa, isupper, &sw, &sz, &rep);
               } else {
                  if (smode == 2) {
                  // Out-of-core mode, symmetric version
                     for (eigsubspaceoocstart(&s, 0); eigsubspaceooccontinue(&s); ) {
                        eigsubspaceoocgetrequestinfo(&s, &requesttype, &requestsize);
                        ae_assert(requesttype == 0, "EVDI: integrity check failed in unit test");
                        ae_assert(requestsize > 0, "EVDI: integrity check failed in unit test");
                        eigsubspaceoocgetrequestdata(&s, &ra);
                        matrixsetlengthatleast(&rb, n, requestsize);
                        rmatrixgemm(n, requestsize, n, 1.0, &densea, 0, 0, 0, &ra, 0, 0, 0, 0.0, &rb, 0, 0);
                        eigsubspaceoocsendresult(&s, &rb);
                     }
                     eigsubspaceoocstop(&s, &sw, &sz, &rep);
                  } else {
                     ae_assert(false, "unittest: integrity check failed");
                  }
               }
            }
         // Compare against reference values
            for (i = 0; i < m; i++) {
               Ok = Ok && NearAtR(sw.xR[i], diaga.xR[i], tollambda);
               v = ae_v_dotproduct(qa.xyR[i], 1, &sz.xyR[0][i], sz.stride, n);
               mx = 0.0;
               for (j = 0; j < n; j++) {
                  mx = rmax2(mx, fabs(sz.xyR[j][i] * sign(v) - qa.xyR[i][j]));
               }
               Ok = Ok && mx <= tolvector;
            }
         }
      }
   }
// Problem with highly separated eigenvalues (either with alternating
// sign - or all positive). Only a few iterations is performed, we
// want to check convergence properties on such problems.
   tollambda = 1.0E-9;
   tolvector = 1.0E-4;
   itscount = 5;
   for (n = 1; n <= 25; n++) {
      for (m = 1; m <= n; m++) {
         for (smode = 0; smode <= 2; smode++) {
         // Generate eigenproblem
            sgn = (double)(2 * hqrnduniformi(&rs, 2) - 1);
            decaya = 1.05;
            ae_vector_set_length(&diaga, n);
            diaga.xR[0] = pow(10.0, hqrndmiduniformr(&rs));
            for (i = 1; i < n; i++) {
               diaga.xR[i] = diaga.xR[i - 1] * sgn / (decaya * (1.0 + 0.01 * hqrnduniformr(&rs)));
            }
            for (i = m; i < n; i++) {
               diaga.xR[i] /= 100.0 + 10.0 * hqrnduniformr(&rs);
            }
            rmatrixrndorthogonal(n, &qa);
            ae_matrix_set_length(&densea, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = 0.0;
                  for (k = 0; k < n; k++) {
                     v += qa.xyR[k][i] * diaga.xR[k] * qa.xyR[k][j];
                  }
                  densea.xyR[i][j] = v;
               }
            }
            isupper = hqrnduniformr(&rs) > 0.5;
            ae_matrix_set_length(&halfa, n, n);
            sparsecreate(n, n, 0, &halfsa);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  halfa.xyR[i][j] = hqrnduniformr(&rs);
                  if (j >= i && isupper) {
                     halfa.xyR[i][j] = densea.xyR[i][j];
                     sparseset(&halfsa, i, j, densea.xyR[i][j]);
                  }
                  if (j <= i && !isupper) {
                     halfa.xyR[i][j] = densea.xyR[i][j];
                     sparseset(&halfsa, i, j, densea.xyR[i][j]);
                  }
               }
            }
            sformat = hqrnduniformi(&rs, 2);
            if (sformat == 0) {
               sparseconverttocrs(&halfsa);
            }
            if (sformat == 1) {
               sparseconverttosks(&halfsa);
            }
         // Solve with eigensolver operating in dense mode
            eigsubspacecreate(n, m, &s);
            eigsubspacesetcond(&s, 0.0, itscount);
            if (smode == 0) {
            // Dense mode
               eigsubspacesolvedenses(&s, &halfa, isupper, &sw, &sz, &rep);
            } else {
               if (smode == 1) {
               // Sparse mode
                  eigsubspacesolvesparses(&s, &halfsa, isupper, &sw, &sz, &rep);
               } else {
                  if (smode == 2) {
                  // Out-of-core mode, symmetric version
                  //
                  // NOTE: we check that solver performs no more than ItsCount+2 calls
                     callcount = 0;
                     for (eigsubspaceoocstart(&s, 0); eigsubspaceooccontinue(&s); ) {
                        eigsubspaceoocgetrequestinfo(&s, &requesttype, &requestsize);
                        ae_assert(requesttype == 0, "EVDI: integrity check failed in unit test");
                        ae_assert(requestsize > 0, "EVDI: integrity check failed in unit test");
                        eigsubspaceoocgetrequestdata(&s, &ra);
                        matrixsetlengthatleast(&rb, n, requestsize);
                        rmatrixgemm(n, requestsize, n, 1.0, &densea, 0, 0, 0, &ra, 0, 0, 0, 0.0, &rb, 0, 0);
                        eigsubspaceoocsendresult(&s, &rb);
                        callcount++;
                     }
                     eigsubspaceoocstop(&s, &sw, &sz, &rep);
                     Ok = Ok && callcount <= itscount + 2;
                  } else {
                     ae_assert(false, "unittest: integrity check failed");
                  }
               }
            }
         // Compare against reference values
            Ok = Ok && rep.iterationscount <= itscount;
            for (i = 0; i < m; i++) {
               Ok = Ok && NearAtR(sw.xR[i], diaga.xR[i], tollambda);
               v = ae_v_dotproduct(qa.xyR[i], 1, &sz.xyR[0][i], sz.stride, n);
               mx = 0.0;
               for (j = 0; j < n; j++) {
                  mx = rmax2(mx, fabs(sz.xyR[j][i] * sign(v) - qa.xyR[i][j]));
               }
               Ok = Ok && mx <= tolvector;
            }
         }
      }
   }
// Problem with numerically zero matrix. We check ability to stop
// and to return orthogonal vectors.
   tollambda = 1.0E-9;
   itscount = 5;
   for (n = 1; n <= 25; n++) {
      for (m = 1; m <= n; m++) {
      // Generate eigenproblem
         ae_matrix_set_length(&densea, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               densea.xyR[i][j] = 0.0;
            }
         }
      // Solve with eigensolver operating in dense mode,
      // iteration count based stopping condition.
         eigsubspacecreate(n, m, &s);
         eigsubspacesetcond(&s, 0.0, itscount);
         eigsubspacesolvedenses(&s, &densea, true, &sw, &sz, &rep);
         Ok = Ok && rep.iterationscount <= itscount;
         for (i = 0; i < m; i++) {
            for (j = i; j < m; j++) {
               v = ae_v_dotproduct(&sz.xyR[0][i], sz.stride, &sz.xyR[0][j], sz.stride, n);
               if (j == i) {
                  v--;
               }
               Ok = Ok && SmallAtR(v, 1.0E3 * machineepsilon);
            }
            Ok = Ok && sw.xR[i] == 0.0;
         }
      // Solve with eigensolver operating in dense mode,
      // eps-based stopping condition.
         eigsubspacecreate(n, m, &s);
         eigsubspacesetcond(&s, tollambda, 0);
         eigsubspacesolvedenses(&s, &densea, true, &sw, &sz, &rep);
         for (i = 0; i < m; i++) {
            for (j = i; j < m; j++) {
               v = ae_v_dotproduct(&sz.xyR[0][i], sz.stride, &sz.xyR[0][j], sz.stride, n);
               if (j == i) {
                  v--;
               }
               Ok = Ok && SmallAtR(v, 1.0E3 * machineepsilon);
            }
            Ok = Ok && sw.xR[i] == 0.0;
         }
      }
   }
// Test warm start functionality:
// * for many randomly generated problems...
// * ...solve original problem with EPS-based criterion
// * ...then apply small rank-1 correction to the matrix
// * ...and solve again, with warm start
// * ...and solve again, with explicit cold start
// * do so many times and calculate total iteration counts
//
// Iteration counts for warm starts should be significantly lower,
// whilst solution found should be within tolerances.
   cnta = 0;
   cntb = 0;
   cntc = 0;
   eps = 1.0E-3;
   nu = 0.001;
   for (pass = 1; pass <= 50; pass++) {
   // Generate eigenproblem and rank-1 update
      n = 50 + hqrnduniformi(&rs, 20);
      m = 1 + hqrnduniformi(&rs, 5);
      ae_matrix_set_length(&ra, n, n);
      ae_matrix_set_length(&tmp2, n, n);
      ae_vector_set_length(&u, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            tmp2.xyR[i][j] = hqrndnormal(&rs);
         }
      }
      rmatrixgemm(n, n, n, 1.0, &tmp2, 0, 0, 0, &tmp2, 0, 0, 1, 0.0, &ra, 0, 0);
   // Solve with eigensolver operating in cold-start mode,
   // iteration count based stopping condition.
      eigsubspacecreate(n, m, &s);
      eigsubspacesetcond(&s, eps, 0);
      eigsubspacesolvedenses(&s, &ra, true, &sw, &sz, &rep);
      cnta += rep.iterationscount;
   // Solve with eigensolver operating in warm-start mode,
   // iteration count based stopping condition.
      for (i = 0; i < n; i++) {
         u.xR[i] = hqrndnormal(&rs);
      }
      rmatrixger(n, n, &ra, 0, 0, nu, &u, 0, &u, 0);
      eigsubspacesetwarmstart(&s, true);
      eigsubspacesolvedenses(&s, &ra, true, &sw, &sz, &rep);
      cntb += rep.iterationscount;
   // Solve with eigensolver operating in explicit cold-start mode,
   // iteration count based stopping condition.
      for (i = 0; i < n; i++) {
         u.xR[i] = hqrndnormal(&rs);
      }
      rmatrixger(n, n, &ra, 0, 0, nu, &u, 0, &u, 0);
      eigsubspacesetwarmstart(&s, false);
      eigsubspacesolvedenses(&s, &ra, true, &sw, &sz, &rep);
      cntc += rep.iterationscount;
   }
   Ok = Ok && cntb <= 0.66 * cnta;
   Ok = Ok && cntc >= 0.66 * cnta;
   ae_frame_leave();
   return Ok;
}

// Testing symmetric EVD subroutine
bool testevd() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t j;
   ae_int_t failc;
   ae_int_t runs;
   double failthreshold;
   double threshold;
   double bithreshold;
   bool Ok;
   bool nsOk;
   bool sOk;
   bool hOk;
   bool tdOk;
   bool sbiOk;
   bool hbiOk;
   bool tdbiOk;
   bool sisymmOk;
   bool wOk;
   ae_frame_make(&_frame_block);
   NewMatrix(ra, 0, 0, DT_REAL);
   failthreshold = 0.005;
   threshold = 1.0E-8;
   bithreshold = 1.0E-6;
   nsOk = true;
   sOk = true;
   hOk = true;
   tdOk = true;
   sbiOk = true;
   hbiOk = true;
   tdbiOk = true;
   sisymmOk = true;
   failc = 0;
   runs = 0;
// Test subspace iteration solver
   sisymmOk = sisymmOk && testevdunit_testsisymm();
// Test dense solvers
   for (n = 1; n <= ablasblocksize(&ra); n++) {
      testevdunit_testevdset(n, threshold, bithreshold, &failc, &runs, &nsOk, &sOk, &hOk, &tdOk, &sbiOk, &hbiOk, &tdbiOk);
   }
   for (j = 2; j <= 3; j++) {
      for (n = j * ablasblocksize(&ra) - 1; n <= j * ablasblocksize(&ra) + 1; n++) {
         testevdunit_testevdset(n, threshold, bithreshold, &failc, &runs, &nsOk, &sOk, &hOk, &tdOk, &sbiOk, &hbiOk, &tdbiOk);
      }
   }
   wOk = (double)failc / runs <= failthreshold;
// The final report.
   Ok = nsOk && sOk && hOk && tdOk && sbiOk && hbiOk && tdbiOk && wOk && sisymmOk;
   if (!Ok || !silent) {
      printf("EVD Unit Tests\n");
      printf("Dense Direct Solvers:\n");
      printf("* NS:                                     %s\n", nsOk? "Ok": "Failed");
      printf("* S:                                      %s\n", sOk? "Ok": "Failed");
      printf("* H:                                      %s\n", hOk? "Ok": "Failed");
      printf("* TD:                                     %s\n", tdOk? "Ok": "Failed");
      printf("* SBI:                                    %s\n", sbiOk? "Ok": "Failed");
      printf("* HBI:                                    %s\n", hbiOk? "Ok": "Failed");
      printf("* TDBI:                                   %s\n", tdbiOk? "Ok": "Failed");
      printf("* Failure Threshold:                      %s\n", wOk? "Ok": "Failed");
      printf("Iterative Solvers:\n");
      printf("* Subspace Iteration (S):                 %s\n", sisymmOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === trfac testing unit ===
// Test sparse real Cholesky.
// ALGLIB Project: Copyright 16.01.2014 by Sergey Bochkanov
static bool sparserealcholeskytest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nz;
   double pnz;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_int_t t0;
   ae_int_t t1;
   bool isupper;
   double offscale;
   double tol;
   ae_int_t maxfmt;
   ae_int_t minperm;
   ae_int_t maxperm;
   ae_int_t routinetype;
   ae_int_t permtype;
   ae_int_t facttype;
   ae_int_t updatewidth;
   ae_int_t updaterank;
   ae_int_t targetwidth;
   ae_int_t bigsize;
   ae_int_t bottomsize;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewObj(sparsematrix, sa1);
   NewObj(sparsematrix, sc);
   NewObj(sparsematrix, sp);
   NewObj(sparsebuffers, sbuf);
   NewVector(p0, 0, DT_INT);
   NewVector(p1, 0, DT_INT);
   NewVector(d, 0, DT_REAL);
   NewVector(b1, 0, DT_BOOL);
   NewObj(hqrndstate, rs);
   NewObj(sparsedecompositionanalysis, analysis);
   Ok = true;
   hqrndrandomize(&rs);
// Settings
   maxfmt = 2;
   minperm = -2;
   maxperm = 2;
   offscale = 1.0E-3;
   tol = 1.0E-8;
// Modern Cholesky (SparseCholesky, SparseCholeskyP, Analyze/Factorize) tests:
// performed for positive definite matrices of all sizes in 1..20 and all sparsity percentages.
   for (n = 1; n <= 30; n++) {
      nz = n * n - n;
      while (true) {
      // Generate symmetric N*N matrix where probability of non-diagonal element
      // being non-zero is PNZ. Off-diagonal elements are set to very
      // small values, so positive definiteness is guaranteed.
         if (n > 1) {
            pnz = (double)nz / (n * n - n);
         } else {
            pnz = 1.0;
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j <= i; j++) {
               if (i == j) {
                  a.xyR[i][i] = 1.0 + hqrnduniformr(&rs);
                  continue;
               }
               if (hqrnduniformr(&rs) <= pnz) {
                  a.xyR[i][j] = 0.25 / n * hqrndmiduniformr(&rs);
                  a.xyR[j][i] = a.xyR[i][j];
               } else {
                  a.xyR[i][j] = 0.0;
                  a.xyR[j][i] = 0.0;
               }
            }
         }
      // Create matrix in hash-based storage format, convert it to random storage format.
         isupper = randombool();
         sparsecreate(n, n, 0, &sa);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j >= i: j <= i) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               }
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j < i: j > i) {
                  if (hqrnduniformr(&rs) <= pnz) {
                     sparseset(&sa, i, j, hqrndnormal(&rs));
                  }
               }
            }
         }
         sparseconvertto(&sa, hqrnduniformi(&rs, maxfmt + 1));
      // Try various factorization routines:
      // * SparseCholesky() without permutation
      // * SparseCholeskyP()
      // * Analyze/Factorize family of functions
         for (routinetype = 0; routinetype <= 2; routinetype++) {
         // The factorization
            sparsecopy(&sa, &sc);
            if (routinetype == 0) {
            // Positive-definite Cholesky without permutation
               if (!sparsecholesky(&sc, isupper)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
               ae_vector_set_length(&p0, n);
               ae_vector_set_length(&d, n);
               for (i = 0; i < n; i++) {
                  p0.xZ[i] = i;
                  d.xR[i] = 1.0;
               }
            }
            if (routinetype == 1) {
            // Positive-definite Cholesky with permutation
               if (!sparsecholeskyp(&sc, isupper, &p0)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
               ae_vector_set_length(&d, n);
               for (i = 0; i < n; i++) {
                  d.xR[i] = 1.0;
               }
            }
            if (routinetype == 2) {
            // Positive-definite analyze/factorize with randomly chosen permutation.
            // We also check that we may analyze one matrix and factorize another one
            // with same sparsity pattern.
               sparsecopybuf(&sc, &sp);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     if (sparseexists(&sp, i, j)) {
                        sparserewriteexisting(&sp, i, j, 1.0);
                     }
                  }
               }
               permtype = minperm + hqrnduniformi(&rs, maxperm - minperm + 1);
               if (hqrndnormal(&rs) > 0.0) {
               // Test analyze/factorize sequence
                  if (!sparsecholeskyanalyze(&sc, isupper, 0, permtype, &analysis)) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
                  sparsecreate(1, 1, 0, &sc);
                  if (!sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
               } else {
               // Test analyze/reload/factorize sequence
                  if (!sparsecholeskyanalyze(&sp, isupper, 0, permtype, &analysis)) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
                  sparsecholeskyreload(&analysis, &sc, isupper);
                  sparsecreate(1, 1, 0, &sc);
                  if (!sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
               }
               if (d.cnt != n) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
               for (i = 0; i < n; i++) {
                  Ok = Ok && d.xR[i] == 1.0;
               }
            }
         // Check output sizes and formats
            Ok = Ok && sparseiscrs(&sc) && sparsegetnrows(&sc) == n && sparsegetncols(&sc) == n;
            Ok = Ok && p0.cnt == n;
            Ok = Ok && d.cnt == n;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               Ok = Ok && p0.xZ[i] >= i && p0.xZ[i] < n;
               Ok = Ok && isfinite(d.xR[i]);
            }
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            t0 = 0;
            t1 = 0;
            while (sparseenumerate(&sc, &t0, &t1, &i, &j, &v)) {
               Ok = Ok && (isupper? j >= i: j <= i);
            }
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Now, test correctness of Cholesky decomposition itself.
         // We calculate U'*U (or L*L') and check it against permutation
         // of A given by P0.
         //
         // NOTE: we expect that only one triangle of SC is filled,
         //       and another one is exactly zero.
            ae_matrix_set_length(&a1, n, n);
            if (isupper) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     v = 0.0;
                     for (k = 0; k < n; k++) {
                        v += sparseget(&sc, k, j) * d.xR[k] * sparseget(&sc, k, i);
                     }
                     a1.xyR[i][j] = v;
                  }
               }
            } else {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     v = 0.0;
                     for (k = 0; k < n; k++) {
                        v += sparseget(&sc, j, k) * d.xR[k] * sparseget(&sc, i, k);
                     }
                     a1.xyR[i][j] = v;
                  }
               }
            }
            for (i = n - 1; i >= 0; i--) {
               swaprows(&a1, i, p0.xZ[i], n);
               swapcols(&a1, i, p0.xZ[i], n);
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  Ok = Ok && NearAtR(a.xyR[i][j], a1.xyR[i][j], tol);
               }
            }
         }
      // Check handling of degenerate problems: zeros at main diagonal, negative definite matrices
         for (routinetype = 0; routinetype <= 1; routinetype++) {
         // Exact zero at diagonal
            sparsecopy(&sa, &sc);
            sparseconverttohash(&sc);
            k = hqrnduniformi(&rs, n);
            sparseset(&sc, k, k, 0.0);
            sparseconvertto(&sc, hqrnduniformi(&rs, maxfmt + 1));
            if (routinetype == 0) {
               Ok = Ok && !sparsecholesky(&sc, isupper);
            }
            if (routinetype == 1) {
               Ok = Ok && !sparsecholeskyp(&sc, isupper, &p0);
            }
         // Negative definite matrix
            sparsecopy(&sa, &sc);
            sparseconverttohash(&sc);
            k = hqrnduniformi(&rs, n);
            sparseset(&sc, k, k, -1.0E10);
            sparseconvertto(&sc, hqrnduniformi(&rs, maxfmt + 1));
            if (routinetype == 0) {
               Ok = Ok && !sparsecholesky(&sc, isupper);
            }
            if (routinetype == 1) {
               Ok = Ok && !sparsecholeskyp(&sc, isupper, &p0);
            }
         }
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ == 0.
         if (nz == 0) {
            break;
         }
         nz /= 2;
      }
   }
// Negative definite LDLT factorization: performed for matrices with various sparsity factors
   for (n = 1; n <= 30; n++) {
      nz = n * n - n;
      while (true) {
      // Generate symmetric N*N matrix where probability of non-diagonal element
      // being non-zero is PNZ. Off-diagonal elements are set to very
      // small values, so positive definiteness is guaranteed.
         if (n > 1) {
            pnz = (double)nz / (n * n - n);
         } else {
            pnz = 1.0;
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j <= i; j++) {
               if (i == j) {
                  a.xyR[i][i] = possign(hqrndnormal(&rs)) * (1.0 + hqrnduniformr(&rs));
                  continue;
               }
               if (hqrnduniformr(&rs) <= pnz) {
                  a.xyR[i][j] = 0.25 / n * hqrndmiduniformr(&rs);
                  a.xyR[j][i] = a.xyR[i][j];
               } else {
                  a.xyR[i][j] = 0.0;
                  a.xyR[j][i] = 0.0;
               }
            }
         }
      // Create matrix in hash-based storage format, convert it to random storage format.
         isupper = randombool();
         sparsecreate(n, n, 0, &sa);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j >= i: j <= i) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               }
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j < i: j > i) {
                  if (hqrnduniformr(&rs) <= pnz) {
                     sparseset(&sa, i, j, hqrndnormal(&rs));
                  }
               }
            }
         }
         sparseconvertto(&sa, hqrnduniformi(&rs, maxfmt + 1));
      // Try Analyze/Factorize family of functions
         sparsecopy(&sa, &sc);
         sparsecopybuf(&sc, &sp);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (sparseexists(&sp, i, j)) {
                  sparserewriteexisting(&sp, i, j, 1.0);
               }
            }
         }
         facttype = 1;
         permtype = minperm + hqrnduniformi(&rs, maxperm - minperm + 1);
         if (hqrndnormal(&rs) > 0.0) {
         // Test analyze/factorize sequence
            if (!sparsecholeskyanalyze(&sc, isupper, facttype, permtype, &analysis)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            sparsecreate(1, 1, 0, &sc);
            if (!sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         } else {
         // Test analyze/reload/factorize sequence
            if (!sparsecholeskyanalyze(&sp, isupper, facttype, permtype, &analysis)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            sparsecholeskyreload(&analysis, &sc, isupper);
            sparsecreate(1, 1, 0, &sc);
            if (!sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      // Check output sizes and formats
         Ok = Ok && sparseiscrs(&sc) && sparsegetnrows(&sc) == n && sparsegetncols(&sc) == n;
         Ok = Ok && p0.cnt == n;
         Ok = Ok && d.cnt == n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && p0.xZ[i] >= i && p0.xZ[i] < n;
            Ok = Ok && isfinite(d.xR[i]);
         }
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         t0 = 0;
         t1 = 0;
         while (sparseenumerate(&sc, &t0, &t1, &i, &j, &v)) {
            Ok = Ok && (isupper? j >= i: j <= i);
         }
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Now, test correctness of Cholesky decomposition itself.
      // We calculate U'*U (or L*L') and check it against permutation
      // of A given by P0.
      //
      // NOTE: we expect that only one triangle of SC is filled,
      //       and another one is exactly zero.
         ae_matrix_set_length(&a1, n, n);
         if (isupper) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = 0.0;
                  for (k = 0; k < n; k++) {
                     v += sparseget(&sc, k, j) * d.xR[k] * sparseget(&sc, k, i);
                  }
                  a1.xyR[i][j] = v;
               }
            }
         } else {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = 0.0;
                  for (k = 0; k < n; k++) {
                     v += sparseget(&sc, j, k) * d.xR[k] * sparseget(&sc, i, k);
                  }
                  a1.xyR[i][j] = v;
               }
            }
         }
         for (i = n - 1; i >= 0; i--) {
            swaprows(&a1, i, p0.xZ[i], n);
            swapcols(&a1, i, p0.xZ[i], n);
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               Ok = Ok && NearAtR(a.xyR[i][j], a1.xyR[i][j], tol);
            }
         }
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ == 0.
         if (nz == 0) {
            break;
         }
         nz /= 2;
      }
   }
// Basis test of modified Cholesky.
//
// We do not perform deep tests here, basically the fact that with diagonal modification
// we can complete factorization that can't be completed without modification.
   for (n = 1; n <= 30; n++) {
      nz = n * n - n;
      while (true) {
      // Generate symmetric N*N matrix where probability of non-diagonal element
      // being non-zero is PNZ. One of diagonal elements is guaranteed to be
      // negative in order to test modification strategy.
         if (n > 1) {
            pnz = (double)nz / (n * n - n);
         } else {
            pnz = 1.0;
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j <= i; j++) {
               if (i == j) {
                  a.xyR[i][i] = hqrndnormal(&rs);
                  continue;
               }
               if (hqrnduniformr(&rs) <= pnz) {
                  a.xyR[i][j] = 0.25 / n * hqrndmiduniformr(&rs);
                  a.xyR[j][i] = a.xyR[i][j];
               } else {
                  a.xyR[i][j] = 0.0;
                  a.xyR[j][i] = 0.0;
               }
            }
         }
         i = hqrnduniformi(&rs, n);
         a.xyR[i][i] = -1.0;
         sparsecreate(n, n, 0, &sa);
         isupper = randombool(); //(@) Was not present in the original: isupper was left dangling from the previous set of loops.
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j >= i: j <= i) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               }
            }
         }
      // Try Analyze/Factorize family of functions
         facttype = 0;
         permtype = minperm + hqrnduniformi(&rs, maxperm - minperm + 1);
         sparsecopy(&sa, &sc);
         if (!sparsecholeskyanalyze(&sc, isupper, facttype, permtype, &analysis)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         if (sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         sparsecopy(&sa, &sc);
         sparsecholeskysetmodtype(&analysis, 1, 1.0, 0.0, 0.0, 0.0);
         sparsecholeskyreload(&analysis, &sc, isupper);
         if (!sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ = 0.
         if (nz == 0) {
            break;
         }
         nz /= 2;
      }
   }
// Basis test of modified Cholesky.
//
// We do not perform deep tests here, basically the fact that with diagonal modification
// we can complete factorization that can't be completed without modification.
   for (n = 1; n <= 30; n++) {
      nz = n * n - n;
      while (true) {
      // Generate symmetric N*N matrix where probability of non-diagonal element
      // being non-zero is PNZ. One of diagonal elements is guaranteed to be
      // negative in order to test modification strategy.
         if (n > 1) {
            pnz = (double)nz / (n * n - n);
         } else {
            pnz = 1.0;
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j <= i; j++) {
               if (i == j) {
                  a.xyR[i][i] = hqrndnormal(&rs);
                  continue;
               }
               if (hqrnduniformr(&rs) <= pnz) {
                  a.xyR[i][j] = 0.25 / n * hqrndmiduniformr(&rs);
                  a.xyR[j][i] = a.xyR[i][j];
               } else {
                  a.xyR[i][j] = 0.0;
                  a.xyR[j][i] = 0.0;
               }
            }
         }
         i = hqrnduniformi(&rs, n);
         a.xyR[i][i] = -1.0;
         sparsecreate(n, n, 0, &sa);
         isupper = randombool(); //(@) Was not present in the original: isupper was left dangling from the previous set of loops.
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j >= i: j <= i) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               }
            }
         }
      // Try Analyze/Factorize family of functions
         facttype = 0;
         permtype = minperm + hqrnduniformi(&rs, maxperm - minperm + 1);
         sparsecopy(&sa, &sc);
         if (!sparsecholeskyanalyze(&sc, isupper, facttype, permtype, &analysis)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         if (sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         sparsecopy(&sa, &sc);
         sparsecholeskysetmodtype(&analysis, 1, 1.0, 0.0, 0.0, 0.0);
         sparsecholeskyreload(&analysis, &sc, isupper);
         if (!sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ == 0.
         if (nz == 0) {
            break;
         }
         nz /= 2;
      }
   }
// Specially designed matrix that allows us to test all internal supernodal update kernels,
// with all update ranks, update widths, target widths
   updaterank = 1;
   updatewidth = 3;
   targetwidth = updatewidth;
   for (updaterank = 1; updaterank <= spsymmgetmaxfastkernel(); updaterank++) {
      for (updatewidth = 1; updatewidth <= spsymmgetmaxfastkernel(); updatewidth++) {
         for (targetwidth = updatewidth; targetwidth <= spsymmgetmaxfastkernel(); targetwidth++) {
         // Generate test matrix A:
         //
         // [ U                  ]
         // [ UU                 ]
         // [ UUU                ]
         // [ UUUT               ]
         // [ UUUTT              ]
         // [ UUUTTT             ]
         // [    TTTT            ]
         // [    TTTTR           ]
         // [    TTTTRR          ]
         // [    TTTTRRR         ]
         // [    TTTTRRRR        ]
         // [    TTTTRRRRR       ]
         // [        RRRRRR      ]
         // [        RRRRRRR     ]
         // [        RRRRRRRR    ]
         // [        RRRRRRRRR   ]
         // [ UUUTTTTRRRRRRRRRR  ]
         // [ UUUTTTTRRRRRRRRRRR ]
         //
         // where U is update matrix, T is target matrix, heights of U and T are chosen in
         // such a way that supernode T will NOT be merged with supernode U, their sizes
         // are chosen to investigate all possible kinds of update kernels. The residual
         // R is also chosen in such a way that it is NOT merged with T.
            bigsize = 10;
            bottomsize = 2 + hqrnduniformi(&rs, 10);
            n = updaterank + targetwidth + 2 * bigsize + bottomsize;
            ae_matrix_set_length(&a, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (i == j) {
                     a.xyR[i][j] = 1.0 + hqrnduniformr(&rs);
                  } else {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
            for (j = 0; j < updaterank; j++) {
               for (i = j + 1; i < updaterank + updatewidth; i++) {
                  a.xyR[i][j] = 0.25 / n * hqrndmiduniformr(&rs);
               }
               for (i = n - bottomsize; i < n; i++) {
                  a.xyR[i][j] = 0.25 / n * hqrndmiduniformr(&rs);
               }
            }
            for (j = updaterank; j < updaterank + targetwidth; j++) {
               for (i = j + 1; i < updaterank + targetwidth + bigsize; i++) {
                  a.xyR[i][j] = 0.25 / n * hqrndmiduniformr(&rs);
               }
               for (i = n - bottomsize; i < n; i++) {
                  a.xyR[i][j] = 0.25 / n * hqrndmiduniformr(&rs);
               }
            }
            for (j = updaterank + targetwidth; j < n; j++) {
               for (i = j + 1; i < n; i++) {
                  a.xyR[i][j] = 0.25 / n * hqrndmiduniformr(&rs);
               }
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < i; j++) {
                  a.xyR[j][i] = a.xyR[i][j];
               }
            }
         // Create matrix in hash-based storage format
            isupper = false;
            sparsecreate(n, n, 0, &sa);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               }
            }
         // Try analysis with random permutation and factorization
            facttype = hqrnduniformi(&rs, 2);
            permtype = minperm + hqrnduniformi(&rs, maxperm - minperm + 1);
            if (!sparsecholeskyanalyze(&sa, isupper, facttype, permtype, &analysis)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            if (!sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         // Check output sizes and formats
            Ok = Ok && sparseiscrs(&sc) && sparsegetnrows(&sc) == n && sparsegetncols(&sc) == n;
            Ok = Ok && p0.cnt == n;
            Ok = Ok && d.cnt == n;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               Ok = Ok && p0.xZ[i] >= i && p0.xZ[i] < n;
               Ok = Ok && isfinite(d.xR[i]);
            }
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            t0 = 0;
            t1 = 0;
            while (sparseenumerate(&sc, &t0, &t1, &i, &j, &v)) {
               Ok = Ok && (isupper? j >= i: j <= i);
            }
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Now, test correctness of Cholesky decomposition itself.
         // We calculate U'*U (or L*L') and check it against permutation
         // of A given by P0.
         //
         // NOTE: we expect that only one triangle of SC is filled,
         //       and another one is exactly zero.
            ae_matrix_set_length(&a1, n, n);
            if (isupper) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     v = 0.0;
                     for (k = 0; k < n; k++) {
                        v += sparseget(&sc, k, j) * d.xR[k] * sparseget(&sc, k, i);
                     }
                     a1.xyR[i][j] = v;
                  }
               }
            } else {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     v = 0.0;
                     for (k = 0; k < n; k++) {
                        v += sparseget(&sc, j, k) * d.xR[k] * sparseget(&sc, i, k);
                     }
                     a1.xyR[i][j] = v;
                  }
               }
            }
            for (i = n - 1; i >= 0; i--) {
               swaprows(&a1, i, p0.xZ[i], n);
               swapcols(&a1, i, p0.xZ[i], n);
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  Ok = Ok && NearAtR(a.xyR[i][j], a1.xyR[i][j], tol);
               }
            }
         }
      }
   }
// SparseCholeskySkyline test: performed for matrices
// of all sizes in 1..20 and all sparsity percentages.
   for (n = 1; n <= 20; n++) {
      nz = n * n - n;
      while (true) {
      // Choose IsUpper - main triangle to work with.
      //
      // Generate A - symmetric N*N matrix where probability of non-diagonal
      // element being non-zero is PNZ. Off-diagonal elements are set to
      // very small values, so positive definiteness is guaranteed. Full matrix
      // is generated.
      //
      // Additionally, we create A1 - same as A, but one of the triangles is
      // asymmetrically spoiled. If IsUpper is True, we spoil lower one, or vice versa.
         isupper = randombool();
         if (n > 1) {
            pnz = (double)nz / (n * n - n);
         } else {
            pnz = 1.0;
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j <= i; j++) {
               if (i == j) {
                  a.xyR[i][i] = 1.0 + hqrnduniformr(&rs);
                  continue;
               }
               if (hqrnduniformr(&rs) <= pnz) {
                  a.xyR[i][j] = offscale * (hqrnduniformr(&rs) - 0.5);
                  a.xyR[j][i] = a.xyR[i][j];
               } else {
                  a.xyR[i][j] = 0.0;
                  a.xyR[j][i] = 0.0;
               }
            }
         }
         ae_matrix_set_length(&a1, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j >= i: j <= i) {
               // Copy one triangle
                  a1.xyR[i][j] = a.xyR[i][j];
               } else {
               // Form another sparse pattern in different triangle.
                  if (hqrnduniformr(&rs) <= pnz) {
                     a1.xyR[i][j] = offscale * (hqrnduniformr(&rs) - 0.5);
                  } else {
                     a1.xyR[i][j] = 0.0;
                  }
               }
            }
         }
      // Create copies of A and A1 in hash-based storage format.
      // Only one triangle of A is copied, but A1 is copied fully.
      // Convert them to SKS
         sparsecreate(n, n, 0, &sa);
         sparsecreate(n, n, 0, &sa1);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j >= i: j <= i) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               }
               sparseset(&sa1, i, j, a1.xyR[i][j]);
            }
         }
         sparseconverttosks(&sa);
         sparseconverttosks(&sa1);
      // Call SparseCholeskySkyline() for SA and make several tests:
      // * check that it is still SKS
      // * check that it has correct size (exactly N*N)
      // * check that correct triangle is returned (and another one is unchanged - zero)
      // * check that it is correct Cholesky decomposition.
      //   We calculate U'*U (or L*L') and check at against A. We expect
      //   that only one triangle of SA is filled, and another one is
      //   exactly zero.
         if (!sparsecholeskyskyline(&sa, n, isupper)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         Ok = Ok && sparseissks(&sa);
         Ok = Ok && sparsegetncols(&sa) == n;
         Ok = Ok && sparsegetnrows(&sa) == n;
         t0 = 0;
         t1 = 0;
         while (sparseenumerate(&sa, &t0, &t1, &i, &j, &v)) {
            Ok = Ok && (isupper? j >= i: j <= i);
         }
         if (isupper) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = 0.0;
                  for (k = 0; k < n; k++) {
                     v += sparseget(&sa, k, j) * sparseget(&sa, k, i);
                  }
                  Ok = Ok && NearAtR(a.xyR[i][j], v, tol);
               }
            }
         } else {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = 0.0;
                  for (k = 0; k < n; k++) {
                     v += sparseget(&sa, j, k) * sparseget(&sa, i, k);
                  }
                  Ok = Ok && NearAtR(a.xyR[i][j], v, tol);
               }
            }
         }
      // Call SparseCholeskySkyline() for SA1 and make several tests:
      // * check that it is still SKS
      // * check that it has correct size (exactly N*N)
      // * check that factorized triangle matches contents of SA,
      //   and another triangle was unchanged (matches contents of A1).
         if (!sparsecholeskyskyline(&sa1, n, isupper)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         Ok = Ok && sparseissks(&sa1);
         Ok = Ok && sparsegetncols(&sa1) == n;
         Ok = Ok && sparsegetnrows(&sa1) == n;
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j >= i: j <= i) {
                  Ok = Ok && NearAtR(sparseget(&sa1, i, j), sparseget(&sa, i, j), 10.0 * machineepsilon);
               } else {
                  Ok = Ok && NearAtR(sparseget(&sa1, i, j), a1.xyR[i][j], 10.0 * machineepsilon);
               }
            }
         }
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ == 0.
         if (nz == 0) {
            break;
         }
         nz /= 2;
      }
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing sparse real LU decomposition.
// ALGLIB Project: Copyright 16.01.2014 by Sergey Bochkanov
static bool sparsereallutest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nz;
   double pnz;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   bool success;
   double tol;
   bool haszero;
   ae_int_t pivottype;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b1, 0, 0, DT_REAL);
   NewMatrix(b2, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(pivr, 0, DT_INT);
   NewVector(pivc, 0, DT_INT);
   NewObj(sparsematrix, sa);
   NewObj(sparsematrix, crsa);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   tol = 1.0E4 * machineepsilon;
// Test matrix sizes in 1...20 and with all sparsity percentages
   for (n = 1; n <= 20; n++) {
      nz = n * n;
      while (true) {
      // Generate N*N matrix where probability of element being
      // non-zero is PNZ. Create sparse matrix in hash-based storage format.
         pnz = (double)nz / (n * n);
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (hqrnduniformr(&rs) <= pnz) {
                  a.xyR[i][j] = hqrndnormal(&rs);
               } else {
                  a.xyR[i][j] = 0.0;
               }
            }
         }
         sparsecreate(n, n, 0, &sa);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               sparseset(&sa, i, j, a.xyR[i][j]);
            }
         }
      // Test SparseLU()
         for (pivottype = 0; pivottype <= 2; pivottype++) {
            sparsecopytocrs(&sa, &crsa);
            ae_vector_set_length(&pivr, 0);
            ae_vector_set_length(&pivc, 0);
            success = sparselu(&crsa, pivottype, &pivr, &pivc);
            Ok = Ok && sparseiscrs(&crsa);
            Ok = Ok && sparsegetncols(&crsa) == n;
            Ok = Ok && sparsegetnrows(&crsa) == n;
            Ok = Ok && pivr.cnt == n;
            Ok = Ok && pivc.cnt == n;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               Ok = Ok && pivr.xZ[i] >= 0 && pivr.xZ[i] < n && pivc.xZ[i] >= 0 && pivc.xZ[i] < n;
            }
            for (i = 0; i < n; i++) {
               Ok = Ok && (pivottype != 1 || pivc.xZ[i] == i);
            }
            ae_matrix_set_length(&b1, n, n);
            ae_matrix_set_length(&b2, n, n);
            haszero = false;
            for (i = 0; i < n; i++) {
               for (j = 0; j < i; j++) {
                  b1.xyR[i][j] = sparseget(&crsa, i, j);
               }
               b1.xyR[i][i] = 1.0;
               for (j = i + 1; j < n; j++) {
                  b1.xyR[i][j] = 0.0;
               }
               for (j = 0; j < i; j++) {
                  b2.xyR[i][j] = 0.0;
               }
               for (j = i; j < n; j++) {
                  b2.xyR[i][j] = sparseget(&crsa, i, j);
               }
               haszero = haszero || b2.xyR[i][i] == 0.0;
            }
            ae_matrix_set_length(&c, n, n);
            rmatrixgemm(n, n, n, 1.0, &b1, 0, 0, 0, &b2, 0, 0, 0, 0.0, &c, 0, 0);
            for (i = n - 1; i >= 0; i--) {
               j = pivr.xZ[i];
               for (k = 0; k < n; k++) {
                  swapr(&c.xyR[i][k], &c.xyR[j][k]);
               }
            }
            for (i = n - 1; i >= 0; i--) {
               j = pivc.xZ[i];
               for (k = 0; k < n; k++) {
                  swapr(&c.xyR[k][i], &c.xyR[k][j]);
               }
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  Ok = Ok && NearAtR(c.xyR[i][j], a.xyR[i][j], tol);
               }
            }
            Ok = Ok && success != haszero;
         }
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ == 0.
         if (nz == 0) {
            break;
         }
         nz /= 2;
      }
   }
   ae_frame_leave();
   return Ok;
}

static bool testtrfacunit_testrluproblem(RMatrix *a, ae_int_t m, ae_int_t n, double threshold, bool *PropOkP) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t minmn;
   double v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(ca, 0, 0, DT_REAL);
   NewMatrix(cl, 0, 0, DT_REAL);
   NewMatrix(cu, 0, 0, DT_REAL);
   NewMatrix(ca2, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_REAL);
   NewVector(p, 0, DT_INT);
   minmn = imin2(m, n);
// PLU test
   ae_matrix_set_length(&ca, m, n);
   for (i = 0; i < m; i++) {
      ae_v_move(ca.xyR[i], 1, a->xyR[i], 1, n);
   }
   rmatrixplu(&ca, m, n, &p);
   for (i = 0; i < minmn; i++) {
      if (p.xZ[i] < i || p.xZ[i] >= m) {
         *PropOkP = false;
         ae_frame_leave();
         return Ok;
      }
   }
   ae_matrix_set_length(&cl, m, minmn);
   for (j = 0; j < minmn; j++) {
      for (i = 0; i < j; i++) {
         cl.xyR[i][j] = 0.0;
      }
      cl.xyR[j][j] = 1.0;
      for (i = j + 1; i < m; i++) {
         cl.xyR[i][j] = ca.xyR[i][j];
      }
   }
   ae_matrix_set_length(&cu, minmn, n);
   for (i = 0; i < minmn; i++) {
      for (j = 0; j < i; j++) {
         cu.xyR[i][j] = 0.0;
      }
      for (j = i; j < n; j++) {
         cu.xyR[i][j] = ca.xyR[i][j];
      }
   }
   ae_matrix_set_length(&ca2, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(cl.xyR[i], 1, &cu.xyR[0][j], cu.stride, minmn);
         ca2.xyR[i][j] = v;
      }
   }
   ae_vector_set_length(&ct, n);
   for (i = minmn - 1; i >= 0; i--) {
      if (i != p.xZ[i]) {
         ae_v_move(ct.xR, 1, ca2.xyR[i], 1, n);
         ae_v_move(ca2.xyR[i], 1, ca2.xyR[p.xZ[i]], 1, n);
         ae_v_move(ca2.xyR[p.xZ[i]], 1, ct.xR, 1, n);
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         Ok = Ok && NearAtR(a->xyR[i][j], ca2.xyR[i][j], threshold);
      }
   }
// LUP test
   ae_matrix_set_length(&ca, m, n);
   for (i = 0; i < m; i++) {
      ae_v_move(ca.xyR[i], 1, a->xyR[i], 1, n);
   }
   rmatrixlup(&ca, m, n, &p);
   for (i = 0; i < minmn; i++) {
      if (p.xZ[i] < i || p.xZ[i] >= n) {
         *PropOkP = false;
         ae_frame_leave();
         return Ok;
      }
   }
   ae_matrix_set_length(&cl, m, minmn);
   for (j = 0; j < minmn; j++) {
      for (i = 0; i < j; i++) {
         cl.xyR[i][j] = 0.0;
      }
      for (i = j; i < m; i++) {
         cl.xyR[i][j] = ca.xyR[i][j];
      }
   }
   ae_matrix_set_length(&cu, minmn, n);
   for (i = 0; i < minmn; i++) {
      for (j = 0; j < i; j++) {
         cu.xyR[i][j] = 0.0;
      }
      cu.xyR[i][i] = 1.0;
      for (j = i + 1; j < n; j++) {
         cu.xyR[i][j] = ca.xyR[i][j];
      }
   }
   ae_matrix_set_length(&ca2, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(cl.xyR[i], 1, &cu.xyR[0][j], cu.stride, minmn);
         ca2.xyR[i][j] = v;
      }
   }
   ae_vector_set_length(&ct, m);
   for (i = minmn - 1; i >= 0; i--) {
      if (i != p.xZ[i]) {
         ae_v_move(ct.xR, 1, &ca2.xyR[0][i], ca2.stride, m);
         ae_v_move(&ca2.xyR[0][i], ca2.stride, &ca2.xyR[0][p.xZ[i]], ca2.stride, m);
         ae_v_move(&ca2.xyR[0][p.xZ[i]], ca2.stride, ct.xR, 1, m);
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         Ok = Ok && NearAtR(a->xyR[i][j], ca2.xyR[i][j], threshold);
      }
   }
   ae_frame_leave();
   return Ok;
}

static bool testtrfacunit_testcluproblem(CMatrix *a, ae_int_t m, ae_int_t n, double threshold, bool *PropOkP) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t minmn;
   complex v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewMatrix(cl, 0, 0, DT_COMPLEX);
   NewMatrix(cu, 0, 0, DT_COMPLEX);
   NewMatrix(ca2, 0, 0, DT_COMPLEX);
   NewVector(ct, 0, DT_COMPLEX);
   NewVector(p, 0, DT_INT);
   minmn = imin2(m, n);
// PLU test
   ae_matrix_set_length(&ca, m, n);
   for (i = 0; i < m; i++) {
      ae_v_cmove(ca.xyC[i], 1, a->xyC[i], 1, "N", n);
   }
   cmatrixplu(&ca, m, n, &p);
   for (i = 0; i < minmn; i++) {
      if (p.xZ[i] < i || p.xZ[i] >= m) {
         *PropOkP = false;
         ae_frame_leave();
         return Ok;
      }
   }
   ae_matrix_set_length(&cl, m, minmn);
   for (j = 0; j < minmn; j++) {
      for (i = 0; i < j; i++) {
         cl.xyC[i][j] = complex_from_d(0.0);
      }
      cl.xyC[j][j] = complex_from_d(1.0);
      for (i = j + 1; i < m; i++) {
         cl.xyC[i][j] = ca.xyC[i][j];
      }
   }
   ae_matrix_set_length(&cu, minmn, n);
   for (i = 0; i < minmn; i++) {
      for (j = 0; j < i; j++) {
         cu.xyC[i][j] = complex_from_d(0.0);
      }
      for (j = i; j < n; j++) {
         cu.xyC[i][j] = ca.xyC[i][j];
      }
   }
   ae_matrix_set_length(&ca2, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(cl.xyC[i], 1, "N", &cu.xyC[0][j], cu.stride, "N", minmn);
         ca2.xyC[i][j] = v;
      }
   }
   ae_vector_set_length(&ct, n);
   for (i = minmn - 1; i >= 0; i--) {
      if (i != p.xZ[i]) {
         ae_v_cmove(ct.xC, 1, ca2.xyC[i], 1, "N", n);
         ae_v_cmove(ca2.xyC[i], 1, ca2.xyC[p.xZ[i]], 1, "N", n);
         ae_v_cmove(ca2.xyC[p.xZ[i]], 1, ct.xC, 1, "N", n);
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         Ok = Ok && NearAtC(a->xyC[i][j], ca2.xyC[i][j], threshold);
      }
   }
// LUP test
   ae_matrix_set_length(&ca, m, n);
   for (i = 0; i < m; i++) {
      ae_v_cmove(ca.xyC[i], 1, a->xyC[i], 1, "N", n);
   }
   cmatrixlup(&ca, m, n, &p);
   for (i = 0; i < minmn; i++) {
      if (p.xZ[i] < i || p.xZ[i] >= n) {
         *PropOkP = false;
         ae_frame_leave();
         return Ok;
      }
   }
   ae_matrix_set_length(&cl, m, minmn);
   for (j = 0; j < minmn; j++) {
      for (i = 0; i < j; i++) {
         cl.xyC[i][j] = complex_from_d(0.0);
      }
      for (i = j; i < m; i++) {
         cl.xyC[i][j] = ca.xyC[i][j];
      }
   }
   ae_matrix_set_length(&cu, minmn, n);
   for (i = 0; i < minmn; i++) {
      for (j = 0; j < i; j++) {
         cu.xyC[i][j] = complex_from_d(0.0);
      }
      cu.xyC[i][i] = complex_from_d(1.0);
      for (j = i + 1; j < n; j++) {
         cu.xyC[i][j] = ca.xyC[i][j];
      }
   }
   ae_matrix_set_length(&ca2, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(cl.xyC[i], 1, "N", &cu.xyC[0][j], cu.stride, "N", minmn);
         ca2.xyC[i][j] = v;
      }
   }
   ae_vector_set_length(&ct, m);
   for (i = minmn - 1; i >= 0; i--) {
      if (i != p.xZ[i]) {
         ae_v_cmove(ct.xC, 1, &ca2.xyC[0][i], ca2.stride, "N", m);
         ae_v_cmove(&ca2.xyC[0][i], ca2.stride, &ca2.xyC[0][p.xZ[i]], ca2.stride, "N", m);
         ae_v_cmove(&ca2.xyC[0][p.xZ[i]], ca2.stride, ct.xC, 1, "N", m);
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         Ok = Ok && NearAtC(a->xyC[i][j], ca2.xyC[i][j], threshold);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing dense Cholesky updates
// ALGLIB Project: Copyright 16.01.2014 by Sergey Bochkanov
static bool testtrfacunit_testdensecholeskyupdates() {
   ae_frame _frame_block;
   ae_int_t n;
   double pfix;
   ae_int_t i;
   ae_int_t j;
   bool isupper;
   double tol;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a0, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(u, 0, DT_REAL);
   NewVector(fix, 0, DT_BOOL);
   NewVector(bufr, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Settings
   tol = 1.0E-8;
// Test rank-1 updates
//
// For each matrix size in 1..30 select sparse update vector with probability of element
// being non-zero equal to 1/2.
   for (n = 1; n <= 30; n++) {
   // Generate two matrices A0 == A1, fill one triangle with SPD matrix,
   // another one with trash. Prepare vector U.
      isupper = hqrnduniformr(&rs) < 0.5;
      spdmatrixrndcond(n, 1.0E4, &a0);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (isupper? j < i: j > i) {
               a0.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
            }
         }
      }
      ae_matrix_set_length(&a1, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a1.xyR[i][j] = a0.xyR[i][j];
         }
      }
      ae_vector_set_length(&u, n);
      for (i = 0; i < n; i++) {
         if (hqrnduniformr(&rs) <= 0.5) {
            u.xR[i] = hqrnduniformr(&rs) - 0.5;
         } else {
            u.xR[i] = 0.0;
         }
      }
   // Factorize and compare:
   // * A0 is factorized as follows: first with full Cholesky, then
   //   we call SPDMatrixCholeskyUpdateAdd1
   // * A1 is transformed explicitly before factorization with full Cholesky
   //
   // We randomly test either SPDMatrixCholeskyUpdateFix() or its
   // buffered version, SPDMatrixCholeskyUpdateFixBuf()
      Ok = Ok && spdmatrixcholesky(&a0, n, isupper);
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      if (hqrnduniformr(&rs) < 0.5) {
         spdmatrixcholeskyupdateadd1(&a0, n, isupper, &u);
      } else {
         spdmatrixcholeskyupdateadd1buf(&a0, n, isupper, &u, &bufr);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (isupper? j >= i: j <= i) {
               a1.xyR[i][j] += u.xR[i] * u.xR[j];
            }
         }
      }
      Ok = Ok && spdmatrixcholesky(&a1, n, isupper);
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            Ok = Ok && NearAtR(a0.xyR[i][j], a1.xyR[i][j], tol);
         }
      }
   }
// Test variable fixing functions.
//
// For each matrix size in 1..30 select PFix - probability of each variable being fixed,
// and perform test.
   for (n = 1; n <= 30; n++) {
   // Generate two matrices A0 == A1, fill one triangle with SPD matrix,
   // another one with trash. Prepare vector Fix.
      pfix = (double)hqrnduniformi(&rs, n + 1) / n;
      isupper = hqrnduniformr(&rs) < 0.5;
      spdmatrixrndcond(n, 1.0E4, &a0);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (isupper? j < i: j > i) {
               a0.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
            }
         }
      }
      ae_matrix_set_length(&a1, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a1.xyR[i][j] = a0.xyR[i][j];
         }
      }
      ae_vector_set_length(&fix, n);
      for (i = 0; i < n; i++) {
         fix.xB[i] = hqrnduniformr(&rs) <= pfix;
      }
   // Factorize and compare:
   // * A0 is factorized as follows: first with full Cholesky, then
   //   variables are fixed with SPDMatrixCholeskyUpdateFix
   // * A1 is fixed explicitly before factorization with full Cholesky
   //
   // We randomly test either SPDMatrixCholeskyUpdateFix() or its
   // buffered version, SPDMatrixCholeskyUpdateFixBuf()
      Ok = Ok && spdmatrixcholesky(&a0, n, isupper);
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      if (hqrnduniformr(&rs) < 0.5) {
         spdmatrixcholeskyupdatefixbuf(&a0, n, isupper, &fix, &bufr);
      } else {
         spdmatrixcholeskyupdatefix(&a0, n, isupper, &fix);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (isupper? j >= i: j <= i) {
               if (fix.xB[i] || fix.xB[j]) {
                  if (i == j) {
                     a1.xyR[i][j] = 1.0;
                  } else {
                     a1.xyR[i][j] = 0.0;
                  }
               }
            }
         }
      }
      Ok = Ok && spdmatrixcholesky(&a1, n, isupper);
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            Ok = Ok && NearAtR(a0.xyR[i][j], a1.xyR[i][j], tol);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

bool testtrfac() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t mx;
   ae_int_t maxmn;
   ae_int_t largemn;
   ae_int_t i;
   ae_int_t j;
   complex vc;
   double vr;
   bool Ok;
   bool dspdOk;
   bool sspdOk;
   bool srOk;
   bool hpdOk;
   bool rOk;
   bool cOk;
   bool propOk;
   bool dspdupdOk;
   double threshold;
   ae_int_t pass;
   ae_frame_make(&_frame_block);
   NewMatrix(ra, 0, 0, DT_REAL);
   NewMatrix(ral, 0, 0, DT_REAL);
   NewMatrix(rau, 0, 0, DT_REAL);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewMatrix(cal, 0, 0, DT_COMPLEX);
   NewMatrix(cau, 0, 0, DT_COMPLEX);
   rOk = true;
   dspdOk = true;
   sspdOk = true;
   cOk = true;
   hpdOk = true;
   propOk = true;
   dspdupdOk = true;
   srOk = true;
   Ok = true;
   maxmn = 4 * matrixtilesizea() + 1;
   largemn = 256;
   threshold = 1000.0 * machineepsilon * maxmn;
// Sparse Cholesky
   sspdOk = sspdOk && sparserealcholeskytest();
// Sparse LU
   srOk = srOk && sparsereallutest();
// Cholesky updates
   dspdupdOk = dspdupdOk && testtrfacunit_testdensecholeskyupdates();
// test LU:
// * first, test on small-scale matrices
// * then, perform several large-scale tests
   for (mx = 1; mx <= maxmn; mx++) {
   // Initialize N/M, both are <= MX,
   // at least one of them is exactly equal to MX
      n = 1 + randominteger(mx);
      m = 1 + randominteger(mx);
      if (randombool()) {
         n = mx;
      } else {
         m = mx;
      }
   // First, test on zero matrix
      ae_matrix_set_length(&ra, m, n);
      ae_matrix_set_length(&ca, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            ra.xyR[i][j] = 0.0;
            ca.xyC[i][j] = complex_from_i(0);
         }
      }
      cOk = cOk && testtrfacunit_testcluproblem(&ca, m, n, threshold, &propOk);
      rOk = rOk && testtrfacunit_testrluproblem(&ra, m, n, threshold, &propOk);
   // Second, random matrix with moderate condition number
      ae_matrix_set_length(&ra, m, n);
      ae_matrix_set_length(&ca, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            ra.xyR[i][j] = 0.0;
            ca.xyC[i][j] = complex_from_i(0);
         }
      }
      for (i = 0; i < imin2(m, n); i++) {
         ra.xyR[i][i] = 1 + 10.0 * randomreal();
         ca.xyC[i][i] = complex_from_d(1 + 10.0 * randomreal());
      }
      cmatrixrndorthogonalfromtheleft(&ca, m, n);
      cmatrixrndorthogonalfromtheright(&ca, m, n);
      rmatrixrndorthogonalfromtheleft(&ra, m, n);
      rmatrixrndorthogonalfromtheright(&ra, m, n);
      cOk = cOk && testtrfacunit_testcluproblem(&ca, m, n, threshold, &propOk);
      rOk = rOk && testtrfacunit_testrluproblem(&ra, m, n, threshold, &propOk);
   }
   for (pass = 1; pass <= 2; pass++) {
      m = largemn + (randominteger(3) - 1);
      n = largemn + (randominteger(3) - 1);
   // Random matrix with moderate condition number
      ae_matrix_set_length(&ra, m, n);
      ae_matrix_set_length(&ca, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            ra.xyR[i][j] = 0.0;
            ca.xyC[i][j] = complex_from_i(0);
         }
      }
      for (i = 0; i < imin2(m, n); i++) {
         ra.xyR[i][i] = 1 + 10.0 * randomreal();
         ca.xyC[i][i] = complex_from_d(1 + 10.0 * randomreal());
      }
      cmatrixrndorthogonalfromtheleft(&ca, m, n);
      cmatrixrndorthogonalfromtheright(&ca, m, n);
      rmatrixrndorthogonalfromtheleft(&ra, m, n);
      rmatrixrndorthogonalfromtheright(&ra, m, n);
      cOk = cOk && testtrfacunit_testcluproblem(&ca, m, n, threshold, &propOk);
      rOk = rOk && testtrfacunit_testrluproblem(&ra, m, n, threshold, &propOk);
   }
// Test Cholesky
   for (n = 1; n <= maxmn; n++) {
   // Load CA (HPD matrix with low condition number),
   //      CAL and CAU - its lower and upper triangles
      hpdmatrixrndcond(n, 1 + 50.0 * randomreal(), &ca);
      ae_matrix_set_length(&cal, n, n);
      ae_matrix_set_length(&cau, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            cal.xyC[i][j] = complex_from_i(i);
            cau.xyC[i][j] = complex_from_i(j);
         }
      }
      for (i = 0; i < n; i++) {
         ae_v_cmove(cal.xyC[i], 1, ca.xyC[i], 1, "N", i + 1);
         ae_v_cmove(&cau.xyC[i][i], 1, &ca.xyC[i][i], 1, "N", n - i);
      }
   // Test HPDMatrixCholesky:
   // 1. it must leave upper (lower) part unchanged
   // 2. max(A-L*L^H) must be small
      if (hpdmatrixcholesky(&cal, n, false)) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (j > i) {
                  hpdOk = hpdOk && !ae_c_neq_d(cal.xyC[i][j], i);
               } else {
                  vc = ae_v_cdotproduct(cal.xyC[i], 1, "N", cal.xyC[j], 1, "Conj", j + 1);
                  hpdOk = hpdOk && NearAtC(ca.xyC[i][j], vc, threshold);
               }
            }
         }
      } else {
         hpdOk = false;
      }
      if (hpdmatrixcholesky(&cau, n, true)) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (j < i) {
                  hpdOk = hpdOk && !ae_c_neq_d(cau.xyC[i][j], j);
               } else {
                  vc = ae_v_cdotproduct(&cau.xyC[0][i], cau.stride, "Conj", &cau.xyC[0][j], cau.stride, "N", i + 1);
                  hpdOk = hpdOk && NearAtC(ca.xyC[i][j], vc, threshold);
               }
            }
         }
      } else {
         hpdOk = false;
      }
   // Load RA (SPD matrix with low condition number),
   //      RAL and RAU - its lower and upper triangles
   //
   // Test SPDMatrixCholesky:
   // 1. it must leave upper (lower) part unchanged
   // 2. max(A-L*L^H) must be small
   //
   // After testing SPDMatrixCholesky() we compare results
   // returned by SparseCholeskyX() against ones returned
   // by SPDMatrixCholesky().
      spdmatrixrndcond(n, 1 + 50.0 * randomreal(), &ra);
      ae_matrix_set_length(&ral, n, n);
      ae_matrix_set_length(&rau, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            ral.xyR[i][j] = (double)i;
            rau.xyR[i][j] = (double)j;
         }
      }
      for (i = 0; i < n; i++) {
         ae_v_move(ral.xyR[i], 1, ra.xyR[i], 1, i + 1);
         ae_v_move(&rau.xyR[i][i], 1, &ra.xyR[i][i], 1, n - i);
      }
      if (spdmatrixcholesky(&ral, n, false)) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (j > i) {
                  dspdOk = dspdOk && ral.xyR[i][j] == (double)i;
               } else {
                  vr = ae_v_dotproduct(ral.xyR[i], 1, ral.xyR[j], 1, j + 1);
                  dspdOk = dspdOk && NearAtR(ra.xyR[i][j], vr, threshold);
               }
            }
         }
      } else {
         dspdOk = false;
      }
      if (spdmatrixcholesky(&rau, n, true)) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (j < i) {
                  dspdOk = dspdOk && rau.xyR[i][j] == (double)j;
               } else {
                  vr = ae_v_dotproduct(&rau.xyR[0][i], rau.stride, &rau.xyR[0][j], rau.stride, i + 1);
                  dspdOk = dspdOk && NearAtR(ra.xyR[i][j], vr, threshold);
               }
            }
         }
      } else {
         dspdOk = false;
      }
   // Check algorithms on negative definite matrices -
   // correct error code must be returned.
      ae_matrix_set_length(&ra, n, n);
      ae_matrix_set_length(&ca, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            ra.xyR[i][j] = 0.0;
            ca.xyC[i][j] = complex_from_d(0.0);
         }
         ra.xyR[i][i] = 1.0;
         ca.xyC[i][i] = complex_from_d(1.0);
      }
      ra.xyR[n / 2][n / 2] = -1.0;
      ca.xyC[n / 2][n / 2] = complex_from_d(-1.0);
      dspdOk = dspdOk && !spdmatrixcholesky(&ra, n, randombool());
      hpdOk = hpdOk && !hpdmatrixcholesky(&ca, n, randombool());
   }
// The final report.
   Ok = rOk && srOk && dspdOk && sspdOk && cOk && hpdOk && propOk && dspdupdOk;
   if (!Ok || !silent) {
      printf("Factorization Tests\n");
      printf("* Triangular Factorization Tests\n");
      printf("* Real (Dense):                           %s\n", rOk? "Ok": "Failed");
      printf("* Real (Sparse):                          %s\n", srOk? "Ok": "Failed");
      printf("* SPD (Dense):                            %s\n", dspdOk? "Ok": "Failed");
      printf("* SPD (Sparse):                           %s\n", sspdOk? "Ok": "Failed");
      printf("* Complex:                                %s\n", cOk? "Ok": "Failed");
      printf("* HPD:                                    %s\n", hpdOk? "Ok": "Failed");
      printf("* Other Properties:                       %s\n", propOk? "Ok": "Failed");
      printf("* Updated Factorization Test\n");
      printf("* SPD (Dense):                            %s\n", dspdupdOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === polynomialsolver testing unit ===
// Test
bool testpolynomialsolver() {
   ae_frame _frame_block;
   bool Ok;
   double eps;
   ae_int_t n;
   ae_frame_make(&_frame_block);
   NewVector(a, 0, DT_REAL);
   NewVector(x, 0, DT_COMPLEX);
   NewObj(polynomialsolverreport, rep);
   Ok = true;
// Basic tests
   eps = 1.0E-6;
   n = 1;
   ae_vector_set_length(&a, n + 1);
   a.xR[0] = 2.0;
   a.xR[1] = 3.0;
   polynomialsolve(&a, n, &x, &rep);
   Ok = Ok && NearAtR(x.xC[0].x, -2.0 / 3.0, eps);
   Ok = Ok && x.xC[0].y == 0.0;
   Ok = Ok && rep.maxerr <= 100.0 * machineepsilon;
   n = 2;
   ae_vector_set_length(&a, n + 1);
   a.xR[0] = 1.0;
   a.xR[1] = -2.0;
   a.xR[2] = 1.0;
   polynomialsolve(&a, n, &x, &rep);
   Ok = Ok && NearAtCR(x.xC[0], 1.0, eps);
   Ok = Ok && NearAtCR(x.xC[1], 1.0, eps);
   Ok = Ok && rep.maxerr <= 100.0 * machineepsilon;
   n = 2;
   ae_vector_set_length(&a, n + 1);
   a.xR[0] = 2.0;
   a.xR[1] = -3.0;
   a.xR[2] = 1.0;
   polynomialsolve(&a, n, &x, &rep);
   if (x.xC[0].x < x.xC[1].x) {
      Ok = Ok && NearAtR(x.xC[0].x, 1, eps);
      Ok = Ok && NearAtR(x.xC[1].x, 2, eps);
   } else {
      Ok = Ok && NearAtR(x.xC[0].x, 2, eps);
      Ok = Ok && NearAtR(x.xC[1].x, 1, eps);
   }
   Ok = Ok && x.xC[0].y == 0.0;
   Ok = Ok && x.xC[1].y == 0.0;
   Ok = Ok && rep.maxerr <= 100.0 * machineepsilon;
   n = 2;
   ae_vector_set_length(&a, n + 1);
   a.xR[0] = 1.0;
   a.xR[1] = 0.0;
   a.xR[2] = 1.0;
   polynomialsolve(&a, n, &x, &rep);
   Ok = Ok && NearAtCR(ae_c_mul(x.xC[0], x.xC[0]), -1.0, eps);
   Ok = Ok && rep.maxerr <= 100.0 * machineepsilon;
   n = 4;
   ae_vector_set_length(&a, n + 1);
   a.xR[0] = 0.0;
   a.xR[1] = 0.0;
   a.xR[2] = 0.0;
   a.xR[3] = 0.0;
   a.xR[4] = 1.0;
   polynomialsolve(&a, n, &x, &rep);
   Ok = Ok && !ae_c_neq_d(x.xC[0], 0.0);
   Ok = Ok && !ae_c_neq_d(x.xC[1], 0.0);
   Ok = Ok && !ae_c_neq_d(x.xC[2], 0.0);
   Ok = Ok && !ae_c_neq_d(x.xC[3], 0.0);
   Ok = Ok && rep.maxerr <= 100.0 * machineepsilon;
   n = 2;
   ae_vector_set_length(&a, n + 1);
   a.xR[0] = 0.0;
   a.xR[1] = 3.0;
   a.xR[2] = 2.0;
   polynomialsolve(&a, n, &x, &rep);
   if (x.xC[0].x > x.xC[1].x) {
      Ok = Ok && !ae_c_neq_d(x.xC[0], 0.0);
      Ok = Ok && NearAtR(x.xC[1].x, -3.0 / 2.0, eps);
      Ok = Ok && x.xC[1].y == 0.0;
   } else {
      Ok = Ok && !ae_c_neq_d(x.xC[1], 0.0);
      Ok = Ok && NearAtR(x.xC[0].x, -3.0 / 2.0, eps);
      Ok = Ok && x.xC[0].y == 0.0;
   }
   Ok = Ok && rep.maxerr <= 100.0 * machineepsilon;
// The final report.
   if (!Ok || !silent) {
      printf("Polynomial Solver Test\n");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === bdsvd testing unit ===
static void testbdsvdunit_fillidentity(RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_matrix_set_length(a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (i == j) {
            a->xyR[i][j] = 1.0;
         } else {
            a->xyR[i][j] = 0.0;
         }
      }
   }
}

static void testbdsvdunit_fillsparsede(RVector *d, RVector *e, ae_int_t n, double sparsity) {
   ae_int_t i;
   ae_vector_set_length(d, n);
   ae_vector_set_length(e, imax2(0, n - 2) + 1);
   for (i = 0; i < n; i++) {
      if (randombool(sparsity)) {
         d->xR[i] = 0.0;
      } else {
         d->xR[i] = randommid();
      }
   }
   for (i = 0; i < n - 1; i++) {
      if (randombool(sparsity)) {
         e->xR[i] = 0.0;
      } else {
         e->xR[i] = randommid();
      }
   }
}

static bool testbdsvdunit_getbdsvderror(RVector *d, RVector *e, ae_int_t n, bool isupper, RMatrix *u, RMatrix *c, RVector *w, RMatrix *vt, double *materr, double *orterr) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double locerr;
   double sm;
   bool Ok = true;
// decomposition error
   locerr = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         sm = 0.0;
         for (k = 0; k < n; k++) {
            sm += w->xR[k] * u->xyR[i][k] * vt->xyR[k][j];
         }
         if (isupper) {
            if (i == j) {
               locerr = rmax2(locerr, fabs(d->xR[i] - sm));
            } else {
               if (i == j - 1) {
                  locerr = rmax2(locerr, fabs(e->xR[i] - sm));
               } else {
                  locerr = rmax2(locerr, fabs(sm));
               }
            }
         } else {
            if (i == j) {
               locerr = rmax2(locerr, fabs(d->xR[i] - sm));
            } else {
               if (i - 1 == j) {
                  locerr = rmax2(locerr, fabs(e->xR[j] - sm));
               } else {
                  locerr = rmax2(locerr, fabs(sm));
               }
            }
         }
      }
   }
   *materr = rmax2(*materr, locerr);
// check for C = U'
// we consider it as decomposition error
   locerr = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         locerr = rmax2(locerr, fabs(u->xyR[i][j] - c->xyR[j][i]));
      }
   }
   *materr = rmax2(*materr, locerr);
// orthogonality error
   locerr = 0.0;
   for (i = 0; i < n; i++) {
      for (j = i; j < n; j++) {
         sm = ae_v_dotproduct(&u->xyR[0][i], u->stride, &u->xyR[0][j], u->stride, n);
         if (i != j) {
            locerr = rmax2(locerr, fabs(sm));
         } else {
            locerr = rmax2(locerr, fabs(sm - 1));
         }
         sm = ae_v_dotproduct(vt->xyR[i], 1, vt->xyR[j], 1, n);
         if (i != j) {
            locerr = rmax2(locerr, fabs(sm));
         } else {
            locerr = rmax2(locerr, fabs(sm - 1));
         }
      }
   }
   *orterr = rmax2(*orterr, locerr);
// values order error
   for (i = 1; i < n; i++) {
      if (w->xR[i] > w->xR[i - 1]) {
         Ok = true;
      }
   }
   return Ok;
}

static void testbdsvdunit_checksvdmultiplication(RVector *d, RVector *e, ae_int_t n, bool isupper, RMatrix *u, RMatrix *c, RVector *w, RMatrix *vt, double *err) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t nru;
   ae_int_t ncc;
   ae_int_t ncvt;
   ae_int_t pass;
   double v;
   ae_frame_make(&_frame_block);
   NewVector(wt, 0, DT_REAL);
   NewMatrix(u2, 0, 0, DT_REAL);
   NewMatrix(c2, 0, 0, DT_REAL);
   NewMatrix(vt2, 0, 0, DT_REAL);
   NewMatrix(u1, 0, 0, DT_REAL);
   NewMatrix(c1, 0, 0, DT_REAL);
   NewMatrix(vt1, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   ae_vector_set_length(&wt, n);
// Perform nonsquare SVD
   for (pass = 1; pass <= 20; pass++) {
   // Problem size
      nru = hqrnduniformi(&rs, 2 * n);
      ncc = hqrnduniformi(&rs, 2 * n);
      ncvt = hqrnduniformi(&rs, 2 * n);
   // Reference matrices (copy 1) and working matrices (copy 2)
      for (i = 0; i < n; i++) {
         wt.xR[i] = d->xR[i];
      }
      if (nru > 0) {
      // init U1/U2
         ae_matrix_set_length(&u1, nru, n);
         ae_matrix_set_length(&u2, nru, n);
         for (i = 0; i < u1.rows; i++) {
            for (j = 0; j < u1.cols; j++) {
               u1.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               u2.xyR[i][j] = u1.xyR[i][j];
            }
         }
      } else {
      // Set U1/U2 to 1x1 matrices; working with 1x1 matrices allows
      // to test correctness of code which passes them to MKL.
         ae_matrix_set_length(&u1, 1, 1);
         ae_matrix_set_length(&u2, 1, 1);
      }
      if (ncc > 0) {
         ae_matrix_set_length(&c1, n, ncc);
         ae_matrix_set_length(&c2, n, ncc);
         for (i = 0; i < c1.rows; i++) {
            for (j = 0; j < c1.cols; j++) {
               c1.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               c2.xyR[i][j] = c1.xyR[i][j];
            }
         }
      } else {
      // Set C1/C1 to 1x1 matrices; working with 1x1 matrices allows
      // to test correctness of code which passes them to MKL.
         ae_matrix_set_length(&c1, 1, 1);
         ae_matrix_set_length(&c2, 1, 1);
      }
      if (ncvt > 0) {
         ae_matrix_set_length(&vt1, n, ncvt);
         ae_matrix_set_length(&vt2, n, ncvt);
         for (i = 0; i < vt1.rows; i++) {
            for (j = 0; j < vt1.cols; j++) {
               vt1.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               vt2.xyR[i][j] = vt1.xyR[i][j];
            }
         }
      } else {
      // Set VT1/VT1 to 1x1 matrices; working with 1x1 matrices allows
      // to test correctness of code which passes them to MKL.
         ae_matrix_set_length(&vt1, 1, 1);
         ae_matrix_set_length(&vt2, 1, 1);
      }
   // SVD with non-square U/C/VT
      if (!rmatrixbdsvd(&wt, e, n, isupper, hqrnduniformr(&rs) > 0.0, &u2, nru, &c2, ncc, &vt2, ncvt)) {
         *err = 1.0;
         ae_frame_leave();
         return;
      }
      for (i = 0; i < nru; i++) {
         for (j = 0; j < u2.cols; j++) {
            v = ae_v_dotproduct(u1.xyR[i], 1, &u->xyR[0][j], u->stride, n);
            *err = rmax2(*err, fabs(v - u2.xyR[i][j]));
         }
      }
      for (i = 0; i < c2.rows; i++) {
         for (j = 0; j < ncc; j++) {
            v = ae_v_dotproduct(c->xyR[i], 1, &c1.xyR[0][j], c1.stride, n);
            *err = rmax2(*err, fabs(v - c2.xyR[i][j]));
         }
      }
      for (i = 0; i < vt2.rows; i++) {
         for (j = 0; j < ncvt; j++) {
            v = ae_v_dotproduct(vt->xyR[i], 1, &vt1.xyR[0][j], vt1.stride, n);
            *err = rmax2(*err, fabs(v - vt2.xyR[i][j]));
         }
      }
   }
   ae_frame_leave();
}

static void testbdsvdunit_testbdsvdproblem(RVector *d, RVector *e, ae_int_t n, double *materr, double *orterr, bool *SortOkP, bool *ConvOkP, ae_int_t *failcount, ae_int_t *succcount) {
   ae_frame _frame_block;
   ae_int_t i;
   double mx;
   ae_frame_make(&_frame_block);
   NewMatrix(u, 0, 0, DT_REAL);
   NewMatrix(vt, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   mx = 0.0;
   for (i = 0; i < n; i++) {
      if (!SmallAtR(d->xR[i], mx)) {
         mx = fabs(d->xR[i]);
      }
   }
   for (i = 0; i < n - 1; i++) {
      if (!SmallAtR(e->xR[i], mx)) {
         mx = fabs(e->xR[i]);
      }
   }
   if (mx == 0.0) {
      mx = 1.0;
   }
// Upper BDSVD tests
   ae_vector_set_length(&w, n);
   testbdsvdunit_fillidentity(&u, n);
   testbdsvdunit_fillidentity(&vt, n);
   testbdsvdunit_fillidentity(&c, n);
   for (i = 0; i < n; i++) {
      w.xR[i] = d->xR[i];
   }
   if (!rmatrixbdsvd(&w, e, n, true, false, &u, n, &c, n, &vt, n)) {
      ++*failcount;
      *ConvOkP = false;
      ae_frame_leave();
      return;
   }
   *SortOkP = *SortOkP && testbdsvdunit_getbdsvderror(d, e, n, true, &u, &c, &w, &vt, materr, orterr);
   testbdsvdunit_checksvdmultiplication(d, e, n, true, &u, &c, &w, &vt, materr);
   testbdsvdunit_fillidentity(&u, n);
   testbdsvdunit_fillidentity(&vt, n);
   testbdsvdunit_fillidentity(&c, n);
   for (i = 0; i < n; i++) {
      w.xR[i] = d->xR[i];
   }
   if (!rmatrixbdsvd(&w, e, n, true, true, &u, n, &c, n, &vt, n)) {
      ++*failcount;
      *ConvOkP = false;
      ae_frame_leave();
      return;
   }
   *SortOkP = *SortOkP && testbdsvdunit_getbdsvderror(d, e, n, true, &u, &c, &w, &vt, materr, orterr);
   testbdsvdunit_checksvdmultiplication(d, e, n, true, &u, &c, &w, &vt, materr);
// Lower BDSVD tests
   ae_vector_set_length(&w, n);
   testbdsvdunit_fillidentity(&u, n);
   testbdsvdunit_fillidentity(&vt, n);
   testbdsvdunit_fillidentity(&c, n);
   for (i = 0; i < n; i++) {
      w.xR[i] = d->xR[i];
   }
   if (!rmatrixbdsvd(&w, e, n, false, false, &u, n, &c, n, &vt, n)) {
      ++*failcount;
      *ConvOkP = false;
      ae_frame_leave();
      return;
   }
   *SortOkP = *SortOkP && testbdsvdunit_getbdsvderror(d, e, n, false, &u, &c, &w, &vt, materr, orterr);
   testbdsvdunit_checksvdmultiplication(d, e, n, false, &u, &c, &w, &vt, materr);
   testbdsvdunit_fillidentity(&u, n);
   testbdsvdunit_fillidentity(&vt, n);
   testbdsvdunit_fillidentity(&c, n);
   for (i = 0; i < n; i++) {
      w.xR[i] = d->xR[i];
   }
   if (!rmatrixbdsvd(&w, e, n, false, true, &u, n, &c, n, &vt, n)) {
      ++*failcount;
      *ConvOkP = false;
      ae_frame_leave();
      return;
   }
   *SortOkP = *SortOkP && testbdsvdunit_getbdsvderror(d, e, n, false, &u, &c, &w, &vt, materr, orterr);
   testbdsvdunit_checksvdmultiplication(d, e, n, false, &u, &c, &w, &vt, materr);
// update counter
   ++*succcount;
   ae_frame_leave();
}

// Testing bidiagonal SVD decomposition subroutine
bool testbdsvd() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t i;
   ae_int_t pass;
   bool Ok;
   bool sortOk;
   bool convOk;
   double materr;
   double orterr;
   double threshold;
   double failr;
   ae_int_t failcount;
   ae_int_t succcount;
   ae_frame_make(&_frame_block);
   NewVector(d, 0, DT_REAL);
   NewVector(e, 0, DT_REAL);
   NewMatrix(mempty, 0, 0, DT_REAL);
   failcount = 0;
   succcount = 0;
   materr = 0.0;
   orterr = 0.0;
   sortOk = true;
   convOk = true;
   Ok = true;
   maxn = 15;
   threshold = 5.0 * 100.0 * machineepsilon;
   ae_vector_set_length(&d, maxn);
   ae_vector_set_length(&e, maxn - 1);
// special case: zero divide matrix
// unfixed LAPACK routine should fail on this problem
   n = 7;
   d.xR[0] = -6.96462904751731892700e-01;
   d.xR[1] = 0.00000000000000000000e+00;
   d.xR[2] = -5.73827770385971991400e-01;
   d.xR[3] = -6.62562624399371191700e-01;
   d.xR[4] = 5.82737148001782223600e-01;
   d.xR[5] = 3.84825263580925003300e-01;
   d.xR[6] = 9.84087420830525472200e-01;
   e.xR[0] = -7.30307931760612871800e-02;
   e.xR[1] = -2.30079042939542843800e-01;
   e.xR[2] = -6.87824621739351216300e-01;
   e.xR[3] = -1.77306437707837570600e-02;
   e.xR[4] = 1.78285126526551632000e-15;
   e.xR[5] = -4.89434737751289969400e-02;
   rmatrixbdsvd(&d, &e, n, true, false, &mempty, 0, &mempty, 0, &mempty, 0);
// zero matrix, several cases
   for (i = 0; i < maxn; i++) {
      d.xR[i] = 0.0;
   }
   for (i = 0; i < maxn - 1; i++) {
      e.xR[i] = 0.0;
   }
   for (n = 1; n <= maxn; n++) {
      testbdsvdunit_testbdsvdproblem(&d, &e, n, &materr, &orterr, &sortOk, &convOk, &failcount, &succcount);
   }
// Dense matrix
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= 10; pass++) {
         for (i = 0; i < maxn; i++) {
            d.xR[i] = randommid();
         }
         for (i = 0; i < maxn - 1; i++) {
            e.xR[i] = randommid();
         }
         testbdsvdunit_testbdsvdproblem(&d, &e, n, &materr, &orterr, &sortOk, &convOk, &failcount, &succcount);
      }
   }
// Sparse matrices, very sparse matrices, incredible sparse matrices
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= 10; pass++) {
         testbdsvdunit_fillsparsede(&d, &e, n, 0.5);
         testbdsvdunit_testbdsvdproblem(&d, &e, n, &materr, &orterr, &sortOk, &convOk, &failcount, &succcount);
         testbdsvdunit_fillsparsede(&d, &e, n, 0.8);
         testbdsvdunit_testbdsvdproblem(&d, &e, n, &materr, &orterr, &sortOk, &convOk, &failcount, &succcount);
         testbdsvdunit_fillsparsede(&d, &e, n, 0.9);
         testbdsvdunit_testbdsvdproblem(&d, &e, n, &materr, &orterr, &sortOk, &convOk, &failcount, &succcount);
         testbdsvdunit_fillsparsede(&d, &e, n, 0.95);
         testbdsvdunit_testbdsvdproblem(&d, &e, n, &materr, &orterr, &sortOk, &convOk, &failcount, &succcount);
      }
   }
   failr = (double)failcount / (succcount + failcount);
// The final report.
   Ok = convOk && materr <= threshold && orterr <= threshold && sortOk;
   if (!Ok || !silent) {
      printf("Bi-Diagonal Singular Value Decomposition Decomposition Tests\n");
      printf("SVD Decomposition Error:                  %5.3e\n", materr);
      printf("SVD Orthogonality Error:                  %5.3e\n", orterr);
      printf("Singular Values Order:                    %s\n", sortOk? "Ok": "Failed");
      printf("Always converged:                         %s\n", convOk? "Yes": "No");
      if (!convOk) {
         printf("Fail Ratio:                               %5.3f\n", failr);
      }
      printf("Threshold:                                %5.3e\n", threshold);
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === svd testing unit ===
static void testsvdunit_fillsparsea(RMatrix *a, ae_int_t m, ae_int_t n, double sparsity) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         if (randombool(sparsity)) {
            a->xyR[i][j] = 0.0;
         } else {
            a->xyR[i][j] = randommid();
         }
      }
   }
}

static bool testsvdunit_getsvderror(RMatrix *a, ae_int_t m, ae_int_t n, RMatrix *u, RVector *w, RMatrix *vt, double *materr, double *orterr) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t minmn;
   double locerr;
   double sm;
   bool Ok = true;
   minmn = imin2(m, n);
// decomposition error
   locerr = 0.0;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         sm = 0.0;
         for (k = 0; k < minmn; k++) {
            sm += w->xR[k] * u->xyR[i][k] * vt->xyR[k][j];
         }
         locerr = rmax2(locerr, fabs(a->xyR[i][j] - sm));
      }
   }
   *materr = rmax2(*materr, locerr);
// orthogonality error
   locerr = 0.0;
   for (i = 0; i < minmn; i++) {
      for (j = i; j < minmn; j++) {
         sm = ae_v_dotproduct(&u->xyR[0][i], u->stride, &u->xyR[0][j], u->stride, m);
         if (i != j) {
            locerr = rmax2(locerr, fabs(sm));
         } else {
            locerr = rmax2(locerr, fabs(sm - 1));
         }
         sm = ae_v_dotproduct(vt->xyR[i], 1, vt->xyR[j], 1, n);
         if (i != j) {
            locerr = rmax2(locerr, fabs(sm));
         } else {
            locerr = rmax2(locerr, fabs(sm - 1));
         }
      }
   }
   *orterr = rmax2(*orterr, locerr);
// values order error
   for (i = 1; i < minmn; i++) {
      if (w->xR[i] > w->xR[i - 1]) {
         Ok = true;
      }
   }
   return Ok;
}

static void testsvdunit_testsvdproblem(RMatrix *a, ae_int_t m, ae_int_t n, double *materr, double *orterr, double *othererr, bool *SortOkP, bool *ConvOkP, ae_int_t *failcount, ae_int_t *succcount) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ujob;
   ae_int_t vtjob;
   ae_int_t memjob;
   ae_int_t ucheck;
   ae_int_t vtcheck;
   ae_frame_make(&_frame_block);
   NewMatrix(u, 0, 0, DT_REAL);
   NewMatrix(vt, 0, 0, DT_REAL);
   NewMatrix(u2, 0, 0, DT_REAL);
   NewMatrix(vt2, 0, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
// Main SVD test
   if (!rmatrixsvd(a, m, n, 2, 2, 2, &w, &u, &vt)) {
      ++*failcount;
      *ConvOkP = false;
      ae_frame_leave();
      return;
   }
   *SortOkP = *SortOkP && testsvdunit_getsvderror(a, m, n, &u, &w, &vt, materr, orterr);
// Additional SVD tests
   for (ujob = 0; ujob <= 2; ujob++) {
      for (vtjob = 0; vtjob <= 2; vtjob++) {
         for (memjob = 0; memjob <= 2; memjob++) {
            if (!rmatrixsvd(a, m, n, ujob, vtjob, memjob, &w2, &u2, &vt2)) {
               ++*failcount;
               *ConvOkP = false;
               ae_frame_leave();
               return;
            }
            ucheck = 0;
            if (ujob == 1) {
               ucheck = imin2(m, n);
            }
            if (ujob == 2) {
               ucheck = m;
            }
            vtcheck = 0;
            if (vtjob == 1) {
               vtcheck = imin2(m, n);
            }
            if (vtjob == 2) {
               vtcheck = n;
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < ucheck; j++) {
                  *othererr = rmax2(*othererr, fabs(u.xyR[i][j] - u2.xyR[i][j]));
               }
            }
            for (i = 0; i < vtcheck; i++) {
               for (j = 0; j < n; j++) {
                  *othererr = rmax2(*othererr, fabs(vt.xyR[i][j] - vt2.xyR[i][j]));
               }
            }
            for (i = 0; i < imin2(m, n); i++) {
               *othererr = rmax2(*othererr, fabs(w.xR[i] - w2.xR[i]));
            }
         }
      }
   }
// update counter
   ++*succcount;
   ae_frame_leave();
}

// Testing SVD decomposition subroutine
bool testsvd() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t maxmn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t gpass;
   ae_int_t pass;
   bool Ok;
   bool sortOk;
   bool convOk;
   double materr;
   double orterr;
   double othererr;
   double threshold;
   double failr;
   ae_int_t failcount;
   ae_int_t succcount;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   failcount = 0;
   succcount = 0;
   materr = 0.0;
   orterr = 0.0;
   othererr = 0.0;
   sortOk = true;
   convOk = true;
   Ok = true;
   maxmn = 30;
   threshold = 5.0 * 100.0 * machineepsilon;
   ae_matrix_set_length(&a, maxmn, maxmn);
// TODO: div by zero fail, convergence fail
   for (gpass = 1; gpass <= 1; gpass++) {
   // zero matrix, several cases
      for (i = 0; i < maxmn; i++) {
         for (j = 0; j < maxmn; j++) {
            a.xyR[i][j] = 0.0;
         }
      }
      for (i = 1; i <= imin2(5, maxmn); i++) {
         for (j = 1; j <= imin2(5, maxmn); j++) {
            testsvdunit_testsvdproblem(&a, i, j, &materr, &orterr, &othererr, &sortOk, &convOk, &failcount, &succcount);
         }
      }
   // Long dense matrix
      for (i = 0; i < maxmn; i++) {
         for (j = 0; j < imin2(5, maxmn); j++) {
            a.xyR[i][j] = randommid();
         }
      }
      for (i = 1; i <= maxmn; i++) {
         for (j = 1; j <= imin2(5, maxmn); j++) {
            testsvdunit_testsvdproblem(&a, i, j, &materr, &orterr, &othererr, &sortOk, &convOk, &failcount, &succcount);
         }
      }
      for (i = 0; i < imin2(5, maxmn); i++) {
         for (j = 0; j < maxmn; j++) {
            a.xyR[i][j] = randommid();
         }
      }
      for (i = 1; i <= imin2(5, maxmn); i++) {
         for (j = 1; j <= maxmn; j++) {
            testsvdunit_testsvdproblem(&a, i, j, &materr, &orterr, &othererr, &sortOk, &convOk, &failcount, &succcount);
         }
      }
   // Dense matrices
      for (m = 1; m <= imin2(10, maxmn); m++) {
         for (n = 1; n <= imin2(10, maxmn); n++) {
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = randommid();
               }
            }
            testsvdunit_testsvdproblem(&a, m, n, &materr, &orterr, &othererr, &sortOk, &convOk, &failcount, &succcount);
         }
      }
   // Sparse matrices, very sparse matrices, incredible sparse matrices
      for (m = 1; m <= 10; m++) {
         for (n = 1; n <= 10; n++) {
            for (pass = 1; pass <= 2; pass++) {
               testsvdunit_fillsparsea(&a, m, n, 0.8);
               testsvdunit_testsvdproblem(&a, m, n, &materr, &orterr, &othererr, &sortOk, &convOk, &failcount, &succcount);
               testsvdunit_fillsparsea(&a, m, n, 0.9);
               testsvdunit_testsvdproblem(&a, m, n, &materr, &orterr, &othererr, &sortOk, &convOk, &failcount, &succcount);
               testsvdunit_fillsparsea(&a, m, n, 0.95);
               testsvdunit_testsvdproblem(&a, m, n, &materr, &orterr, &othererr, &sortOk, &convOk, &failcount, &succcount);
            }
         }
      }
   }
   failr = (double)failcount / (succcount + failcount);
// The final report.
   Ok = convOk && materr <= threshold && orterr <= threshold && othererr <= threshold && sortOk;
   if (!Ok || !silent) {
      printf("Singular Value Decomposition Tests\n");
      printf("SVD Decomposition Error:                  %5.3e\n", materr);
      printf("SVD Orthogonality Error:                  %5.3e\n", orterr);
      printf("SVD With Different Parameters Error:      %5.3e\n", othererr);
      printf("Singular Values Order:                    %s\n", sortOk? "Ok": "Failed");
      printf("Always converged:                         %s\n", convOk? "Yes": "No");
      if (!convOk) {
         printf("Fail Ratio:                               %5.3f\n", failr);
      }
      printf("Threshold:                                %5.3e\n", threshold);
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === trlinsolve testing unit ===
// Main unittest subroutine
bool testtrlinsolve() {
   ae_frame _frame_block;
   ae_int_t maxmn;
   ae_int_t passcount;
   double threshold;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t cnts;
   ae_int_t cntu;
   ae_int_t cntt;
   ae_int_t cntm;
   bool Ok;
   bool isupper;
   bool istrans;
   bool isunit;
   double v;
   double s;
   ae_frame_make(&_frame_block);
   NewMatrix(aeffective, 0, 0, DT_REAL);
   NewMatrix(aparam, 0, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   Ok = true;
   maxmn = 15;
   passcount = 15;
   threshold = 1000.0 * machineepsilon;
// Different problems
   for (n = 1; n <= maxmn; n++) {
      ae_matrix_set_length(&aeffective, n, n);
      ae_matrix_set_length(&aparam, n, n);
      ae_vector_set_length(&xe, n);
      ae_vector_set_length(&b, n);
      for (pass = 1; pass <= passcount; pass++) {
         for (cnts = 0; cnts <= 1; cnts++) {
            for (cntu = 0; cntu <= 1; cntu++) {
               for (cntt = 0; cntt <= 1; cntt++) {
                  for (cntm = 0; cntm <= 2; cntm++) {
                     isupper = cnts == 0;
                     isunit = cntu == 0;
                     istrans = cntt == 0;
                  // Skip meaningless combinations of parameters:
                  // (matrix is singular) AND (matrix is unit diagonal)
                     if (cntm == 2 && isunit) {
                        continue;
                     }
                  // Clear matrices
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           aeffective.xyR[i][j] = 0.0;
                           aparam.xyR[i][j] = 0.0;
                        }
                     }
                  // Prepare matrices
                     if (isupper) {
                        for (i = 0; i < n; i++) {
                           for (j = i; j < n; j++) {
                              aeffective.xyR[i][j] = 0.9 * randommid();
                              aparam.xyR[i][j] = aeffective.xyR[i][j];
                           }
                           aeffective.xyR[i][i] = (2 * randominteger(2) - 1) * (0.8 + randomreal());
                           aparam.xyR[i][i] = aeffective.xyR[i][i];
                        }
                     } else {
                        for (i = 0; i < n; i++) {
                           for (j = 0; j <= i; j++) {
                              aeffective.xyR[i][j] = 0.9 * randommid();
                              aparam.xyR[i][j] = aeffective.xyR[i][j];
                           }
                           aeffective.xyR[i][i] = (2 * randominteger(2) - 1) * (0.8 + randomreal());
                           aparam.xyR[i][i] = aeffective.xyR[i][i];
                        }
                     }
                     if (isunit) {
                        for (i = 0; i < n; i++) {
                           aeffective.xyR[i][i] = 1.0;
                           aparam.xyR[i][i] = 0.0;
                        }
                     }
                     if (istrans) {
                        if (isupper) {
                           for (i = 0; i < n; i++) {
                              for (j = i + 1; j < n; j++) {
                                 aeffective.xyR[j][i] = aeffective.xyR[i][j];
                                 aeffective.xyR[i][j] = 0.0;
                              }
                           }
                        } else {
                           for (i = 0; i < n; i++) {
                              for (j = i + 1; j < n; j++) {
                                 aeffective.xyR[i][j] = aeffective.xyR[j][i];
                                 aeffective.xyR[j][i] = 0.0;
                              }
                           }
                        }
                     }
                  // Prepare task, solve, compare
                     for (i = 0; i < n; i++) {
                        xe.xR[i] = randommid();
                     }
                     for (i = 0; i < n; i++) {
                        v = ae_v_dotproduct(aeffective.xyR[i], 1, xe.xR, 1, n);
                        b.xR[i] = v;
                     }
                     rmatrixtrsafesolve(&aparam, n, &b, &s, isupper, istrans, isunit);
                     ae_v_muld(xe.xR, 1, n, s);
                     ae_v_sub(xe.xR, 1, b.xR, 1, n);
                     v = ae_v_dotproduct(xe.xR, 1, xe.xR, 1, n);
                     v = sqrt(v);
                     Ok = Ok && v <= threshold;
                  }
               }
            }
         }
      }
   }
// The final report.
   if (!Ok || !silent) {
      printf("Real Matrix Safe TR Solver Test\n");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === safesolve testing unit ===
// Copy
static void testsafesolveunit_rmatrixmakeacopy(RMatrix *a, ae_int_t m, ae_int_t n, RMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyR[i][j] = a->xyR[i][j];
      }
   }
}

// Copy
static void testsafesolveunit_cmatrixmakeacopy(CMatrix *a, ae_int_t m, ae_int_t n, CMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyC[i][j] = a->xyC[i][j];
      }
   }
}

// Main unittest subroutine
bool testsafesolve() {
   ae_frame _frame_block;
   ae_int_t maxmn;
   double threshold;
   bool rOk;
   bool cOk;
   bool Ok;
   bool isupper;
   ae_int_t trans;
   bool isunit;
   double scalea;
   double growth;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t j1;
   ae_int_t j2;
   complex cv;
   double rv;
   ae_frame_make(&_frame_block);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewMatrix(cea, 0, 0, DT_COMPLEX);
   NewMatrix(ctmpa, 0, 0, DT_COMPLEX);
   NewVector(cxs, 0, DT_COMPLEX);
   NewVector(cxe, 0, DT_COMPLEX);
   NewMatrix(ra, 0, 0, DT_REAL);
   NewMatrix(rea, 0, 0, DT_REAL);
   NewMatrix(rtmpa, 0, 0, DT_REAL);
   NewVector(rxs, 0, DT_REAL);
   NewVector(rxe, 0, DT_REAL);
   maxmn = 30;
   threshold = 100000.0 * machineepsilon;
   rOk = true;
   cOk = true;
   Ok = true;
// Different problems: general tests
   for (n = 1; n <= maxmn; n++) {
   // test complex solver with well-conditioned matrix:
   // 1. generate A: fill off-diagonal elements with small values,
   //    diagonal elements are filled with larger values
   // 2. generate 'effective' A
   // 3. prepare task (exact X is stored in CXE, right part - in CXS),
   //    solve and compare CXS and CXE
      isupper = randombool();
      trans = randominteger(3);
      isunit = randombool();
      scalea = randomreal() + 0.5;
      ae_matrix_set_length(&ca, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (i == j) {
               ca.xyC[i][j] = complex_from_d((2 * randominteger(2) - 1) * (5 + randomreal()), (2 * randominteger(2) - 1) * (5 + randomreal()));
            } else {
               ca.xyC[i][j] = complex_from_d(0.1 * randommid(), 0.1 * randommid());
            }
         }
      }
      testsafesolveunit_cmatrixmakeacopy(&ca, n, n, &ctmpa);
      for (i = 0; i < n; i++) {
         if (isupper) {
            j1 = 0;
            j2 = i - 1;
         } else {
            j1 = i + 1;
            j2 = n - 1;
         }
         for (j = j1; j <= j2; j++) {
            ctmpa.xyC[i][j] = complex_from_i(0);
         }
         if (isunit) {
            ctmpa.xyC[i][i] = complex_from_i(1);
         }
      }
      ae_matrix_set_length(&cea, n, n);
      for (i = 0; i < n; i++) {
         if (trans == 0) {
            ae_v_cmoved(cea.xyC[i], 1, ctmpa.xyC[i], 1, "N", n, scalea);
         }
         if (trans == 1) {
            ae_v_cmoved(&cea.xyC[0][i], cea.stride, ctmpa.xyC[i], 1, "N", n, scalea);
         }
         if (trans == 2) {
            ae_v_cmoved(&cea.xyC[0][i], cea.stride, ctmpa.xyC[i], 1, "Conj", n, scalea);
         }
      }
      ae_vector_set_length(&cxe, n);
      for (i = 0; i < n; i++) {
         cxe.xC[i] = complex_from_d(randommid(), randommid());
      }
      ae_vector_set_length(&cxs, n);
      for (i = 0; i < n; i++) {
         cv = ae_v_cdotproduct(cea.xyC[i], 1, "N", cxe.xC, 1, "N", n);
         cxs.xC[i] = cv;
      }
      if (cmatrixscaledtrsafesolve(&ca, scalea, n, &cxs, isupper, trans, isunit, sqrt(maxrealnumber))) {
         for (i = 0; i < n; i++) {
            cOk = cOk && NearAtC(cxs.xC[i], cxe.xC[i], threshold);
         }
      } else {
         cOk = false;
      }
   // same with real
      isupper = randombool();
      trans = randominteger(2);
      isunit = randombool();
      scalea = randomreal() + 0.5;
      ae_matrix_set_length(&ra, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (i == j) {
               ra.xyR[i][j] = (2 * randominteger(2) - 1) * (5 + randomreal());
            } else {
               ra.xyR[i][j] = 0.1 * randommid();
            }
         }
      }
      testsafesolveunit_rmatrixmakeacopy(&ra, n, n, &rtmpa);
      for (i = 0; i < n; i++) {
         if (isupper) {
            j1 = 0;
            j2 = i - 1;
         } else {
            j1 = i + 1;
            j2 = n - 1;
         }
         for (j = j1; j <= j2; j++) {
            rtmpa.xyR[i][j] = 0.0;
         }
         if (isunit) {
            rtmpa.xyR[i][i] = 1.0;
         }
      }
      ae_matrix_set_length(&rea, n, n);
      for (i = 0; i < n; i++) {
         if (trans == 0) {
            ae_v_moved(rea.xyR[i], 1, rtmpa.xyR[i], 1, n, scalea);
         }
         if (trans == 1) {
            ae_v_moved(&rea.xyR[0][i], rea.stride, rtmpa.xyR[i], 1, n, scalea);
         }
      }
      ae_vector_set_length(&rxe, n);
      for (i = 0; i < n; i++) {
         rxe.xR[i] = randommid();
      }
      ae_vector_set_length(&rxs, n);
      for (i = 0; i < n; i++) {
         rv = ae_v_dotproduct(rea.xyR[i], 1, rxe.xR, 1, n);
         rxs.xR[i] = rv;
      }
      if (rmatrixscaledtrsafesolve(&ra, scalea, n, &rxs, isupper, trans, isunit, sqrt(maxrealnumber))) {
         for (i = 0; i < n; i++) {
            rOk = rOk && NearAtR(rxs.xR[i], rxe.xR[i], threshold);
         }
      } else {
         rOk = false;
      }
   }
// Special test with diagonal ill-conditioned matrix:
// * ability to solve it when resulting growth is less than threshold
// * ability to stop solve when resulting growth is greater than threshold
//
// A = diag(1, 1/growth)
// b = (1, 0.5)
   n = 2;
   growth = 10.0;
   ae_matrix_set_length(&ca, n, n);
   ca.xyC[0][0] = complex_from_i(1);
   ca.xyC[0][1] = complex_from_i(0);
   ca.xyC[1][0] = complex_from_i(0);
   ca.xyC[1][1] = complex_from_d(1 / growth);
   ae_vector_set_length(&cxs, n);
   cxs.xC[0] = complex_from_d(1.0);
   cxs.xC[1] = complex_from_d(0.5);
   cOk = cOk && cmatrixscaledtrsafesolve(&ca, 1.0, n, &cxs, randombool(), randominteger(3), false, 1.05 * rmax2(abscomplex(cxs.xC[1]) * growth, 1.0));
   cOk = cOk && cmatrixscaledtrsafesolve(&ca, 1.0, n, &cxs, randombool(), randominteger(3), false, 0.95 * rmax2(abscomplex(cxs.xC[1]) * growth, 1.0));
   ae_matrix_set_length(&ra, n, n);
   ra.xyR[0][0] = 1.0;
   ra.xyR[0][1] = 0.0;
   ra.xyR[1][0] = 0.0;
   ra.xyR[1][1] = 1 / growth;
   ae_vector_set_length(&rxs, n);
   rxs.xR[0] = 1.0;
   rxs.xR[1] = 0.5;
   rOk = rOk && rmatrixscaledtrsafesolve(&ra, 1.0, n, &rxs, randombool(), randominteger(2), false, 1.05 * rmax2(fabs(rxs.xR[1]) * growth, 1.0));
   rOk = rOk && rmatrixscaledtrsafesolve(&ra, 1.0, n, &rxs, randombool(), randominteger(2), false, 0.95 * rmax2(fabs(rxs.xR[1]) * growth, 1.0));
// Special test with diagonal degenerate matrix:
// * ability to solve it when resulting growth is less than threshold
// * ability to stop solve when resulting growth is greater than threshold
//
// A = diag(1, 0)
// b = (1, 0.5)
   n = 2;
   ae_matrix_set_length(&ca, n, n);
   ca.xyC[0][0] = complex_from_i(1);
   ca.xyC[0][1] = complex_from_i(0);
   ca.xyC[1][0] = complex_from_i(0);
   ca.xyC[1][1] = complex_from_i(0);
   ae_vector_set_length(&cxs, n);
   cxs.xC[0] = complex_from_d(1.0);
   cxs.xC[1] = complex_from_d(0.5);
   cOk = cOk && !cmatrixscaledtrsafesolve(&ca, 1.0, n, &cxs, randombool(), randominteger(3), false, sqrt(maxrealnumber));
   ae_matrix_set_length(&ra, n, n);
   ra.xyR[0][0] = 1.0;
   ra.xyR[0][1] = 0.0;
   ra.xyR[1][0] = 0.0;
   ra.xyR[1][1] = 0.0;
   ae_vector_set_length(&rxs, n);
   rxs.xR[0] = 1.0;
   rxs.xR[1] = 0.5;
   rOk = rOk && !rmatrixscaledtrsafesolve(&ra, 1.0, n, &rxs, randombool(), randominteger(2), false, sqrt(maxrealnumber));
// The final report.
   Ok = rOk && cOk;
   if (!Ok || !silent) {
      printf("Safe TR Solver Tests\n");
      printf("Real:                                     %s\n", rOk? "Ok": "Failed");
      printf("Complex:                                  %s\n", cOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === rcond testing unit ===
static const double testrcondunit_threshold50 = 0.25;
static const double testrcondunit_threshold90 = 0.10;

// Copy
static void testrcondunit_rmatrixmakeacopy(RMatrix *a, ae_int_t m, ae_int_t n, RMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyR[i][j] = a->xyR[i][j];
      }
   }
}

// Copy
static void testrcondunit_cmatrixmakeacopy(CMatrix *a, ae_int_t m, ae_int_t n, CMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyC[i][j] = a->xyC[i][j];
      }
   }
}

// Drops upper or lower half of the matrix - fills it by special pattern
// which may be used later to ensure that this part wasn't changed
static void testrcondunit_rmatrixdrophalf(RMatrix *a, ae_int_t n, bool droplower) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (droplower? i > j: i < j) {
            a->xyR[i][j] = (double)(1 + 2 * i + 3 * j);
         }
      }
   }
}

// Drops upper or lower half of the matrix - fills it by special pattern
// which may be used later to ensure that this part wasn't changed
static void testrcondunit_cmatrixdrophalf(CMatrix *a, ae_int_t n, bool droplower) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (droplower? i > j: i < j) {
            a->xyC[i][j] = complex_from_i(1 + 2 * i + 3 * j);
         }
      }
   }
}

// Generate matrix with given condition number C (2-norm)
static void testrcondunit_rmatrixgenzero(RMatrix *a0, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_matrix_set_length(a0, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a0->xyR[i][j] = 0.0;
      }
   }
}

// Generate matrix with given condition number C (2-norm)
static void testrcondunit_cmatrixgenzero(CMatrix *a0, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_matrix_set_length(a0, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a0->xyC[i][j] = complex_from_i(0);
      }
   }
}

// triangular inverse
static bool testrcondunit_rmatrixinvmattr(RMatrix *a, ae_int_t n, bool isupper, bool isunittriangular) {
   ae_frame _frame_block;
   bool nounit;
   ae_int_t i;
   ae_int_t j;
   double v;
   double ajj;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(t, 0, DT_REAL);
   Ok = true;
   ae_vector_set_length(&t, n);
// Test the input parameters.
   nounit = !isunittriangular;
   if (isupper) {
   // Compute inverse of upper triangular matrix.
      for (j = 0; j < n; j++) {
         if (nounit) {
            if (a->xyR[j][j] == 0.0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            a->xyR[j][j] = 1 / a->xyR[j][j];
            ajj = -a->xyR[j][j];
         } else {
            ajj = -1.0;
         }
      // Compute elements 1:j-1 of j-th column.
         if (j > 0) {
            ae_v_move(t.xR, 1, &a->xyR[0][j], a->stride, j);
            for (i = 0; i < j; i++) {
               if (i < j - 1) {
                  v = ae_v_dotproduct(&a->xyR[i][i + 1], 1, &t.xR[i + 1], 1, j - i - 1);
               } else {
                  v = 0.0;
               }
               if (nounit) {
                  a->xyR[i][j] = v + a->xyR[i][i] * t.xR[i];
               } else {
                  a->xyR[i][j] = v + t.xR[i];
               }
            }
            ae_v_muld(&a->xyR[0][j], a->stride, j, ajj);
         }
      }
   } else {
   // Compute inverse of lower triangular matrix.
      for (j = n - 1; j >= 0; j--) {
         if (nounit) {
            if (a->xyR[j][j] == 0.0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            a->xyR[j][j] = 1 / a->xyR[j][j];
            ajj = -a->xyR[j][j];
         } else {
            ajj = -1.0;
         }
         if (j < n - 1) {
         // Compute elements j+1:n of j-th column.
            ae_v_move(&t.xR[j + 1], 1, &a->xyR[j + 1][j], a->stride, n - j - 1);
            for (i = j + 1; i < n; i++) {
               if (i > j + 1) {
                  v = ae_v_dotproduct(&a->xyR[i][j + 1], 1, &t.xR[j + 1], 1, i - j - 1);
               } else {
                  v = 0.0;
               }
               if (nounit) {
                  a->xyR[i][j] = v + a->xyR[i][i] * t.xR[i];
               } else {
                  a->xyR[i][j] = v + t.xR[i];
               }
            }
            ae_v_muld(&a->xyR[j + 1][j], a->stride, n - j - 1, ajj);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// triangular inverse
static bool testrcondunit_cmatrixinvmattr(CMatrix *a, ae_int_t n, bool isupper, bool isunittriangular) {
   ae_frame _frame_block;
   bool nounit;
   ae_int_t i;
   ae_int_t j;
   complex v;
   complex ajj;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(t, 0, DT_COMPLEX);
   Ok = true;
   ae_vector_set_length(&t, n);
// Test the input parameters.
   nounit = !isunittriangular;
   if (isupper) {
   // Compute inverse of upper triangular matrix.
      for (j = 0; j < n; j++) {
         if (nounit) {
            if (ae_c_eq_d(a->xyC[j][j], 0.0)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            a->xyC[j][j] = ae_c_d_div(1, a->xyC[j][j]);
            ajj = ae_c_neg(a->xyC[j][j]);
         } else {
            ajj = complex_from_i(-1);
         }
      // Compute elements 1:j-1 of j-th column.
         if (j > 0) {
            ae_v_cmove(t.xC, 1, &a->xyC[0][j], a->stride, "N", j);
            for (i = 0; i < j; i++) {
               if (i < j - 1) {
                  v = ae_v_cdotproduct(&a->xyC[i][i + 1], 1, "N", &t.xC[i + 1], 1, "N", j - i - 1);
               } else {
                  v = complex_from_i(0);
               }
               if (nounit) {
                  a->xyC[i][j] = ae_c_add(v, ae_c_mul(a->xyC[i][i], t.xC[i]));
               } else {
                  a->xyC[i][j] = ae_c_add(v, t.xC[i]);
               }
            }
            ae_v_cmulc(&a->xyC[0][j], a->stride, j, ajj);
         }
      }
   } else {
   // Compute inverse of lower triangular matrix.
      for (j = n - 1; j >= 0; j--) {
         if (nounit) {
            if (ae_c_eq_d(a->xyC[j][j], 0.0)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            a->xyC[j][j] = ae_c_d_div(1, a->xyC[j][j]);
            ajj = ae_c_neg(a->xyC[j][j]);
         } else {
            ajj = complex_from_i(-1);
         }
         if (j < n - 1) {
         // Compute elements j+1:n of j-th column.
            ae_v_cmove(&t.xC[j + 1], 1, &a->xyC[j + 1][j], a->stride, "N", n - j - 1);
            for (i = j + 1; i < n; i++) {
               if (i > j + 1) {
                  v = ae_v_cdotproduct(&a->xyC[i][j + 1], 1, "N", &t.xC[j + 1], 1, "N", i - j - 1);
               } else {
                  v = complex_from_i(0);
               }
               if (nounit) {
                  a->xyC[i][j] = ae_c_add(v, ae_c_mul(a->xyC[i][i], t.xC[i]));
               } else {
                  a->xyC[i][j] = ae_c_add(v, t.xC[i]);
               }
            }
            ae_v_cmulc(&a->xyC[j + 1][j], a->stride, n - j - 1, ajj);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// LU inverse
static bool testrcondunit_rmatrixinvmatlu(RMatrix *a, ZVector *pivots, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t jp;
   double v;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(work, 0, DT_REAL);
   Ok = true;
// Quick return if possible
   if (n == 0) {
      ae_frame_leave();
      return Ok;
   }
   ae_vector_set_length(&work, n);
// Form inv(U)
   if (!testrcondunit_rmatrixinvmattr(a, n, true, false)) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
// Solve the equation inv(A)*L = inv(U) for inv(A).
   for (j = n - 1; j >= 0; j--) {
   // Copy current column of L to WORK and replace with zeros.
      for (i = j + 1; i < n; i++) {
         work.xR[i] = a->xyR[i][j];
         a->xyR[i][j] = 0.0;
      }
   // Compute current column of inv(A).
      if (j < n - 1) {
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(&a->xyR[i][j + 1], 1, &work.xR[j + 1], 1, n - j - 1);
            a->xyR[i][j] -= v;
         }
      }
   }
// Apply column interchanges.
   for (j = n - 2; j >= 0; j--) {
      jp = pivots->xZ[j];
      if (jp != j) {
         ae_v_move(work.xR, 1, &a->xyR[0][j], a->stride, n);
         ae_v_move(&a->xyR[0][j], a->stride, &a->xyR[0][jp], a->stride, n);
         ae_v_move(&a->xyR[0][jp], a->stride, work.xR, 1, n);
      }
   }
   ae_frame_leave();
   return Ok;
}

// LU inverse
static bool testrcondunit_cmatrixinvmatlu(CMatrix *a, ZVector *pivots, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t jp;
   complex v;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(work, 0, DT_COMPLEX);
   Ok = true;
// Quick return if possible
   if (n == 0) {
      ae_frame_leave();
      return Ok;
   }
   ae_vector_set_length(&work, n);
// Form inv(U)
   if (!testrcondunit_cmatrixinvmattr(a, n, true, false)) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
// Solve the equation inv(A)*L = inv(U) for inv(A).
   for (j = n - 1; j >= 0; j--) {
   // Copy current column of L to WORK and replace with zeros.
      for (i = j + 1; i < n; i++) {
         work.xC[i] = a->xyC[i][j];
         a->xyC[i][j] = complex_from_i(0);
      }
   // Compute current column of inv(A).
      if (j < n - 1) {
         for (i = 0; i < n; i++) {
            v = ae_v_cdotproduct(&a->xyC[i][j + 1], 1, "N", &work.xC[j + 1], 1, "N", n - j - 1);
            a->xyC[i][j] = ae_c_sub(a->xyC[i][j], v);
         }
      }
   }
// Apply column interchanges.
   for (j = n - 2; j >= 0; j--) {
      jp = pivots->xZ[j];
      if (jp != j) {
         ae_v_cmove(work.xC, 1, &a->xyC[0][j], a->stride, "N", n);
         ae_v_cmove(&a->xyC[0][j], a->stride, &a->xyC[0][jp], a->stride, "N", n);
         ae_v_cmove(&a->xyC[0][jp], a->stride, work.xC, 1, "N", n);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Matrix inverse
static bool testrcondunit_rmatrixinvmat(RMatrix *a, ae_int_t n) {
   ae_frame _frame_block;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(pivots, 0, DT_INT);
   rmatrixlu(a, n, n, &pivots);
   Ok = testrcondunit_rmatrixinvmatlu(a, &pivots, n);
   ae_frame_leave();
   return Ok;
}

// Matrix inverse
static bool testrcondunit_cmatrixinvmat(CMatrix *a, ae_int_t n) {
   ae_frame _frame_block;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(pivots, 0, DT_INT);
   cmatrixlu(a, n, n, &pivots);
   Ok = testrcondunit_cmatrixinvmatlu(a, &pivots, n);
   ae_frame_leave();
   return Ok;
}

// reference RCond
static void testrcondunit_rmatrixrefrcond(RMatrix *a, ae_int_t n, double *rc1, double *rcinf) {
   ae_frame _frame_block;
   double nrm1a;
   double nrminfa;
   double nrm1inva;
   double nrminfinva;
   double v;
   ae_int_t k;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   *rc1 = 0;
   *rcinf = 0;
   NewMatrix(inva, 0, 0, DT_REAL);
// inv A
   testrcondunit_rmatrixmakeacopy(a, n, n, &inva);
   if (!testrcondunit_rmatrixinvmat(&inva, n)) {
      *rc1 = 0.0;
      *rcinf = 0.0;
      ae_frame_leave();
      return;
   }
// norm A
   nrm1a = 0.0;
   nrminfa = 0.0;
   for (k = 0; k < n; k++) {
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += fabs(a->xyR[i][k]);
      }
      nrm1a = rmax2(nrm1a, v);
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += fabs(a->xyR[k][i]);
      }
      nrminfa = rmax2(nrminfa, v);
   }
// norm inv A
   nrm1inva = 0.0;
   nrminfinva = 0.0;
   for (k = 0; k < n; k++) {
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += fabs(inva.xyR[i][k]);
      }
      nrm1inva = rmax2(nrm1inva, v);
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += fabs(inva.xyR[k][i]);
      }
      nrminfinva = rmax2(nrminfinva, v);
   }
// result
   *rc1 = nrm1inva * nrm1a;
   *rcinf = nrminfinva * nrminfa;
   ae_frame_leave();
}

// reference RCond
static void testrcondunit_cmatrixrefrcond(CMatrix *a, ae_int_t n, double *rc1, double *rcinf) {
   ae_frame _frame_block;
   double nrm1a;
   double nrminfa;
   double nrm1inva;
   double nrminfinva;
   double v;
   ae_int_t k;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   *rc1 = 0;
   *rcinf = 0;
   NewMatrix(inva, 0, 0, DT_COMPLEX);
// inv A
   testrcondunit_cmatrixmakeacopy(a, n, n, &inva);
   if (!testrcondunit_cmatrixinvmat(&inva, n)) {
      *rc1 = 0.0;
      *rcinf = 0.0;
      ae_frame_leave();
      return;
   }
// norm A
   nrm1a = 0.0;
   nrminfa = 0.0;
   for (k = 0; k < n; k++) {
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += abscomplex(a->xyC[i][k]);
      }
      nrm1a = rmax2(nrm1a, v);
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += abscomplex(a->xyC[k][i]);
      }
      nrminfa = rmax2(nrminfa, v);
   }
// norm inv A
   nrm1inva = 0.0;
   nrminfinva = 0.0;
   for (k = 0; k < n; k++) {
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += abscomplex(inva.xyC[i][k]);
      }
      nrm1inva = rmax2(nrm1inva, v);
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += abscomplex(inva.xyC[k][i]);
      }
      nrminfinva = rmax2(nrminfinva, v);
   }
// result
   *rc1 = nrm1inva * nrm1a;
   *rcinf = nrminfinva * nrminfa;
   ae_frame_leave();
}

// Returns True for successful test, False - for failed test
static bool testrcondunit_testrmatrixtrrcond(ae_int_t maxn, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t j1;
   ae_int_t j2;
   ae_int_t pass;
   bool err50;
   bool err90;
   bool errspec;
   bool errless;
   double erc1;
   double ercinf;
   double v;
   bool isupper;
   bool isunit;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ea, 0, 0, DT_REAL);
   NewVector(p, 0, DT_INT);
   NewVector(q50, 0, DT_REAL);
   NewVector(q90, 0, DT_REAL);
   err50 = false;
   err90 = false;
   errless = false;
   errspec = false;
   ae_vector_set_length(&q50, 2);
   ae_vector_set_length(&q90, 2);
   for (n = 1; n <= maxn; n++) {
   // special test for zero matrix
      testrcondunit_rmatrixgenzero(&a, n);
      errspec = errspec || rmatrixtrrcond1(&a, n, randombool(), false) != 0.0;
      errspec = errspec || rmatrixtrrcondinf(&a, n, randombool(), false) != 0.0;
   // general test
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i <= 1; i++) {
         q50.xR[i] = 0.0;
         q90.xR[i] = 0.0;
      }
      for (pass = 1; pass <= passcount; pass++) {
         isupper = randombool();
         isunit = randombool();
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = randomreal() - 0.5;
            }
         }
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 1 + randomreal();
         }
         testrcondunit_rmatrixmakeacopy(&a, n, n, &ea);
         for (i = 0; i < n; i++) {
            if (isupper) {
               j1 = 0;
               j2 = i - 1;
            } else {
               j1 = i + 1;
               j2 = n - 1;
            }
            for (j = j1; j <= j2; j++) {
               ea.xyR[i][j] = 0.0;
            }
            if (isunit) {
               ea.xyR[i][i] = 1.0;
            }
         }
         testrcondunit_rmatrixrefrcond(&ea, n, &erc1, &ercinf);
      // 1-norm
         v = 1 / rmatrixtrrcond1(&a, n, isupper, isunit);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[0] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[0] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // Inf-norm
         v = 1 / rmatrixtrrcondinf(&a, n, isupper, isunit);
         if (v >= testrcondunit_threshold50 * ercinf) {
            q50.xR[1] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * ercinf) {
            q90.xR[1] += 1.0 / passcount;
         }
         errless = errless || v > ercinf * 1.001;
      }
      for (i = 0; i <= 1; i++) {
         err50 = err50 || q50.xR[i] < 0.50;
         err90 = err90 || q90.xR[i] < 0.90;
      }
   // degenerate matrix test
      if (n >= 3) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         a.xyR[0][0] = 1.0;
         a.xyR[n - 1][n - 1] = 1.0;
         errspec = errspec || rmatrixtrrcond1(&a, n, randombool(), false) != 0.0;
         errspec = errspec || rmatrixtrrcondinf(&a, n, randombool(), false) != 0.0;
      }
   // near-degenerate matrix test
      if (n >= 2) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 1.0;
         }
         i = randominteger(n);
         a.xyR[i][i] = 0.1 * maxrealnumber;
         errspec = errspec || rmatrixtrrcond1(&a, n, randombool(), false) != 0.0;
         errspec = errspec || rmatrixtrrcondinf(&a, n, randombool(), false) != 0.0;
      }
   }
// report
   Ok = !(err50 || err90 || errless || errspec);
   ae_frame_leave();
   return Ok;
}

// Returns True for successful test, False - for failed test
static bool testrcondunit_testcmatrixtrrcond(ae_int_t maxn, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t j1;
   ae_int_t j2;
   ae_int_t pass;
   bool err50;
   bool err90;
   bool errspec;
   bool errless;
   double erc1;
   double ercinf;
   double v;
   bool isupper;
   bool isunit;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(ea, 0, 0, DT_COMPLEX);
   NewVector(p, 0, DT_INT);
   NewVector(q50, 0, DT_REAL);
   NewVector(q90, 0, DT_REAL);
   err50 = false;
   err90 = false;
   errless = false;
   errspec = false;
   ae_vector_set_length(&q50, 2);
   ae_vector_set_length(&q90, 2);
   for (n = 1; n <= maxn; n++) {
   // special test for zero matrix
      testrcondunit_cmatrixgenzero(&a, n);
      errspec = errspec || cmatrixtrrcond1(&a, n, randombool(), false) != 0.0;
      errspec = errspec || cmatrixtrrcondinf(&a, n, randombool(), false) != 0.0;
   // general test
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i <= 1; i++) {
         q50.xR[i] = 0.0;
         q90.xR[i] = 0.0;
      }
      for (pass = 1; pass <= passcount; pass++) {
         isupper = randombool();
         isunit = randombool();
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyC[i][j] = complex_from_d(randomreal() - 0.5, randomreal() - 0.5);
            }
         }
         for (i = 0; i < n; i++) {
            a.xyC[i][i] = complex_from_d(1 + randomreal(), 1 + randomreal());
         }
         testrcondunit_cmatrixmakeacopy(&a, n, n, &ea);
         for (i = 0; i < n; i++) {
            if (isupper) {
               j1 = 0;
               j2 = i - 1;
            } else {
               j1 = i + 1;
               j2 = n - 1;
            }
            for (j = j1; j <= j2; j++) {
               ea.xyC[i][j] = complex_from_i(0);
            }
            if (isunit) {
               ea.xyC[i][i] = complex_from_i(1);
            }
         }
         testrcondunit_cmatrixrefrcond(&ea, n, &erc1, &ercinf);
      // 1-norm
         v = 1 / cmatrixtrrcond1(&a, n, isupper, isunit);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[0] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[0] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // Inf-norm
         v = 1 / cmatrixtrrcondinf(&a, n, isupper, isunit);
         if (v >= testrcondunit_threshold50 * ercinf) {
            q50.xR[1] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * ercinf) {
            q90.xR[1] += 1.0 / passcount;
         }
         errless = errless || v > ercinf * 1.001;
      }
      for (i = 0; i <= 1; i++) {
         err50 = err50 || q50.xR[i] < 0.50;
         err90 = err90 || q90.xR[i] < 0.90;
      }
   // degenerate matrix test
      if (n >= 3) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyC[i][j] = complex_from_d(0.0);
            }
         }
         a.xyC[0][0] = complex_from_i(1);
         a.xyC[n - 1][n - 1] = complex_from_i(1);
         errspec = errspec || cmatrixtrrcond1(&a, n, randombool(), false) != 0.0;
         errspec = errspec || cmatrixtrrcondinf(&a, n, randombool(), false) != 0.0;
      }
   // near-degenerate matrix test
      if (n >= 2) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyC[i][j] = complex_from_d(0.0);
            }
         }
         for (i = 0; i < n; i++) {
            a.xyC[i][i] = complex_from_i(1);
         }
         i = randominteger(n);
         a.xyC[i][i] = complex_from_d(0.1 * maxrealnumber);
         errspec = errspec || cmatrixtrrcond1(&a, n, randombool(), false) != 0.0;
         errspec = errspec || cmatrixtrrcondinf(&a, n, randombool(), false) != 0.0;
      }
   }
// report
   Ok = !(err50 || err90 || errless || errspec);
   ae_frame_leave();
   return Ok;
}

// Returns True for successful test, False - for failed test
static bool testrcondunit_testrmatrixrcond(ae_int_t maxn, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   bool err50;
   bool err90;
   bool errspec;
   bool errless;
   double erc1;
   double ercinf;
   double v;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(lua, 0, 0, DT_REAL);
   NewVector(p, 0, DT_INT);
   NewVector(q50, 0, DT_REAL);
   NewVector(q90, 0, DT_REAL);
   err50 = false;
   err90 = false;
   errless = false;
   errspec = false;
   ae_vector_set_length(&q50, 3 + 1);
   ae_vector_set_length(&q90, 3 + 1);
   for (n = 1; n <= maxn; n++) {
   // special test for zero matrix
      testrcondunit_rmatrixgenzero(&a, n);
      testrcondunit_rmatrixmakeacopy(&a, n, n, &lua);
      rmatrixlu(&lua, n, n, &p);
      errspec = errspec || rmatrixrcond1(&a, n) != 0.0;
      errspec = errspec || rmatrixrcondinf(&a, n) != 0.0;
      errspec = errspec || rmatrixlurcond1(&lua, n) != 0.0;
      errspec = errspec || rmatrixlurcondinf(&lua, n) != 0.0;
   // general test
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i <= 3; i++) {
         q50.xR[i] = 0.0;
         q90.xR[i] = 0.0;
      }
      for (pass = 1; pass <= passcount; pass++) {
         rmatrixrndcond(n, exp(randomreal() * log(1000.0)), &a);
         testrcondunit_rmatrixmakeacopy(&a, n, n, &lua);
         rmatrixlu(&lua, n, n, &p);
         testrcondunit_rmatrixrefrcond(&a, n, &erc1, &ercinf);
      // 1-norm, normal
         v = 1 / rmatrixrcond1(&a, n);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[0] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[0] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // 1-norm, LU
         v = 1 / rmatrixlurcond1(&lua, n);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[1] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[1] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // Inf-norm, normal
         v = 1 / rmatrixrcondinf(&a, n);
         if (v >= testrcondunit_threshold50 * ercinf) {
            q50.xR[2] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * ercinf) {
            q90.xR[2] += 1.0 / passcount;
         }
         errless = errless || v > ercinf * 1.001;
      // Inf-norm, LU
         v = 1 / rmatrixlurcondinf(&lua, n);
         if (v >= testrcondunit_threshold50 * ercinf) {
            q50.xR[3] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * ercinf) {
            q90.xR[3] += 1.0 / passcount;
         }
         errless = errless || v > ercinf * 1.001;
      }
      for (i = 0; i <= 3; i++) {
         err50 = err50 || q50.xR[i] < 0.50;
         err90 = err90 || q90.xR[i] < 0.90;
      }
   // degenerate matrix test
      if (n >= 3) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         a.xyR[0][0] = 1.0;
         a.xyR[n - 1][n - 1] = 1.0;
         errspec = errspec || rmatrixrcond1(&a, n) != 0.0;
         errspec = errspec || rmatrixrcondinf(&a, n) != 0.0;
         errspec = errspec || rmatrixlurcond1(&a, n) != 0.0;
         errspec = errspec || rmatrixlurcondinf(&a, n) != 0.0;
      }
   // near-degenerate matrix test
      if (n >= 2) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 1.0;
         }
         i = randominteger(n);
         a.xyR[i][i] = 0.1 * maxrealnumber;
         errspec = errspec || rmatrixrcond1(&a, n) != 0.0;
         errspec = errspec || rmatrixrcondinf(&a, n) != 0.0;
         errspec = errspec || rmatrixlurcond1(&a, n) != 0.0;
         errspec = errspec || rmatrixlurcondinf(&a, n) != 0.0;
      }
   }
// report
   Ok = !(err50 || err90 || errless || errspec);
   ae_frame_leave();
   return Ok;
}

// Returns True for successful test, False - for failed test
static bool testrcondunit_testcmatrixrcond(ae_int_t maxn, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   bool err50;
   bool err90;
   bool errless;
   bool errspec;
   double erc1;
   double ercinf;
   double v;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(lua, 0, 0, DT_COMPLEX);
   NewVector(p, 0, DT_INT);
   NewVector(q50, 0, DT_REAL);
   NewVector(q90, 0, DT_REAL);
   ae_vector_set_length(&q50, 3 + 1);
   ae_vector_set_length(&q90, 3 + 1);
   err50 = false;
   err90 = false;
   errless = false;
   errspec = false;
// process
   for (n = 1; n <= maxn; n++) {
   // special test for zero matrix
      testrcondunit_cmatrixgenzero(&a, n);
      testrcondunit_cmatrixmakeacopy(&a, n, n, &lua);
      cmatrixlu(&lua, n, n, &p);
      errspec = errspec || cmatrixrcond1(&a, n) != 0.0;
      errspec = errspec || cmatrixrcondinf(&a, n) != 0.0;
      errspec = errspec || cmatrixlurcond1(&lua, n) != 0.0;
      errspec = errspec || cmatrixlurcondinf(&lua, n) != 0.0;
   // general test
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i <= 3; i++) {
         q50.xR[i] = 0.0;
         q90.xR[i] = 0.0;
      }
      for (pass = 1; pass <= passcount; pass++) {
         cmatrixrndcond(n, exp(randomreal() * log(1000.0)), &a);
         testrcondunit_cmatrixmakeacopy(&a, n, n, &lua);
         cmatrixlu(&lua, n, n, &p);
         testrcondunit_cmatrixrefrcond(&a, n, &erc1, &ercinf);
      // 1-norm, normal
         v = 1 / cmatrixrcond1(&a, n);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[0] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[0] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // 1-norm, LU
         v = 1 / cmatrixlurcond1(&lua, n);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[1] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[1] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // Inf-norm, normal
         v = 1 / cmatrixrcondinf(&a, n);
         if (v >= testrcondunit_threshold50 * ercinf) {
            q50.xR[2] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * ercinf) {
            q90.xR[2] += 1.0 / passcount;
         }
         errless = errless || v > ercinf * 1.001;
      // Inf-norm, LU
         v = 1 / cmatrixlurcondinf(&lua, n);
         if (v >= testrcondunit_threshold50 * ercinf) {
            q50.xR[3] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * ercinf) {
            q90.xR[3] += 1.0 / passcount;
         }
         errless = errless || v > ercinf * 1.001;
      }
      for (i = 0; i <= 3; i++) {
         err50 = err50 || q50.xR[i] < 0.50;
         err90 = err90 || q90.xR[i] < 0.90;
      }
   // degenerate matrix test
      if (n >= 3) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyC[i][j] = complex_from_d(0.0);
            }
         }
         a.xyC[0][0] = complex_from_i(1);
         a.xyC[n - 1][n - 1] = complex_from_i(1);
         errspec = errspec || cmatrixrcond1(&a, n) != 0.0;
         errspec = errspec || cmatrixrcondinf(&a, n) != 0.0;
         errspec = errspec || cmatrixlurcond1(&a, n) != 0.0;
         errspec = errspec || cmatrixlurcondinf(&a, n) != 0.0;
      }
   // near-degenerate matrix test
      if (n >= 2) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyC[i][j] = complex_from_d(0.0);
            }
         }
         for (i = 0; i < n; i++) {
            a.xyC[i][i] = complex_from_i(1);
         }
         i = randominteger(n);
         a.xyC[i][i] = complex_from_d(0.1 * maxrealnumber);
         errspec = errspec || cmatrixrcond1(&a, n) != 0.0;
         errspec = errspec || cmatrixrcondinf(&a, n) != 0.0;
         errspec = errspec || cmatrixlurcond1(&a, n) != 0.0;
         errspec = errspec || cmatrixlurcondinf(&a, n) != 0.0;
      }
   }
// report
   Ok = !(err50 || err90 || errless || errspec);
   ae_frame_leave();
   return Ok;
}

// Returns True for successful test, False - for failed test
static bool testrcondunit_testspdmatrixrcond(ae_int_t maxn, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   bool err50;
   bool err90;
   bool errspec;
   bool errless;
   bool isupper;
   double erc1;
   double ercinf;
   double v;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(cha, 0, 0, DT_REAL);
   NewVector(p, 0, DT_INT);
   NewVector(q50, 0, DT_REAL);
   NewVector(q90, 0, DT_REAL);
   err50 = false;
   err90 = false;
   errless = false;
   errspec = false;
   ae_vector_set_length(&q50, 2);
   ae_vector_set_length(&q90, 2);
   for (n = 1; n <= maxn; n++) {
      isupper = randombool();
   // general test
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i <= 1; i++) {
         q50.xR[i] = 0.0;
         q90.xR[i] = 0.0;
      }
      for (pass = 1; pass <= passcount; pass++) {
         spdmatrixrndcond(n, exp(randomreal() * log(1000.0)), &a);
         testrcondunit_rmatrixrefrcond(&a, n, &erc1, &ercinf);
         testrcondunit_rmatrixdrophalf(&a, n, isupper);
         testrcondunit_rmatrixmakeacopy(&a, n, n, &cha);
         spdmatrixcholesky(&cha, n, isupper);
      // normal
         v = 1 / spdmatrixrcond(&a, n, isupper);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[0] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[0] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // Cholesky
         v = 1 / spdmatrixcholeskyrcond(&cha, n, isupper);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[1] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[1] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      }
      for (i = 0; i <= 1; i++) {
         err50 = err50 || q50.xR[i] < 0.50;
         err90 = err90 || q90.xR[i] < 0.90;
      }
   // degenerate matrix test
      if (n >= 3) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         a.xyR[0][0] = 1.0;
         a.xyR[n - 1][n - 1] = 1.0;
         errspec = errspec || spdmatrixrcond(&a, n, isupper) != -1.0;
         errspec = errspec || spdmatrixcholeskyrcond(&a, n, isupper) != 0.0;
      }
   // near-degenerate matrix test
      if (n >= 2) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 1.0;
         }
         i = randominteger(n);
         a.xyR[i][i] = 0.1 * maxrealnumber;
         errspec = errspec || spdmatrixrcond(&a, n, isupper) != 0.0;
         errspec = errspec || spdmatrixcholeskyrcond(&a, n, isupper) != 0.0;
      }
   }
// report
   Ok = !(err50 || err90 || errless || errspec);
   ae_frame_leave();
   return Ok;
}

// Returns True for successful test, False - for failed test
static bool testrcondunit_testhpdmatrixrcond(ae_int_t maxn, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   bool err50;
   bool err90;
   bool errspec;
   bool errless;
   bool isupper;
   double erc1;
   double ercinf;
   double v;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(cha, 0, 0, DT_COMPLEX);
   NewVector(p, 0, DT_INT);
   NewVector(q50, 0, DT_REAL);
   NewVector(q90, 0, DT_REAL);
   err50 = false;
   err90 = false;
   errless = false;
   errspec = false;
   ae_vector_set_length(&q50, 2);
   ae_vector_set_length(&q90, 2);
   for (n = 1; n <= maxn; n++) {
      isupper = randombool();
   // general test
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i <= 1; i++) {
         q50.xR[i] = 0.0;
         q90.xR[i] = 0.0;
      }
      for (pass = 1; pass <= passcount; pass++) {
         hpdmatrixrndcond(n, exp(randomreal() * log(1000.0)), &a);
         testrcondunit_cmatrixrefrcond(&a, n, &erc1, &ercinf);
         testrcondunit_cmatrixdrophalf(&a, n, isupper);
         testrcondunit_cmatrixmakeacopy(&a, n, n, &cha);
         hpdmatrixcholesky(&cha, n, isupper);
      // normal
         v = 1 / hpdmatrixrcond(&a, n, isupper);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[0] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[0] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // Cholesky
         v = 1 / hpdmatrixcholeskyrcond(&cha, n, isupper);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[1] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[1] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      }
      for (i = 0; i <= 1; i++) {
         err50 = err50 || q50.xR[i] < 0.50;
         err90 = err90 || q90.xR[i] < 0.90;
      }
   // degenerate matrix test
      if (n >= 3) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyC[i][j] = complex_from_d(0.0);
            }
         }
         a.xyC[0][0] = complex_from_i(1);
         a.xyC[n - 1][n - 1] = complex_from_i(1);
         errspec = errspec || hpdmatrixrcond(&a, n, isupper) != -1.0;
         errspec = errspec || hpdmatrixcholeskyrcond(&a, n, isupper) != 0.0;
      }
   // near-degenerate matrix test
      if (n >= 2) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyC[i][j] = complex_from_d(0.0);
            }
         }
         for (i = 0; i < n; i++) {
            a.xyC[i][i] = complex_from_i(1);
         }
         i = randominteger(n);
         a.xyC[i][i] = complex_from_d(0.1 * maxrealnumber);
         errspec = errspec || hpdmatrixrcond(&a, n, isupper) != 0.0;
         errspec = errspec || hpdmatrixcholeskyrcond(&a, n, isupper) != 0.0;
      }
   }
// report
   Ok = !(err50 || err90 || errless || errspec);
   ae_frame_leave();
   return Ok;
}

bool testrcond() {
   ae_int_t maxn;
   ae_int_t passcount;
   bool Ok;
   bool rtrOk;
   bool ctrOk;
   bool rOk;
   bool cOk;
   bool spdOk;
   bool hpdOk;
   maxn = 10;
   passcount = 100;
// report
   rtrOk = testrcondunit_testrmatrixtrrcond(maxn, passcount);
   ctrOk = testrcondunit_testcmatrixtrrcond(maxn, passcount);
   rOk = testrcondunit_testrmatrixrcond(maxn, passcount);
   cOk = testrcondunit_testcmatrixrcond(maxn, passcount);
   spdOk = testrcondunit_testspdmatrixrcond(maxn, passcount);
   hpdOk = testrcondunit_testhpdmatrixrcond(maxn, passcount);
// The final report.
   Ok = rtrOk && ctrOk && rOk && cOk && spdOk && hpdOk;
   if (!Ok || !silent) {
      printf("RCond Tests\n");
      printf("Real Triangular:                          %s\n", rtrOk? "Ok": "Failed");
      printf("Complex Triangular:                       %s\n", ctrOk? "Ok": "Failed");
      printf("Real:                                     %s\n", rOk? "Ok": "Failed");
      printf("SPD:                                      %s\n", spdOk? "Ok": "Failed");
      printf("HPD:                                      %s\n", hpdOk? "Ok": "Failed");
      printf("Complex:                                  %s\n", cOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === xblas testing unit ===
bool testxblas() {
   ae_frame _frame_block;
   bool approxOk;
   bool exactnessOk;
   bool Ok;
   double approxthreshold;
   ae_int_t maxn;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t i;
   ae_int_t pass;
   double rv1;
   double rv2;
   double rv2err;
   complex cv1;
   complex cv2;
   double cv2err;
   double s;
   ae_frame_make(&_frame_block);
   NewVector(rx, 0, DT_REAL);
   NewVector(ry, 0, DT_REAL);
   NewVector(cx, 0, DT_COMPLEX);
   NewVector(cy, 0, DT_COMPLEX);
   NewVector(temp, 0, DT_REAL);
   approxOk = true;
   exactnessOk = true;
   Ok = true;
   approxthreshold = 1000.0 * machineepsilon;
   maxn = 1000;
   passcount = 10;
// tests:
// 1. ability to calculate dot product
// 2. higher precision
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
      // ability to approximately calculate real dot product
         ae_vector_set_length(&rx, n);
         ae_vector_set_length(&ry, n);
         ae_vector_set_length(&temp, n);
         for (i = 0; i < n; i++) {
            if (randombool(0.2)) {
               rx.xR[i] = 0.0;
            } else {
               rx.xR[i] = randommid();
            }
            if (randombool(0.2)) {
               ry.xR[i] = 0.0;
            } else {
               ry.xR[i] = randommid();
            }
         }
         rv1 = ae_v_dotproduct(rx.xR, 1, ry.xR, 1, n);
         xdot(&rx, &ry, n, &temp, &rv2, &rv2err);
         approxOk = approxOk && NearAtR(rv1, rv2, approxthreshold);
      // ability to approximately calculate complex dot product
         ae_vector_set_length(&cx, n);
         ae_vector_set_length(&cy, n);
         ae_vector_set_length(&temp, 2 * n);
         for (i = 0; i < n; i++) {
            if (randombool(0.2)) {
               cx.xC[i] = complex_from_i(0);
            } else {
               cx.xC[i] = complex_from_d(randommid(), randommid());
            }
            if (randombool(0.2)) {
               cy.xC[i] = complex_from_i(0);
            } else {
               cy.xC[i] = complex_from_d(randommid(), randommid());
            }
         }
         cv1 = ae_v_cdotproduct(cx.xC, 1, "N", cy.xC, 1, "N", n);
         xcdot(&cx, &cy, n, &temp, &cv2, &cv2err);
         approxOk = approxOk && NearAtC(cv1, cv2, approxthreshold);
      }
   }
// test of precision: real
   n = 50000;
   ae_vector_set_length(&rx, n);
   ae_vector_set_length(&ry, n);
   ae_vector_set_length(&temp, n);
   for (pass = 0; pass < passcount; pass++) {
      ae_assert(n % 2 == 0, "Assertion failed");
   // First test: X + X + ... + X - X - X - ... - X = 1*X
      s = exp((double)imax2(pass, 50));
      if (pass == passcount - 1 && pass > 1) {
         s = maxrealnumber;
      }
      ry.xR[0] = randommid() * s * sqrt(2 * randomreal());
      for (i = 1; i < n; i++) {
         ry.xR[i] = ry.xR[0];
      }
      for (i = 0; i < n / 2; i++) {
         rx.xR[i] = 1.0;
      }
      for (i = n / 2; i < n - 1; i++) {
         rx.xR[i] = -1.0;
      }
      rx.xR[n - 1] = 0.0;
      xdot(&rx, &ry, n, &temp, &rv2, &rv2err);
      exactnessOk = exactnessOk && rv2err >= 0.0;
      exactnessOk = exactnessOk && rv2err <= 4 * machineepsilon * fabs(ry.xR[0]);
      exactnessOk = exactnessOk && NearAtR(rv2, ry.xR[0], rv2err);
   // First test: X + X + ... + X = N*X
      s = exp((double)imax2(pass, 50));
      if (pass == passcount - 1 && pass > 1) {
         s = maxrealnumber;
      }
      ry.xR[0] = randommid() * s * sqrt(2 * randomreal());
      for (i = 1; i < n; i++) {
         ry.xR[i] = ry.xR[0];
      }
      for (i = 0; i < n; i++) {
         rx.xR[i] = 1.0;
      }
      xdot(&rx, &ry, n, &temp, &rv2, &rv2err);
      exactnessOk = exactnessOk && rv2err >= 0.0;
      exactnessOk = exactnessOk && rv2err <= 4 * machineepsilon * fabs(ry.xR[0]) * n;
      exactnessOk = exactnessOk && NearAtR(rv2, n * ry.xR[0], rv2err);
   }
// test of precision: complex
   n = 50000;
   ae_vector_set_length(&cx, n);
   ae_vector_set_length(&cy, n);
   ae_vector_set_length(&temp, 2 * n);
   for (pass = 0; pass < passcount; pass++) {
      ae_assert(n % 2 == 0, "Assertion failed");
   // First test: X + X + ... + X - X - X - ... - X = 1*X
      s = exp((double)imax2(pass, 50));
      if (pass == passcount - 1 && pass > 1) {
         s = maxrealnumber;
      }
      cy.xC[0] = complex_from_d(randommid() * s * sqrt(2 * randomreal()), randommid() * s * sqrt(2 * randomreal()));
      for (i = 1; i < n; i++) {
         cy.xC[i] = cy.xC[0];
      }
      for (i = 0; i < n / 2; i++) {
         cx.xC[i] = complex_from_i(1);
      }
      for (i = n / 2; i < n - 1; i++) {
         cx.xC[i] = complex_from_i(-1);
      }
      cx.xC[n - 1] = complex_from_i(0);
      xcdot(&cx, &cy, n, &temp, &cv2, &cv2err);
      exactnessOk = exactnessOk && cv2err >= 0.0;
      exactnessOk = exactnessOk && cv2err <= 4 * machineepsilon * abscomplex(cy.xC[0]);
      exactnessOk = exactnessOk && NearAtC(cv2, cy.xC[0], cv2err);
   // First test: X + X + ... + X = N*X
      s = exp((double)imax2(pass, 50));
      if (pass == passcount - 1 && pass > 1) {
         s = maxrealnumber;
      }
      cy.xC[0] = complex_from_d(randommid() * s * sqrt(2 * randomreal()));
      for (i = 1; i < n; i++) {
         cy.xC[i] = cy.xC[0];
      }
      for (i = 0; i < n; i++) {
         cx.xC[i] = complex_from_i(1);
      }
      xcdot(&cx, &cy, n, &temp, &cv2, &cv2err);
      exactnessOk = exactnessOk && cv2err >= 0.0;
      exactnessOk = exactnessOk && cv2err <= 4 * machineepsilon * abscomplex(cy.xC[0]) * n;
      exactnessOk = exactnessOk && NearAtC(cv2, ae_c_mul_d(cy.xC[0], 1.0 * n), cv2err);
   }
// The final report.
   Ok = approxOk && exactnessOk;
   if (!Ok || !silent) {
      printf("XBLAS Tests\n");
      printf("Approximation Tests:                      %s\n", approxOk? "Ok": "Failed");
      printf("Exact Tests:                              %s\n", exactnessOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
// end
   ae_frame_leave();
   return Ok;
}

// === directdensesolvers testing unit ===
// Checks whether solver results are correct solution.
static bool testdirectdensesolversunit_rmatrixchecksolutionm(RMatrix *xe, ae_int_t n, ae_int_t m, double threshold, ae_int_t info, densesolverreport *rep, RMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   Ok = true;
   if (info <= 0) {
      Ok = false;
   } else {
      Ok = Ok && rep->r1 >= 100.0 * machineepsilon && rep->r1 <= 1.0 + 1000.0 * machineepsilon;
      Ok = Ok && rep->rinf >= 100.0 * machineepsilon && rep->rinf <= 1.0 + 1000.0 * machineepsilon;
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtR(xe->xyR[i][j], xs->xyR[i][j], threshold);
         }
      }
   }
   return Ok;
}

// Checks whether solver results are correct solution.
static bool testdirectdensesolversunit_cmatrixchecksolutionm(CMatrix *xe, ae_int_t n, ae_int_t m, double threshold, ae_int_t info, densesolverreport *rep, CMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   Ok = true;
   if (info <= 0) {
      Ok = false;
   } else {
      Ok = Ok && rep->r1 >= 100.0 * machineepsilon && rep->r1 <= 1.0 + 1000.0 * machineepsilon;
      Ok = Ok && rep->rinf >= 100.0 * machineepsilon && rep->rinf <= 1.0 + 1000.0 * machineepsilon;
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtC(xe->xyC[i][j], xs->xyC[i][j], threshold);
         }
      }
   }
   return Ok;
}

// Checks whether solver results are correct solution.
static bool testdirectdensesolversunit_rmatrixchecksolutionmfast(RMatrix *xe, ae_int_t n, ae_int_t m, double threshold, ae_int_t info, RMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   Ok = true;
   if (info <= 0) {
      Ok = false;
   } else {
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && NearAtR(xe->xyR[i][j], xs->xyR[i][j], threshold);
         }
      }
   }
   return Ok;
}

// Checks whether solver results are correct solution.
static bool testdirectdensesolversunit_cmatrixchecksolutionmfast(CMatrix *xe, ae_int_t n, ae_int_t m, double threshold, ae_int_t info, CMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   Ok = true;
   if (info <= 0) {
      Ok = false;
      return Ok;
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < m; j++) {
         Ok = Ok && NearAtC(xe->xyC[i][j], xs->xyC[i][j], threshold);
      }
   }
   return Ok;
}

// Checks whether solver results are correct solution.
static bool testdirectdensesolversunit_rmatrixchecksolution(RMatrix *xe, ae_int_t n, double threshold, ae_int_t info, densesolverreport *rep, RVector *xs) {
   ae_frame _frame_block;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(xsm, 0, 0, DT_REAL);
   ae_matrix_set_length(&xsm, n, 1);
   ae_v_move(xsm.xyR[0], xsm.stride, xs->xR, 1, n);
   Ok = testdirectdensesolversunit_rmatrixchecksolutionm(xe, n, 1, threshold, info, rep, &xsm);
   ae_frame_leave();
   return Ok;
}

// Checks whether solver results are correct solution.
static bool testdirectdensesolversunit_cmatrixchecksolution(CMatrix *xe, ae_int_t n, double threshold, ae_int_t info, densesolverreport *rep, CVector *xs) {
   ae_frame _frame_block;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(xsm, 0, 0, DT_COMPLEX);
   ae_matrix_set_length(&xsm, n, 1);
   ae_v_cmove(xsm.xyC[0], xsm.stride, xs->xC, 1, "N", n);
   Ok = testdirectdensesolversunit_cmatrixchecksolutionm(xe, n, 1, threshold, info, rep, &xsm);
   ae_frame_leave();
   return Ok;
}

// Checks whether solver results are correct solution.
static bool testdirectdensesolversunit_rmatrixchecksolutionfast(RMatrix *xe, ae_int_t n, double threshold, ae_int_t info, RVector *xs) {
   ae_int_t i;
   bool Ok;
   Ok = true;
   if (info <= 0) {
      Ok = false;
   } else {
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(xe->xyR[i][0], xs->xR[i], threshold);
      }
   }
   return Ok;
}

// Checks whether solver results are correct solution.
static bool testdirectdensesolversunit_cmatrixchecksolutionfast(CMatrix *xe, ae_int_t n, double threshold, ae_int_t info, CVector *xs) {
   ae_frame _frame_block;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(xsm, 0, 0, DT_COMPLEX);
   ae_matrix_set_length(&xsm, n, 1);
   ae_v_cmove(xsm.xyC[0], xsm.stride, xs->xC, 1, "N", n);
   Ok = testdirectdensesolversunit_cmatrixchecksolutionmfast(xe, n, 1, threshold, info, &xsm);
   ae_frame_leave();
   return Ok;
}

// Checks whether solver results indicate singular matrix.
static bool testdirectdensesolversunit_rmatrixchecksingularm(ae_int_t n, ae_int_t m, ae_int_t info, densesolverreport *rep, RMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   Ok = true;
   if (info != -3 && info != 1) {
      Ok = false;
   } else {
      Ok = Ok && rep->r1 >= 0.0 && rep->r1 <= 1000.0 * machineepsilon;
      Ok = Ok && rep->rinf >= 0.0 && rep->rinf <= 1000.0 * machineepsilon;
      if (info == -3) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
               Ok = Ok && xs->xyR[i][j] == 0.0;
            }
         }
      }
   }
   return Ok;
}

// Checks whether solver results indicate singular matrix.
static bool testdirectdensesolversunit_cmatrixchecksingularm(ae_int_t n, ae_int_t m, ae_int_t info, densesolverreport *rep, CMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   Ok = true;
   if (info != -3 && info != 1) {
      Ok = false;
      return Ok;
   }
   Ok = Ok && rep->r1 >= 0.0 && rep->r1 <= 1000.0 * machineepsilon;
   Ok = Ok && rep->rinf >= 0.0 && rep->rinf <= 1000.0 * machineepsilon;
   if (info == -3) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && ae_c_eq_d(xs->xyC[i][j], 0.0);
         }
      }
   }
   return Ok;
}

// Checks whether solver results indicate singular matrix.
static bool testdirectdensesolversunit_rmatrixchecksingularmfast(ae_int_t n, ae_int_t m, ae_int_t info, RMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   Ok = true;
   if (info != -3) {
      Ok = false;
   } else {
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && xs->xyR[i][j] == 0.0;
         }
      }
   }
   return Ok;
}

// Checks whether solver results indicate singular matrix.
static bool testdirectdensesolversunit_cmatrixchecksingularmfast(ae_int_t n, ae_int_t m, ae_int_t info, CMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   Ok = true;
   if (info != -3) {
      Ok = false;
      return Ok;
   }
   if (info == -3) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            Ok = Ok && ae_c_eq_d(xs->xyC[i][j], 0.0);
         }
      }
   }
   return Ok;
}

// Checks whether solver results indicate singular matrix.
static bool testdirectdensesolversunit_rmatrixchecksingular(ae_int_t n, ae_int_t info, densesolverreport *rep, RVector *xs) {
   ae_frame _frame_block;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(xsm, 0, 0, DT_REAL);
   ae_matrix_set_length(&xsm, n, 1);
   ae_v_move(xsm.xyR[0], xsm.stride, xs->xR, 1, n);
   Ok = testdirectdensesolversunit_rmatrixchecksingularm(n, 1, info, rep, &xsm);
   ae_frame_leave();
   return Ok;
}

// Checks whether solver results indicate singular matrix.
static bool testdirectdensesolversunit_cmatrixchecksingular(ae_int_t n, ae_int_t info, densesolverreport *rep, CVector *xs) {
   ae_frame _frame_block;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(xsm, 0, 0, DT_COMPLEX);
   ae_matrix_set_length(&xsm, n, 1);
   ae_v_cmove(xsm.xyC[0], xsm.stride, xs->xC, 1, "N", n);
   Ok = testdirectdensesolversunit_cmatrixchecksingularm(n, 1, info, rep, &xsm);
   ae_frame_leave();
   return Ok;
}

// Checks whether solver results indicate singular matrix.
static bool testdirectdensesolversunit_rmatrixchecksingularfast(ae_int_t n, ae_int_t info, RVector *xs) {
   ae_int_t i;
   bool Ok;
   Ok = true;
   if (info != -3) {
      Ok = false;
   } else {
      for (i = 0; i < n; i++) {
         Ok = Ok && xs->xR[i] == 0.0;
      }
   }
   return Ok;
}

// Checks whether solver results indicate singular matrix.
static bool testdirectdensesolversunit_cmatrixchecksingularfast(ae_int_t n, ae_int_t info, CVector *xs) {
   ae_frame _frame_block;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(xsm, 0, 0, DT_COMPLEX);
   ae_matrix_set_length(&xsm, n, 1);
   ae_v_cmove(xsm.xyC[0], xsm.stride, xs->xC, 1, "N", n);
   Ok = testdirectdensesolversunit_cmatrixchecksingularmfast(n, 1, info, &xsm);
   ae_frame_leave();
   return Ok;
}

// Copy
static void testdirectdensesolversunit_rmatrixmakeacopy(RMatrix *a, ae_int_t m, ae_int_t n, RMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyR[i][j] = a->xyR[i][j];
      }
   }
}

// Copy
static void testdirectdensesolversunit_cmatrixmakeacopy(CMatrix *a, ae_int_t m, ae_int_t n, CMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyC[i][j] = a->xyC[i][j];
      }
   }
}

// Drops upper or lower half of the matrix - fills it by special pattern
// which may be used later to ensure that this part wasn't changed
static void testdirectdensesolversunit_rmatrixdrophalf(RMatrix *a, ae_int_t n, bool droplower) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (droplower? i > j: i < j) {
            a->xyR[i][j] = (double)(1 + 2 * i + 3 * j);
         }
      }
   }
}

// Drops upper or lower half of the matrix - fills it by special pattern
// which may be used later to ensure that this part wasn't changed
static void testdirectdensesolversunit_cmatrixdrophalf(CMatrix *a, ae_int_t n, bool droplower) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (droplower? i > j: i < j) {
            a->xyC[i][j] = complex_from_i(1 + 2 * i + 3 * j);
         }
      }
   }
}

// Unsets real vector
static void testdirectdensesolversunit_unset1d(RVector *x) {
   ae_vector_set_length(x, 1);
   x->xR[0] = randommid();
}

// Unsets real vector
static void testdirectdensesolversunit_cunset1d(CVector *x) {
   ae_vector_set_length(x, 1);
   x->xC[0] = complex_from_d(randommid());
}

// Unsets real matrix
static void testdirectdensesolversunit_unset2d(RMatrix *x) {
   ae_matrix_set_length(x, 1, 1);
   x->xyR[0][0] = randommid();
}

// Unsets real matrix
static void testdirectdensesolversunit_cunset2d(CMatrix *x) {
   ae_matrix_set_length(x, 1, 1);
   x->xyC[0][0] = complex_from_d(randommid());
}

// Unsets report
static void testdirectdensesolversunit_unsetrep(densesolverreport *r) {
   r->r1 = -1.0;
   r->rinf = -1.0;
}

// Unsets report
static void testdirectdensesolversunit_unsetlsrep(densesolverlsreport *r) {
   r->r2 = -1.0;
   r->n = -1;
   r->k = -1;
   testdirectdensesolversunit_unset2d(&r->cx);
}

// Real test
static bool testdirectdensesolversunit_testrsolver(ae_int_t maxn, ae_int_t maxm, ae_int_t passcount, double threshold, bool *RfsOkP) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t m;
   ae_int_t pass;
   ae_int_t taskkind;
   double v;
   double verr;
   ae_int_t info;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(lua, 0, 0, DT_REAL);
   NewMatrix(atmp, 0, 0, DT_REAL);
   NewVector(p, 0, DT_INT);
   NewMatrix(xe, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewVector(bv, 0, DT_REAL);
   NewObj(densesolverreport, rep);
   NewObj(densesolverlsreport, repls);
   NewMatrix(x, 0, 0, DT_REAL);
   NewVector(xv, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(tx, 0, DT_REAL);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (m = 1; m <= maxm; m++) {
         // ********************************************************
         // WELL CONDITIONED TASKS
         // ability to find correct solution is tested
         // ********************************************************
         //
         // 1. generate random well conditioned matrix A.
         // 2. generate random solution vector xe
         // 3. generate right part b == A*xe
         // 4. test different methods on original A
            rmatrixrndcond(n, 1000.0, &a);
            testdirectdensesolversunit_rmatrixmakeacopy(&a, n, n, &lua);
            rmatrixlu(&lua, n, n, &p);
            ae_matrix_set_length(&xe, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  xe.xyR[i][j] = randommid();
               }
            }
            ae_matrix_set_length(&b, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, &xe.xyR[0][j], xe.stride, n);
                  b.xyR[i][j] = v;
               }
            }
         // Test solvers
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset2d(&x);
            rmatrixsolvem(&a, n, &b, m, randombool(), &info, &rep, &x);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyR[i][j] = b.xyR[i][j];
               }
            }
            rmatrixsolvemfast(&a, n, &x, m, &info);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            rmatrixsolve(&a, n, &bv, &info, &rep, &xv);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            rmatrixsolvefast(&a, n, &bv, &info);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolutionfast(&xe, n, threshold, info, &bv);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset2d(&x);
            rmatrixlusolvem(&lua, &p, n, &b, m, &info, &rep, &x);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyR[i][j] = b.xyR[i][j];
               }
            }
            rmatrixlusolvemfast(&lua, &p, n, &x, m, &info);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            rmatrixlusolve(&lua, &p, n, &bv, &info, &rep, &xv);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_move(xv.xR, 1, b.xyR[0], b.stride, n);
            rmatrixlusolvefast(&lua, &p, n, &xv, &info);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolutionfast(&xe, n, threshold, info, &xv);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset2d(&x);
            rmatrixmixedsolvem(&a, &lua, &p, n, &b, m, &info, &rep, &x);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            rmatrixmixedsolve(&a, &lua, &p, n, &bv, &info, &rep, &xv);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
         // Test DenseSolverRLS():
         // * test on original system A*x = b
         // * test on overdetermined system with the same solution: (A' A')'*x = (b' b')'
         // * test on underdetermined system with the same solution: (A 0 0 0 ) * z = b
            info = 0;
            testdirectdensesolversunit_unsetlsrep(&repls);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            rmatrixsolvels(&a, n, n, &bv, 0.0, &info, &repls, &xv);
            if (info <= 0) {
               Ok = false;
            } else {
               Ok = Ok && repls.r2 >= 100.0 * machineepsilon && repls.r2 <= 1.0 + 1000.0 * machineepsilon;
               Ok = Ok && repls.n == n && repls.k == 0;
               for (i = 0; i < n; i++) {
                  Ok = Ok && NearAtR(xe.xyR[i][0], xv.xR[i], threshold);
               }
            }
            info = 0;
            testdirectdensesolversunit_unsetlsrep(&repls);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, 2 * n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            ae_v_move(&bv.xR[n], 1, b.xyR[0], b.stride, n);
            ae_matrix_set_length(&atmp, 2 * n, n);
            copymatrix(&a, 0, n - 1, 0, n - 1, &atmp, 0, n - 1, 0, n - 1);
            copymatrix(&a, 0, n - 1, 0, n - 1, &atmp, n, 2 * n - 1, 0, n - 1);
            rmatrixsolvels(&atmp, 2 * n, n, &bv, 0.0, &info, &repls, &xv);
            if (info <= 0) {
               Ok = false;
            } else {
               Ok = Ok && repls.r2 >= 100.0 * machineepsilon && repls.r2 <= 1.0 + 1000.0 * machineepsilon;
               Ok = Ok && repls.n == n && repls.k == 0;
               for (i = 0; i < n; i++) {
                  Ok = Ok && NearAtR(xe.xyR[i][0], xv.xR[i], threshold);
               }
            }
            info = 0;
            testdirectdensesolversunit_unsetlsrep(&repls);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            ae_matrix_set_length(&atmp, n, 2 * n);
            copymatrix(&a, 0, n - 1, 0, n - 1, &atmp, 0, n - 1, 0, n - 1);
            for (i = 0; i < n; i++) {
               for (j = n; j < 2 * n; j++) {
                  atmp.xyR[i][j] = 0.0;
               }
            }
            rmatrixsolvels(&atmp, n, 2 * n, &bv, 0.0, &info, &repls, &xv);
            if (info <= 0) {
               Ok = false;
            } else {
               Ok = Ok && repls.r2 == 0.0;
               Ok = Ok && repls.n == 2 * n && repls.k == n;
               for (i = 0; i < n; i++) {
                  Ok = Ok && NearAtR(xe.xyR[i][0], xv.xR[i], threshold);
               }
               for (i = n; i < 2 * n; i++) {
                  Ok = Ok && SmallAtR(xv.xR[i], threshold);
               }
            }
         // ********************************************************
         // EXACTLY SINGULAR MATRICES
         // ability to detect singularity is tested
         // ********************************************************
         //
         // 1. generate different types of singular matrices:
         //    * zero (TaskKind == 0)
         //    * with zero columns (TaskKind == 1)
         //    * with zero rows (TaskKind == 2)
         //    * with equal rows/columns (TaskKind == 2 or 3)
         // 2. generate random solution vector xe
         // 3. generate right part b == A*xe
         // 4. test different methods
            for (taskkind = 0; taskkind <= 4; taskkind++) {
               testdirectdensesolversunit_unset2d(&a);
               if (taskkind == 0) {
               // all zeros
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = 0.0;
                     }
                  }
               }
               if (taskkind == 1) {
               // there is zero column
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = randommid();
                     }
                  }
                  k = randominteger(n);
                  ae_v_muld(&a.xyR[0][k], a.stride, n, 0);
               }
               if (taskkind == 2) {
               // there is zero row
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = randommid();
                     }
                  }
                  k = randominteger(n);
                  ae_v_muld(a.xyR[k], 1, n, 0);
               }
               if (taskkind == 3) {
               // equal columns
                  if (n < 2) {
                     continue;
                  }
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = randommid();
                     }
                  }
                  k = 1 + randominteger(n - 1);
                  ae_v_move(a.xyR[0], a.stride, &a.xyR[0][k], a.stride, n);
               }
               if (taskkind == 4) {
               // equal rows
                  if (n < 2) {
                     continue;
                  }
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = randommid();
                     }
                  }
                  k = 1 + randominteger(n - 1);
                  ae_v_move(a.xyR[0], 1, a.xyR[k], 1, n);
               }
               ae_matrix_set_length(&xe, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     xe.xyR[i][j] = randommid();
                  }
               }
               ae_matrix_set_length(&b, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     v = ae_v_dotproduct(a.xyR[i], 1, &xe.xyR[0][j], xe.stride, n);
                     b.xyR[i][j] = v;
                  }
               }
               testdirectdensesolversunit_rmatrixmakeacopy(&a, n, n, &lua);
               rmatrixlu(&lua, n, n, &p);
            // Test RMatrixSolveM()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               rmatrixsolvem(&a, n, &b, m, randombool(), &info, &rep, &x);
               Ok = Ok && testdirectdensesolversunit_rmatrixchecksingularm(n, m, info, &rep, &x);
            // Test RMatrixSolveMFast(); performed only for matrices
            // with zero rows or columns
               if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                  info = 0;
                  ae_matrix_set_length(&x, n, m);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        x.xyR[i][j] = b.xyR[i][j];
                     }
                  }
                  rmatrixsolvemfast(&a, n, &x, m, &info);
                  Ok = Ok && testdirectdensesolversunit_rmatrixchecksingularmfast(n, m, info, &x);
               }
            // Test RMatrixSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
               rmatrixsolve(&a, n, &bv, &info, &rep, &xv);
               Ok = Ok && testdirectdensesolversunit_rmatrixchecksingular(n, info, &rep, &xv);
            // Test RMatrixSolveFast(); performed only for matrices
            // with zero rows or columns
               if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                  info = 0;
                  ae_vector_set_length(&bv, n);
                  ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
                  rmatrixsolvefast(&a, n, &bv, &info);
                  Ok = Ok && testdirectdensesolversunit_rmatrixchecksingularfast(n, info, &bv);
               }
            // Test RMatrixLUSolveM()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               rmatrixlusolvem(&lua, &p, n, &b, m, &info, &rep, &x);
               Ok = Ok && testdirectdensesolversunit_rmatrixchecksingularm(n, m, info, &rep, &x);
            // Test RMatrixLUSolveMFast(); performed only for matrices
            // with zero rows or columns
               if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                  info = 0;
                  ae_matrix_set_length(&x, n, m);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        x.xyR[i][j] = b.xyR[i][j];
                     }
                  }
                  rmatrixlusolvemfast(&lua, &p, n, &x, m, &info);
                  Ok = Ok && testdirectdensesolversunit_rmatrixchecksingularmfast(n, m, info, &x);
               }
            // Test RMatrixLUSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
               rmatrixlusolve(&lua, &p, n, &bv, &info, &rep, &xv);
               Ok = Ok && testdirectdensesolversunit_rmatrixchecksingular(n, info, &rep, &xv);
            // Test RMatrixLUSolveFast(); performed only for matrices
            // with zero rows or columns
               if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                  info = 0;
                  ae_vector_set_length(&bv, n);
                  ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
                  rmatrixlusolvefast(&lua, &p, n, &bv, &info);
                  Ok = Ok && testdirectdensesolversunit_rmatrixchecksingularfast(n, info, &bv);
               }
            // Test RMatrixMixedSolveM()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               rmatrixmixedsolvem(&a, &lua, &p, n, &b, m, &info, &rep, &x);
               Ok = Ok && testdirectdensesolversunit_rmatrixchecksingularm(n, m, info, &rep, &x);
            // Test RMatrixMixedSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
               rmatrixmixedsolve(&a, &lua, &p, n, &bv, &info, &rep, &xv);
               Ok = Ok && testdirectdensesolversunit_rmatrixchecksingular(n, info, &rep, &xv);
            }
         }
      }
   }
// test iterative improvement
   for (pass = 1; pass <= passcount; pass++) {
   // Test iterative improvement matrices
   //
   // A matrix/right part are constructed such that both matrix
   // and solution components are within (-1,+1). Such matrix/right part
   // have nice properties - system can be solved using iterative
   // improvement with |A*x-b| about several ulps of max(1,|b|).
      n = 100;
      ae_matrix_set_length(&a, n, n);
      ae_matrix_set_length(&b, n, 1);
      ae_vector_set_length(&bv, n);
      ae_vector_set_length(&tx, n);
      ae_vector_set_length(&xv, n);
      ae_vector_set_length(&y, n);
      for (i = 0; i < n; i++) {
         xv.xR[i] = randommid();
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = randommid();
         }
         ae_v_move(y.xR, 1, a.xyR[i], 1, n);
         xdot(&y, &xv, n, &tx, &v, &verr);
         bv.xR[i] = v;
      }
      ae_v_move(b.xyR[0], b.stride, bv.xR, 1, n);
   // Test RMatrixSolveM()
      testdirectdensesolversunit_unset2d(&x);
      rmatrixsolvem(&a, n, &b, 1, true, &info, &rep, &x);
      if (info <= 0) {
         *RfsOkP = false;
      } else {
         ae_vector_set_length(&xv, n);
         ae_v_move(xv.xR, 1, x.xyR[0], x.stride, n);
         for (i = 0; i < n; i++) {
            ae_v_move(y.xR, 1, a.xyR[i], 1, n);
            xdot(&y, &xv, n, &tx, &v, &verr);
            *RfsOkP = *RfsOkP && NearAtR(v, b.xyR[i][0], 8.0 * machineepsilon * rmax2(1.0, fabs(b.xyR[i][0])));
         }
      }
   // Test RMatrixSolve()
      testdirectdensesolversunit_unset1d(&xv);
      rmatrixsolve(&a, n, &bv, &info, &rep, &xv);
      if (info <= 0) {
         *RfsOkP = false;
      } else {
         for (i = 0; i < n; i++) {
            ae_v_move(y.xR, 1, a.xyR[i], 1, n);
            xdot(&y, &xv, n, &tx, &v, &verr);
            *RfsOkP = *RfsOkP && NearAtR(v, bv.xR[i], 8.0 * machineepsilon * rmax2(1.0, fabs(bv.xR[i])));
         }
      }
   // Test LS-solver on the same matrix
      rmatrixsolvels(&a, n, n, &bv, 0.0, &info, &repls, &xv);
      if (info <= 0) {
         *RfsOkP = false;
      } else {
         for (i = 0; i < n; i++) {
            ae_v_move(y.xR, 1, a.xyR[i], 1, n);
            xdot(&y, &xv, n, &tx, &v, &verr);
            *RfsOkP = *RfsOkP && NearAtR(v, bv.xR[i], 8.0 * machineepsilon * rmax2(1.0, fabs(bv.xR[i])));
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Real test
static bool testdirectdensesolversunit_testcsolver(ae_int_t maxn, ae_int_t maxm, ae_int_t passcount, double threshold, bool *RfsOkP) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t m;
   ae_int_t pass;
   ae_int_t taskkind;
   double verr;
   complex v;
   ae_int_t info;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(lua, 0, 0, DT_COMPLEX);
   NewMatrix(atmp, 0, 0, DT_COMPLEX);
   NewVector(p, 0, DT_INT);
   NewMatrix(xe, 0, 0, DT_COMPLEX);
   NewMatrix(b, 0, 0, DT_COMPLEX);
   NewVector(bv, 0, DT_COMPLEX);
   NewObj(densesolverreport, rep);
   NewObj(densesolverlsreport, repls);
   NewMatrix(x, 0, 0, DT_COMPLEX);
   NewVector(xv, 0, DT_COMPLEX);
   NewVector(y, 0, DT_COMPLEX);
   NewVector(tx, 0, DT_REAL);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (m = 1; m <= maxm; m++) {
         // ********************************************************
         // WELL CONDITIONED TASKS
         // ability to find correct solution is tested
         // ********************************************************
         //
         // 1. generate random well conditioned matrix A.
         // 2. generate random solution vector xe
         // 3. generate right part b == A*xe
         // 4. test different methods on original A
            cmatrixrndcond(n, 1000.0, &a);
            testdirectdensesolversunit_cmatrixmakeacopy(&a, n, n, &lua);
            cmatrixlu(&lua, n, n, &p);
            ae_matrix_set_length(&xe, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  xe.xyC[i][j] = complex_from_d(randommid(), randommid());
               }
            }
            ae_matrix_set_length(&b, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  v = ae_v_cdotproduct(a.xyC[i], 1, "N", &xe.xyC[0][j], xe.stride, "N", n);
                  b.xyC[i][j] = v;
               }
            }
         // Test solvers
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset2d(&x);
            cmatrixsolvem(&a, n, &b, m, randombool(), &info, &rep, &x);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyC[i][j] = b.xyC[i][j];
               }
            }
            cmatrixsolvemfast(&a, n, &x, m, &info);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            cmatrixsolve(&a, n, &bv, &info, &rep, &xv);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            cmatrixsolvefast(&a, n, &bv, &info);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolutionfast(&xe, n, threshold, info, &bv);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset2d(&x);
            cmatrixlusolvem(&lua, &p, n, &b, m, &info, &rep, &x);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyC[i][j] = b.xyC[i][j];
               }
            }
            cmatrixlusolvemfast(&lua, &p, n, &x, m, &info);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            cmatrixlusolve(&lua, &p, n, &bv, &info, &rep, &xv);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            cmatrixlusolvefast(&lua, &p, n, &bv, &info);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolutionfast(&xe, n, threshold, info, &bv);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset2d(&x);
            cmatrixmixedsolvem(&a, &lua, &p, n, &b, m, &info, &rep, &x);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            cmatrixmixedsolve(&a, &lua, &p, n, &bv, &info, &rep, &xv);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
         // ********************************************************
         // EXACTLY SINGULAR MATRICES
         // ability to detect singularity is tested
         // ********************************************************
         //
         // 1. generate different types of singular matrices:
         //    * zero
         //    * with zero columns
         //    * with zero rows
         //    * with equal rows/columns
         // 2. generate random solution vector xe
         // 3. generate right part b == A*xe
         // 4. test different methods
            for (taskkind = 0; taskkind <= 4; taskkind++) {
               testdirectdensesolversunit_cunset2d(&a);
               if (taskkind == 0) {
               // all zeros
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyC[i][j] = complex_from_i(0);
                     }
                  }
               }
               if (taskkind == 1) {
               // there is zero column
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyC[i][j] = complex_from_d(randommid(), randommid());
                     }
                  }
                  k = randominteger(n);
                  ae_v_cmuld(&a.xyC[0][k], a.stride, n, 0);
               }
               if (taskkind == 2) {
               // there is zero row
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyC[i][j] = complex_from_d(randommid(), randommid());
                     }
                  }
                  k = randominteger(n);
                  ae_v_cmuld(a.xyC[k], 1, n, 0);
               }
               if (taskkind == 3) {
               // equal columns
                  if (n < 2) {
                     continue;
                  }
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyC[i][j] = complex_from_d(randommid(), randommid());
                     }
                  }
                  k = 1 + randominteger(n - 1);
                  ae_v_cmove(a.xyC[0], a.stride, &a.xyC[0][k], a.stride, "N", n);
               }
               if (taskkind == 4) {
               // equal rows
                  if (n < 2) {
                     continue;
                  }
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyC[i][j] = complex_from_d(randommid(), randommid());
                     }
                  }
                  k = 1 + randominteger(n - 1);
                  ae_v_cmove(a.xyC[0], 1, a.xyC[k], 1, "N", n);
               }
               ae_matrix_set_length(&xe, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     xe.xyC[i][j] = complex_from_d(randommid());
                  }
               }
               ae_matrix_set_length(&b, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     v = ae_v_cdotproduct(a.xyC[i], 1, "N", &xe.xyC[0][j], xe.stride, "N", n);
                     b.xyC[i][j] = v;
                  }
               }
               testdirectdensesolversunit_cmatrixmakeacopy(&a, n, n, &lua);
               cmatrixlu(&lua, n, n, &p);
            // Test CMatrixSolveM()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               cmatrixsolvem(&a, n, &b, m, randombool(), &info, &rep, &x);
               Ok = Ok && testdirectdensesolversunit_cmatrixchecksingularm(n, m, info, &rep, &x);
            // Test CMatrixSolveMFast(); performed only for matrices
            // with zero rows or columns
               if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                  info = 0;
                  ae_matrix_set_length(&x, n, m);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        x.xyC[i][j] = b.xyC[i][j];
                     }
                  }
                  cmatrixsolvemfast(&a, n, &x, m, &info);
                  Ok = Ok && testdirectdensesolversunit_cmatrixchecksingularmfast(n, m, info, &x);
               }
            // Test CMatrixSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
               cmatrixsolve(&a, n, &bv, &info, &rep, &xv);
               Ok = Ok && testdirectdensesolversunit_cmatrixchecksingular(n, info, &rep, &xv);
               if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                  info = 0;
                  ae_vector_set_length(&bv, n);
                  ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
                  cmatrixsolvefast(&a, n, &bv, &info);
                  Ok = Ok && testdirectdensesolversunit_cmatrixchecksingularfast(n, info, &bv);
               }
            // Test CMatrixLUSolveM()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               cmatrixlusolvem(&lua, &p, n, &b, m, &info, &rep, &x);
               Ok = Ok && testdirectdensesolversunit_cmatrixchecksingularm(n, m, info, &rep, &x);
            // Test CMatrixLUSolveMFast()
               if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                  info = 0;
                  ae_matrix_set_length(&x, n, m);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        x.xyC[i][j] = b.xyC[i][j];
                     }
                  }
                  cmatrixlusolvemfast(&lua, &p, n, &x, m, &info);
                  Ok = Ok && testdirectdensesolversunit_cmatrixchecksingularmfast(n, m, info, &x);
               }
            // Test CMatrixLUSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
               cmatrixlusolve(&lua, &p, n, &bv, &info, &rep, &xv);
               Ok = Ok && testdirectdensesolversunit_cmatrixchecksingular(n, info, &rep, &xv);
            // Test CMatrixLUSolveFast()
               if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                  info = 0;
                  ae_vector_set_length(&bv, n);
                  ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
                  cmatrixlusolvefast(&lua, &p, n, &bv, &info);
                  Ok = Ok && testdirectdensesolversunit_cmatrixchecksingularfast(n, info, &bv);
               }
            // Test CMatrixMixedSolveM()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               cmatrixmixedsolvem(&a, &lua, &p, n, &b, m, &info, &rep, &x);
               Ok = Ok && testdirectdensesolversunit_cmatrixchecksingularm(n, m, info, &rep, &x);
            // Test CMatrixMixedSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
               cmatrixmixedsolve(&a, &lua, &p, n, &bv, &info, &rep, &xv);
               Ok = Ok && testdirectdensesolversunit_cmatrixchecksingular(n, info, &rep, &xv);
            }
         }
      }
   }
// test iterative improvement
   for (pass = 1; pass <= passcount; pass++) {
   // Test iterative improvement matrices
   //
   // A matrix/right part are constructed such that both matrix
   // and solution components magnitudes are within (-1,+1).
   // Such matrix/right part have nice properties - system can
   // be solved using iterative improvement with |A*x-b| about
   // several ulps of max(1,|b|).
      n = 100;
      ae_matrix_set_length(&a, n, n);
      ae_matrix_set_length(&b, n, 1);
      ae_vector_set_length(&bv, n);
      ae_vector_set_length(&tx, 2 * n);
      ae_vector_set_length(&xv, n);
      ae_vector_set_length(&y, n);
      for (i = 0; i < n; i++) {
         xv.xC[i] = complex_from_d(randommid(), randommid());
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
         ae_v_cmove(y.xC, 1, a.xyC[i], 1, "N", n);
         xcdot(&y, &xv, n, &tx, &v, &verr);
         bv.xC[i] = v;
      }
      ae_v_cmove(b.xyC[0], b.stride, bv.xC, 1, "N", n);
   // Test CMatrixSolveM()
      testdirectdensesolversunit_cunset2d(&x);
      cmatrixsolvem(&a, n, &b, 1, true, &info, &rep, &x);
      if (info <= 0) {
         *RfsOkP = false;
      } else {
         ae_vector_set_length(&xv, n);
         ae_v_cmove(xv.xC, 1, x.xyC[0], x.stride, "N", n);
         for (i = 0; i < n; i++) {
            ae_v_cmove(y.xC, 1, a.xyC[i], 1, "N", n);
            xcdot(&y, &xv, n, &tx, &v, &verr);
            *RfsOkP = *RfsOkP && NearAtC(v, b.xyC[i][0], 8.0 * machineepsilon * rmax2(1.0, abscomplex(b.xyC[i][0])));
         }
      }
   // Test CMatrixSolve()
      testdirectdensesolversunit_cunset1d(&xv);
      cmatrixsolve(&a, n, &bv, &info, &rep, &xv);
      if (info <= 0) {
         *RfsOkP = false;
      } else {
         for (i = 0; i < n; i++) {
            ae_v_cmove(y.xC, 1, a.xyC[i], 1, "N", n);
            xcdot(&y, &xv, n, &tx, &v, &verr);
            *RfsOkP = *RfsOkP && NearAtC(v, bv.xC[i], 8.0 * machineepsilon * rmax2(1.0, abscomplex(bv.xC[i])));
         }
      }
   // TODO: Test LS-solver on the same matrix
   }
   ae_frame_leave();
   return Ok;
}

// SPD test
static bool testdirectdensesolversunit_testspdsolver(ae_int_t maxn, ae_int_t maxm, ae_int_t passcount, double threshold, bool *RfsOkP) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t m;
   ae_int_t pass;
   ae_int_t taskkind;
   double v;
   bool isupper;
   ae_int_t info;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(cha, 0, 0, DT_REAL);
   NewMatrix(atmp, 0, 0, DT_REAL);
   NewVector(p, 0, DT_INT);
   NewMatrix(xe, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewVector(bv, 0, DT_REAL);
   NewObj(densesolverreport, rep);
   NewObj(densesolverlsreport, repls);
   NewMatrix(x, 0, 0, DT_REAL);
   NewVector(xv, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(tx, 0, DT_REAL);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (m = 1; m <= maxm; m++) {
         // ********************************************************
         // WELL CONDITIONED TASKS
         // ability to find correct solution is tested
         // ********************************************************
         //
         // 1. generate random well conditioned matrix A.
         // 2. generate random solution vector xe
         // 3. generate right part b == A*xe
         // 4. test different methods on original A
            isupper = randombool();
            spdmatrixrndcond(n, 1000.0, &a);
            testdirectdensesolversunit_rmatrixmakeacopy(&a, n, n, &cha);
            if (!spdmatrixcholesky(&cha, n, isupper)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            ae_matrix_set_length(&xe, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  xe.xyR[i][j] = randommid();
               }
            }
            ae_matrix_set_length(&b, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, &xe.xyR[0][j], xe.stride, n);
                  b.xyR[i][j] = v;
               }
            }
            testdirectdensesolversunit_rmatrixdrophalf(&a, n, isupper);
            testdirectdensesolversunit_rmatrixdrophalf(&cha, n, isupper);
         // Test solvers
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset2d(&x);
            spdmatrixsolvem(&a, n, isupper, &b, m, &info, &rep, &x);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyR[i][j] = b.xyR[i][j];
               }
            }
            spdmatrixsolvemfast(&a, n, isupper, &x, m, &info);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            spdmatrixsolve(&a, n, isupper, &bv, &info, &rep, &xv);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            spdmatrixsolvefast(&a, n, isupper, &bv, &info);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolutionfast(&xe, n, threshold, info, &bv);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset2d(&x);
            spdmatrixcholeskysolvem(&cha, n, isupper, &b, m, &info, &rep, &x);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyR[i][j] = b.xyR[i][j];
               }
            }
            spdmatrixcholeskysolvemfast(&cha, n, isupper, &x, m, &info);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            spdmatrixcholeskysolve(&cha, n, isupper, &bv, &info, &rep, &xv);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            spdmatrixcholeskysolvefast(&cha, n, isupper, &bv, &info);
            Ok = Ok && testdirectdensesolversunit_rmatrixchecksolutionfast(&xe, n, threshold, info, &bv);
         // ********************************************************
         // EXACTLY SINGULAR MATRICES
         // ability to detect singularity is tested
         // ********************************************************
         //
         // 1. generate different types of singular matrices:
         //    * zero
         //    * with zero columns
         //    * with zero rows
         //    * with equal rows/columns
         // 2. generate random solution vector xe
         // 3. generate right part b == A*xe
         // 4. test different methods
            for (taskkind = 0; taskkind <= 3; taskkind++) {
               testdirectdensesolversunit_unset2d(&a);
               if (taskkind == 0) {
               // all zeros
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = 0.0;
                     }
                  }
               }
               if (taskkind == 1) {
               // there is zero column
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = i; j < n; j++) {
                        a.xyR[i][j] = randommid();
                        a.xyR[j][i] = a.xyR[i][j];
                     }
                  }
                  k = randominteger(n);
                  ae_v_muld(&a.xyR[0][k], a.stride, n, 0);
                  ae_v_muld(a.xyR[k], 1, n, 0);
               }
               if (taskkind == 2) {
               // there is zero row
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = i; j < n; j++) {
                        a.xyR[i][j] = randommid();
                        a.xyR[j][i] = a.xyR[i][j];
                     }
                  }
                  k = randominteger(n);
                  ae_v_muld(a.xyR[k], 1, n, 0);
                  ae_v_muld(&a.xyR[0][k], a.stride, n, 0);
               }
               if (taskkind == 3) {
               // equal columns/rows
                  if (n < 2) {
                     continue;
                  }
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = i; j < n; j++) {
                        a.xyR[i][j] = randommid();
                        a.xyR[j][i] = a.xyR[i][j];
                     }
                  }
                  k = 1 + randominteger(n - 1);
                  ae_v_move(a.xyR[0], a.stride, &a.xyR[0][k], a.stride, n);
                  ae_v_move(a.xyR[0], 1, a.xyR[k], 1, n);
               }
               ae_matrix_set_length(&xe, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     xe.xyR[i][j] = randommid();
                  }
               }
               ae_matrix_set_length(&b, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     v = ae_v_dotproduct(a.xyR[i], 1, &xe.xyR[0][j], xe.stride, n);
                     b.xyR[i][j] = v;
                  }
               }
               testdirectdensesolversunit_rmatrixmakeacopy(&a, n, n, &cha);
               testdirectdensesolversunit_rmatrixdrophalf(&a, n, isupper);
               testdirectdensesolversunit_rmatrixdrophalf(&cha, n, isupper);
            // Test SPDMatrixSolveM()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               spdmatrixsolvem(&a, n, isupper, &b, m, &info, &rep, &x);
               Ok = Ok && testdirectdensesolversunit_rmatrixchecksingularm(n, m, info, &rep, &x);
            // Test SPDMatrixSolveMFast()
               if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                  info = 0;
                  ae_matrix_set_length(&x, n, m);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        x.xyR[i][j] = b.xyR[i][j];
                     }
                  }
                  spdmatrixsolvemfast(&a, n, isupper, &x, m, &info);
                  Ok = Ok && testdirectdensesolversunit_rmatrixchecksingularmfast(n, m, info, &x);
               }
            // Test SPDMatrixSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
               spdmatrixsolve(&a, n, isupper, &bv, &info, &rep, &xv);
               Ok = Ok && testdirectdensesolversunit_rmatrixchecksingular(n, info, &rep, &xv);
            // Test SPDMatrixSolveFast()
               info = 0;
               ae_vector_set_length(&bv, n);
               ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
               spdmatrixsolvefast(&a, n, isupper, &bv, &info);
               Ok = Ok && testdirectdensesolversunit_rmatrixchecksingular(n, info, &rep, &bv);
            // 'equal columns/rows' are degenerate, but
            // Cholesky matrix with equal columns/rows IS NOT degenerate,
            // so it is not used for testing purposes.
               if (taskkind != 3) {
               // Test SPDMatrixLUSolveM() (and fast version)
                  info = 0;
                  testdirectdensesolversunit_unsetrep(&rep);
                  testdirectdensesolversunit_unset2d(&x);
                  spdmatrixcholeskysolvem(&cha, n, isupper, &b, m, &info, &rep, &x);
                  Ok = Ok && testdirectdensesolversunit_rmatrixchecksingularm(n, m, info, &rep, &x);
                  if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                     info = 0;
                     ae_matrix_set_length(&x, n, m);
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < m; j++) {
                           x.xyR[i][j] = b.xyR[i][j];
                        }
                     }
                     spdmatrixcholeskysolvemfast(&a, n, isupper, &x, m, &info);
                     Ok = Ok && testdirectdensesolversunit_rmatrixchecksingularmfast(n, m, info, &x);
                  }
               // Test SPDMatrixLUSolve()
                  info = 0;
                  testdirectdensesolversunit_unsetrep(&rep);
                  testdirectdensesolversunit_unset2d(&x);
                  ae_vector_set_length(&bv, n);
                  ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
                  spdmatrixcholeskysolve(&cha, n, isupper, &bv, &info, &rep, &xv);
                  Ok = Ok && testdirectdensesolversunit_rmatrixchecksingular(n, info, &rep, &xv);
                  if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                     info = 0;
                     ae_vector_set_length(&bv, n);
                     ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
                     spdmatrixcholeskysolvefast(&a, n, isupper, &bv, &info);
                     Ok = Ok && testdirectdensesolversunit_rmatrixchecksingularfast(n, info, &bv);
                  }
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// HPD test
static bool testdirectdensesolversunit_testhpdsolver(ae_int_t maxn, ae_int_t maxm, ae_int_t passcount, double threshold, bool *RfsOkP) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t m;
   ae_int_t pass;
   ae_int_t taskkind;
   complex v;
   bool isupper;
   ae_int_t info;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(cha, 0, 0, DT_COMPLEX);
   NewMatrix(atmp, 0, 0, DT_COMPLEX);
   NewVector(p, 0, DT_INT);
   NewMatrix(xe, 0, 0, DT_COMPLEX);
   NewMatrix(b, 0, 0, DT_COMPLEX);
   NewVector(bv, 0, DT_COMPLEX);
   NewObj(densesolverreport, rep);
   NewObj(densesolverlsreport, repls);
   NewMatrix(x, 0, 0, DT_COMPLEX);
   NewVector(xv, 0, DT_COMPLEX);
   NewVector(y, 0, DT_COMPLEX);
   NewVector(tx, 0, DT_COMPLEX);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (m = 1; m <= maxm; m++) {
         // ********************************************************
         // WELL CONDITIONED TASKS
         // ability to find correct solution is tested
         // ********************************************************
         //
         // 1. generate random well conditioned matrix A.
         // 2. generate random solution vector xe
         // 3. generate right part b == A*xe
         // 4. test different methods on original A
            isupper = randombool();
            hpdmatrixrndcond(n, 1000.0, &a);
            testdirectdensesolversunit_cmatrixmakeacopy(&a, n, n, &cha);
            if (!hpdmatrixcholesky(&cha, n, isupper)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            ae_matrix_set_length(&xe, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  xe.xyC[i][j] = complex_from_d(randommid(), randommid());
               }
            }
            ae_matrix_set_length(&b, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  v = ae_v_cdotproduct(a.xyC[i], 1, "N", &xe.xyC[0][j], xe.stride, "N", n);
                  b.xyC[i][j] = v;
               }
            }
            testdirectdensesolversunit_cmatrixdrophalf(&a, n, isupper);
            testdirectdensesolversunit_cmatrixdrophalf(&cha, n, isupper);
         // Test solvers
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset2d(&x);
            hpdmatrixsolvem(&a, n, isupper, &b, m, &info, &rep, &x);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyC[i][j] = b.xyC[i][j];
               }
            }
            hpdmatrixsolvemfast(&a, n, isupper, &x, m, &info);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            hpdmatrixsolve(&a, n, isupper, &bv, &info, &rep, &xv);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            hpdmatrixsolvefast(&a, n, isupper, &bv, &info);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolution(&xe, n, threshold, info, &rep, &bv);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset2d(&x);
            hpdmatrixcholeskysolvem(&cha, n, isupper, &b, m, &info, &rep, &x);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyC[i][j] = b.xyC[i][j];
               }
            }
            hpdmatrixcholeskysolvemfast(&cha, n, isupper, &x, m, &info);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            hpdmatrixcholeskysolve(&cha, n, isupper, &bv, &info, &rep, &xv);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            hpdmatrixcholeskysolvefast(&cha, n, isupper, &bv, &info);
            Ok = Ok && testdirectdensesolversunit_cmatrixchecksolutionfast(&xe, n, threshold, info, &bv);
         // ********************************************************
         // EXACTLY SINGULAR MATRICES
         // ability to detect singularity is tested
         // ********************************************************
         //
         // 1. generate different types of singular matrices:
         //    * zero
         //    * with zero columns
         //    * with zero rows
         //    * with equal rows/columns
         // 2. generate random solution vector xe
         // 3. generate right part b == A*xe
         // 4. test different methods
            for (taskkind = 0; taskkind <= 3; taskkind++) {
               testdirectdensesolversunit_cunset2d(&a);
               if (taskkind == 0) {
               // all zeros
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyC[i][j] = complex_from_i(0);
                     }
                  }
               }
               if (taskkind == 1) {
               // there is zero column
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = i; j < n; j++) {
                        a.xyC[j][i] = a.xyC[i][j] = complex_from_d(randommid(), i == j? 0.0: randommid());
                     }
                  }
                  k = randominteger(n);
                  ae_v_cmuld(&a.xyC[0][k], a.stride, n, 0);
                  ae_v_cmuld(a.xyC[k], 1, n, 0);
               }
               if (taskkind == 2) {
               // there is zero row
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = i; j < n; j++) {
                        a.xyC[j][i] = a.xyC[i][j] = complex_from_d(randommid(), i == j? 0.0: randommid());
                     }
                  }
                  k = randominteger(n);
                  ae_v_cmuld(a.xyC[k], 1, n, 0);
                  ae_v_cmuld(&a.xyC[0][k], a.stride, n, 0);
               }
               if (taskkind == 3) {
               // equal columns/rows
                  if (n < 2) {
                     continue;
                  }
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = i; j < n; j++) {
                        a.xyC[j][i] = a.xyC[i][j] = complex_from_d(randommid(), i == j? 0.0: randommid());
                     }
                  }
                  k = 1 + randominteger(n - 1);
                  ae_v_cmove(a.xyC[0], a.stride, &a.xyC[0][k], a.stride, "N", n);
                  ae_v_cmove(a.xyC[0], 1, a.xyC[k], 1, "N", n);
               }
               ae_matrix_set_length(&xe, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     xe.xyC[i][j] = complex_from_d(randommid());
                  }
               }
               ae_matrix_set_length(&b, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     v = ae_v_cdotproduct(a.xyC[i], 1, "N", &xe.xyC[0][j], xe.stride, "N", n);
                     b.xyC[i][j] = v;
                  }
               }
               testdirectdensesolversunit_cmatrixmakeacopy(&a, n, n, &cha);
               testdirectdensesolversunit_cmatrixdrophalf(&a, n, isupper);
               testdirectdensesolversunit_cmatrixdrophalf(&cha, n, isupper);
            // Test SPDMatrixSolveM() (and fast version)
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               hpdmatrixsolvem(&a, n, isupper, &b, m, &info, &rep, &x);
               Ok = Ok && testdirectdensesolversunit_cmatrixchecksingularm(n, m, info, &rep, &x);
               if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                  info = 0;
                  ae_matrix_set_length(&x, n, m);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        x.xyC[i][j] = b.xyC[i][j];
                     }
                  }
                  hpdmatrixsolvemfast(&a, n, isupper, &x, m, &info);
                  Ok = Ok && testdirectdensesolversunit_cmatrixchecksingularmfast(n, m, info, &x);
               }
            // Test SPDMatrixSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
               hpdmatrixsolve(&a, n, isupper, &bv, &info, &rep, &xv);
               Ok = Ok && testdirectdensesolversunit_cmatrixchecksingular(n, info, &rep, &xv);
               if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                  info = 0;
                  ae_vector_set_length(&bv, n);
                  ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
                  hpdmatrixsolvefast(&a, n, isupper, &bv, &info);
                  Ok = Ok && testdirectdensesolversunit_cmatrixchecksingularfast(n, info, &bv);
               }
            // 'equal columns/rows' are degenerate, but
            // Cholesky matrix with equal columns/rows IS NOT degenerate,
            // so it is not used for testing purposes.
               if (taskkind != 3) {
               // Test SPDMatrixCholeskySolveM()/fast
                  info = 0;
                  testdirectdensesolversunit_unsetrep(&rep);
                  testdirectdensesolversunit_cunset2d(&x);
                  hpdmatrixcholeskysolvem(&cha, n, isupper, &b, m, &info, &rep, &x);
                  Ok = Ok && testdirectdensesolversunit_cmatrixchecksingularm(n, m, info, &rep, &x);
                  if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                     info = 0;
                     ae_matrix_set_length(&x, n, m);
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < m; j++) {
                           x.xyC[i][j] = b.xyC[i][j];
                        }
                     }
                     hpdmatrixcholeskysolvemfast(&cha, n, isupper, &x, m, &info);
                     Ok = Ok && testdirectdensesolversunit_cmatrixchecksingularmfast(n, m, info, &x);
                  }
               // Test HPDMatrixCholeskySolve() (fast)
                  info = 0;
                  testdirectdensesolversunit_unsetrep(&rep);
                  testdirectdensesolversunit_cunset2d(&x);
                  ae_vector_set_length(&bv, n);
                  ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
                  hpdmatrixcholeskysolve(&cha, n, isupper, &bv, &info, &rep, &xv);
                  Ok = Ok && testdirectdensesolversunit_cmatrixchecksingular(n, info, &rep, &xv);
                  if (taskkind == 0 || taskkind == 1 || taskkind == 2) {
                     ae_vector_set_length(&bv, n);
                     ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
                     hpdmatrixcholeskysolvefast(&cha, n, isupper, &bv, &info);
                     Ok = Ok && testdirectdensesolversunit_cmatrixchecksingularfast(n, info, &bv);
                  }
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test
bool testdirectdensesolvers() {
   ae_int_t maxn;
   ae_int_t maxm;
   ae_int_t passcount;
   double threshold;
   bool rOk;
   bool cOk;
   bool spdOk;
   bool hpdOk;
   bool rfsOk;
   bool Ok;
   maxn = 10;
   maxm = 5;
   passcount = 5;
   threshold = 10000.0 * machineepsilon;
   rfsOk = true;
   rOk = true;
   cOk = true;
   spdOk = true;
   hpdOk = true;
   rOk = rOk && testdirectdensesolversunit_testrsolver(maxn, maxm, passcount, threshold, &rfsOk);
   spdOk = spdOk && testdirectdensesolversunit_testspdsolver(maxn, maxm, passcount, threshold, &rfsOk);
   cOk = cOk && testdirectdensesolversunit_testcsolver(maxn, maxm, passcount, threshold, &rfsOk);
   hpdOk = hpdOk && testdirectdensesolversunit_testhpdsolver(maxn, maxm, passcount, threshold, &rfsOk);
// The final report.
   Ok = rOk && cOk && spdOk && hpdOk && rfsOk;
   if (!Ok || !silent) {
      printf("Dense Solver Tests\n");
      printf("* Real:                                   %s\n", rOk? "Ok": "Failed");
      printf("* Complex:                                %s\n", cOk? "Ok": "Failed");
      printf("* SPD:                                    %s\n", spdOk? "Ok": "Failed");
      printf("* HPD:                                    %s\n", hpdOk? "Ok": "Failed");
      printf("* Iterative Improvement:                  %s\n", rfsOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === directsparsesolvers testing unit ===
// SPD SKS test
static bool testdirectsparsesolversunit_testsks() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t maxn;
   double threshold;
   ae_int_t bw;
   bool isupper;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewObj(sparsematrix, sa2);
   NewObj(sparsesolverreport, rep);
   NewObj(hqrndstate, rs);
   passcount = 10;
   maxn = 30;
   threshold = 1.0E-6;
   hqrndrandomize(&rs);
// Well conditioned SPD problems solved with SKS solver
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
      // 1. generate random well conditioned matrix A.
      // 2. generate random solution vector xe
      // 3. generate right part b == A*xe
         isupper = hqrndnormal(&rs) > 0.5;
         bw = hqrnduniformi(&rs, n + 1);
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         sparsecreate(n, n, 0, &sa);
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 1.0 + hqrnduniformr(&rs);
            sparseset(&sa, i, i, a.xyR[i][i]);
            for (j = i + 1; j <= i + bw && j < n; j++) {
               a.xyR[i][j] = (hqrnduniformr(&rs) - 0.5) / n;
               a.xyR[j][i] = a.xyR[i][j];
               if (isupper) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               } else {
                  sparseset(&sa, j, i, a.xyR[i][j]);
               }
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j < i: j > i) {
                  if (hqrnduniformr(&rs) < 0.25) {
                     sparseset(&sa, i, j, hqrndnormal(&rs));
                  }
               }
            }
         }
         sparseconvertto(&sa, hqrnduniformi(&rs, 3));
         ae_vector_set_length(&xe, n);
         for (i = 0; i < n; i++) {
            xe.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&b, n);
         rmatrixgemv(n, n, 1.0, &a, 0, 0, 0, &xe, 0, 0.0, &b, 0);
      // Test SKS solver
         ae_vector_set_length(&xs, 0);
         sparsecopytosks(&sa, &sa2);
         sparsespdsolvesks(&sa2, isupper, &b, &xs, &rep);
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && xs.cnt == n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(xe.xR[i], xs.xR[i], threshold);
         }
      // Test solver #2
         sparsecopytosks(&sa, &sa2);
         if (!sparsecholeskyskyline(&sa2, n, isupper)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         ae_vector_set_length(&xs, 0);
         sparsespdcholeskysolve(&sa2, isupper, &b, &xs, &rep);
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && xs.cnt == n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(xe.xR[i], xs.xR[i], threshold);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// SPD SKS test
static bool testdirectsparsesolversunit_testcholesky() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t maxn;
   double threshold;
   ae_int_t bw;
   bool isupper;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewObj(sparsematrix, sa2);
   NewObj(sparsesolverreport, rep);
   NewObj(hqrndstate, rs);
   passcount = 10;
   maxn = 30;
   threshold = 1.0E-6;
   hqrndrandomize(&rs);
// Well conditioned SPD problems solved with Cholesky solver
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
      // 1. generate random well conditioned matrix A.
      // 2. generate random solution vector xe
      // 3. generate right part b == A*xe
         isupper = hqrndnormal(&rs) > 0.5;
         bw = hqrnduniformi(&rs, n + 1);
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         sparsecreate(n, n, 0, &sa);
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 1 + hqrnduniformr(&rs);
            sparseset(&sa, i, i, a.xyR[i][i]);
            for (j = i + 1; j <= i + bw && j < n; j++) {
               a.xyR[i][j] = (hqrnduniformr(&rs) - 0.5) / n;
               a.xyR[j][i] = a.xyR[i][j];
               if (isupper) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               } else {
                  sparseset(&sa, j, i, a.xyR[i][j]);
               }
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j < i: j > i) {
                  if (hqrnduniformr(&rs) < 0.25) {
                     sparseset(&sa, i, j, hqrndnormal(&rs));
                  }
               }
            }
         }
         sparseconvertto(&sa, hqrnduniformi(&rs, 3));
         ae_vector_set_length(&xe, n);
         for (i = 0; i < n; i++) {
            xe.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&b, n);
         rmatrixgemv(n, n, 1.0, &a, 0, 0, 0, &xe, 0, 0.0, &b, 0);
      // Test CRS/AMD solver
         ae_vector_set_length(&xs, 0);
         sparsecopy(&sa, &sa2);
         sparsespdsolve(&sa2, isupper, &b, &xs, &rep);
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && xs.cnt == n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(xe.xR[i], xs.xR[i], threshold);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// General linear test
static bool testdirectsparsesolversunit_testgen() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t maxn;
   double threshold;
   ae_int_t n;
   ae_int_t noffdiag;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(xs2, 0, DT_REAL);
   NewVector(pivp, 0, DT_INT);
   NewVector(pivq, 0, DT_INT);
   NewObj(sparsematrix, sa);
   NewObj(sparsematrix, sa2);
   NewObj(sparsesolverreport, rep);
   NewObj(hqrndstate, rs);
   passcount = 10;
   maxn = 30;
   threshold = 1.0E-6;
   hqrndrandomize(&rs);
// Well conditioned general linear problems solved with LU solver
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
      // Select number of off-diagonal entries, we want to try matrices
      // from dense to sparse
         noffdiag = n * (n - 1);
         while (true) {
         // 1. generate random well conditioned matrix A.
         // 2. apply row/col permutation
         // 3. generate random solution vector xe
         // 4. generate right part b == A*xe
            ae_matrix_set_length(&a, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
            }
            for (k = 0; k < noffdiag; k++) {
               i = hqrnduniformi(&rs, n);
               j = hqrnduniformi(&rs, n);
               a.xyR[i][j] = 0.01 * hqrndnormal(&rs) / n;
            }
            for (i = 0; i < n; i++) {
               a.xyR[i][i] = 1.0 + pow(2.0, hqrndnormal(&rs));
            }
            for (i = 0; i < n; i++) {
               swaprows(&a, i, i + hqrnduniformi(&rs, n - i), n);
            }
            for (i = 0; i < n; i++) {
               swapcols(&a, i, i + hqrnduniformi(&rs, n - i), n);
            }
            sparsecreate(n, n, 0, &sa);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               }
            }
            sparseconvertto(&sa, hqrnduniformi(&rs, 3));
            ae_vector_set_length(&xe, n);
            for (i = 0; i < n; i++) {
               xe.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&b, n);
            rmatrixgemv(n, n, 1.0, &a, 0, 0, 0, &xe, 0, 0.0, &b, 0);
         // Test solver #1
            ae_vector_set_length(&xs, 0);
            sparsesolve(&sa, &b, &xs, &rep);
            Ok = Ok && rep.terminationtype > 0;
            Ok = Ok && xs.cnt == n;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               Ok = Ok && NearAtR(xe.xR[i], xs.xR[i], threshold);
            }
         // Test solver #2
            ae_vector_set_length(&xs, 0);
            sparsecopytocrs(&sa, &sa2);
            sparselu(&sa2, 0, &pivp, &pivq);
            sparselusolve(&sa2, &pivp, &pivq, &b, &xs2, &rep);
            Ok = Ok && rep.terminationtype > 0;
            Ok = Ok && xs2.cnt == n;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               Ok = Ok && NearAtR(xe.xR[i], xs2.xR[i], threshold);
            }
         // Update fill factor
            if (noffdiag == 0) {
               break;
            }
            noffdiag /= 2;
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

bool testdirectsparsesolvers() {
   bool rsksOk;
   bool rcholOk;
   bool rgenOk;
   bool Ok;
   rsksOk = true;
   rcholOk = true;
   rgenOk = true;
   rsksOk = rsksOk && testdirectsparsesolversunit_testsks();
   rcholOk = rcholOk && testdirectsparsesolversunit_testcholesky();
   rgenOk = rgenOk && testdirectsparsesolversunit_testgen();
// The final report.
   Ok = rsksOk && rcholOk && rgenOk;
   if (!Ok || !silent) {
      printf("Direct Sparse Solvers Test\n");
      printf("* SPD-SKS (Real):                         %s\n", rsksOk? "Ok": "Failed");
      printf("* SPD-CRS (Real):                         %s\n", rcholOk? "Ok": "Failed");
      printf("* General (Real):                         %s\n", rgenOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === fbls testing unit ===
// Testing GMRES.
static bool testfblsunit_testgmres() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t rk;
   ae_int_t itscnt;
   double e;
   double eprev;
   double v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(r, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   NewObj(fblsgmresstate, state);
   hqrndrandomize(&rs);
// Test following properties:
// * increasing iterations count results in decreased residual
// * residual with ItsCnt == N is nearly zero
// * State.Qi are orthonormal
   for (n = 1; n <= 5; n++) {
   // Create problem
      hqrndnormalv(&rs, n, &b);
      hqrndnormalm(&rs, n, n, &a);
   // Test sequence of iteration counts
      eprev = maxrealnumber;
      for (itscnt = 1; itscnt <= n; itscnt++) {
      // Solve
         for (fblsgmrescreate(&b, n, itscnt, &state); fblsgmresiteration(&state); ) {
            rmatrixmv(n, n, &a, 0, 0, 0, &state.x, 0, &state.ax, 0);
         }
      // Check orthonormality of Qi
         Ok = Ok && state.qi.rows >= itscnt;
         Ok = Ok && state.qi.cols >= n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < itscnt; i++) {
            for (j = 0; j < itscnt; j++) {
               v = rdotrr(n, &state.qi, i, &state.qi, j);
               if (i == j) {
                  v--;
               }
               Ok = Ok && SmallAtR(v, 100.0 * machineepsilon);
            }
         }
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Compute residual
         allocv(n, &r);
         rmatrixmv(n, n, &a, 0, 0, 0, &state.xs, 0, &r, 0);
         raddv(n, -1.0, &b, &r);
         e = sqrt(rdotv2(n, &r));
      // Test condition
         Ok = Ok && e < eprev;
         if (itscnt == n) {
            Ok = Ok && e <= 10000.0 * machineepsilon;
         }
         eprev = e;
      }
   }
// Test that solving A*x == b with rank-k A (k < N) returns exact solution for ItsCnt >= k
   for (n = 2; n <= 10; n++) {
      for (rk = 1; rk < n; rk++) {
      // Create problem
         hqrndnormalm(&rs, n, rk, &c);
         ae_matrix_set_length(&a, n, n);
         rmatrixgemm(n, n, rk, 1.0, &c, 0, 0, 0, &c, 0, 0, 1, 0.0, &a, 0, 0);
         hqrndnormalv(&rs, n, &xe);
         ae_vector_set_length(&b, n);
         rmatrixmv(n, n, &a, 0, 0, 0, &xe, 0, &b, 0);
      // Try various iteration counts
         for (itscnt = rk; itscnt <= n; itscnt++) {
         // Solve
            for (fblsgmrescreate(&b, n, itscnt, &state); fblsgmresiteration(&state); ) {
               rmatrixmv(n, n, &a, 0, 0, 0, &state.x, 0, &state.ax, 0);
            }
         // Compute residual
            allocv(n, &r);
            rmatrixmv(n, n, &a, 0, 0, 0, &state.xs, 0, &r, 0);
            raddv(n, -1.0, &b, &r);
            e = sqrt(rdotv2(n, &r));
         // Test condition
            Ok = Ok && e <= 1.0E6 * machineepsilon;
         }
      }
   }
// Test with zero matrix
   for (n = 1; n <= 10; n++) {
      for (itscnt = 1; itscnt <= n; itscnt++) {
      // Create problem
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         hqrndnormalv(&rs, n, &b);
      // Try to solve
         for (fblsgmrescreate(&b, n, itscnt, &state); fblsgmresiteration(&state); ) {
            rmatrixmv(n, n, &a, 0, 0, 0, &state.x, 0, &state.ax, 0);
         }
      // Test solution
         for (i = 0; i < n; i++) {
            Ok = Ok && state.xs.xR[i] == 0.0;
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Testing
bool testfbls() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   bool cgOk;
   bool lsOk;
   bool cholOk;
   bool gmresOk;
   double eps;
   double v;
   double v1;
   double v2;
   double scalea;
   bool uppera;
   double alpha;
   double e1;
   double e2;
   ae_frame_make(&_frame_block);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(tmp1, 0, DT_REAL);
   NewVector(tmp2, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ea, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(buf, 0, DT_REAL);
   NewObj(fblslincgstate, cgstate);
   mx = 10;
   Ok = true;
   cgOk = true;
   lsOk = true;
   cholOk = true;
   gmresOk = testfblsunit_testgmres();
// Test CG solver:
// * generate problem (A, B, Alpha, XE - exact solution) and initial approximation X
// * E1 = ||A'A*x-b||
// * solve
// * E2 = ||A'A*x-b||
// * test that E2 < 0.001*E1
   for (n = 1; n <= mx; n++) {
      for (m = 1; m <= mx; m++) {
         ae_matrix_set_length(&a, m, n);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xe, n);
         ae_vector_set_length(&tmp1, m);
         ae_vector_set_length(&tmp2, n);
      // init A, alpha, B, X (initial approximation), XE (exact solution)
      // X is initialized in such way that is has no chances to be equal to XE.
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = randommid();
            }
         }
         alpha = randomreal() + 0.1;
         for (i = 0; i < n; i++) {
            b.xR[i] = randommid();
            xe.xR[i] = randommid();
            x.xR[i] = (2 * randominteger(2) - 1) * (2 + randomreal());
         }
      // Test dense CG (which solves A'A*x == b and accepts dense A)
         for (i = 0; i < n; i++) {
            x.xR[i] = (2 * randominteger(2) - 1) * (2 + randomreal());
         }
         rmatrixmv(m, n, &a, 0, 0, 0, &x, 0, &tmp1, 0);
         rmatrixmv(n, m, &a, 0, 0, 1, &tmp1, 0, &tmp2, 0);
         ae_v_addd(tmp2.xR, 1, x.xR, 1, n, alpha);
         ae_v_sub(tmp2.xR, 1, b.xR, 1, n);
         v = ae_v_dotproduct(tmp2.xR, 1, tmp2.xR, 1, n);
         e1 = sqrt(v);
         fblssolvecgx(&a, m, n, alpha, &b, &x, &buf);
         rmatrixmv(m, n, &a, 0, 0, 0, &x, 0, &tmp1, 0);
         rmatrixmv(n, m, &a, 0, 0, 1, &tmp1, 0, &tmp2, 0);
         ae_v_addd(tmp2.xR, 1, x.xR, 1, n, alpha);
         ae_v_sub(tmp2.xR, 1, b.xR, 1, n);
         v = ae_v_dotproduct(tmp2.xR, 1, tmp2.xR, 1, n);
         e2 = sqrt(v);
         cgOk = cgOk && e2 <= 0.001 * e1;
      // Test sparse CG (which relies on reverse communication)
         for (i = 0; i < n; i++) {
            x.xR[i] = (2 * randominteger(2) - 1) * (2 + randomreal());
         }
         rmatrixmv(m, n, &a, 0, 0, 0, &x, 0, &tmp1, 0);
         rmatrixmv(n, m, &a, 0, 0, 1, &tmp1, 0, &tmp2, 0);
         ae_v_addd(tmp2.xR, 1, x.xR, 1, n, alpha);
         ae_v_sub(tmp2.xR, 1, b.xR, 1, n);
         v = ae_v_dotproduct(tmp2.xR, 1, tmp2.xR, 1, n);
         e1 = sqrt(v);
         for (fblscgcreate(&x, &b, n, &cgstate); fblscgiteration(&cgstate); ) {
            rmatrixmv(m, n, &a, 0, 0, 0, &cgstate.x, 0, &tmp1, 0);
            rmatrixmv(n, m, &a, 0, 0, 1, &tmp1, 0, &cgstate.ax, 0);
            ae_v_addd(cgstate.ax.xR, 1, cgstate.x.xR, 1, n, alpha);
            v1 = ae_v_dotproduct(tmp1.xR, 1, tmp1.xR, 1, m);
            v2 = ae_v_dotproduct(cgstate.x.xR, 1, cgstate.x.xR, 1, n);
            cgstate.xax = v1 + alpha * v2;
         }
         rmatrixmv(m, n, &a, 0, 0, 0, &cgstate.xk, 0, &tmp1, 0);
         rmatrixmv(n, m, &a, 0, 0, 1, &tmp1, 0, &tmp2, 0);
         ae_v_addd(tmp2.xR, 1, cgstate.xk.xR, 1, n, alpha);
         ae_v_sub(tmp2.xR, 1, b.xR, 1, n);
         v = ae_v_dotproduct(tmp2.xR, 1, tmp2.xR, 1, n);
         e2 = sqrt(v);
         cgOk = cgOk && NearAtR(e1, cgstate.e1, 100.0 * machineepsilon * e1);
         cgOk = cgOk && NearAtR(e2, cgstate.e2, 100.0 * machineepsilon * e1);
         cgOk = cgOk && e2 <= 0.001 * e1;
      }
   }
// Test linear least squares:
// * try N = 1..5, M = N..2*N
//                           [ B ]
// * generate MxN matrix A = [   ], where (M-N)xN submatrix B contains
//                           [ C ]
//   random values from [-1,+1], and NxN submatrix C is diagonally dominant
//   (diagonal of C is equal to 1.0, and magnitude of off-diagonal elements
//   is smaller than 0.01). Such matrix is guaranteed to be non-degenerate.
// * generate random known solution xe, set right part b == A*xe
// * check that results of FBLSSolveLS agree with xe
   eps = 1.0E-6;
   for (n = 1; n <= 5; n++) {
      for (m = n; m <= 2 * n; m++) {
         ae_matrix_set_length(&a, m, n);
         for (i = 0; i < m - n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = randommid();
            }
         }
         for (i = m - n; i < m; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.01 * randommid();
            }
            a.xyR[i][i - (m - n)] = 1.0;
         }
         ae_vector_set_length(&xe, n);
         for (i = 0; i < n; i++) {
            xe.xR[i] = randommid();
         }
         ae_vector_set_length(&b, m);
         for (i = 0; i < m; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, xe.xR, 1, n);
            b.xR[i] = v;
         }
         fblssolvels(&a, &b, m, n, &tmp0, &tmp1, &tmp2);
         for (i = 0; i < n; i++) {
            lsOk = lsOk && NearAtR(b.xR[i], xe.xR[i], eps);
         }
      }
   }
// Test Cholesky solver:
// * generate trial A, ScaleA, XS and corresponding right part B
   for (n = 1; n <= 30; n++) {
   // Generate test problem
      ae_matrix_set_length(&a, n, n);
      ae_matrix_set_length(&ea, n, n);
      ae_vector_set_length(&xe, n);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&buf, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = 0.005 * randommid();
         }
         a.xyR[i][i] = 1 + randomreal();
         xe.xR[i] = randomreal() - 0.5;
      }
      scalea = pow(10.0, 2.0 * randommid());
      uppera = randombool();
      for (i = 0; i < n; i++) {
         if (uppera) {
            for (j = 0; j < i; j++) {
               ea.xyR[i][j] = 0.0;
            }
            for (j = i; j < n; j++) {
               ea.xyR[i][j] = a.xyR[i][j];
            }
         } else {
            for (j = 0; j <= i; j++) {
               ea.xyR[i][j] = a.xyR[i][j];
            }
            for (j = i + 1; j < n; j++) {
               ea.xyR[i][j] = 0.0;
            }
         }
      }
      if (uppera) {
         rmatrixgemv(n, n, 1.0, &ea, 0, 0, 0, &xe, 0, 0.0, &buf, 0);
         rmatrixgemv(n, n, 1.0, &ea, 0, 0, 1, &buf, 0, 0.0, &b, 0);
      } else {
         rmatrixgemv(n, n, 1.0, &ea, 0, 0, 1, &xe, 0, 0.0, &buf, 0);
         rmatrixgemv(n, n, 1.0, &ea, 0, 0, 0, &buf, 0, 0.0, &b, 0);
      }
      ae_v_muld(b.xR, 1, n, scalea);
   // Test
      fblscholeskysolve(&a, sqrt(scalea), n, uppera, &b, &buf);
      for (i = 0; i < n; i++) {
         cholOk = cholOk && NearAtR(b.xR[i], xe.xR[i], 1.0E3 * machineepsilon);
      }
   }
// The final report.
   Ok = cgOk && lsOk && cholOk && gmresOk;
   if (!Ok || !silent) {
      printf("MinCG Optimization Tests\n");
      printf("CG Errors:                                %s\n", cgOk? "Ok": "Failed");
      printf("LS Errors:                                %s\n", lsOk? "Ok": "Failed");
      printf("Chol Errors:                              %s\n", cholOk? "Ok": "Failed");
      printf("GmRes Errors:                             %s\n", gmresOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === iterativesparse testing unit ===
bool testiterativesparse() {
   return true;
}

// === lincg testing unit ===
static const double testlincgunit_e0 = 1.0E-6;
static const double testlincgunit_maxcond = 30.0;

// Function for testing LinCGIteration function(custom option), which to solve
// Ax == b(here A is random positive definite matrix NxN, b is random vector). It
// uses  the  default  stopping criterion(RNorm < FEps == 10^-6). If algorithm does
// more iterations than size  of  the problem, then  some errors are possible.
// The test verifies the following propirties:
//     1. (A*pk,pm) == 0 for any m != k;
//     2. (rk,rm) == 0 for any m != k;
//     3. (rk,pm) == 0 for any m != k;
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_complextest() {
   ae_frame _frame_block;
   ae_int_t n;
   double c;
   double normofresidual;
   double sclr;
   double na;
   double nv0;
   double nv1;
   ae_int_t sz;
   double mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   double tmp;
   double getrnorm;
   ae_int_t numofit;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, state);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(residual, 0, DT_REAL);
   NewMatrix(mtx, 0, 0, DT_REAL);
   NewMatrix(mtp, 0, 0, DT_REAL);
   NewMatrix(mtr, 0, 0, DT_REAL);
   mx = 100.0;
   n = 5;
   for (sz = 1; sz <= n; sz++) {
   // Generate:
   // * random A with norm NA (equal to 1.0),
   // * random right part B whose elements are uniformly distributed in [-MX,+MX]
   // * random starting point X0 whose elements are uniformly distributed in [-MX,+MX]
      c = 15.0 + 15.0 * randomreal();
      spdmatrixrndcond(sz, c, &a);
      na = 1.0;
      ae_vector_set_length(&b, sz);
      for (i = 0; i < sz; i++) {
         b.xR[i] = mx * randommid();
      }
      ae_vector_set_length(&x0, sz);
      for (i = 0; i < sz; i++) {
         x0.xR[i] = mx * randommid();
      }
      ae_matrix_set_length(&mtx, sz + 1, sz);
   // Start optimization, record its progress for further analysis
   // NOTE: we set update frequency of R to 2 in order to test that R is updated correctly
      lincgcreate(sz, &state);
      lincgsetxrep(&state, true);
      lincgsetb(&state, &b);
      lincgsetstartingpoint(&state, &x0);
      lincgsetcond(&state, 0.0, sz);
      lincgsetrupdatefreq(&state, 2);
      numofit = 0;
      getrnorm = maxrealnumber;
      while (lincgiteration(&state))
         if (state.needmv) {
            for (i = 0; i < sz; i++) {
               state.mv.xR[i] = 0.0;
               for (j = 0; j < sz; j++) {
                  state.mv.xR[i] += a.xyR[i][j] * state.x.xR[j];
               }
            }
         } else if (state.needvmv) {
            state.vmv = 0.0;
            for (i = 0; i < sz; i++) {
               state.mv.xR[i] = 0.0;
               for (j = 0; j < sz; j++) {
                  state.mv.xR[i] += a.xyR[i][j] * state.x.xR[j];
               }
               state.vmv += state.mv.xR[i] * state.x.xR[i];
            }
         } else if (state.needprec) {
            for (i = 0; i < sz; i++) {
               state.pv.xR[i] = state.x.xR[i];
            }
         } else if (state.xupdated) {
         // Save current point to MtX, it will be used later for additional tests
            if (numofit >= mtx.rows) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < sz; i++) {
               mtx.xyR[numofit][i] = state.x.xR[i];
            }
            getrnorm = state.r2;
            numofit++;
         }
      lincgresults(&state, &x0, &rep);
      if (getrnorm != rep.r2) {
         if (!silent) {
            printf("ComplexTest: Failed\n");
            printf("* IterationsCount = %0d, NMV = %0d, TerminationType = %0d, Size = %0d, Cond = %0.5f\n",
               (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype, (int)sz, c
            );
            printf("* GetRNorm(%0.2e) != Rep.R2(%0.2e)\n", getrnorm, rep.r2);
         }
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   // Calculate residual, check result
      ae_vector_set_length(&residual, sz);
      for (i = 0; i < sz; i++) {
         tmp = 0.0;
         for (j = 0; j < sz; j++) {
            tmp += a.xyR[i][j] * x0.xR[j];
         }
         residual.xR[i] = b.xR[i] - tmp;
      }
      normofresidual = 0.0;
      for (i = 0; i < sz; i++) {
         if (!SmallAtR(residual.xR[i], testlincgunit_e0)) {
            if (!silent) {
               printf("ComplexTest: Failed\n");
               printf("* IterationsCount = %0d, NMV = %0d, TerminationType = %0d, Size = %0d, Cond = %0.5f\n",
                  (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype, (int)sz, c
               );
               printf("* Discrepancy[%0d](%0.2e) > E0(%0.2e)\n",
                  (int)i, residual.xR[i], testlincgunit_e0
               );
            }
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         normofresidual += residual.xR[i] * residual.xR[i];
      }
      if (!NearAtR(normofresidual, rep.r2, testlincgunit_e0)) {
         if (!silent) {
            printf("ComplexTest: Failed\n");
            printf("* IterationsCount = %0d, NMV = %0d, TerminationType = %0d, Size = %0d, Cond = %0.5f\n",
               (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype, (int)sz, c
            );
            printf("* |NormOfResidual - Rep.R2|(%0.2e) > E0(%0.2e), NormOfResidual = %0.2e, Rep.R2 = %0.2e\n",
               fabs(normofresidual - rep.r2), testlincgunit_e0, normofresidual, rep.r2
            );
         }
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   // Check algorithm properties (conjugacy/orthogonality).
   // Here we use MtX which was filled during algorithm progress towards solution.
   //
   // NOTE: this test is skipped when algorithm converged in less than SZ iterations.
      if (sz > 1 && rep.iterationscount == sz) {
         ae_matrix_set_length(&mtp, sz, sz);
         ae_matrix_set_length(&mtr, sz, sz);
         for (i = 0; i < sz; i++) {
            for (j = 0; j < sz; j++) {
               mtp.xyR[i][j] = mtx.xyR[i + 1][j] - mtx.xyR[i][j];
               tmp = 0.0;
               for (k = 0; k < sz; k++) {
                  tmp += a.xyR[j][k] * mtx.xyR[i][k];
               }
               mtr.xyR[i][j] = b.xR[j] - tmp;
            }
         }
      // (Api,pj) == 0?
         sclr = 0.0;
         nv0 = 0.0;
         nv1 = 0.0;
         for (i = 0; i < sz; i++) {
            for (j = 0; j < sz; j++) {
               if (i == j) {
                  continue;
               }
               for (k = 0; k < sz; k++) {
                  tmp = 0.0;
                  for (l = 0; l < sz; l++) {
                     tmp += a.xyR[k][l] * mtp.xyR[i][l];
                  }
                  sclr += tmp * mtp.xyR[j][k];
                  nv0 += mtp.xyR[i][k] * mtp.xyR[i][k];
                  nv1 += mtp.xyR[j][k] * mtp.xyR[j][k];
               }
               nv0 = sqrt(nv0);
               nv1 = sqrt(nv1);
               if (!SmallAtR(sclr, testlincgunit_e0 * na * nv0 * nv1)) {
                  if (!silent) {
                     printf("ComplexTest: Failed\n");
                     printf("* IterationsCount = %0d, NMV = %0d, TerminationType = %0d, Size = %0d, Cond = %0.5f\n",
                        (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype, (int)sz, c
                     );
                     printf("* (Ap%0d,p%0d) != 0, {Sclr = %0.15f, NA = %0.15f, NV0 = %0.15f, NV1 = %0.15f}\n",
                        (int)i, (int)j, sclr, na, nv0, nv1
                     );
                  }
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      // (ri,pj) == 0?
         for (i = 1; i < sz; i++) {
            for (j = 0; j < i; j++) {
               sclr = 0.0;
               nv0 = 0.0;
               nv1 = 0.0;
               for (k = 0; k < sz; k++) {
                  sclr += mtr.xyR[i][k] * mtp.xyR[j][k];
                  nv0 += mtr.xyR[i][k] * mtr.xyR[i][k];
                  nv1 += mtp.xyR[j][k] * mtp.xyR[j][k];
               }
               nv0 = sqrt(nv0);
               nv1 = sqrt(nv1);
               if (!SmallAtR(sclr, testlincgunit_e0 * nv0 * nv1)) {
                  if (!silent) {
                     printf("ComplexTest: Failed\n");
                     printf("* IterationsCount = %0d, NMV = %0d, TerminationType = %0d, Size = %0d, Cond = %0.5f\n",
                        (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype, (int)sz, c
                     );
                     printf("* (r%0d,p%0d) != 0, {Sclr = %0.15f, NV0 = %0.15f, NV1 = %0.15f}\n", (int)i, (int)j, sclr, nv0, nv1);
                  }
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      // (ri,rj) == 0?
         for (i = 0; i < sz; i++) {
            for (j = i + 1; j < sz; j++) {
               sclr = 0.0;
               nv0 = 0.0;
               nv1 = 0.0;
               for (k = 0; k < sz; k++) {
                  sclr += mtr.xyR[i][k] * mtr.xyR[j][k];
                  nv0 += mtr.xyR[i][k] * mtr.xyR[i][k];
                  nv1 += mtr.xyR[j][k] * mtr.xyR[j][k];
               }
               nv0 = sqrt(nv0);
               nv1 = sqrt(nv1);
               if (!SmallAtR(sclr, testlincgunit_e0 * nv0 * nv1)) {
                  if (!silent) {
                     printf("ComplexTest: Failed\n");
                     printf("* IterationsCount = %0d, NMV = %0d, TerminationType = %0d, Size = %0d, Cond = %0.5f\n",
                        (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype, (int)sz, c
                     );
                     printf("* (rm,rk) != 0, {Sclr = %0.15f, NV0 = %0.15f, NV1 = %0.15f}\n", sclr, nv0, nv1);
                  }
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      }
   }
   if (!silent) {
      printf("ComplexTest: Ok\n");
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This function prepare problem with a known solution 'Xs'(A*Xs-b == 0). There
// b is A*Xs. After, function check algorithm result and 'Xs'.
// There used two stopping criterions:
//     1. achieved the required precision(StCrit == 0);
//     2. execution of the required number of iterations(StCrit == 1).
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_complexres() {
   ae_frame _frame_block;
   double err;
   ae_int_t n;
   ae_int_t sz;
   double c;
   ae_int_t i;
   ae_int_t j;
   ae_int_t stcrit;
   double mx;
   double tmp;
   double eps;
   ae_int_t xp;
   ae_int_t nxp;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, s);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   sz = 5;
   mx = 100.0;
   nxp = 100;
   for (xp = 0; xp < nxp; xp++) {
      for (n = 1; n <= sz; n++) {
         for (stcrit = 0; stcrit <= 1; stcrit++) {
         // Generate:
         // * random A with norm NA (equal to 1.0),
         // * random solution XS whose elements are uniformly distributed in [-MX,+MX]
         // * random starting point X0 whose elements are uniformly distributed in [-MX,+MX]
         // * B = A*Xs
            c = (testlincgunit_maxcond - 1) * randomreal() + 1;
            spdmatrixrndcond(n, c, &a);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&xs, n);
            for (i = 0; i < n; i++) {
               x0.xR[i] = mx * randommid();
               xs.xR[i] = mx * randommid();
            }
            eps = 0.0;
            for (i = 0; i < n; i++) {
               b.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  b.xR[i] += a.xyR[i][j] * xs.xR[j];
               }
               eps += b.xR[i] * b.xR[i];
            }
            eps = 1.0E-6 * sqrt(eps);
         // Solve with different stopping criteria
            lincgcreate(n, &s);
            lincgsetb(&s, &b);
            lincgsetstartingpoint(&s, &x0);
            lincgsetxrep(&s, true);
            if (stcrit == 0) {
               lincgsetcond(&s, 1.0E-6, 0);
            } else {
               lincgsetcond(&s, 0.0, n);
            }
            while (lincgiteration(&s))
               if (s.needmv) {
                  for (i = 0; i < n; i++) {
                     s.mv.xR[i] = 0.0;
                     for (j = 0; j < n; j++) {
                        s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                     }
                  }
               } else if (s.needvmv) {
                  s.vmv = 0.0;
                  for (i = 0; i < n; i++) {
                     s.mv.xR[i] = 0.0;
                     for (j = 0; j < n; j++) {
                        s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                     }
                     s.vmv += s.mv.xR[i] * s.x.xR[i];
                  }
               } else if (s.needprec) {
                  for (i = 0; i < n; i++) {
                     s.pv.xR[i] = s.x.xR[i];
                  }
               }
            lincgresults(&s, &x0, &rep);
         // Check result
            err = 0.0;
            for (i = 0; i < n; i++) {
               tmp = 0.0;
               for (j = 0; j < n; j++) {
                  tmp += a.xyR[i][j] * x0.xR[j];
               }
               err += sqr(b.xR[i] - tmp);
            }
            err = sqrt(err);
            if (err > eps) {
               if (!silent) {
                  printf("ComplexRes: Failed\n");
                  printf("* IterationsCount = %0d, NMV = %0d, TerminationType = %0d\n", (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype);
                  printf("* X:");
                  for (j = 0; j < n; j++) {
                     printf(" [%0d] == %0.10f", (int)j, x0.xR[j]);
                  }
                  putchar('\n');
                  printf("* Xs:");
                  for (j = 0; j < n; j++) {
                     printf(" [%0d] == %0.10f\n", (int)j, xs.xR[j]);
                  }
                  putchar('\n');
               }
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
// test has been passed
   if (!silent) {
      printf("ComplexRes: Ok\n");
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This function check, that XUpdated return State.X == X0 at zero iteration and
// State.X == X(algorithm result) at last.
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_basictestx() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t sz;
   double c;
   ae_int_t i;
   ae_int_t j;
   double mx;
   ae_int_t iters;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, s);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x00, 0, DT_REAL);
   NewVector(x01, 0, DT_REAL);
   sz = 5;
   mx = 100.0;
   for (n = 1; n <= sz; n++) {
   // Generate:
   // * random A with norm NA (equal to 1.0),
   // * random right part B whose elements are uniformly distributed in [-MX,+MX]
   // * random starting point X0 whose elements are uniformly distributed in [-MX,+MX]
      c = (testlincgunit_maxcond - 1) * randomreal() + 1;
      spdmatrixrndcond(n, c, &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&x00, n);
      ae_vector_set_length(&x01, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = mx * randommid();
         b.xR[i] = mx * randommid();
      }
   // Solve, save first and last reported points to x00 and x01
      lincgcreate(n, &s);
      lincgsetb(&s, &b);
      lincgsetstartingpoint(&s, &x0);
      lincgsetxrep(&s, true);
      lincgsetcond(&s, 0.0, n);
      iters = 0;
      while (lincgiteration(&s))
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
         } else if (s.needvmv) {
            s.vmv = 0.0;
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
               s.vmv += s.mv.xR[i] * s.x.xR[i];
            }
         } else if (s.needprec) {
            for (i = 0; i < n; i++) {
               s.pv.xR[i] = s.x.xR[i];
            }
         } else if (s.xupdated) {
            if (iters == 0) {
               for (i = 0; i < n; i++) {
                  x00.xR[i] = s.x.xR[i];
               }
            }
            if (iters == n) {
               for (i = 0; i < n; i++) {
                  x01.xR[i] = s.x.xR[i];
               }
            }
            iters++;
         }
   // Check first and last points
      for (i = 0; i < n; i++) {
         if (x00.xR[i] != x0.xR[i]) {
            if (!silent) {
               printf("BasicTestX: Failed\n");
               printf("* IterationsCount = %0d, NMV = %0d, TerminationType = %0d\n", (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype);
               printf("* x0:");
               for (j = 0; j < n; j++) {
                  printf(" [%0d] == %0.5f", (int)j, x0.xR[j]);
               }
               putchar('\n');
               printf("* x00:");
               for (j = 0; j < n; j++) {
                  printf(" [%0d] == %0.5f", (int)j, x00.xR[j]);
               }
               putchar('\n');
            }
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
      lincgresults(&s, &x0, &rep);
      for (i = 0; i < n; i++) {
         if (x01.xR[i] != x0.xR[i]) {
            if (!silent) {
               printf("BasicTestX: Failed\n");
               printf("* IterationsCount = %0d, NMV = %0d, TerminationType = %0d\n", (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype);
               printf("* x0:");
               for (j = 0; j < n; j++) {
                  printf(" [%0d] == %0.5f", (int)j, x0.xR[j]);
               }
               putchar('\n');
               printf("* x01:");
               for (j = 0; j < n; j++) {
                  printf(" [%0d] == %0.5f", (int)j, x01.xR[j]);
               }
               putchar('\n');
            }
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   }
// test has been passed
   if (!silent) {
      printf("BasicTestX: Ok\n");
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This function checks that XUpdated returns correct State.R2. It creates
// large badly conditioned problem (N == 50), which should be large enough and
// ill-conditioned enough to cause periodic recalculation of R.
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_testrcorrectness() {
   ae_frame _frame_block;
   ae_int_t n;
   double c;
   ae_int_t i;
   ae_int_t j;
   double r2;
   double v;
   double rtol;
   ae_int_t maxits;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, s);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   rtol = 1.0E6 * machineepsilon;
   n = 50;
   maxits = n / 2;
   c = 10000.0;
   spdmatrixrndcond(n, c, &a);
   ae_vector_set_length(&b, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = randommid();
   }
   lincgcreate(n, &s);
   lincgsetb(&s, &b);
   lincgsetxrep(&s, true);
   lincgsetcond(&s, 0.0, maxits);
   while (lincgiteration(&s))
      if (s.needmv) {
         for (i = 0; i < n; i++) {
            s.mv.xR[i] = 0.0;
            for (j = 0; j < n; j++) {
               s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
            }
         }
      } else if (s.needvmv) {
         s.vmv = 0.0;
         for (i = 0; i < n; i++) {
            s.mv.xR[i] = 0.0;
            for (j = 0; j < n; j++) {
               s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
            }
            s.vmv += s.mv.xR[i] * s.x.xR[i];
         }
      } else if (s.needprec) {
         for (i = 0; i < n; i++) {
            s.pv.xR[i] = s.x.xR[i];
         }
      } else if (s.xupdated) {
      // calculate R2, compare with value returned in state.R2
         r2 = 0.0;
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += a.xyR[i][j] * s.x.xR[j];
            }
            r2 += sqr(v - b.xR[i]);
         }
         if (!NearAtR(r2, s.r2, rtol)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   lincgresults(&s, &b, &rep);
   if (rep.iterationscount != maxits) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This function check, that number of iterations are't more than MaxIts.
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_basictestiters() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t sz;
   double c;
   ae_int_t i;
   ae_int_t j;
   double mx;
   ae_int_t iters;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, s);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   sz = 5;
   mx = 100.0;
   for (n = 1; n <= sz; n++) {
   // Generate:
   // * random A with norm NA (equal to 1.0),
   // * random right part B whose elements are uniformly distributed in [-MX,+MX]
   // * random starting point X0 whose elements are uniformly distributed in [-MX,+MX]
      c = (testlincgunit_maxcond - 1) * randomreal() + 1;
      spdmatrixrndcond(n, c, &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = mx * randommid();
         b.xR[i] = mx * randommid();
      }
   // Solve
      lincgcreate(n, &s);
      lincgsetb(&s, &b);
      lincgsetstartingpoint(&s, &x0);
      lincgsetxrep(&s, true);
      lincgsetcond(&s, 0.0, n);
      iters = 0;
      while (lincgiteration(&s))
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
         } else if (s.needvmv) {
            s.vmv = 0.0;
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
               s.vmv += s.mv.xR[i] * s.x.xR[i];
            }
         } else if (s.needprec) {
            for (i = 0; i < n; i++) {
               s.pv.xR[i] = s.x.xR[i];
            }
         } else if (s.xupdated) {
            iters++;
         }
      lincgresults(&s, &x0, &rep);
   // Check
      if (iters != rep.iterationscount + 1 || iters > n + 1) {
         if (!silent) {
            printf("BasicTestIters: Failed\n");
            printf("* IterationsCount = %0d, NMV = %0d, TerminationType = %0d, Iters = %0d\n",
               (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype, (int)iters
            );
         }
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   // Restart problem
      c = (testlincgunit_maxcond - 1) * randomreal() + 1;
      spdmatrixrndcond(n, c, &a);
      for (i = 0; i < n; i++) {
         x0.xR[i] = mx * randommid();
         b.xR[i] = mx * randommid();
      }
      lincgsetstartingpoint(&s, &x0);
      lincgrestart(&s);
      lincgsetb(&s, &b);
      iters = 0;
      while (lincgiteration(&s))
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
         } else if (s.needvmv) {
            s.vmv = 0.0;
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
               s.vmv += s.mv.xR[i] * s.x.xR[i];
            }
         } else if (s.needprec) {
            for (i = 0; i < n; i++) {
               s.pv.xR[i] = s.x.xR[i];
            }
         } else if (s.xupdated) {
            iters++;
         }
      lincgresults(&s, &x0, &rep);
   // check
      if (iters != rep.iterationscount + 1 || iters > n + 1) {
         if (!silent) {
            printf("BasicTestIters: Failed\n");
            printf("* IterationsCount = %0d, NMV = %0d, TerminationType = %0d, Iters = %0d\n",
               (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype, (int)iters
            );
         }
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
// test has been passed
   if (!silent) {
      printf("BasicTestIters: Ok\n");
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Orthogonalization by Gram-Shmidt method.
static void testlincgunit_gramshmidtortnorm(RMatrix *a, ae_int_t n, ae_int_t k, double eps, RMatrix *b, ae_int_t *k2) {
   double scaling;
   double tmp;
   double e;
   ae_int_t i;
   ae_int_t j;
   ae_int_t l;
   ae_int_t m;
   double sc;
   SetMatrix(b);
   *k2 = 0;
   *k2 = 0;
   scaling = 0.0;
   ae_matrix_set_length(b, k, n);
   for (i = 0; i < k; i++) {
      tmp = 0.0;
      for (j = 0; j < n; j++) {
         tmp += a->xyR[i][j] * a->xyR[i][j];
      }
      if (tmp > scaling) {
         scaling = tmp;
      }
   }
   scaling = sqrt(scaling);
   e = eps * scaling;
   for (i = 0; i < k; i++) {
      tmp = 0.0;
      for (j = 0; j < n; j++) {
         b->xyR[*k2][j] = a->xyR[i][j];
         tmp += a->xyR[i][j] * a->xyR[i][j];
      }
      tmp = sqrt(tmp);
      if (tmp <= e) {
         continue;
      }
      for (j = 0; j < *k2; j++) {
         sc = 0.0;
         for (m = 0; m < n; m++) {
            sc += b->xyR[*k2][m] * b->xyR[j][m];
         }
         for (l = 0; l < n; l++) {
            b->xyR[*k2][l] -= sc * b->xyR[j][l];
         }
      }
      tmp = 0.0;
      for (j = 0; j < n; j++) {
         tmp += b->xyR[*k2][j] * b->xyR[*k2][j];
      }
      tmp = sqrt(tmp);
      if (tmp <= e) {
         continue;
      } else {
         for (j = 0; j < n; j++) {
            b->xyR[*k2][j] /= tmp;
         }
      }
      ++*k2;
   }
}

// Checks that a vector belongs to the basis.
static bool testlincgunit_frombasis(RVector *x, RMatrix *basis, ae_int_t n, ae_int_t k, double eps) {
   ae_frame _frame_block;
   double normx;
   ae_int_t k2;
   ae_int_t i;
   ae_int_t j;
   double alpha;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(ortnormbasis, 0, 0, DT_REAL);
   NewVector(alphas, 0, DT_REAL);
   ae_vector_set_length(&alphas, k);
// calculating NORM for X
   normx = 0.0;
   for (i = 0; i < n; i++) {
      normx += x->xR[i] * x->xR[i];
   }
   normx = sqrt(normx);
// Gram-Shmidt method
   testlincgunit_gramshmidtortnorm(basis, n, k, eps, &ortnormbasis, &k2);
   for (i = 0; i < k2; i++) {
      alpha = 0.0;
      for (j = 0; j < n; j++) {
         alpha += x->xR[j] * ortnormbasis.xyR[i][j];
      }
      alphas.xR[i] = alpha;
   }
// check
   for (i = 0; i < n; i++) {
      alpha = 0.0;
      for (j = 0; j < k2; j++) {
         alpha += alphas.xR[j] * ortnormbasis.xyR[j][i];
      }
      if (!NearAtR(x->xR[i], alpha, normx * eps)) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This function check, that programmed method is Krylov subspace methed.
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_krylovsubspacetest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t sz;
   double c;
   ae_int_t i;
   ae_int_t j;
   ae_int_t l;
   ae_int_t m;
   double mx;
   double tmp;
   double normr0;
   ae_int_t numofit;
   ae_int_t maxits;
   ae_int_t k2;
   double eps;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, s);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewMatrix(ksr, 0, 0, DT_REAL);
   NewVector(r0, 0, DT_REAL);
   NewVector(tarray, 0, DT_REAL);
   NewMatrix(mtx, 0, 0, DT_REAL);
   eps = 1.0E-6;
   maxits = 3;
   sz = 5;
   mx = 100.0;
   for (n = 1; n <= sz; n++) {
   // Generate:
   // * random A with unit norm
   // * cond(A) in [0.5*MaxCond, 1.0*MaxCond]
   // * random x0 and b such that |A*x0-b| is large enough for algorithm to make at least one iteration.
   //
   // IMPORTANT: it is very important to have cond(A) both (1) not very large and
   //            (2) not very small. Large cond(A) will make our problem ill-conditioned,
   //            thus analytic properties won't hold. Small cond(A), from the other side,
   //            will give us rapid convergence of the algorithm - in fact, too rapid.
   //            Krylov basis will be dominated by numerical noise and test may fail.
      c = testlincgunit_maxcond * (0.5 * randomreal() + 0.5);
      spdmatrixrndcond(n, c, &a);
      ae_matrix_set_length(&mtx, n + 1, n);
      ae_matrix_set_length(&ksr, n, n);
      ae_vector_set_length(&r0, n);
      ae_vector_set_length(&tarray, n);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      do {
         for (i = 0; i < n; i++) {
            x0.xR[i] = mx * randommid();
            b.xR[i] = mx * randommid();
         }
         normr0 = 0.0;
         for (i = 0; i < n; i++) {
            tmp = 0.0;
            for (j = 0; j < n; j++) {
               tmp += a.xyR[i][j] * x0.xR[j];
            }
            r0.xR[i] = b.xR[i] - tmp;
            normr0 += r0.xR[i] * r0.xR[i];
         }
      } while (sqrt(normr0) <= eps);
   // Fill KSR by {r0, A*r0, A^2*r0, ... }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            ksr.xyR[i][j] = r0.xR[j];
         }
         for (j = 0; j < i; j++) {
            for (l = 0; l < n; l++) {
               tarray.xR[l] = 0.0;
               for (m = 0; m < n; m++) {
                  tarray.xR[l] += a.xyR[l][m] * ksr.xyR[i][m];
               }
            }
            for (l = 0; l < n; l++) {
               ksr.xyR[i][l] = tarray.xR[l];
            }
         }
      }
   // Solve system, record intermediate points for futher analysis.
   // NOTE: we set update frequency of R to 2 in order to test that R is updated correctly
      lincgcreate(n, &s);
      lincgsetb(&s, &b);
      lincgsetstartingpoint(&s, &x0);
      lincgsetxrep(&s, true);
      lincgsetcond(&s, 0.0, n);
      lincgsetrupdatefreq(&s, 2);
      numofit = 0;
      while (lincgiteration(&s))
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
         } else if (s.needvmv) {
            s.vmv = 0.0;
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
               s.vmv += s.mv.xR[i] * s.x.xR[i];
            }
         } else if (s.needprec) {
            for (i = 0; i < n; i++) {
               s.pv.xR[i] = s.x.xR[i];
            }
         } else if (s.xupdated) {
            for (i = 0; i < n; i++) {
               mtx.xyR[numofit][i] = s.x.xR[i];
            }
            numofit++;
         }
   // Check that I-th step S_i == X[I+1]-X[i] belongs to I-th Krylov subspace.
   // Checks are done for first K2 steps, with K2 small enough to avoid
   // numerical errors.
      if (n <= maxits) {
         k2 = n;
      } else {
         k2 = maxits;
      }
      for (i = 0; i < k2; i++) {
         for (j = 0; j < n; j++) {
            tarray.xR[j] = mtx.xyR[i + 1][j] - mtx.xyR[i][j];
         }
         if (!testlincgunit_frombasis(&tarray, &ksr, n, i + 1, testlincgunit_e0)) {
            if (!silent) {
               printf("KrylovSubspaceTest: Failed\n");
               printf("* Size = %0d, Iters = %0d\n", (int)n, (int)i);
            }
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   }
   if (!silent) {
      printf("KrylovSubspaceTest: Ok\n");
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Function for testing  LinCgSolveSparse. This function  prepare problem with
// a known solution 'Xs'(A*Xs-b == 0). There b is A*Xs. After, function calculate
// result by LinCGSolveSparse and compares it with 'Xs'.
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_sparsetest() {
   ae_frame _frame_block;
   double err;
   ae_int_t n;
   ae_int_t sz;
   double c;
   ae_int_t i;
   ae_int_t j;
   double mx;
   double eps;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, s);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewObj(sparsematrix, uppera);
   NewObj(sparsematrix, lowera);
   sz = 5;
   mx = 100.0;
   for (n = 1; n <= sz; n++) {
   // Generate:
   // * random A with unit norm
   // * random X0 (starting point) and XS (known solution)
   // Copy dense A to sparse SA
      c = (testlincgunit_maxcond - 1) * randomreal() + 1;
      spdmatrixrndcond(n, c, &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&xs, n);
      for (i = 0; i < n; i++) {
         xs.xR[i] = mx * randommid();
      }
      eps = 0.0;
      for (i = 0; i < n; i++) {
         b.xR[i] = 0.0;
         for (j = 0; j < n; j++) {
            b.xR[i] += a.xyR[i][j] * xs.xR[j];
         }
         eps += b.xR[i] * b.xR[i];
      }
      eps = 1.0E-6 * sqrt(eps);
      sparsecreate(n, n, 0, &uppera);
      sparsecreate(n, n, 0, &lowera);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (j >= i) {
               sparseset(&uppera, i, j, a.xyR[i][j]);
            }
            if (j <= i) {
               sparseset(&lowera, i, j, a.xyR[i][j]);
            }
         }
      }
      sparseconverttocrs(&uppera);
      sparseconverttocrs(&lowera);
   // Test upper triangle
      lincgcreate(n, &s);
      lincgsetcond(&s, 0.0, n);
      lincgsolvesparse(&s, &uppera, true, &b);
      lincgresults(&s, &x0, &rep);
      err = 0.0;
      for (i = 0; i < n; i++) {
         err += sqr(x0.xR[i] - xs.xR[i]);
      }
      err = sqrt(err);
      if (err > eps) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   // Test lower triangle
      lincgcreate(n, &s);
      lincgsetcond(&s, 0.0, n);
      lincgsolvesparse(&s, &lowera, false, &b);
      lincgresults(&s, &x1, &rep);
      err = 0.0;
      for (i = 0; i < n; i++) {
         err += sqr(x1.xR[i] - xs.xR[i]);
      }
      err = sqrt(err);
      if (err > eps) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Function for testing  the preconditioned conjugate gradient method.
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_precondtest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t sz;
   ae_int_t numofit;
   double c;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double eps;
   bool bflag;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, s);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ta, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewVector(m, 0, DT_REAL);
   NewMatrix(mtx, 0, 0, DT_REAL);
   NewMatrix(mtprex, 0, 0, DT_REAL);
   NewVector(de, 0, DT_REAL);
   NewVector(rde, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(tb, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(tx0, 0, DT_REAL);
   NewVector(err, 0, DT_REAL);
// Test 1.
//
// Preconditioned CG for A*x == b with preconditioner M == E*E' is algebraically
// equivalent to non-preconditioned CG for (inv(E)*A*inv(E'))*z = inv(E)*b
// with z == E'*x.
//
// We test it by generating random preconditioner, running algorithm twice -
// one  time  for  original  problem  with  preconditioner , another one  for
// modified problem without preconditioner.
   sz = 5;
   for (n = 1; n <= sz; n++) {
   // Generate:
   // * random A with unit norm
   // * random positive definite diagonal preconditioner M
   // * dE == sqrt(M)
   // * rdE == dE^(-1)
   // * tA = rdE*A*rdE
   // * random x0 and b - for original preconditioned problem
   // * tx0 and tb - for modified problem
      c = (testlincgunit_maxcond - 1) * randomreal() + 1;
      spdmatrixrndcond(n, c, &a);
      ae_matrix_set_length(&ta, n, n);
      ae_matrix_set_length(&mtx, n + 1, n);
      ae_matrix_set_length(&mtprex, n + 1, n);
      ae_vector_set_length(&m, n);
      ae_vector_set_length(&de, n);
      ae_vector_set_length(&rde, n);
      for (i = 0; i < n; i++) {
         m.xR[i] = randomreal() + 0.5;
         de.xR[i] = sqrt(m.xR[i]);
         rde.xR[i] = 1 / de.xR[i];
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            ta.xyR[i][j] = rde.xR[i] * a.xyR[i][j] * rde.xR[j];
         }
      }
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&tb, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&tx0, n);
      ae_vector_set_length(&err, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         b.xR[i] = randommid();
      }
      eps = 1.0E-5;
      for (i = 0; i < n; i++) {
         tx0.xR[i] = de.xR[i] * x0.xR[i];
         tb.xR[i] = rde.xR[i] * b.xR[i];
      }
   // Solve two problems, intermediate points are saved to MtX and MtPreX
      lincgcreate(n, &s);
      lincgsetb(&s, &b);
      lincgsetstartingpoint(&s, &x0);
      lincgsetxrep(&s, true);
      lincgsetcond(&s, 0.0, n);
      numofit = 0;
      while (lincgiteration(&s))
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
         } else if (s.needvmv) {
            s.vmv = 0.0;
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
               s.vmv += s.mv.xR[i] * s.x.xR[i];
            }
         } else if (s.needprec) {
            for (i = 0; i < n; i++) {
               s.pv.xR[i] = s.x.xR[i] / m.xR[i];
            }
         } else if (s.xupdated) {
            if (numofit >= mtx.rows) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               mtx.xyR[numofit][i] = s.x.xR[i];
            }
            numofit++;
         }
      lincgsetstartingpoint(&s, &tx0);
      lincgsetb(&s, &tb);
      lincgrestart(&s);
      numofit = 0;
      while (lincgiteration(&s))
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += ta.xyR[i][j] * s.x.xR[j];
               }
            }
         } else if (s.needvmv) {
            s.vmv = 0.0;
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += ta.xyR[i][j] * s.x.xR[j];
               }
               s.vmv += s.mv.xR[i] * s.x.xR[i];
            }
         } else if (s.needprec) {
            for (i = 0; i < n; i++) {
               s.pv.xR[i] = s.x.xR[i];
            }
         } else if (s.xupdated) {
            if (numofit >= mtprex.rows) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < n; i++) {
               mtprex.xyR[numofit][i] = s.x.xR[i];
            }
            numofit++;
         }
   // Compare results - sequence of points generated when solving original problem with
   // points generated by modified problem.
      for (i = 0; i < numofit; i++) {
         for (j = 0; j < n; j++) {
            if (!NearAtR(mtx.xyR[i][j], rde.xR[j] * mtprex.xyR[i][j], eps)) {
               if (!silent) {
                  printf("PrecondTest: Failed\n");
                  printf("* Size = %0d, IterationsCount = %0d, NMV = %0d, TerminationType = %0d\n",
                     (int)n, (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype
                  );
                  printf("* mtx[%0d]:", (int)i);
                  for (k = 0; k < n; k++) {
                     printf(" [%0d] == %0.10f", (int)k, mtx.xyR[i][k]);
                  }
                  putchar('\n');
                  printf("* mtx^[%0d]:", (int)i);
                  for (k = 0; k < n; k++) {
                     printf(" [%0d] == %0.10f", (int)k, mtprex.xyR[i][k]);
                  }
                  putchar('\n');
               }
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
// Test 2.
//
// We test automatic diagonal preconditioning used by SolveSparse.
// In order to do so we:
// 1. generate 20*20 matrix A0 with condition number equal to 1.0E1
// 2. generate random "exact" solution xe and right part b == A0*xe
// 3. generate random ill-conditioned diagonal scaling matrix D with
//    condition number equal to 1.0E50:
// 4. transform A*x == b into badly scaled problem:
//    A0*x0 == b0
//    A0*D*(inv(D)*x0) == b0
//    (D*A0*D)*(inv(D)*x0) == (D*b0)
//    finally we got new problem A*x == b with A == D*A0*D, b == D*b0, x == inv(D)*x0
//
// Then we solve A*x == b:
// 1. with default preconditioner
// 2. with explicitly activayed diagonal preconditioning
// 3. with unit preconditioner.
// 1st and 2nd solutions must be close to xe, 3rd solution must be very
// far from the true one.
   n = 20;
   spdmatrixrndcond(n, 1.0E1, &ta);
   ae_vector_set_length(&xe, n);
   for (i = 0; i < n; i++) {
      xe.xR[i] = randomnormal();
   }
   ae_vector_set_length(&b, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = 0.0;
      for (j = 0; j < n; j++) {
         b.xR[i] += ta.xyR[i][j] * xe.xR[j];
      }
   }
   ae_vector_set_length(&d, n);
   for (i = 0; i < n; i++) {
      d.xR[i] = pow(10.0, 50.0 * randommid());
   }
   ae_matrix_set_length(&a, n, n);
   sparsecreate(n, n, n * n, &sa);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a.xyR[i][j] = d.xR[i] * ta.xyR[i][j] * d.xR[j];
         sparseset(&sa, i, j, a.xyR[i][j]);
      }
      b.xR[i] *= d.xR[i];
      xe.xR[i] /= d.xR[i];
   }
   sparseconverttocrs(&sa);
   lincgcreate(n, &s);
   lincgsetcond(&s, 0.0, 2 * n);
   lincgsolvesparse(&s, &sa, true, &b);
   lincgresults(&s, &x0, &rep);
   if (rep.terminationtype <= 0) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   for (i = 0; i < n; i++) {
      if (!NearAtR(xe.xR[i], x0.xR[i], 5.0E-2 / d.xR[i])) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   lincgsetprecunit(&s);
   lincgsolvesparse(&s, &sa, true, &b);
   lincgresults(&s, &x0, &rep);
   if (rep.terminationtype > 0) {
      bflag = false;
      for (i = 0; i < n; i++) {
         bflag = bflag || !NearAtR(xe.xR[i], x0.xR[i], 5.0E-2 / d.xR[i]);
      }
      if (!bflag) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   lincgsetprecdiag(&s);
   lincgsolvesparse(&s, &sa, true, &b);
   lincgresults(&s, &x0, &rep);
   if (rep.terminationtype <= 0) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   for (i = 0; i < n; i++) {
      if (!NearAtR(xe.xR[i], x0.xR[i], 5.0E-2 / d.xR[i])) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
// test has been passed
   if (!silent) {
      printf("PrecondTest: Ok\n");
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

bool testlincg() {
   bool basictestxOk;
   bool basictestitersOk;
   bool complexresOk;
   bool complexOk;
   bool rcorrectnessOk;
   bool krylovsubspaceOk;
   bool sparseOk;
   bool precondOk;
   bool Ok;
   if (!silent) printf("LinCG Test Breakdown\n");
   basictestxOk = testlincgunit_basictestx();
   basictestitersOk = testlincgunit_basictestiters();
   complexresOk = testlincgunit_complexres();
   complexOk = testlincgunit_complextest();
   rcorrectnessOk = testlincgunit_testrcorrectness();
   krylovsubspaceOk = testlincgunit_krylovsubspacetest();
   sparseOk = testlincgunit_sparsetest();
   precondOk = testlincgunit_precondtest();
// The final report.
   Ok = basictestxOk && complexresOk && complexOk && rcorrectnessOk && basictestitersOk && krylovsubspaceOk && sparseOk && precondOk;
   if (!Ok || !silent) {
      printf("LinCG Tests\n");
      printf("Basic Test X:                             %s\n", basictestxOk? "Ok": "Failed");
      printf("Basic Test Iters:                         %s\n", basictestitersOk? "Ok": "Failed");
      printf("Complex Res Test:                         %s\n", complexresOk? "Ok": "Failed");
      printf("Complex Test:                             %s\n", complexOk? "Ok": "Failed");
      printf("R2 Correctness:                           %s\n", rcorrectnessOk? "Ok": "Failed");
      printf("Krylov SubSpace Test:                     %s\n", krylovsubspaceOk? "Ok": "Failed");
      printf("Sparse Test:                              %s\n", sparseOk? "Ok": "Failed");
      printf("Precondinioner Test:                      %s\n", precondOk? "Ok": "Failed");
   // was errors?
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === normestimator testing unit ===
bool testnormestimator() {
   ae_frame _frame_block;
   double tol;
   ae_int_t maxmn;
   ae_int_t m;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t passcount;
   double snorm;
   double enorm;
   double enorm2;
   ae_int_t nbetter;
   double sigma;
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(rowsizes, 0, DT_INT);
   NewObj(sparsematrix, s);
   NewObj(normestimatorstate, e);
   NewObj(normestimatorstate, e2);
   tol = 0.01;
   maxmn = 5;
   Ok = true;
// First test: algorithm must correctly determine matrix norm
   for (m = 1; m <= maxmn; m++) {
      for (n = 1; n <= maxmn; n++) {
      // Create estimator with quite large NStart and NIts.
      // It should guarantee that we converge to the correct solution.
         normestimatorcreate(m, n, 15, 15, &e);
      // Try with zero A first
         sparsecreate(m, n, 1, &s);
         sparseconverttocrs(&s);
         normestimatorestimatesparse(&e, &s);
         normestimatorresults(&e, &enorm);
         Ok = Ok && enorm == 0.0;
      // Choose random norm, try with non-zero matrix
      // with specified norm.
         snorm = exp(5.0 * randommid());
         sparsecreate(m, n, 1, &s);
         if (m >= n) {
         // Generate random orthogonal M*M matrix,
         // use N leading columns as columns of A
            rmatrixrndorthogonal(m, &a);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  sparseset(&s, i, j, snorm * a.xyR[i][j]);
               }
            }
         } else {
         // Generate random orthogonal N*N matrix,
         // use M leading rows as rows of A
            rmatrixrndorthogonal(n, &a);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  sparseset(&s, i, j, snorm * a.xyR[i][j]);
               }
            }
         }
         sparseconverttocrs(&s);
         normestimatorestimatesparse(&e, &s);
         normestimatorresults(&e, &enorm);
         Ok = Ok && enorm <= snorm * (1 + tol) && enorm >= snorm * (1 - tol);
      }
   }
// NStart == 10 should give statistically better results than NStart == 1.
// In order to test it we perform PassCount attempts to solve random
// problem by means of two estimators: one with NStart == 10 and another
// one with NStart == 1. Every time we compare two estimates and choose
// better one.
//
// Random variable NBetter is a number of cases when NStart == 10 was better.
// Under null hypothesis (no difference) it is binomially distributed
// with mean PassCount/2 and variance PassCount/4. However, we expect
// to have significant deviation to the right, in the area of larger
// values.
//
// NOTE: we use fixed N because this test is independent of problem size.
   n = 3;
   normestimatorcreate(n, n, 1, 1, &e);
   normestimatorcreate(n, n, 10, 1, &e2);
   normestimatorsetseed(&e, 0);
   normestimatorsetseed(&e2, 0);
   nbetter = 0;
   passcount = 2000;
   sigma = 5.0;
   for (pass = 1; pass <= passcount; pass++) {
      snorm = pow(10.0, randommid());
      sparsecreate(n, n, 1, &s);
      rmatrixrndcond(n, 2.0, &a);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            sparseset(&s, i, j, snorm * a.xyR[i][j]);
         }
      }
      sparseconverttocrs(&s);
      normestimatorestimatesparse(&e, &s);
      normestimatorresults(&e, &enorm);
      normestimatorestimatesparse(&e2, &s);
      normestimatorresults(&e2, &enorm2);
      if (fabs(enorm2 - snorm) < fabs(enorm - snorm)) {
         nbetter++;
      }
   }
   Ok = Ok && nbetter >= 0.5 * passcount + sigma * sqrt(0.25 * passcount);
// Same as previous one (for NStart), but tests dependence on NIts.
   n = 3;
   normestimatorcreate(n, n, 1, 1, &e);
   normestimatorcreate(n, n, 1, 10, &e2);
   normestimatorsetseed(&e, 0);
   normestimatorsetseed(&e2, 0);
   nbetter = 0;
   passcount = 2000;
   sigma = 5.0;
   for (pass = 1; pass <= passcount; pass++) {
      snorm = pow(10.0, randommid());
      sparsecreate(n, n, 1, &s);
      rmatrixrndcond(n, 2.0, &a);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            sparseset(&s, i, j, snorm * a.xyR[i][j]);
         }
      }
      sparseconverttocrs(&s);
      normestimatorestimatesparse(&e, &s);
      normestimatorresults(&e, &enorm);
      normestimatorestimatesparse(&e2, &s);
      normestimatorresults(&e2, &enorm2);
      if (fabs(enorm2 - snorm) < fabs(enorm - snorm)) {
         nbetter++;
      }
   }
   Ok = Ok && nbetter >= 0.5 * passcount + sigma * sqrt(0.25 * passcount);
// The final report.
   if (!Ok || !silent) {
      printf("Norm Estimator Test\n");
      printf("Test:                                     %s\n", Ok? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === linlsqr testing unit ===
static const double testlinlsqrunit_e0 = 1.0E-6;
static const double testlinlsqrunit_tolort = 1.0E-4;
static const double testlinlsqrunit_emergencye0 = 1.0E-12;

// This function compares solution calculated by LSQR with one calculated  by
// SVD solver. Following comparisons are performed:
// 1. either:
//    1.a) residual norm |Rk| for LSQR solution is at most EpsErr*|B|
//    1.b) |A^T*Rk|/(|A|*|Rk|) <= EpsOrt
// 2. norm(LSQR_solution) is at most 1.2*norm(SVD_solution)
//
// Test (1) verifies that LSQR found good solution, test  (2)  verifies  that
// LSQR finds solution with close-to-minimum norm. We use factor as large  as
// 1.2 to test deviation from SVD solution because LSQR is not very  good  at
// solving degenerate problems.
//
// Inputs:
//     A       -   array[M,N], system matrix
//     B       -   right part
//     M, N    -   problem size
//     LambdaV -   regularization value for the problem, >= 0
//     X       -   array[N], solution found by LSQR
//     EpsErr  -   tolerance for |A*x-b|
//     EpsOrt  -   tolerance for |A^T*Rk|/(|A|*|Rk|)
//
// Result:
//     True, for solution which passess all the tests
static bool testlinlsqrunit_isitgoodsolution(RMatrix *a, RVector *b, ae_int_t m, ae_int_t n, double lambdav, RVector *x, double epserr, double epsort) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t minmn;
   bool svdresult;
   double v;
   double rnorm;
   double bnorm;
   double anorm;
   double atrnorm;
   double xnorm;
   double svdxnorm;
   bool clause1holds;
   bool clause2holds;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(svda, 0, 0, DT_REAL);
   NewMatrix(u, 0, 0, DT_REAL);
   NewMatrix(vt, 0, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(svdx, 0, DT_REAL);
   NewVector(tmparr, 0, DT_REAL);
   NewVector(r, 0, DT_REAL);
// Solve regularized problem with SVD solver
   ae_matrix_set_length(&svda, m + n, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         svda.xyR[i][j] = a->xyR[i][j];
      }
   }
   for (i = m; i < m + n; i++) {
      for (j = 0; j < n; j++) {
         if (i - m == j) {
            svda.xyR[i][j] = lambdav;
         } else {
            svda.xyR[i][j] = 0.0;
         }
      }
   }
   svdresult = rmatrixsvd(&svda, m + n, n, 1, 1, 0, &w, &u, &vt);
   ae_assert(svdresult, "LINLSQR: internal error in unit test (SVD failed)");
   minmn = imin2(m, n);
   ae_vector_set_length(&svdx, n);
   ae_vector_set_length(&tmparr, minmn);
   for (i = 0; i < minmn; i++) {
      tmparr.xR[i] = 0.0;
      for (j = 0; j < m; j++) {
         tmparr.xR[i] += u.xyR[j][i] * b->xR[j];
      }
      if (w.xR[i] <= sqrt(machineepsilon) * w.xR[0]) {
         tmparr.xR[i] = 0.0;
      } else {
         tmparr.xR[i] /= w.xR[i];
      }
   }
   for (i = 0; i < n; i++) {
      svdx.xR[i] = 0.0;
      for (j = 0; j < minmn; j++) {
         svdx.xR[i] += vt.xyR[j][i] * tmparr.xR[j];
      }
   }
// Calculate residual, perform checks 1.a and 1.b:
// * first, we check 1.a
// * in case 1.a fails we check 1.b
   ae_vector_set_length(&r, m + n);
   for (i = 0; i < m + n; i++) {
      v = ae_v_dotproduct(svda.xyR[i], 1, x->xR, 1, n);
      r.xR[i] = v;
      if (i < m) {
         r.xR[i] -= b->xR[i];
      }
   }
   v = ae_v_dotproduct(r.xR, 1, r.xR, 1, m + n);
   rnorm = sqrt(v);
   v = ae_v_dotproduct(b->xR, 1, b->xR, 1, m);
   bnorm = sqrt(v);
   if (rnorm <= epserr * bnorm) {
   // 1.a is true, no further checks is needed
      clause1holds = true;
   } else {
   // 1.a is false, we have to check 1.b
   //
   // In order to do so, we calculate ||A|| and ||A^T*Rk||. We do
   // not store product of A and Rk to some array, all we need is
   // just one component of product at time, stored in V.
   //
      anorm = 0.0;
      atrnorm = 0.0;
      for (i = 0; i < n; i++) {
         v = 0.0;
         for (j = 0; j < m + n; j++) {
            v += svda.xyR[j][i] * r.xR[j];
            anorm += sqr(svda.xyR[j][i]);
         }
         atrnorm += sqr(v);
      }
      anorm = sqrt(anorm);
      atrnorm = sqrt(atrnorm);
      clause1holds = anorm * rnorm == 0.0 || atrnorm / (anorm * rnorm) <= epsort;
   }
// Check (2).
// Here we assume that Result == True when we enter this block.
   v = ae_v_dotproduct(x->xR, 1, x->xR, 1, n);
   xnorm = sqrt(v);
   v = ae_v_dotproduct(svdx.xR, 1, svdx.xR, 1, n);
   svdxnorm = sqrt(v);
   clause2holds = xnorm <= 1.2 * svdxnorm;
// End
   Ok = clause1holds && clause2holds;
   ae_frame_leave();
   return Ok;
}

// This  function  generates  random  MxN  problem,  solves  it with LSQR and
// compares with results obtained from SVD solver. Matrix A is  generated  as
// MxN  matrix  with  uniformly  distributed  random  entries, i.e. it has no
// special properties (like conditioning or separation of singular values).
//
// We apply random amount regularization to our problem (from zero to  large)
// in  order  to  test  regularizer.  Default  stopping  criteria  are  used.
// Preconditioning is turned off because it skews results for  rank-deficient
// problems.
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_svdtest() {
   ae_frame _frame_block;
   ae_int_t szn;
   ae_int_t szm;
   ae_int_t n;
   ae_int_t m;
   double lambdai;
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewObj(sparsematrix, spa);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   szm = 5;
   szn = 5;
   for (m = 1; m <= szm; m++) {
      for (n = 1; n <= szn; n++) {
      // Prepare MxN matrix A, right part B, lambda
         lambdai = randomreal();
         ae_matrix_set_length(&a, m, n);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = randommid();
            }
         }
         sparsecreate(m, n, 1, &spa);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               sparseset(&spa, i, j, a.xyR[i][j]);
            }
         }
         sparseconverttocrs(&spa);
         ae_vector_set_length(&b, m);
         for (i = 0; i < m; i++) {
            b.xR[i] = randommid();
         }
      // Solve by calling LinLSQRIteration
         linlsqrcreate(m, n, &s);
         linlsqrsetb(&s, &b);
         linlsqrsetlambdai(&s, lambdai);
         linlsqrsetprecunit(&s);
         while (linlsqriteration(&s))
            if (s.needmv) {
               for (i = 0; i < m; i++) {
                  s.mv.xR[i] = 0.0;
                  for (j = 0; j < n; j++) {
                     s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                  }
               }
            } else if (s.needmtv) {
               for (i = 0; i < n; i++) {
                  s.mtv.xR[i] = 0.0;
                  for (j = 0; j < m; j++) {
                     s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                  }
               }
            }
         linlsqrresults(&s, &x0, &rep);
         if (!testlinlsqrunit_isitgoodsolution(&a, &b, m, n, lambdai, &x0, testlinlsqrunit_e0, testlinlsqrunit_tolort)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      // test LinLSQRRestart and LinLSQRSolveSparse
         linlsqrrestart(&s);
         linlsqrsolvesparse(&s, &spa, &b);
         linlsqrresults(&s, &x0, &rep);
         if (!testlinlsqrunit_isitgoodsolution(&a, &b, m, n, lambdai, &x0, testlinlsqrunit_e0, testlinlsqrunit_tolort)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   }
   if (!silent) {
      printf("SVDTest: Ok\n");
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// The test checks that algorithm can solve MxN (with N <= M)  well-conditioned
// problems - and can do so within exactly  N  iterations.  We  use  moderate
// condition numbers, from 1.0 to 10.0, because larger condition  number  may
// require several additional iterations to converge.
//
// We try different scalings of the A and B.
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_mwcranksvdtest() {
   ae_frame _frame_block;
   double bnorm;
   ae_int_t szm;
   ae_int_t n;
   ae_int_t m;
   ae_int_t ns0;
   ae_int_t ns1;
   ae_int_t nlambdai;
   double s0;
   double s1;
   double lambdai;
   double c;
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   szm = 5;
   for (m = 1; m <= szm; m++) {
      for (n = 1; n <= m; n++) {
         for (nlambdai = 0; nlambdai <= 3; nlambdai++) {
            for (ns0 = -1; ns0 <= 1; ns0++) {
               for (ns1 = -1; ns1 <= 1; ns1++) {
               // Generate problem:
               // * scale factors s0, s1
               // * MxN well conditioned A (with condition number C in [1,10] and norm s0)
               // * regularization coefficient LambdaI
               // * right part b, with |b| == s1
                  s0 = pow(10.0, (double)(10 * ns0));
                  s1 = pow(10.0, (double)(10 * ns1));
                  lambdai = 0.0;
                  if (nlambdai == 0) {
                     lambdai = 0.0;
                  }
                  if (nlambdai == 1) {
                     lambdai = s0 / 1000;
                  }
                  if (nlambdai == 2) {
                     lambdai = s0;
                  }
                  if (nlambdai == 3) {
                     lambdai = s0 * 1000;
                  }
                  c = (10 - 1) * randomreal() + 1;
                  rmatrixrndcond(m, c, &a);
                  for (i = 0; i < m; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] *= s0;
                     }
                  }
                  ae_vector_set_length(&b, m);
                  do {
                     bnorm = 0.0;
                     for (i = 0; i < m; i++) {
                        b.xR[i] = randommid();
                        bnorm += b.xR[i] * b.xR[i];
                     }
                     bnorm = sqrt(bnorm);
                  } while (bnorm <= testlinlsqrunit_e0);
                  for (i = 0; i < m; i++) {
                     b.xR[i] = b.xR[i] * s1 / bnorm;
                  }
               // Solve by LSQR method
                  linlsqrcreate(m, n, &s);
                  linlsqrsetb(&s, &b);
                  linlsqrsetcond(&s, 0.0, 0.0, n);
                  linlsqrsetlambdai(&s, lambdai);
                  while (linlsqriteration(&s))
                     if (s.needmv) {
                        for (i = 0; i < m; i++) {
                           s.mv.xR[i] = 0.0;
                           for (j = 0; j < n; j++) {
                              s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                           }
                        }
                     } else if (s.needmtv) {
                        for (i = 0; i < n; i++) {
                           s.mtv.xR[i] = 0.0;
                           for (j = 0; j < m; j++) {
                              s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                           }
                        }
                     }
                  linlsqrresults(&s, &x0, &rep);
                  if (!testlinlsqrunit_isitgoodsolution(&a, &b, m, n, lambdai, &x0, testlinlsqrunit_e0, testlinlsqrunit_tolort)) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
               }
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// The test checks that algorithm can find a solution with minimum norm for a
// singular rectangular problem. System matrix has special property - singular
// values are either zero or well separated from zero.
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_mwicranksvdtest() {
   ae_frame _frame_block;
   double bnorm;
   ae_int_t szm;
   ae_int_t n;
   ae_int_t m;
   ae_int_t nz;
   ae_int_t ns0;
   ae_int_t ns1;
   ae_int_t nlambdai;
   double s0;
   double s1;
   double lambdai;
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewObj(sparsematrix, spa);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   Ok = true;
   szm = 5;
   for (m = 1; m <= szm; m++) {
      for (n = 1; n <= m; n++) {
         for (nlambdai = 0; nlambdai <= 2; nlambdai++) {
            for (ns0 = -1; ns0 <= 1; ns0++) {
               for (ns1 = -1; ns1 <= 1; ns1++) {
                  for (nz = 0; nz < n; nz++) {
                  // Generate problem:
                  // * scale coefficients s0, s1
                  // * regularization coefficient LambdaI
                  // * MxN matrix A, norm(A) == s0, with NZ zero singular values and N-NZ nonzero ones
                  // * right part b with norm(b) == s1
                     s0 = pow(10.0, (double)(10 * ns0));
                     s1 = pow(10.0, (double)(10 * ns1));
                     lambdai = 0.0;
                     if (nlambdai == 0) {
                        lambdai = 0.0;
                     }
                     if (nlambdai == 1) {
                        lambdai = s0;
                     }
                     if (nlambdai == 2) {
                        lambdai = s0 * 1000;
                     }
                     ae_matrix_set_length(&a, m, n);
                     for (i = 0; i < m; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] = 0.0;
                        }
                     }
                     for (i = 0; i < n - nz; i++) {
                        a.xyR[i][i] = s0 * (0.1 + 0.9 * randomreal());
                     }
                     rmatrixrndorthogonalfromtheleft(&a, m, n);
                     rmatrixrndorthogonalfromtheright(&a, m, n);
                     ae_vector_set_length(&b, m);
                     do {
                        bnorm = 0.0;
                        for (i = 0; i < m; i++) {
                           b.xR[i] = randommid();
                           bnorm += b.xR[i] * b.xR[i];
                        }
                        bnorm = sqrt(bnorm);
                     } while (bnorm <= testlinlsqrunit_e0);
                     for (i = 0; i < m; i++) {
                        b.xR[i] = b.xR[i] * s1 / bnorm;
                     }
                  // Solve by LSQR method
                     linlsqrcreate(m, n, &s);
                     linlsqrsetb(&s, &b);
                     linlsqrsetcond(&s, testlinlsqrunit_emergencye0, testlinlsqrunit_emergencye0, n);
                     linlsqrsetlambdai(&s, lambdai);
                     while (linlsqriteration(&s))
                        if (s.needmv) {
                           for (i = 0; i < m; i++) {
                              s.mv.xR[i] = 0.0;
                              for (j = 0; j < n; j++) {
                                 s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                              }
                           }
                        } else if (s.needmtv) {
                           for (i = 0; i < n; i++) {
                              s.mtv.xR[i] = 0.0;
                              for (j = 0; j < m; j++) {
                                 s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                              }
                           }
                        }
                     linlsqrresults(&s, &x0, &rep);
                  // Check
                     if (!testlinlsqrunit_isitgoodsolution(&a, &b, m, n, lambdai, &x0, testlinlsqrunit_e0, testlinlsqrunit_tolort)) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  }
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// The test does check, that algorithm can find a solution with minimum norm,
// if a problem has bidiagonal matrix on diagonals of a lot of zeros. This
// problem has to lead to case when State.Alpha and State.Beta are zero, and we
// we can be sure that the algorithm correctly handles it.
//
// We do not use iteration count as stopping condition, because problem can
// be degenerate and we may need more than N iterations to converge.
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_bidiagonaltest() {
   ae_frame _frame_block;
   double bnorm;
   ae_int_t sz;
   ae_int_t n;
   ae_int_t m;
   ae_int_t minmn;
   ae_int_t ns0;
   ae_int_t ns1;
   double s0;
   double s1;
   ae_int_t i;
   ae_int_t j;
   ae_int_t p;
   ae_int_t diag;
   double pnz;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   sz = 5;
   for (m = 1; m <= sz; m++) {
      for (n = 1; n <= sz; n++) {
         minmn = imin2(m, n);
         for (p = 0; p <= 2; p++) {
            for (ns0 = -1; ns0 <= 1; ns0++) {
               for (ns1 = -1; ns1 <= 1; ns1++) {
                  for (diag = 0; diag <= 1; diag++) {
                  // Generate problem:
                  // * scaling coefficients s0, s1
                  // * bidiagonal A, with probability of having zero element at diagonal equal to PZ
                     s0 = pow(10.0, (double)(10 * ns0));
                     s1 = pow(10.0, (double)(10 * ns1));
                     pnz = 1.0;
                     if (p == 0) {
                        pnz = 0.75;
                     }
                     if (p == 1) {
                        pnz = 0.5;
                     }
                     if (p == 2) {
                        pnz = 0.25;
                     }
                     ae_matrix_set_length(&a, m, n);
                     for (i = 0; i < m; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] = 0.0;
                        }
                     }
                     for (i = 0; i < minmn; i++) {
                        if (randombool(pnz)) {
                           a.xyR[i][i] = randommid();
                        }
                     }
                     for (i = 1; i < minmn; i++) {
                        if (randombool(pnz)) {
                           if (diag == 0) {
                              a.xyR[i - 1][i] = randommid();
                           }
                           if (diag == 1) {
                              a.xyR[i][i - 1] = randommid();
                           }
                        }
                     }
                     for (i = 0; i < m; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] *= s0;
                        }
                     }
                     ae_vector_set_length(&b, m);
                     do {
                        bnorm = 0.0;
                        for (i = 0; i < m; i++) {
                           b.xR[i] = randommid();
                           bnorm += b.xR[i] * b.xR[i];
                        }
                        bnorm = sqrt(bnorm);
                     } while (bnorm <= testlinlsqrunit_e0);
                     for (i = 0; i < m; i++) {
                        b.xR[i] = b.xR[i] * s1 / bnorm;
                     }
                  // LSQR solution
                     linlsqrcreate(m, n, &s);
                     linlsqrsetb(&s, &b);
                     linlsqrsetcond(&s, testlinlsqrunit_e0, testlinlsqrunit_e0, 0);
                     while (linlsqriteration(&s))
                        if (s.needmv) {
                           for (i = 0; i < m; i++) {
                              s.mv.xR[i] = 0.0;
                              for (j = 0; j < n; j++) {
                                 s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                              }
                           }
                        } else if (s.needmtv) {
                           for (i = 0; i < n; i++) {
                              s.mtv.xR[i] = 0.0;
                              for (j = 0; j < m; j++) {
                                 s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                              }
                           }
                        }
                     linlsqrresults(&s, &x0, &rep);
                  // Check
                     if (!testlinlsqrunit_isitgoodsolution(&a, &b, m, n, 0.0, &x0, testlinlsqrunit_e0, testlinlsqrunit_tolort)) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  }
               }
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// The test does check, that algorithm correctly solves a problem in cases:
//     1. A == 0, B != 0;
//     2. A != 0, B == 0;
//     3. A == 0, B == 0.
// If some part is not zero then it filled with ones.
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_zeromatrixtest() {
   ae_frame _frame_block;
   ae_int_t sz;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t nzeropart;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   sz = 5;
   Ok = true;
   for (m = 1; m <= sz; m++) {
      for (n = 1; n <= sz; n++) {
         for (nzeropart = 0; nzeropart <= 2; nzeropart++) {
         // Initialize A, b
            ae_matrix_set_length(&a, m, n);
            if (nzeropart == 0 || nzeropart == 2) {
               for (i = 0; i < m; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
            } else {
               for (i = 0; i < m; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 1.0;
                  }
               }
            }
            ae_vector_set_length(&b, m);
            if (nzeropart == 1 || nzeropart == 2) {
               for (i = 0; i < m; i++) {
                  b.xR[i] = 0.0;
               }
            } else {
               for (i = 0; i < m; i++) {
                  b.xR[i] = 1.0;
               }
            }
         // LSQR
            linlsqrcreate(m, n, &s);
            linlsqrsetb(&s, &b);
            linlsqrsetcond(&s, 0.0, 0.0, n);
            while (linlsqriteration(&s))
               if (s.needmv) {
                  for (i = 0; i < m; i++) {
                     s.mv.xR[i] = 0.0;
                     for (j = 0; j < n; j++) {
                        s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                     }
                  }
               } else if (s.needmtv) {
                  for (i = 0; i < n; i++) {
                     s.mtv.xR[i] = 0.0;
                     for (j = 0; j < m; j++) {
                        s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                     }
                  }
               }
            linlsqrresults(&s, &x0, &rep);
         // Check
            if (!testlinlsqrunit_isitgoodsolution(&a, &b, m, n, 0.0, &x0, testlinlsqrunit_e0, testlinlsqrunit_tolort)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// The test does check, that algorithm correctly displays a progress report.
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_reportcorrectnesstest() {
   ae_frame _frame_block;
   double rnorm;
   double tnorm;
   ae_int_t sz;
   ae_int_t n;
   ae_int_t m;
   ae_int_t lambdai;
   double mn;
   double mx;
   double c;
   ae_int_t i;
   ae_int_t j;
   ae_int_t its;
   double tmp;
   double eps;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(u, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(firstx, 0, DT_REAL);
   NewVector(lastx, 0, DT_REAL);
   eps = 0.001;
   sz = 5;
   mn = -100.0;
   mx = 100.0;
   c = 100.0;
   Ok = true;
   for (m = 1; m <= sz; m++) {
      for (n = 1; n <= m; n++) {
         for (lambdai = 0; lambdai <= 1; lambdai++) {
            its = -1;
         // initialize matrix A
            spdmatrixrndcond(m + n, c, &a);
            for (i = m; i < m + n; i++) {
               for (j = 0; j < n; j++) {
                  if (i - m == j) {
                     a.xyR[i][j] = (double)lambdai;
                  } else {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
         // initialize b
            ae_vector_set_length(&b, m + n);
            rnorm = 0.0;
            for (i = 0; i < m + n; i++) {
               if (i < m) {
                  b.xR[i] = (mx - mn) * randomreal() + mn;
                  rnorm += b.xR[i] * b.xR[i];
               } else {
                  b.xR[i] = 0.0;
               }
            }
         // initialize FirstX and LastX
            ae_vector_set_length(&firstx, n);
            ae_vector_set_length(&lastx, n);
         // calculating by LSQR method
            linlsqrcreate(m, n, &s);
            linlsqrsetb(&s, &b);
            linlsqrsetcond(&s, 0.0, 0.0, n);
            linlsqrsetlambdai(&s, (double)lambdai);
            linlsqrsetxrep(&s, true);
            Ok = Ok && linlsqrpeekiterationscount(&s) == 0;
            while (linlsqriteration(&s))
               if (s.needmv) {
                  for (i = 0; i < m; i++) {
                     s.mv.xR[i] = 0.0;
                     for (j = 0; j < n; j++) {
                        s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                     }
                  }
               } else if (s.needmtv) {
                  for (i = 0; i < n; i++) {
                     s.mtv.xR[i] = 0.0;
                     for (j = 0; j < m; j++) {
                        s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                     }
                  }
               } else if (s.xupdated) {
                  tnorm = 0.0;
                  for (i = 0; i < m + n; i++) {
                     tmp = 0.0;
                     for (j = 0; j < n; j++) {
                        tmp += a.xyR[i][j] * s.x.xR[j];
                     }
                     tnorm += (b.xR[i] - tmp) * (b.xR[i] - tmp);
                  }
               // check, that RNorm is't more than S.R2
               // and difference between S.R2 and TNorm
               // is't more than 'eps'(here S.R2 == ||rk||,
               // calculated by the algorithm for LSQR, and
               // TNorm == ||A*S.x-b||, calculated by test function).
                  if (s.r2 > rnorm || !NearAtR(s.r2, tnorm, eps)) {
                     if (!silent) {
                        printf("ReportCorrectnessTest: Failed\n");
                        printf("* TNorm = %0.2e, RNorm = %0.2e, S.R2 = %0.2e\n", tnorm, rnorm, s.r2);
                     }
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
                  rnorm = s.r2;
                  its++;
               // get X value from first iteration
               // and from last iteration.
                  if (its == 0) {
                     for (i = 0; i < n; i++) {
                        firstx.xR[i] = s.x.xR[i];
                     }
                  }
                  if (its == n) {
                     for (i = 0; i < n; i++) {
                        lastx.xR[i] = s.x.xR[i];
                     }
                  }
               // check iterations counter
                  Ok = Ok && linlsqrpeekiterationscount(&s) == its;
               }
            linlsqrresults(&s, &x0, &rep);
            Ok = Ok && linlsqrpeekiterationscount(&s) == n;
         // check, that FirstX is equal to zero and LastX
         // is equal to x0.
            for (i = 0; i < n; i++) {
               if (firstx.xR[i] != 0.0 || lastx.xR[i] != x0.xR[i]) {
                  if (!silent) {
                     printf("ReportCorrectnessTest: Failed\n");
                     printf("* IterationsCount = %0d, NMV = %0d, TerminationType = %0d\n", (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype);
                     printf("* X:");
                     for (j = 0; j < n; j++) {
                        printf(" [%0d] == %0.10e", (int)j, x0.xR[j]);
                     }
                     putchar('\n');
                     printf("* LastX:");
                     for (j = 0; j < n; j++) {
                        printf(" [%0d] == %0.10e", (int)j, lastx.xR[j]);
                     }
                     putchar('\n');
                  }
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      }
   }
   if (!silent) {
      printf("ReportCorrectnessTest: Ok\n");
   }
   ae_frame_leave();
   return Ok;
}

// The test does check, that correctly executed stop criteria by algorithm.
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_stoppingcriteriatest() {
   ae_frame _frame_block;
   double bnorm;
   ae_int_t sz;
   ae_int_t n;
   ae_int_t k0;
   ae_int_t k1;
   double anorm;
   double arknorm;
   double rknorm;
   double mn;
   double mx;
   double c;
   ae_int_t maxits;
   ae_int_t i;
   ae_int_t j;
   double tmp;
   double eps;
   double epsmod;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(u, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(ark, 0, DT_REAL);
   NewVector(rk, 0, DT_REAL);
   sz = 5;
   mn = -100.0;
   mx = 100.0;
   c = 100.0;
   for (n = 1; n <= sz; n++) {
   // Initialize A, unit b
      spdmatrixrndcond(n, c, &a);
      ae_vector_set_length(&b, n);
      bnorm = 0.0;
      for (i = 0; i < n; i++) {
         b.xR[i] = (mx - mn) * randomreal() + mn;
         bnorm += b.xR[i] * b.xR[i];
      }
      bnorm = sqrt(bnorm);
   // Test MaxIts
   //
   // NOTE: we do not check TerminationType because algorithm may terminate for
   // several reasons. The only thing which is guaranteed is that stopping condition
   // MaxIts holds.
      maxits = 1 + randominteger(n);
      linlsqrcreate(n, n, &s);
      linlsqrsetb(&s, &b);
      linlsqrsetcond(&s, 0.0, 0.0, maxits);
      while (linlsqriteration(&s))
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
         } else if (s.needmtv) {
            for (i = 0; i < n; i++) {
               s.mtv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
               }
            }
         }
      linlsqrresults(&s, &x0, &rep);
      if (rep.iterationscount > maxits || rep.terminationtype <= 0) {
         if (!silent) {
            printf("StoppingCriteriaTest: Failed\n");
            printf("* N = %0d, IterationsCount = %0d, NMV = %0d, TerminationType = %0d\n", (int)n, (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype);
         }
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   // Test EpsB.
   // Set EpsB == eps, check that |r| < epsMod*|b|, where epsMod == 1.1*eps.
   // This modified epsilon is used to avoid influence of the numerical errors.
   //
   // NOTE: we do not check TerminationType because algorithm may terminate for
   // several reasons. The only thing which is guaranteed is that stopping condition
   // EpsB holds.
      eps = pow(10.0, (double)-(2 + randominteger(3)));
      epsmod = 1.1 * eps;
      ae_vector_set_length(&rk, n);
      linlsqrcreate(n, n, &s);
      linlsqrsetb(&s, &b);
      linlsqrsetcond(&s, 0.0, eps, 0);
      while (linlsqriteration(&s))
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
         } else if (s.needmtv) {
            for (i = 0; i < n; i++) {
               s.mtv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
               }
            }
         }
      linlsqrresults(&s, &x0, &rep);
      rknorm = 0.0;
      for (i = 0; i < n; i++) {
         tmp = 0.0;
         for (j = 0; j < n; j++) {
            tmp += a.xyR[i][j] * x0.xR[j];
         }
         rknorm += (tmp - b.xR[i]) * (tmp - b.xR[i]);
      }
      rknorm = sqrt(rknorm);
      if (rknorm > epsmod * bnorm || rep.terminationtype <= 0) {
         if (!silent) {
            printf("StoppingCriteriaTest: Failed\n");
            printf("* rkNorm = %0.2e, IterationsCount = %0d, NMV = %0d, TerminationType = %0d\n",
               rknorm, (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype
            );
         }
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
// Test EpsA.
//
// Generate well conditioned underdetermined system with nonzero residual
// at the solution. Such system can be generated by generating random
// orthogonal matrix (N >= 2) and using first N-1 columns as rectangular
// system matrix, and sum of all columns with random non-zero coefficients
// as right part.
   for (n = 2; n <= sz; n++) {
      for (k0 = -1; k0 <= 1; k0++) {
         for (k1 = -1; k1 <= 1; k1++) {
         // Initialize A with non-unit norm 10^(10*K0), b with non-unit norm 10^(10*K1)
            anorm = pow(10.0, (double)(10 * k0));
            rmatrixrndorthogonal(n, &a);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] *= anorm;
               }
            }
            ae_vector_set_length(&b, n);
            for (j = 0; j < n; j++) {
               b.xR[j] = 0.0;
            }
            for (i = 0; i < n; i++) {
               tmp = 1 + randomreal();
               ae_v_addd(b.xR, 1, &a.xyR[0][i], a.stride, n, tmp);
            }
            tmp = 0.0;
            for (i = 0; i < n; i++) {
               tmp += sqr(b.xR[i]);
            }
            tmp = pow(10.0, (double)(10 * k1)) / sqrt(tmp);
            ae_v_muld(b.xR, 1, n, tmp);
         // Test EpsA
         //
         // NOTE: it is guaranteed that algorithm will terminate with correct
         // TerminationType because other stopping criteria (EpsB) won't be satisfied
         // on such system.
            eps = pow(10.0, (double)-(2 + randominteger(3)));
            epsmod = 1.1 * eps;
            linlsqrcreate(n, n - 1, &s);
            linlsqrsetb(&s, &b);
            linlsqrsetcond(&s, eps, 0.0, 0);
            while (linlsqriteration(&s))
               if (s.needmv) {
                  for (i = 0; i < n; i++) {
                     s.mv.xR[i] = 0.0;
                     for (j = 0; j < n - 1; j++) {
                        s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                     }
                  }
               } else if (s.needmtv) {
                  for (i = 0; i < n - 1; i++) {
                     s.mtv.xR[i] = 0.0;
                     for (j = 0; j < n; j++) {
                        s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                     }
                  }
               }
            linlsqrresults(&s, &x0, &rep);
         // Check condition
            ae_vector_set_length(&rk, n);
            ae_vector_set_length(&ark, n - 1);
            rknorm = 0.0;
            for (i = 0; i < n; i++) {
               rk.xR[i] = b.xR[i];
               for (j = 0; j < n - 1; j++) {
                  rk.xR[i] -= a.xyR[i][j] * x0.xR[j];
               }
               rknorm += sqr(rk.xR[i]);
            }
            rknorm = sqrt(rknorm);
            arknorm = 0.0;
            for (i = 0; i < n - 1; i++) {
               ark.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  ark.xR[i] += a.xyR[j][i] * rk.xR[j];
               }
               arknorm += sqr(ark.xR[i]);
            }
            arknorm = sqrt(arknorm);
            if (arknorm / (anorm * rknorm) > epsmod || rep.terminationtype != 4) {
               if (!silent) {
                  printf("StoppingCriteriaTest: Failed\n");
                  printf("* N = %0d, IterationsCount = %0d, NMV = %0d, TerminationType = %0d\n",
                     (int)n, (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype
                  );
               }
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
   if (!silent) {
      printf("StoppingCriteriaTest: Ok\n");
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This test compares LSQR  for  original  system  A*x == b  against  CG  for  a
// modified system (A'*A)x = A*b. Both algorithms should give same  sequences
// of trial points (under exact arithmetics, or  for  very  good  conditioned
// systems).
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_analytictest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t smallk;
   ae_int_t pointsstored;
   double v;
   double tol;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(xk, 0, 0, DT_REAL);
   NewMatrix(ap, 0, 0, DT_REAL);
   NewMatrix(r, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
// Set:
// * SmallK - number of steps to check, must be small number in order
//   to reduce influence of the rounding errors
// * Tol - error tolerance for orthogonality/conjugacy criteria
   Ok = true;
   smallk = 4;
   tol = 1.0E-7;
   for (m = smallk; m <= smallk + 5; m++) {
      for (n = smallk; n <= m; n++) {
      // Prepare problem:
      // * MxN matrix A, Mx1 vector B
      // * A is filled with random values from [-1,+1]
      // * diagonal elements are filled with large positive values
      //   (should make system better conditioned)
         ae_matrix_set_length(&a, m, n);
         ae_vector_set_length(&b, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = randommid();
            }
            b.xR[i] = randommid();
         }
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 10 * (1 + randomreal());
         }
      // Solve with LSQR, save trial points into XK[] array
         ae_matrix_set_length(&xk, smallk + 1, n);
         linlsqrcreate(m, n, &s);
         linlsqrsetb(&s, &b);
         linlsqrsetcond(&s, 0.0, 0.0, smallk);
         linlsqrsetxrep(&s, true);
         pointsstored = 0;
         while (linlsqriteration(&s))
            if (s.needmv) {
               for (i = 0; i < m; i++) {
                  s.mv.xR[i] = 0.0;
                  for (j = 0; j < n; j++) {
                     s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                  }
               }
            } else if (s.needmtv) {
               for (i = 0; i < n; i++) {
                  s.mtv.xR[i] = 0.0;
                  for (j = 0; j < m; j++) {
                     s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                  }
               }
            } else if (s.xupdated) {
               ae_assert(pointsstored < xk.rows, "LinLSQR test: internal error");
               ae_v_move(xk.xyR[pointsstored], 1, s.x.xR, 1, n);
               pointsstored++;
            }
         if (pointsstored < 3) {
         // At least two iterations should be performed
         // (our task is not that easy to solve)
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      // We have recorded sequence of points generated by LSQR,
      // and now we want to make a comparion against linear CG.
      //
      // Of course, we could just perform CG solution of (A'*A)*x = A'*b,
      // but it will need a CG solver, and we do not want to reference one
      // just to perform testing.
      //
      // However, we can do better - we can check that sequence of steps
      // satisfies orthogonality/conjugacy conditions, which are stated
      // as follows:
      // * (r[i]^T)*r[j] == 0 for i != j
      // * (p[i]^T)*A'*A*p[j] == 0 for i != j
      // where r[i] == (A'*A)*x[i]-A'*b is I-th residual , p[i] is I-th step.
      //
      // In order to test these criteria we generate two matrices:
      // * (PointsStored-1)*M matrix AP (matrix of A*p products)
      // * (PointsStored-1)*N matrix R  (matrix of residuals)
      // Then, we check that each matrix has orthogonal rows.
         ae_matrix_set_length(&ap, pointsstored - 1, m);
         ae_matrix_set_length(&r, pointsstored - 1, n);
         ae_vector_set_length(&tmp, m);
         for (k = 0; k < pointsstored - 1; k++) {
         // Calculate K-th row of AP
            for (i = 0; i < m; i++) {
               ap.xyR[k][i] = 0.0;
               for (j = 0; j < n; j++) {
                  ap.xyR[k][i] += a.xyR[i][j] * (xk.xyR[k + 1][j] - xk.xyR[k][j]);
               }
            }
         // Calculate K-th row of R
            for (i = 0; i < m; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xk.xyR[k], 1, n);
               tmp.xR[i] = v - b.xR[i];
            }
            for (j = 0; j < n; j++) {
               v = ae_v_dotproduct(&a.xyR[0][j], a.stride, tmp.xR, 1, m);
               r.xyR[k][j] = v;
            }
         }
         for (i = 0; i < pointsstored - 1; i++) {
            for (j = 0; j < pointsstored - 1; j++) {
               if (i != j) {
                  v = ae_v_dotproduct(ap.xyR[i], 1, ap.xyR[j], 1, m);
                  Ok = Ok && SmallAtR(v, tol);
                  v = ae_v_dotproduct(r.xyR[i], 1, r.xyR[j], 1, n);
                  Ok = Ok && SmallAtR(v, tol);
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// This test checks behavior of the termination requests.
// ALGLIB: Copyright 16.11.2018 by Sergey Bochkanov
static bool testlinlsqrunit_testterminationrequests() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t m;
   ae_int_t callsleft;
   ae_int_t reportsafterrequest;
   bool firstpointreported;
   ae_int_t i;
   ae_int_t j;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewObj(hqrndstate, rs);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   hqrndrandomize(&rs);
   for (pass = 1; pass <= 50; pass++) {
   // Prepare problem
      callsleft = 1 + hqrnduniformi(&rs, 10);
      n = callsleft + 100 + hqrnduniformi(&rs, 50);
      m = n + hqrnduniformi(&rs, 50);
      ae_matrix_set_length(&a, m, n);
      ae_vector_set_length(&b, m);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
         b.xR[i] = hqrndnormal(&rs);
      }
   // Solve with LSQR, terminate after specified amount of A*x/A^T*x requests.
      linlsqrcreate(m, n, &s);
      linlsqrsetb(&s, &b);
      linlsqrsetcond(&s, 0.0, 0.0, n);
      linlsqrsetxrep(&s, true);
      firstpointreported = false;
      reportsafterrequest = 0;
      while (linlsqriteration(&s))
         if (s.needmv) {
            for (i = 0; i < m; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
            if (firstpointreported) {
               callsleft--;
            }
            if (callsleft == 0) {
               linlsqrrequesttermination(&s);
            }
         } else if (s.needmtv) {
            for (i = 0; i < n; i++) {
               s.mtv.xR[i] = 0.0;
               for (j = 0; j < m; j++) {
                  s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
               }
            }
            if (firstpointreported) {
               callsleft--;
            }
            if (callsleft == 0) {
               linlsqrrequesttermination(&s);
            }
         } else if (s.xupdated) {
            firstpointreported = true;
            if (callsleft <= 0) {
               reportsafterrequest++;
            }
         }
      linlsqrresults(&s, &x1, &rep);
      Ok = Ok && rep.terminationtype == 8;
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && reportsafterrequest == 1;
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing preconditioned LSQR method.
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_preconditionertest() {
   ae_frame _frame_block;
   bool bflag;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ta, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewVector(b, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
// Test 1.
//
// We test automatic diagonal preconditioning used by SolveSparse.
// In order to do so we:
// 1. generate 20*20 matrix A0 with condition number equal to 1.0E1
// 2. generate random "exact" solution xe and right part b == A0*xe
// 3. generate random ill-conditioned diagonal scaling matrix D with
//    condition number equal to 1.0E50:
// 4. transform A*x == b into badly scaled problem:
//    A0*x0 == b0
//    (A0*D)*(inv(D)*x0) == b0
//    finally we got new problem A*x == b with A == A0*D, b == b0, x == inv(D)*x0
//
// Then we solve A*x == b:
// 1. with default preconditioner
// 2. with explicitly activayed diagonal preconditioning
// 3. with unit preconditioner.
// 1st and 2nd solutions must be close to xe, 3rd solution must be very
// far from the true one.
   n = 20;
   rmatrixrndcond(n, 1.0E1, &ta);
   ae_vector_set_length(&xe, n);
   for (i = 0; i < n; i++) {
      xe.xR[i] = randomnormal();
   }
   ae_vector_set_length(&b, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = 0.0;
      for (j = 0; j < n; j++) {
         b.xR[i] += ta.xyR[i][j] * xe.xR[j];
      }
   }
   ae_vector_set_length(&d, n);
   for (i = 0; i < n; i++) {
      d.xR[i] = pow(10.0, 50.0 * randommid());
   }
   ae_matrix_set_length(&a, n, n);
   sparsecreate(n, n, n * n, &sa);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a.xyR[i][j] = ta.xyR[i][j] * d.xR[j];
         sparseset(&sa, i, j, a.xyR[i][j]);
      }
      xe.xR[i] /= d.xR[i];
   }
   sparseconverttocrs(&sa);
   linlsqrcreate(n, n, &s);
   linlsqrsetcond(&s, 0.0, 0.0, 2 * n);
   linlsqrsolvesparse(&s, &sa, &b);
   linlsqrresults(&s, &x0, &rep);
   if (rep.terminationtype <= 0) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   for (i = 0; i < n; i++) {
      if (!NearAtR(xe.xR[i], x0.xR[i], 5.0E-2 / d.xR[i])) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   linlsqrsetprecunit(&s);
   linlsqrsolvesparse(&s, &sa, &b);
   linlsqrresults(&s, &x0, &rep);
   if (rep.terminationtype > 0) {
      bflag = false;
      for (i = 0; i < n; i++) {
         bflag = bflag || !NearAtR(xe.xR[i], x0.xR[i], 5.0E-2 / d.xR[i]);
      }
      if (!bflag) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   linlsqrsetprecdiag(&s);
   linlsqrsolvesparse(&s, &sa, &b);
   linlsqrresults(&s, &x0, &rep);
   if (rep.terminationtype <= 0) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   for (i = 0; i < n; i++) {
      if (!NearAtR(xe.xR[i], x0.xR[i], 5.0E-2 / d.xR[i])) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
// test has been passed
   Ok = true;
   ae_frame_leave();
   return Ok;
}

bool testlinlsqr() {
   bool svdtestOk;
   bool mwcranksvdOk;
   bool mwicranksvdOk;
   bool bidiagonalOk;
   bool zeromatrixOk;
   bool reportcorrectnessOk;
   bool stoppingcriteriaOk;
   bool analytictestOk;
   bool prectestOk;
   bool termreqOk;
   bool Ok;
   if (!silent) printf("LinLSQR Test Breakdown\n");
   termreqOk = true;
   svdtestOk = testlinlsqrunit_svdtest();
   mwcranksvdOk = testlinlsqrunit_mwcranksvdtest();
   mwicranksvdOk = testlinlsqrunit_mwicranksvdtest();
   bidiagonalOk = testlinlsqrunit_bidiagonaltest();
   zeromatrixOk = testlinlsqrunit_zeromatrixtest();
   reportcorrectnessOk = testlinlsqrunit_reportcorrectnesstest();
   stoppingcriteriaOk = testlinlsqrunit_stoppingcriteriatest();
   analytictestOk = testlinlsqrunit_analytictest();
   prectestOk = testlinlsqrunit_preconditionertest();
   termreqOk = termreqOk && testlinlsqrunit_testterminationrequests();
// The final report.
   Ok = svdtestOk && mwcranksvdOk && mwicranksvdOk && bidiagonalOk && zeromatrixOk && reportcorrectnessOk && stoppingcriteriaOk && analytictestOk && prectestOk && termreqOk;
   if (!Ok || !silent) {
      printf("LinLSQR Tests\n");
      printf("Different Matrix Types:\n");
      printf("* General M x N:                          %s\n", svdtestOk? "Ok": "Failed");
      printf("* Well-Conditioned M x N:                 %s\n", mwcranksvdOk? "Ok": "Failed");
      printf("* Rank Deficient M x N:                   %s\n", mwicranksvdOk? "Ok": "Failed");
      printf("* Sparse Bi-Diagonal:                     %s\n", bidiagonalOk? "Ok": "Failed");
      printf("* Zero:                                   %s\n", zeromatrixOk? "Ok": "Failed");
      printf("Other Properties:\n");
      printf("* Report Correctness:                     %s\n", reportcorrectnessOk? "Ok": "Failed");
      printf("* Stopping Criteria:                      %s\n", stoppingcriteriaOk? "Ok": "Failed");
      printf("* Analytic Properties:                    %s\n", analytictestOk? "Ok": "Failed");
      printf("* Preconditioner Test:                    %s\n", prectestOk? "Ok": "Failed");
      printf("* Termination Requests:                   %s\n", termreqOk? "Ok": "Failed");
   // was errors?
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === linmin testing unit ===
bool testlinmin() {
   bool Ok;
// The final report.
   Ok = true;
   if (!Ok || !silent) {
      printf("LinMin Test\n");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === nleq testing unit ===
// Himmelblau's function
//
//     F = (x^2+y-11)^2 + (x+y^2-7)^2
//
// posed as system of M functions:
//
//     f0 = x^2+y-11
//     f1 = x+y^2-7
//
static void testnlequnit_testfunchbm(nleqstate *state) {
   double x = state->x.xR[0], y = state->x.xR[1];
   if (state->needf) {
      state->f = sqr(x * x + y - 11) + sqr(x + y * y - 7);
   } else if (state->needfij) {
      state->fi.xR[0] = x * x + y - 11;
      state->fi.xR[1] = x + y * y - 7;
      state->j.xyR[0][0] = 2 * x;
      state->j.xyR[0][1] = 1.0;
      state->j.xyR[1][0] = 1.0;
      state->j.xyR[1][1] = 2 * y;
   } else ae_assert(false, "testnlequnit_testfunchbm: internal error!");
}

// Himmelblau's function
//
//     F = (x^2+y-11)^2 + (x+y^2-7)^2
//
// posed as system of 1 function
static void testnlequnit_testfunchb1(nleqstate *state) {
   double x = state->x.xR[0], y = state->x.xR[1];
   if (state->needf) {
      state->f = sqr(sqr(x * x + y - 11) + sqr(x + y * y - 7));
   } else if (state->needfij) {
      state->fi.xR[0] = sqr(x * x + y - 11) + sqr(x + y * y - 7);
      state->j.xyR[0][0] = 2 * (x * x + y - 11) * 2 * x + 2 * (x + y * y - 7);
      state->j.xyR[0][1] = 2 * (x * x + y - 11) + 2 * (x + y * y - 7) * 2 * y;
   } else ae_assert(false, "testnlequnit_testfunchb1: internal error!");
}

// Shifted Himmelblau's function
//
//     F = (x^2+y-11)^2 + (x+y^2-7)^2 + 1
//
// posed as system of M functions:
//
//     f0 = x^2+y-11
//     f1 = x+y^2-7
//     f2 = 1
//
// This function is used to test algorithm on problem which has no solution.
static void testnlequnit_testfuncshbm(nleqstate *state) {
   double x = state->x.xR[0], y = state->x.xR[1];
   if (state->needf) {
      state->f = sqr(x * x + y - 11) + sqr(x + y * y - 7) + 1;
   } else if (state->needfij) {
      state->fi.xR[0] = x * x + y - 11;
      state->fi.xR[1] = x + y * y - 7;
      state->fi.xR[2] = 1.0;
      state->j.xyR[0][0] = 2 * x;
      state->j.xyR[0][1] = 1.0;
      state->j.xyR[1][0] = 1.0;
      state->j.xyR[1][1] = 2 * y;
      state->j.xyR[2][0] = 0.0;
      state->j.xyR[2][1] = 0.0;
   } else ae_assert(false, "testnlequnit_testfuncshbm: internal error!");
}

bool testnleq() {
   ae_frame _frame_block;
   bool Ok;
   bool basicsOk;
   bool convOk;
   bool otherOk;
   ae_int_t n;
   ae_int_t i;
   ae_int_t k;
   double v;
   double flast;
   bool firstrep;
   ae_int_t nfunc;
   ae_int_t njac;
   ae_int_t itcnt;
   ae_int_t pass;
   ae_int_t passcount;
   double epsf;
   double stpmax;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewObj(nleqstate, state);
   NewObj(nleqreport, rep);
   Ok = true;
   basicsOk = true;
   convOk = true;
   otherOk = true;
// Basic tests
//
// Test with Himmelblau's function (M):
// * ability to find correct result
// * ability to work after soft restart (restart after finish)
// * ability to work after hard restart (restart in the middle of optimization)
   passcount = 100;
   for (pass = 0; pass < passcount; pass++) {
   // Ability to find correct result
      ae_vector_set_length(&x, 2);
      x.xR[0] = 10.0 * randommid();
      x.xR[1] = 10.0 * randommid();
      nleqcreatelm(2, 2, &x, &state);
      epsf = 1.0E-9;
      nleqsetcond(&state, epsf, 0);
      while (nleqiteration(&state)) testnlequnit_testfunchbm(&state);
      nleqresults(&state, &x, &rep);
      if (rep.terminationtype > 0) {
         basicsOk = basicsOk && sqr(x.xR[0] * x.xR[0] + x.xR[1] - 11) + sqr(x.xR[0] + x.xR[1] * x.xR[1] - 7) <= sqr(epsf);
      } else {
         basicsOk = false;
      }
   // Ability to work after soft restart
      ae_vector_set_length(&x, 2);
      x.xR[0] = 10.0 * randommid();
      x.xR[1] = 10.0 * randommid();
      nleqcreatelm(2, 2, &x, &state);
      epsf = 1.0E-9;
      nleqsetcond(&state, epsf, 0);
      while (nleqiteration(&state)) testnlequnit_testfunchbm(&state);
      nleqresults(&state, &x, &rep);
      ae_vector_set_length(&x, 2);
      x.xR[0] = 10.0 * randommid();
      x.xR[1] = 10.0 * randommid();
      for (nleqrestartfrom(&state, &x); nleqiteration(&state); ) testnlequnit_testfunchbm(&state);
      nleqresults(&state, &x, &rep);
      if (rep.terminationtype > 0) {
         basicsOk = basicsOk && sqr(x.xR[0] * x.xR[0] + x.xR[1] - 11) + sqr(x.xR[0] + x.xR[1] * x.xR[1] - 7) <= sqr(epsf);
      } else {
         basicsOk = false;
      }
   // Ability to work after hard restart:
   // * stopping condition: small F
   // * StpMax is so small that we need about 10000 iterations to
   //   find solution (steps are small)
   // * choose random K significantly less that 9999
   // * iterate for some time, then break, restart optimization
      ae_vector_set_length(&x, 2);
      x.xR[0] = 100.0;
      x.xR[1] = 100.0;
      nleqcreatelm(2, 2, &x, &state);
      epsf = 1.0E-9;
      nleqsetcond(&state, epsf, 0);
      nleqsetstpmax(&state, 0.01);
      k = 1 + randominteger(100);
      for (i = 0; i < k && nleqiteration(&state); i++) testnlequnit_testfunchbm(&state);
      ae_vector_set_length(&x, 2);
      x.xR[0] = 10.0 * randommid();
      x.xR[1] = 10.0 * randommid();
      for (nleqrestartfrom(&state, &x); nleqiteration(&state); ) testnlequnit_testfunchbm(&state);
      nleqresults(&state, &x, &rep);
      if (rep.terminationtype > 0) {
         basicsOk = basicsOk && sqr(x.xR[0] * x.xR[0] + x.xR[1] - 11) + sqr(x.xR[0] + x.xR[1] * x.xR[1] - 7) <= sqr(epsf);
      } else {
         basicsOk = false;
      }
   }
// Basic tests
//
// Test with Himmelblau's function (1):
// * ability to find correct result
   passcount = 100;
   for (pass = 0; pass < passcount; pass++) {
   // Ability to find correct result
      ae_vector_set_length(&x, 2);
      x.xR[0] = 10.0 * randommid();
      x.xR[1] = 10.0 * randommid();
      nleqcreatelm(2, 1, &x, &state);
      epsf = 1.0E-9;
      nleqsetcond(&state, epsf, 0);
      while (nleqiteration(&state)) testnlequnit_testfunchb1(&state);
      nleqresults(&state, &x, &rep);
      if (rep.terminationtype > 0) {
         basicsOk = basicsOk && sqr(x.xR[0] * x.xR[0] + x.xR[1] - 11) + sqr(x.xR[0] + x.xR[1] * x.xR[1] - 7) <= epsf;
      } else {
         basicsOk = false;
      }
   }
// Basic tests
//
// Ability to detect situation when we can't find minimum
   passcount = 100;
   for (pass = 0; pass < passcount; pass++) {
      ae_vector_set_length(&x, 2);
      x.xR[0] = 10.0 * randommid();
      x.xR[1] = 10.0 * randommid();
      nleqcreatelm(2, 3, &x, &state);
      epsf = 1.0E-9;
      nleqsetcond(&state, epsf, 0);
      while (nleqiteration(&state)) testnlequnit_testfuncshbm(&state);
      nleqresults(&state, &x, &rep);
      basicsOk = basicsOk && rep.terminationtype == -4;
   }
// Test correctness of intermediate reports and final report:
// * first report is starting point
// * function value decreases on subsequent reports
// * function value is correctly reported
// * last report is final point
// * NFunc and NJac are compared with values counted directly
// * IterationsCount is compared with value counter directly
   n = 2;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&xlast, n);
   x.xR[0] = 10.0 * randommid();
   x.xR[1] = 10.0 * randommid();
   xlast.xR[0] = maxrealnumber;
   xlast.xR[1] = maxrealnumber;
   nleqcreatelm(n, 2, &x, &state);
   nleqsetcond(&state, 1.0E-6, 0);
   nleqsetxrep(&state, true);
   firstrep = true;
   flast = maxrealnumber;
   nfunc = 0;
   njac = 0;
   itcnt = 0;
   while (nleqiteration(&state))
      if (state.xupdated) {
      // first report must be starting point
         if (firstrep) {
            for (i = 0; i < n; i++) {
               otherOk = otherOk && state.x.xR[i] == x.xR[i];
            }
            firstrep = false;
         }
      // function value must decrease
         otherOk = otherOk && state.f <= flast;
      // check correctness of function value
         v = sqr(state.x.xR[0] * state.x.xR[0] + state.x.xR[1] - 11) + sqr(state.x.xR[0] + state.x.xR[1] * state.x.xR[1] - 7);
         otherOk = otherOk && NearAtR(v, state.f, rmax2(v, 1.0) * 100.0 * machineepsilon);
      // update info and continue
         ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
         flast = state.f;
         itcnt++;
      } else if (state.needf || state.needfij) {
         nfunc++;
         if (state.needfij) njac++;
         testnlequnit_testfunchbm(&state);
      }
   nleqresults(&state, &x, &rep);
   if (rep.terminationtype > 0) {
      otherOk = otherOk && xlast.xR[0] == x.xR[0] && xlast.xR[1] == x.xR[1];
      v = sqr(x.xR[0] * x.xR[0] + x.xR[1] - 11) + sqr(x.xR[0] + x.xR[1] * x.xR[1] - 7);
      otherOk = otherOk && NearAtR(flast, v, rmax2(v, 1.0) * 100.0 * machineepsilon);
   } else {
      convOk = false;
   }
   otherOk = otherOk && rep.nfunc == nfunc;
   otherOk = otherOk && rep.njac == njac;
   otherOk = otherOk && rep.iterationscount == itcnt - 1;
// Test ability to set limit on algorithm steps
   ae_vector_set_length(&x, 2);
   ae_vector_set_length(&xlast, 2);
   x.xR[0] = 20.0 * randomreal() + 20;
   x.xR[1] = 20.0 * randomreal() + 20;
   xlast.xR[0] = x.xR[0];
   xlast.xR[1] = x.xR[1];
   stpmax = 0.1 + 0.1 * randomreal();
   epsf = 1.0E-9;
   nleqcreatelm(2, 2, &x, &state);
   nleqsetstpmax(&state, stpmax);
   nleqsetcond(&state, epsf, 0);
   nleqsetxrep(&state, true);
   while (nleqiteration(&state)) {
      if (state.needf || state.needfij) {
         testnlequnit_testfunchbm(&state);
      }
      if (state.needf || state.needfij || state.xupdated) {
         otherOk = otherOk && sqrt(sqr(state.x.xR[0] - xlast.xR[0]) + sqr(state.x.xR[1] - xlast.xR[1])) <= 1.00001 * stpmax;
      }
      if (state.xupdated) {
         xlast.xR[0] = state.x.xR[0];
         xlast.xR[1] = state.x.xR[1];
      }
   }
// The final report.
   Ok = basicsOk && convOk && otherOk;
   if (!Ok || !silent) {
      printf("NL-EQ Solver Tests\n");
      printf("Basic Functionality:                      %s\n", basicsOk? "Ok": "Failed");
      printf("Convergence:                              %s\n", convOk? "Ok": "Failed");
      printf("Other Properties:                         %s\n", otherOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === matinv testing unit ===
// Copy
static void testmatinvunit_rmatrixmakeacopy(RMatrix *a, ae_int_t m, ae_int_t n, RMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyR[i][j] = a->xyR[i][j];
      }
   }
}

// Copy
static void testmatinvunit_cmatrixmakeacopy(CMatrix *a, ae_int_t m, ae_int_t n, CMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyC[i][j] = a->xyC[i][j];
      }
   }
}

// Checks whether inverse is correct
static bool testmatinvunit_rmatrixcheckinverse(RMatrix *a, RMatrix *inva, ae_int_t n, double threshold, ae_int_t info, matinvreport *rep) {
   ae_int_t i;
   ae_int_t j;
   double v;
   bool Ok;
   Ok = true;
   if (info <= 0) {
      Ok = false;
   } else {
      Ok = Ok && rep->r1 >= 100.0 * machineepsilon && rep->r1 <= 1.0 + 1000.0 * machineepsilon;
      Ok = Ok && rep->rinf >= 100.0 * machineepsilon && rep->rinf <= 1.0 + 1000.0 * machineepsilon;
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            v = ae_v_dotproduct(a->xyR[i], 1, &inva->xyR[0][j], inva->stride, n);
            if (i == j) {
               v--;
            }
            Ok = Ok && SmallAtR(v, threshold);
         }
      }
   }
   return Ok;
}

// Checks whether inverse is correct
static bool testmatinvunit_cmatrixcheckinverse(CMatrix *a, CMatrix *inva, ae_int_t n, double threshold, ae_int_t info, matinvreport *rep) {
   ae_int_t i;
   ae_int_t j;
   complex v;
   bool Ok;
   Ok = true;
   if (info <= 0) {
      Ok = false;
   } else {
      Ok = Ok && rep->r1 >= 100.0 * machineepsilon && rep->r1 <= 1.0 + 1000.0 * machineepsilon;
      Ok = Ok && rep->rinf >= 100.0 * machineepsilon && rep->rinf <= 1.0 + 1000.0 * machineepsilon;
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            v = ae_v_cdotproduct(a->xyC[i], 1, "N", &inva->xyC[0][j], inva->stride, "N", n);
            if (i == j) {
               v = ae_c_sub_d(v, 1);
            }
            Ok = Ok && SmallAtC(v, threshold);
         }
      }
   }
   return Ok;
}

// Checks whether inverse is correct
static bool testmatinvunit_spdmatrixcheckinverse(RMatrix *a, RMatrix *inva, bool isupper, ae_int_t n, double threshold, ae_int_t info, matinvreport *rep) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   bool Ok;
   ae_frame_make(&_frame_block);
   DupMatrix(a);
   DupMatrix(inva);
   for (i = 0; i < n - 1; i++) {
      if (isupper) {
         ae_v_move(&a->xyR[i + 1][i], a->stride, &a->xyR[i][i + 1], 1, n - i - 1);
         ae_v_move(&inva->xyR[i + 1][i], inva->stride, &inva->xyR[i][i + 1], 1, n - i - 1);
      } else {
         ae_v_move(&a->xyR[i][i + 1], 1, &a->xyR[i + 1][i], a->stride, n - i - 1);
         ae_v_move(&inva->xyR[i][i + 1], 1, &inva->xyR[i + 1][i], inva->stride, n - i - 1);
      }
   }
   Ok = true;
   if (info <= 0) {
      Ok = false;
   } else {
      Ok = Ok && rep->r1 >= 100.0 * machineepsilon && rep->r1 <= 1.0 + 1000.0 * machineepsilon;
      Ok = Ok && rep->rinf >= 100.0 * machineepsilon && rep->rinf <= 1.0 + 1000.0 * machineepsilon;
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            v = ae_v_dotproduct(a->xyR[i], 1, &inva->xyR[0][j], inva->stride, n);
            if (i == j) {
               v--;
            }
            Ok = Ok && SmallAtR(v, threshold);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Checks whether inverse is correct
static bool testmatinvunit_hpdmatrixcheckinverse(CMatrix *a, CMatrix *inva, bool isupper, ae_int_t n, double threshold, ae_int_t info, matinvreport *rep) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   complex v;
   bool Ok;
   ae_frame_make(&_frame_block);
   DupMatrix(a);
   DupMatrix(inva);
   for (i = 0; i < n - 1; i++) {
      if (isupper) {
         ae_v_cmove(&a->xyC[i + 1][i], a->stride, &a->xyC[i][i + 1], 1, "Conj", n - i - 1);
         ae_v_cmove(&inva->xyC[i + 1][i], inva->stride, &inva->xyC[i][i + 1], 1, "Conj", n - i - 1);
      } else {
         ae_v_cmove(&a->xyC[i][i + 1], 1, &a->xyC[i + 1][i], a->stride, "Conj", n - i - 1);
         ae_v_cmove(&inva->xyC[i][i + 1], 1, &inva->xyC[i + 1][i], inva->stride, "Conj", n - i - 1);
      }
   }
   Ok = true;
   if (info <= 0) {
      Ok = false;
   } else {
      Ok = Ok && rep->r1 >= 100.0 * machineepsilon && rep->r1 <= 1.0 + 1000.0 * machineepsilon;
      Ok = Ok && rep->rinf >= 100.0 * machineepsilon && rep->rinf <= 1.0 + 1000.0 * machineepsilon;
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            v = ae_v_cdotproduct(a->xyC[i], 1, "N", &inva->xyC[0][j], inva->stride, "N", n);
            if (i == j) {
               v = ae_c_sub_d(v, 1);
            }
            Ok = Ok && SmallAtC(v, threshold);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Checks whether inversion result indicate singular matrix
static bool testmatinvunit_rmatrixcheckinversesingular(RMatrix *inva, ae_int_t n, double threshold, ae_int_t info, matinvreport *rep) {
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   Ok = true;
   if (info != -3 && info != 1) {
      Ok = false;
   } else {
      Ok = Ok && rep->r1 >= 0.0 && rep->r1 <= 1000.0 * machineepsilon;
      Ok = Ok && rep->rinf >= 0.0 && rep->rinf <= 1000.0 * machineepsilon;
      if (info == -3) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               Ok = Ok && inva->xyR[i][j] == 0.0;
            }
         }
      }
   }
   return Ok;
}

// Checks whether inversion result indicate singular matrix
static bool testmatinvunit_cmatrixcheckinversesingular(CMatrix *inva, ae_int_t n, double threshold, ae_int_t info, matinvreport *rep) {
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   Ok = true;
   if (info != -3 && info != 1) {
      Ok = false;
   } else {
      Ok = Ok && rep->r1 >= 0.0 && rep->r1 <= 1000.0 * machineepsilon;
      Ok = Ok && rep->rinf >= 0.0 && rep->rinf <= 1000.0 * machineepsilon;
      if (info == -3) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               Ok = Ok && ae_c_eq_d(inva->xyC[i][j], 0.0);
            }
         }
      }
   }
   return Ok;
}

// Drops upper or lower half of the matrix - fills it by special pattern
// which may be used later to ensure that this part wasn't changed
static void testmatinvunit_rmatrixdrophalf(RMatrix *a, ae_int_t n, bool droplower) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (droplower? i > j: i < j) {
            a->xyR[i][j] = (double)(1 + 2 * i + 3 * j);
         }
      }
   }
}

// Drops upper or lower half of the matrix - fills it by special pattern
// which may be used later to ensure that this part wasn't changed
static void testmatinvunit_cmatrixdrophalf(CMatrix *a, ae_int_t n, bool droplower) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (droplower? i > j: i < j) {
            a->xyC[i][j] = complex_from_i(1 + 2 * i + 3 * j);
         }
      }
   }
}

// Real TR inverse
static bool testmatinvunit_testrtrinv(ae_int_t minn, ae_int_t maxn, ae_int_t passcount, double threshold) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t task;
   bool isupper;
   bool isunit;
   double v;
   ae_int_t info;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewObj(matinvreport, rep);
// Test
   for (n = minn; n <= maxn; n++) {
      ae_matrix_set_length(&a, n, n);
      ae_matrix_set_length(&b, n, n);
      for (task = 0; task <= 3; task++) {
         for (pass = 1; pass <= passcount; pass++) {
         // Determine task
            isupper = task % 2 == 0;
            isunit = task / 2 % 2 == 0;
         // Generate matrix
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (i == j) {
                     a.xyR[i][i] = 1 + randomreal();
                  } else {
                     a.xyR[i][j] = 0.1 * randommid();
                  }
                  b.xyR[i][j] = a.xyR[i][j];
               }
            }
         // Inverse
            rmatrixtrinverse(&b, n, isupper, isunit, &info, &rep);
            if (info <= 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         // Structural test
            if (isunit) {
               for (i = 0; i < n; i++) {
                  Ok = Ok && a.xyR[i][i] == b.xyR[i][i];
               }
            }
            if (isupper) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < i; j++) {
                     Ok = Ok && a.xyR[i][j] == b.xyR[i][j];
                  }
               }
            } else {
               for (i = 0; i < n; i++) {
                  for (j = i + 1; j < n; j++) {
                     Ok = Ok && a.xyR[i][j] == b.xyR[i][j];
                  }
               }
            }
         // Inverse test
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper? j < i: j > i) {
                     a.xyR[i][j] = 0.0;
                     b.xyR[i][j] = 0.0;
                  }
               }
            }
            if (isunit) {
               for (i = 0; i < n; i++) {
                  a.xyR[i][i] = 1.0;
                  b.xyR[i][i] = 1.0;
               }
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, &b.xyR[0][j], b.stride, n);
                  if (j != i) {
                     Ok = Ok && SmallAtR(v, threshold);
                  } else {
                     Ok = Ok && NearAtR(v, 1, threshold);
                  }
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Complex TR inverse
static bool testmatinvunit_testctrinv(ae_int_t minn, ae_int_t maxn, ae_int_t passcount, double threshold) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t task;
   bool isupper;
   bool isunit;
   complex v;
   ae_int_t info;
   double emax;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(b, 0, 0, DT_COMPLEX);
   NewObj(matinvreport, rep);
// Test
   for (n = minn; n <= maxn; n++) {
      ae_matrix_set_length(&a, n, n);
      ae_matrix_set_length(&b, n, n);
      for (task = 0; task <= 3; task++) {
         for (pass = 1; pass <= passcount; pass++) {
         // Determine task
            isupper = task % 2 == 0;
            isunit = task / 2 % 2 == 0;
         // Generate matrix
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (i == j) {
                     a.xyC[i][i] = complex_from_d(1 + randomreal(), 1 + randomreal());
                  } else {
                     a.xyC[i][j] = complex_from_d(0.1 * randommid(), 0.1 * randommid());
                  }
                  b.xyC[i][j] = a.xyC[i][j];
               }
            }
         // Inverse
            cmatrixtrinverse(&b, n, isupper, isunit, &info, &rep);
            if (info <= 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         // Structural test
            if (isunit) {
               for (i = 0; i < n; i++) {
                  Ok = Ok && !ae_c_neq(a.xyC[i][i], b.xyC[i][i]);
               }
            }
            if (isupper) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < i; j++) {
                     Ok = Ok && !ae_c_neq(a.xyC[i][j], b.xyC[i][j]);
                  }
               }
            } else {
               for (i = 0; i < n; i++) {
                  for (j = i + 1; j < n; j++) {
                     Ok = Ok && !ae_c_neq(a.xyC[i][j], b.xyC[i][j]);
                  }
               }
            }
         // Inverse test
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper? j < i: j > i) {
                     a.xyC[i][j] = complex_from_i(0);
                     b.xyC[i][j] = complex_from_i(0);
                  }
               }
            }
            if (isunit) {
               for (i = 0; i < n; i++) {
                  a.xyC[i][i] = complex_from_i(1);
                  b.xyC[i][i] = complex_from_i(1);
               }
            }
            emax = 0.0;
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = ae_v_cdotproduct(a.xyC[i], 1, "N", &b.xyC[0][j], b.stride, "N", n);
                  if (j == i) {
                     v = ae_c_sub_d(v, 1);
                  }
                  emax = rmax2(emax, abscomplex(v));
               }
            }
            Ok = Ok && emax <= threshold;
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Unsets real matrix
static void testmatinvunit_unset2d(RMatrix *x) {
   ae_matrix_set_length(x, 1, 1);
   x->xyR[0][0] = randommid();
}

// Unsets real matrix
static void testmatinvunit_cunset2d(CMatrix *x) {
   ae_matrix_set_length(x, 1, 1);
   x->xyC[0][0] = complex_from_d(randommid());
}

// Unsets report
static void testmatinvunit_unsetrep(matinvreport *r) {
   r->r1 = -1.0;
   r->rinf = -1.0;
}

// Real test
static bool testmatinvunit_testrinv(ae_int_t minn, ae_int_t maxn, ae_int_t passcount, double threshold) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t taskkind;
   ae_int_t info;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(lua, 0, 0, DT_REAL);
   NewMatrix(inva, 0, 0, DT_REAL);
   NewMatrix(invlua, 0, 0, DT_REAL);
   NewVector(p, 0, DT_INT);
   NewObj(matinvreport, rep);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = minn; n <= maxn; n++) {
      // ********************************************************
      // WELL CONDITIONED TASKS
      // ability to find correct solution is tested
      // ********************************************************
      //
      // 1. generate random well conditioned matrix A.
      // 2. generate random solution vector xe
      // 3. generate right part b == A*xe
      // 4. test different methods on original A
         rmatrixrndcond(n, 1000.0, &a);
         testmatinvunit_rmatrixmakeacopy(&a, n, n, &lua);
         rmatrixlu(&lua, n, n, &p);
         testmatinvunit_rmatrixmakeacopy(&a, n, n, &inva);
         testmatinvunit_rmatrixmakeacopy(&lua, n, n, &invlua);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         rmatrixinverse(&inva, n, &info, &rep);
         Ok = Ok && testmatinvunit_rmatrixcheckinverse(&a, &inva, n, threshold, info, &rep);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         rmatrixluinverse(&invlua, &p, n, &info, &rep);
         Ok = Ok && testmatinvunit_rmatrixcheckinverse(&a, &invlua, n, threshold, info, &rep);
      // ********************************************************
      // EXACTLY SINGULAR MATRICES
      // ability to detect singularity is tested
      // ********************************************************
      //
      // 1. generate different types of singular matrices:
      //    * zero
      //    * with zero columns
      //    * with zero rows
      //    * with equal rows/columns
      // 2. test different methods
         for (taskkind = 0; taskkind <= 4; taskkind++) {
            testmatinvunit_unset2d(&a);
            if (taskkind == 0) {
            // all zeros
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
            if (taskkind == 1) {
            // there is zero column
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = randommid();
                  }
               }
               k = randominteger(n);
               ae_v_muld(&a.xyR[0][k], a.stride, n, 0);
            }
            if (taskkind == 2) {
            // there is zero row
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = randommid();
                  }
               }
               k = randominteger(n);
               ae_v_muld(a.xyR[k], 1, n, 0);
            }
            if (taskkind == 3) {
            // equal columns
               if (n < 2) {
                  continue;
               }
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = randommid();
                  }
               }
               k = 1 + randominteger(n - 1);
               ae_v_move(a.xyR[0], a.stride, &a.xyR[0][k], a.stride, n);
            }
            if (taskkind == 4) {
            // equal rows
               if (n < 2) {
                  continue;
               }
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = randommid();
                  }
               }
               k = 1 + randominteger(n - 1);
               ae_v_move(a.xyR[0], 1, a.xyR[k], 1, n);
            }
            testmatinvunit_rmatrixmakeacopy(&a, n, n, &lua);
            rmatrixlu(&lua, n, n, &p);
            info = 0;
            testmatinvunit_unsetrep(&rep);
            rmatrixinverse(&a, n, &info, &rep);
            Ok = Ok && testmatinvunit_rmatrixcheckinversesingular(&a, n, threshold, info, &rep);
            info = 0;
            testmatinvunit_unsetrep(&rep);
            rmatrixluinverse(&lua, &p, n, &info, &rep);
            Ok = Ok && testmatinvunit_rmatrixcheckinversesingular(&lua, n, threshold, info, &rep);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Complex test
static bool testmatinvunit_testcinv(ae_int_t minn, ae_int_t maxn, ae_int_t passcount, double threshold) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t taskkind;
   ae_int_t info;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(lua, 0, 0, DT_COMPLEX);
   NewMatrix(inva, 0, 0, DT_COMPLEX);
   NewMatrix(invlua, 0, 0, DT_COMPLEX);
   NewVector(p, 0, DT_INT);
   NewObj(matinvreport, rep);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = minn; n <= maxn; n++) {
      // ********************************************************
      // WELL CONDITIONED TASKS
      // ability to find correct solution is tested
      // ********************************************************
      //
      // 1. generate random well conditioned matrix A.
      // 2. generate random solution vector xe
      // 3. generate right part b == A*xe
      // 4. test different methods on original A
         cmatrixrndcond(n, 1000.0, &a);
         testmatinvunit_cmatrixmakeacopy(&a, n, n, &lua);
         cmatrixlu(&lua, n, n, &p);
         testmatinvunit_cmatrixmakeacopy(&a, n, n, &inva);
         testmatinvunit_cmatrixmakeacopy(&lua, n, n, &invlua);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         cmatrixinverse(&inva, n, &info, &rep);
         Ok = Ok && testmatinvunit_cmatrixcheckinverse(&a, &inva, n, threshold, info, &rep);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         cmatrixluinverse(&invlua, &p, n, &info, &rep);
         Ok = Ok && testmatinvunit_cmatrixcheckinverse(&a, &invlua, n, threshold, info, &rep);
      // ********************************************************
      // EXACTLY SINGULAR MATRICES
      // ability to detect singularity is tested
      // ********************************************************
      //
      // 1. generate different types of singular matrices:
      //    * zero
      //    * with zero columns
      //    * with zero rows
      //    * with equal rows/columns
      // 2. test different methods
         for (taskkind = 0; taskkind <= 4; taskkind++) {
            testmatinvunit_cunset2d(&a);
            if (taskkind == 0) {
            // all zeros
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_i(0);
                  }
               }
            }
            if (taskkind == 1) {
            // there is zero column
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_d(randommid(), randommid());
                  }
               }
               k = randominteger(n);
               ae_v_cmuld(&a.xyC[0][k], a.stride, n, 0);
            }
            if (taskkind == 2) {
            // there is zero row
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_d(randommid(), randommid());
                  }
               }
               k = randominteger(n);
               ae_v_cmuld(a.xyC[k], 1, n, 0);
            }
            if (taskkind == 3) {
            // equal columns
               if (n < 2) {
                  continue;
               }
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_d(randommid(), randommid());
                  }
               }
               k = 1 + randominteger(n - 1);
               ae_v_cmove(a.xyC[0], a.stride, &a.xyC[0][k], a.stride, "N", n);
            }
            if (taskkind == 4) {
            // equal rows
               if (n < 2) {
                  continue;
               }
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_d(randommid(), randommid());
                  }
               }
               k = 1 + randominteger(n - 1);
               ae_v_cmove(a.xyC[0], 1, a.xyC[k], 1, "N", n);
            }
            testmatinvunit_cmatrixmakeacopy(&a, n, n, &lua);
            cmatrixlu(&lua, n, n, &p);
            info = 0;
            testmatinvunit_unsetrep(&rep);
            cmatrixinverse(&a, n, &info, &rep);
            Ok = Ok && testmatinvunit_cmatrixcheckinversesingular(&a, n, threshold, info, &rep);
            info = 0;
            testmatinvunit_unsetrep(&rep);
            cmatrixluinverse(&lua, &p, n, &info, &rep);
            Ok = Ok && testmatinvunit_cmatrixcheckinversesingular(&lua, n, threshold, info, &rep);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// SPD test
static bool testmatinvunit_testspdinv(ae_int_t minn, ae_int_t maxn, ae_int_t passcount, double threshold) {
   ae_frame _frame_block;
   bool isupper;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t taskkind;
   ae_int_t info;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(cha, 0, 0, DT_REAL);
   NewMatrix(inva, 0, 0, DT_REAL);
   NewMatrix(invcha, 0, 0, DT_REAL);
   NewObj(matinvreport, rep);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = minn; n <= maxn; n++) {
         isupper = randombool();
      // ********************************************************
      // WELL CONDITIONED TASKS
      // ability to find correct solution is tested
      // ********************************************************
      //
      // 1. generate random well conditioned matrix A.
      // 2. generate random solution vector xe
      // 3. generate right part b == A*xe
      // 4. test different methods on original A
         spdmatrixrndcond(n, 1000.0, &a);
         testmatinvunit_rmatrixdrophalf(&a, n, isupper);
         testmatinvunit_rmatrixmakeacopy(&a, n, n, &cha);
         if (!spdmatrixcholesky(&cha, n, isupper)) {
            continue;
         }
         testmatinvunit_rmatrixmakeacopy(&a, n, n, &inva);
         testmatinvunit_rmatrixmakeacopy(&cha, n, n, &invcha);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         spdmatrixinverse(&inva, n, isupper, &info, &rep);
         Ok = Ok && testmatinvunit_spdmatrixcheckinverse(&a, &inva, isupper, n, threshold, info, &rep);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         spdmatrixcholeskyinverse(&invcha, n, isupper, &info, &rep);
         Ok = Ok && testmatinvunit_spdmatrixcheckinverse(&a, &invcha, isupper, n, threshold, info, &rep);
      // ********************************************************
      // EXACTLY SINGULAR MATRICES
      // ability to detect singularity is tested
      // ********************************************************
      //
      // 1. generate different types of singular matrices:
      //    * zero
      //    * with zero columns
      //    * with zero rows
      // 2. test different methods
         for (taskkind = 0; taskkind <= 2; taskkind++) {
            testmatinvunit_unset2d(&a);
            if (taskkind == 0) {
            // all zeros
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
            if (taskkind == 1) {
            // there is zero column
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = randommid();
                  }
               }
               k = randominteger(n);
               ae_v_muld(&a.xyR[0][k], a.stride, n, 0);
            }
            if (taskkind == 2) {
            // there is zero row
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = randommid();
                  }
               }
               k = randominteger(n);
               ae_v_muld(a.xyR[k], 1, n, 0);
            }
            info = 0;
            testmatinvunit_unsetrep(&rep);
            spdmatrixcholeskyinverse(&a, n, isupper, &info, &rep);
            if (info != -3 && info != 1) {
               Ok = false;
            } else {
               Ok = Ok && rep.r1 >= 0.0 && rep.r1 <= 1000.0 * machineepsilon;
               Ok = Ok && rep.rinf >= 0.0 && rep.rinf <= 1000.0 * machineepsilon;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// HPD test
static bool testmatinvunit_testhpdinv(ae_int_t minn, ae_int_t maxn, ae_int_t passcount, double threshold) {
   ae_frame _frame_block;
   bool isupper;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t taskkind;
   ae_int_t info;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(cha, 0, 0, DT_COMPLEX);
   NewMatrix(inva, 0, 0, DT_COMPLEX);
   NewMatrix(invcha, 0, 0, DT_COMPLEX);
   NewObj(matinvreport, rep);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = minn; n <= maxn; n++) {
         isupper = randombool();
      // ********************************************************
      // WELL CONDITIONED TASKS
      // ability to find correct solution is tested
      // ********************************************************
      //
      // 1. generate random well conditioned matrix A.
      // 2. generate random solution vector xe
      // 3. generate right part b == A*xe
      // 4. test different methods on original A
         hpdmatrixrndcond(n, 1000.0, &a);
         testmatinvunit_cmatrixdrophalf(&a, n, isupper);
         testmatinvunit_cmatrixmakeacopy(&a, n, n, &cha);
         if (!hpdmatrixcholesky(&cha, n, isupper)) {
            continue;
         }
         testmatinvunit_cmatrixmakeacopy(&a, n, n, &inva);
         testmatinvunit_cmatrixmakeacopy(&cha, n, n, &invcha);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         hpdmatrixinverse(&inva, n, isupper, &info, &rep);
         Ok = Ok && testmatinvunit_hpdmatrixcheckinverse(&a, &inva, isupper, n, threshold, info, &rep);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         hpdmatrixcholeskyinverse(&invcha, n, isupper, &info, &rep);
         Ok = Ok && testmatinvunit_hpdmatrixcheckinverse(&a, &invcha, isupper, n, threshold, info, &rep);
      // ********************************************************
      // EXACTLY SINGULAR MATRICES
      // ability to detect singularity is tested
      // ********************************************************
      //
      // 1. generate different types of singular matrices:
      //    * zero
      //    * with zero columns
      //    * with zero rows
      // 2. test different methods
         for (taskkind = 0; taskkind <= 2; taskkind++) {
            testmatinvunit_cunset2d(&a);
            if (taskkind == 0) {
            // all zeros
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_i(0);
                  }
               }
            }
            if (taskkind == 1) {
            // there is zero column
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_d(randommid(), randommid());
                  }
               }
               k = randominteger(n);
               ae_v_cmuld(&a.xyC[0][k], a.stride, n, 0);
               ae_v_cmuld(a.xyC[k], 1, n, 0);
            }
            if (taskkind == 2) {
            // there is zero row
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_d(randommid(), randommid());
                  }
               }
               k = randominteger(n);
               ae_v_cmuld(a.xyC[k], 1, n, 0);
               ae_v_cmuld(&a.xyC[0][k], a.stride, n, 0);
            }
            info = 0;
            testmatinvunit_unsetrep(&rep);
            hpdmatrixcholeskyinverse(&a, n, isupper, &info, &rep);
            if (info != -3 && info != 1) {
               Ok = false;
            } else {
               Ok = Ok && rep.r1 >= 0.0 && rep.r1 <= 1000.0 * machineepsilon;
               Ok = Ok && rep.rinf >= 0.0 && rep.rinf <= 1000.0 * machineepsilon;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test
bool testmatinv() {
   ae_int_t maxrn;
   ae_int_t maxcn;
   ae_int_t largen;
   ae_int_t passcount;
   double threshold;
   bool rtrOk;
   bool ctrOk;
   bool rOk;
   bool cOk;
   bool spdOk;
   bool hpdOk;
   bool Ok;
   maxrn = 3 * matrixtilesizea() + 1;
   maxcn = 3 * matrixtilesizea() + 1;
   largen = 4 * matrixtilesizeb() + 1;
   passcount = 1;
   threshold = 10000.0 * machineepsilon;
   rtrOk = true;
   ctrOk = true;
   rOk = true;
   cOk = true;
   spdOk = true;
   hpdOk = true;
   rtrOk = rtrOk && testmatinvunit_testrtrinv(1, maxrn, passcount, threshold);
   ctrOk = ctrOk && testmatinvunit_testctrinv(1, maxcn, passcount, threshold);
   rOk = rOk && testmatinvunit_testrinv(1, maxrn, passcount, threshold);
   spdOk = spdOk && testmatinvunit_testspdinv(1, maxrn, passcount, threshold);
   cOk = cOk && testmatinvunit_testcinv(1, maxcn, passcount, threshold);
   hpdOk = hpdOk && testmatinvunit_testhpdinv(1, maxcn, passcount, threshold);
   rtrOk = rtrOk && testmatinvunit_testrtrinv(largen, largen, passcount, threshold);
   ctrOk = ctrOk && testmatinvunit_testctrinv(largen, largen, passcount, threshold);
   rOk = rOk && testmatinvunit_testrinv(largen, largen, passcount, threshold);
   spdOk = spdOk && testmatinvunit_testspdinv(largen, largen, passcount, threshold);
   cOk = cOk && testmatinvunit_testcinv(largen, largen, passcount, threshold);
   hpdOk = hpdOk && testmatinvunit_testhpdinv(largen, largen, passcount, threshold);
// The final report.
   Ok = rtrOk && ctrOk && rOk && cOk && spdOk && hpdOk;
   if (!Ok || !silent) {
      printf("Matrix Inverse Tests\n");
      printf("* Real Triangular:                        %s\n", rtrOk? "Ok": "Failed");
      printf("* Complex Triangular:                     %s\n", ctrOk? "Ok": "Failed");
      printf("* Real:                                   %s\n", rOk? "Ok": "Failed");
      printf("* Complex:                                %s\n", cOk? "Ok": "Failed");
      printf("* SPD:                                    %s\n", spdOk? "Ok": "Failed");
      printf("* HPD:                                    %s\n", hpdOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === optserv testing unit ===
// This function checks preconditioning functions
static bool testoptservunit_testprec() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t k;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i0;
   ae_int_t j0;
   ae_int_t j1;
   double v;
   double rho;
   double theta;
   double tolg;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(va, 0, 0, DT_REAL);
   NewVector(vc, 0, DT_REAL);
   NewVector(vd, 0, DT_REAL);
   NewVector(vb, 0, DT_REAL);
   NewVector(s0, 0, DT_REAL);
   NewVector(s1, 0, DT_REAL);
   NewVector(s2, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewObj(precbuflbfgs, buf);
   NewObj(precbuflowrank, lowrankbuf);
   NewVector(norms, 0, DT_REAL);
   NewMatrix(sk, 0, 0, DT_REAL);
   NewMatrix(yk, 0, 0, DT_REAL);
   NewMatrix(bk, 0, 0, DT_REAL);
   NewVector(bksk, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewObj(matinvreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Test for inexact L-BFGS preconditioner.
//
// We generate QP problem 0.5*x'*H*x, with random H == D+V'*C*V.
// Different K's, from 0 to N, are tried. We test preconditioner
// code which uses compact L-BFGS update against reference implementation
// which uses non-compact BFGS scheme.
//
// For each K we perform two tests: first for KxN non-zero matrix V,
// second one for NxN matrix V with last N-K rows set to zero. Last test
// checks algorithm's ability to handle zero updates.
   tolg = 1.0E-9;
   for (n = 1; n <= 10; n++) {
      for (k = 0; k <= n; k++) {
      // Prepare problem:
      // * VD, VC, VA, with VC/VA reordered by ascending of VC[i]*norm(VA[i,...])^2
      // * trial vector S (copies are stored to S0,S1,S2)
         ae_vector_set_length(&vd, n);
         ae_vector_set_length(&s0, n);
         ae_vector_set_length(&s1, n);
         ae_vector_set_length(&s2, n);
         for (i = 0; i < n; i++) {
            vd.xR[i] = exp(hqrndnormal(&rs));
            s0.xR[i] = hqrndnormal(&rs);
            s1.xR[i] = s0.xR[i];
            s2.xR[i] = s0.xR[i];
         }
         rmatrixrndcond(n, 1.0E2, &va);
         vectorsetlengthatleast(&vc, n);
         for (i = 0; i < k; i++) {
            vc.xR[i] = exp(hqrndnormal(&rs));
         }
         for (i = k; i < n; i++) {
            vc.xR[i] = 0.0;
            for (j = 0; j < n; j++) {
               va.xyR[i][j] = 0.0;
            }
         }
         ae_vector_set_length(&norms, k);
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(va.xyR[i], 1, va.xyR[i], 1, n);
            norms.xR[i] = v * vc.xR[i];
         }
         for (i = 0; i < k; i++) {
            for (j = 0; j < k - 1; j++) {
               if (norms.xR[j] > norms.xR[j + 1]) {
               // Swap elements J and J+1
                  swapr(&norms.xR[j], &norms.xR[j + 1]);
                  swapr(&vc.xR[j], &vc.xR[j + 1]);
                  for (j0 = 0; j0 < n; j0++) {
                     swapr(&va.xyR[j][j0], &va.xyR[j + 1][j0]);
                  }
               }
            }
         }
      // Generate reference model and apply it to S2:
      // * generate approximate Hessian Bk
      // * calculate inv(Bk)
      // * calculate inv(Bk)*S2, store to S2
         matrixsetlengthatleast(&sk, k, n);
         matrixsetlengthatleast(&yk, k, n);
         ae_matrix_set_length(&bk, n, n);
         ae_vector_set_length(&bksk, n);
         ae_vector_set_length(&tmp, n);
         for (i = 0; i < k; i++) {
            ae_v_move(sk.xyR[i], 1, va.xyR[i], 1, n);
            v = ae_v_dotproduct(va.xyR[i], 1, sk.xyR[i], 1, n);
            v *= vc.xR[i];
            for (j = 0; j < n; j++) {
               yk.xyR[i][j] = vd.xR[j] * sk.xyR[i][j] + va.xyR[i][j] * v;
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (i == j) {
                  bk.xyR[i][i] = vd.xR[i];
               } else {
                  bk.xyR[i][j] = 0.0;
               }
            }
         }
         for (i = 0; i < k; i++) {
            theta = 0.0;
            for (j0 = 0; j0 < n; j0++) {
               bksk.xR[j0] = 0.0;
               for (j1 = 0; j1 < n; j1++) {
                  theta += sk.xyR[i][j0] * bk.xyR[j0][j1] * sk.xyR[i][j1];
                  bksk.xR[j0] += bk.xyR[j0][j1] * sk.xyR[i][j1];
               }
            }
            theta = 1 / theta;
            rho = ae_v_dotproduct(sk.xyR[i], 1, yk.xyR[i], 1, n);
            rho = 1 / rho;
            for (j0 = 0; j0 < n; j0++) {
               for (j1 = 0; j1 < n; j1++) {
                  bk.xyR[j0][j1] += rho * yk.xyR[i][j0] * yk.xyR[i][j1];
               }
            }
            for (j0 = 0; j0 < n; j0++) {
               for (j1 = 0; j1 < n; j1++) {
                  bk.xyR[j0][j1] -= theta * bksk.xR[j0] * bksk.xR[j1];
               }
            }
         }
         rmatrixinverse(&bk, n, &j0, &rep);
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(bk.xyR[i], 1, s2.xR, 1, n);
            tmp.xR[i] = v;
         }
         for (i = 0; i < n; i++) {
            s2.xR[i] = tmp.xR[i];
         }
      // First test for non-zero V:
      // * apply preconditioner to X0
      // * compare reference model against implementation being tested
         inexactlbfgspreconditioner(&s0, n, &vd, &vc, &va, k, &buf);
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(s2.xR[i], s0.xR[i], tolg);
         }
      // Second test - N-K zero rows appended to V and rows are
      // randomly reordered. Doing so should not change result,
      // algorithm must be able to order rows according to second derivative
      // and skip zero updates.
         for (i = 0; i < n; i++) {
            i0 = i + hqrnduniformi(&rs, n - i);
            swapr(&vc.xR[i], &vc.xR[i0]);
            for (j = 0; j < n; j++) {
               swapr(&va.xyR[i][j], &va.xyR[i0][j]);
            }
         }
         inexactlbfgspreconditioner(&s1, n, &vd, &vc, &va, n, &buf);
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(s2.xR[i], s1.xR[i], tolg);
         }
      }
   }
// Test for exact low-rank preconditioner.
//
// We generate QP problem 0.5*x'*H*x, with random H == D+V'*C*V.
// Different K's, from 0 to N, are tried. We test preconditioner
// code which uses Woodbury update against reference implementation
// which performs straightforward matrix inversion.
//
// For each K we perform two tests: first for KxN non-zero matrix V,
// second one for NxN matrix V with randomly appended N-K zero rows.
// Last test checks algorithm's ability to handle zero updates.
   tolg = 1.0E-9;
   for (n = 1; n <= 10; n++) {
      for (k = 0; k <= n; k++) {
      // Prepare problem:
      // * VD, VC, VA
      // * trial vector S (copies are stored to S0,S1,S2)
         ae_vector_set_length(&vd, n);
         ae_vector_set_length(&s0, n);
         ae_vector_set_length(&s1, n);
         ae_vector_set_length(&s2, n);
         for (i = 0; i < n; i++) {
            vd.xR[i] = exp(hqrndnormal(&rs));
            s0.xR[i] = hqrndnormal(&rs);
            s1.xR[i] = s0.xR[i];
            s2.xR[i] = s0.xR[i];
         }
         rmatrixrndcond(n, 1.0E2, &va);
         vectorsetlengthatleast(&vc, n);
         for (i = 0; i < k; i++) {
            vc.xR[i] = exp(hqrndnormal(&rs));
         }
         for (i = k; i < n; i++) {
            vc.xR[i] = 0.0;
            for (j = 0; j < n; j++) {
               va.xyR[i][j] = 0.0;
            }
         }
      // Generate reference model and apply it to S2
         ae_matrix_set_length(&bk, n, n);
         ae_vector_set_length(&tmp, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (i == j) {
                  v = vd.xR[i];
               } else {
                  v = 0.0;
               }
               for (j1 = 0; j1 < k; j1++) {
                  v += va.xyR[j1][i] * vc.xR[j1] * va.xyR[j1][j];
               }
               bk.xyR[i][j] = v;
            }
         }
         rmatrixinverse(&bk, n, &j, &rep);
         ae_assert(j > 0, "Assertion failed");
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += bk.xyR[i][j] * s2.xR[j];
            }
            tmp.xR[i] = v;
         }
         for (i = 0; i < n; i++) {
            s2.xR[i] = tmp.xR[i];
         }
      // First test for non-zero V:
      // * apply preconditioner to X0
      // * compare reference model against implementation being tested
         preparelowrankpreconditioner(&vd, &vc, &va, n, k, &lowrankbuf);
         applylowrankpreconditioner(&s0, &lowrankbuf);
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(s2.xR[i], s0.xR[i], tolg);
         }
      // Second test - N-K zero rows appended to V and rows are
      // randomly reordered. Doing so should not change result,
      // algorithm must be able to order rows according to second derivative
      // and skip zero updates.
         for (i = 0; i < n; i++) {
            i0 = i + hqrnduniformi(&rs, n - i);
            swapr(&vc.xR[i], &vc.xR[i0]);
            for (j = 0; j < n; j++) {
               swapr(&va.xyR[i][j], &va.xyR[i0][j]);
            }
         }
         preparelowrankpreconditioner(&vd, &vc, &va, n, n, &lowrankbuf);
         applylowrankpreconditioner(&s1, &lowrankbuf);
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(s2.xR[i], s1.xR[i], tolg);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

bool testoptserv() {
   bool precOk;
   bool Ok;
   precOk = true;
   precOk = precOk && testoptservunit_testprec();
// The final report.
   Ok = precOk;
   if (!Ok || !silent) {
      printf("OptServ Test\n");
      printf("* Preconditioners:                        %s\n", precOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === minlbfgs testing unit ===
static const ae_int_t testminlbfgsunit_maxoptguardlevel = 1;

// Calculate test function #2
//
// Simple variation of #1, much more nonlinear, which makes unlikely premature
// convergence of algorithm .
static void testminlbfgsunit_testfunc2(minlbfgsstate *state) {
   if (state->x.xR[0] < 100.0) {
      if (state->needf || state->needfg) {
         state->f = sqr(exp(state->x.xR[0]) - 2) + sqr(sqr(state->x.xR[1])) + sqr(state->x.xR[2] - state->x.xR[0]);
         if (state->needfg) {
            state->g.xR[0] = 2 * (exp(state->x.xR[0]) - 2) * exp(state->x.xR[0]) + 2 * (state->x.xR[0] - state->x.xR[2]);
            state->g.xR[1] = 4 * state->x.xR[1] * sqr(state->x.xR[1]);
            state->g.xR[2] = 2 * (state->x.xR[2] - state->x.xR[0]);
         }
      }
   } else {
      if (state->needf || state->needfg) {
         state->f = sqrt(maxrealnumber);
         if (state->needfg) {
            state->g.xR[0] = sqrt(maxrealnumber);
            state->g.xR[1] = 0.0;
            state->g.xR[2] = 0.0;
         }
      }
   }
}

// Calculate test function #3
//
// Simple variation of #1, much more nonlinear, with non-zero value at minimum.
// It achieve two goals:
// * makes unlikely premature convergence of algorithm .
// * solves some issues with EpsF stopping condition which arise when
//   F(minimum) is zero
//
static void testminlbfgsunit_testfunc3(minlbfgsstate *state) {
   double s;
   s = 0.001;
   if (state->x.xR[0] < 100.0) {
      if (state->needf || state->needfg) {
         state->f = sqr(exp(state->x.xR[0]) - 2) + sqr(sqr(state->x.xR[1]) + s) + sqr(state->x.xR[2] - state->x.xR[0]);
         if (state->needfg) {
            state->g.xR[0] = 2 * (exp(state->x.xR[0]) - 2) * exp(state->x.xR[0]) + 2 * (state->x.xR[0] - state->x.xR[2]);
            state->g.xR[1] = 2 * (sqr(state->x.xR[1]) + s) * 2 * state->x.xR[1];
            state->g.xR[2] = 2 * (state->x.xR[2] - state->x.xR[0]);
         }
      }
   } else {
      if (state->needf || state->needfg) {
         state->f = sqrt(maxrealnumber);
         if (state->needfg) {
            state->g.xR[0] = sqrt(maxrealnumber);
            state->g.xR[1] = 0.0;
            state->g.xR[2] = 0.0;
         }
      }
   }
}

// Calculate test function IIP2
//
// f(x) = sum( ((i*i+1)*x[i])^2, i = 0..N-1)
//
// It has high condition number which makes fast convergence unlikely without
// good preconditioner.
//
static void testminlbfgsunit_calciip2(minlbfgsstate *state, ae_int_t n) {
   ae_int_t i;
   if (state->needf || state->needfg) {
      state->f = 0.0;
      for (i = 0; i < n; i++) {
         state->f += sqr(i * i + 1) * sqr(state->x.xR[i]);
         if (state->needfg) {
            state->g.xR[i] = sqr(i * i + 1) * 2 * state->x.xR[i];
         }
      }
   }
}

// This function tests preconditioning
static bool testminlbfgsunit_testpreconditioning() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t cntb1;
   ae_int_t cntb2;
   ae_int_t cntg1;
   ae_int_t cntg2;
   ae_int_t pkind;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(minlbfgsstate, state);
   NewObj(minlbfgsreport, rep);
   NewVector(x, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(diagh, 0, DT_REAL);
   m = 1;
   k = 50;
// Preconditioner test1.
//
// If
// * B1 is default preconditioner
// * B2 is Cholesky preconditioner with unit diagonal
// * G1 is Cholesky preconditioner based on exact Hessian with perturbations
// * G2 is diagonal precomditioner based on approximate diagonal of Hessian matrix
// then "bad" preconditioners (B1/B2/..) are worse than "good" ones (G1/G2/..).
// "Worse" means more iterations to converge.
//
// We test it using f(x) = sum( ((i*i+1)*x[i])^2, i = 0..N-1) and L-BFGS
// optimizer with deliberately small M == 1.
//
// N        - problem size
// PKind    - zero for upper triangular preconditioner, one for lower triangular.
// K        - number of repeated passes (should be large enough to average out random factors)
   for (n = 10; n <= 15; n++) {
      pkind = randominteger(2);
      ae_vector_set_length(&x, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 0.0;
      }
      minlbfgscreate(n, m, &x, &state);
   // Test it with default preconditioner
      minlbfgssetprecdefault(&state);
      cntb1 = 0;
      for (pass = 0; pass < k; pass++) {
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         for (minlbfgsrestartfrom(&state, &x); minlbfgsiteration(&state); ) testminlbfgsunit_calciip2(&state, n);
         minlbfgsresults(&state, &x, &rep);
         cntb1 += rep.iterationscount;
         Ok = Ok && rep.terminationtype > 0;
      }
   // Test it with unit preconditioner
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (i == j) {
               a.xyR[i][i] = 1.0;
            } else {
               a.xyR[i][j] = 0.0;
            }
         }
      }
      minlbfgssetpreccholesky(&state, &a, pkind == 0);
      cntb2 = 0;
      for (pass = 0; pass < k; pass++) {
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         for (minlbfgsrestartfrom(&state, &x); minlbfgsiteration(&state); ) testminlbfgsunit_calciip2(&state, n);
         minlbfgsresults(&state, &x, &rep);
         cntb2 += rep.iterationscount;
         Ok = Ok && rep.terminationtype > 0;
      }
   // Test it with perturbed Hessian preconditioner
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (i == j) {
               a.xyR[i][i] = (i * i + 1) * (0.8 + 0.4 * randomreal());
            } else {
               if (pkind == 0 && j > i || pkind == 1 && j < i) {
                  a.xyR[i][j] = 0.05 * randommid();
               } else {
                  a.xyR[i][j] = NAN;
               }
            }
         }
      }
      minlbfgssetpreccholesky(&state, &a, pkind == 0);
      cntg1 = 0;
      for (pass = 0; pass < k; pass++) {
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         for (minlbfgsrestartfrom(&state, &x); minlbfgsiteration(&state); ) testminlbfgsunit_calciip2(&state, n);
         minlbfgsresults(&state, &x, &rep);
         cntg1 += rep.iterationscount;
         Ok = Ok && rep.terminationtype > 0;
      }
   // Test it with perturbed diagonal preconditioner
      ae_vector_set_length(&diagh, n);
      for (i = 0; i < n; i++) {
         diagh.xR[i] = 2 * sqr(i * i + 1) * (0.8 + 0.4 * randomreal());
      }
      minlbfgssetprecdiag(&state, &diagh);
      cntg2 = 0;
      for (pass = 0; pass < k; pass++) {
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         for (minlbfgsrestartfrom(&state, &x); minlbfgsiteration(&state); ) testminlbfgsunit_calciip2(&state, n);
         minlbfgsresults(&state, &x, &rep);
         cntg2 += rep.iterationscount;
         Ok = Ok && rep.terminationtype > 0;
      }
   // Compare
      Ok = Ok && cntb1 >= cntg1;
      Ok = Ok && cntb2 >= cntg1;
      Ok = Ok && cntb1 >= cntg2;
      Ok = Ok && cntb2 >= cntg2;
   }
// Preconditioner test 2.
//
// If
// * B2 is default preconditioner with non-unit scale S[i] == 1/sqrt(h[i])
// * G2 is scale-based preconditioner with non-unit scale S[i] == 1/sqrt(h[i])
// then B2 is worse than G2.
// "Worse" means more iterations to converge.
   for (n = 10; n <= 15; n++) {
      ae_vector_set_length(&x, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 0.0;
      }
      minlbfgscreate(n, m, &x, &state);
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 1 / sqrt(2 * pow((double)(i * i + 1), 2.0) * (0.8 + 0.4 * randomreal()));
      }
      minlbfgssetprecdefault(&state);
      minlbfgssetscale(&state, &s);
      cntb2 = 0;
      for (pass = 0; pass < k; pass++) {
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         for (minlbfgsrestartfrom(&state, &x); minlbfgsiteration(&state); ) testminlbfgsunit_calciip2(&state, n);
         minlbfgsresults(&state, &x, &rep);
         cntb2 += rep.iterationscount;
         Ok = Ok && rep.terminationtype > 0;
      }
      minlbfgssetprecscale(&state);
      minlbfgssetscale(&state, &s);
      cntg2 = 0;
      for (pass = 0; pass < k; pass++) {
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         for (minlbfgsrestartfrom(&state, &x); minlbfgsiteration(&state); ) testminlbfgsunit_calciip2(&state, n);
         minlbfgsresults(&state, &x, &rep);
         cntg2 += rep.iterationscount;
         Ok = Ok && rep.terminationtype > 0;
      }
      Ok = Ok && cntb2 >= cntg2;
   }
   ae_frame_leave();
   return Ok;
}

// This function tests other properties
static bool testminlbfgsunit_testother() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   bool hasxlast;
   double lastscaledstep;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double fprev;
   double xprev;
   double v;
   double stpmax;
   double tmpeps;
   double epsg;
   ae_int_t pkind;
   ae_int_t ckind;
   ae_int_t mkind;
   double vc;
   double vm;
   double diffstep;
   ae_int_t dkind;
   bool wasf;
   bool wasfg;
   double r;
   ae_int_t spoiliteration;
   ae_int_t stopiteration;
   ae_int_t spoilvar;
   double spoilval;
   double ss;
   bool terminationrequested;
   ae_int_t pass;
   ae_int_t stopcallidx;
   ae_int_t callidx;
   ae_int_t maxits;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(a, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(h, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewObj(minlbfgsstate, state);
   NewObj(minlbfgsreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Test reports (F should form monotone sequence)
   n = 50;
   m = 2;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&xlast, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = 1.0;
   }
   minlbfgscreate(n, m, &x, &state);
   minlbfgssetcond(&state, 0.0, 0.0, 0.0, 100);
   minlbfgssetxrep(&state, true);
   fprev = maxrealnumber;
   while (minlbfgsiteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += sqr((1 + i) * state.x.xR[i]);
            state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
         }
      } else if (state.xupdated) {
         Ok = Ok && state.f <= fprev;
         if (fprev == maxrealnumber) {
            for (i = 0; i < n; i++) {
               Ok = Ok && state.x.xR[i] == x.xR[i];
            }
         }
         fprev = state.f;
         ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
      }
   minlbfgsresults(&state, &x, &rep);
   for (i = 0; i < n; i++) {
      Ok = Ok && x.xR[i] == xlast.xR[i];
   }
// Test differentiation vs. analytic gradient
// (first one issues NeedF requests, second one issues NeedFG requests)
   n = 50;
   m = 5;
   diffstep = 1.0E-6;
   for (dkind = 0; dkind <= 1; dkind++) {
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 1.0;
      }
      if (dkind == 0) {
         minlbfgscreate(n, m, &x, &state);
      }
      if (dkind == 1) {
         minlbfgscreatef(n, m, &x, diffstep, &state);
      }
      minlbfgssetcond(&state, 0.0, 0.0, 0.0, n / 2);
      wasf = false;
      wasfg = false;
      while (minlbfgsiteration(&state))
         if (state.needf || state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += sqr((1 + i) * state.x.xR[i]);
               if (state.needfg) {
                  state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
               }
            }
            wasf = wasf || state.needf;
            wasfg = wasfg || state.needfg;
         }
      minlbfgsresults(&state, &x, &rep);
      if (dkind == 0) {
         Ok = Ok && !wasf && wasfg;
      }
      if (dkind == 1) {
         Ok = Ok && wasf && !wasfg;
      }
   }
// Test that numerical differentiation uses scaling.
//
// In order to test that we solve simple optimization
// problem: min(x^2) with initial x equal to 0.0.
//
// We choose random DiffStep and S, then we check that
// optimizer evaluates function at +-DiffStep*S only.
   ae_vector_set_length(&x, 1);
   ae_vector_set_length(&s, 1);
   diffstep = randomreal() * 1.0E-6;
   s.xR[0] = exp(2.0*randommid());
   x.xR[0] = 0.0;
   minlbfgscreatef(1, 1, &x, diffstep, &state);
   minlbfgssetcond(&state, 1.0E-6, 0.0, 0.0, 0);
   minlbfgssetscale(&state, &s);
   v = 0.0;
   while (minlbfgsiteration(&state)) {
      state.f = sqr(state.x.xR[0]);
      v = rmax2(v, fabs(state.x.xR[0]));
   }
   minlbfgsresults(&state, &x, &rep);
   r = v / (s.xR[0] * diffstep);
   Ok = Ok && SmallAtR(log(r), log(1.0 + 1000.0 * machineepsilon));
// test maximum step
   n = 1;
   m = 1;
   ae_vector_set_length(&x, n);
   x.xR[0] = 100.0;
   stpmax = 0.05 + 0.05 * randomreal();
   minlbfgscreate(n, m, &x, &state);
   minlbfgssetcond(&state, 1.0E-9, 0.0, 0.0, 0);
   minlbfgssetstpmax(&state, stpmax);
   minlbfgssetxrep(&state, true);
   xprev = x.xR[0];
   while (minlbfgsiteration(&state))
      if (state.needfg) {
         state.f = exp(state.x.xR[0]) + exp(-state.x.xR[0]);
         state.g.xR[0] = exp(state.x.xR[0]) - exp(-state.x.xR[0]);
         Ok = Ok && NearAtR(state.x.xR[0], xprev, (1 + sqrt(machineepsilon)) * stpmax);
      } else if (state.xupdated) {
         Ok = Ok && NearAtR(state.x.xR[0], xprev, (1 + sqrt(machineepsilon)) * stpmax);
         xprev = state.x.xR[0];
      }
// Test correctness of the scaling:
// * initial point is random point from [+1,+2]^N
// * f(x) = SUM(A[i]*x[i]^4), C[i] is random from [0.01,100]
// * we use random scaling matrix
// * we test different variants of the preconditioning:
//   0) unit preconditioner
//   1) random diagonal from [0.01,100]
//   2) scale preconditioner
// * we set stringent stopping conditions (we try EpsG and EpsX)
// * and we test that in the extremum stopping conditions are
//   satisfied subject to the current scaling coefficients.
   tmpeps = 1.0E-10;
   m = 1;
   for (n = 1; n <= 10; n++) {
      for (pkind = 0; pkind <= 2; pkind++) {
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xlast, n);
         ae_vector_set_length(&a, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&h, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = randomreal() + 1;
            a.xR[i] = exp(log(100.0) * randommid());
            s.xR[i] = exp(log(100.0) * randommid());
            h.xR[i] = exp(log(100.0) * randommid());
         }
         minlbfgscreate(n, m, &x, &state);
         minlbfgssetscale(&state, &s);
         minlbfgssetxrep(&state, true);
         if (pkind == 1) {
            minlbfgssetprecdiag(&state, &h);
         }
         if (pkind == 2) {
            minlbfgssetprecscale(&state);
         }
      // Test gradient-based stopping condition
         for (i = 0; i < n; i++) {
            x.xR[i] = randomreal() + 1;
         }
         minlbfgssetcond(&state, tmpeps, 0.0, 0.0, 0);
         for (minlbfgsrestartfrom(&state, &x); minlbfgsiteration(&state); )
            if (state.needfg) {
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  state.f += a.xR[i] * pow(state.x.xR[i], 4.0);
                  state.g.xR[i] = 4 * a.xR[i] * pow(state.x.xR[i], 3.0);
               }
            }
         minlbfgsresults(&state, &x, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += sqr(s.xR[i] * 4 * a.xR[i] * pow(x.xR[i], 3.0));
         }
         v = sqrt(v);
         Ok = Ok && v <= tmpeps;
      // Test step-based stopping condition
         for (i = 0; i < n; i++) {
            x.xR[i] = randomreal() + 1;
         }
         hasxlast = false;
         lastscaledstep = maxrealnumber;
         minlbfgssetcond(&state, 0.0, 0.0, tmpeps, 0);
         for (minlbfgsrestartfrom(&state, &x); minlbfgsiteration(&state); )
            if (state.needfg) {
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  state.f += a.xR[i] * pow(state.x.xR[i], 4.0);
                  state.g.xR[i] = 4 * a.xR[i] * pow(state.x.xR[i], 3.0);
               }
            } else if (state.xupdated) {
               if (hasxlast) {
                  lastscaledstep = 0.0;
                  for (i = 0; i < n; i++) {
                     lastscaledstep += sqr(state.x.xR[i] - xlast.xR[i]) / sqr(s.xR[i]);
                  }
                  lastscaledstep = sqrt(lastscaledstep);
               } else {
                  lastscaledstep = 0.0;
               }
               ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
               hasxlast = true;
            }
         minlbfgsresults(&state, &x, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         Ok = Ok && lastscaledstep <= tmpeps;
      }
   }
// Check correctness of the "trimming".
//
// Trimming is a technique which is used to help algorithm
// cope with unbounded functions. In order to check this
// technique we will try to solve following optimization
// problem:
//
//     min f(x) subject to no constraints on X
//            { 1/(1-x) + 1/(1+x) + c*x, if -0.999999 < x < 0.999999
//     f(x) = {
//            { M, if x <= -0.999999 or x >= 0.999999
//
// where c is either 1.0 or 1.0E+6, M is either 1.0E8, 1.0E20 or +INF
// (we try different combinations)
   for (ckind = 0; ckind <= 1; ckind++) {
      for (mkind = 0; mkind <= 2; mkind++) {
      // Choose c and M
         vc = 1.0;
         vm = 1.0;
         if (ckind == 0) {
            vc = 1.0;
         }
         if (ckind == 1) {
            vc = 1.0E+6;
         }
         if (mkind == 0) {
            vm = 1.0E+8;
         }
         if (mkind == 1) {
            vm = 1.0E+20;
         }
         if (mkind == 2) {
            vm = +INFINITY;
         }
      // Create optimizer, solve optimization problem
         epsg = 1.0E-6 * vc;
         ae_vector_set_length(&x, 1);
         x.xR[0] = 0.0;
         minlbfgscreate(1, 1, &x, &state);
         minlbfgssetcond(&state, epsg, 0.0, 0.0, 0);
         while (minlbfgsiteration(&state))
            if (state.needfg) {
               if (-0.999999 < state.x.xR[0] && state.x.xR[0] < 0.999999) {
                  state.f = 1 / (1 - state.x.xR[0]) + 1 / (1 + state.x.xR[0]) + vc * state.x.xR[0];
                  state.g.xR[0] = 1 / sqr(1 - state.x.xR[0]) - 1 / sqr(1 + state.x.xR[0]) + vc;
               } else {
                  state.f = vm;
               }
            }
         minlbfgsresults(&state, &x, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         Ok = Ok && NearAtR(1.0 / sqr(1.0 - x.xR[0]), 1.0 / sqr(1.0 + x.xR[0]) - vc, epsg);
      }
   }
// Test integrity checks for NAN/INF:
// * algorithm solves optimization problem, which is normal for some time (quadratic)
// * after 5-th step we choose random component of gradient and consistently spoil
//   it by NAN or INF.
// * we check that correct termination code is returned (-8)
   n = 100;
   for (pass = 1; pass <= 10; pass++) {
      spoiliteration = 5;
      stopiteration = 8;
      if (hqrndnormal(&rs) > 0.0) {
      // Gradient can be spoiled by +INF, -INF, NAN
         spoilvar = hqrnduniformi(&rs, n);
         i = hqrnduniformi(&rs, 3);
         spoilval = NAN;
         if (i == 0) {
            spoilval = -INFINITY;
         }
         if (i == 1) {
            spoilval = +INFINITY;
         }
      } else {
      // Function value can be spoiled only by NAN
      // (+INF can be recognized as legitimate value during optimization)
         spoilvar = -1;
         spoilval = NAN;
      }
      spdmatrixrndcond(n, 1.0E5, &fulla);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         b.xR[i] = hqrndnormal(&rs);
         x0.xR[i] = hqrndnormal(&rs);
      }
      minlbfgscreate(n, 1, &x0, &state);
      minlbfgssetcond(&state, 0.0, 0.0, 0.0, stopiteration);
      minlbfgssetxrep(&state, true);
      k = -1;
      while (minlbfgsiteration(&state))
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += b.xR[i] * state.x.xR[i];
               state.g.xR[i] = b.xR[i];
               for (j = 0; j < n; j++) {
                  state.f += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                  state.g.xR[i] += fulla.xyR[i][j] * state.x.xR[j];
               }
            }
            if (k >= spoiliteration) {
               if (spoilvar < 0) {
                  state.f = spoilval;
               } else {
                  state.g.xR[spoilvar] = spoilval;
               }
            }
         } else if (state.xupdated) {
            k++;
         } else ae_assert(false, "Assertion failed");
      minlbfgsresults(&state, &x1, &rep);
      Ok = Ok && rep.terminationtype == -8;
   }
// Check algorithm ability to handle request for termination:
// * to terminate with correct return code = 8
// * to return point which was "current" at the moment of termination
   for (pass = 1; pass <= 50; pass++) {
      n = 3;
      ss = 100.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 6 + randomreal();
      }
      stopcallidx = randominteger(20);
      maxits = 25;
      minlbfgscreate(n, 1, &x, &state);
      minlbfgssetcond(&state, 0.0, 0.0, 0.0, maxits);
      minlbfgssetxrep(&state, true);
      callidx = 0;
      terminationrequested = false;
      ae_v_move(xlast.xR, 1, x.xR, 1, n);
      while (minlbfgsiteration(&state))
         if (state.needfg) {
            state.f = ss * sqr(exp(state.x.xR[0]) - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
            state.g.xR[0] = 2 * ss * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[2] - state.x.xR[0]) * (-1);
            state.g.xR[1] = 2 * state.x.xR[1];
            state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
            if (callidx == stopcallidx) {
               minlbfgsrequesttermination(&state);
               terminationrequested = true;
            }
            callidx++;
         } else if (state.xupdated) {
            if (!terminationrequested) {
               ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
            }
         } else ae_assert(false, "Assertion failed");
      minlbfgsresults(&state, &x, &rep);
      Ok = Ok && rep.terminationtype == 8;
      for (i = 0; i < n; i++) {
         Ok = Ok && x.xR[i] == xlast.xR[i];
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests report of "non-C1" test #0 for task #0
// given by matrix A.
static bool testminlbfgsunit_testoptguardc1test0reportfortask0(optguardnonc1test0report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool hasc1discontinuities;
   bool Ok = true;
   if (rep->positive) {
   // Check positive report, first checks
      Ok = Ok && rep->fidx == 0;
      Ok = Ok && rep->n == n;
      Ok = Ok && 0 <= rep->stpidxa;
      Ok = Ok && rep->stpidxa < rep->stpidxb;
      Ok = Ok && rep->stpidxb < rep->cnt;
      Ok = Ok && rep->x0.cnt == rep->n;
      Ok = Ok && rep->d.cnt == rep->n;
      Ok = Ok && rep->stp.cnt == rep->cnt;
      Ok = Ok && rep->f.cnt == rep->cnt;
      Ok = Ok && isfinitevector(&rep->x0, n);
      Ok = Ok && isfinitevector(&rep->d, n);
      Ok = Ok && isfinitevector(&rep->stp, rep->cnt);
      Ok = Ok && isfinitevector(&rep->f, rep->cnt);
      if (!Ok) {
         return Ok;
      }
   // Check consistency of X0, D, Stp and F
      for (k = 0; k < rep->cnt - 1; k++) {
         Ok = Ok && rep->stp.xR[k] < rep->stp.xR[k + 1];
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += fabs(vv);
         }
         Ok = Ok && NearAtR(v, rep->f.xR[k], 1.0E-6 * rmax2(fabs(v), 1.0));
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      Ok = Ok && hasc1discontinuities;
   } else {
   // Check negative report: fields must be empty
      Ok = Ok && rep->stpidxa == -1;
      Ok = Ok && rep->stpidxb == -1;
      Ok = Ok && rep->fidx == -1;
      Ok = Ok && rep->cnt == 0;
      Ok = Ok && rep->n == 0;
      Ok = Ok && rep->x0.cnt == 0;
      Ok = Ok && rep->d.cnt == 0;
      Ok = Ok && rep->stp.cnt == 0;
      Ok = Ok && rep->f.cnt == 0;
   }
   return Ok;
}

// This function tests report of "non-C1" test #1 for task #0
// given by matrix A.
static bool testminlbfgsunit_testoptguardc1test1reportfortask0(optguardnonc1test1report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool tooclose;
   bool hasc1discontinuities;
   bool Ok = true;
   if (rep->positive) {
   // Check positive report, first checks
      Ok = Ok && rep->fidx == 0;
      Ok = Ok && rep->vidx >= 0;
      Ok = Ok && rep->vidx <= n;
      Ok = Ok && rep->n == n;
      Ok = Ok && 0 <= rep->stpidxa;
      Ok = Ok && rep->stpidxa < rep->stpidxb;
      Ok = Ok && rep->stpidxb < rep->cnt;
      Ok = Ok && rep->x0.cnt == rep->n;
      Ok = Ok && rep->d.cnt == rep->n;
      Ok = Ok && rep->stp.cnt == rep->cnt;
      Ok = Ok && rep->g.cnt == rep->cnt;
      Ok = Ok && isfinitevector(&rep->x0, n);
      Ok = Ok && isfinitevector(&rep->d, n);
      Ok = Ok && isfinitevector(&rep->stp, rep->cnt);
      Ok = Ok && isfinitevector(&rep->g, rep->cnt);
      if (!Ok) {
         return Ok;
      }
   // Check consistency of X0, D, Stp and G
      for (k = 0; k < rep->cnt - 1; k++) {
         Ok = Ok && rep->stp.xR[k] < rep->stp.xR[k + 1];
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         tooclose = false;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += sign(vv) * a->xyR[i][rep->vidx];
            tooclose = tooclose || SmallR(vv, 1.0E-4);
         }
         if (!tooclose) {
            Ok = Ok && NearAtR(v, rep->g.xR[k], 1.0E-6 * rmax2(fabs(v), 1.0));
         }
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      tooclose = false;
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         tooclose = tooclose || SmallR(va, 1.0E-8) || SmallR(vb, 1.0E-8);
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      if (!tooclose) {
         Ok = Ok && hasc1discontinuities;
      }
   } else {
   // Check negative report: fields must be empty
      Ok = Ok && rep->stpidxa == -1;
      Ok = Ok && rep->stpidxb == -1;
      Ok = Ok && rep->fidx == -1;
      Ok = Ok && rep->vidx == -1;
      Ok = Ok && rep->cnt == 0;
      Ok = Ok && rep->n == 0;
      Ok = Ok && rep->x0.cnt == 0;
      Ok = Ok && rep->d.cnt == 0;
      Ok = Ok && rep->stp.cnt == 0;
      Ok = Ok && rep->g.cnt == 0;
   }
   return Ok;
}

// This function tests OptGuard
static bool testminlbfgsunit_testoptguard() {
   ae_frame _frame_block;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t m;
   double diffstep;
   ae_int_t pass;
   ae_int_t defecttype;
   bool failed;
   ae_int_t passcount;
   ae_int_t maxfails;
   ae_int_t failurecounter;
   ae_int_t maxc1test0fails;
   ae_int_t maxc1test1fails;
   ae_int_t c1test0fails;
   ae_int_t c1test1fails;
   double avgstr0len;
   double avglng0len;
   double avgstr1len;
   double avglng1len;
   ae_int_t varidx;
   ae_int_t skind;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minlbfgsstate, state);
   NewObj(minlbfgsreport, rep);
   NewObj(optguardreport, ogrep);
   NewObj(optguardnonc1test0report, ognonc1test0strrep);
   NewObj(optguardnonc1test0report, ognonc1test0lngrep);
   NewObj(optguardnonc1test1report, ognonc1test1strrep);
   NewObj(optguardnonc1test1report, ognonc1test1lngrep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewMatrix(jactrue, 0, 0, DT_REAL);
   NewMatrix(jacdefect, 0, 0, DT_REAL);
   hqrndrandomize(&rs);
// Check that gradient verification is disabled by default:
// gradient checking for bad problem must return nothing
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = 1.0 + 0.1 * i;
   }
   spdmatrixrndcond(n, 1.0E3, &a);
   spdmatrixrndcond(n, 1.0E3, &a1);
   minlbfgscreate(n, 3, &x0, &state);
   minlbfgssetcond(&state, 0.0, 0.0, 1.0E-9, 10);
   while (minlbfgsiteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += 0.5 * state.x.xR[i] * v;
         }
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
      } else ae_assert(false, "Assertion failed");
   minlbfgsresults(&state, &x1, &rep);
   minlbfgsoptguardresults(&state, &ogrep);
   Ok = Ok && rep.terminationtype > 0;
   Ok = Ok && isfinitevector(&x1, n);
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && ogrep.badgradxbase.cnt == 0;
   Ok = Ok && ogrep.badgraduser.rows == 0;
   Ok = Ok && ogrep.badgraduser.cols == 0;
   Ok = Ok && ogrep.badgradnum.rows == 0;
   Ok = Ok && ogrep.badgradnum.cols == 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && !ogrep.badgradsuspected;
   Ok = Ok && ogrep.badgradfidx == -1;
   Ok = Ok && ogrep.badgradvidx == -1;
// Test that C0/C1 continuity monitoring is disabled by default;
// we solve nonsmooth problem and test that nothing is returned
// by OptGuard.
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = hqrndnormal(&rs);
   }
   ae_matrix_set_length(&a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a.xyR[i][j] = hqrndnormal(&rs);
      }
   }
   minlbfgscreate(n, 2, &x0, &state);
   minlbfgssetcond(&state, 0.0, 0.0, 1.0E-9, 50);
   while (minlbfgsiteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += fabs(v);
            v = (double)sign(v);
            for (j = 0; j < n; j++) {
               state.g.xR[j] += v * a.xyR[i][j];
            }
         }
      } else ae_assert(false, "Assertion failed");
   minlbfgsresults(&state, &x1, &rep);
   minlbfgsoptguardresults(&state, &ogrep);
   Ok = Ok && isfinitevector(&x1, n);
   Ok = Ok && rep.terminationtype > 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && !ogrep.nonc0suspected;
   Ok = Ok && !ogrep.nonc1suspected;
   Ok = Ok && optguardallclear(&ogrep);
   Ok = Ok && ogrep.nonc0fidx < 0;
   Ok = Ok && ogrep.nonc1fidx < 0;
   Ok = Ok && !ogrep.nonc1test0positive;
   Ok = Ok && !ogrep.nonc1test1positive;
// Test gradient checking functionality, try various
// defect types:
// * accidental zeroing of some gradient component
// * accidental addition of 1.0 to some component
// * accidental multiplication by 2.0
// Try distorting both target and constraints.
   diffstep = 0.001;
   n = 10;
   m = 2;
   for (skind = 0; skind <= 1; skind++) {
      for (defecttype = -1; defecttype <= 2; defecttype++) {
         varidx = hqrnduniformi(&rs, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, skind * 15.0 * hqrndmiduniformr(&rs));
            x0.xR[i] = (1.0 + 0.1 * i) * s.xR[i];
         }
         spdmatrixrndcond(n, 1.0E3, &a);
         spdmatrixrndcond(n, 1.0E3, &a1);
         minlbfgscreate(n, m, &x0, &state);
         minlbfgsoptguardgradient(&state, diffstep);
         minlbfgssetcond(&state, 0.0, 0.0, 1.0E-9, 10);
         minlbfgssetscale(&state, &s);
         while (minlbfgsiteration(&state))
            if (state.needfg) {
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += state.x.xR[j] / s.xR[j] * a.xyR[i][j];
                  }
                  state.f += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                  state.g.xR[i] = v;
               }
               if (defecttype == 0) {
                  state.g.xR[varidx] = 0.0;
               }
               if (defecttype == 1) {
                  state.g.xR[varidx]++;
               }
               if (defecttype == 2) {
                  state.g.xR[varidx] *= 2;
               }
               for (i = 0; i < n; i++) {
                  state.g.xR[i] /= s.xR[i];
               }
            } else ae_assert(false, "Assertion failed");
         minlbfgsresults(&state, &x1, &rep);
         minlbfgsoptguardresults(&state, &ogrep);
      // Check that something is returned
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && isfinitevector(&x1, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Compute reference values for true and spoiled Jacobian at X0
         Ok = Ok && isfinitevector(&ogrep.badgradxbase, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         ae_matrix_set_length(&jactrue, 1, n);
         ae_matrix_set_length(&jacdefect, 1, n);
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += ogrep.badgradxbase.xR[j] / s.xR[j] * a.xyR[i][j];
            }
            jactrue.xyR[0][i] = v;
            jacdefect.xyR[0][i] = v;
         }
         if (defecttype == 0) {
            jacdefect.xyR[0][varidx] = 0.0;
         }
         if (defecttype == 1) {
            jacdefect.xyR[0][varidx]++;
         }
         if (defecttype == 2) {
            jacdefect.xyR[0][varidx] *= 2;
         }
         for (i = 0; i < n; i++) {
            jactrue.xyR[0][i] /= s.xR[i];
            jacdefect.xyR[0][i] /= s.xR[i];
         }
      // Check OptGuard report
         Ok = Ok && apservisfinitematrix(&ogrep.badgraduser, 1, n);
         Ok = Ok && apservisfinitematrix(&ogrep.badgradnum, 1, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         if (defecttype >= 0) {
            Ok = Ok && ogrep.badgradsuspected;
            Ok = Ok && ogrep.badgradfidx == 0;
            Ok = Ok && ogrep.badgradvidx == varidx;
         } else {
            Ok = Ok && !ogrep.badgradsuspected;
            Ok = Ok && ogrep.badgradfidx == -1;
            Ok = Ok && ogrep.badgradvidx == -1;
         }
         for (j = 0; j < n; j++) {
            Ok = Ok && NearAtR(jactrue.xyR[0][j], ogrep.badgradnum.xyR[0][j], 0.01 / s.xR[j]);
            Ok = Ok && NearAtR(jacdefect.xyR[0][j], ogrep.badgraduser.xyR[0][j], 0.01 / s.xR[j]);
         }
      }
   }
// A test for detection of C1 continuity violations in the target.
//
// Target function is a sum of |(x,c_i)| for i = 1..N.
// No constraints is present.
// Analytic gradient is provided.
//
// OptGuard should be able to detect violations in more than
// 99.9% of runs; it means that 100 runs should have no more than 4
// failures in all cases (even after multiple repeated tests; according
// to the binomial distribution quantiles).
//
// We select some N and perform exhaustive search for this N.
   passcount = 100;
   maxfails = 4;
   maxc1test0fails = 10;
   maxc1test1fails = 10;
   n = 1 + hqrnduniformi(&rs, 10);
   m = 1 + hqrnduniformi(&rs, n);
   failurecounter = 0;
   c1test0fails = 0;
   c1test1fails = 0;
   avgstr0len = 0.0;
   avglng0len = 0.0;
   avgstr1len = 0.0;
   avglng1len = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = pow(2.0, hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      minlbfgscreate(n, m, &x0, &state);
      minlbfgssetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      minlbfgssetscale(&state, &s);
      minlbfgsoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminlbfgsunit_maxoptguardlevel));
      while (minlbfgsiteration(&state))
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.g.xR[i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
               v = (double)sign(v);
               for (j = 0; j < n; j++) {
                  state.g.xR[j] += v * a.xyR[i][j];
               }
            }
         } else ae_assert(false, "Assertion failed");
      minlbfgsresults(&state, &x1, &rep);
      minlbfgsoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Check generic OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      Ok = Ok && !ogrep.nonc0suspected;
      Ok = Ok && ogrep.nonc0fidx < 0;
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   // Check C1 continuity test #0
      minlbfgsoptguardnonc1test0results(&state, &ognonc1test0strrep, &ognonc1test0lngrep);
      minlbfgsoptguardnonc1test1results(&state, &ognonc1test1strrep, &ognonc1test1lngrep);
      if (ogrep.nonc1test0positive) {
         Ok = Ok && ogrep.nonc1suspected;
         Ok = Ok && ognonc1test0strrep.positive;
         Ok = Ok && ognonc1test0lngrep.positive;
         Ok = Ok && ogrep.nonc1fidx == 0;
         Ok = Ok && testminlbfgsunit_testoptguardc1test0reportfortask0(&ognonc1test0strrep, &a, n);
         Ok = Ok && testminlbfgsunit_testoptguardc1test0reportfortask0(&ognonc1test0lngrep, &a, n);
         avgstr0len += (double)ognonc1test0strrep.cnt / passcount;
         avglng0len += (double)ognonc1test0lngrep.cnt / passcount;
      } else {
         Ok = Ok && !ognonc1test0strrep.positive;
         Ok = Ok && !ognonc1test0lngrep.positive;
         Ok = Ok && testminlbfgsunit_testoptguardc1test0reportfortask0(&ognonc1test0strrep, &a, n);
         Ok = Ok && testminlbfgsunit_testoptguardc1test0reportfortask0(&ognonc1test0lngrep, &a, n);
         c1test0fails++;
      }
      if (ogrep.nonc1test1positive) {
         Ok = Ok && ogrep.nonc1suspected;
         Ok = Ok && ognonc1test1strrep.positive;
         Ok = Ok && ognonc1test1lngrep.positive;
         Ok = Ok && ogrep.nonc1fidx == 0;
         Ok = Ok && testminlbfgsunit_testoptguardc1test1reportfortask0(&ognonc1test1strrep, &a, n);
         Ok = Ok && testminlbfgsunit_testoptguardc1test1reportfortask0(&ognonc1test1lngrep, &a, n);
         avgstr1len += (double)ognonc1test1strrep.cnt / passcount;
         avglng1len += (double)ognonc1test1lngrep.cnt / passcount;
      } else {
         Ok = Ok && !ognonc1test1strrep.positive;
         Ok = Ok && !ognonc1test1lngrep.positive;
         Ok = Ok && testminlbfgsunit_testoptguardc1test1reportfortask0(&ognonc1test1strrep, &a, n);
         Ok = Ok && testminlbfgsunit_testoptguardc1test1reportfortask0(&ognonc1test1lngrep, &a, n);
         c1test1fails++;
      }
   }
   Ok = Ok && failurecounter <= maxfails;
   Ok = Ok && c1test0fails <= maxc1test0fails;
   Ok = Ok && c1test1fails <= maxc1test1fails;
   Ok = Ok && avglng0len > avgstr0len;
   Ok = Ok && avglng1len > avgstr1len;
// Detection of C1 continuity violations in the target under numerical differentiation:
// * target function is a sum of |(x,c_i)| for i = 1..N.
// * no constraints is present.
// * analytic gradient is provided.
//
// OptGuard should always be able to detect violations in more than
// 99% of runs (note: reduced strength when compared with analytic gradient);
// it means that 100 runs should have no more than 10 failures in all cases
// (even after multiple repeated tests; according to the binomial distribution
// quantiles).
//
// We select some N and perform exhaustive search for this N.
   diffstep = 0.0001;
   passcount = 100;
   maxfails = 10;
   n = 1 + hqrnduniformi(&rs, 10);
   m = 1 + hqrnduniformi(&rs, n);
   failurecounter = 0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 0.01 * pow(2.0, 0.33 * hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      minlbfgscreatef(n, m, &x0, diffstep, &state);
      minlbfgssetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      minlbfgsoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminlbfgsunit_maxoptguardlevel));
      while (minlbfgsiteration(&state))
         if (state.needf) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
            }
         } else ae_assert(false, "Assertion failed");
      minlbfgsresults(&state, &x1, &rep);
      minlbfgsoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Check OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      Ok = Ok && !ogrep.nonc0suspected;
      Ok = Ok && ogrep.nonc0fidx < 0;
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   }
   Ok = Ok && failurecounter <= maxfails;
// Make sure than no false positives are reported for larger
// problems where numerical noise can be an issue:
// * N == 100 dimensions
// * positive-definite quadratic programming problem
// * upper limit on iterations count, MaxIts == 25
// We simply test that OptGuard does not return error code.
   n = 100;
   m = 5;
   spdmatrixrndcond(n, 1.0E2, &a);
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = hqrndnormal(&rs);
      x0.xR[i] = pow(2.0, hqrndnormal(&rs));
   }
   minlbfgscreate(n, m, &x0, &state);
   minlbfgsoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminlbfgsunit_maxoptguardlevel));
   minlbfgssetcond(&state, 0.0, 0.0, 1.0E-9, 25);
   while (minlbfgsiteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += b.xR[i] * state.x.xR[i];
            state.g.xR[i] = b.xR[i];
            for (j = 0; j < n; j++) {
               state.f += 0.5 * state.x.xR[i] * a.xyR[i][j] * state.x.xR[j];
               state.g.xR[i] += a.xyR[i][j] * state.x.xR[j];
            }
         }
      } else ae_assert(false, "Assertion failed");
   minlbfgsresults(&state, &x1, &rep);
   Ok = Ok && isfinitevector(&x1, n);
   Ok = Ok && rep.terminationtype > 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   minlbfgsoptguardresults(&state, &ogrep);
   Ok = Ok && optguardallclear(&ogrep);
   ae_frame_leave();
   return Ok;
}

bool testminlbfgs() {
   ae_frame _frame_block;
   bool Ok;
   bool refOk;
   bool nonconvOk;
   bool eqOk;
   bool convOk;
   bool crashtestOk;
   bool otherOk;
   bool restartsOk;
   bool precOk;
   bool optguardOk;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_int_t maxits;
   double diffstep;
   ae_int_t dkind;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(diagh, 0, DT_REAL);
   NewObj(minlbfgsstate, state);
   NewObj(minlbfgsreport, rep);
   Ok = true;
   refOk = true;
   precOk = true;
   nonconvOk = true;
   restartsOk = true;
   eqOk = true;
   convOk = true;
   crashtestOk = true;
   otherOk = true;
   precOk = precOk && testminlbfgsunit_testpreconditioning();
   otherOk = otherOk && testminlbfgsunit_testother();
// Reference problem
   diffstep = 1.0E-6;
   for (dkind = 0; dkind <= 1; dkind++) {
      ae_vector_set_length(&x, 3);
      n = 3;
      m = 2;
      x.xR[0] = 50.0 * randommid();
      x.xR[1] = 50.0 * randommid();
      x.xR[2] = 50.0 * randommid();
      if (dkind == 0) {
         minlbfgscreate(n, m, &x, &state);
      }
      if (dkind == 1) {
         minlbfgscreatef(n, m, &x, diffstep, &state);
      }
      minlbfgssetcond(&state, 0.0, 0.0, 0.0, 0);
      while (minlbfgsiteration(&state))
         if (state.needf || state.needfg) {
            state.f = sqr(state.x.xR[0] - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
            if (state.needfg) {
               state.g.xR[0] = 2 * (state.x.xR[0] - 2) + 2 * (state.x.xR[0] - state.x.xR[2]);
               state.g.xR[1] = 2 * state.x.xR[1];
               state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
            }
         }
      minlbfgsresults(&state, &x, &rep);
      refOk = refOk && rep.terminationtype > 0 && NearAtR(x.xR[0], 2, 0.001) && SmallAtR(x.xR[1], 0.001) && NearAtR(x.xR[2], 2, 0.001);
   }
// nonconvex problems with complex surface: we start from point with very small
// gradient, but we need ever smaller gradient in the next step due to
// Wolfe conditions.
   diffstep = 1.0E-6;
   for (dkind = 0; dkind <= 1; dkind++) {
      ae_vector_set_length(&x, 1);
      n = 1;
      m = 1;
      v = -100.0;
      while (v < 0.1) {
         x.xR[0] = v;
         if (dkind == 0) {
            minlbfgscreate(n, m, &x, &state);
         }
         if (dkind == 1) {
            minlbfgscreatef(n, m, &x, diffstep, &state);
         }
         minlbfgssetcond(&state, 1.0E-9, 0.0, 0.0, 0);
         while (minlbfgsiteration(&state))
            if (state.needf || state.needfg) {
               state.f = sqr(state.x.xR[0]) / (1 + sqr(state.x.xR[0]));
               if (state.needfg) {
                  state.g.xR[0] = (2 * state.x.xR[0] * (1 + sqr(state.x.xR[0])) - sqr(state.x.xR[0]) * 2 * state.x.xR[0]) / sqr(1 + sqr(state.x.xR[0]));
               }
            }
         minlbfgsresults(&state, &x, &rep);
         nonconvOk = nonconvOk && rep.terminationtype > 0 && SmallAtR(x.xR[0], 0.001);
         v += 0.1;
      }
   }
// F2 problem with restarts:
// * make several iterations and restart BEFORE termination
// * iterate and restart AFTER termination
//
// NOTE: step is bounded from above to avoid premature convergence
   diffstep = 1.0E-6;
   for (dkind = 0; dkind <= 1; dkind++) {
      ae_vector_set_length(&x, 3);
      n = 3;
      m = 2;
      x.xR[0] = 10 + 10.0 * randomreal();
      x.xR[1] = 10 + 10.0 * randomreal();
      x.xR[2] = 10 + 10.0 * randomreal();
      if (dkind == 0) {
         minlbfgscreate(n, m, &x, &state);
      }
      if (dkind == 1) {
         minlbfgscreatef(n, m, &x, diffstep, &state);
      }
      minlbfgssetstpmax(&state, 0.1);
      minlbfgssetcond(&state, 0.0000001, 0.0, 0.0, 0);
      for (i = 0; i <= 10 && minlbfgsiteration(&state); i++) testminlbfgsunit_testfunc2(&state);
      x.xR[0] = 10 + 10.0 * randomreal();
      x.xR[1] = 10 + 10.0 * randomreal();
      x.xR[2] = 10 + 10.0 * randomreal();
      for (minlbfgsrestartfrom(&state, &x); minlbfgsiteration(&state); ) testminlbfgsunit_testfunc2(&state);
      minlbfgsresults(&state, &x, &rep);
      restartsOk = restartsOk && rep.terminationtype > 0 && NearAtR(x.xR[0], log(2.0), 0.01) && SmallAtR(x.xR[1], 0.01) && NearAtR(x.xR[2], log(2.0), 0.01);
      x.xR[0] = 10 + 10.0 * randomreal();
      x.xR[1] = 10 + 10.0 * randomreal();
      x.xR[2] = 10 + 10.0 * randomreal();
      for (minlbfgsrestartfrom(&state, &x); minlbfgsiteration(&state); ) testminlbfgsunit_testfunc2(&state);
      minlbfgsresults(&state, &x, &rep);
      restartsOk = restartsOk && rep.terminationtype > 0 && NearAtR(x.xR[0], log(2.0), 0.01) && SmallAtR(x.xR[1], 0.01) && NearAtR(x.xR[2], log(2.0), 0.01);
   }
// Linear equations
   diffstep = 1.0E-6;
   for (n = 1; n <= 10; n++) {
   // Prepare task
      ae_matrix_set_length(&a, n, n);
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xe, n);
      ae_vector_set_length(&b, n);
      for (i = 0; i < n; i++) {
         xe.xR[i] = randommid();
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = randommid();
         }
         a.xyR[i][i] += 3 * sign(a.xyR[i][i]);
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(a.xyR[i], 1, xe.xR, 1, n);
         b.xR[i] = v;
      }
   // Test different M/DKind
      for (m = 1; m <= n; m++) {
         for (dkind = 0; dkind <= 1; dkind++) {
         // Solve task
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            if (dkind == 0) {
               minlbfgscreate(n, m, &x, &state);
            }
            if (dkind == 1) {
               minlbfgscreatef(n, m, &x, diffstep, &state);
            }
            minlbfgssetcond(&state, 0.0, 0.0, 0.0, 0);
            while (minlbfgsiteration(&state))
               if (state.needf || state.needfg) {
                  state.f = 0.0;
                  if (state.needfg) {
                     for (i = 0; i < n; i++) {
                        state.g.xR[i] = 0.0;
                     }
                  }
                  for (i = 0; i < n; i++) {
                     v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
                     state.f += sqr(v - b.xR[i]);
                     if (state.needfg) {
                        for (j = 0; j < n; j++) {
                           state.g.xR[j] += 2 * (v - b.xR[i]) * a.xyR[i][j];
                        }
                     }
                  }
               }
            minlbfgsresults(&state, &x, &rep);
            eqOk = eqOk && rep.terminationtype > 0;
            for (i = 0; i < n; i++) {
               eqOk = eqOk && NearAtR(x.xR[i], xe.xR[i], 0.001);
            }
         }
      }
   }
// Testing convergence properties
   diffstep = 1.0E-6;
   for (dkind = 0; dkind <= 1; dkind++) {
      ae_vector_set_length(&x, 3);
      n = 3;
      m = 2;
      for (i = 0; i <= 2; i++) {
         x.xR[i] = 3.0 * randommid();
      }
      if (dkind == 0) {
         minlbfgscreate(n, m, &x, &state);
      }
      if (dkind == 1) {
         minlbfgscreatef(n, m, &x, diffstep, &state);
      }
      minlbfgssetcond(&state, 0.001, 0.0, 0.0, 0);
      while (minlbfgsiteration(&state)) testminlbfgsunit_testfunc3(&state);
      minlbfgsresults(&state, &x, &rep);
      convOk = convOk && rep.terminationtype == 4;
      for (i = 0; i <= 2; i++) {
         x.xR[i] = 3.0 * randommid();
      }
      if (dkind == 0) {
         minlbfgscreate(n, m, &x, &state);
      }
      if (dkind == 1) {
         minlbfgscreatef(n, m, &x, diffstep, &state);
      }
      minlbfgssetcond(&state, 0.0, 0.001, 0.0, 0);
      while (minlbfgsiteration(&state)) testminlbfgsunit_testfunc3(&state);
      minlbfgsresults(&state, &x, &rep);
      convOk = convOk && rep.terminationtype == 1;
      for (i = 0; i <= 2; i++) {
         x.xR[i] = 3.0 * randommid();
      }
      if (dkind == 0) {
         minlbfgscreate(n, m, &x, &state);
      }
      if (dkind == 1) {
         minlbfgscreatef(n, m, &x, diffstep, &state);
      }
      minlbfgssetcond(&state, 0.0, 0.0, 0.001, 0);
      while (minlbfgsiteration(&state)) testminlbfgsunit_testfunc3(&state);
      minlbfgsresults(&state, &x, &rep);
      convOk = convOk && rep.terminationtype == 2;
      for (i = 0; i <= 2; i++) {
         x.xR[i] = randommid();
      }
      if (dkind == 0) {
         minlbfgscreate(n, m, &x, &state);
      }
      if (dkind == 1) {
         minlbfgscreatef(n, m, &x, diffstep, &state);
      }
      minlbfgssetcond(&state, 0.0, 0.0, 0.0, 10);
      while (minlbfgsiteration(&state)) testminlbfgsunit_testfunc3(&state);
      minlbfgsresults(&state, &x, &rep);
      convOk = convOk && rep.terminationtype == 5 && rep.iterationscount == 10;
   }
// Crash test: too many iterations on a simple tasks
// May fail when encounter zero step, underflow or something like that
   ae_vector_set_length(&x, 2 + 1);
   n = 3;
   m = 2;
   maxits = 10000;
   for (i = 0; i <= 2; i++) {
      x.xR[i] = 3.0 * randommid();
   }
   minlbfgscreate(n, m, &x, &state);
   minlbfgssetcond(&state, 0.0, 0.0, 0.0, maxits);
   while (minlbfgsiteration(&state)) {
      state.f = sqr(exp(state.x.xR[0]) - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
      state.g.xR[0] = 2 * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[0] - state.x.xR[2]);
      state.g.xR[1] = 2 * state.x.xR[1];
      state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
   }
   minlbfgsresults(&state, &x, &rep);
   crashtestOk = crashtestOk && rep.terminationtype > 0;
// Test OptGuard
   optguardOk = true;
   optguardOk = optguardOk && testminlbfgsunit_testoptguard();
// The final report.
   Ok = refOk && nonconvOk && eqOk && convOk && crashtestOk && otherOk && restartsOk && precOk && optguardOk;
   if (!Ok || !silent) {
      printf("L-BFGS Optimization Tests\n");
      printf("Reference Problem:                        %s\n", refOk? "Ok": "Failed");
      printf("Non-Convex Problem:                       %s\n", nonconvOk? "Ok": "Failed");
      printf("Linear Equations:                         %s\n", eqOk? "Ok": "Failed");
      printf("Restarts:                                 %s\n", restartsOk? "Ok": "Failed");
      printf("Preconditioner:                           %s\n", precOk? "Ok": "Failed");
      printf("Convergence Properties:                   %s\n", convOk? "Ok": "Failed");
      printf("Crash Test:                               %s\n", crashtestOk? "Ok": "Failed");
      printf("Other Properties:                         %s\n", otherOk? "Ok": "Failed");
      printf("OptGuard:                                 %s\n", optguardOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === cqmodels testing unit ===
bool testcqmodels() {
   ae_frame _frame_block;
   bool eval0Ok;
   bool eval1Ok;
   bool eval2Ok;
   bool newton0Ok;
   bool newton1Ok;
   bool newton2Ok;
   bool Ok;
   ae_int_t nkind;
   ae_int_t kmax;
   ae_int_t n;
   ae_int_t k;
   ae_int_t i;
   ae_int_t pass;
   ae_int_t j;
   double alpha;
   double theta;
   double tau;
   double v;
   double v2;
   double h;
   double f0;
   double mkind;
   double xtadx2;
   double noise;
   ae_frame_make(&_frame_block);
   NewObj(convexquadraticmodel, s);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(r, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(ge, 0, DT_REAL);
   NewVector(gt, 0, DT_REAL);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(adx, 0, DT_REAL);
   NewVector(adxe, 0, DT_REAL);
   NewVector(activeset, 0, DT_BOOL);
   Ok = true;
// Eval0 test: unconstrained model evaluation
   eval0Ok = true;
   for (n = 1; n <= 5; n++) {
      for (k = 0; k <= 2 * n; k++) {
      // Allocate place
         ae_matrix_set_length(&a, n, n);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&ge, n);
         ae_vector_set_length(&gt, n);
         ae_vector_set_length(&tmp0, n);
         if (k > 0) {
            ae_matrix_set_length(&q, k, n);
            ae_vector_set_length(&r, k);
         }
      // Generate problem
         alpha = randomreal() + 1.0;
         theta = randomreal() + 1.0;
         tau = randomreal() * randominteger(2);
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 10 * (1 + randomreal());
            b.xR[i] = randommid();
            d.xR[i] = randomreal() + 1;
            for (j = i + 1; j < n; j++) {
               v = 0.05 * randommid();
               a.xyR[i][j] = v;
               a.xyR[j][i] = v;
            }
            for (j = 0; j < k; j++) {
               q.xyR[j][i] = randommid();
            }
         }
         for (i = 0; i < k; i++) {
            r.xR[i] = randommid();
         }
      // Build model
         cqminit(n, &s);
         cqmseta(&s, &a, randombool(), alpha);
         cqmsetb(&s, &b);
         cqmsetq(&s, &q, &r, k, theta);
         cqmsetd(&s, &d, tau);
      // Evaluate and compare:
      // * X          -   random point
      // * GE         -   "exact" gradient
      // * XTADX2     -   x'*(alpha*A+tau*D)*x/2
      // * ADXE       -   (alpha*A+tau*D)*x
      // * V          -   model value at X
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
            ge.xR[i] = 0.0;
         }
         v = 0.0;
         xtadx2 = 0.0;
         ae_vector_set_length(&adxe, n);
         for (i = 0; i < n; i++) {
            adxe.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            v += x.xR[i] * b.xR[i];
            ge.xR[i] += b.xR[i];
            v += 0.5 * sqr(x.xR[i]) * tau * d.xR[i];
            ge.xR[i] += x.xR[i] * tau * d.xR[i];
            adxe.xR[i] += x.xR[i] * tau * d.xR[i];
            xtadx2 += 0.5 * sqr(x.xR[i]) * tau * d.xR[i];
            for (j = 0; j < n; j++) {
               v += 0.5 * alpha * x.xR[i] * a.xyR[i][j] * x.xR[j];
               ge.xR[i] += alpha * a.xyR[i][j] * x.xR[j];
               adxe.xR[i] += alpha * a.xyR[i][j] * x.xR[j];
               xtadx2 += 0.5 * alpha * x.xR[i] * a.xyR[i][j] * x.xR[j];
            }
         }
         for (i = 0; i < k; i++) {
            v2 = ae_v_dotproduct(q.xyR[i], 1, x.xR, 1, n);
            v += 0.5 * theta * sqr(v2 - r.xR[i]);
            for (j = 0; j < n; j++) {
               ge.xR[j] += theta * (v2 - r.xR[i]) * q.xyR[i][j];
            }
         }
         v2 = cqmeval(&s, &x);
         eval0Ok = eval0Ok && NearAtR(v, v2, 10000.0 * machineepsilon);
         cqmevalx(&s, &x, &v2, &noise);
         eval0Ok = eval0Ok && NearAtR(v, v2, 10000.0 * machineepsilon);
         eval0Ok = eval0Ok && noise >= 0.0 && noise <= 10000.0 * machineepsilon;
         v2 = cqmxtadx2(&s, &x, &tmp0);
         eval0Ok = eval0Ok && NearAtR(xtadx2, v2, 10000.0 * machineepsilon);
         cqmgradunconstrained(&s, &x, &gt);
         for (i = 0; i < n; i++) {
            eval0Ok = eval0Ok && NearAtR(ge.xR[i], gt.xR[i], 10000.0 * machineepsilon);
         }
         cqmadx(&s, &x, &adx);
         for (i = 0; i < n; i++) {
            eval0Ok = eval0Ok && NearAtR(adx.xR[i], adxe.xR[i], 10000.0 * machineepsilon);
         }
      }
   }
   Ok = Ok && eval0Ok;
// Eval1 test: constrained model evaluation
   eval1Ok = true;
   for (n = 1; n <= 5; n++) {
      for (k = 0; k <= 2 * n; k++) {
      // Allocate place
         ae_matrix_set_length(&a, n, n);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&activeset, n);
         if (k > 0) {
            ae_matrix_set_length(&q, k, n);
            ae_vector_set_length(&r, k);
         }
      // Generate problem
         alpha = randomreal() + 1.0;
         theta = randomreal() + 1.0;
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 10 * (1 + randomreal());
            b.xR[i] = randommid();
            xc.xR[i] = randommid();
            activeset.xB[i] = randombool();
            for (j = i + 1; j < n; j++) {
               v = 0.05 * randommid();
               a.xyR[i][j] = v;
               a.xyR[j][i] = v;
            }
            for (j = 0; j < k; j++) {
               q.xyR[j][i] = randommid();
            }
         }
         for (i = 0; i < k; i++) {
            r.xR[i] = randommid();
         }
      // Build model, evaluate at random point X, compare
         cqminit(n, &s);
         cqmseta(&s, &a, randombool(), alpha);
         cqmsetb(&s, &b);
         cqmsetq(&s, &q, &r, k, theta);
         cqmsetactiveset(&s, &xc, &activeset);
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
            if (!activeset.xB[i]) {
               xc.xR[i] = x.xR[i];
            }
         }
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += xc.xR[i] * b.xR[i];
            for (j = 0; j < n; j++) {
               v += 0.5 * alpha * xc.xR[i] * a.xyR[i][j] * xc.xR[j];
            }
         }
         for (i = 0; i < k; i++) {
            v2 = ae_v_dotproduct(q.xyR[i], 1, xc.xR, 1, n);
            v += 0.5 * theta * sqr(v2 - r.xR[i]);
         }
         eval1Ok = eval1Ok && NearAtR(v, cqmeval(&s, &xc), 10000.0 * machineepsilon);
         eval1Ok = eval1Ok && NearAtR(v, cqmdebugconstrainedevalt(&s, &x), 10000.0 * machineepsilon);
         eval1Ok = eval1Ok && NearAtR(v, cqmdebugconstrainedevale(&s, &x), 10000.0 * machineepsilon);
      }
   }
   Ok = Ok && eval1Ok;
// Eval2 test: we generate empty problem and apply sequence of random transformations,
// re-evaluating and re-checking model after each modification.
//
// The purpose of such test is to ensure that our caching strategy works correctly.
   eval2Ok = true;
   for (n = 1; n <= 5; n++) {
      kmax = 2 * n;
      ae_matrix_set_length(&a, n, n);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&d, n);
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xc, n);
      ae_matrix_set_length(&q, kmax, n);
      ae_vector_set_length(&r, kmax);
      ae_vector_set_length(&activeset, n);
      ae_vector_set_length(&tmp0, n);
      alpha = 0.0;
      theta = 0.0;
      k = 0;
      tau = 1.0 + randomreal();
      for (i = 0; i < n; i++) {
         activeset.xB[i] = false;
         d.xR[i] = 1.0;
         b.xR[i] = 0.0;
         xc.xR[i] = randommid();
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = 0.0;
         }
      }
      cqminit(n, &s);
      cqmsetd(&s, &d, tau);
      for (pass = 1; pass <= 100; pass++) {
      // Select random modification type, apply modification.
      //
      // MKind is a random integer in [0,7] - number of specific
      // modification to apply.
         mkind = (double)randominteger(8);
         if (mkind == 0.0) {
         // Set non-zero D
            tau = 1.0 + randomreal();
            for (i = 0; i < n; i++) {
               d.xR[i] = 2.0 * randomreal() + 1;
            }
            cqmsetd(&s, &d, tau);
         } else {
            if (mkind == 1.0) {
            // Set zero D.
            // In case Alpha == 0, set non-zero A.
               if (alpha == 0.0) {
                  alpha = 1.0 + randomreal();
                  for (i = 0; i < n; i++) {
                     for (j = i + 1; j < n; j++) {
                        a.xyR[i][j] = 0.1 * randommid();
                        a.xyR[j][i] = a.xyR[i][j];
                     }
                  }
                  for (i = 0; i < n; i++) {
                     a.xyR[i][i] = 4 + 2.0 * randomreal();
                  }
                  cqmseta(&s, &a, randombool(), alpha);
               }
               tau = 0.0;
               for (i = 0; i < n; i++) {
                  d.xR[i] = 0.0;
               }
               cqmsetd(&s, &d, 0.0);
            } else {
               if (mkind == 2.0) {
               // Set non-zero A
                  alpha = 1.0 + randomreal();
                  for (i = 0; i < n; i++) {
                     for (j = i + 1; j < n; j++) {
                        a.xyR[i][j] = 0.1 * randommid();
                        a.xyR[j][i] = a.xyR[i][j];
                     }
                  }
                  for (i = 0; i < n; i++) {
                     a.xyR[i][i] = 4 + 2.0 * randomreal();
                  }
                  cqmseta(&s, &a, randombool(), alpha);
               } else {
                  if (mkind == 3.0) {
                  // Set zero A.
                  // In case Tau == 0, set non-zero D.
                     if (tau == 0.0) {
                        tau = 1.0 + randomreal();
                        for (i = 0; i < n; i++) {
                           d.xR[i] = 2.0 * randomreal() + 1;
                        }
                        cqmsetd(&s, &d, tau);
                     }
                     alpha = 0.0;
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] = 0.0;
                        }
                     }
                     cqmseta(&s, &a, randombool(), alpha);
                  } else {
                     if (mkind == 4.0) {
                     // Set B.
                        for (i = 0; i < n; i++) {
                           b.xR[i] = randommid();
                        }
                        cqmsetb(&s, &b);
                     } else {
                        if (mkind == 5.0) {
                        // Set Q.
                           k = randominteger(kmax + 1);
                           theta = 1.0 + randomreal();
                           for (i = 0; i < k; i++) {
                              r.xR[i] = randommid();
                              for (j = 0; j < n; j++) {
                                 q.xyR[i][j] = randommid();
                              }
                           }
                           cqmsetq(&s, &q, &r, k, theta);
                        } else {
                           if (mkind == 6.0) {
                           // Set active set
                              for (i = 0; i < n; i++) {
                                 activeset.xB[i] = randombool();
                                 xc.xR[i] = randommid();
                              }
                              cqmsetactiveset(&s, &xc, &activeset);
                           } else {
                              if (mkind == 7.0) {
                              // Rewrite main diagonal
                                 if (alpha == 0.0) {
                                    alpha = 1.0;
                                 }
                                 for (i = 0; i < n; i++) {
                                    tmp0.xR[i] = 1 + randomreal();
                                    a.xyR[i][i] = tmp0.xR[i] / alpha;
                                 }
                                 cqmrewritedensediagonal(&s, &tmp0);
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      // generate random point with respect to constraints,
      // test model at this point
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
            if (activeset.xB[i]) {
               x.xR[i] = xc.xR[i];
            }
         }
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += x.xR[i] * b.xR[i];
         }
         if (tau > 0.0) {
            for (i = 0; i < n; i++) {
               v += 0.5 * tau * d.xR[i] * sqr(x.xR[i]);
            }
         }
         if (alpha > 0.0) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v += 0.5 * alpha * x.xR[i] * a.xyR[i][j] * x.xR[j];
               }
            }
         }
         if (theta > 0.0) {
            for (i = 0; i < k; i++) {
               v2 = ae_v_dotproduct(q.xyR[i], 1, x.xR, 1, n);
               v += 0.5 * theta * sqr(v2 - r.xR[i]);
            }
         }
         v2 = cqmeval(&s, &x);
         eval2Ok = eval2Ok && NearAtR(v, v2, 10000.0 * machineepsilon);
         v2 = cqmdebugconstrainedevalt(&s, &x);
         eval2Ok = eval2Ok && NearAtR(v, v2, 10000.0 * machineepsilon);
         v2 = cqmdebugconstrainedevale(&s, &x);
         eval2Ok = eval2Ok && NearAtR(v, v2, 10000.0 * machineepsilon);
      }
   }
   Ok = Ok && eval2Ok;
// Newton0 test: unconstrained optimization
   newton0Ok = true;
   for (n = 1; n <= 5; n++) {
      for (k = 0; k <= 2 * n; k++) {
      // Allocate place
         ae_matrix_set_length(&a, n, n);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&x0, n);
         if (k > 0) {
            ae_matrix_set_length(&q, k, n);
            ae_vector_set_length(&r, k);
         }
      // Generate problem with known solution x0:
      //   min f(x),
      //   f(x) = 0.5*(x-x0)'*A*(x-x0)
      //        = 0.5*x'*A*x + (-x0'*A)*x + 0.5*x0'*A*x0'
         alpha = randomreal() + 1.0;
         for (i = 0; i < n; i++) {
            x0.xR[i] = randommid();
            a.xyR[i][i] = 10 * (1 + randomreal());
            for (j = i + 1; j < n; j++) {
               v = 0.05 * randommid();
               a.xyR[i][j] = v;
               a.xyR[j][i] = v;
            }
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, x0.xR, 1, n);
            b.xR[i] = -alpha * v;
         }
         theta = randomreal() + 1.0;
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               q.xyR[i][j] = randommid();
            }
            v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
            r.xR[i] = v;
         }
      // Build model, evaluate at random point X, compare
         cqminit(n, &s);
         cqmseta(&s, &a, randombool(), alpha);
         cqmsetb(&s, &b);
         cqmsetq(&s, &q, &r, k, theta);
         cqmconstrainedoptimum(&s, &x);
         for (i = 0; i < n; i++) {
            newton0Ok = newton0Ok && NearAtR(x.xR[i], x0.xR[i], 1.0E6 * machineepsilon);
         }
      }
   }
   Ok = Ok && newton0Ok;
// Newton1 test: constrained optimization
   newton1Ok = true;
   h = 1.0E-3;
   for (n = 1; n <= 5; n++) {
      for (k = 0; k <= 2 * n; k++) {
      // Allocate place
         ae_matrix_set_length(&a, n, n);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&activeset, n);
         if (k > 0) {
            ae_matrix_set_length(&q, k, n);
            ae_vector_set_length(&r, k);
         }
      // Generate test problem with unknown solution.
         alpha = randomreal() + 1.0;
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 10 * (1 + randomreal());
            b.xR[i] = randommid();
            xc.xR[i] = randommid();
            activeset.xB[i] = randombool();
            for (j = i + 1; j < n; j++) {
               v = 0.05 * randommid();
               a.xyR[i][j] = v;
               a.xyR[j][i] = v;
            }
         }
         theta = randomreal() + 1.0;
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               q.xyR[i][j] = randommid();
            }
            r.xR[i] = randommid();
         }
      // Build model, find solution
         cqminit(n, &s);
         cqmseta(&s, &a, randombool(), alpha);
         cqmsetb(&s, &b);
         cqmsetq(&s, &q, &r, k, theta);
         cqmsetactiveset(&s, &xc, &activeset);
         if (cqmconstrainedoptimum(&s, &x)) {
         // Check that constraints are satisfied,
         // and that solution is true optimum
            f0 = cqmeval(&s, &x);
            for (i = 0; i < n; i++) {
               newton1Ok = newton1Ok && (!activeset.xB[i] || x.xR[i] == xc.xR[i]);
               if (!activeset.xB[i]) {
                  v = x.xR[i];
                  x.xR[i] = v + h;
                  v2 = cqmeval(&s, &x);
                  newton1Ok = newton1Ok && v2 >= f0;
                  x.xR[i] = v - h;
                  v2 = cqmeval(&s, &x);
                  newton1Ok = newton1Ok && v2 >= f0;
                  x.xR[i] = v;
               }
            }
         } else {
            newton1Ok = false;
         }
      }
   }
   Ok = Ok && newton1Ok;
// Newton2 test: we test ability to work with diagonal matrices, including
// very large ones (up to 100.000 elements). This test checks that:
// a) we can work with Alpha == 0, i.e. when we have strictly diagonal A
// b) diagonal problems are handled efficiently, i.e. algorithm will
//    successfully solve problem with N == 100.000
//
// Test problem:
// * diagonal term D and rank-K term Q
// * known solution X0,
// * about 50% of constraints are active and equal to components of X0
   newton2Ok = true;
   for (nkind = 0; nkind <= 5; nkind++) {
      for (k = 0; k <= 5; k++) {
         n = iround(pow((double)n, (double)nkind));
      // generate problem
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&activeset, n);
         if (k > 0) {
            ae_matrix_set_length(&q, k, n);
            ae_vector_set_length(&r, k);
         }
         tau = 1 + randomreal();
         theta = 1 + randomreal();
         for (i = 0; i < n; i++) {
            x0.xR[i] = randommid();
            d.xR[i] = 1 + randomreal();
            b.xR[i] = -x0.xR[i] * tau * d.xR[i];
            activeset.xB[i] = randombool();
         }
         for (i = 0; i < k; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               q.xyR[i][j] = randommid();
               v += q.xyR[i][j] * x0.xR[j];
            }
            r.xR[i] = v;
         }
      // Solve, test
         cqminit(n, &s);
         cqmsetb(&s, &b);
         cqmsetd(&s, &d, tau);
         cqmsetq(&s, &q, &r, k, theta);
         cqmsetactiveset(&s, &x0, &activeset);
         if (cqmconstrainedoptimum(&s, &x)) {
         // Check that constraints are satisfied,
         // and that solution is true optimum
            f0 = cqmeval(&s, &x);
            for (i = 0; i < n; i++) {
               newton2Ok = newton2Ok && (!activeset.xB[i] || x.xR[i] == x0.xR[i]);
               newton2Ok = newton2Ok && (activeset.xB[i] || NearAtR(x.xR[i], x0.xR[i], 1000.0 * machineepsilon));
            }
         // Check that constrained evaluation at some point gives correct results
            for (i = 0; i < n; i++) {
               if (activeset.xB[i]) {
                  x.xR[i] = x0.xR[i];
               } else {
                  x.xR[i] = randommid();
               }
            }
            v = 0.0;
            for (i = 0; i < n; i++) {
               v += 0.5 * tau * d.xR[i] * sqr(x.xR[i]) + x.xR[i] * b.xR[i];
            }
            for (i = 0; i < k; i++) {
               v2 = ae_v_dotproduct(q.xyR[i], 1, x.xR, 1, n);
               v += 0.5 * theta * sqr(v2 - r.xR[i]);
            }
            v2 = cqmeval(&s, &x);
            newton2Ok = newton2Ok && isfinite(v2) && NearAtR(v, v2, 10000.0 * machineepsilon);
            v2 = cqmdebugconstrainedevalt(&s, &x);
            newton2Ok = newton2Ok && isfinite(v2) && NearAtR(v, v2, 10000.0 * machineepsilon);
            v2 = cqmdebugconstrainedevale(&s, &x);
            newton2Ok = newton2Ok && isfinite(v2) && NearAtR(v, v2, 10000.0 * machineepsilon);
         } else {
            newton2Ok = false;
         }
      }
   }
   Ok = Ok && newton2Ok;
// The final report.
   if (!Ok || !silent) {
      printf("Convex Quadratic Models Tests\n");
      printf("Eval0 Test:                               %s\n", eval0Ok? "Ok": "Failed");
      printf("Eval1 Test:                               %s\n", eval1Ok? "Ok": "Failed");
      printf("Eval2 Test:                               %s\n", eval2Ok? "Ok": "Failed");
      printf("Newton0 Test:                             %s\n", newton0Ok? "Ok": "Failed");
      printf("Newton1 Test:                             %s\n", newton1Ok? "Ok": "Failed");
      printf("Newton2 Test:                             %s\n", newton2Ok? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === snnls testing unit ===
bool testsnnls() {
   ae_frame _frame_block;
   bool test0Ok;
   bool test1Ok;
   bool test2Ok;
   bool testnewtonOk;
   bool Ok;
   double eps;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_int_t ns;
   ae_int_t nd;
   ae_int_t nr;
   double rho;
   double xtol;
   ae_int_t nmax;
   ae_frame_make(&_frame_block);
   NewMatrix(densea, 0, 0, DT_REAL);
   NewMatrix(effectivea, 0, 0, DT_REAL);
   NewVector(isconstrained, 0, DT_BOOL);
   NewVector(g, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewObj(snnlssolver, s);
   NewObj(hqrndstate, rs);
   test0Ok = true;
   test1Ok = true;
   test2Ok = true;
   testnewtonOk = true;
   Ok = true;
   hqrndrandomize(&rs);
   nmax = 10;
// Test 2 (comes first because it is very basic):
// * NS == 0
// * ND in [1,NMAX]
// * NR == ND
// * DenseA is diagonal with positive entries
// * B is random
// * random constraints
// Exact solution is known and can be tested
   eps = 1.0E-12;
   for (nd = 1; nd <= nmax; nd++) {
   // Generate problem
      ns = 0;
      nr = nd;
      ae_matrix_set_length(&densea, nd, nd);
      ae_vector_set_length(&b, nd);
      ae_vector_set_length(&isconstrained, nd);
      for (i = 0; i < nd; i++) {
         for (j = 0; j < nd; j++) {
            densea.xyR[i][j] = 0.0;
         }
         densea.xyR[i][i] = (double)(1 + hqrnduniformi(&rs, 2));
         b.xR[i] = (double)((1 + hqrnduniformi(&rs, 2)) * (2 * hqrnduniformi(&rs, 2) - 1));
         isconstrained.xB[i] = hqrnduniformr(&rs) > 0.5;
      }
   // Solve with SNNLS solver
      snnlsinit(0, 0, 0, &s);
      snnlssetproblem(&s, &densea, &b, 0, nd, nd);
      for (i = 0; i < nd; i++) {
         if (!isconstrained.xB[i]) {
            snnlsdropnnc(&s, i);
         }
      }
      snnlssolve(&s, &x);
   // Check
      for (i = 0; i < nd; i++) {
         if (isconstrained.xB[i]) {
            test2Ok = test2Ok && NearAtR(x.xR[i], rmax2(b.xR[i] / densea.xyR[i][i], 0.0), eps);
            test2Ok = test2Ok && x.xR[i] >= 0.0;
         } else {
            test2Ok = test2Ok && NearAtR(x.xR[i], b.xR[i] / densea.xyR[i][i], eps);
         }
      }
   }
// Test 0:
// * NS in [0,NMAX]
// * ND in [0,NMAX]
// * NR in [NS,NS+ND+NMAX]
// * NS+ND > 0, NR > 0
// * about 50% of variables are constrained
// * we check that constrained gradient is small at the solution
   eps = 1.0E-5;
   for (ns = 0; ns <= nmax; ns++) {
      for (nd = 0; nd <= nmax; nd++) {
         for (nr = ns; nr <= ns + nd + nmax; nr++) {
         // Skip NS+ND == 0, NR == 0
            if (ns + nd == 0) {
               continue;
            }
            if (nr == 0) {
               continue;
            }
         // Generate problem:
         // * DenseA, array[NR,ND]
         // * EffectiveA, array[NR,NS+ND]
         // * B, array[NR]
         // * IsConstrained, array[NS+ND]
            if (nd > 0) {
               ae_matrix_set_length(&densea, nr, nd);
               for (i = 0; i < nr; i++) {
                  for (j = 0; j < nd; j++) {
                     densea.xyR[i][j] = randommid();
                  }
               }
            }
            ae_matrix_set_length(&effectivea, nr, ns + nd);
            for (i = 0; i < nr; i++) {
               for (j = 0; j < ns + nd; j++) {
                  effectivea.xyR[i][j] = 0.0;
               }
            }
            for (i = 0; i < ns; i++) {
               effectivea.xyR[i][i] = 1.0;
            }
            for (i = 0; i < nr; i++) {
               for (j = 0; j < nd; j++) {
                  effectivea.xyR[i][ns + j] = densea.xyR[i][j];
               }
            }
            ae_vector_set_length(&b, nr);
            for (i = 0; i < nr; i++) {
               b.xR[i] = randommid();
            }
            ae_vector_set_length(&isconstrained, ns + nd);
            for (i = 0; i < ns + nd; i++) {
               isconstrained.xB[i] = randombool();
            }
         // Solve with SNNLS solver
            snnlsinit(0, 0, 0, &s);
            snnlssetproblem(&s, &densea, &b, ns, nd, nr);
            for (i = 0; i < ns + nd; i++) {
               if (!isconstrained.xB[i]) {
                  snnlsdropnnc(&s, i);
               }
            }
            snnlssolve(&s, &x);
         // Check non-negativity
            for (i = 0; i < ns + nd; i++) {
               test0Ok = test0Ok && (!isconstrained.xB[i] || x.xR[i] >= 0.0);
            }
         // Calculate gradient A'*A*x-b'*A.
         // Check projected gradient (each component must be less than Eps).
            ae_vector_set_length(&g, ns + nd);
            for (i = 0; i < ns + nd; i++) {
               v = ae_v_dotproduct(b.xR, 1, &effectivea.xyR[0][i], effectivea.stride, nr);
               g.xR[i] = -v;
            }
            for (i = 0; i < nr; i++) {
               v = ae_v_dotproduct(effectivea.xyR[i], 1, x.xR, 1, ns + nd);
               ae_v_addd(g.xR, 1, effectivea.xyR[i], 1, ns + nd, v);
            }
            for (i = 0; i < ns + nd; i++) {
               if (!isconstrained.xB[i] || x.xR[i] > 0.0) {
                  test0Ok = test0Ok && SmallAtR(g.xR[i], eps);
               } else {
                  test0Ok = test0Ok && g.xR[i] >= -eps;
               }
            }
         }
      }
   }
// Test 1: ability of the solver to take very short steps.
//
// We solve problem similar to one solver in test 0, but with
// progressively decreased magnitude of variables. We generate
// problem with already-known solution and compare results against it.
   xtol = 1.0E-7;
   for (ns = 0; ns <= nmax; ns++) {
      for (nd = 0; nd <= nmax; nd++) {
         for (nr = ns; nr <= ns + nd + nmax; nr++) {
            for (k = 0; k <= 20; k++) {
            // Skip NS+ND == 0, NR == 0
            //
            // Skip degenerate problems (NR < NS+ND) - important for this particular test.
               if (ns + nd == 0) {
                  continue;
               }
               if (nr == 0) {
                  continue;
               }
               if (nr < ns + nd) {
                  continue;
               }
            // Generate problem:
            // * DenseA, array[NR,ND]
            // * EffectiveA, array[NR,NS+ND]
            // * B, array[NR]
            // * IsConstrained, array[NS+ND]
               rho = pow(10.0, (double)-k);
               if (nd > 0) {
                  ae_matrix_set_length(&densea, nr, nd);
                  for (i = 0; i < nr; i++) {
                     for (j = 0; j < nd; j++) {
                        densea.xyR[i][j] = hqrndmiduniformr(&rs);
                     }
                  }
               }
               ae_matrix_set_length(&effectivea, nr, ns + nd);
               for (i = 0; i < nr; i++) {
                  for (j = 0; j < ns + nd; j++) {
                     effectivea.xyR[i][j] = 0.0;
                  }
               }
               for (i = 0; i < ns; i++) {
                  effectivea.xyR[i][i] = 1.0;
               }
               for (i = 0; i < nr; i++) {
                  for (j = 0; j < nd; j++) {
                     effectivea.xyR[i][ns + j] = densea.xyR[i][j];
                  }
               }
               ae_vector_set_length(&xs, ns + nd);
               ae_vector_set_length(&isconstrained, ns + nd);
               for (i = 0; i < ns + nd; i++) {
                  xs.xR[i] = rho * (hqrnduniformr(&rs) - 0.5);
                  isconstrained.xB[i] = xs.xR[i] > 0.0;
               }
               ae_vector_set_length(&b, nr);
               for (i = 0; i < nr; i++) {
                  v = 0.0;
                  for (j = 0; j < ns + nd; j++) {
                     v += effectivea.xyR[i][j] * xs.xR[j];
                  }
                  b.xR[i] = v;
               }
            // Solve with SNNLS solver
               snnlsinit(0, 0, 0, &s);
               snnlssetproblem(&s, &densea, &b, ns, nd, nr);
               for (i = 0; i < ns + nd; i++) {
                  if (!isconstrained.xB[i]) {
                     snnlsdropnnc(&s, i);
                  }
               }
               snnlssolve(&s, &x);
            // Check non-negativity
               for (i = 0; i < ns + nd; i++) {
                  test1Ok = test1Ok && (!isconstrained.xB[i] || x.xR[i] >= 0.0);
               }
            // Compare with true solution
               for (i = 0; i < ns + nd; i++) {
                  test1Ok = test1Ok && NearAtR(xs.xR[i], x.xR[i], rho * xtol);
               }
            }
         }
      }
   }
// Test for Newton phase:
// * NS in [0,NMAX]
// * ND in [0,NMAX]
// * NR in [NS,NS+ND+NMAX]
// * NS+ND > 0, NR > 0
// * all variables are unconstrained
// * S.DebugMaxNewton is set to 1, S.RefinementIts is set to 1,
//   i.e. algorithm is terminated after one Newton iteration, and no
//   iterative refinement is used.
// * we test that gradient is small at solution, i.e. one Newton iteration
//   on unconstrained problem is enough to find solution. In case of buggy
//   Newton solver one iteration won't move us to the solution - it may
//   decrease function value, but won't find exact solution.
//
// This test is intended to catch subtle bugs in the Newton solver which
// do NOT prevent algorithm from converging to the solution, but slow it
// down (convergence becomes linear or even slower).
   eps = 1.0E-4;
   for (ns = 0; ns <= nmax; ns++) {
      for (nd = 0; nd <= nmax; nd++) {
         for (nr = ns; nr <= ns + nd + nmax; nr++) {
         // Skip NS+ND == 0, NR == 0
            if (ns + nd == 0) {
               continue;
            }
            if (nr == 0) {
               continue;
            }
         // Generate problem:
         // * DenseA, array[NR,ND]
         // * EffectiveA, array[NR,NS+ND]
         // * B, array[NR]
         // * IsConstrained, array[NS+ND]
            if (nd > 0) {
               ae_matrix_set_length(&densea, nr, nd);
               for (i = 0; i < nr; i++) {
                  for (j = 0; j < nd; j++) {
                     densea.xyR[i][j] = hqrndnormal(&rs);
                  }
               }
            }
            ae_matrix_set_length(&effectivea, nr, ns + nd);
            for (i = 0; i < nr; i++) {
               for (j = 0; j < ns + nd; j++) {
                  effectivea.xyR[i][j] = 0.0;
               }
            }
            for (i = 0; i < ns; i++) {
               effectivea.xyR[i][i] = 1.0;
            }
            for (i = 0; i < nr; i++) {
               for (j = 0; j < nd; j++) {
                  effectivea.xyR[i][ns + j] = densea.xyR[i][j];
               }
            }
            ae_vector_set_length(&b, nr);
            for (i = 0; i < nr; i++) {
               b.xR[i] = hqrndnormal(&rs);
            }
         // Solve with SNNLS solver
            snnlsinit(0, 0, 0, &s);
            snnlssetproblem(&s, &densea, &b, ns, nd, nr);
            for (i = 0; i < ns + nd; i++) {
               snnlsdropnnc(&s, i);
            }
            s.debugmaxinnerits = 1;
            snnlssolve(&s, &x);
         // Calculate gradient A'*A*x-b'*A.
         // Check projected gradient (each component must be less than Eps).
            ae_vector_set_length(&g, ns + nd);
            for (i = 0; i < ns + nd; i++) {
               v = ae_v_dotproduct(b.xR, 1, &effectivea.xyR[0][i], effectivea.stride, nr);
               g.xR[i] = -v;
            }
            for (i = 0; i < nr; i++) {
               v = ae_v_dotproduct(effectivea.xyR[i], 1, x.xR, 1, ns + nd);
               ae_v_addd(g.xR, 1, effectivea.xyR[i], 1, ns + nd, v);
            }
            for (i = 0; i < ns + nd; i++) {
               testnewtonOk = testnewtonOk && SmallAtR(g.xR[i], eps);
            }
         }
      }
   }
// The final report.
   Ok = test0Ok && test1Ok && test2Ok && testnewtonOk;
   if (!Ok || !silent) {
      printf("Special NNLS Solver Tests\n");
      printf("Test 0:                                   %s\n", test0Ok? "Ok": "Failed");
      printf("Test 1:                                   %s\n", test1Ok? "Ok": "Failed");
      printf("Test 2:                                   %s\n", test2Ok? "Ok": "Failed");
      printf("Newton Phase:                             %s\n", testnewtonOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === sactivesets testing unit ===
// This function tests special properties.
static bool testsactivesetsunit_testspecproperties() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t nec;
   ae_int_t nic;
   double v;
   double vv;
   ae_int_t scaletype;
   ae_int_t pass;
   ae_int_t distortidx;
   double distortmag;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(sactiveset, state);
   NewObj(hqrndstate, rs);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   hqrndrandomize(&rs);
// N-dimensional problem with Ne equality and Ni inequality constraints.
//
// Check that SActiveSet object uses efficient algorithm
// to determine initial point: it avoids expensive (N+Ni)-dimensional
// QP subproblem when initial point is feasible w.r.t. constraints.
//
// In order to do so we try to find initial point for a problem with
// 2 equality constraints and 1000000 inequality constraints (+box
// constraints). Inefficient algorithm will simply fail to allocate
// enough memory, so we do not have to perform any checks here.
   n = 5;
   nec = 2;
   nic = 1000000;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&bl, n);
   ae_vector_set_length(&bu, n);
   for (scaletype = 0; scaletype <= 1; scaletype++) {
   // Generate problem
      for (i = 0; i < n; i++) {
         x.xR[i] = hqrnduniformr(&rs);
         bl.xR[i] = x.xR[i] - hqrnduniformr(&rs) * hqrnduniformi(&rs, 2);
         bu.xR[i] = x.xR[i] + hqrnduniformr(&rs) * hqrnduniformi(&rs, 2);
      }
      ae_matrix_set_length(&c, nec + nic, n + 1);
      ae_vector_set_length(&ct, nec + nic);
      for (i = 0; i < nec + nic; i++) {
         v = 0.0;
         for (j = 0; j < n; j++) {
            c.xyR[i][j] = hqrndnormal(&rs);
            v += c.xyR[i][j] * x.xR[j];
         }
         c.xyR[i][n] = v;
         if (i < nec) {
            ct.xZ[i] = 0;
         } else {
            c.xyR[i][n] += 0.1;
            ct.xZ[i] = -1;
         }
      }
   // Apply scaling (if needed), then randomly multiply C by
   // some large/small value in order to distort magnitude of
   // linear constraints.
   //
   // Correct SActiveSet implementation must be able to renormalize
   // constraints prior to checking feasibility of initial point.
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 1.0;
         if (scaletype != 0) {
            s.xR[i] = pow(10.0, 20.0 * hqrndmiduniformr(&rs));
         }
         x.xR[i] *= s.xR[i];
         bl.xR[i] *= s.xR[i];
         bu.xR[i] *= s.xR[i];
         for (j = 0; j < nec + nic; j++) {
            c.xyR[j][i] /= s.xR[i];
         }
      }
      for (i = 0; i < nec + nic; i++) {
         v = pow(10.0, 20.0 * hqrndmiduniformr(&rs));
         ae_v_muld(c.xyR[i], 1, n + 1, v);
      }
   // Solve.
   // Simply being able to survive SASStartOptimization() call is enough for this test
      sasinit(n, &state);
      sassetscale(&state, &s);
      sassetbc(&state, &bl, &bu);
      sassetlc(&state, &c, &ct, nec + nic);
      sasstartoptimization(&state, &x);
   }
// Test that algorithm can correctly distinguish between feasible
// and non-feasible initial points. In order to do so we try to
// call SASStartOptimization() for moderately sized problem and
// examine State.FeasInitPt flag after call is done.
//
// This test is performed for equality-only constraints
   for (pass = 1; pass <= 10; pass++) {
      n = 50 + hqrnduniformi(&rs, 10);
      nec = 10 + hqrnduniformi(&rs, 10);
      nic = 0;
      ae_vector_set_length(&x, n);
      for (scaletype = 0; scaletype <= 1; scaletype++) {
      // Generate problem, prepare distortion which introduces infeasibility
         for (i = 0; i < n; i++) {
            x.xR[i] = hqrnduniformr(&rs);
         }
         ae_matrix_set_length(&c, nec + nic, n + 1);
         ae_vector_set_length(&ct, nec + nic);
         for (i = 0; i < nec + nic; i++) {
            v = 0.0;
            vv = 0.0;
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
               vv += sqr(c.xyR[i][j]);
               v += c.xyR[i][j] * x.xR[j];
            }
            c.xyR[i][n] = v;
            vv = coalesce(vv, 1.0);
            vv = 1 / sqrt(vv);
            ae_v_muld(c.xyR[i], 1, n + 1, vv);
            ct.xZ[i] = 0;
         }
         distortidx = hqrnduniformi(&rs, n);
         distortmag = 0.0;
         for (i = 0; i < nec + nic; i++) {
            distortmag = rmax2(distortmag, fabs(c.xyR[i][distortidx]));
         }
         ae_assert(distortmag > 0.0, "Assertion failed");
         distortmag = 1.0E7 * machineepsilon / distortmag;
      // Apply scaling (if needed), then randomly multiply C by
      // some large/small value in order to distort magnitude of
      // linear constraints.
      //
      // Correct SActiveSet implementation must be able to renormalize
      // constraints prior to checking feasibility of initial point.
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = 1.0;
            if (scaletype != 0) {
               s.xR[i] = pow(10.0, 20.0 * hqrndmiduniformr(&rs));
            }
            x.xR[i] *= s.xR[i];
            for (j = 0; j < nec + nic; j++) {
               c.xyR[j][i] /= s.xR[i];
            }
         }
         for (i = 0; i < nec + nic; i++) {
            v = pow(10.0, 20.0 * hqrndmiduniformr(&rs));
            ae_v_muld(c.xyR[i], 1, n + 1, v);
         }
      // Solve for feasible initial X and check State.FeasInitPt flag
         sasinit(n, &state);
         sassetscale(&state, &s);
         sassetlc(&state, &c, &ct, nec + nic);
         sasstartoptimization(&state, &x);
         Ok = Ok && state.feasinitpt;
      // Solve for infeasible initial X and check State.FeasInitPt flag
         x.xR[distortidx] += s.xR[distortidx] * distortmag;
         sasinit(n, &state);
         sassetscale(&state, &s);
         sassetlc(&state, &c, &ct, nec + nic);
         sasstartoptimization(&state, &x);
         Ok = Ok && !state.feasinitpt;
      }
   }
   ae_frame_leave();
   return Ok;
}

bool testsactivesets() {
   bool Ok;
   bool specOk;
   specOk = true;
   specOk = specOk && testsactivesetsunit_testspecproperties();
// The final report.
   Ok = specOk;
   if (!Ok || !silent) {
      printf("Active Sets Test\n");
      printf("* Special Properties:                     %s\n", specOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === minbleic testing unit ===
static const ae_int_t testminbleicunit_maxoptguardlevel = 1;

// Calculate test function IIP2
//
// f(x) = sum( ((i*i+1)^FK*x[i])^2, i = 0..N-1)
//
// It has high condition number which makes fast convergence unlikely without
// good preconditioner.
//
static void testminbleicunit_calciip2(minbleicstate *state, ae_int_t n, ae_int_t fk) {
   ae_int_t i;
   if (state->needfg) {
      state->f = 0.0;
      for (i = 0; i < n; i++) {
         state->f += pow((double)(i * i + 1), (double)(2 * fk)) * sqr(state->x.xR[i]);
         state->g.xR[i] = pow((double)(i * i + 1), (double)(2 * fk)) * 2 * state->x.xR[i];
      }
   }
}

// This function sets random preconditioner:
// * unit one, for PrecKind == 0
// * diagonal-based one, for PrecKind == 1
// * scale-based one, for PrecKind == 2
static void testminbleicunit_setrandompreconditioner(minbleicstate *state, ae_int_t n, ae_int_t preckind) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewVector(p, 0, DT_REAL);
   if (preckind == 1) {
      ae_vector_set_length(&p, n);
      for (i = 0; i < n; i++) {
         p.xR[i] = exp(3.0 * randommid());
      }
      minbleicsetprecdiag(state, &p);
   } else {
      minbleicsetprecdefault(state);
   }
   ae_frame_leave();
}

// This function test feasibility properties.
// It launches a sequence of problems and examines their solutions.
// Most of the attention is directed towards feasibility properties,
// although we make some quick checks to ensure that actual solution is found.
//
// *ConvOkP is set to true on conversion errors, and is left unchanged otherwise.
// *IntOkP is set to true on internal errors (errors in the control flow).
static bool testminbleicunit_testfeasibility(bool *ConvOkP, bool *IntOkP) {
   ae_frame _frame_block;
   ae_int_t pkind;
   ae_int_t preckind;
   ae_int_t passcount;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t nmax;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t p;
   double v;
   double v2;
   double v3;
   double vv;
   double epsx;
   double epsfeas;
   double weakepsg;
   ae_int_t dkind;
   double diffstep;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(svdw, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(svdu, 0, 0, DT_REAL);
   NewMatrix(svdvt, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(minbleicstate, state);
   NewObj(minbleicreport, rep);
   nmax = 5;
   weakepsg = 1.0E-4;
   epsx = 1.0E-4;
   epsfeas = 1.0E-6;
   passcount = 10;
   for (pass = 1; pass <= passcount; pass++) {
   // Test problem 1:
   // * no boundary and inequality constraints
   // * randomly generated plane as equality constraint
   // * random point (not necessarily on the plane)
   // * f = |x|^P, P = {2, 4} is used as target function
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * either analytic gradient or numerical differentiation are used
   // * we check that after work is over we are on the plane and
   //   that we are in the stationary point of constrained F
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         for (preckind = 0; preckind <= 2; preckind++) {
            for (pkind = 1; pkind <= 2; pkind++) {
               for (n = 1; n <= nmax; n++) {
               // Generate X, BL, BU, CT and left part of C.
               //
               // Right part of C is generated using somewhat complex algo:
               // * we generate random vector and multiply it by C.
               // * result is used as the right part.
               // * calculations are done on the fly, vector itself is not stored
               // We use such algo to be sure that our system is consistent.
                  p = 2 * pkind;
                  ae_vector_set_length(&x, n);
                  ae_vector_set_length(&g, n);
                  ae_matrix_set_length(&c, 1, n + 1);
                  ae_vector_set_length(&ct, 1);
                  c.xyR[0][n] = 0.0;
                  for (i = 0; i < n; i++) {
                     x.xR[i] = randommid();
                     c.xyR[0][i] = randommid();
                     v = randommid();
                     c.xyR[0][n] += c.xyR[0][i] * v;
                  }
                  ct.xZ[0] = 0;
               // Create and optimize
                  if (dkind == 0) {
                     minbleiccreate(n, &x, &state);
                  }
                  if (dkind == 1) {
                     minbleiccreatef(n, &x, diffstep, &state);
                  }
                  minbleicsetlc(&state, &c, &ct, 1);
                  minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbleicunit_setrandompreconditioner(&state, n, preckind);
                  while (minbleiciteration(&state))
                     if (state.needf || state.needfg) {
                        state.f = 0.0;
                        for (i = 0; i < n; i++) {
                           state.f += pow(state.x.xR[i], (double)p);
                           if (state.needfg) {
                              state.g.xR[i] = p * pow(state.x.xR[i], (double)(p - 1));
                           }
                        }
                     }
                  minbleicresults(&state, &x, &rep);
                  if (rep.terminationtype <= 0) {
                     *ConvOkP = false;
                     ae_frame_leave();
                     return Ok;
                  }
               // Test feasibility of solution
                  v = ae_v_dotproduct(c.xyR[0], 1, x.xR, 1, n);
                  Ok = Ok && NearAtR(v, c.xyR[0][n], epsfeas);
               // if C is nonzero, test that result is
               // a stationary point of constrained F.
               //
               // NOTE: this check is done only if C is nonzero
                  vv = ae_v_dotproduct(c.xyR[0], 1, c.xyR[0], 1, n);
                  if (vv != 0.0) {
                  // Calculate gradient at the result
                  // Project gradient into C
                  // Check projected norm
                     for (i = 0; i < n; i++) {
                        g.xR[i] = p * pow(x.xR[i], (double)(p - 1));
                     }
                     v2 = ae_v_dotproduct(c.xyR[0], 1, c.xyR[0], 1, n);
                     v = ae_v_dotproduct(c.xyR[0], 1, g.xR, 1, n);
                     vv = v / v2;
                     ae_v_subd(g.xR, 1, c.xyR[0], 1, n, vv);
                     v3 = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
                     *ConvOkP = *ConvOkP && sqrt(v3) <= weakepsg;
                  }
               }
            }
         }
      }
   // Test problem 2 (multiple equality constraints):
   // * 1 <= N <= NMax, 1 <= K <= N
   // * no boundary constraints
   // * N-dimensional space
   // * randomly generated point xs
   // * K randomly generated hyperplanes which all pass through xs
   //   define K equality constraints: (a[k],x) == b[k]
   // * equality constraints are checked for being well conditioned
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * f(x) = |x-x0|^2, x0 = xs+a[0]
   // * either analytic gradient or numerical differentiation are used
   // * extremum of f(x) is exactly xs because:
   //   * xs is the closest point in the plane defined by (a[0],x) == b[0]
   //   * xs is feasible by definition
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         for (preckind = 0; preckind <= 2; preckind++) {
            for (n = 2; n <= nmax; n++) {
               for (k = 1; k <= n; k++) {
               // Generate X, X0, XS, BL, BU, CT and left part of C.
               //
               // Right part of C is generated using somewhat complex algo:
               // * we generate random vector and multiply it by C.
               // * result is used as the right part.
               // * calculations are done on the fly, vector itself is not stored
               // We use such algo to be sure that our system is consistent.
                  ae_vector_set_length(&x, n);
                  ae_vector_set_length(&x0, n);
                  ae_vector_set_length(&xs, n);
                  ae_vector_set_length(&g, n);
                  ae_matrix_set_length(&c, k, n + 1);
                  ae_vector_set_length(&ct, k);
                  c.xyR[0][n] = 0.0;
                  for (i = 0; i < n; i++) {
                     x.xR[i] = randommid();
                     xs.xR[i] = randommid();
                  }
                  do {
                     for (i = 0; i < k; i++) {
                        for (j = 0; j < n; j++) {
                           c.xyR[i][j] = randommid();
                        }
                        v = ae_v_dotproduct(c.xyR[i], 1, xs.xR, 1, n);
                        c.xyR[i][n] = v;
                        ct.xZ[i] = 0;
                     }
                     Ok = Ok && rmatrixsvd(&c, k, n, 0, 0, 0, &svdw, &svdu, &svdvt);
                  } while (svdw.xR[0] <= 0.0 || svdw.xR[k - 1] <= 0.001 * svdw.xR[0]);
                  ae_v_move(x0.xR, 1, xs.xR, 1, n);
                  ae_v_add(x0.xR, 1, c.xyR[0], 1, n);
               // Create and optimize
                  if (dkind == 0) {
                     minbleiccreate(n, &x, &state);
                  }
                  if (dkind == 1) {
                     minbleiccreatef(n, &x, diffstep, &state);
                  }
                  minbleicsetlc(&state, &c, &ct, k);
                  minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbleicunit_setrandompreconditioner(&state, n, preckind);
                  while (minbleiciteration(&state))
                     if (state.needf || state.needfg) {
                        state.f = 0.0;
                        for (i = 0; i < n; i++) {
                           state.f += sqr(state.x.xR[i] - x0.xR[i]);
                           if (state.needfg) {
                              state.g.xR[i] = 2 * (state.x.xR[i] - x0.xR[i]);
                           }
                        }
                     }
                  minbleicresults(&state, &x, &rep);
                  if (rep.terminationtype <= 0) {
                     *ConvOkP = false;
                     ae_frame_leave();
                     return Ok;
                  }
               // check feasiblity properties
                  for (i = 0; i < k; i++) {
                     v = ae_v_dotproduct(c.xyR[i], 1, x.xR, 1, n);
                     Ok = Ok && NearAtR(v, c.xyR[i][n], epsx);
                  }
               // Compare with XS
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     v += sqr(x.xR[i] - xs.xR[i]);
                  }
                  v = sqrt(v);
                  *ConvOkP = *ConvOkP && SmallAtR(v, 0.001);
               }
            }
         }
      }
   // Another simple problem:
   // * bound constraints 0 <= x[i] <= 1
   // * no linear constraints
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P == {2,4} and x0 is randomly selected from [-1,+2]^N
   // * with such simple boundaries and function it is easy to find
   //   analytic form of solution: S[i] = bound(x0[i], 0, 1)
   // * we also check that both final solution and subsequent iterates
   //   are strictly feasible
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         for (preckind = 0; preckind <= 2; preckind++) {
            for (pkind = 1; pkind <= 2; pkind++) {
               for (n = 1; n <= nmax; n++) {
               // Generate X, BL, BU.
                  p = 2 * pkind;
                  ae_vector_set_length(&bl, n);
                  ae_vector_set_length(&bu, n);
                  ae_vector_set_length(&x, n);
                  ae_vector_set_length(&x0, n);
                  for (i = 0; i < n; i++) {
                     bl.xR[i] = 0.0;
                     bu.xR[i] = 1.0;
                     x.xR[i] = randomreal();
                     x0.xR[i] = 3.0 * randomreal() - 1.0;
                  }
               // Create and optimize
                  if (dkind == 0) {
                     minbleiccreate(n, &x, &state);
                  }
                  if (dkind == 1) {
                     minbleiccreatef(n, &x, diffstep, &state);
                  }
                  minbleicsetbc(&state, &bl, &bu);
                  minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbleicunit_setrandompreconditioner(&state, n, preckind);
                  while (minbleiciteration(&state)) {
                     if (state.needf || state.needfg) {
                        state.f = 0.0;
                        for (i = 0; i < n; i++) {
                           state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                           if (state.needfg) {
                              state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                           }
                        }
                     }
                     for (i = 0; i < n; i++) {
                        Ok = Ok && state.x.xR[i] >= 0.0;
                        Ok = Ok && state.x.xR[i] <= 1.0;
                     }
                  }
                  minbleicresults(&state, &x, &rep);
                  if (rep.terminationtype <= 0) {
                     *ConvOkP = false;
                     ae_frame_leave();
                     return Ok;
                  }
               // * compare solution with analytic one
               // * check feasibility
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     if (x.xR[i] > 0.0 && x.xR[i] < 1.0) {
                        v += sqr(p * pow(x.xR[i] - x0.xR[i], (double)(p - 1)));
                     }
                     Ok = Ok && x.xR[i] >= 0.0;
                     Ok = Ok && x.xR[i] <= 1.0;
                  }
                  *ConvOkP = *ConvOkP && sqrt(v) <= weakepsg;
               }
            }
         }
      }
   // Same as previous problem, but with minor modifications:
   // * some bound constraints are 0 <= x[i] <= 1, some are Ci == x[i] == Ci
   // * no linear constraints
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P == {2,4} and x0 is randomly selected from [-1,+2]^N
   // * with such simple boundaries and function it is easy to find
   //   analytic form of solution: S[i] = bound(x0[i], 0, 1)
   // * we also check that both final solution and subsequent iterates
   //   are strictly feasible
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         for (preckind = 0; preckind <= 2; preckind++) {
            for (pkind = 1; pkind <= 2; pkind++) {
               for (n = 1; n <= nmax; n++) {
               // Generate X, BL, BU.
                  p = 2 * pkind;
                  ae_vector_set_length(&bl, n);
                  ae_vector_set_length(&bu, n);
                  ae_vector_set_length(&x, n);
                  ae_vector_set_length(&x0, n);
                  for (i = 0; i < n; i++) {
                     if (randombool()) {
                        bl.xR[i] = 0.0;
                        bu.xR[i] = 1.0;
                     } else {
                        bl.xR[i] = randomreal();
                        bu.xR[i] = bl.xR[i];
                     }
                     x.xR[i] = randomreal();
                     x0.xR[i] = 3.0 * randomreal() - 1.0;
                  }
               // Create and optimize
                  if (dkind == 0) {
                     minbleiccreate(n, &x, &state);
                  }
                  if (dkind == 1) {
                     minbleiccreatef(n, &x, diffstep, &state);
                  }
                  minbleicsetbc(&state, &bl, &bu);
                  minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbleicunit_setrandompreconditioner(&state, n, preckind);
                  while (minbleiciteration(&state)) {
                     if (state.needf || state.needfg) {
                        state.f = 0.0;
                        for (i = 0; i < n; i++) {
                           state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                           if (state.needfg) {
                              state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                           }
                        }
                     }
                     for (i = 0; i < n; i++) {
                        Ok = Ok && state.x.xR[i] >= bl.xR[i];
                        Ok = Ok && state.x.xR[i] <= bu.xR[i];
                     }
                  }
                  minbleicresults(&state, &x, &rep);
                  if (rep.terminationtype <= 0) {
                     *ConvOkP = false;
                     ae_frame_leave();
                     return Ok;
                  }
               // * compare solution with analytic one
               // * check feasibility
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     if (x.xR[i] > bl.xR[i] && x.xR[i] < bu.xR[i]) {
                        v += sqr(p * pow(x.xR[i] - x0.xR[i], (double)(p - 1)));
                     }
                     Ok = Ok && x.xR[i] >= bl.xR[i];
                     Ok = Ok && x.xR[i] <= bu.xR[i];
                  }
                  *ConvOkP = *ConvOkP && sqrt(v) <= weakepsg;
               }
            }
         }
      }
   // Same as previous one, but with bound constraints posed
   // as general linear ones:
   // * no bound constraints
   // * 2*N linear constraints 0 <= x[i] <= 1
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P == {2,4} and x0 is randomly selected from [-1,+2]^N
   // * with such simple constraints and function it is easy to find
   //   analytic form of solution: S[i] = bound(x0[i], 0, 1).
   // * however, we can't guarantee that solution is strictly feasible
   //   with respect to nonlinearity constraint, so we check
   //   for approximate feasibility.
      for (preckind = 0; preckind <= 2; preckind++) {
         for (pkind = 1; pkind <= 2; pkind++) {
            for (n = 1; n <= nmax; n++) {
            // Generate X, BL, BU.
               p = 2 * pkind;
               ae_vector_set_length(&x, n);
               ae_vector_set_length(&x0, n);
               ae_matrix_set_length(&c, 2 * n, n + 1);
               ae_vector_set_length(&ct, 2 * n);
               for (i = 0; i < n; i++) {
                  x.xR[i] = randomreal();
                  x0.xR[i] = 3.0 * randomreal() - 1.0;
                  for (j = 0; j <= n; j++) {
                     c.xyR[2 * i][j] = 0.0;
                     c.xyR[2 * i + 1][j] = 0.0;
                  }
                  c.xyR[2 * i][i] = 1.0;
                  c.xyR[2 * i][n] = 0.0;
                  ct.xZ[2 * i] = 1;
                  c.xyR[2 * i + 1][i] = 1.0;
                  c.xyR[2 * i + 1][n] = 1.0;
                  ct.xZ[2 * i + 1] = -1;
               }
            // Create and optimize
               minbleiccreate(n, &x, &state);
               minbleicsetlc(&state, &c, &ct, 2 * n);
               minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
               testminbleicunit_setrandompreconditioner(&state, n, preckind);
               while (minbleiciteration(&state))
                  if (state.needfg) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                        state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                     }
                  } else {
                  // Unknown protocol specified
                     *IntOkP = false;
                     ae_frame_leave();
                     return Ok;
                  }
               minbleicresults(&state, &x, &rep);
               if (rep.terminationtype <= 0) {
                  *ConvOkP = false;
                  ae_frame_leave();
                  return Ok;
               }
            // * compare solution with analytic one
            // * check feasibility
               v = 0.0;
               for (i = 0; i < n; i++) {
                  if (x.xR[i] > 0.02 && x.xR[i] < 0.98) {
                     v += sqr(p * pow(x.xR[i] - x0.xR[i], (double)(p - 1)));
                  }
                  Ok = Ok && x.xR[i] >= 0.0 - epsfeas;
                  Ok = Ok && x.xR[i] <= 1.0 + epsfeas;
               }
               *ConvOkP = *ConvOkP && sqrt(v) <= weakepsg;
            }
         }
      }
   // Feasibility problem:
   // * bound constraints 0 <= x[i] <= 1
   // * starting point xs with xs[i] in [-1,+2]
   // * random point xc from [0,1] is used to generate K <= N
   //   random linear equality/inequality constraints of the form
   //   (c,x-xc) == 0.0 (or, alternatively, >= or <= ), where
   //   c is a random vector.
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P == {2,4} and x0 is randomly selected from [-1,+2]^N
   // * we do not know analytic form of the solution, and, if fact, we do not
   //   check for solution correctness. We just check that algorithm converges
   //   to the feasible points.
      for (preckind = 0; preckind <= 2; preckind++) {
         for (pkind = 1; pkind <= 2; pkind++) {
            for (n = 1; n <= nmax; n++) {
               for (k = 1; k <= n; k++) {
               // Generate X, BL, BU.
                  p = 2 * pkind;
                  ae_vector_set_length(&x0, n);
                  ae_vector_set_length(&xc, n);
                  ae_vector_set_length(&xs, n);
                  ae_matrix_set_length(&c, k, n + 1);
                  ae_vector_set_length(&ct, k);
                  ae_vector_set_length(&bl, n);
                  ae_vector_set_length(&bu, n);
                  for (i = 0; i < n; i++) {
                     x0.xR[i] = 3.0 * randomreal() - 1.0;
                     xs.xR[i] = 3.0 * randomreal() - 1.0;
                     xc.xR[i] = 0.1 + 0.8 * randomreal();
                     bl.xR[i] = 0.0;
                     bu.xR[i] = 1.0;
                  }
                  for (i = 0; i < k; i++) {
                     c.xyR[i][n] = 0.0;
                     for (j = 0; j < n; j++) {
                        c.xyR[i][j] = randommid();
                        c.xyR[i][n] += c.xyR[i][j] * xc.xR[j];
                     }
                     ct.xZ[i] = randominteger(3) - 1;
                  }
               // Create and optimize
                  minbleiccreate(n, &xs, &state);
                  minbleicsetbc(&state, &bl, &bu);
                  minbleicsetlc(&state, &c, &ct, k);
                  minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbleicunit_setrandompreconditioner(&state, n, preckind);
                  while (minbleiciteration(&state))
                     if (state.needfg) {
                        state.f = 0.0;
                        for (i = 0; i < n; i++) {
                           state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                           state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                        }
                     } else {
                     // Unknown protocol specified
                        *IntOkP = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  minbleicresults(&state, &x, &rep);
                  if (rep.terminationtype <= 0) {
                     *ConvOkP = false;
                     ae_frame_leave();
                     return Ok;
                  }
               // Check feasibility
                  for (i = 0; i < n; i++) {
                     Ok = Ok && x.xR[i] >= 0.0;
                     Ok = Ok && x.xR[i] <= 1.0;
                  }
                  for (i = 0; i < k; i++) {
                     v = ae_v_dotproduct(c.xyR[i], 1, x.xR, 1, n);
                     v -= c.xyR[i][n];
                     if (ct.xZ[i] == 0) {
                        Ok = Ok && SmallAtR(v, epsfeas);
                     }
                     if (ct.xZ[i] < 0) {
                        Ok = Ok && v <= epsfeas;
                     }
                     if (ct.xZ[i] > 0) {
                        Ok = Ok && v >= -epsfeas;
                     }
                  }
               }
            }
         }
      }
   // Infeasible problem:
   // * all bound constraints are 0 <= x[i] <= 1 except for one
   // * that one is 0 >= x[i] >= 1
   // * no linear constraints
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from detecting
   //   infeasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P == {2,4} and x0 is randomly selected from [-1,+2]^N
   // * algorithm must return correct error code on such problem
      for (preckind = 0; preckind <= 2; preckind++) {
         for (pkind = 1; pkind <= 2; pkind++) {
            for (n = 1; n <= nmax; n++) {
            // Generate X, BL, BU.
               p = 2 * pkind;
               ae_vector_set_length(&bl, n);
               ae_vector_set_length(&bu, n);
               ae_vector_set_length(&x, n);
               ae_vector_set_length(&x0, n);
               for (i = 0; i < n; i++) {
                  bl.xR[i] = 0.0;
                  bu.xR[i] = 1.0;
                  x.xR[i] = randomreal();
                  x0.xR[i] = 3.0 * randomreal() - 1.0;
               }
               i = randominteger(n);
               bl.xR[i] = 1.0;
               bu.xR[i] = 0.0;
            // Create and optimize
               minbleiccreate(n, &x, &state);
               minbleicsetbc(&state, &bl, &bu);
               minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
               testminbleicunit_setrandompreconditioner(&state, n, preckind);
               while (minbleiciteration(&state))
                  if (state.needfg) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                        state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                     }
                  } else {
                  // Unknown protocol specified
                     *IntOkP = false;
                     ae_frame_leave();
                     return Ok;
                  }
               minbleicresults(&state, &x, &rep);
               Ok = Ok && rep.terminationtype == -3;
            }
         }
      }
   // Infeasible problem (2):
   // * no bound and inequality constraints
   // * 1 <= K <= N arbitrary equality constraints
   // * (K+1)th constraint which is equal to the first constraint a*x == c,
   //   but with c = c+1. I.e. we have both a*x == c and a*x == c+1, which can't
   //   be true (other constraints may be inconsistent too, but we don't
   //   have to check it).
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from detecting
   //   infeasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x|^P, where P == {2,4}
   // * algorithm must return correct error code on such problem
      for (preckind = 0; preckind <= 2; preckind++) {
         for (pkind = 1; pkind <= 2; pkind++) {
            for (n = 1; n <= nmax; n++) {
               for (k = 1; k <= n; k++) {
               // Generate X, BL, BU.
                  p = 2 * pkind;
                  ae_vector_set_length(&x, n);
                  ae_matrix_set_length(&c, k + 1, n + 1);
                  ae_vector_set_length(&ct, k + 1);
                  for (i = 0; i < n; i++) {
                     x.xR[i] = randomreal();
                  }
                  for (i = 0; i < k; i++) {
                     for (j = 0; j <= n; j++) {
                        c.xyR[i][j] = randommid();
                     }
                     ct.xZ[i] = 0;
                  }
                  ct.xZ[k] = 0;
                  ae_v_move(c.xyR[k], 1, c.xyR[0], 1, n);
                  c.xyR[k][n] = c.xyR[0][n] + 1;
               // Create and optimize
                  minbleiccreate(n, &x, &state);
                  minbleicsetlc(&state, &c, &ct, k + 1);
                  minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbleicunit_setrandompreconditioner(&state, n, preckind);
                  while (minbleiciteration(&state))
                     if (state.needfg) {
                        state.f = 0.0;
                        for (i = 0; i < n; i++) {
                           state.f += pow(state.x.xR[i], (double)p);
                           state.g.xR[i] = p * pow(state.x.xR[i], (double)(p - 1));
                        }
                     } else {
                     // Unknown protocol specified
                        *IntOkP = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  minbleicresults(&state, &x, &rep);
                  Ok = Ok && rep.terminationtype == -3;
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function additional properties.
static bool testminbleicunit_testother() {
   ae_frame _frame_block;
   ae_int_t passcount;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double fprev;
   double xprev;
   double stpmax;
   double v;
   ae_int_t nec;
   ae_int_t nic;
   ae_int_t pkind;
   ae_int_t ckind;
   ae_int_t mkind;
   double vc;
   double vm;
   double epsx;
   double epsg;
   double eps;
   double tmpeps;
   double diffstep;
   ae_int_t dkind;
   bool wasf;
   bool wasfg;
   double r;
   ae_int_t spoiliteration;
   ae_int_t stopiteration;
   ae_int_t spoilvar;
   double spoilval;
   double ss;
   ae_int_t stopcallidx;
   ae_int_t callidx;
   ae_int_t maxits;
   bool terminationrequested;
   ae_int_t scaletype;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(xf, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewVector(a, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(h, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(minbleicstate, state);
   NewObj(minbleicreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   epsx = 1.0E-4;
   epsg = 1.0E-8;
   passcount = 10;
// Try to reproduce bug 570 (optimizer hangs on problems where it is required
// to perform very small step - less than 1E-50 - in order to activate constraints).
//
// The problem being solved is:
//
//     min x[0]+x[1]+...+x[n-1]
//
// subject to
//
//     x[i] >= 0, for i = 0..n-1
//
// with initial point
//
//     x[0] = 1.0E-100, x[1] == x[2] == ... == 0.5
//
// We try to reproduce this problem in different settings:
// * boundary-only constraints - we test that completion code is positive,
//   and all x[] are EXACTLY zero
// * boundary constraints posed as general linear ones - we test that
//   completion code is positive, and all x[] are APPROXIMATELY zero.
   n = 10;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&bl, n);
   ae_vector_set_length(&bu, n);
   ae_matrix_set_length(&c, n, n + 1);
   ae_vector_set_length(&ct, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = 0.5;
      bl.xR[i] = 0.0;
      bu.xR[i] = +INFINITY;
      ct.xZ[i] = 1;
      for (j = 0; j <= n; j++) {
         c.xyR[i][j] = 0.0;
      }
      c.xyR[i][i] = 1.0;
   }
   x.xR[0] = 1.0E-100;
   minbleiccreate(n, &x, &state);
   minbleicsetbc(&state, &bl, &bu);
   minbleicsetcond(&state, 0.0, 0.0, 0.0, 2 * n);
   while (minbleiciteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += state.x.xR[i];
            state.g.xR[i] = 1.0;
         }
      }
   minbleicresults(&state, &xf, &rep);
   Ok = Ok && rep.terminationtype > 0;
   if (rep.terminationtype > 0) {
      for (i = 0; i < n; i++) {
         Ok = Ok && xf.xR[i] == 0.0;
      }
   }
   minbleiccreate(n, &x, &state);
   minbleicsetlc(&state, &c, &ct, n);
   minbleicsetcond(&state, 1.0E-64, 0.0, 0.0, 10);
   while (minbleiciteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += state.x.xR[i];
            state.g.xR[i] = 1.0;
         }
      }
   minbleicresults(&state, &xf, &rep);
   Ok = Ok && rep.terminationtype > 0;
   if (rep.terminationtype > 0) {
      for (i = 0; i < n; i++) {
         Ok = Ok && SmallAtR(xf.xR[i], 1.0E-10);
      }
   }
// Test reports:
// * first value must be starting point
// * last value must be last point
   for (pass = 1; pass <= passcount; pass++) {
      n = 50;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      ae_vector_set_length(&bl, n);
      ae_vector_set_length(&bu, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 10.0;
         bl.xR[i] = randommid();
         bu.xR[i] = +INFINITY;
      }
      minbleiccreate(n, &x, &state);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetcond(&state, 1.0E-64, 0.0, 0.0, 10);
      minbleicsetxrep(&state, true);
      fprev = maxrealnumber;
      while (minbleiciteration(&state))
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += sqr((1 + i) * state.x.xR[i]);
               state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
            }
         } else if (state.xupdated) {
            if (fprev == maxrealnumber) {
               for (i = 0; i < n; i++) {
                  Ok = Ok && state.x.xR[i] == x.xR[i];
               }
            }
            fprev = state.f;
            ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
         }
      minbleicresults(&state, &x, &rep);
      for (i = 0; i < n; i++) {
         Ok = Ok && x.xR[i] == xlast.xR[i];
      }
   }
// Test differentiation vs. analytic gradient
// (first one issues NeedF requests, second one issues NeedFG requests)
   for (pass = 1; pass <= passcount; pass++) {
      n = 10;
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xlast, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 1.0;
         }
         if (dkind == 0) {
            minbleiccreate(n, &x, &state);
         }
         if (dkind == 1) {
            minbleiccreatef(n, &x, diffstep, &state);
         }
         minbleicsetcond(&state, 1.0E-6, 0.0, epsx, 0);
         wasf = false;
         wasfg = false;
         while (minbleiciteration(&state))
            if (state.needf || state.needfg) {
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  state.f += sqr((1 + i) * state.x.xR[i]);
                  if (state.needfg) {
                     state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
                  }
               }
               wasf = wasf || state.needf;
               wasfg = wasfg || state.needfg;
            }
         minbleicresults(&state, &x, &rep);
         if (dkind == 0) {
            Ok = Ok && !wasf && wasfg;
         }
         if (dkind == 1) {
            Ok = Ok && wasf && !wasfg;
         }
      }
   }
// Test that numerical differentiation uses scaling.
//
// In order to test that we solve simple optimization
// problem: min(x^2) with initial x equal to 0.0.
//
// We choose random DiffStep and S, then we check that
// optimizer evaluates function at +-DiffStep*S only.
   for (pass = 1; pass <= passcount; pass++) {
      ae_vector_set_length(&x, 1);
      ae_vector_set_length(&s, 1);
      diffstep = randomreal() * 1.0E-6;
      s.xR[0] = exp(2.0*randommid());
      x.xR[0] = 0.0;
      minbleiccreatef(1, &x, diffstep, &state);
      minbleicsetcond(&state, 1.0E-6, 0.0, epsx, 0);
      minbleicsetscale(&state, &s);
      v = 0.0;
      while (minbleiciteration(&state)) {
         state.f = sqr(state.x.xR[0]);
         v = rmax2(v, fabs(state.x.xR[0]));
      }
      minbleicresults(&state, &x, &rep);
      r = v / (s.xR[0] * diffstep);
      Ok = Ok && SmallAtR(log(r), log(1.0 + 1000.0 * machineepsilon));
   }
// Test stpmax
   for (pass = 1; pass <= passcount; pass++) {
      n = 1;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&bl, n);
      ae_vector_set_length(&bu, n);
      x.xR[0] = 100.0;
      bl.xR[0] = randommid();
      bu.xR[0] = +INFINITY;
      stpmax = 0.05 + 0.05 * randomreal();
      minbleiccreate(n, &x, &state);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetcond(&state, epsg, 0.0, epsx, 0);
      minbleicsetxrep(&state, true);
      minbleicsetstpmax(&state, stpmax);
      xprev = x.xR[0];
      while (minbleiciteration(&state))
         if (state.needfg) {
            state.f = exp(state.x.xR[0]) + exp(-state.x.xR[0]);
            state.g.xR[0] = exp(state.x.xR[0]) - exp(-state.x.xR[0]);
            Ok = Ok && NearAtR(state.x.xR[0], xprev, (1 + sqrt(machineepsilon)) * stpmax);
         } else if (state.xupdated) {
            Ok = Ok && NearAtR(state.x.xR[0], xprev, (1 + sqrt(machineepsilon)) * stpmax);
            xprev = state.x.xR[0];
         }
   }
// Ability to solve problems with function which is unbounded from below
   for (pass = 1; pass <= passcount; pass++) {
      n = 1;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&bl, n);
      ae_vector_set_length(&bu, n);
      bl.xR[0] = 4.0 * randomreal() + 1;
      bu.xR[0] = bl.xR[0] + 1;
      x.xR[0] = 0.5 * (bl.xR[0] + bu.xR[0]);
      minbleiccreate(n, &x, &state);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetcond(&state, epsg, 0.0, epsx, 0);
      while (minbleiciteration(&state))
         if (state.needfg) {
            state.f = -1.0E8 * sqr(state.x.xR[0]);
            state.g.xR[0] = -2.0E8 * state.x.xR[0];
         }
      minbleicresults(&state, &x, &rep);
      Ok = Ok && NearAtR(x.xR[0], bu.xR[0], epsx);
   }
// Test correctness of the scaling:
// * initial point is random point from [+1,+2]^N
// * f(x) = SUM(A[i]*x[i]^4), C[i] is random from [0.01,100]
// * function is EFFECTIVELY unconstrained; it has formal constraints,
//   but they are inactive at the solution; we try different variants
//   in order to explore different control paths of the optimizer:
//   0) absense of constraints
//   1) bound constraints -100000 <= x[i] <= 100000
//   2) one linear constraint 0*x == 0
//   3) combination of (1) and (2)
// * we use random scaling matrix
// * we test different variants of the preconditioning:
//   0) unit preconditioner
//   1) random diagonal from [0.01,100]
//   2) scale preconditioner
// * we set very stringent stopping conditions
// * and we test that in the extremum stopping conditions are
//   satisfied subject to the current scaling coefficients.
   for (pass = 1; pass <= passcount; pass++) {
      tmpeps = 1.0E-5;
      for (n = 1; n <= 10; n++) {
         for (ckind = 0; ckind <= 3; ckind++) {
            for (pkind = 0; pkind <= 2; pkind++) {
               ae_vector_set_length(&x, n);
               ae_vector_set_length(&a, n);
               ae_vector_set_length(&s, n);
               ae_vector_set_length(&h, n);
               ae_vector_set_length(&bl, n);
               ae_vector_set_length(&bu, n);
               ae_matrix_set_length(&c, 1, n + 1);
               ae_vector_set_length(&ct, 1);
               ct.xZ[0] = 0;
               c.xyR[0][n] = 0.0;
               for (i = 0; i < n; i++) {
                  x.xR[i] = randomreal() + 1;
                  bl.xR[i] = -100000.0;
                  bu.xR[i] = 100000.0;
                  c.xyR[0][i] = 0.0;
                  a.xR[i] = exp(log(10.0) * randommid());
                  s.xR[i] = exp(log(10.0) * randommid());
                  h.xR[i] = exp(log(10.0) * randommid());
               }
               minbleiccreate(n, &x, &state);
               if (ckind == 1 || ckind == 3) {
                  minbleicsetbc(&state, &bl, &bu);
               }
               if (ckind == 2 || ckind == 3) {
                  minbleicsetlc(&state, &c, &ct, 1);
               }
               if (pkind == 1) {
                  minbleicsetprecdiag(&state, &h);
               }
               if (pkind == 2) {
                  minbleicsetprecscale(&state);
               }
               minbleicsetcond(&state, tmpeps, 0.0, 0.0, 0);
               minbleicsetscale(&state, &s);
               while (minbleiciteration(&state))
                  if (state.needfg) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += a.xR[i] * sqr(state.x.xR[i]);
                        state.g.xR[i] = 2 * a.xR[i] * state.x.xR[i];
                     }
                  }
               minbleicresults(&state, &x, &rep);
               if (rep.terminationtype <= 0) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
               v = 0.0;
               for (i = 0; i < n; i++) {
                  v += sqr(s.xR[i] * 2 * a.xR[i] * x.xR[i]);
               }
               v = sqrt(v);
               Ok = Ok && v <= tmpeps;
            }
         }
      }
   }
// Check correctness of the "trimming".
//
// Trimming is a technique which is used to help algorithm
// cope with unbounded functions. In order to check this
// technique we will try to solve following optimization
// problem:
//
//     min f(x) subject to no constraints on X
//            { 1/(1-x) + 1/(1+x) + c*x, if -0.999999 < x < 0.999999
//     f(x) = {
//            { M, if x <= -0.999999 or x >= 0.999999
//
// where c is either 1.0 or 1.0E+4, M is either 1.0E8, 1.0E20 or +INF
// (we try different combinations)
   for (pass = 1; pass <= passcount; pass++) {
      for (ckind = 0; ckind <= 1; ckind++) {
         for (mkind = 0; mkind <= 2; mkind++) {
         // Choose c and M
            vc = 1.0;
            vm = 1.0;
            if (ckind == 0) {
               vc = 1.0;
            }
            if (ckind == 1) {
               vc = 1.0E+4;
            }
            if (mkind == 0) {
               vm = 1.0E+8;
            }
            if (mkind == 1) {
               vm = 1.0E+20;
            }
            if (mkind == 2) {
               vm = +INFINITY;
            }
         // Create optimizer, solve optimization problem
            epsg = 1.0E-6 * vc;
            ae_vector_set_length(&x, 1);
            x.xR[0] = 0.0;
            minbleiccreate(1, &x, &state);
            minbleicsetcond(&state, epsg, 0.0, 0.0, 0);
            while (minbleiciteration(&state))
               if (state.needfg) {
                  if (-0.999999 < state.x.xR[0] && state.x.xR[0] < 0.999999) {
                     state.f = 1 / (1 - state.x.xR[0]) + 1 / (1 + state.x.xR[0]) + vc * state.x.xR[0];
                     state.g.xR[0] = 1 / sqr(1 - state.x.xR[0]) - 1 / sqr(1 + state.x.xR[0]) + vc;
                  } else {
                     state.f = vm;
                     state.g.xR[0] = 0.0;
                  }
               }
            minbleicresults(&state, &x, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            Ok = Ok && NearAtR(1.0 / sqr(1.0 - x.xR[0]), 1.0 / sqr(1.0 + x.xR[0]) - vc, epsg);
         }
      }
   }
// Test behaviour on noisy functions.
//
// Consider following problem:
// * f(x,y) = (x+1)^2 + (y+1)^2 + 10000*MachineEpsilon*RandomReal()
// * boundary constraints x >= 0, y >= 0
// * starting point (x0,y0) == (10*MachineEpsilon,1.0)
//
// Such problem contains small numerical noise. Without noise its
// solution is (xs,ys) == (0,0), which is easy to find. However, presence
// of the noise makes it hard to solve:
// * noisy f(x,y) is monotonically decreasing only when we perform
//   steps orders of magnitude larger than 10000*MachineEpsilon
// * at small scales f(x,y) is non-monotonic and non-convex
// * however, our first step must be done towards
//   (x1,y1) = (0,1-some_small_value), and length of such step is
//   many times SMALLER than 10000*MachineEpsilon
// * second step, from (x1,y1) to (xs,ys), will be large enough to
//   ignore numerical noise, so the only problem is to perform
//   first step
//
// Naive implementation of BLEIC should fail sometimes (sometimes -
// due to non-deterministic nature of noise) on such problem. However,
// our improved implementation should solve it correctly. We test
// several variations of inner stopping criteria.
   for (pass = 1; pass <= passcount; pass++) {
      eps = 1.0E-9;
      ae_vector_set_length(&x, 2);
      ae_vector_set_length(&bl, 2);
      ae_vector_set_length(&bu, 2);
      x.xR[0] = 10.0 * machineepsilon;
      x.xR[1] = 1.0;
      bl.xR[0] = 0.0;
      bu.xR[0] = +INFINITY;
      bl.xR[1] = 0.0;
      bu.xR[1] = +INFINITY;
      for (ckind = 0; ckind <= 2; ckind++) {
         minbleiccreate(2, &x, &state);
         minbleicsetbc(&state, &bl, &bu);
         if (ckind == 0) {
            minbleicsetcond(&state, eps, 0.0, 0.0, 0);
         }
         if (ckind == 1) {
            minbleicsetcond(&state, 0.0, eps, 0.0, 0);
         }
         if (ckind == 2) {
            minbleicsetcond(&state, 0.0, 0.0, eps, 0);
         }
         while (minbleiciteration(&state))
            if (state.needfg) {
               state.f = sqr(state.x.xR[0] + 1) + sqr(state.x.xR[1] + 1) + 10000.0 * machineepsilon * randomreal();
               state.g.xR[0] = 2 * (state.x.xR[0] + 1);
               state.g.xR[1] = 2 * (state.x.xR[1] + 1);
            }
         minbleicresults(&state, &xf, &rep);
         if (rep.terminationtype <= 0 || xf.xR[0] != 0.0 || xf.xR[1] != 0.0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   }
// Deterministic variation of the previous problem.
//
// Consider following problem:
// * boundary constraints x >= 0, y >= 0
// * starting point (x0,y0) == (10*MachineEpsilon,1.0)
//            / (x+1)^2 + (y+1)^2,        for (x,y) != (x0,y0)
// * f(x,y) = |
//            \ (x+1)^2 + (y+1)^2 - 0.1,  for (x,y) == (x0,y0)
//
// Such problem contains deterministic numerical noise (-0.1 at
// starting point). Without noise its solution is easy to find.
// However, presence of the noise makes it hard to solve:
// * our first step must be done towards (x1,y1) = (0,1-some_small_value),
//   but such step will increase function valye by approximately 0.1  -
//   instead of decreasing it.
//
// Naive implementation of BLEIC should fail on such problem. However,
// our improved implementation should solve it correctly. We test
// several variations of inner stopping criteria.
   for (pass = 1; pass <= passcount; pass++) {
      eps = 1.0E-9;
      ae_vector_set_length(&x, 2);
      ae_vector_set_length(&bl, 2);
      ae_vector_set_length(&bu, 2);
      x.xR[0] = 10.0 * machineepsilon;
      x.xR[1] = 1.0;
      bl.xR[0] = 0.0;
      bu.xR[0] = +INFINITY;
      bl.xR[1] = 0.0;
      bu.xR[1] = +INFINITY;
      for (ckind = 0; ckind <= 2; ckind++) {
         minbleiccreate(2, &x, &state);
         minbleicsetbc(&state, &bl, &bu);
         if (ckind == 0) {
            minbleicsetcond(&state, eps, 0.0, 0.0, 0);
         }
         if (ckind == 1) {
            minbleicsetcond(&state, 0.0, eps, 0.0, 0);
         }
         if (ckind == 2) {
            minbleicsetcond(&state, 0.0, 0.0, eps, 0);
         }
         while (minbleiciteration(&state))
            if (state.needfg) {
               state.f = sqr(state.x.xR[0] + 1) + sqr(state.x.xR[1] + 1);
               if (state.x.xR[0] == x.xR[0] && state.x.xR[1] == x.xR[1]) {
                  state.f -= 0.1;
               }
               state.g.xR[0] = 2 * (state.x.xR[0] + 1);
               state.g.xR[1] = 2 * (state.x.xR[1] + 1);
            }
         minbleicresults(&state, &xf, &rep);
         if (rep.terminationtype <= 0 || xf.xR[0] != 0.0 || xf.xR[1] != 0.0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   }
// Test integrity checks for NAN/INF:
// * algorithm solves optimization problem, which is normal for some time (quadratic)
// * after 5-th step we choose random component of gradient and consistently spoil
//   it by NAN or INF.
// * we check that correct termination code is returned (-8)
   n = 100;
   for (pass = 1; pass <= 10; pass++) {
      spoiliteration = 5;
      stopiteration = 8;
      if (hqrndnormal(&rs) > 0.0) {
      // Gradient can be spoiled by +INF, -INF, NAN
         spoilvar = hqrnduniformi(&rs, n);
         i = hqrnduniformi(&rs, 3);
         spoilval = NAN;
         if (i == 0) {
            spoilval = -INFINITY;
         }
         if (i == 1) {
            spoilval = +INFINITY;
         }
      } else {
      // Function value can be spoiled only by NAN
      // (+INF can be recognized as legitimate value during optimization)
         spoilvar = -1;
         spoilval = NAN;
      }
      spdmatrixrndcond(n, 1.0E5, &fulla);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         b.xR[i] = hqrndnormal(&rs);
         x0.xR[i] = hqrndnormal(&rs);
      }
      minbleiccreate(n, &x0, &state);
      minbleicsetcond(&state, 0.0, 0.0, 0.0, stopiteration);
      minbleicsetxrep(&state, true);
      k = -1;
      while (minbleiciteration(&state))
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += b.xR[i] * state.x.xR[i];
               state.g.xR[i] = b.xR[i];
               for (j = 0; j < n; j++) {
                  state.f += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                  state.g.xR[i] += fulla.xyR[i][j] * state.x.xR[j];
               }
            }
            if (k >= spoiliteration) {
               if (spoilvar < 0) {
                  state.f = spoilval;
               } else {
                  state.g.xR[spoilvar] = spoilval;
               }
            }
         } else if (state.xupdated) {
            k++;
         } else ae_assert(false, "Assertion failed");
      minbleicresults(&state, &x1, &rep);
      Ok = Ok && rep.terminationtype == -8;
   }
// Check algorithm ability to handle request for termination:
// * to terminate with correct return code = 8
// * to return point which was "current" at the moment of termination
//
// NOTE: we solve problem with "corrupted" preconditioner which makes it hard
//       to converge in less than StopCallIdx iterations
   for (pass = 1; pass <= 50; pass++) {
      n = 3;
      ss = 100.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 6 + randomreal();
      }
      ae_vector_set_length(&s, 3);
      s.xR[0] = 0.00001;
      s.xR[1] = 0.00001;
      s.xR[2] = 10000.0;
      stopcallidx = randominteger(20);
      maxits = 25;
      minbleiccreate(n, &x, &state);
      minbleicsetcond(&state, 0.0, 0.0, 0.0, maxits);
      minbleicsetxrep(&state, true);
      minbleicsetprecdiag(&state, &s);
      callidx = 0;
      terminationrequested = false;
      ae_v_move(xlast.xR, 1, x.xR, 1, n);
      while (minbleiciteration(&state))
         if (state.needfg) {
            state.f = ss * sqr(exp(state.x.xR[0]) - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
            state.g.xR[0] = 2 * ss * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[2] - state.x.xR[0]) * (-1);
            state.g.xR[1] = 2 * state.x.xR[1];
            state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
            if (callidx == stopcallidx) {
               minbleicrequesttermination(&state);
               terminationrequested = true;
            }
            callidx++;
         } else if (state.xupdated) {
            if (!terminationrequested) {
               ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
            }
         } else ae_assert(false, "Assertion failed");
      minbleicresults(&state, &x, &rep);
      Ok = Ok && rep.terminationtype == 8;
      for (i = 0; i < n; i++) {
         Ok = Ok && x.xR[i] == xlast.xR[i];
      }
   }
// N-dimensional problem with Ne equality and Ni inequality constraints.
//
// Check that internal SActiveSet object uses efficient algorithm
// to determine initial point: it avoids expensive (N+Ni)-dimensional
// QP subproblem when initial point is feasible w.r.t. constraints.
//
// In order to do so we try to solve 5-dimensional QP problem with
// 2 equality constraints and 1000000 inequality constraints (+box
// constraints). Inefficient algorithm will simply fail to allocate
// enough memory, so we do not have to perform any checks here.
   n = 5;
   nec = 2;
   nic = 1000000;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&bl, n);
   ae_vector_set_length(&bu, n);
   for (scaletype = 0; scaletype <= 1; scaletype++) {
   // Generate problem
      for (i = 0; i < n; i++) {
         x.xR[i] = hqrnduniformr(&rs);
         bl.xR[i] = x.xR[i] - hqrnduniformr(&rs) * hqrnduniformi(&rs, 2);
         bu.xR[i] = x.xR[i] + hqrnduniformr(&rs) * hqrnduniformi(&rs, 2);
      }
      ae_matrix_set_length(&c, nec + nic, n + 1);
      ae_vector_set_length(&ct, nec + nic);
      for (i = 0; i < nec + nic; i++) {
         v = 0.0;
         for (j = 0; j < n; j++) {
            c.xyR[i][j] = hqrndnormal(&rs);
            v += c.xyR[i][j] * x.xR[j];
         }
         c.xyR[i][n] = v;
         if (i < nec) {
            ct.xZ[i] = 0;
         } else {
            c.xyR[i][n] += 0.1;
            ct.xZ[i] = -1;
         }
      }
   // Apply scaling (if needed), then randomly multiply C by
   // some large/small value in order to distort magnitude of
   // linear constraints.
   //
   // Correct SActiveSet implementation must be able to renormalize
   // constraints prior to checking feasibility of initial point.
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 1.0;
         if (scaletype != 0) {
            s.xR[i] = pow(10.0, 20.0 * hqrndmiduniformr(&rs));
         }
         x.xR[i] *= s.xR[i];
         bl.xR[i] *= s.xR[i];
         bu.xR[i] *= s.xR[i];
         for (j = 0; j < nec + nic; j++) {
            c.xyR[j][i] /= s.xR[i];
         }
      }
      for (i = 0; i < nec + nic; i++) {
         v = pow(10.0, 20.0 * hqrndmiduniformr(&rs));
         ae_v_muld(c.xyR[i], 1, n + 1, v);
      }
   // Solve
      minbleiccreate(n, &x, &state);
      minbleicsetscale(&state, &s);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetlc(&state, &c, &ct, nec + nic);
      minbleicsetcond(&state, 0.0, 0.0, 0.0, 1);
      while (minbleiciteration(&state))
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += state.x.xR[i];
               state.g.xR[i] = 1.0;
            }
         }
      minbleicresults(&state, &xf, &rep);
   }
// Test that SActiveSet object prevents steps which increase infeasibility.
// In order to do so we:
// * generate random SPD matrix A with moderate condition number ~1E3
//   and huge norm (about 1E9)
// * generate random initial point x0 with unit norm
// * generate single linear constraint c'*x >= c'*x0, with c == A*x0
// * run BLEIC algorithm from initial point x0 for target function f == 0.5*x'*A*x
//   and check that it stops at x0 (less than 1E-12 away from it)
   n = 20;
   for (pass = 0; pass < 20000; pass++) { //(@) Was originally ... pass <= 20000 ...
      spdmatrixrndcond(n, 1.0E3, &fulla);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            fulla.xyR[i][j] *= 1.0E9;
         }
      }
      ae_vector_set_length(&x0, n);
      v = 0.0;
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrnduniformr(&rs);
         v += sqr(x0.xR[i]);
      }
      ae_assert(v > 0.0, "MinBLEIC: integrity check failed in the unit test");
      for (i = 0; i < n; i++) {
         x0.xR[i] /= sqrt(v);
      }
      ae_matrix_set_length(&c, 1, n + 1);
      ae_vector_set_length(&ct, 1);
      ct.xZ[0] = 1;
      c.xyR[0][n] = 0.0;
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(fulla.xyR[i], 1, x0.xR, 1, n);
         c.xyR[0][i] = v;
         c.xyR[0][n] += v * x0.xR[i];
      }
      ae_assert(c.xyR[0][n] > 0.0, "MinBLEIC: integrity check failed in the unit test");
      minbleiccreate(n, &x0, &state);
      minbleicsetlc(&state, &c, &ct, 1);
      minbleicsetcond(&state, 0.0, 0.0, 1.0E-15, 0);
      while (minbleiciteration(&state))
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(fulla.xyR[i], 1, state.x.xR, 1, n);
               state.f += 0.5 * v * state.x.xR[i];
               state.g.xR[i] = v;
            }
         }
      minbleicresults(&state, &xf, &rep);
      Ok = Ok && rep.terminationtype > 0;
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(x0.xR[i], xf.xR[i], 1.0E-12);
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests convergence properties.
// We solve several simple problems with different combinations of constraints
static bool testminbleicunit_testconv() {
   ae_frame _frame_block;
   ae_int_t passcount;
   ae_int_t pass;
   double epsg;
   double epsfeas;
   double tol;
   ae_int_t m;
   ae_int_t n;
   ae_int_t k;
   ae_int_t i;
   ae_int_t j;
   double v;
   double vv;
   ae_int_t preckind;
   ae_int_t akind;
   ae_int_t shiftkind;
   ae_int_t bscale;
   double tolconstr;
   double f0;
   double f1;
   ae_int_t ccnt;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(xf, 0, DT_REAL);
   NewVector(xs0, 0, DT_REAL);
   NewVector(xs1, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(ce, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewVector(nonnegative, 0, DT_BOOL);
   NewObj(minbleicstate, state);
   NewObj(minbleicreport, rep);
   NewObj(snnlssolver, nnls);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   epsg = 1.0E-8;
   epsfeas = 1.0E-8;
   tol = 0.001;
   passcount = 10;
// Three closely connected problems:
// * 2-dimensional space
// * octagonal area bounded by:
//   * -1 <= x <= +1
//   * -1 <= y <= +1
//   * x+y <= 1.5
//   * x-y <= 1.5
//   * -x+y <= 1.5
//   * -x-y <= 1.5
// * several target functions:
//   * f0 == x+0.001*y, minimum at x == -1, y == -0.5
//   * f1 == (x+10)^2+y^2, minimum at x == -1, y == 0
//   * f2 == (x+10)^2+(y-0.6)^2, minimum at x == -1, y == 0.5
   ae_vector_set_length(&x, 2);
   ae_vector_set_length(&bl, 2);
   ae_vector_set_length(&bu, 2);
   ae_matrix_set_length(&c, 4, 3);
   ae_vector_set_length(&ct, 4);
   bl.xR[0] = -1.0;
   bl.xR[1] = -1.0;
   bu.xR[0] = 1.0;
   bu.xR[1] = 1.0;
   c.xyR[0][0] = 1.0;
   c.xyR[0][1] = 1.0;
   c.xyR[0][2] = 1.5;
   ct.xZ[0] = -1;
   c.xyR[1][0] = 1.0;
   c.xyR[1][1] = -1.0;
   c.xyR[1][2] = 1.5;
   ct.xZ[1] = -1;
   c.xyR[2][0] = -1.0;
   c.xyR[2][1] = 1.0;
   c.xyR[2][2] = 1.5;
   ct.xZ[2] = -1;
   c.xyR[3][0] = -1.0;
   c.xyR[3][1] = -1.0;
   c.xyR[3][2] = 1.5;
   ct.xZ[3] = -1;
   for (pass = 1; pass <= passcount; pass++) {
   // f0
      x.xR[0] = 0.1 * randommid();
      x.xR[1] = 0.1 * randommid();
      minbleiccreate(2, &x, &state);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetlc(&state, &c, &ct, 4);
      minbleicsetcond(&state, epsg, 0.0, 0.0, 0);
      while (minbleiciteration(&state))
         if (state.needfg) {
            state.f = state.x.xR[0] + 0.001 * state.x.xR[1];
            state.g.xR[0] = 1.0;
            state.g.xR[1] = 0.001;
         }
      minbleicresults(&state, &x, &rep);
      if (rep.terminationtype > 0) {
         Ok = Ok && NearAtR(x.xR[0], -1.0, tol);
         Ok = Ok && NearAtR(x.xR[1], -0.5, tol);
      } else {
         Ok = false;
      }
   // f1
      x.xR[0] = 0.1 * randommid();
      x.xR[1] = 0.1 * randommid();
      minbleiccreate(2, &x, &state);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetlc(&state, &c, &ct, 4);
      minbleicsetcond(&state, epsg, 0.0, 0.0, 0);
      while (minbleiciteration(&state))
         if (state.needfg) {
            state.f = sqr(state.x.xR[0] + 10) + sqr(state.x.xR[1]);
            state.g.xR[0] = 2 * (state.x.xR[0] + 10);
            state.g.xR[1] = 2 * state.x.xR[1];
         }
      minbleicresults(&state, &x, &rep);
      if (rep.terminationtype > 0) {
         Ok = Ok && NearAtR(x.xR[0], -1.0, tol);
         Ok = Ok && SmallAtR(x.xR[1], tol);
      } else {
         Ok = false;
      }
   // f2
      x.xR[0] = 0.1 * randommid();
      x.xR[1] = 0.1 * randommid();
      minbleiccreate(2, &x, &state);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetlc(&state, &c, &ct, 4);
      minbleicsetcond(&state, epsg, 0.0, 0.0, 0);
      while (minbleiciteration(&state))
         if (state.needfg) {
            state.f = sqr(state.x.xR[0] + 10) + sqr(state.x.xR[1] - 0.6);
            state.g.xR[0] = 2 * (state.x.xR[0] + 10);
            state.g.xR[1] = 2 * (state.x.xR[1] - 0.6);
         }
      minbleicresults(&state, &x, &rep);
      if (rep.terminationtype > 0) {
         Ok = Ok && NearAtR(x.xR[0], -1.0, tol);
         Ok = Ok && NearAtR(x.xR[1], 0.5, tol);
      } else {
         Ok = false;
      }
   }
// Degenerate optimization problem with excessive constraints.
//
// * N = 3..10, M == N div 3, K == 2*N
// * f(x) = 0.5*|A*x-b|^2, where A is MxN random matrix, b is Mx1 random vector
// * bound constraint:
//   a) Ci == x[i] == Ci for i = 0..M-1
//   b) 0 <= x[i] <= 1   for i = M..N-1
// * linear constraints (for fixed feasible xf and random ai):
//   a) ai*x == ai*xf                 for i = 0..M-1
//   b) ai*x <= ai*xf+random(0.1,1.0) for i = M..K-1
// * preconditioner is chosen at random (we just want to be
//   sure that preconditioning won't prevent us from detecting
//   infeasible point):
//   a) unit preconditioner
//   b) random diagonal-based preconditioner
//   c) random scale-based preconditioner
// * we choose two random initial points from interior of the area
//   given by bound constraints.
//
// We do not know analytic solution of this problem, and we do not need
// to solve it :) we just perform two restarts from two different initial
// points and check that both solutions give approximately same function
// value.
   for (preckind = 0; preckind <= 2; preckind++) {
      for (n = 3; n <= 10; n++) {
      // Generate problem
         m = n / 3;
         k = 2 * n;
         ae_vector_set_length(&bl, n);
         ae_vector_set_length(&bu, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xs0, n);
         ae_vector_set_length(&xs1, n);
         ae_vector_set_length(&xf, n);
         for (i = 0; i < n; i++) {
            if (i < m) {
               v = randomreal();
               bl.xR[i] = v;
               bu.xR[i] = v;
               xf.xR[i] = v;
               xs0.xR[i] = v;
               xs1.xR[i] = v;
            } else {
               bl.xR[i] = 0.0;
               bu.xR[i] = 1.0;
               xf.xR[i] = randomreal();
               xs0.xR[i] = randomreal();
               xs1.xR[i] = randomreal();
            }
            x.xR[i] = randomreal();
         }
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < k; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = randomnormal();
               v += sqr(c.xyR[i][j]);
            }
            if (v > 0.0) {
               for (j = 0; j < n; j++) {
                  c.xyR[i][j] /= sqrt(v);
               }
            }
            v = ae_v_dotproduct(c.xyR[i], 1, xf.xR, 1, n);
            c.xyR[i][n] = v;
            if (i < m) {
               ct.xZ[i] = 0;
            } else {
               ct.xZ[i] = -1;
               c.xyR[i][n] += 0.1 + 0.9 * randomreal();
            }
         }
         ae_matrix_set_length(&a, m, n + 1);
         for (i = 0; i < m; i++) {
            for (j = 0; j <= n; j++) {
               a.xyR[i][j] = randomreal();
            }
         }
      // Create and optimize
         minbleiccreate(n, &x, &state);
         minbleicsetbc(&state, &bl, &bu);
         minbleicsetlc(&state, &c, &ct, k);
         minbleicsetcond(&state, epsg, 0.0, 0.0, 0);
         testminbleicunit_setrandompreconditioner(&state, n, preckind);
      // Solve problem 0:
      // * restart from XS0
      // * solve
      // * check convergence/feasibility
      // * calculate F0 - function value at solution
         for (minbleicrestartfrom(&state, &xs0); minbleiciteration(&state); ) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.g.xR[i] = 0.0;
            }
            for (i = 0; i < m; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
               v -= a.xyR[i][n];
               state.f += 0.5 * sqr(v);
               ae_v_addd(state.g.xR, 1, a.xyR[i], 1, n, v);
            }
         }
         minbleicresults(&state, &x, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            if (x.xR[i] < bl.xR[i] || x.xR[i] > bu.xR[i]) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(c.xyR[i], 1, x.xR, 1, n);
            v -= c.xyR[i][n];
            if (ct.xZ[i] == 0 && !SmallAtR(v, epsfeas)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            if (ct.xZ[i] < 0 && v > epsfeas) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
         f0 = 0.0;
         for (i = 0; i < m; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
            v -= a.xyR[i][n];
            f0 += 0.5 * sqr(v);
         }
      // Solve problem 1:
      // * restart from XS1
      // * solve
      // * check convergence/feasibility
      // * calculate F1 - function value at solution
         for (minbleicrestartfrom(&state, &xs1); minbleiciteration(&state); ) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.g.xR[i] = 0.0;
            }
            for (i = 0; i < m; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
               v -= a.xyR[i][n];
               state.f += 0.5 * sqr(v);
               ae_v_addd(state.g.xR, 1, a.xyR[i], 1, n, v);
            }
         }
         minbleicresults(&state, &x, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            if (x.xR[i] < bl.xR[i] || x.xR[i] > bu.xR[i]) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(c.xyR[i], 1, x.xR, 1, n);
            v -= c.xyR[i][n];
            if (ct.xZ[i] == 0 && !SmallAtR(v, epsfeas)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            if (ct.xZ[i] < 0 && v > epsfeas) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
         f1 = 0.0;
         for (i = 0; i < m; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
            v -= a.xyR[i][n];
            f1 += 0.5 * sqr(v);
         }
      // compare F0 and F1
         Ok = Ok && NearAtR(f0, f1, 1.0E-4);
      }
   }
// Convex/nonconvex optimization problem with excessive
// (degenerate constraints):
//
// * N = 2..8
// * f = 0.5*x'*A*x+b'*x
// * b has normally distributed entries with scale 10^BScale
// * several kinds of A are tried: zero, well conditioned SPD, well conditioned indefinite, low rank
// * box constraints: x[i] in [-1,+1]
// * 2^N "excessive" general linear constraints (v_k,x) <= (v_k,v_k)+v_shift,
//   where v_k is one of 2^N vertices of feasible hypercube, v_shift is
//   a shift parameter:
//   * with zero v_shift such constraints are degenerate (each vertex has
//     N box constraints and one "redundant" linear constraint)
//   * with positive v_shift linear constraint is always inactive
//   * with small (about machine epsilon) but negative v_shift,
//     constraint is close to degenerate - but not exactly
//
// We check that constrained gradient is close to zero at solution.
// Box constraint is considered active if distance to boundary is less
// than TolConstr.
//
// NOTE: TolConstr must be large enough so it won't conflict with
//       perturbation introduced by v_shift
   tolconstr = 1.0E-8;
   for (n = 2; n <= 8; n++) {
      for (akind = 0; akind <= 3; akind++) {
         for (shiftkind = -5; shiftkind <= 1; shiftkind++) {
            for (bscale = 0; bscale >= -2; bscale--) {
            // Generate A, B and initial point
               ae_matrix_set_length(&a, n, n);
               ae_vector_set_length(&b, n);
               ae_vector_set_length(&x, n);
               for (i = 0; i < n; i++) {
                  b.xR[i] = pow(10.0, (double)bscale) * hqrndnormal(&rs);
                  x.xR[i] = hqrnduniformr(&rs) - 0.5;
               }
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               if (akind == 1) {
               // Dense well conditioned SPD
                  spdmatrixrndcond(n, 50.0, &a);
               }
               if (akind == 2) {
               // Dense well conditioned indefinite
                  smatrixrndcond(n, 50.0, &a);
               }
               if (akind == 3) {
               // Low rank
                  ae_vector_set_length(&tmp, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = 0.0;
                     }
                  }
                  for (k = 1; k < imin2(4, n); k++) {
                     for (i = 0; i < n; i++) {
                        tmp.xR[i] = hqrndnormal(&rs);
                     }
                     v = hqrndnormal(&rs);
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                        }
                     }
                  }
               }
            // Generate constraints
               ae_vector_set_length(&bl, n);
               ae_vector_set_length(&bu, n);
               for (i = 0; i < n; i++) {
                  bl.xR[i] = -1.0;
                  bu.xR[i] = 1.0;
               }
               ccnt = iround(pow(2.0, (double)n));
               ae_matrix_set_length(&c, ccnt, n + 1);
               ae_vector_set_length(&ct, ccnt);
               for (i = 0; i < ccnt; i++) {
                  ct.xZ[i] = -1;
                  k = i;
                  c.xyR[i][n] = sign((double)shiftkind) * pow(10.0, fabs((double)shiftkind)) * machineepsilon;
                  for (j = 0; j < n; j++) {
                     c.xyR[i][j] = (double)(2 * (k % 2) - 1);
                     c.xyR[i][n] += c.xyR[i][j] * c.xyR[i][j];
                     k /= 2;
                  }
               }
            // Create and optimize
               minbleiccreate(n, &x, &state);
               minbleicsetbc(&state, &bl, &bu);
               minbleicsetlc(&state, &c, &ct, ccnt);
               minbleicsetcond(&state, 1.0E-9, 0.0, 0.0, 0);
               while (minbleiciteration(&state))
                  if (state.needfg) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += state.x.xR[i] * b.xR[i];
                        state.g.xR[i] = b.xR[i];
                     }
                     for (i = 0; i < n; i++) {
                        v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
                        state.f += 0.5 * state.x.xR[i] * v;
                        state.g.xR[i] += v;
                     }
                  } else ae_assert(false, "Assertion failed");
               minbleicresults(&state, &xs0, &rep);
               Ok = Ok && rep.terminationtype > 0;
               if (!Ok) {
                  ae_frame_leave();
                  return Ok;
               }
            // Evaluate gradient at solution and test
               vv = 0.0;
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, xs0.xR, 1, n);
                  v += b.xR[i];
                  if (xs0.xR[i] <= bl.xR[i] + tolconstr && v > 0.0) {
                     v = 0.0;
                  }
                  if (xs0.xR[i] >= bu.xR[i] - tolconstr && v < 0.0) {
                     v = 0.0;
                  }
                  vv += sqr(v);
               }
               vv = sqrt(vv);
               Ok = Ok && vv <= 1.0E-5;
            }
         }
      }
   }
// Convex/nonconvex optimization problem with combination of
// box and linear constraints:
//
// * N = 2..8
// * f = 0.5*x'*A*x+b'*x
// * b has normally distributed entries with scale 10^BScale
// * several kinds of A are tried: zero, well conditioned SPD,
//   well conditioned indefinite, low rank
// * box constraints: x[i] in [-1,+1]
// * initial point x0 = [0 0 ... 0 0]
// * CCnt == min(3,N-1) general linear constraints of form (c,x) == 0.
//   random mix of equality/inequality constraints is tried.
//   x0 is guaranteed to be feasible.
//
// We check that constrained gradient is close to zero at solution.
// Inequality constraint is considered active if distance to boundary
// is less than TolConstr. We use nonnegative least squares solver
// in order to compute constrained gradient.
   tolconstr = 1.0E-8;
   for (n = 2; n <= 8; n++) {
      for (akind = 0; akind <= 3; akind++) {
         for (bscale = 0; bscale >= -2; bscale--) {
         // Generate A, B and initial point
            ae_matrix_set_length(&a, n, n);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&x, n);
            for (i = 0; i < n; i++) {
               b.xR[i] = pow(10.0, (double)bscale) * hqrndnormal(&rs);
               x.xR[i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
            }
            if (akind == 1) {
            // Dense well conditioned SPD
               spdmatrixrndcond(n, 50.0, &a);
            }
            if (akind == 2) {
            // Dense well conditioned indefinite
               smatrixrndcond(n, 50.0, &a);
            }
            if (akind == 3) {
            // Low rank
               ae_vector_set_length(&tmp, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               for (k = 1; k < imin2(4, n); k++) {
                  for (i = 0; i < n; i++) {
                     tmp.xR[i] = hqrndnormal(&rs);
                  }
                  v = hqrndnormal(&rs);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                     }
                  }
               }
            }
         // Generate constraints
            ae_vector_set_length(&bl, n);
            ae_vector_set_length(&bu, n);
            for (i = 0; i < n; i++) {
               bl.xR[i] = -1.0;
               bu.xR[i] = 1.0;
            }
            ccnt = imin2(3, n - 1);
            ae_matrix_set_length(&c, ccnt, n + 1);
            ae_vector_set_length(&ct, ccnt);
            for (i = 0; i < ccnt; i++) {
               ct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
               c.xyR[i][n] = 0.0;
               for (j = 0; j < n; j++) {
                  c.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         // Create and optimize
            minbleiccreate(n, &x, &state);
            minbleicsetbc(&state, &bl, &bu);
            minbleicsetlc(&state, &c, &ct, ccnt);
            minbleicsetcond(&state, 1.0E-9, 0.0, 0.0, 0);
            while (minbleiciteration(&state))
               if (state.needfg) {
                  state.f = 0.0;
                  for (i = 0; i < n; i++) {
                     state.f += state.x.xR[i] * b.xR[i];
                     state.g.xR[i] = b.xR[i];
                  }
                  for (i = 0; i < n; i++) {
                     v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
                     state.f += 0.5 * state.x.xR[i] * v;
                     state.g.xR[i] += v;
                  }
               } else ae_assert(false, "Assertion failed");
            minbleicresults(&state, &xs0, &rep);
            Ok = Ok && rep.terminationtype > 0;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // 1. evaluate unconstrained gradient at solution
         //
         // 2. calculate constrained gradient (NNLS solver is used
         //    to evaluate gradient subject to active constraints).
         //    In order to do this we form CE matrix, matrix of active
         //    constraints (columns store constraint vectors). Then
         //    we try to approximate gradient vector by columns of CE,
         //    subject to non-negativity restriction placed on variables
         //    corresponding to inequality constraints.
         //
         //    Residual from such regression is a constrained gradient vector.
            ae_vector_set_length(&g, n);
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xs0.xR, 1, n);
               g.xR[i] = v + b.xR[i];
            }
            ae_matrix_set_length(&ce, n, n + ccnt);
            ae_vector_set_length(&nonnegative, n + ccnt);
            k = 0;
            for (i = 0; i < n; i++) {
               Ok = Ok && xs0.xR[i] >= bl.xR[i];
               Ok = Ok && xs0.xR[i] <= bu.xR[i];
               if (xs0.xR[i] <= bl.xR[i] + tolconstr) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = 0.0;
                  }
                  ce.xyR[i][k] = 1.0;
                  nonnegative.xB[k] = true;
                  k++;
                  continue;
               }
               if (xs0.xR[i] >= bu.xR[i] - tolconstr) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = 0.0;
                  }
                  ce.xyR[i][k] = -1.0;
                  nonnegative.xB[k] = true;
                  k++;
                  continue;
               }
            }
            for (i = 0; i < ccnt; i++) {
               v = ae_v_dotproduct(c.xyR[i], 1, xs0.xR, 1, n);
               v -= c.xyR[i][n];
               Ok = Ok && (ct.xZ[i] != 0 || SmallAtR(v, tolconstr));
               Ok = Ok && (ct.xZ[i] <= 0 || v >= -tolconstr);
               Ok = Ok && (ct.xZ[i] >= 0 || v <= +tolconstr);
               if (ct.xZ[i] == 0) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = c.xyR[i][j];
                  }
                  nonnegative.xB[k] = false;
                  k++;
                  continue;
               }
               if (ct.xZ[i] > 0 && v <= tolconstr || ct.xZ[i] < 0 && v >= -tolconstr) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = sign((double)ct.xZ[i]) * c.xyR[i][j];
                  }
                  nonnegative.xB[k] = true;
                  k++;
                  continue;
               }
            }
            snnlsinit(0, 0, 0, &nnls);
            snnlssetproblem(&nnls, &ce, &g, 0, k, n);
            for (i = 0; i < k; i++) {
               if (!nonnegative.xB[i]) {
                  snnlsdropnnc(&nnls, i);
               }
            }
            snnlssolve(&nnls, &tmp);
            for (i = 0; i < k; i++) {
               for (j = 0; j < n; j++) {
                  g.xR[j] -= tmp.xR[i] * ce.xyR[j][i];
               }
            }
            vv = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
            vv = sqrt(vv);
            Ok = Ok && vv <= 1.0E-5;
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests preconditioning
static bool testminbleicunit_testpreconditioning() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t i;
   ae_int_t k;
   ae_int_t cntb1;
   ae_int_t cntb2;
   ae_int_t cntg1;
   ae_int_t cntg2;
   double epsg;
   ae_int_t ckind;
   ae_int_t fk;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(vd, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(units, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(diagh, 0, DT_REAL);
   NewObj(minbleicstate, state);
   NewObj(minbleicreport, rep);
// Preconditioner test 1.
//
// If
// * B1 is default preconditioner with unit scale
// * G1 is diagonal preconditioner based on approximate diagonal of Hessian matrix
// * B2 is default preconditioner with non-unit scale S[i] == 1/sqrt(h[i])
// * G2 is scale-based preconditioner with non-unit scale S[i] == 1/sqrt(h[i])
// then B1 is worse than G1, B2 is worse than G2.
// "Worse" means more iterations to converge.
//
// Test problem setup:
// * f(x) = sum( ((i*i+1)*x[i])^2, i = 0..N-1)
// * constraints:
//   0) absent
//   1) boundary only
//   2) linear equality only
//   3) combination of boundary and linear equality constraints
//
// N        - problem size
// K        - number of repeated passes (should be large enough to average out random factors)
   k = 100;
   epsg = 1.0E-8;
   for (n = 10; n <= 10; n++) {
      for (ckind = 0; ckind <= 3; ckind++) {
         fk = 1;
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&units, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 0.0;
            units.xR[i] = 1.0;
         }
         minbleiccreate(n, &x, &state);
         minbleicsetcond(&state, epsg, 0.0, 0.0, 0);
         if (ckind == 1 || ckind == 3) {
            ae_vector_set_length(&bl, n);
            ae_vector_set_length(&bu, n);
            for (i = 0; i < n; i++) {
               bl.xR[i] = -1.0;
               bu.xR[i] = 1.0;
            }
            minbleicsetbc(&state, &bl, &bu);
         }
         if (ckind == 2 || ckind == 3) {
            ae_matrix_set_length(&c, 1, n + 1);
            ae_vector_set_length(&ct, 1);
            ct.xZ[0] = randominteger(3) - 1;
            for (i = 0; i < n; i++) {
               c.xyR[0][i] = randommid();
            }
            c.xyR[0][n] = 0.0;
            minbleicsetlc(&state, &c, &ct, 1);
         }
      // Test it with default preconditioner VS. perturbed diagonal preconditioner
         minbleicsetprecdefault(&state);
         minbleicsetscale(&state, &units);
         cntb1 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            for (minbleicrestartfrom(&state, &x); minbleiciteration(&state); ) testminbleicunit_calciip2(&state, n, fk);
            minbleicresults(&state, &x, &rep);
            cntb1 += rep.inneriterationscount;
            Ok = Ok && rep.terminationtype > 0;
         }
         ae_vector_set_length(&diagh, n);
         for (i = 0; i < n; i++) {
            diagh.xR[i] = 2 * pow((double)(i * i + 1), (double)(2 * fk)) * (0.8 + 0.4 * randomreal());
         }
         minbleicsetprecdiag(&state, &diagh);
         minbleicsetscale(&state, &units);
         cntg1 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            for (minbleicrestartfrom(&state, &x); minbleiciteration(&state); ) testminbleicunit_calciip2(&state, n, fk);
            minbleicresults(&state, &x, &rep);
            cntg1 += rep.inneriterationscount;
            Ok = Ok && rep.terminationtype > 0;
         }
         Ok = Ok && cntb1 >= cntg1;
      // Test it with scale-based preconditioner
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = 1 / sqrt(2 * pow((double)(i * i + 1), (double)(2 * fk)) * (0.8 + 0.4 * randomreal()));
         }
         minbleicsetprecdefault(&state);
         minbleicsetscale(&state, &s);
         cntb2 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            for (minbleicrestartfrom(&state, &x); minbleiciteration(&state); ) testminbleicunit_calciip2(&state, n, fk);
            minbleicresults(&state, &x, &rep);
            cntb2 += rep.inneriterationscount;
            Ok = Ok && rep.terminationtype > 0;
         }
         minbleicsetprecscale(&state);
         minbleicsetscale(&state, &s);
         cntg2 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            for (minbleicrestartfrom(&state, &x); minbleiciteration(&state); ) testminbleicunit_calciip2(&state, n, fk);
            minbleicresults(&state, &x, &rep);
            cntg2 += rep.inneriterationscount;
            Ok = Ok && rep.terminationtype > 0;
         }
         Ok = Ok && cntb2 >= cntg2;
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests problems which caused bugs in the past.
static bool testminbleicunit_testbugs() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_int_t pass;
   double tolx;
   double regterm;
   ae_int_t n;
   ae_int_t ckind;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(h, 0, DT_REAL);
   NewVector(prior, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(minbleicstate, state);
   NewObj(minbleicreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Reproduce situation: optimizer sometimes hangs when starts with
// gradient orthogonal to the only linear constraint. In most cases
// it is solved successfully, but sometimes leads to infinite loop
// in one of the early optimizer versions.
//
// The problem is:
// * f(x) = x'*x + c'*x
// * linear constraint c'*x == 0
// * initial point is x == 0
// * there are two ways to choose coefficient vector c:
//   * its components can be long binary fractions
//   * or they can be either 0 or 1
//   both ways test different scenarios for accumulation of rounding errors
//
// If test fails, it usually hangs
   tolx = 1.0E-10;
   for (pass = 1; pass <= 10; pass++) {
      for (ckind = 0; ckind <= 1; ckind++) {
         for (n = 2; n <= 10; n++) {
            ae_vector_set_length(&x, n);
            ae_matrix_set_length(&c, 1, n + 1);
            ae_vector_set_length(&ct, 1);
            for (i = 0; i < n; i++) {
               x.xR[i] = 0.0;
               if (ckind == 0) {
                  c.xyR[0][i] = sqrt(hqrnduniformr(&rs));
               } else {
                  c.xyR[0][i] = (double)hqrnduniformi(&rs, 2);
               }
            }
            c.xyR[0][n] = 0.0;
            ct.xZ[0] = 0;
            minbleiccreate(n, &x, &state);
            minbleicsetlc(&state, &c, &ct, 1);
            minbleicsetcond(&state, 0.0, 0.0, 0.0, 99);
            while (minbleiciteration(&state))
               if (state.needfg) {
                  state.f = 0.0;
                  for (i = 0; i < n; i++) {
                     state.f += sqr(state.x.xR[i]) + state.x.xR[i] * c.xyR[0][i];
                     state.g.xR[i] = 2 * state.x.xR[i] + c.xyR[0][i];
                  }
               } else ae_assert(false, "Assertion failed");
            minbleicresultsbuf(&state, &x1, &rep);
            Ok = Ok && rep.terminationtype > 0;
            for (i = 0; i < n; i++) {
               Ok = Ok && SmallAtR(x1.xR[i], tolx);
            }
         }
      }
   }
// Reproduce optimization problem which caused bugs (optimizer hangs)
// when BLEIC was used from MCPD unit. We perform test on specific
// 9-dimensional problem, no need to try general-case methods.
//
// This test hangs if bug is present. Thus, we do not test completion
// code returned by optimizer - we just test that it was returned :)
   tolx = 1.0E-8;
   regterm = 1.0E-8;
   for (pass = 1; pass <= 1000; pass++) {
   // Prepare constraints:
   // * [0,1] box constraints on all variables
   // * 5 linear constraints, first one is random equality;
   //   second one is random inequality; other ones are "sum-to-one" constraints
   //   for x0-x2, x3-x5, x6-x8.
      ae_vector_set_length(&bl, 9);
      ae_vector_set_length(&bu, 9);
      for (i = 0; i < 9; i++) {
         bl.xR[i] = 0.0;
         bu.xR[i] = 1.0;
      }
      ae_matrix_set_length(&c, 5, 10);
      ae_vector_set_length(&ct, 5);
      for (i = 0; i <= 1; i++) {
         c.xyR[i][9] = 0.0;
         for (j = 0; j < 9; j++) {
            c.xyR[i][j] = randommid();
            c.xyR[i][9] += c.xyR[i][j] * (1.0 / 9.0);
         }
      }
      ct.xZ[0] = 0;
      ct.xZ[1] = 1;
      c.xyR[1][9] -= 0.1;
      for (i = 0; i < 3; i++) {
         for (k = 0; k < 9; k++) {
            c.xyR[2 + i][k] = 0.0;
         }
         for (k = 0; k < 3; k++) {
            c.xyR[2 + i][k * 3 + i] = 1.0;
         }
         c.xyR[2 + i][9] = 1.0;
         ct.xZ[2 + i] = 0;
      }
   // Prepare weights
      ae_vector_set_length(&w, 3);
      for (i = 0; i < w.cnt; i++) {
         w.xR[i] = 1.0;
      }
   // Prepare preconditioner H
      ae_vector_set_length(&h, 9);
      for (i = 0; i < h.cnt; i++) {
         h.xR[i] = 1.0;
      }
   // Prepare prior value for regularization
      ae_vector_set_length(&prior, 9);
      for (i = 0; i < prior.cnt; i++) {
         prior.xR[i] = 0.0;
      }
      prior.xR[0] = 1.0;
      prior.xR[4] = 1.0;
      prior.xR[8] = 1.0;
   // Prepare dataset XY
      ae_matrix_set_length(&xy, 6, 3);
      for (i = 0; i < xy.rows; i++) {
         for (j = 0; j < xy.cols; j++) {
            xy.xyR[i][j] = randomreal();
         }
      }
   // Optimize
      ae_vector_set_length(&x, 9);
      for (i = 0; i < 9; i++) {
         x.xR[i] = 1.0 / 9.0;
      }
      minbleiccreate(9, &x, &state);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetlc(&state, &c, &ct, 5);
      minbleicsetcond(&state, 0.0, 0.0, tolx, 0);
      minbleicsetprecdiag(&state, &h);
      while (minbleiciteration(&state))
         if (state.needfg) {
         // Calculate regularization term
            state.f = 0.0;
            for (i = 0; i < 9; i++) {
               state.f += regterm * sqr(state.x.xR[i] - prior.xR[i]);
               state.g.xR[i] = 2 * regterm * (state.x.xR[i] - prior.xR[i]);
            }
         // calculate prediction error/gradient for K-th pair
            for (k = 0; k < xy.rows - 1; k++) {
               for (i = 0; i < 3; i++) {
                  v = ae_v_dotproduct(&state.x.xR[i * 3], 1, xy.xyR[k], 1, 3);
                  state.f += sqr(w.xR[i] * (v - xy.xyR[k + 1][i]));
                  for (j = 0; j < 3; j++) {
                     state.g.xR[i * 3 + j] += 2 * w.xR[i] * w.xR[i] * (v - xy.xyR[k + 1][i]) * xy.xyR[k][j];
                  }
               }
            }
         } else ae_assert(false, "Assertion failed");
      minbleicresultsbuf(&state, &x, &rep);
   }
   ae_frame_leave();
   return Ok;
}

// This function tests report of "non-C1" test #0 for task #0
// given by matrix A.
static bool testminbleicunit_testoptguardc1test0reportfortask0(optguardnonc1test0report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool hasc1discontinuities;
   bool Ok = true;
   if (rep->positive) {
   // Check positive report, first checks
      Ok = Ok && rep->fidx == 0;
      Ok = Ok && rep->n == n;
      Ok = Ok && 0 <= rep->stpidxa;
      Ok = Ok && rep->stpidxa < rep->stpidxb;
      Ok = Ok && rep->stpidxb < rep->cnt;
      Ok = Ok && rep->x0.cnt == rep->n;
      Ok = Ok && rep->d.cnt == rep->n;
      Ok = Ok && rep->stp.cnt == rep->cnt;
      Ok = Ok && rep->f.cnt == rep->cnt;
      Ok = Ok && isfinitevector(&rep->x0, n);
      Ok = Ok && isfinitevector(&rep->d, n);
      Ok = Ok && isfinitevector(&rep->stp, rep->cnt);
      Ok = Ok && isfinitevector(&rep->f, rep->cnt);
      if (!Ok) {
         return Ok;
      }
   // Check consistency of X0, D, Stp and F
      for (k = 0; k < rep->cnt - 1; k++) {
         Ok = Ok && rep->stp.xR[k] < rep->stp.xR[k + 1];
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += fabs(vv);
         }
         Ok = Ok && NearAtR(v, rep->f.xR[k], 1.0E-6 * rmax2(fabs(v), 1.0));
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      Ok = Ok && hasc1discontinuities;
   } else {
   // Check negative report: fields must be empty
      Ok = Ok && rep->stpidxa == -1;
      Ok = Ok && rep->stpidxb == -1;
      Ok = Ok && rep->fidx == -1;
      Ok = Ok && rep->cnt == 0;
      Ok = Ok && rep->n == 0;
      Ok = Ok && rep->x0.cnt == 0;
      Ok = Ok && rep->d.cnt == 0;
      Ok = Ok && rep->stp.cnt == 0;
      Ok = Ok && rep->f.cnt == 0;
   }
   return Ok;
}

// This function tests report of "non-C1" test #1 for task #0
// given by matrix A.
static bool testminbleicunit_testoptguardc1test1reportfortask0(optguardnonc1test1report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool tooclose;
   bool hasc1discontinuities;
   bool Ok = true;
   if (rep->positive) {
   // Check positive report, first checks
      Ok = Ok && rep->fidx == 0;
      Ok = Ok && rep->vidx >= 0;
      Ok = Ok && rep->vidx <= n;
      Ok = Ok && rep->n == n;
      Ok = Ok && 0 <= rep->stpidxa;
      Ok = Ok && rep->stpidxa < rep->stpidxb;
      Ok = Ok && rep->stpidxb < rep->cnt;
      Ok = Ok && rep->x0.cnt == rep->n;
      Ok = Ok && rep->d.cnt == rep->n;
      Ok = Ok && rep->stp.cnt == rep->cnt;
      Ok = Ok && rep->g.cnt == rep->cnt;
      Ok = Ok && isfinitevector(&rep->x0, n);
      Ok = Ok && isfinitevector(&rep->d, n);
      Ok = Ok && isfinitevector(&rep->stp, rep->cnt);
      Ok = Ok && isfinitevector(&rep->g, rep->cnt);
      if (!Ok) {
         return Ok;
      }
   // Check consistency of X0, D, Stp and G
      for (k = 0; k < rep->cnt - 1; k++) {
         Ok = Ok && rep->stp.xR[k] < rep->stp.xR[k + 1];
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         tooclose = false;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += sign(vv) * a->xyR[i][rep->vidx];
            tooclose = tooclose || SmallR(vv, 1.0E-4);
         }
         if (!tooclose) {
            Ok = Ok && NearAtR(v, rep->g.xR[k], 1.0E-6 * rmax2(fabs(v), 1.0));
         }
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      tooclose = false;
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         tooclose = tooclose || SmallR(va, 1.0E-8) || SmallR(vb, 1.0E-8);
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      if (!tooclose) {
         Ok = Ok && hasc1discontinuities;
      }
   } else {
   // Check negative report: fields must be empty
      Ok = Ok && rep->stpidxa == -1;
      Ok = Ok && rep->stpidxb == -1;
      Ok = Ok && rep->fidx == -1;
      Ok = Ok && rep->vidx == -1;
      Ok = Ok && rep->cnt == 0;
      Ok = Ok && rep->n == 0;
      Ok = Ok && rep->x0.cnt == 0;
      Ok = Ok && rep->d.cnt == 0;
      Ok = Ok && rep->stp.cnt == 0;
      Ok = Ok && rep->g.cnt == 0;
   }
   return Ok;
}

// This function tests OptGuard
static bool testminbleicunit_testoptguard() {
   ae_frame _frame_block;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   double diffstep;
   ae_int_t pass;
   ae_int_t defecttype;
   bool failed;
   ae_int_t passcount;
   ae_int_t maxfails;
   ae_int_t failurecounter;
   ae_int_t maxc1test0fails;
   ae_int_t maxc1test1fails;
   ae_int_t c1test0fails;
   ae_int_t c1test1fails;
   double avgstr0len;
   double avglng0len;
   double avgstr1len;
   double avglng1len;
   ae_int_t varidx;
   ae_int_t skind;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minbleicstate, state);
   NewObj(minbleicreport, rep);
   NewObj(optguardreport, ogrep);
   NewObj(optguardnonc1test0report, ognonc1test0strrep);
   NewObj(optguardnonc1test0report, ognonc1test0lngrep);
   NewObj(optguardnonc1test1report, ognonc1test1strrep);
   NewObj(optguardnonc1test1report, ognonc1test1lngrep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(jactrue, 0, 0, DT_REAL);
   NewMatrix(jacdefect, 0, 0, DT_REAL);
   hqrndrandomize(&rs);
// Check that gradient verification is disabled by default:
// gradient checking for bad problem must return nothing
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = 1.0 + 0.1 * i;
   }
   spdmatrixrndcond(n, 1.0E3, &a);
   spdmatrixrndcond(n, 1.0E3, &a1);
   minbleiccreate(n, &x0, &state);
   minbleicsetcond(&state, 0.0, 0.0, 1.0E-9, 10);
   while (minbleiciteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += 0.5 * state.x.xR[i] * v;
         }
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
      } else ae_assert(false, "Assertion failed");
   minbleicresults(&state, &x1, &rep);
   minbleicoptguardresults(&state, &ogrep);
   Ok = Ok && rep.terminationtype > 0;
   Ok = Ok && isfinitevector(&x1, n);
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && ogrep.badgradxbase.cnt == 0;
   Ok = Ok && ogrep.badgraduser.rows == 0;
   Ok = Ok && ogrep.badgraduser.cols == 0;
   Ok = Ok && ogrep.badgradnum.rows == 0;
   Ok = Ok && ogrep.badgradnum.cols == 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && !ogrep.badgradsuspected;
   Ok = Ok && ogrep.badgradfidx == -1;
   Ok = Ok && ogrep.badgradvidx == -1;
// Test that C0/C1 continuity monitoring is disabled by default;
// we solve nonsmooth problem and test that nothing is returned
// by OptGuard.
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = hqrndnormal(&rs);
   }
   ae_matrix_set_length(&a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a.xyR[i][j] = hqrndnormal(&rs);
      }
   }
   minbleiccreate(n, &x0, &state);
   minbleicsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
   while (minbleiciteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += fabs(v);
            v = (double)sign(v);
            for (j = 0; j < n; j++) {
               state.g.xR[j] += v * a.xyR[i][j];
            }
         }
      } else ae_assert(false, "Assertion failed");
   minbleicresults(&state, &x1, &rep);
   minbleicoptguardresults(&state, &ogrep);
   Ok = Ok && isfinitevector(&x1, n);
   Ok = Ok && rep.terminationtype > 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && !ogrep.nonc0suspected;
   Ok = Ok && !ogrep.nonc1suspected;
   Ok = Ok && optguardallclear(&ogrep);
   Ok = Ok && ogrep.nonc0fidx < 0;
   Ok = Ok && ogrep.nonc1fidx < 0;
   Ok = Ok && !ogrep.nonc1test0positive;
   Ok = Ok && !ogrep.nonc1test1positive;
// Test gradient checking functionality, try various
// defect types:
// * accidental zeroing of some gradient component
// * accidental addition of 1.0 to some component
// * accidental multiplication by 2.0
// Try distorting both target and constraints.
   diffstep = 0.001;
   n = 10;
   for (skind = 0; skind <= 1; skind++) {
      for (defecttype = -1; defecttype <= 2; defecttype++) {
         varidx = hqrnduniformi(&rs, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, skind * 15.0 * hqrndmiduniformr(&rs));
            x0.xR[i] = (1.0 + 0.1 * i) * s.xR[i];
            j = hqrnduniformi(&rs, 3);
            bndl.xR[i] = -100 * s.xR[i];
            bndu.xR[i] = 100 * s.xR[i];
            if (j == 1) {
               bndl.xR[i] = x0.xR[i];
            }
            if (j == 2) {
               bndu.xR[i] = x0.xR[i];
            }
         }
         spdmatrixrndcond(n, 1.0E3, &a);
         spdmatrixrndcond(n, 1.0E3, &a1);
         minbleiccreate(n, &x0, &state);
         minbleicoptguardgradient(&state, diffstep);
         minbleicsetcond(&state, 0.0, 0.0, 1.0E-9, 10);
         minbleicsetscale(&state, &s);
         minbleicsetbc(&state, &bndl, &bndu);
         while (minbleiciteration(&state))
            if (state.needfg) {
               for (i = 0; i < n; i++) {
                  Ok = Ok && state.x.xR[i] >= bndl.xR[i];
                  Ok = Ok && state.x.xR[i] <= bndu.xR[i];
               }
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += state.x.xR[j] / s.xR[j] * a.xyR[i][j];
                  }
                  state.f += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                  state.g.xR[i] = v;
               }
               if (defecttype == 0) {
                  state.g.xR[varidx] = 0.0;
               }
               if (defecttype == 1) {
                  state.g.xR[varidx]++;
               }
               if (defecttype == 2) {
                  state.g.xR[varidx] *= 2;
               }
               for (i = 0; i < n; i++) {
                  state.g.xR[i] /= s.xR[i];
               }
            } else ae_assert(false, "Assertion failed");
         minbleicresults(&state, &x1, &rep);
         minbleicoptguardresults(&state, &ogrep);
      // Check that something is returned
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && isfinitevector(&x1, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Compute reference values for true and spoiled Jacobian at X0
         Ok = Ok && isfinitevector(&ogrep.badgradxbase, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         ae_matrix_set_length(&jactrue, 1, n);
         ae_matrix_set_length(&jacdefect, 1, n);
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += ogrep.badgradxbase.xR[j] / s.xR[j] * a.xyR[i][j];
            }
            jactrue.xyR[0][i] = v;
            jacdefect.xyR[0][i] = v;
         }
         if (defecttype == 0) {
            jacdefect.xyR[0][varidx] = 0.0;
         }
         if (defecttype == 1) {
            jacdefect.xyR[0][varidx]++;
         }
         if (defecttype == 2) {
            jacdefect.xyR[0][varidx] *= 2;
         }
         for (i = 0; i < n; i++) {
            jactrue.xyR[0][i] /= s.xR[i];
            jacdefect.xyR[0][i] /= s.xR[i];
         }
      // Check OptGuard report
         Ok = Ok && apservisfinitematrix(&ogrep.badgraduser, 1, n);
         Ok = Ok && apservisfinitematrix(&ogrep.badgradnum, 1, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         if (defecttype >= 0) {
            Ok = Ok && ogrep.badgradsuspected;
            Ok = Ok && ogrep.badgradfidx == 0;
            Ok = Ok && ogrep.badgradvidx == varidx;
         } else {
            Ok = Ok && !ogrep.badgradsuspected;
            Ok = Ok && ogrep.badgradfidx == -1;
            Ok = Ok && ogrep.badgradvidx == -1;
         }
         for (j = 0; j < n; j++) {
            Ok = Ok && NearAtR(jactrue.xyR[0][j], ogrep.badgradnum.xyR[0][j], 0.01 / s.xR[j]);
            Ok = Ok && NearAtR(jacdefect.xyR[0][j], ogrep.badgraduser.xyR[0][j], 0.01 / s.xR[j]);
         }
      }
   }
// A test for detection of C1 continuity violations in the target.
//
// Target function is a sum of |(x,c_i)| for i = 1..N.
// No constraints is present.
// Analytic gradient is provided.
//
// OptGuard should be able to detect violations in more than
// 99.9% of runs; it means that 100 runs should have no more than 4
// failures in all cases (even after multiple repeated tests; according
// to the binomial distribution quantiles).
//
// We select some N and perform exhaustive search for this N.
   passcount = 100;
   maxfails = 4;
   maxc1test0fails = 10;
   maxc1test1fails = 10;
   n = 1 + hqrnduniformi(&rs, 10);
   failurecounter = 0;
   c1test0fails = 0;
   c1test1fails = 0;
   avgstr0len = 0.0;
   avglng0len = 0.0;
   avgstr1len = 0.0;
   avglng1len = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = pow(2.0, hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      minbleiccreate(n, &x0, &state);
      minbleicsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      minbleicsetscale(&state, &s);
      minbleicoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminbleicunit_maxoptguardlevel));
      while (minbleiciteration(&state))
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.g.xR[i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
               v = (double)sign(v);
               for (j = 0; j < n; j++) {
                  state.g.xR[j] += v * a.xyR[i][j];
               }
            }
         } else ae_assert(false, "Assertion failed");
      minbleicresults(&state, &x1, &rep);
      minbleicoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Check generic OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      Ok = Ok && !ogrep.nonc0suspected;
      Ok = Ok && ogrep.nonc0fidx < 0;
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   // Check C1 continuity test #0
      minbleicoptguardnonc1test0results(&state, &ognonc1test0strrep, &ognonc1test0lngrep);
      minbleicoptguardnonc1test1results(&state, &ognonc1test1strrep, &ognonc1test1lngrep);
      if (ogrep.nonc1test0positive) {
         Ok = Ok && ogrep.nonc1suspected;
         Ok = Ok && ognonc1test0strrep.positive;
         Ok = Ok && ognonc1test0lngrep.positive;
         Ok = Ok && ogrep.nonc1fidx == 0;
         Ok = Ok && testminbleicunit_testoptguardc1test0reportfortask0(&ognonc1test0strrep, &a, n);
         Ok = Ok && testminbleicunit_testoptguardc1test0reportfortask0(&ognonc1test0lngrep, &a, n);
         avgstr0len += (double)ognonc1test0strrep.cnt / passcount;
         avglng0len += (double)ognonc1test0lngrep.cnt / passcount;
      } else {
         Ok = Ok && !ognonc1test0strrep.positive;
         Ok = Ok && !ognonc1test0lngrep.positive;
         Ok = Ok && testminbleicunit_testoptguardc1test0reportfortask0(&ognonc1test0strrep, &a, n);
         Ok = Ok && testminbleicunit_testoptguardc1test0reportfortask0(&ognonc1test0lngrep, &a, n);
         c1test0fails++;
      }
      if (ogrep.nonc1test1positive) {
         Ok = Ok && ogrep.nonc1suspected;
         Ok = Ok && ognonc1test1strrep.positive;
         Ok = Ok && ognonc1test1lngrep.positive;
         Ok = Ok && ogrep.nonc1fidx == 0;
         Ok = Ok && testminbleicunit_testoptguardc1test1reportfortask0(&ognonc1test1strrep, &a, n);
         Ok = Ok && testminbleicunit_testoptguardc1test1reportfortask0(&ognonc1test1lngrep, &a, n);
         avgstr1len += (double)ognonc1test1strrep.cnt / passcount;
         avglng1len += (double)ognonc1test1lngrep.cnt / passcount;
      } else {
         Ok = Ok && !ognonc1test1strrep.positive;
         Ok = Ok && !ognonc1test1lngrep.positive;
         Ok = Ok && testminbleicunit_testoptguardc1test1reportfortask0(&ognonc1test1strrep, &a, n);
         Ok = Ok && testminbleicunit_testoptguardc1test1reportfortask0(&ognonc1test1lngrep, &a, n);
         c1test1fails++;
      }
   }
   Ok = Ok && failurecounter <= maxfails;
   Ok = Ok && c1test0fails <= maxc1test0fails;
   Ok = Ok && c1test1fails <= maxc1test1fails;
   Ok = Ok && avglng0len > avgstr0len;
   Ok = Ok && avglng1len > avgstr1len;
// Detection of C1 continuity violations in the target under numerical differentiation:
// * target function is a sum of |(x,c_i)| for i = 1..N.
// * no constraints is present.
// * analytic gradient is provided.
//
// OptGuard should always be able to detect violations in more than
// 99% of runs (note: reduced strength when compared with analytic gradient);
// it means that 100 runs should have no more than 10 failures in all cases
// (even after multiple repeated tests; according to the binomial distribution
// quantiles).
//
// We select some N and perform exhaustive search for this N.
   diffstep = 0.0001;
   passcount = 100;
   maxfails = 10;
   n = 1 + hqrnduniformi(&rs, 10);
   failurecounter = 0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 0.01 * pow(2.0, 0.33 * hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      minbleiccreatef(n, &x0, diffstep, &state);
      minbleicsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      minbleicoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminbleicunit_maxoptguardlevel));
      while (minbleiciteration(&state))
         if (state.needf) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
            }
         } else ae_assert(false, "Assertion failed");
      minbleicresults(&state, &x1, &rep);
      minbleicoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Check OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      Ok = Ok && !ogrep.nonc0suspected;
      Ok = Ok && ogrep.nonc0fidx < 0;
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   }
   Ok = Ok && failurecounter <= maxfails;
// Make sure than no false positives are reported for larger
// problems where numerical noise can be an issue:
// * N == 100 dimensions
// * positive-definite quadratic programming problem
// * upper limit on iterations count, MaxIts == 25
// We simply test that OptGuard does not return error code.
   n = 100;
   spdmatrixrndcond(n, 1.0E2, &a);
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = hqrndnormal(&rs);
      x0.xR[i] = pow(2.0, hqrndnormal(&rs));
   }
   minbleiccreate(n, &x0, &state);
   minbleicoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminbleicunit_maxoptguardlevel));
   minbleicsetcond(&state, 0.0, 0.0, 1.0E-9, 25);
   while (minbleiciteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += b.xR[i] * state.x.xR[i];
            state.g.xR[i] = b.xR[i];
            for (j = 0; j < n; j++) {
               state.f += 0.5 * state.x.xR[i] * a.xyR[i][j] * state.x.xR[j];
               state.g.xR[i] += a.xyR[i][j] * state.x.xR[j];
            }
         }
      } else ae_assert(false, "Assertion failed");
   minbleicresults(&state, &x1, &rep);
   Ok = Ok && isfinitevector(&x1, n);
   Ok = Ok && rep.terminationtype > 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   minbleicoptguardresults(&state, &ogrep);
   Ok = Ok && optguardallclear(&ogrep);
   ae_frame_leave();
   return Ok;
}

bool testminbleic() {
   bool Ok;
   bool feasibilityOk;
   bool otherOk;
   bool precOk;
   bool intOk;
   bool convOk;
   bool optguardOk;
   bool bugsOk;
   Ok = true;
   feasibilityOk = true;
   otherOk = true;
   precOk = true;
   intOk = true;
   convOk = true;
   optguardOk = true;
   bugsOk = true;
   feasibilityOk = feasibilityOk && testminbleicunit_testfeasibility(&convOk, &intOk); //(@)
   otherOk = otherOk && testminbleicunit_testother();
   convOk = convOk && testminbleicunit_testconv();
   bugsOk = bugsOk && testminbleicunit_testbugs();
   precOk = precOk && testminbleicunit_testpreconditioning();
   optguardOk = optguardOk && testminbleicunit_testoptguard();
// The final report.
   Ok = feasibilityOk && otherOk && convOk && intOk && precOk && optguardOk && bugsOk;
   if (!Ok || !silent) {
      printf("BLEIC Optimization Tests\n");
      printf("Feasibility Properties:                   %s\n", feasibilityOk? "Ok": "Failed");
      printf("Preconditioning:                          %s\n", precOk? "Ok": "Failed");
      printf("Other Properties:                         %s\n", otherOk? "Ok": "Failed");
      printf("Convergence Properties:                   %s\n", convOk? "Ok": "Failed");
      printf("Internal Errors:                          %s\n", intOk? "Ok": "Failed");
      printf("OptGuard:                                 %s\n", optguardOk? "Ok": "Failed");
      printf("Fixed Bugs:                               %s\n", bugsOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === minqp testing unit ===
// set random type of the QP solver, must support boundary constraints
static void testminqpunit_setrandomalgobc(minqpstate *s) {
   ae_int_t i;
   i = randominteger(2);
   if (i == 0) {
      minqpsetalgoquickqp(s, 0.0, 0.0, 1.0E-13, 0, true);
   }
   if (i == 1) {
      minqpsetalgobleic(s, 1.0E-12, 0.0, 0.0, 0);
   }
}

// Function to test: 'MinQPCreate', 'MinQPSetQuadraticTerm', 'MinQPSetBC',
// 'MinQPSetOrigin', 'MinQPSetStartingPoint', 'MinQPOptimize', 'MinQPResults'.
//
// Test problem:
//     A = diag(aii), aii > 0 (random)
//     b = 0
//     random bounds (either no bounds, one bound, two bounds a < b, two bounds a == b)
//     random start point
//     dimension - from 1 to 5.
static bool simpletest() {
   ae_frame _frame_block;
   ae_int_t nexp;
   ae_int_t msn;
   ae_int_t sn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double maxstb;
   ae_int_t infd;
   double maxn;
   double maxnb;
   double minnb;
   double eps;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(minqpstate, state);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(ub, 0, DT_REAL);
   NewVector(db, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(tx, 0, DT_REAL);
   NewVector(stx, 0, DT_REAL);
   NewVector(xori, 0, DT_REAL);
   NewObj(minqpreport, rep);
   eps = 0.001;
   msn = 5;
   maxstb = 10.0;
   nexp = 1000;
   maxn = 10.0;
   maxnb = 1000.0;
   minnb = -1000.0;
   for (sn = 1; sn <= msn; sn++) {
      ae_vector_set_length(&tx, sn);
      ae_vector_set_length(&xori, sn);
      ae_vector_set_length(&stx, sn);
      ae_vector_set_length(&db, sn);
      ae_vector_set_length(&ub, sn);
      ae_matrix_set_length(&a, sn, sn);
      for (i = 0; i <= nexp; i++) {
      // create diagonal matrix
         for (k = 0; k < sn; k++) {
            for (j = 0; j <= k; j++) {
               if (j != k) {
                  a.xyR[k][j] = 0.0;
               } else {
                  a.xyR[k][j] = maxn * randomreal() + 1;
               }
            }
         }
         minqpcreate(sn, &state);
         testminqpunit_setrandomalgobc(&state);
         minqpsetquadraticterm(&state, &a, false);
         for (j = 0; j < sn; j++) {
            infd = randominteger(5);
            if (infd == 0) {
               db.xR[j] = -INFINITY;
               ub.xR[j] = +INFINITY;
            } else {
               if (infd == 1) {
                  db.xR[j] = -INFINITY;
                  ub.xR[j] = (maxnb - minnb) * randomreal() + minnb;
               } else {
                  if (infd == 2) {
                     db.xR[j] = (maxnb - minnb) * randomreal() + minnb;
                     ub.xR[j] = +INFINITY;
                  } else {
                     if (infd == 3) {
                        db.xR[j] = (maxnb - minnb) * randomreal() + minnb;
                        ub.xR[j] = db.xR[j] + maxstb * randomreal() + 0.01;
                     } else {
                        db.xR[j] = (maxnb - minnb) * randomreal() + minnb;
                        ub.xR[j] = db.xR[j];
                     }
                  }
               }
            }
         }
         minqpsetbc(&state, &db, &ub);
      // initialization for shifting
      // initial value for 'XORi'
      // and searching true results
         for (j = 0; j < sn; j++) {
            xori.xR[j] = (maxnb - minnb) * randomreal() + minnb;
            tx.xR[j] = rboundval(xori.xR[j], db.xR[j], ub.xR[j]);
         }
         minqpsetorigin(&state, &xori);
      // initialization for starting point
         for (j = 0; j < sn; j++) {
            stx.xR[j] = (maxnb - minnb) * randomreal() + minnb;
         }
         minqpsetstartingpoint(&state, &stx);
      // optimize and get result
         minqpoptimize(&state);
         minqpresults(&state, &x, &rep);
         for (j = 0; j < sn; j++) {
            if (!NearAtR(tx.xR[j], x.xR[j], eps) || x.xR[j] < db.xR[j] || x.xR[j] > ub.xR[j]) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Function to test: 'MinQPCreate', 'MinQPSetLinearTerm', 'MinQPSetQuadraticTerm',
// 'MinQPSetOrigin', 'MinQPSetStartingPoint', 'MinQPOptimize', 'MinQPResults'.
//
// Test problem:
//     A = positive-definite matrix, obtained by 'SPDMatrixRndCond' function
//     b != 0
//     without bounds
//     random start point
//     dimension - from 1 to 5.
static bool functest1() {
   ae_frame _frame_block;
   ae_int_t nexp;
   ae_int_t msn;
   ae_int_t sn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double eps;
   ae_int_t c2;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(minqpstate, state);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(ub, 0, DT_REAL);
   NewVector(db, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(tx, 0, DT_REAL);
   NewVector(stx, 0, DT_REAL);
   NewVector(xori, 0, DT_REAL);
   NewVector(xoric, 0, DT_REAL);
   NewObj(minqpreport, rep);
   NewVector(b, 0, DT_REAL);
   eps = 0.001;
   msn = 5;
   c2 = 1000;
   nexp = 1000;
   for (sn = 1; sn <= msn; sn++) {
      ae_vector_set_length(&b, sn);
      ae_vector_set_length(&tx, sn);
      ae_vector_set_length(&xori, sn);
      ae_vector_set_length(&xoric, sn);
      ae_vector_set_length(&stx, sn);
      for (i = 0; i <= nexp; i++) {
      // create simmetric matrix 'A'
         spdmatrixrndcond(sn, exp(randomreal() * log((double)c2)), &a);
         minqpcreate(sn, &state);
         testminqpunit_setrandomalgobc(&state);
         minqpsetquadraticterm(&state, &a, false);
         for (j = 0; j < sn; j++) {
            xoric.xR[j] = randommid();
         }
      // create linear part
         for (j = 0; j < sn; j++) {
            b.xR[j] = 0.0;
            for (k = 0; k < sn; k++) {
               b.xR[j] -= xoric.xR[k] * a.xyR[k][j];
            }
         }
         minqpsetlinearterm(&state, &b);
      // initialization for shifting
      // initial value for 'XORi'
      // and searching true results
         for (j = 0; j < sn; j++) {
            xori.xR[j] = randommid();
            tx.xR[j] = xori.xR[j] + xoric.xR[j];
         }
         minqpsetorigin(&state, &xori);
      // initialization for starting point
         for (j = 0; j < sn; j++) {
            stx.xR[j] = randommid();
         }
         minqpsetstartingpoint(&state, &stx);
      // optimize and get result
         minqpoptimize(&state);
         minqpresults(&state, &x, &rep);
         for (j = 0; j < sn; j++) {
            if (!NearAtR(tx.xR[j], x.xR[j], eps)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Function normal
static double testminqpunit_projectedantigradnorm(ae_int_t n, RVector *x, RVector *g, RVector *bndl, RVector *bndu) {
   ae_int_t i;
   double r;
   double result;
   r = 0.0;
   for (i = 0; i < n; i++) {
      ae_assert(x->xR[i] >= bndl->xR[i] && x->xR[i] <= bndu->xR[i], "ProjectedAntiGradNormal: boundary constraints violation");
      if (x->xR[i] > bndl->xR[i] && x->xR[i] < bndu->xR[i] || x->xR[i] == bndl->xR[i] && -g->xR[i] > 0.0 || x->xR[i] == bndu->xR[i] && -g->xR[i] < 0.0) {
         r += g->xR[i] * g->xR[i];
      }
   }
   result = sqrt(r);
   return result;
}

// Function to test: 'MinQPCreate', 'MinQPSetLinearTerm', 'MinQPSetQuadraticTerm',
// 'MinQPSetBC', 'MinQPSetOrigin', 'MinQPSetStartingPoint', 'MinQPOptimize',
// 'MinQPResults'.
//
// Test problem:
//     A = positive-definite matrix, obtained by 'SPDMatrixRndCond' function
//     b != 0
//     boundary constraints
//     random start point
//     dimension - from 1 to 5.
static bool functest2() {
   ae_frame _frame_block;
   ae_int_t nexp;
   ae_int_t msn;
   ae_int_t sn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double maxstb;
   ae_int_t infd;
   double maxnb;
   double minnb;
   double eps;
   ae_int_t c2;
   double anti;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(minqpstate, state);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(ub, 0, DT_REAL);
   NewVector(db, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(tmpx, 0, DT_REAL);
   NewVector(stx, 0, DT_REAL);
   NewVector(xori, 0, DT_REAL);
   NewVector(xoric, 0, DT_REAL);
   NewObj(minqpreport, rep);
   NewVector(b, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(c, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   eps = 0.001;
   msn = 5;
   c2 = 1000;
   maxstb = 10.0;
   nexp = 1000;
   maxnb = 1000.0;
   minnb = -1000.0;
   for (sn = 1; sn <= msn; sn++) {
      ae_vector_set_length(&tmpx, sn);
      ae_vector_set_length(&b, sn);
      ae_vector_set_length(&c, sn);
      ae_vector_set_length(&g, sn);
      ae_vector_set_length(&xori, sn);
      ae_vector_set_length(&xoric, sn);
      ae_vector_set_length(&stx, sn);
      ae_vector_set_length(&db, sn);
      ae_vector_set_length(&ub, sn);
      ae_vector_set_length(&y0, sn);
      ae_vector_set_length(&y1, sn);
      for (i = 0; i <= nexp; i++) {
      // create simmetric matrix 'A'
         spdmatrixrndcond(sn, exp(randomreal() * log((double)c2)), &a);
         minqpcreate(sn, &state);
         testminqpunit_setrandomalgobc(&state);
         minqpsetquadraticterm(&state, &a, false);
         for (j = 0; j < sn; j++) {
            xoric.xR[j] = (maxnb - minnb) * randomreal() + minnb;
         }
      // create linear part
         for (j = 0; j < sn; j++) {
            b.xR[j] = 0.0;
            for (k = 0; k < sn; k++) {
               b.xR[j] -= xoric.xR[k] * a.xyR[k][j];
            }
         }
         minqpsetlinearterm(&state, &b);
         for (j = 0; j < sn; j++) {
            infd = randominteger(4);
            if (infd == 0) {
               db.xR[j] = -INFINITY;
               ub.xR[j] = +INFINITY;
            } else {
               if (infd == 1) {
                  db.xR[j] = -INFINITY;
                  ub.xR[j] = (maxnb - minnb) * randomreal() + minnb;
               } else {
                  if (infd == 2) {
                     db.xR[j] = (maxnb - minnb) * randomreal() + minnb;
                     ub.xR[j] = +INFINITY;
                  } else {
                     db.xR[j] = (maxnb - minnb) * randomreal() + minnb;
                     ub.xR[j] = db.xR[j] + maxstb * randomreal() + 0.01;
                  }
               }
            }
         }
         minqpsetbc(&state, &db, &ub);
      // initialization for shifting
      // initial value for 'XORi'
      // and searching true results
         for (j = 0; j < sn; j++) {
            xori.xR[j] = (maxnb - minnb) * randomreal() + minnb;
         }
         minqpsetorigin(&state, &xori);
         for (j = 0; j < sn; j++) {
            c.xR[j] = 0.0;
            for (k = 0; k < sn; k++) {
               c.xR[j] -= xori.xR[k] * a.xyR[k][j];
            }
         }
      // initialization for starting point
         for (j = 0; j < sn; j++) {
            stx.xR[j] = (maxnb - minnb) * randomreal() + minnb;
         }
         minqpsetstartingpoint(&state, &stx);
      // optimize and get result
         minqpoptimize(&state);
         minqpresults(&state, &x, &rep);
         rmatrixmv(sn, sn, &a, 0, 0, 0, &x, 0, &y0, 0);
         for (j = 0; j < sn; j++) {
            g.xR[j] = y0.xR[j] + c.xR[j] + b.xR[j];
         }
         anti = testminqpunit_projectedantigradnorm(sn, &x, &g, &db, &ub);
         for (j = 0; j < sn; j++) {
            if (!SmallAtR(anti, eps)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

#if 0 //(@) Not used anymore.
// ConsoleTest.
static bool consoletest() {
   ae_frame _frame_block;
   ae_int_t nexp;
   ae_int_t msn;
   ae_int_t sn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double eps;
   double c;
   double anti;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(minqpstate, state);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(ub, 0, DT_REAL);
   NewVector(db, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(stx, 0, DT_REAL);
   NewVector(xori, 0, DT_REAL);
   NewVector(xoric, 0, DT_REAL);
   NewObj(minqpreport, rep);
   NewVector(b, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   eps = 0.001;
   msn = 2;
   nexp = 0;
   for (sn = 2; sn <= msn; sn++) {
      ae_vector_set_length(&b, sn);
      ae_vector_set_length(&g, sn);
      ae_vector_set_length(&xori, sn);
      ae_vector_set_length(&xoric, sn);
      ae_vector_set_length(&stx, sn);
      ae_vector_set_length(&db, sn);
      ae_vector_set_length(&ub, sn);
      ae_vector_set_length(&y0, sn);
      ae_vector_set_length(&y1, sn);
      for (i = 0; i <= nexp; i++) {
      // create simmetric matrix 'A'
         ae_matrix_set_length(&a, sn, sn);
         for (j = 0; j < sn; j++) {
            for (k = 0; k < sn; k++) {
               if (j == k) {
                  a.xyR[j][k] = 1.0;
               } else {
                  a.xyR[j][k] = 0.0;
               }
               printf("%0.5f ", a.xyR[j][k]);
            }
            printf("\n");
         }
         minqpcreate(sn, &state);
         testminqpunit_setrandomalgobc(&state);
         minqpsetquadraticterm(&state, &a, false);
         for (j = 0; j < sn; j++) {
            xoric.xR[j] = 1.0;
            printf("XoriC == %0.5f \n", xoric.xR[j]);
         }
      // create linear part
         for (j = 0; j < sn; j++) {
            b.xR[j] = 0.0;
            for (k = 0; k < sn; k++) {
               b.xR[j] -= xoric.xR[k] * a.xyR[k][j];
            }
            printf("B[%0d] == %0.5f\n", (int)j, b.xR[j]);
         }
         minqpsetlinearterm(&state, &b);
         for (j = 0; j < sn; j++) {
            db.xR[j] = 10.0;
            ub.xR[j] = 20.0;
         }
         minqpsetbc(&state, &db, &ub);
      // initialization for shifting
      // initial value for 'XORi'
      // and searching true results
         for (j = 0; j < sn; j++) {
            xori.xR[j] = 1.0;
         }
         minqpsetorigin(&state, &xori);
      // optimize and get result
         minqpoptimize(&state);
         minqpresults(&state, &x, &rep);
         rmatrixmv(sn, sn, &a, 0, 0, 0, &x, 0, &y0, 0);
         rmatrixmv(sn, sn, &a, 0, 0, 0, &x, 0, &y1, 0);
         for (j = 0; j < sn; j++) {
            c = 0.0;
            for (k = 0; k < sn; k++) {
               c -= xori.xR[k] * a.xyR[k][j];
            }
            g.xR[j] = b.xR[j] + c + y0.xR[j] + y1.xR[j];
         }
         anti = testminqpunit_projectedantigradnorm(sn, &x, &b, &db, &ub);
         printf("SN == %0d\n", (int)sn);
         printf("NEXP == %0d\n", (int)i);
         printf("TermType == %0d\n", (int)rep.terminationtype);
         for (j = 0; j < sn; j++) {
            printf("X[%0d] == %0.5f;\n", (int)j, x.xR[j]);
            printf("DB[%0d] == %0.5f; UB[%0d] == %0.5f\n", (int)j, db.xR[j], (int)j, ub.xR[j]);
            printf("XORi[%0d] == %0.5f; XORiC[%0d] == %0.5f;\n", (int)j, xori.xR[j], (int)j, xoric.xR[j]);
            printf("Anti[%0d] == %0.5f;\n", (int)j, anti);
            if (!SmallAtR(anti, eps)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}
#endif

// Convert dense matrix to sparse matrix using random format
static void testminqpunit_densetosparse(RMatrix *a, ae_int_t n, sparsematrix *s) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(&_frame_block);
   SetObj(sparsematrix, s);
   NewObj(sparsematrix, s0);
   sparsecreate(n, n, n * n, &s0);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         sparseset(&s0, i, j, a->xyR[i][j]);
      }
   }
   sparsecopytobuf(&s0, randominteger(3), s);
   ae_frame_leave();
}

// This function tests that norm of bound-constrained gradient at point X is
// less than Eps:
// * unconstrained gradient is A*x+b
// * if I-th component is at the boundary, and antigradient points outside of
//   the feasible area, I-th component of constrained gradient is zero
//
// This function accepts QP terms A and B, bound constraints, current point,
// and performs test. Additionally, it checks that point is feasible w.r.t.
// boundary constraints.
static bool testminqpunit_testbcgradandfeasibility(RMatrix *a, RVector *b, RVector *bndl, RVector *bndu, ae_int_t n, RVector *x, double eps) {
   bool Ok = true;
   ae_int_t i;
   ae_int_t j;
   double g;
   double gnorm;
   gnorm = 0.0;
   for (i = 0; i < n; i++) {
      g = b->xR[i];
      for (j = 0; j < n; j++) {
         g += a->xyR[i][j] * x->xR[j];
      }
      if (x->xR[i] == bndl->xR[i] && g > 0.0) {
         g = 0.0;
      }
      if (x->xR[i] == bndu->xR[i] && g < 0.0) {
         g = 0.0;
      }
      gnorm += sqr(g);
      if (x->xR[i] < bndl->xR[i]) {
         Ok = false;
      }
      if (x->xR[i] > bndu->xR[i]) {
         Ok = false;
      }
   }
   gnorm = sqrt(gnorm);
   if (gnorm > eps) {
      Ok = false;
   }
   return Ok;
}

// This function performs tests specific for QuickQP solver
static bool quickqptests() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double g;
   double gnorm;
   ae_int_t origintype;
   ae_int_t scaletype;
   bool isupper;
   bool issparse;
   ae_int_t itscnt;
   ae_int_t nidx;
   double eps;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   NewVector(nlist, 0, DT_INT);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(za, 0, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewMatrix(halfa, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewVector(ct, 0, DT_INT);
   NewVector(b, 0, DT_REAL);
   NewVector(zb, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(xend0, 0, DT_REAL);
   NewVector(xend1, 0, DT_REAL);
   NewVector(xori, 0, DT_REAL);
   NewVector(xz, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   Ok = true;
   hqrndrandomize(&rs);
// Convex unconstrained test:
// * N dimensions
// * positive-definite A
// * algorithm randomly choose dense or sparse A, and for
//   sparse matrix it randomly choose format.
// * random B with normal entries
// * initial point is random, feasible
// * random origin (zero or non-zero) and scale (unit or
//   non-unit) are generated
   eps = 1.0E-5;
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         origintype = hqrnduniformi(&rs, 2);
         scaletype = hqrnduniformi(&rs, 2);
         isupper = hqrnduniformr(&rs) < 0.5;
         issparse = hqrnduniformr(&rs) < 0.5;
         spdmatrixrndcond(n, 1.0E3, &fulla);
         ae_matrix_set_length(&halfa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j >= i: j <= i) {
                  halfa.xyR[i][j] = fulla.xyR[i][j];
               } else {
                  halfa.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         }
         testminqpunit_densetosparse(&halfa, n, &sa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xori, n);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            x0.xR[i] = hqrndnormal(&rs);
            if (origintype == 0) {
               xori.xR[i] = 0.0;
            } else {
               xori.xR[i] = hqrndnormal(&rs);
            }
            if (scaletype == 0) {
               s.xR[i] = 1.0;
            } else {
               s.xR[i] = exp(0.5 * hqrndnormal(&rs));
            }
         }
      // Solve problem
         minqpcreate(n, &state);
         minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 0, hqrnduniformr(&rs) > 0.5);
         minqpsetlinearterm(&state, &b);
         if (issparse) {
            minqpsetquadratictermsparse(&state, &sa, isupper);
         } else {
            minqpsetquadraticterm(&state, &halfa, isupper);
         }
         if (origintype != 0) {
            minqpsetorigin(&state, &xori);
         }
         if (scaletype != 0) {
            minqpsetscale(&state, &s);
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return Ok;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            g = b.xR[i];
            for (j = 0; j < n; j++) {
               g += fulla.xyR[i][j] * (x1.xR[j] - xori.xR[j]);
            }
            gnorm += sqr(g);
         }
         gnorm = sqrt(gnorm);
         Ok = Ok && gnorm <= eps;
      }
   }
// Convex test:
// * N dimensions
// * random number (0..N) of random boundary constraints
// * positive-definite A
// * algorithm randomly choose dense or sparse A, and for
//   sparse matrix it randomly choose format.
// * random B with normal entries
// * initial point is random, feasible
// * random origin (zero or non-zero) and scale (unit or
//   non-unit) are generated
   eps = 1.0E-5;
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         origintype = hqrnduniformi(&rs, 2);
         scaletype = hqrnduniformi(&rs, 2);
         isupper = hqrnduniformr(&rs) < 0.5;
         issparse = hqrnduniformr(&rs) < 0.5;
         spdmatrixrndcond(n, 1.0E3, &fulla);
         ae_matrix_set_length(&halfa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j >= i: j <= i) {
                  halfa.xyR[i][j] = fulla.xyR[i][j];
               } else {
                  halfa.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         }
         testminqpunit_densetosparse(&halfa, n, &sa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xori, n);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = -INFINITY;
            bndu.xR[i] = +INFINITY;
            x0.xR[i] = hqrndnormal(&rs);
            if (origintype == 0) {
               xori.xR[i] = 0.0;
            } else {
               xori.xR[i] = hqrndnormal(&rs);
            }
            if (scaletype == 0) {
               s.xR[i] = 1.0;
            } else {
               s.xR[i] = exp(0.5 * hqrndnormal(&rs));
            }
            j = hqrnduniformi(&rs, 5);
            if (j == 0) {
               bndl.xR[i] = 0.0;
               x0.xR[i] = fabs(x0.xR[i]);
            }
            if (j == 1) {
               bndu.xR[i] = 0.0;
               x0.xR[i] = -fabs(x0.xR[i]);
            }
            if (j == 2) {
               bndl.xR[i] = hqrndnormal(&rs);
               bndu.xR[i] = bndl.xR[i];
               x0.xR[i] = bndl.xR[i];
            }
            if (j == 3) {
               bndl.xR[i] = -0.1;
               bndu.xR[i] = 0.1;
               x0.xR[i] = 0.1 * hqrndmiduniformr(&rs);
            }
         }
      // Solve problem
         minqpcreate(n, &state);
         minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 0, hqrnduniformr(&rs) > 0.5);
         minqpsetlinearterm(&state, &b);
         if (issparse) {
            minqpsetquadratictermsparse(&state, &sa, isupper);
         } else {
            minqpsetquadraticterm(&state, &halfa, isupper);
         }
         if (origintype != 0) {
            minqpsetorigin(&state, &xori);
         }
         if (scaletype != 0) {
            minqpsetscale(&state, &s);
         }
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return Ok;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            g = b.xR[i];
            for (j = 0; j < n; j++) {
               g += fulla.xyR[i][j] * (x1.xR[j] - xori.xR[j]);
            }
            if (x1.xR[i] == bndl.xR[i] && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] == bndu.xR[i] && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            Ok = Ok && x1.xR[i] >= bndl.xR[i];
            Ok = Ok && x1.xR[i] <= bndu.xR[i];
         }
         gnorm = sqrt(gnorm);
         Ok = Ok && gnorm <= eps;
      }
   }
// Strongly non-convex test:
// * N dimensions, N >= 2
// * box constraints, x[i] in [-1,+1]
// * A = A0-0.5*I, where A0 is SPD with unit norm and smallest
//   singular value equal to 1.0E-3, I is identity matrix
// * random B with normal entries
// * initial point is random, feasible
//
// We perform two tests:
// * unconstrained problem must be recognized as unbounded
// * constrained problem can be successfully solved
//
// NOTE: it is important to have N >= 2, because formula for A
//       can be applied only to matrix with at least two
//       singular values
   eps = 1.0E-5;
   for (n = 2; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         spdmatrixrndcond(n, 1.0E3, &fulla);
         for (i = 0; i < n; i++) {
            fulla.xyR[i][i] -= 0.5;
         }
         isupper = hqrnduniformr(&rs) < 0.5;
         ae_matrix_set_length(&halfa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j >= i: j <= i) {
                  halfa.xyR[i][j] = fulla.xyR[i][j];
               } else {
                  halfa.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         }
         testminqpunit_densetosparse(&halfa, n, &sa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = -1.0;
            bndu.xR[i] = +1.0;
            x0.xR[i] = hqrndmiduniformr(&rs);
         }
      // Solve problem:
      // * without constraints we expect failure
      // * with constraints algorithm must succeed
         minqpcreate(n, &state);
         minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 0, hqrnduniformr(&rs) > 0.5);
         minqpsetlinearterm(&state, &b);
         if (hqrndnormal(&rs) > 0.0) {
            minqpsetquadraticterm(&state, &halfa, isupper);
         } else {
            minqpsetquadratictermsparse(&state, &sa, isupper);
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype == -4;
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return Ok;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(fulla.xyR[i], 1, x1.xR, 1, n);
            g = v + b.xR[i];
            if (x1.xR[i] == bndl.xR[i] && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] == bndu.xR[i] && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            Ok = Ok && x1.xR[i] >= bndl.xR[i];
            Ok = Ok && x1.xR[i] <= bndu.xR[i];
         }
         gnorm = sqrt(gnorm);
         Ok = Ok && gnorm <= eps;
      }
   }
// Basic semi-definite test:
// * N dimensions, N >= 2
// * box constraints, x[i] in [-1,+1]
//       [ 1 1 ... 1 1 ]
// * A = [ ... ... ... ], with one (random) diagonal entry set to -1
//       [ 1 1 ... 1 1 ]
// * random B with normal entries
// * initial point is random, feasible
//
// We perform two tests:
// * unconstrained problem must be recognized as unbounded
// * constrained problem must be recognized as bounded and
//   successfully solved
//
// Both problems require subtle programming when we work
// with semidefinite QP.
//
// NOTE: unlike BLEIC-QP algorthm, QQP may detect unboundedness
//       of the problem when started from any x0, with any b.
//       BLEIC-based solver requires carefully chosen x0 and b
//       to find direction of zero curvature, but this solver
//       can find it from any point.
   ae_vector_set_length(&nlist, 12);
   nlist.xZ[0] = 2;
   nlist.xZ[1] = 3;
   nlist.xZ[2] = 4;
   nlist.xZ[3] = 5;
   nlist.xZ[4] = 6;
   nlist.xZ[5] = 7;
   nlist.xZ[6] = 8;
   nlist.xZ[7] = 9;
   nlist.xZ[8] = 10;
   nlist.xZ[9] = 20;
   nlist.xZ[10] = 40;
   nlist.xZ[11] = 80;
   eps = 1.0E-5;
   for (nidx = 0; nidx < nlist.cnt; nidx++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         n = nlist.xZ[nidx];
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            do {
               b.xR[i] = hqrndnormal(&rs);
            } while (b.xR[i] == 0.0);
            bndl.xR[i] = -1.0;
            bndu.xR[i] = +1.0;
            x0.xR[i] = hqrndmiduniformr(&rs);
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 1.0;
            }
         }
         j = hqrnduniformi(&rs, n);
         a.xyR[j][j] = -1.0;
         testminqpunit_densetosparse(&a, n, &sa);
      // Solve problem:
      // * without constraints we expect failure
      // * with constraints algorithm must succeed
         minqpcreate(n, &state);
         minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 0, hqrnduniformr(&rs) > 0.5);
         minqpsetlinearterm(&state, &b);
         if (hqrndnormal(&rs) > 0.0) {
            minqpsetquadraticterm(&state, &a, true);
         } else {
            minqpsetquadratictermsparse(&state, &sa, true);
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype == -4;
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return Ok;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            g = b.xR[i];
            for (j = 0; j < n; j++) {
               g += a.xyR[i][j] * x1.xR[j];
            }
            if (x1.xR[i] == bndl.xR[i] && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] == bndu.xR[i] && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            Ok = Ok && x1.xR[i] >= bndl.xR[i];
            Ok = Ok && x1.xR[i] <= bndu.xR[i];
         }
         gnorm = sqrt(gnorm);
         Ok = Ok && gnorm <= eps;
      }
   }
// Linear (zero-quadratic) test:
// * N dimensions, N >= 1
// * box constraints, x[i] in [-1,+1]
// * A = 0
// * random B with normal entries
// * initial point is random, feasible
//
// We perform two tests:
// * unconstrained problem must be recognized as unbounded
// * constrained problem can be successfully solved
//
// NOTE: we may explicitly set zero A, or assume that by
//       default it is zero. During test we will try both
//       ways.
   eps = 1.0E-5;
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            do {
               b.xR[i] = hqrndnormal(&rs);
            } while (b.xR[i] == 0.0);
            bndl.xR[i] = -1.0;
            bndu.xR[i] = +1.0;
            x0.xR[i] = hqrndmiduniformr(&rs);
         }
      // Solve problem:
      // * without constraints we expect failure
      // * with constraints algorithm must succeed
         minqpcreate(n, &state);
         minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 0, hqrnduniformr(&rs) > 0.5);
         minqpsetlinearterm(&state, &b);
         if (hqrndnormal(&rs) > 0.0) {
            ae_matrix_set_length(&a, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
            }
            minqpsetquadraticterm(&state, &a, true);
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype == -4;
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return Ok;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         for (i = 0; i < n; i++) {
            Ok = Ok && (b.xR[i] <= 0.0 || x1.xR[i] <= bndl.xR[i]);
            Ok = Ok && (b.xR[i] >= 0.0 || x1.xR[i] >= bndu.xR[i]);
         }
      }
   }
// Test for Newton phase of QQP algorithm - we test that Newton
// phase can find good solution within one step. In order to do
// so we:
// * solve convex QP problem (dense or sparse)
// * with K <= N equality-only constraints ai == x == bi
// * with number of outer iterations limited to just 1
// * and with CG phase turned off (we modify internal structures
//   of the QQP solver in order to make it)
   eps = 1.0E-5;
   for (pass = 1; pass <= 10; pass++) {
   // Generate problem
      n = 50 + hqrnduniformi(&rs, 51);
      spdmatrixrndcond(n, 1.0E3, &a);
      testminqpunit_densetosparse(&a, n, &sa);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         b.xR[i] = hqrndnormal(&rs);
         x0.xR[i] = hqrndnormal(&rs);
         if (hqrndnormal(&rs) > 0.0) {
            bndl.xR[i] = -INFINITY;
            bndu.xR[i] = +INFINITY;
         } else {
            bndl.xR[i] = hqrndnormal(&rs);
            bndu.xR[i] = bndl.xR[i];
         }
      }
   // Solve problem
   //
   // NOTE: we modify internal structures of QQP solver in order
   //       to deactivate CG phase
      minqpcreate(n, &state);
      minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 1, true);
      state.qqpsettingsuser.cgphase = false;
      minqpsetlinearterm(&state, &b);
      if (hqrndnormal(&rs) > 0.0) {
         minqpsetquadraticterm(&state, &a, hqrndnormal(&rs) > 0.0);
      } else {
         minqpsetquadratictermsparse(&state, &sa, hqrndnormal(&rs) > 0.0);
      }
      minqpsetbc(&state, &bndl, &bndu);
      minqpoptimize(&state);
      minqpresults(&state, &x1, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (rep.terminationtype <= 0) {
         ae_frame_leave();
         return Ok;
      }
   // Test - calculate constrained gradient at solution,
   // check its norm.
      gnorm = 0.0;
      for (i = 0; i < n; i++) {
         g = b.xR[i];
         for (j = 0; j < n; j++) {
            g += a.xyR[i][j] * x1.xR[j];
         }
         if (x1.xR[i] == bndl.xR[i] && g > 0.0) {
            g = 0.0;
         }
         if (x1.xR[i] == bndu.xR[i] && g < 0.0) {
            g = 0.0;
         }
         gnorm += sqr(g);
         Ok = Ok && x1.xR[i] >= bndl.xR[i];
         Ok = Ok && x1.xR[i] <= bndu.xR[i];
      }
      gnorm = sqrt(gnorm);
      Ok = Ok && gnorm <= eps;
   }
// Test for Newton phase of QQP algorithm - we test that Newton
// updates work correctly, i.e. that CNewtonUpdate() internal
// function correctly updates inverse Hessian matrix.
//
// To test it we:
// * solve ill conditioned convex QP problem
// * with unconstrained solution XZ whose components are within [-0.5,+0.5]
// * with one inequality constraint X[k] >= 5
// * with initial point such that:
//   * X0[i] = 100       for i != k
//   * X0[k] = 5+1.0E-5
// * with number of outer iterations limited to just 1
// * and with CG phase turned off (we modify internal structures
//   of the QQP solver in order to make it)
//
// The idea is that single Newton step is not enough to find solution,
// but with just one update we can move exactly to the solution.
//
// We perform two tests:
// * first one with State.QQP.NewtMaxIts set to 1, in order to
//   make sure that algorithm fails with just one iteration
// * second one with State.QQP.NewtMaxIts set to 2, in order to
//   make sure that algorithm converges when it can perform update
   eps = 1.0E-5;
   for (pass = 1; pass <= 10; pass++) {
   // Generate problem
      n = 20 + hqrnduniformi(&rs, 20);
      spdmatrixrndcond(n, 1.0E5, &a);
      testminqpunit_densetosparse(&a, n, &sa);
      sparseconverttocrs(&sa);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&xz, n);
      for (i = 0; i < n; i++) {
         xz.xR[i] = hqrnduniformr(&rs) - 0.5;
         x0.xR[i] = 100.0;
         bndl.xR[i] = -INFINITY;
         bndu.xR[i] = +INFINITY;
      }
      k = hqrnduniformi(&rs, n);
      x0.xR[k] = 5.00001;
      bndl.xR[k] = 5.0;
      sparsemv(&sa, &xz, &b);
      for (i = 0; i < n; i++) {
         b.xR[i] = -b.xR[i];
      }
   // Create solver
      minqpcreate(n, &state);
      minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 1, true);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, hqrndnormal(&rs) > 0.0);
      minqpsetbc(&state, &bndl, &bndu);
      minqpsetstartingpoint(&state, &x0);
   // Solve problem. First time, with no Newton updates.
   // It must fail.
   //
   // NOTE: we modify internal structures of QQP solver in order
   //       to deactivate CG phase and turn off Newton updates.
      state.qqpsettingsuser.cgphase = false;
      state.qqpsettingsuser.cnphase = true;
      state.qqpsettingsuser.cnmaxupdates = 0;
      minqpoptimize(&state);
      minqpresults(&state, &x1, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      Ok = Ok && !testminqpunit_testbcgradandfeasibility(&a, &b, &bndl, &bndu, n, &x1, eps);
   // Now with Newton updates - it must succeeed.
      state.qqpsettingsuser.cgphase = false;
      state.qqpsettingsuser.cnmaxupdates = n;
      minqpoptimize(&state);
      minqpresults(&state, &x1, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      Ok = Ok && testminqpunit_testbcgradandfeasibility(&a, &b, &bndl, &bndu, n, &x1, eps);
   }
// Check that problem with general constraints results in
// correct error code (-5 should be returned).
   ae_matrix_set_length(&c, 1, 3);
   ae_vector_set_length(&ct, 1);
   c.xyR[0][0] = 1.0;
   c.xyR[0][1] = 1.0;
   c.xyR[0][2] = 2.0;
   ct.xZ[0] = 0;
   minqpcreate(2, &state);
   minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 0, hqrnduniformr(&rs) > 0.5);
   minqpsetlc(&state, &c, &ct, 1);
   minqpoptimize(&state);
   minqpresults(&state, &x1, &rep);
   Ok = Ok && rep.terminationtype == -5;
// Test sparse functionality. QQP solver must perform
// same steps independently of matrix type (dense or sparse).
//
// We generate random unconstrained test problem and solve it
// twice - first time we solve dense version, second time -
// sparse version is solved.
//
// During this test we:
// * use stringent stopping criteria (one outer iteration)
// * turn off Newton phase of the algorithm to slow down
//   convergence
   eps = 1.0E-3;
   itscnt = 1;
   n = 20;
   isupper = randombool();
   spdmatrixrndcond(n, 1.0E3, &za);
   sparsecreate(n, n, 0, &sa);
   ae_matrix_set_length(&a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (j >= i && isupper) {
            sparseset(&sa, i, j, za.xyR[i][j]);
            a.xyR[i][j] = za.xyR[i][j];
         }
         if (j <= i && !isupper) {
            sparseset(&sa, i, j, za.xyR[i][j]);
            a.xyR[i][j] = za.xyR[i][j];
         }
      }
   }
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&s, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = randomnormal();
      s.xR[i] = pow(10.0, randomnormal() / 10);
   }
   minqpcreate(n, &state);
   minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, itscnt, false);
   minqpsetscale(&state, &s);
   minqpsetlinearterm(&state, &b);
   minqpsetquadraticterm(&state, &a, isupper);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   minqpcreate(n, &state);
   minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, itscnt, false);
   minqpsetscale(&state, &s);
   minqpsetlinearterm(&state, &b);
   minqpsetquadratictermsparse(&state, &sa, isupper);
   minqpoptimize(&state);
   minqpresults(&state, &xend1, &rep);
   for (i = 0; i < n; i++) {
      Ok = Ok && NearAtR(xend0.xR[i], xend1.xR[i], eps);
   }
// Test scale-invariance. QQP performs same steps on scaled and
// unscaled problems (assuming that scale of the variables is known).
//
// We generate random scale matrix S and random well-conditioned and
// well scaled matrix A. Then we solve two problems:
//
//     (1) f = 0.5*x'*A*x+b'*x
//         (identity scale matrix is used)
//
// and
//
//     (2) f = 0.5*y'*(inv(S)*A*inv(S))*y + (inv(S)*b)'*y
//         (scale matrix S is used)
//
// Solution process is started from X == 0, we perform ItsCnt == 1 outer
// iterations with Newton phase turned off (to slow down convergence;
// we want to prevent algorithm from converging to exact solution which
// is exactly same for both problems; the idea is to test that same
// intermediate tests are taken).
//
// As result, we must get S*x == y
   eps = 1.0E-3;
   itscnt = 1;
   n = 100;
   ae_vector_set_length(&s, n);
   for (i = 0; i < n; i++) {
      s.xR[i] = pow(10.0, randomnormal() / 10);
   }
   spdmatrixrndcond(n, 1.0E3, &a);
   ae_matrix_set_length(&za, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         za.xyR[i][j] = a.xyR[i][j] / (s.xR[i] * s.xR[j]);
      }
   }
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&zb, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = randomnormal();
      zb.xR[i] = b.xR[i] / s.xR[i];
   }
   minqpcreate(n, &state);
   minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, itscnt, false);
   minqpsetlinearterm(&state, &b);
   minqpsetquadraticterm(&state, &a, true);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   minqpcreate(n, &state);
   minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, itscnt, false);
   minqpsetlinearterm(&state, &zb);
   minqpsetquadraticterm(&state, &za, true);
   minqpsetscale(&state, &s);
   minqpoptimize(&state);
   minqpresults(&state, &xend1, &rep);
   for (i = 0; i < n; i++) {
      Ok = Ok && NearAtR(s.xR[i] * xend0.xR[i], xend1.xR[i], eps);
   }
// Test that QQP can efficiently use sparse matrices (i.e. it is
// not disguised version of some dense QP solver). In order to test
// it we create very large and very sparse problem (diagonal matrix
// with N == 40.000) and perform 10 iterations of QQP solver.
//
// In case QP solver uses some form of dense linear algebra to solve
// this problem, it will take TOO much time to solve it. And we will
// notice it by EXTREME slowdown during testing.
   n = 40000;
   sparsecreate(n, n, 0, &sa);
   for (i = 0; i < n; i++) {
      sparseset(&sa, i, i, pow(10.0, -3 * randomreal()));
   }
   ae_vector_set_length(&b, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = randomnormal();
   }
   minqpcreate(n, &state);
   minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 10, hqrnduniformr(&rs) > 0.5);
   minqpsetlinearterm(&state, &b);
   minqpsetquadratictermsparse(&state, &sa, true);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   ae_frame_leave();
   return Ok;
}

// This function performs tests specific for BLEIC solver
static bool bleictests() {
   ae_frame _frame_block;
   ae_int_t nidx;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   double eps;
   double v;
   double g;
   double gnorm;
   ae_int_t itscnt;
   bool isupper;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   NewVector(nlist, 0, DT_INT);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(za, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(zb, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(sparsematrix, sa);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   NewVector(xend0, 0, DT_REAL);
   NewVector(xend1, 0, DT_REAL);
   Ok = true;
   hqrndrandomize(&rs);
// Test sparse functionality. BLEIC-based solver must perform
// same steps independently of matrix type (dense or sparse).
//
// We generate random unconstrained test problem and solve it
// twice - first time we solve dense version, second time -
// sparse version is solved.
   eps = 1.0E-3;
   itscnt = 5;
   n = 20;
   isupper = randombool();
   spdmatrixrndcond(n, 1.0E3, &za);
   sparsecreate(n, n, 0, &sa);
   ae_matrix_set_length(&a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (j >= i && isupper) {
            sparseset(&sa, i, j, za.xyR[i][j]);
            a.xyR[i][j] = za.xyR[i][j];
         }
         if (j <= i && !isupper) {
            sparseset(&sa, i, j, za.xyR[i][j]);
            a.xyR[i][j] = za.xyR[i][j];
         }
      }
   }
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&s, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = randomnormal();
      s.xR[i] = pow(10.0, randomnormal() / 10);
   }
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, 0.0, 0.0, 0.0, itscnt);
   minqpsetlinearterm(&state, &b);
   minqpsetquadraticterm(&state, &a, isupper);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, 0.0, 0.0, 0.0, itscnt);
   minqpsetlinearterm(&state, &b);
   minqpsetquadratictermsparse(&state, &sa, isupper);
   minqpoptimize(&state);
   minqpresults(&state, &xend1, &rep);
   for (i = 0; i < n; i++) {
      Ok = Ok && NearAtR(xend0.xR[i], xend1.xR[i], eps);
   }
// Test scale-invariance. BLEIC performs same steps on scaled and
// unscaled problems (assuming that scale of the variables is known).
//
// We generate random scale matrix S and random well-conditioned and
// well scaled matrix A. Then we solve two problems:
//
//     (1) f = 0.5*x'*A*x+b'*x
//         (identity scale matrix is used)
//
// and
//
//     (2) f = 0.5*y'*(inv(S)*A*inv(S))*y + (inv(S)*b)'*y
//         (scale matrix S is used)
//
// Solution process is started from X == 0, we perform ItsCnt == 5 steps.
// As result, we must get S*x == y
   eps = 1.0E-3;
   itscnt = 5;
   n = 20;
   ae_vector_set_length(&s, n);
   for (i = 0; i < n; i++) {
      s.xR[i] = pow(10.0, randomnormal() / 10);
   }
   spdmatrixrndcond(n, 1.0E3, &a);
   ae_matrix_set_length(&za, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         za.xyR[i][j] = a.xyR[i][j] / (s.xR[i] * s.xR[j]);
      }
   }
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&zb, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = randomnormal();
      zb.xR[i] = b.xR[i] / s.xR[i];
   }
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, 0.0, 0.0, 0.0, itscnt);
   minqpsetlinearterm(&state, &b);
   minqpsetquadraticterm(&state, &a, true);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, 0.0, 0.0, 0.0, itscnt);
   minqpsetlinearterm(&state, &zb);
   minqpsetquadraticterm(&state, &za, true);
   minqpsetscale(&state, &s);
   minqpoptimize(&state);
   minqpresults(&state, &xend1, &rep);
   for (i = 0; i < n; i++) {
      Ok = Ok && NearAtR(s.xR[i] * xend0.xR[i], xend1.xR[i], eps);
   }
// Test that BLEIC can efficiently use sparse matrices (i.e. it is
// not disguised version of some dense QP solver). In order to test
// it we create very large and very sparse problem (diagonal matrix
// with N == 20.000) and perform 10 iterations of BLEIC-based QP solver.
//
// In case QP solver uses some form of dense linear algebra to solve
// this problem, it will take TOO much time to solve it. And we will
// notice it by EXTREME slowdown during testing.
   n = 20000;
   sparsecreate(n, n, 0, &sa);
   for (i = 0; i < n; i++) {
      sparseset(&sa, i, i, pow(10.0, -3 * randomreal()));
   }
   ae_vector_set_length(&b, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = randomnormal();
   }
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, 0.0, 0.0, 0.0, 10);
   minqpsetlinearterm(&state, &b);
   minqpsetquadratictermsparse(&state, &sa, true);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
// Special semi-definite test:
// * N dimensions, N >= 2 (important!)
// * box constraints, x[i] in [-1,+1]
//       [ 1 1 ... 1 1 ]
// * A = [ ... ... ... ]
//       [ 1 1 ... 1 1 ]
// * random B such that SUM(b[i]) == 0.0 (important!)
// * initial point x0 is chosen in such way that SUM(x[i]) == 0.0
//   (important!)
//
// We perform two tests:
// * unconstrained problem must be recognized as unbounded
//   (when starting from x0!)
// * constrained problem must be recognized as bounded
//   and successfully solved
//
// Both problems require subtle programming when we work
// with semidefinite QP.
//
// NOTE: it is very important to have N >= 2 (otherwise problem
//       will be bounded from below even without boundary
//       constraints) and to have x0/b0 such that sum of
//       components is zero (such x0 is exact minimum of x'*A*x,
//       which allows algorithm to find direction of zero curvature
//       at the very first step). If x0/b are chosen in other way,
//       algorithm may be unable to find direction of zero
//       curvature and will cycle forever, slowly decreasing
//       function value at each iteration.
//       This is major difference from similar test for QQP solver -
//       QQP can find direction of zero curvature from almost any
//       point due to internal CG solver which favors such directions.
//       BLEIC uses LBFGS, which is less able to find direction of
//       zero curvature.
   ae_vector_set_length(&nlist, 12);
   nlist.xZ[0] = 2;
   nlist.xZ[1] = 3;
   nlist.xZ[2] = 4;
   nlist.xZ[3] = 5;
   nlist.xZ[4] = 6;
   nlist.xZ[5] = 7;
   nlist.xZ[6] = 8;
   nlist.xZ[7] = 9;
   nlist.xZ[8] = 10;
   nlist.xZ[9] = 20;
   nlist.xZ[10] = 40;
   nlist.xZ[11] = 80;
   eps = 1.0E-5;
   for (nidx = 0; nidx < nlist.cnt; nidx++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         n = nlist.xZ[nidx];
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            do {
               b.xR[i] = hqrndnormal(&rs);
            } while (b.xR[i] == 0.0);
            bndl.xR[i] = -1.0;
            bndu.xR[i] = +1.0;
            x0.xR[i] = hqrndmiduniformr(&rs);
         }
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += x0.xR[i];
         }
         for (i = 0; i < n; i++) {
            x0.xR[i] -= v / n;
         }
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += b.xR[i];
         }
         for (i = 0; i < n; i++) {
            b.xR[i] -= v / n;
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 1.0;
            }
         }
         testminqpunit_densetosparse(&a, n, &sa);
      // Solve problem:
      // * without constraints we expect failure
      // * with constraints algorithm must succeed
         minqpcreate(n, &state);
         minqpsetalgobleic(&state, 0.0, 0.0, 0.0, 0);
         minqpsetlinearterm(&state, &b);
         minqpsetstartingpoint(&state, &x0);
         if (hqrndnormal(&rs) > 0.0) {
            minqpsetquadraticterm(&state, &a, true);
         } else {
            minqpsetquadratictermsparse(&state, &sa, true);
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype == -4;
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return Ok;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            g = b.xR[i];
            for (j = 0; j < n; j++) {
               g += a.xyR[i][j] * x1.xR[j];
            }
            if (x1.xR[i] == bndl.xR[i] && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] == bndu.xR[i] && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            Ok = Ok && x1.xR[i] >= bndl.xR[i];
            Ok = Ok && x1.xR[i] <= bndu.xR[i];
         }
         gnorm = sqrt(gnorm);
         Ok = Ok && gnorm <= eps;
      }
   }
// Test that BLEIC-based QP solver can solve non-convex problems
// which are bounded from below on the feasible set:
//
//     min -||x||^2 s.t. x[i] in [-1,+1]
//
// We also test ability of the solver to detect unbounded problems
// (we remove one of the constraints and repeat solution process).
   n = 20;
   eps = 1.0E-14;
   sparsecreate(n, n, 0, &sa);
   for (i = 0; i < n; i++) {
      sparseset(&sa, i, i, -1.0);
   }
   ae_vector_set_length(&bndl, n);
   ae_vector_set_length(&bndu, n);
   ae_vector_set_length(&x, n);
   for (i = 0; i < n; i++) {
      bndl.xR[i] = -1.0;
      bndu.xR[i] = 1.0;
      x.xR[i] = randomreal() - 0.5;
   }
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, eps, 0.0, 0.0, 0);
   minqpsetquadratictermsparse(&state, &sa, true);
   minqpsetbc(&state, &bndl, &bndu);
   minqpsetstartingpoint(&state, &x);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   Ok = Ok && rep.terminationtype > 0;
   if (rep.terminationtype > 0) {
      for (i = 0; i < n; i++) {
         Ok = Ok && (xend0.xR[i] == -1.0 || xend0.xR[i] == 1.0);
      }
   }
   i = randominteger(n);
   bndl.xR[i] = -INFINITY;
   bndu.xR[i] = +INFINITY;
   minqpsetbc(&state, &bndl, &bndu);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   Ok = Ok && rep.terminationtype == -4;
// Test that BLEIC-based QP solver can solve non-convex problems
// which are bounded from below on the feasible set:
//
//     min -||x||^2 s.t. x[i] in [-1,+1],
//     with inequality constraints handled as general linear ones
//
// We also test ability of the solver to detect unbounded problems
// (we remove last pair of constraints and try to solve modified
// problem).
   n = 20;
   eps = 1.0E-14;
   sparsecreate(n, n, 0, &sa);
   for (i = 0; i < n; i++) {
      sparseset(&sa, i, i, -1.0);
   }
   ae_matrix_set_length(&c, 2 * n, n + 1);
   ae_vector_set_length(&ct, 2 * n);
   for (i = 0; i < n; i++) {
      for (j = 0; j <= n; j++) {
         c.xyR[2 * i][j] = 0.0;
         c.xyR[2 * i + 1][j] = 0.0;
      }
      c.xyR[2 * i][i] = 1.0;
      c.xyR[2 * i][n] = 1.0;
      ct.xZ[2 * i] = -1;
      c.xyR[2 * i + 1][i] = 1.0;
      c.xyR[2 * i + 1][n] = -1.0;
      ct.xZ[2 * i + 1] = 1;
   }
   ae_vector_set_length(&x, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = randomreal() - 0.5;
   }
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, eps, 0.0, 0.0, 0);
   minqpsetquadratictermsparse(&state, &sa, true);
   minqpsetlc(&state, &c, &ct, 2 * n);
   minqpsetstartingpoint(&state, &x);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   Ok = Ok && rep.terminationtype > 0;
   if (rep.terminationtype > 0) {
      for (i = 0; i < n; i++) {
         Ok = Ok && (NearAtR(xend0.xR[i], -1.0, 100.0 * machineepsilon) || NearAtR(xend0.xR[i], 1.0, 100.0 * machineepsilon));
      }
   }
   minqpsetlc(&state, &c, &ct, 2 * (n - 1));
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   Ok = Ok && rep.terminationtype == -4;
// Test that BLEIC-based QP solver can solve QP problems with
// zero quadratic term:
//
//     min b'*x  s.t. x[i] in [-1,+1]
//
// It means that QP solver can be used as linear programming solver
// (altough performance of such solver is worse than that of specialized
// LP solver).
//
// NOTE: we perform this test twice - first time without explicitly setting
//       quadratic term (we test that default quadratic term is zero), and
//       second time - with explicitly set quadratic term.
   n = 20;
   sparsecreate(n, n, 0, &sa);
   ae_vector_set_length(&bndl, n);
   ae_vector_set_length(&bndu, n);
   ae_vector_set_length(&b, n);
   for (i = 0; i < n; i++) {
      bndl.xR[i] = -1.0;
      bndu.xR[i] = 1.0;
      b.xR[i] = randomnormal();
   }
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, eps, 0.0, 0.0, 0);
   minqpsetlinearterm(&state, &b);
   minqpsetbc(&state, &bndl, &bndu);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   Ok = Ok && rep.terminationtype > 0;
   if (rep.terminationtype > 0) {
      for (i = 0; i < n; i++) {
         Ok = Ok && (b.xR[i] <= 0.0 || xend0.xR[i] == bndl.xR[i]);
         Ok = Ok && (b.xR[i] >= 0.0 || xend0.xR[i] == bndu.xR[i]);
      }
   }
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, eps, 0.0, 0.0, 0);
   minqpsetlinearterm(&state, &b);
   minqpsetbc(&state, &bndl, &bndu);
   minqpsetquadratictermsparse(&state, &sa, true);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   Ok = Ok && rep.terminationtype > 0;
   if (rep.terminationtype > 0) {
      for (i = 0; i < n; i++) {
         Ok = Ok && (b.xR[i] <= 0.0 || xend0.xR[i] == bndl.xR[i]);
         Ok = Ok && (b.xR[i] >= 0.0 || xend0.xR[i] == bndu.xR[i]);
      }
   }
// Test specific problem sent by V.Semenenko, which resulted in
// the initinite loop in FindFeasiblePoint (before fix). We do
// not test results returned by solver - simply being able to
// stop is enough for this test.
//
// NOTE: it is important that modifications to problem are applied
//       sequentially. Test fails after 100-5000 such modifications.
//       One modification is not enough to cause failure.
   n = 3;
   ae_matrix_set_length(&a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a.xyR[i][j] = 0.0;
      }
   }
   a.xyR[0][0] = 1.222990;
   a.xyR[1][1] = 1.934900;
   a.xyR[2][2] = 0.603924;
   ae_vector_set_length(&b, n);
   b.xR[0] = -4.97245;
   b.xR[1] = -9.09039;
   b.xR[2] = -4.63856;
   ae_matrix_set_length(&c, 8, n + 1);
   for (i = 0; i < c.rows; i++) {
      for (j = 0; j < n; j++) {
         c.xyR[i][j] = 0.0;
      }
   }
   c.xyR[0][0] = 1.0;
   c.xyR[0][n] = 4.94298;
   c.xyR[1][0] = 1.0;
   c.xyR[1][n] = 4.79981;
   c.xyR[2][1] = 1.0;
   c.xyR[2][n] = -0.4848;
   c.xyR[3][1] = 1.0;
   c.xyR[3][n] = -0.73804;
   c.xyR[4][2] = 1.0;
   c.xyR[4][n] = 0.575729;
   c.xyR[5][2] = 1.0;
   c.xyR[5][n] = 0.458645;
   c.xyR[6][0] = 1.0;
   c.xyR[6][2] = -1.0;
   c.xyR[6][n] = -0.0546574;
   c.xyR[7][0] = 1.0;
   c.xyR[7][2] = -1.0;
   c.xyR[7][n] = -0.5900440;
   ae_vector_set_length(&ct, 8);
   ct.xZ[0] = -1;
   ct.xZ[1] = 1;
   ct.xZ[2] = -1;
   ct.xZ[3] = 1;
   ct.xZ[4] = -1;
   ct.xZ[5] = 1;
   ct.xZ[6] = -1;
   ct.xZ[7] = 1;
   ae_vector_set_length(&s, n);
   s.xR[0] = 0.143171;
   s.xR[1] = 0.253240;
   s.xR[2] = 0.117084;
   ae_vector_set_length(&x0, n);
   x0.xR[0] = 3.51126;
   x0.xR[1] = 4.05731;
   x0.xR[2] = 6.63307;
   for (pass = 1; pass <= 10000; pass++) {
   // Apply random distortion
      for (j = 0; j < n; j++) {
         b.xR[j] += (2 * hqrnduniformi(&rs, 2) - 1) * 0.1;
      }
      for (j = 0; j < 6; j++) {
         c.xyR[j][n] += (2 * hqrnduniformi(&rs, 2) - 1) * 0.1;
      }
   // Solve
      minqpcreate(3, &state);
      minqpsetquadraticterm(&state, &a, true);
      minqpsetlinearterm(&state, &b);
      minqpsetlc(&state, &c, &ct, 8);
      minqpsetalgobleic(&state, 0.0, 0.0, 0.0, 0);
      minqpsetstartingpoint(&state, &x0);
      minqpoptimize(&state);
      minqpresults(&state, &x1, &rep);
   }
   ae_frame_leave();
   return Ok;
}

// set random type of the QP solver.
// All "modern" solvers can be chosen.
//
// Outputs:
//     BCTol   -   expected precision of box  constraints  handling  assuming
//                 unit scale of variables.
//     LCTol   -   expected precinion of linear constraints handling assuming
//                 unit scale of variables.
//
// Result:
//     Solver type:
//     *-1 for QuickQP
//     * 0 for BLEIC-QP
//     * 1 for DENSE-AUL
//     * 2 for DENSE-IPM
//     * 3 for SPARSE-IPM
//
// BCTol and LCTol have following meaning - if some constraint is active,  it
// means that we should be at most TOL units away from boundary. It is possible
// that zero value is returned.
//
// From definition it follows that if we stopped at more than TOL  units away
// from the boundary, gradient in corresponding direction is nearly zero.
static ae_int_t testminqpunit_setrandomalgoallmodern(minqpstate *s, double *bctol, double *lctol) {
   ae_int_t result;
   *bctol = 0;
   *lctol = 0;
   result = randominteger(5) - 1;
   if (result == -1) {
      minqpsetalgoquickqp(s, 1.0E-12, 0.0, 0.0, 0, randombool());
      *bctol = 0.0;
      *lctol = 0.0;
   }
   if (result == 0) {
      minqpsetalgobleic(s, 1.0E-12, 0.0, 0.0, 0);
      *bctol = 0.0;
      *lctol = 1.0E-8;
   }
   if (result == 1) {
      minqpsetalgodenseaul(s, 1.0E-12, 1000.0, 10);
      *bctol = 1.0E-3;
      *lctol = 1.0E-3;
   }
   if (result == 2) {
      minqpsetalgodenseipm(s, 1.0E-12);
      *bctol = 1.0E-3;
      *lctol = 1.0E-3;
   }
   if (result == 3) {
      minqpsetalgosparseipm(s, 1.0E-12);
      *bctol = 1.0E-3;
      *lctol = 1.0E-3;
   }
   return result;
}

// set random type of theQP solver
static void testminqpunit_setrandomalgononconvex(minqpstate *s) {
   ae_int_t i;
   i = 1 + randominteger(2);
   if (i == 1) {
      minqpsetalgobleic(s, 1.0E-12, 0.0, 0.0, 0);
   }
   if (i == 2) {
      minqpsetalgoquickqp(s, 1.0E-12, 0.0, 0.0, 0, randombool());
   }
}

// set random type of theQP solver
static void testminqpunit_setrandomalgosemidefinite(minqpstate *s, double *bctol, double *lctol) {
   ae_int_t i;
   *bctol = 0;
   *lctol = 0;
   i = 1 + randominteger(4);
   if (i == 1) {
      minqpsetalgobleic(s, 1.0E-12, 0.0, 0.0, 0);
      *bctol = 0.0;
      *lctol = 1.0E-8;
   }
   if (i == 2) {
      minqpsetalgoquickqp(s, 1.0E-12, 0.0, 0.0, 0, randombool());
      *bctol = 0.0;
      *lctol = 0.0;
   }
   if (i == 3) {
      minqpsetalgodenseipm(s, 1.0E-12);
      *bctol = 1.0E-3;
      *lctol = 1.0E-3;
   }
   if (i == 4) {
      minqpsetalgosparseipm(s, 1.0E-12);
      *bctol = 1.0E-3;
      *lctol = 1.0E-3;
   }
}

// set random type of the QP solver,
// must support convex problems with boundary/linear constraints
static void testminqpunit_setrandomalgoconvexlc(minqpstate *s) {
   ae_int_t i;
   i = randominteger(4);
   if (i == 0) {
      minqpsetalgodenseaul(s, 1.0E-12, 10000.0, 15);
   }
   if (i == 1) {
      minqpsetalgobleic(s, 0.0, 0.0, 1.0E-12, 0);
   }
   if (i == 2) {
      minqpsetalgodenseipm(s, 1.0E-12);
   }
   if (i == 3) {
      minqpsetalgosparseipm(s, 1.0E-12);
   }
}

// set random type of the QP solver,
// must support nonconvex problems with boundary/linear constraints
static void testminqpunit_setrandomalgononconvexlc(minqpstate *s) {
   ae_int_t i;
   i = randominteger(1);
   if (i == 0) {
      minqpsetalgobleic(s, 1.0E-12, 0.0, 0.0, 0);
   }
}

// This function tests bound constrained quadratic programming algorithm.
static bool testminqpunit_bcqptest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   double v;
   double g;
   double gnorm;
   ae_int_t origintype;
   ae_int_t scaletype;
   bool isupper;
   bool issparse;
   double bctol;
   double lctol;
   double vl;
   double vu;
   double eps;
   ae_int_t solvertype;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewMatrix(halfa, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewVector(ct, 0, DT_INT);
   NewVector(b, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(gtrial, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(xori, 0, DT_REAL);
   NewVector(xz, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Convex test:
// * N dimensions
// * random number (0..N) of random boundary constraints
// * positive-definite A
// * algorithm randomly choose dense or sparse A, and for
//   sparse matrix it randomly choose format.
// * random B with normal entries
// * initial point is random, feasible
// * random origin (zero or non-zero) and scale (unit or
//   non-unit) are generated
   eps = 1.0E-3;
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         origintype = hqrnduniformi(&rs, 2);
         scaletype = hqrnduniformi(&rs, 2);
         isupper = hqrnduniformr(&rs) < 0.5;
         issparse = hqrnduniformr(&rs) < 0.5;
         spdmatrixrndcond(n, 1.0E3, &fulla);
         ae_matrix_set_length(&halfa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j >= i: j <= i) {
                  halfa.xyR[i][j] = fulla.xyR[i][j];
               } else {
                  halfa.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         }
         testminqpunit_densetosparse(&halfa, n, &sa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xori, n);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = -INFINITY;
            bndu.xR[i] = +INFINITY;
            x0.xR[i] = hqrndnormal(&rs);
            if (origintype == 0) {
               xori.xR[i] = 0.0;
            } else {
               xori.xR[i] = hqrndnormal(&rs);
            }
            if (scaletype == 0) {
               s.xR[i] = 1.0;
            } else {
               s.xR[i] = exp(0.5 * hqrndnormal(&rs));
            }
            j = hqrnduniformi(&rs, 5);
            if (j == 0) {
               bndl.xR[i] = 0.0;
               x0.xR[i] = fabs(x0.xR[i]);
            }
            if (j == 1) {
               bndu.xR[i] = 0.0;
               x0.xR[i] = -fabs(x0.xR[i]);
            }
            if (j == 2) {
               bndl.xR[i] = hqrndnormal(&rs);
               bndu.xR[i] = bndl.xR[i];
               x0.xR[i] = bndl.xR[i];
            }
            if (j == 3) {
               bndl.xR[i] = -0.1;
               bndu.xR[i] = +0.1;
               x0.xR[i] = 0.1 * hqrndmiduniformr(&rs);
            }
         }
      // Solve problem
         minqpcreate(n, &state);
         solvertype = testminqpunit_setrandomalgoallmodern(&state, &bctol, &lctol);
         minqpsetlinearterm(&state, &b);
         minqpsetstartingpoint(&state, &x0);
         if (issparse) {
            minqpsetquadratictermsparse(&state, &sa, isupper);
         } else {
            minqpsetquadraticterm(&state, &halfa, isupper);
         }
         if (origintype != 0) {
            minqpsetorigin(&state, &xori);
         }
         if (scaletype != 0) {
            minqpsetscale(&state, &s);
         }
         if (hqrndnormal(&rs) > 0.0) {
            minqpsetbc(&state, &bndl, &bndu);
         } else {
            for (i = 0; i < n; i++) {
               minqpsetbci(&state, i, bndl.xR[i], bndu.xR[i]);
            }
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && x1.cnt >= n;
         Ok = Ok && rep.lagbc.cnt >= n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            g = b.xR[i];
            for (j = 0; j < n; j++) {
               g += fulla.xyR[i][j] * (x1.xR[j] - xori.xR[j]);
            }
            if (x1.xR[i] <= bndl.xR[i] + bctol && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] >= bndu.xR[i] - bctol && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            Ok = Ok && x1.xR[i] >= bndl.xR[i];
            Ok = Ok && x1.xR[i] <= bndu.xR[i];
         }
         gnorm = sqrt(gnorm);
         Ok = Ok && gnorm <= eps;
      // Test Lagrange multipliers returned by the solver (we skip
      // BLEIC solver because it does not return Lagrange vals).
         if (solvertype != -1 && solvertype != 0) {
            ae_vector_set_length(&gtrial, n);
            for (i = 0; i < n; i++) {
               v = b.xR[i];
               for (j = 0; j < n; j++) {
                  v += fulla.xyR[i][j] * (x1.xR[j] - xori.xR[j]);
               }
               gtrial.xR[i] = v;
            }
            for (i = 0; i < n; i++) {
               gtrial.xR[i] += rep.lagbc.xR[i];
            }
            for (i = 0; i < n; i++) {
               Ok = Ok && SmallAtR(gtrial.xR[i], 1.0E-3);
            }
         }
      }
   }
// Convex test, same box constraints for all variables:
// * N dimensions
// * box constraints set with minqpsetbcall()
// * positive-definite A
// * algorithm randomly choose dense or sparse A, and for
//   sparse matrix it randomly choose format.
// * random B with normal entries
// * initial point is random, feasible
// * random origin (zero or non-zero) and scale (unit or
//   non-unit) are generated
   eps = 1.0E-3;
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         origintype = hqrnduniformi(&rs, 2);
         scaletype = hqrnduniformi(&rs, 2);
         isupper = hqrnduniformr(&rs) < 0.5;
         issparse = hqrnduniformr(&rs) < 0.5;
         spdmatrixrndcond(n, 1.0E3, &fulla);
         ae_matrix_set_length(&halfa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j >= i: j <= i) {
                  halfa.xyR[i][j] = fulla.xyR[i][j];
               } else {
                  halfa.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         }
         testminqpunit_densetosparse(&halfa, n, &sa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xori, n);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            x0.xR[i] = hqrndnormal(&rs);
            if (origintype == 0) {
               xori.xR[i] = 0.0;
            } else {
               xori.xR[i] = hqrndnormal(&rs);
            }
            if (scaletype == 0) {
               s.xR[i] = 1.0;
            } else {
               s.xR[i] = exp(0.5 * hqrndnormal(&rs));
            }
         }
         vl = -INFINITY;
         vu = +INFINITY;
         j = hqrnduniformi(&rs, 5);
         if (j == 0) {
            vl = 0.0;
         }
         if (j == 1) {
            vu = 0.0;
         }
         if (j == 2) {
            vl = hqrndnormal(&rs);
            vu = vl;
         }
         if (j == 3) {
            vl = -0.1 - pow(2.0, hqrndnormal(&rs));
            vu = 0.1 + pow(2.0, hqrndnormal(&rs));
         }
      // Solve problem
         minqpcreate(n, &state);
         testminqpunit_setrandomalgoallmodern(&state, &bctol, &lctol);
         minqpsetlinearterm(&state, &b);
         minqpsetstartingpoint(&state, &x0);
         if (issparse) {
            minqpsetquadratictermsparse(&state, &sa, isupper);
         } else {
            minqpsetquadraticterm(&state, &halfa, isupper);
         }
         if (origintype != 0) {
            minqpsetorigin(&state, &xori);
         }
         if (scaletype != 0) {
            minqpsetscale(&state, &s);
         }
         minqpsetbcall(&state, vl, vu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return Ok;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            g = b.xR[i];
            for (j = 0; j < n; j++) {
               g += fulla.xyR[i][j] * (x1.xR[j] - xori.xR[j]);
            }
            if (x1.xR[i] <= vl + bctol && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] >= vu - bctol && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            Ok = Ok && x1.xR[i] >= vl;
            Ok = Ok && x1.xR[i] <= vu;
         }
         gnorm = sqrt(gnorm);
         Ok = Ok && gnorm <= eps;
      }
   }
// Semidefinite test:
// * N dimensions
// * nonnegativity constraints
// * A = [ 1 1 ... 1 1 ; 1 1 ... 1 1 ; .... ; 1 1 ... 1 1 ]
// * algorithm randomly choose dense or sparse A, and for
//   sparse matrix it randomly choose format.
// * random B with normal entries
// * initial point is random, feasible
   eps = 1.0E-4;
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         isupper = hqrnduniformr(&rs) < 0.5;
         issparse = hqrnduniformr(&rs) < 0.5;
         ae_matrix_set_length(&fulla, n, n);
         ae_matrix_set_length(&halfa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               fulla.xyR[i][j] = 1.0;
               if (isupper? j >= i: j <= i) {
                  halfa.xyR[i][j] = fulla.xyR[i][j];
               } else {
                  halfa.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         }
         testminqpunit_densetosparse(&halfa, n, &sa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = 0.0;
            bndu.xR[i] = +INFINITY;
            x0.xR[i] = (double)hqrnduniformi(&rs, 2);
         }
      // Solve problem
         minqpcreate(n, &state);
         testminqpunit_setrandomalgosemidefinite(&state, &bctol, &lctol);
         minqpsetstartingpoint(&state, &x0);
         minqpsetlinearterm(&state, &b);
         if (issparse) {
            minqpsetquadratictermsparse(&state, &sa, isupper);
         } else {
            minqpsetquadraticterm(&state, &halfa, isupper);
         }
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return Ok;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            g = b.xR[i];
            for (j = 0; j < n; j++) {
               g += fulla.xyR[i][j] * x1.xR[j];
            }
            if (x1.xR[i] <= bndl.xR[i] + bctol && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] >= bndu.xR[i] - bctol && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            Ok = Ok && x1.xR[i] >= bndl.xR[i];
            Ok = Ok && x1.xR[i] <= bndu.xR[i];
         }
         gnorm = sqrt(gnorm);
         Ok = Ok && gnorm <= eps;
      }
   }
// Non-convex test:
// * N dimensions, N >= 2
// * box constraints, x[i] in [-1,+1]
// * A = A0-0.5*I, where A0 is SPD with unit norm and smallest
//   singular value equal to 1.0E-3, I is identity matrix
// * random B with normal entries
// * initial point is random, feasible
//
// We perform two tests:
// * unconstrained problem must be recognized as unbounded
// * constrained problem can be successfully solved
//
// NOTE: it is important to have N >= 2, because formula for A
//       can be applied only to matrix with at least two
//       singular values
   eps = 1.0E-4;
   for (n = 2; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         spdmatrixrndcond(n, 1.0E3, &fulla);
         for (i = 0; i < n; i++) {
            fulla.xyR[i][i] -= 0.5;
         }
         isupper = hqrnduniformr(&rs) < 0.5;
         ae_matrix_set_length(&halfa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper? j >= i: j <= i) {
                  halfa.xyR[i][j] = fulla.xyR[i][j];
               } else {
                  halfa.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         }
         testminqpunit_densetosparse(&halfa, n, &sa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = -1.0;
            bndu.xR[i] = 1.0;
            x0.xR[i] = hqrndmiduniformr(&rs);
         }
      // Solve problem:
      // * without constraints we expect failure
      // * with constraints algorithm must succeed
         minqpcreate(n, &state);
         testminqpunit_setrandomalgononconvex(&state);
         minqpsetstartingpoint(&state, &x0);
         minqpsetlinearterm(&state, &b);
         if (hqrndnormal(&rs) > 0.0) {
            minqpsetquadraticterm(&state, &halfa, isupper);
         } else {
            minqpsetquadratictermsparse(&state, &sa, isupper);
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype == -4;
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return Ok;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(fulla.xyR[i], 1, x1.xR, 1, n);
            g = v + b.xR[i];
            if (x1.xR[i] == bndl.xR[i] && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] == bndu.xR[i] && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            Ok = Ok && x1.xR[i] >= bndl.xR[i];
            Ok = Ok && x1.xR[i] <= bndu.xR[i];
         }
         gnorm = sqrt(gnorm);
         Ok = Ok && gnorm <= eps;
      }
   }
// Linear (zero-quadratic) test:
// * N dimensions, N >= 1
// * box constraints, x[i] in [-1,+1]
// * A = 0
// * random B with normal entries
// * initial point is random, feasible
//
// We perform two tests:
// * unconstrained problem must be recognized as unbounded
// * constrained problem can be successfully solved
//
// NOTE: we may explicitly set zero A, or assume that by
//       default it is zero. During test we will try both
//       ways.
   eps = 1.0E-4;
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            do {
               b.xR[i] = hqrndnormal(&rs);
            } while (b.xR[i] == 0.0);
            bndl.xR[i] = -1.0;
            bndu.xR[i] = 1.0;
            x0.xR[i] = hqrndmiduniformr(&rs);
         }
      // Solve problem:
      // * without constraints we expect failure
      // * with constraints algorithm must succeed
         minqpcreate(n, &state);
         testminqpunit_setrandomalgosemidefinite(&state, &bctol, &lctol);
         minqpsetlinearterm(&state, &b);
         minqpsetstartingpoint(&state, &x0);
         if (hqrndnormal(&rs) > 0.0) {
            ae_matrix_set_length(&a, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
            }
            minqpsetquadraticterm(&state, &a, true);
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && (rep.terminationtype == -4 || rep.terminationtype == -2);
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return Ok;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         for (i = 0; i < n; i++) {
            Ok = Ok && (b.xR[i] <= 0.0 || x1.xR[i] <= bndl.xR[i] + bctol);
            Ok = Ok && (b.xR[i] >= 0.0 || x1.xR[i] >= bndu.xR[i] - bctol);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests equality constrained quadratic programming algorithm.
static bool testminqpunit_ecqptest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t k;
   double eps;
   double theta;
   double f0;
   double f1;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   ae_int_t rk;
   double v;
   ae_int_t aulits;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(b2, 0, DT_REAL);
   NewVector(xstart, 0, DT_REAL);
   NewVector(xstart2, 0, DT_REAL);
   NewVector(xend, 0, DT_REAL);
   NewVector(xend2, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(xd, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(xorigin, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(minqpstate, state);
   NewObj(minqpstate, state2);
   NewObj(minqpreport, rep);
   Ok = true;
// First test:
// * N*N identity A
// * K < N equality constraints Q*x = Q*x0, where Q is random
//   orthogonal K*N matrix, x0 is some random vector
// * x1 is some random vector such that Q*x1 == 0. It is always possible
//   to find such x1, because K < N
// * optimization problem has form 0.5*x'*A*x-(x1*A)*x
// * exact solution must be equal to x0
   eps = 1.0E-4;
   for (n = 2; n <= 6; n++) {
      for (k = 1; k < n; k++) {
      // Generate problem: A, b, CMatrix, x0, XStart
         rmatrixrndorthogonal(n, &q);
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
            a.xyR[i][i] = 1.0;
         }
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = randommid();
            x1.xR[i] = x0.xR[i];
            xstart.xR[i] = randommid();
         }
         for (i = 0; i < k; i++) {
            ae_v_move(c.xyR[i], 1, q.xyR[i], 1, n);
            v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
            v = randommid();
            ae_v_addd(x1.xR, 1, q.xyR[i], 1, n, v);
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
            b.xR[i] = -v;
         }
      // Create optimizer, solve
         minqpcreate(n, &state);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state, &b);
         minqpsetquadraticterm(&state, &a, randombool());
         minqpsetstartingpoint(&state, &xstart);
         minqpsetlc(&state, &c, &ct, k);
         minqpoptimize(&state);
         minqpresults(&state, &xend, &rep);
      // Compare with analytic solution
         if (rep.terminationtype <= 0) {
            Ok = false;
            continue;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(xend.xR[i], x0.xR[i], eps);
         }
      }
   }
// Second test:
// * N*N SPD A
// * K < N equality constraints Q*x = Q*x0, where Q is random
//   orthogonal K*N matrix, x0 is some random vector
// * optimization problem has form 0.5*x'*A*x-(x1*A)*x,
//   where x1 is some random vector
// * we check feasibility properties of the solution
// * we do not know analytic form of the exact solution,
//   but we know that projection of gradient into equality constrained
//   subspace must be zero at the solution
   eps = 1.0E-4;
   for (n = 2; n <= 6; n++) {
      for (k = 1; k < n; k++) {
      // Generate problem: A, b, CMatrix, x0, XStart
         rmatrixrndorthogonal(n, &q);
         spdmatrixrndcond(n, pow(10.0, 3.0 * randomreal()), &a);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = randommid();
            x1.xR[i] = randommid();
            xstart.xR[i] = randommid();
         }
         for (i = 0; i < k; i++) {
            ae_v_move(c.xyR[i], 1, q.xyR[i], 1, n);
            v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
            b.xR[i] = -v;
         }
      // Create optimizer, solve
         minqpcreate(n, &state);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state, &b);
         minqpsetquadraticterm(&state, &a, randombool());
         minqpsetstartingpoint(&state, &xstart);
         minqpsetlc(&state, &c, &ct, k);
         minqpoptimize(&state);
         minqpresults(&state, &xend, &rep);
      // Calculate gradient, check projection
         if (rep.terminationtype <= 0) {
            Ok = false;
            continue;
         }
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(xend.xR, 1, c.xyR[i], 1, n);
            Ok = Ok && NearAtR(v, c.xyR[i][n], eps);
         }
         ae_vector_set_length(&g, n);
         ae_v_move(g.xR, 1, b.xR, 1, n);
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, xend.xR, 1, n);
            g.xR[i] += v;
         }
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(g.xR, 1, c.xyR[i], 1, n);
            ae_v_subd(g.xR, 1, c.xyR[i], 1, n, v);
         }
         v = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
         Ok = Ok && sqrt(v) <= eps;
      }
   }
// Boundary and linear equality constrained QP problem:
// * N*N SPD A with moderate condtion number (up to 100)
// * boundary constraints 0 <= x[i] <= 1
// * K < N equality constraints C*x = C*x0, where Q is random
//   K*N matrix, x0 is some random vector from the
//   feasible hypercube (0 <= x0[i] <= 1)
// * optimization problem has form 0.5*x'*A*x-(x1*A)*x,
//   where x1 is some random vector with -1 <= x1[i] <= +1.
//   (sometimes solution is in the inner area, sometimes at the boundary)
// * every component of the initial point XStart is either 0 or 1
//   (point is located at the vertices of the feasible hypercube)
//
// Solution of such problem is calculated using two methods:
// a) boundary and linearly constrained QP
// b) augmented Lagrangian boundary constrained QP: we add explicit quadratic
//    penalty to the problem; we also add Lagrangian terms and perform many
//    subsequent iterations to find good estimates of the Lagrange multipliers.
//
// Sometimes augmented Largangian converges to slightly different point
// (boundary constraints lead to extremely slow, non-smooth convergence of
// the Lagrange multipliers). In order to correctly handle such situations
// we compare function values instead of final points - and use relaxed criteria
// to test for convergence.
//
// NOTE: sometimes we need as much as 300 Augmented Lagrangian iterations for
//       method to converge.
   eps = 5.0E-2;
   theta = 1.0E+4;
   aulits = 300;
   for (n = 4; n <= 6; n++) {
      for (k = 1; k < n - 2; k++) {
      // Generate problem: A, b, BndL, BndU, CMatrix, x0, x1, XStart
         spdmatrixrndcond(n, pow(10.0, 2.0 * randomreal()), &a);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = randomreal();
            x1.xR[i] = randommid();
            bndl.xR[i] = 0.0;
            bndu.xR[i] = 1.0;
            xstart.xR[i] = (double)randominteger(2);
         }
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = randommid();
            }
            v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
            b.xR[i] = -v;
         }
      // Create exact optimizer, solve
         minqpcreate(n, &state);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state, &b);
         minqpsetquadraticterm(&state, &a, randombool());
         minqpsetstartingpoint(&state, &xstart);
         minqpsetbc(&state, &bndl, &bndu);
         minqpsetlc(&state, &c, &ct, k);
         minqpoptimize(&state);
         minqpresults(&state, &xend, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            continue;
         }
      // Solve problem using barrier functions (quadrative objective, boundary constraints,
      // explicit penalty term added to the main quadratic matrix. Lagrangian terms improve
      // solution quality):
      // * A2 = A+C'*C
      // * b2 = b-r'*C
      // * b2 is iteratively updated using augmented Lagrangian update
      //
      // NOTE: we may need many outer iterations to converge to the optimal values
      //       of Lagrange multipliers. Convergence is slowed down by the presense
      //       of boundary constraints, whose activation/deactivation slows down
      //       process.
         ae_matrix_set_length(&a2, n, n);
         rmatrixcopy(n, n, &a, 0, 0, &a2, 0, 0);
         rmatrixsyrk(n, k, theta, &c, 0, 0, 2, 1.0, &a2, 0, 0, true);
         for (i = 0; i < n; i++) {
            for (j = i + 1; j < n; j++) {
               a2.xyR[j][i] = a2.xyR[i][j];
            }
         }
         ae_vector_set_length(&b2, n);
         ae_v_move(b2.xR, 1, b.xR, 1, n);
         for (i = 0; i < k; i++) {
            v = c.xyR[i][n] * theta;
            ae_v_subd(b2.xR, 1, c.xyR[i], 1, n, v);
         }
         minqpcreate(n, &state2);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetquadraticterm(&state2, &a2, randombool());
         minqpsetstartingpoint(&state2, &xstart);
         minqpsetbc(&state2, &bndl, &bndu);
         for (i = 1; i <= aulits; i++) {
         // Solve, update B2 according to augmented Lagrangian algorithm
            minqpsetlinearterm(&state2, &b2);
            minqpoptimize(&state2);
            minqpresults(&state2, &xend2, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               continue;
            }
            for (j = 0; j < k; j++) {
               v = ae_v_dotproduct(c.xyR[j], 1, xend2.xR, 1, n);
               v = theta * (v - c.xyR[j][n]);
               ae_v_addd(b2.xR, 1, c.xyR[j], 1, n, v);
            }
         }
      // Calculate function value and XEnd and XEnd2
         f0 = 0.0;
         f1 = 0.0;
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               f0 += 0.5 * xend.xR[i] * a.xyR[i][j] * xend.xR[j];
               f1 += 0.5 * xend2.xR[i] * a.xyR[i][j] * xend2.xR[j];
            }
            f0 += xend.xR[i] * b.xR[i];
            f1 += xend2.xR[i] * b.xR[i];
         }
      // Check feasibility properties and compare
         Ok = Ok && NearAtR(f0, f1, eps);
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(xend.xR, 1, c.xyR[i], 1, n);
            Ok = Ok && NearAtR(v, c.xyR[i][n], 1.0E6 * machineepsilon);
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && xend.xR[i] >= 0.0;
            Ok = Ok && xend.xR[i] <= 1.0;
         }
      }
   }
// Boundary and linear equality constrained QP problem,
// test for correct handling of non-zero XOrigin:
// * N*N SPD A with moderate condtion number (up to 100)
// * boundary constraints 0 <= x[i] <= 1
// * K < N equality constraints Q*x = Q*x0, where Q is random
//   orthogonal K*N matrix, x0 is some random vector from the
//   inner area of the feasible hypercube (0.1 <= x0[i] <= 0.9)
// * optimization problem has form 0.5*(x-xorigin)'*A*(x-xorigin)+b*(x-xorigin),
//   where b is some random vector with -1 <= b[i] <= +1.
//   (sometimes solution is in the inner area, sometimes at the boundary)
// * every component of the initial point XStart is random from [-1,1]
//
// Solution of such problem is calculated using two methods:
// a) QP with SetOrigin() call
// b) QP with XOrigin explicitly added to the quadratic function,
//
// Both methods should give same results; any significant difference is
// evidence of some error in the QP implementation.
   eps = 1.0E-4;
   for (n = 2; n <= 6; n++) {
      for (k = 1; k < n; k++) {
      // Generate problem: A, b, BndL, BndU, CMatrix, x0, x1, XStart.
      // Additionally, we compute modified b: b2 = b-xorigin'*A
         rmatrixrndorthogonal(n, &q);
         spdmatrixrndcond(n, pow(10.0, 2.0 * randomreal()), &a);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&b2, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xorigin, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 0.1 + 0.8 * randomreal();
            b.xR[i] = randommid();
            bndl.xR[i] = 0.0;
            bndu.xR[i] = 1.0;
            xstart.xR[i] = (double)randominteger(2);
            xorigin.xR[i] = randommid();
         }
         for (i = 0; i < k; i++) {
            ae_v_move(c.xyR[i], 1, q.xyR[i], 1, n);
            v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, xorigin.xR, 1, n);
            b2.xR[i] = b.xR[i] - v;
         }
      // Solve with SetOrigin() call
         minqpcreate(n, &state);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state, &b);
         minqpsetquadraticterm(&state, &a, randombool());
         minqpsetstartingpoint(&state, &xstart);
         minqpsetorigin(&state, &xorigin);
         minqpsetbc(&state, &bndl, &bndu);
         minqpsetlc(&state, &c, &ct, k);
         minqpoptimize(&state);
         minqpresults(&state, &xend, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            continue;
         }
      // Solve problem using explicit origin
         minqpcreate(n, &state2);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state2, &b2);
         minqpsetquadraticterm(&state2, &a, randombool());
         minqpsetstartingpoint(&state2, &xstart);
         minqpsetbc(&state2, &bndl, &bndu);
         minqpsetlc(&state2, &c, &ct, k);
         minqpoptimize(&state2);
         minqpresults(&state2, &xend2, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            continue;
         }
      // Check feasibility properties and compare solutions
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(xend.xR, 1, c.xyR[i], 1, n);
            Ok = Ok && NearAtR(v, c.xyR[i][n], eps);
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(xend.xR[i], xend2.xR[i], eps);
            Ok = Ok && xend.xR[i] >= 0.0;
            Ok = Ok && xend.xR[i] <= 1.0;
         }
      }
   }
// Boundary and linear equality constrained QP problem with excessive
// equality constraints:
// * N*N SPD A with moderate condtion number (up to 100)
// * boundary constraints 0 <= x[i] <= 1
// * K == 2*N equality constraints Q*x = Q*x0, where Q is random matrix,
//   x0 is some random vector from the feasible hypercube (0.1 <= x0[i] <= 0.9)
// * optimization problem has form 0.5*x'*A*x-b*x,
//   where b is some random vector
// * because constraints are excessive, the main problem is to find
//   feasible point; the only existing feasible point is solution,
//   so we have to check only feasibility
   eps = 1.0E-4;
   for (n = 1; n <= 6; n++) {
   // Generate problem: A, b, BndL, BndU, CMatrix, x0, x1, XStart
      k = 2 * n;
      spdmatrixrndcond(n, pow(10.0, 3.0 * randomreal()), &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&x1, n);
      ae_vector_set_length(&xstart, n);
      ae_matrix_set_length(&c, k, n + 1);
      ae_vector_set_length(&ct, k);
      for (i = 0; i < n; i++) {
         x0.xR[i] = 0.1 + 0.8 * randomreal();
         x1.xR[i] = randommid();
         bndl.xR[i] = 0.0;
         bndu.xR[i] = 1.0;
         xstart.xR[i] = (double)randominteger(2);
      }
      for (i = 0; i < k; i++) {
         for (j = 0; j < n; j++) {
            c.xyR[i][j] = randommid();
         }
         v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
         c.xyR[i][n] = v;
         ct.xZ[i] = 0;
      }
      for (i = 0; i < n; i++) {
         b.xR[i] = randommid();
      }
   // Create optimizer, solve
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, randombool());
      minqpsetstartingpoint(&state, &xstart);
      minqpsetbc(&state, &bndl, &bndu);
      minqpsetlc(&state, &c, &ct, k);
      minqpoptimize(&state);
      ae_vector_set_length(&xend, 0);
      minqpresults(&state, &xend, &rep);
   // Check feasibility properties of the solution
   // NOTE: we do not check termination type because some solvers (IPM) may return feasible X even with negative code
      if (xend.cnt != n) {
         Ok = false;
         continue;
      }
      for (i = 0; i < k; i++) {
         v = ae_v_dotproduct(xend.xR, 1, c.xyR[i], 1, n);
         Ok = Ok && NearAtR(v, c.xyR[i][n], eps);
      }
   }
// Boundary and linear equality constrained QP problem,
// test checks that different starting points yield same final point:
// * random N from [1..6], random K from [1..2*N]
// * N*N SPD A with moderate condtion number (up to 100)
// * boundary constraints 0 <= x[i] <= 1
// * K < N random linear equality constraints C*x = C*x0,
//   where x0 is some random vector from the inner area of the
//   feasible hypercube (0.1 <= x0[i] <= 0.9)
// * optimization problem has form 0.5*x'*A*x+b*x,
//   where b is some random vector with -5 <= b[i] <= +5
// * every component of the initial point XStart is random from [-2,+2]
// * we perform two starts from random different XStart and compare values
//   of the target function (although final points may be slightly different,
//   function values should match each other)
//
// Both points should give same results; any significant difference is
// evidence of some error in the QP implementation.
   eps = 1.0E-4;
   for (pass = 1; pass <= 50; pass++) {
   // Generate problem: N, K, A, b, BndL, BndU, CMatrix, x0, x1, XStart.
      n = randominteger(5) + 2;
      k = randominteger(n - 1) + 1;
      spdmatrixrndcond(n, pow(10.0, 2.0 * randomreal()), &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&b2, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&xstart, n);
      ae_vector_set_length(&xstart2, n);
      ae_matrix_set_length(&c, k, n + 1);
      ae_vector_set_length(&ct, k);
      for (i = 0; i < n; i++) {
         x0.xR[i] = 0.1 + 0.8 * randomreal();
         b.xR[i] = randommid();
         bndl.xR[i] = 0.0;
         bndu.xR[i] = 1.0;
         xstart.xR[i] = 2.0 * randommid();
         xstart2.xR[i] = 2.0 * randommid();
      }
      for (i = 0; i < k; i++) {
         for (j = 0; j < n; j++) {
            c.xyR[i][j] = randommid();
         }
         v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
         c.xyR[i][n] = v;
         ct.xZ[i] = 0;
      }
   // Solve with XStart
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, randombool());
      minqpsetstartingpoint(&state, &xstart);
      minqpsetbc(&state, &bndl, &bndu);
      minqpsetlc(&state, &c, &ct, k);
      minqpoptimize(&state);
      minqpresults(&state, &xend, &rep);
      if (rep.terminationtype <= 0) {
         Ok = false;
         continue;
      }
   // Solve with XStart2
      minqpsetstartingpoint(&state, &xstart2);
      minqpoptimize(&state);
      minqpresults(&state, &xend2, &rep);
      if (rep.terminationtype <= 0) {
         Ok = false;
         continue;
      }
   // Calculate function value and XEnd and XEnd2, compare solutions
      f0 = 0.0;
      f1 = 0.0;
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            f0 += 0.5 * xend.xR[i] * a.xyR[i][j] * xend.xR[j];
            f1 += 0.5 * xend2.xR[i] * a.xyR[i][j] * xend2.xR[j];
         }
         f0 += xend.xR[i] * b.xR[i];
         f1 += xend2.xR[i] * b.xR[i];
      }
      Ok = Ok && NearAtR(f0, f1, eps);
   }
// Test ability to correctly handle situation where algorithm
// either:
// (1) starts from point with gradient whose projection to
//     active set is almost zero (but not exactly zero)
// (2) performs step to such point
//
// In order to do this we solve problem
// * min 0.5*x'*x - (x0+c)'*x
// * subject to c'*x = c'*x0, with c and x0 random unit vectors
// * with initial point xs = x0+r*xd, where r is scalar,
//   xd is vector which is orthogonal to c.
// * we try different r == power(2,-rk) for rk = 0...70. The idea
//   is that as we approach closer and closer to x0, which is
//   a solution of the constrained problem, constrained gradient
//   of the function rapidly vanishes.
   eps = 1.0E-6;
   for (rk = 0; rk <= 70; rk++) {
      n = 10;
   // Generate x0, c, xd, xs, generate unit A
      randomunit(n, &x0);
      randomunit(n, &xd);
      randomunit(n, &tmp);
      ae_matrix_set_length(&c, 1, n + 1);
      ae_vector_set_length(&ct, 1);
      ae_vector_set_length(&xs, n);
      ae_vector_set_length(&b, n);
      c.xyR[0][n] = 0.0;
      ct.xZ[0] = 0;
      v = 0.0;
      for (i = 0; i < n; i++) {
         c.xyR[0][i] = tmp.xR[i];
         c.xyR[0][n] += tmp.xR[i] * x0.xR[i];
         b.xR[i] = -(x0.xR[i] + tmp.xR[i]);
         v += tmp.xR[i] * xd.xR[i];
      }
      for (i = 0; i < n; i++) {
         xd.xR[i] -= v * tmp.xR[i];
         xs.xR[i] = x0.xR[i] + xd.xR[i] * pow(2.0, (double)-rk);
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = 0.0;
         }
         a.xyR[i][i] = 1.0;
      }
   // Create and solve optimization problem
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, true);
      minqpsetstartingpoint(&state, &xs);
      minqpsetlc(&state, &c, &ct, 1);
      minqpoptimize(&state);
      minqpresults(&state, &xend, &rep);
      if (rep.terminationtype <= 0) {
         Ok = false;
         continue;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(xend.xR[i], x0.xR[i], eps);
      }
      v = -c.xyR[0][n];
      for (i = 0; i < n; i++) {
         v += xend.xR[i] * c.xyR[0][i];
      }
      Ok = Ok && SmallAtR(v, 1.0E5 * machineepsilon);
   }
   ae_frame_leave();
   return Ok;
}

// This function tests inequality constrained quadratic programming algorithm.
static bool testminqpunit_icqptest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t k;
   double eps;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   double v;
   double vv;
   double f0;
   double f1;
   double tolconstr;
   ae_int_t bscale;
   ae_int_t akind;
   ae_int_t shiftkind;
   ae_int_t ccnt;
   bool isnonconvex;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewMatrix(t2, 0, 0, DT_REAL);
   NewMatrix(t3, 0, 0, DT_REAL);
   NewMatrix(ce, 0, 0, DT_REAL);
   NewVector(xs0, 0, DT_REAL);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(xstart, 0, DT_REAL);
   NewVector(xstart2, 0, DT_REAL);
   NewVector(xend, 0, DT_REAL);
   NewVector(xend2, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(b2, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(xorigin, 0, DT_REAL);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(tmp1, 0, DT_REAL);
   NewVector(da, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewVector(nonnegative, 0, DT_BOOL);
   NewObj(minqpstate, state);
   NewObj(minqpstate, state2);
   NewObj(minqpreport, rep);
   NewObj(minqpreport, rep2);
   NewObj(hqrndstate, rs);
   NewObj(snnlssolver, nnls);
   hqrndrandomize(&rs);
// Inequality constrained problem:
// * N*N diagonal A
// * one inequality constraint q'*x >= 0, where q is random unit vector
// * optimization problem has form 0.5*x'*A*x-(x1*A)*x,
//   where x1 is some random vector
// * either:
//   a) x1 is feasible => we must stop at x1
//   b) x1 is infeasible => we must stop at the boundary q'*x == 0 and
//      projection of gradient onto q*x == 0 must be zero
//
// NOTE: we make several passes because some specific kind of errors is rarely
//       caught by this test, so we need several repetitions.
   eps = 1.0E-4;
   for (n = 2; n <= 6; n++) {
      for (pass = 0; pass <= 4; pass++) {
      // Generate problem: A, b, CMatrix, x0, XStart
         spdmatrixrndcond(n, pow(10.0, 3.0 * randomreal()), &a);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, 1, n + 1);
         ae_vector_set_length(&ct, 1);
         for (i = 0; i < n; i++) {
            x1.xR[i] = randommid();
            xstart.xR[i] = randommid();
         }
         do {
            v = 0.0;
            for (i = 0; i < n; i++) {
               c.xyR[0][i] = randommid();
               v += sqr(c.xyR[0][i]);
            }
            v = sqrt(v);
         } while (v == 0.0);
         for (i = 0; i < n; i++) {
            c.xyR[0][i] /= v;
         }
         c.xyR[0][n] = 0.0;
         ct.xZ[0] = 1;
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
            b.xR[i] = -v;
         }
      // Create optimizer, solve
         minqpcreate(n, &state);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state, &b);
         minqpsetquadraticterm(&state, &a, randombool());
         minqpsetstartingpoint(&state, &xstart);
         minqpsetlc(&state, &c, &ct, 1);
         minqpoptimize(&state);
         minqpresults(&state, &xend, &rep);
      // Test
         if (rep.terminationtype <= 0) {
            Ok = false;
            continue;
         }
         v = ae_v_dotproduct(x1.xR, 1, c.xyR[0], 1, n);
         if (v >= 0.0) {
         // X1 is feasible, compare target function values at XEnd and X1
            for (i = 0; i < n; i++) {
               Ok = Ok && NearAtR(xend.xR[i], x1.xR[i], eps);
            }
         } else {
         // X1 is infeasible:
         // * XEnd must be approximately feasible
         // * gradient projection onto c'*x == 0 must be zero
            v = ae_v_dotproduct(xend.xR, 1, c.xyR[0], 1, n);
            Ok = Ok && v >= -eps;
            ae_vector_set_length(&g, n);
            ae_v_move(g.xR, 1, b.xR, 1, n);
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xend.xR, 1, n);
               g.xR[i] += v;
            }
            v = ae_v_dotproduct(g.xR, 1, c.xyR[0], 1, n);
            ae_v_subd(g.xR, 1, c.xyR[0], 1, n, v);
            v = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
            Ok = Ok && sqrt(v) <= eps;
         }
      }
   }
// Boundary and linear equality/inequality constrained QP problem,
// test for correct handling of non-zero XOrigin:
// * N*N SPD A with moderate condtion number (up to 100)
// * boundary constraints 0 <= x[i] <= 1
// * K < N linear equality/inequality constraints Q*x = Q*x0, where
//   Q is random orthogonal K*N matrix, x0 is some random vector from the
//   inner area of the feasible hypercube (0.1 <= x0[i] <= 0.9)
// * optimization problem has form 0.5*(x-xorigin)'*A*(x-xorigin)+b*(x-xorigin),
//   where b is some random vector with -1 <= b[i] <= +1.
//   (sometimes solution is in the inner area, sometimes at the boundary)
// * every component of the initial point XStart is random from [-1,1]
//
// Solution of such problem is calculated using two methods:
// a) QP with SetOrigin() call
// b) QP with XOrigin explicitly added to the quadratic function,
//
// Both methods should give same results; any significant difference is
// evidence of some error in the QP implementation.
   eps = 1.0E-4;
   for (n = 2; n <= 6; n++) {
      for (k = 1; k < n; k++) {
      // Generate problem: A, b, BndL, BndU, CMatrix, x0, x1, XStart.
      // Additionally, we compute modified b: b2 = b-xorigin'*A
         rmatrixrndorthogonal(n, &q);
         spdmatrixrndcond(n, pow(10.0, 2.0 * randomreal()), &a);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&b2, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xorigin, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 0.1 + 0.8 * randomreal();
            b.xR[i] = randommid();
            bndl.xR[i] = 0.0;
            bndu.xR[i] = 1.0;
            xstart.xR[i] = (double)randominteger(2);
            xorigin.xR[i] = randommid();
         }
         for (i = 0; i < k; i++) {
            ae_v_move(c.xyR[i], 1, q.xyR[i], 1, n);
            v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = randominteger(3) - 1;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, xorigin.xR, 1, n);
            b2.xR[i] = b.xR[i] - v;
         }
      // Solve with SetOrigin() call
         minqpcreate(n, &state);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state, &b);
         minqpsetquadraticterm(&state, &a, randombool());
         minqpsetstartingpoint(&state, &xstart);
         minqpsetorigin(&state, &xorigin);
         minqpsetbc(&state, &bndl, &bndu);
         minqpsetlc(&state, &c, &ct, k);
         minqpoptimize(&state);
         minqpresults(&state, &xend, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            continue;
         }
      // Solve problem using explicit origin
         minqpcreate(n, &state2);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state2, &b2);
         minqpsetquadraticterm(&state2, &a, randombool());
         minqpsetstartingpoint(&state2, &xstart);
         minqpsetbc(&state2, &bndl, &bndu);
         minqpsetlc(&state2, &c, &ct, k);
         minqpoptimize(&state2);
         minqpresults(&state2, &xend2, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            continue;
         }
      // Calculate function value and XEnd and XEnd2
         f0 = 0.0;
         f1 = 0.0;
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               f0 += 0.5 * (xend.xR[i] - xorigin.xR[i]) * a.xyR[i][j] * (xend.xR[j] - xorigin.xR[j]);
               f1 += 0.5 * (xend2.xR[i] - xorigin.xR[i]) * a.xyR[i][j] * (xend2.xR[j] - xorigin.xR[j]);
            }
            f0 += (xend.xR[i] - xorigin.xR[i]) * b.xR[i];
            f1 += (xend2.xR[i] - xorigin.xR[i]) * b.xR[i];
         }
      // Check feasibility properties and compare solutions
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(xend.xR, 1, c.xyR[i], 1, n);
            if (ct.xZ[i] == 0) {
               Ok = Ok && NearAtR(v, c.xyR[i][n], eps);
            }
            if (ct.xZ[i] > 0) {
               Ok = Ok && v >= c.xyR[i][n] - eps;
            }
            if (ct.xZ[i] < 0) {
               Ok = Ok && v <= c.xyR[i][n] + eps;
            }
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(xend.xR[i], xend2.xR[i], eps);
            Ok = Ok && xend.xR[i] >= 0.0;
            Ok = Ok && xend.xR[i] <= 1.0;
         }
      }
   }
// Boundary constraints vs linear ones:
// * N*N SPD A
// * optimization problem has form 0.5*x'*A*x-(x1*A)*x,
//   where x1 is some random vector from [-1,+1]
// * K == 2*N constraints of the form ai <= x[i] or x[i] <= b[i],
//   with ai in [-1.0,-0.1], bi in [+0.1,+1.0]
// * initial point xstart is from [-1,+2]
// * we solve two related QP problems:
//   a) one with constraints posed as boundary ones
//   b) another one with same constraints posed as general linear ones
// both problems must have same solution.
// Here we test that boundary constrained and linear inequality constrained
// solvers give same results.
   eps = 1.0E-3;
   for (n = 1; n <= 6; n++) {
   // Generate problem: A, b, x0, XStart, C, CT
      spdmatrixrndcond(n, pow(10.0, 3.0 * randomreal()), &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x1, n);
      ae_vector_set_length(&xstart, n);
      ae_matrix_set_length(&c, 2 * n, n + 1);
      ae_vector_set_length(&ct, 2 * n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      for (i = 0; i < n; i++) {
         x1.xR[i] = randommid();
         xstart.xR[i] = 3.0 * randomreal() - 1.0;
         bndl.xR[i] = -(0.1 + 0.9 * randomreal());
         bndu.xR[i] = 0.1 + 0.9 * randomreal();
         for (j = 0; j < n; j++) {
            c.xyR[2 * i][j] = 0.0;
            c.xyR[2 * i + 1][j] = 0.0;
         }
         c.xyR[2 * i][i] = 1.0;
         c.xyR[2 * i][n] = bndl.xR[i];
         ct.xZ[2 * i] = 1;
         c.xyR[2 * i + 1][i] = 1.0;
         c.xyR[2 * i + 1][n] = bndu.xR[i];
         ct.xZ[2 * i + 1] = -1;
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
         b.xR[i] = -v;
      }
   // Solve linear inequality constrained problem
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, randombool());
      minqpsetstartingpoint(&state, &xstart);
      minqpsetlc(&state, &c, &ct, 2 * n);
      minqpoptimize(&state);
      minqpresults(&state, &xend, &rep);
   // Solve boundary constrained problem
      minqpcreate(n, &state2);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state2, &b);
      minqpsetquadraticterm(&state2, &a, randombool());
      minqpsetstartingpoint(&state2, &xstart);
      minqpsetbc(&state2, &bndl, &bndu);
      minqpoptimize(&state2);
      minqpresults(&state2, &xend2, &rep2);
   // Calculate gradient, check projection
      if (rep.terminationtype <= 0 || rep2.terminationtype <= 0) {
         Ok = false;
         continue;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && xend.xR[i] >= bndl.xR[i] - eps;
         Ok = Ok && xend.xR[i] <= bndu.xR[i] + eps;
         Ok = Ok && NearAtR(xend.xR[i], xend2.xR[i], eps);
      }
   }
// Boundary constraints posed as general linear ones:
// * no bound constraints
// * 2*N linear constraints 0 <= x[i] <= 1
// * preconditioner is chosen at random (we just want to be
//   sure that preconditioning won't prevent us from converging
//   to the feasible point):
//   * unit preconditioner
//   * random diagonal-based preconditioner
//   * random scale-based preconditioner
// * F(x) = |x-x0|^P, where P == {2,4} and x0 is randomly selected from [-1,+2]^N
// * with such simple constraints and function it is easy to find
//   analytic form of solution: S[i] = bound(x0[i], 0, 1).
// * however, we can't guarantee that solution is strictly feasible
//   with respect to nonlinearity constraint, so we check
//   for approximate feasibility.
   for (n = 1; n <= 5; n++) {
   // Generate X, BL, BU.
      ae_matrix_set_length(&a, n, n);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&xstart, n);
      ae_vector_set_length(&x0, n);
      ae_matrix_set_length(&c, 2 * n, n + 1);
      ae_vector_set_length(&ct, 2 * n);
      for (i = 0; i < n; i++) {
         xstart.xR[i] = randomreal();
         x0.xR[i] = 3.0 * randomreal() - 1.0;
         b.xR[i] = -x0.xR[i];
         for (j = 0; j <= n; j++) {
            c.xyR[2 * i][j] = 0.0;
            c.xyR[2 * i + 1][j] = 0.0;
         }
         c.xyR[2 * i][i] = 1.0;
         c.xyR[2 * i][n] = 0.0;
         ct.xZ[2 * i] = 1;
         c.xyR[2 * i + 1][i] = 1.0;
         c.xyR[2 * i + 1][n] = 1.0;
         ct.xZ[2 * i + 1] = -1;
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (i == j) {
               a.xyR[i][j] = 1.0;
            } else {
               a.xyR[i][j] = 0.0;
            }
         }
      }
   // Create and optimize
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlc(&state, &c, &ct, 2 * n);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, randombool());
      minqpsetstartingpoint(&state, &xstart);
      minqpoptimize(&state);
      minqpresults(&state, &xend, &rep);
      if (rep.terminationtype <= 0) {
         Ok = false;
         continue;
      }
   // * compare solution with analytic one
   // * check feasibility
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(xend.xR[i], rboundval(x0.xR[i], 0.0, 1.0), 0.05);
         Ok = Ok && xend.xR[i] >= 0.0 - 1.0E-6;
         Ok = Ok && xend.xR[i] <= 1.0 + 1.0E-6;
      }
   }
// Boundary and linear equality/inequality constrained QP problem with
// excessive constraints:
// * N*N SPD A with moderate condtion number (up to 100)
// * boundary constraints 0 <= x[i] <= 1
// * K == 2*N equality/inequality constraints Q*x = Q*x0, where Q is random matrix,
//   x0 is some random vector from the feasible hypercube (0.1 <= x0[i] <= 0.9)
// * optimization problem has form 0.5*x'*A*x-b*x,
//   where b is some random vector
// * because constraints are excessive, the main problem is to find
//   feasible point; usually, the only existing feasible point is solution,
//   so we have to check only feasibility
   eps = 1.0E-4;
   for (n = 1; n <= 6; n++) {
   // Generate problem: A, b, BndL, BndU, CMatrix, x0, x1, XStart
      k = 2 * n;
      spdmatrixrndcond(n, pow(10.0, 3.0 * randomreal()), &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&x1, n);
      ae_vector_set_length(&xstart, n);
      ae_matrix_set_length(&c, k, n + 1);
      ae_vector_set_length(&ct, k);
      for (i = 0; i < n; i++) {
         x0.xR[i] = 0.1 + 0.8 * randomreal();
         x1.xR[i] = randommid();
         bndl.xR[i] = 0.0;
         bndu.xR[i] = 1.0;
         xstart.xR[i] = (double)randominteger(2);
      }
      for (i = 0; i < k; i++) {
         for (j = 0; j < n; j++) {
            c.xyR[i][j] = randommid();
         }
         v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
         ct.xZ[i] = randominteger(3) - 1;
         if (ct.xZ[i] == 0) {
            c.xyR[i][n] = v;
         }
         if (ct.xZ[i] > 0) {
            c.xyR[i][n] = v - 1.0E-3;
         }
         if (ct.xZ[i] < 0) {
            c.xyR[i][n] = v + 1.0E-3;
         }
      }
      for (i = 0; i < n; i++) {
         b.xR[i] = randommid();
      }
   // Create optimizer, solve
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, randombool());
      minqpsetstartingpoint(&state, &xstart);
      minqpsetbc(&state, &bndl, &bndu);
      minqpsetlc(&state, &c, &ct, k);
      minqpoptimize(&state);
      ae_vector_set_length(&xend, 0);
      minqpresults(&state, &xend, &rep);
   // Check feasibility properties of the solution
   // NOTE: we do not check termination type because some solvers (IPM) may return feasible X even with negative code
      if (xend.cnt != n) {
         Ok = false;
         continue;
      }
      for (i = 0; i < k; i++) {
         v = ae_v_dotproduct(xend.xR, 1, c.xyR[i], 1, n);
         if (ct.xZ[i] == 0) {
            Ok = Ok && NearAtR(v, c.xyR[i][n], eps);
         }
         if (ct.xZ[i] > 0) {
            Ok = Ok && v >= c.xyR[i][n] - eps;
         }
         if (ct.xZ[i] < 0) {
            Ok = Ok && v <= c.xyR[i][n] + eps;
         }
      }
   }
// General inequality constrained problem:
// * N*N SPD diagonal A with moderate condtion number
// * no boundary constraints
// * K == N inequality constraints C*x >= C*x0, where C is N*N well conditioned
//   matrix, x0 is some random vector [-1,+1]
// * optimization problem has form 0.5*x'*A*x-b'*x,
//   where b is random vector from [-1,+1]
// * using duality, we can obtain solution of QP problem as follows:
//   a) intermediate problem min(0.5*y'*B*y + d'*y) s.t. y >= 0
//      is solved, where B = C*inv(A)*C', d = -(C*inv(A)*b + C*x0)
//   b) after we got dual solution ys, we calculate primal solution
//      xs = inv(A)*(C'*ys-b)
   eps = 1.0E-3;
   for (n = 1; n <= 6; n++) {
   // Generate problem
      ae_vector_set_length(&da, n);
      ae_matrix_set_length(&a, n, n);
      rmatrixrndcond(n, pow(10.0, 2.0 * randomreal()), &t2);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&xstart, n);
      ae_matrix_set_length(&c, n, n + 1);
      ae_vector_set_length(&ct, n);
      for (i = 0; i < n; i++) {
         da.xR[i] = exp(4.0 * randommid());
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = 0.0;
         }
         a.xyR[i][i] = da.xR[i];
      }
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         b.xR[i] = randommid();
         xstart.xR[i] = randommid();
      }
      for (i = 0; i < n; i++) {
         ae_v_move(c.xyR[i], 1, t2.xyR[i], 1, n);
         v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
         c.xyR[i][n] = v;
         ct.xZ[i] = 1;
      }
   // Solve primal problem, check feasibility
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, randombool());
      minqpsetstartingpoint(&state, &xstart);
      minqpsetlc(&state, &c, &ct, n);
      minqpoptimize(&state);
      minqpresults(&state, &xend, &rep);
      if (rep.terminationtype <= 0) {
         Ok = false;
         continue;
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(xend.xR, 1, c.xyR[i], 1, n);
         Ok = Ok && v >= c.xyR[i][n] - eps;
      }
   // Generate dual problem:
   // * A2 stores new quadratic term
   // * B2 stores new linear term
   // * BndL/BndU store boundary constraints
      ae_matrix_set_length(&t3, n, n);
      ae_matrix_set_length(&a2, n, n);
      rmatrixtranspose(n, n, &c, 0, 0, &t3, 0, 0);
      for (i = 0; i < n; i++) {
         v = 1 / sqrt(da.xR[i]);
         ae_v_muld(t3.xyR[i], 1, n, v);
      }
      rmatrixsyrk(n, n, 1.0, &t3, 0, 0, 2, 0.0, &a2, 0, 0, true);
      ae_vector_set_length(&tmp0, n);
      ae_v_move(tmp0.xR, 1, b.xR, 1, n);
      for (i = 0; i < n; i++) {
         tmp0.xR[i] /= da.xR[i];
      }
      ae_vector_set_length(&b2, n);
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(c.xyR[i], 1, tmp0.xR, 1, n);
         b2.xR[i] = -(v + c.xyR[i][n]);
      }
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      for (i = 0; i < n; i++) {
         bndl.xR[i] = 0.0;
         bndu.xR[i] = +INFINITY;
      }
      minqpcreate(n, &state2);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state2, &b2);
      minqpsetquadraticterm(&state2, &a2, true);
      minqpsetbc(&state2, &bndl, &bndu);
      minqpoptimize(&state2);
      minqpresults(&state2, &xend2, &rep2);
      if (rep2.terminationtype <= 0) {
         Ok = false;
         continue;
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(&c.xyR[0][i], c.stride, xend2.xR, 1, n);
         tmp0.xR[i] = v - b.xR[i];
      }
      for (i = 0; i < n; i++) {
         tmp0.xR[i] /= da.xR[i];
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(tmp0.xR[i], xend.xR[i], eps * rmax2(fabs(tmp0.xR[i]), 1.0));
      }
   }
// Boundary and linear equality/inequality constrained QP problem,
// test checks that different starting points yield same final point:
// * random N from [1..6], random K from [1..2*N]
// * N*N SPD A with moderate condtion number (up to 100)
// * boundary constraints 0 <= x[i] <= 1
// * K < 2*N linear inequality constraints Q*x <= Q*x0, where
//   Q is random K*N matrix, x0 is some random vector from the
//   inner area of the feasible hypercube (0.1 <= x0[i] <= 0.9)
// * optimization problem has form 0.5*x'*A*x+b*x,
//   where b is some random vector with -5 <= b[i] <= +5
// * every component of the initial point XStart is random from [-2,+2]
// * we perform two starts from random different XStart and compare values
//   of the target function (although final points may be slightly different,
//   function values should match each other)
   eps = 1.0E-4;
   for (pass = 1; pass <= 50; pass++) {
   // Generate problem: N, K, A, b, BndL, BndU, CMatrix, x0, x1, XStart.
      n = randominteger(5) + 2;
      k = randominteger(2 * n) + 1;
      spdmatrixrndcond(n, pow(10.0, 2.0 * randomreal()), &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&b2, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&xstart, n);
      ae_vector_set_length(&xstart2, n);
      ae_matrix_set_length(&c, k, n + 1);
      ae_vector_set_length(&ct, k);
      for (i = 0; i < n; i++) {
         x0.xR[i] = 0.1 + 0.8 * randomreal();
         b.xR[i] = randommid();
         bndl.xR[i] = 0.0;
         bndu.xR[i] = 1.0;
         xstart.xR[i] = 2.0 * randommid();
         xstart2.xR[i] = 2.0 * randommid();
      }
      for (i = 0; i < k; i++) {
      // Generate I-th row of C
      // Avoid excessive (more than N/2) equality constraints.
         for (j = 0; j < n; j++) {
            c.xyR[i][j] = randommid();
         }
         v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
         c.xyR[i][n] = v;
         ct.xZ[i] = randominteger(3) - 1;
         if (i >= 0.5 * n && ct.xZ[i] == 0) {
            ct.xZ[i] = 1;
         }
         if (ct.xZ[i] < 0) {
            c.xyR[i][n] += 0.1;
         }
         if (ct.xZ[i] > 0) {
            c.xyR[i][n] -= 0.1;
         }
      }
   // Solve with XStart
   // NOTE: we do not check termination type because some solvers (IPM) may return feasible X even with negative code
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, randombool());
      minqpsetstartingpoint(&state, &xstart);
      minqpsetbc(&state, &bndl, &bndu);
      minqpsetlc(&state, &c, &ct, k);
      minqpoptimize(&state);
      ae_vector_set_length(&xend, 0);
      minqpresults(&state, &xend, &rep);
      if (xend.cnt != n || !isfinitevector(&xend, n)) {
         Ok = false;
         continue;
      }
   // Solve with XStart2
      minqpsetstartingpoint(&state, &xstart2);
      minqpoptimize(&state);
      ae_vector_set_length(&xend2, 0);
      minqpresults(&state, &xend2, &rep);
      if (xend2.cnt != n || !isfinitevector(&xend2, n)) {
         Ok = false;
         continue;
      }
   // Calculate function value and XEnd and XEnd2, compare solutions
      f0 = 0.0;
      f1 = 0.0;
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            f0 += 0.5 * xend.xR[i] * a.xyR[i][j] * xend.xR[j];
            f1 += 0.5 * xend2.xR[i] * a.xyR[i][j] * xend2.xR[j];
         }
         f0 += xend.xR[i] * b.xR[i];
         f1 += xend2.xR[i] * b.xR[i];
      }
      Ok = Ok && NearAtR(f0, f1, eps);
   }
// Convex/nonconvex optimization problem with excessive constraints:
//
// * N = 2..5
// * f = 0.5*x'*A*x+b'*x
// * b has normally distributed entries with scale 10^BScale
// * several kinds of A are tried: zero, well conditioned SPD, well conditioned indefinite, low rank SPD, low rank indefinite
// * box constraints: x[i] in [-1,+1]
// * 2^N "excessive" general linear constraints (v_k,x) <= (v_k,v_k)+v_shift,
//   where v_k is one of 2^N vertices of feasible hypercube, v_shift is
//   a shift parameter:
//   * with zero v_shift such constraints are degenerate (each vertex has
//     N box constraints and one "redundant" linear constraint)
//   * with positive v_shift linear constraint is always inactive
//   * with small (about machine epsilon) but negative v_shift,
//     constraint is close to degenerate - but not exactly
//
// We check that constrained gradient is close to zero at solution.
// Box constraint is considered active if distance to boundary is less
// than TolConstr.
//
// NOTE: TolConstr must be large enough so it won't conflict with
//       perturbation introduced by v_shift
   tolconstr = 1.0E-3;
   for (n = 2; n <= 5; n++) {
      for (akind = 0; akind <= 4; akind++) {
         for (shiftkind = -5; shiftkind <= 1; shiftkind++) {
            for (bscale = 0; bscale >= -2; bscale--) {
            // Generate A, B and initial point
               ae_matrix_set_length(&a, n, n);
               ae_vector_set_length(&b, n);
               ae_vector_set_length(&x, n);
               for (i = 0; i < n; i++) {
                  b.xR[i] = pow(10.0, (double)bscale) * hqrndnormal(&rs);
                  x.xR[i] = hqrnduniformr(&rs) - 0.5;
               }
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               isnonconvex = false;
               if (akind == 1) {
               // Dense well conditioned SPD
                  spdmatrixrndcond(n, 50.0, &a);
               }
               if (akind == 2) {
               // Dense well conditioned indefinite
                  smatrixrndcond(n, 50.0, &a);
                  isnonconvex = true;
               }
               if (akind == 3) {
               // Low rank semidefinite
                  ae_vector_set_length(&tmp, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = 0.0;
                     }
                  }
                  for (k = 1; k < imin2(4, n); k++) {
                     for (i = 0; i < n; i++) {
                        tmp.xR[i] = hqrndnormal(&rs);
                     }
                     v = pow(2.0, hqrndnormal(&rs));
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                        }
                     }
                  }
               }
               if (akind == 4) {
               // Low rank indefinite
                  ae_vector_set_length(&tmp, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = 0.0;
                     }
                  }
                  for (k = 1; k < imin2(4, n); k++) {
                     for (i = 0; i < n; i++) {
                        tmp.xR[i] = hqrndnormal(&rs);
                     }
                     v = hqrndnormal(&rs);
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                        }
                     }
                  }
                  isnonconvex = true;
               }
            // Generate constraints
               ae_vector_set_length(&bl, n);
               ae_vector_set_length(&bu, n);
               for (i = 0; i < n; i++) {
                  bl.xR[i] = -1.0;
                  bu.xR[i] = 1.0;
               }
               ccnt = iround(pow(2.0, (double)n));
               ae_matrix_set_length(&c, ccnt, n + 1);
               ae_vector_set_length(&ct, ccnt);
               for (i = 0; i < ccnt; i++) {
                  ct.xZ[i] = -1;
                  k = i;
                  c.xyR[i][n] = sign((double)shiftkind) * pow(10.0, fabs((double)shiftkind)) * machineepsilon;
                  for (j = 0; j < n; j++) {
                     c.xyR[i][j] = (double)(2 * (k % 2) - 1);
                     c.xyR[i][n] += c.xyR[i][j] * c.xyR[i][j];
                     k /= 2;
                  }
               }
            // Create and optimize
               minqpcreate(n, &state);
               minqpsetstartingpoint(&state, &x);
               if (isnonconvex) {
                  testminqpunit_setrandomalgononconvexlc(&state);
               } else {
                  testminqpunit_setrandomalgoconvexlc(&state);
               }
               minqpsetbc(&state, &bl, &bu);
               minqpsetlc(&state, &c, &ct, ccnt);
               minqpsetlinearterm(&state, &b);
               minqpsetquadraticterm(&state, &a, randombool());
               minqpoptimize(&state);
               minqpresults(&state, &xs0, &rep);
               Ok = Ok && rep.terminationtype > 0;
               if (!Ok) {
                  ae_frame_leave();
                  return Ok;
               }
            // Evaluate gradient at solution and test
               vv = 0.0;
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, xs0.xR, 1, n);
                  v += b.xR[i];
                  if (xs0.xR[i] <= bl.xR[i] + tolconstr && v > 0.0) {
                     v = 0.0;
                  }
                  if (xs0.xR[i] >= bu.xR[i] - tolconstr && v < 0.0) {
                     v = 0.0;
                  }
                  vv += sqr(v);
               }
               vv = sqrt(vv);
               Ok = Ok && vv <= 1.0E-3;
            }
         }
      }
   }
// Convex/nonconvex optimization problem with combination of
// box and linear constraints:
//
// * N = 2..8
// * f = 0.5*x'*A*x+b'*x
// * b has normally distributed entries with scale 10^BScale
// * several kinds of A are tried: zero, well conditioned SPD,
//   well conditioned indefinite, low rank semidefinite, low rank indefinite
// * box constraints: x[i] in [-1,+1]
// * initial point x0 = [0 0 ... 0 0]
// * CCnt == min(3,N-1) general linear constraints of form (c,x) == 0.
//   random mix of equality/inequality constraints is tried.
//   x0 is guaranteed to be feasible.
//
// We check that constrained gradient is close to zero at solution.
// Inequality constraint is considered active if distance to boundary
// is less than TolConstr. We use nonnegative least squares solver
// in order to compute constrained gradient.
   tolconstr = 1.0E-3;
   for (n = 2; n <= 8; n++) {
      for (akind = 0; akind <= 4; akind++) {
         for (bscale = 0; bscale >= -2; bscale--) {
         // Generate A, B and initial point
            ae_matrix_set_length(&a, n, n);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&x, n);
            for (i = 0; i < n; i++) {
               b.xR[i] = pow(10.0, (double)bscale) * hqrndnormal(&rs);
               x.xR[i] = 0.0;
            }
            isnonconvex = false;
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
            }
            if (akind == 1) {
            // Dense well conditioned SPD
               spdmatrixrndcond(n, 50.0, &a);
            }
            if (akind == 2) {
            // Dense well conditioned indefinite
               smatrixrndcond(n, 50.0, &a);
               isnonconvex = true;
            }
            if (akind == 3) {
            // Low rank
               ae_vector_set_length(&tmp, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               for (k = 1; k < imin2(4, n); k++) {
                  for (i = 0; i < n; i++) {
                     tmp.xR[i] = hqrndnormal(&rs);
                  }
                  v = pow(2.0, hqrndnormal(&rs));
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                     }
                  }
               }
            }
            if (akind == 4) {
            // Low rank indefinite
               ae_vector_set_length(&tmp, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               for (k = 1; k < imin2(4, n); k++) {
                  for (i = 0; i < n; i++) {
                     tmp.xR[i] = hqrndnormal(&rs);
                  }
                  v = hqrndnormal(&rs);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                     }
                  }
               }
               isnonconvex = true;
            }
         // Generate constraints
            ae_vector_set_length(&bl, n);
            ae_vector_set_length(&bu, n);
            for (i = 0; i < n; i++) {
               bl.xR[i] = -1.0;
               bu.xR[i] = 1.0;
            }
            ccnt = imin2(3, n - 1);
            ae_matrix_set_length(&c, ccnt, n + 1);
            ae_vector_set_length(&ct, ccnt);
            for (i = 0; i < ccnt; i++) {
               ct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
               c.xyR[i][n] = 0.0;
               for (j = 0; j < n; j++) {
                  c.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         // Create and optimize
            minqpcreate(n, &state);
            minqpsetstartingpoint(&state, &x);
            if (isnonconvex) {
               testminqpunit_setrandomalgononconvexlc(&state);
            } else {
               testminqpunit_setrandomalgoconvexlc(&state);
            }
            minqpsetbc(&state, &bl, &bu);
            minqpsetlc(&state, &c, &ct, ccnt);
            minqpsetlinearterm(&state, &b);
            minqpsetquadraticterm(&state, &a, randombool());
            minqpoptimize(&state);
            minqpresults(&state, &xs0, &rep);
            Ok = Ok && rep.terminationtype > 0;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // 1. evaluate unconstrained gradient at solution
         //
         // 2. calculate constrained gradient (NNLS solver is used
         //    to evaluate gradient subject to active constraints).
         //    In order to do this we form CE matrix, matrix of active
         //    constraints (columns store constraint vectors). Then
         //    we try to approximate gradient vector by columns of CE,
         //    subject to non-negativity restriction placed on variables
         //    corresponding to inequality constraints.
         //
         //    Residual from such regression is a constrained gradient vector.
            ae_vector_set_length(&g, n);
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xs0.xR, 1, n);
               g.xR[i] = v + b.xR[i];
            }
            ae_matrix_set_length(&ce, n, n + ccnt);
            ae_vector_set_length(&nonnegative, n + ccnt);
            k = 0;
            for (i = 0; i < n; i++) {
               Ok = Ok && xs0.xR[i] >= bl.xR[i];
               Ok = Ok && xs0.xR[i] <= bu.xR[i];
               if (xs0.xR[i] <= bl.xR[i] + tolconstr) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = 0.0;
                  }
                  ce.xyR[i][k] = 1.0;
                  nonnegative.xB[k] = true;
                  k++;
                  continue;
               }
               if (xs0.xR[i] >= bu.xR[i] - tolconstr) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = 0.0;
                  }
                  ce.xyR[i][k] = -1.0;
                  nonnegative.xB[k] = true;
                  k++;
                  continue;
               }
            }
            for (i = 0; i < ccnt; i++) {
               v = ae_v_dotproduct(c.xyR[i], 1, xs0.xR, 1, n);
               v -= c.xyR[i][n];
               Ok = Ok && (ct.xZ[i] != 0 || SmallAtR(v, tolconstr));
               Ok = Ok && (ct.xZ[i] <= 0 || v >= -tolconstr);
               Ok = Ok && (ct.xZ[i] >= 0 || v <= +tolconstr);
               if (ct.xZ[i] == 0) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = c.xyR[i][j];
                  }
                  nonnegative.xB[k] = false;
                  k++;
                  continue;
               }
               if (ct.xZ[i] > 0 && v <= tolconstr || ct.xZ[i] < 0 && v >= -tolconstr) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = sign((double)ct.xZ[i]) * c.xyR[i][j];
                  }
                  nonnegative.xB[k] = true;
                  k++;
                  continue;
               }
            }
            snnlsinit(0, 0, 0, &nnls);
            snnlssetproblem(&nnls, &ce, &g, 0, k, n);
            for (i = 0; i < k; i++) {
               if (!nonnegative.xB[i]) {
                  snnlsdropnnc(&nnls, i);
               }
            }
            snnlssolve(&nnls, &tmp);
            for (i = 0; i < k; i++) {
               for (j = 0; j < n; j++) {
                  g.xR[j] -= tmp.xR[i] * ce.xyR[j][i];
               }
            }
            vv = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
            vv = sqrt(vv);
            if (akind == 3 || akind == 4) {
               Ok = Ok && vv <= 1.0E-2;
            } else {
               Ok = Ok && vv <= 1.0E-3;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Randomly split constraints into dense and sparse parts
static void testminqpunit_randomlysplitlc(RMatrix *rawc, ZVector *rawct, ae_int_t rawccnt, ae_int_t n, sparsematrix *sparsec, ZVector *sparsect, ae_int_t *sparseccnt, RMatrix *densec, ZVector *densect, ae_int_t *denseccnt, hqrndstate *rs) {
   ae_int_t i;
   ae_int_t j;
   SetObj(sparsematrix, sparsec);
   SetVector(sparsect);
   *sparseccnt = 0;
   SetMatrix(densec);
   SetVector(densect);
   *denseccnt = 0;
// Split "raw" constraints into dense and sparse parts
   *sparseccnt = hqrnduniformi(rs, rawccnt + 1);
   *denseccnt = rawccnt - (*sparseccnt);
   if (*sparseccnt > 0) {
      sparsecreate(*sparseccnt, n + 1, 0, sparsec);
      ae_vector_set_length(sparsect, *sparseccnt);
      for (i = 0; i < *sparseccnt; i++) {
         for (j = 0; j <= n; j++) {
            sparseset(sparsec, i, j, rawc->xyR[i][j]);
         }
         sparsect->xZ[i] = rawct->xZ[i];
      }
   }
   if (*denseccnt > 0) {
      ae_matrix_set_length(densec, *denseccnt, n + 1);
      ae_vector_set_length(densect, *denseccnt);
      for (i = 0; i < *denseccnt; i++) {
         for (j = 0; j <= n; j++) {
            densec->xyR[i][j] = rawc->xyR[*sparseccnt + i][j];
         }
         densect->xZ[i] = rawct->xZ[*sparseccnt + i];
      }
   }
}

// Randomly split constraints into dense and sparse parts and set them;
// legacy API is used.
static void testminqpunit_randomlysplitandsetlclegacy(RMatrix *rawc, ZVector *rawct, ae_int_t rawccnt, ae_int_t n, minqpstate *state, hqrndstate *rs) {
   ae_frame _frame_block;
   ae_int_t denseccnt;
   ae_int_t sparseccnt;
   ae_frame_make(&_frame_block);
   NewMatrix(densec, 0, 0, DT_REAL);
   NewVector(densect, 0, DT_INT);
   NewObj(sparsematrix, sparsec);
   NewVector(sparsect, 0, DT_INT);
// reset constraints
   minqpsetlc(state, &densec, &densect, 0);
// split and set
   testminqpunit_randomlysplitlc(rawc, rawct, rawccnt, n, &sparsec, &sparsect, &sparseccnt, &densec, &densect, &denseccnt, rs);
   if (hqrnduniformr(rs) > 0.5 || denseccnt * sparseccnt > 0) {
      minqpsetlcmixed(state, &sparsec, &sparsect, sparseccnt, &densec, &densect, denseccnt);
   } else {
      if (denseccnt > 0) {
         minqpsetlc(state, &densec, &densect, denseccnt);
      }
      if (sparseccnt > 0) {
         minqpsetlcsparse(state, &sparsec, &sparsect, sparseccnt);
      }
   }
   ae_frame_leave();
}

// Randomly split 2-sided constraints into dense and sparse parts and set them;
static void testminqpunit_randomlysplitandsetlc2(RMatrix *rawc, RVector *rawcl, RVector *rawcu, ae_int_t rawccnt, ae_int_t n, minqpstate *state, hqrndstate *rs) {
   ae_frame _frame_block;
   ae_int_t denseccnt;
   ae_int_t sparseccnt;
   ae_int_t i;
   ae_int_t j;
   ae_int_t appenddense;
   ae_int_t appendsparse;
   ae_int_t nnz;
   ae_frame_make(&_frame_block);
   NewMatrix(densec, 0, 0, DT_REAL);
   NewVector(densecl, 0, DT_REAL);
   NewVector(densecu, 0, DT_REAL);
   NewObj(sparsematrix, sparsec);
   NewVector(sparsecl, 0, DT_REAL);
   NewVector(sparsecu, 0, DT_REAL);
   NewVector(wrkcl, 0, DT_REAL);
   NewVector(wrkcu, 0, DT_REAL);
   NewVector(cv, 0, DT_REAL);
   NewVector(ci, 0, DT_INT);
// reset constraints
   minqpsetlc2dense(state, &densec, &densecl, &densecu, 0);
// Split "raw" constraints into dense and sparse parts
   sparseccnt = hqrnduniformi(rs, rawccnt + 1);
   denseccnt = rawccnt - sparseccnt;
   appenddense = hqrnduniformi(rs, denseccnt + 1);
   denseccnt -= appenddense;
   appendsparse = hqrnduniformi(rs, sparseccnt + 1);
   sparseccnt -= appendsparse;
   ae_vector_set_length(&wrkcl, sparseccnt + denseccnt);
   ae_vector_set_length(&wrkcu, sparseccnt + denseccnt);
   if (sparseccnt > 0) {
      sparsecreate(sparseccnt, n, 0, &sparsec);
      ae_vector_set_length(&sparsecl, sparseccnt);
      ae_vector_set_length(&sparsecu, sparseccnt);
      for (i = 0; i < sparseccnt; i++) {
         for (j = 0; j < n; j++) {
            sparseset(&sparsec, i, j, rawc->xyR[i][j]);
         }
         sparsecl.xR[i] = rawcl->xR[i];
         sparsecu.xR[i] = rawcu->xR[i];
         wrkcl.xR[i] = sparsecl.xR[i];
         wrkcu.xR[i] = sparsecu.xR[i];
      }
   }
   if (denseccnt > 0) {
      ae_matrix_set_length(&densec, denseccnt, n);
      ae_vector_set_length(&densecl, denseccnt);
      ae_vector_set_length(&densecu, denseccnt);
      for (i = 0; i < denseccnt; i++) {
         for (j = 0; j < n; j++) {
            densec.xyR[i][j] = rawc->xyR[sparseccnt + appendsparse + i][j];
         }
         densecl.xR[i] = rawcl->xR[sparseccnt + appendsparse + i];
         densecu.xR[i] = rawcu->xR[sparseccnt + appendsparse + i];
         wrkcl.xR[sparseccnt + i] = densecl.xR[i];
         wrkcu.xR[sparseccnt + i] = densecu.xR[i];
      }
   }
// split and set
   if (hqrnduniformr(rs) > 0.5 || denseccnt * sparseccnt > 0) {
      minqpsetlc2mixed(state, &sparsec, sparseccnt, &densec, denseccnt, &wrkcl, &wrkcu);
   } else {
      if (denseccnt > 0) {
         minqpsetlc2dense(state, &densec, &densecl, &densecu, denseccnt);
      }
      if (sparseccnt > 0) {
         minqpsetlc2(state, &sparsec, &sparsecl, &sparsecu, sparseccnt);
      }
   }
   ae_vector_set_length(&cv, 2 * n);
   ae_vector_set_length(&ci, 2 * n);
   for (i = sparseccnt; i < sparseccnt + appendsparse; i++) {
   // Generate sparse representation
      nnz = 0;
      for (j = 0; j < n; j++) {
         if (rawc->xyR[i][j] != 0.0) {
            cv.xR[nnz] = rawc->xyR[i][j];
            ci.xZ[nnz] = j;
            nnz++;
         }
      }
   // Add duplicates which do not change constraint (after simplification)
      while (nnz > 0 && nnz < ci.cnt && hqrnduniformr(rs) < 0.75) {
         j = hqrnduniformi(rs, nnz);
         ci.xZ[nnz] = ci.xZ[j];
         cv.xR[nnz] = hqrndnormal(rs);
         cv.xR[j] -= cv.xR[nnz];
         nnz++;
      }
   // Add constraint to the set
      minqpaddlc2(state, &ci, &cv, nnz, rawcl->xR[i], rawcu->xR[i]);
   }
   for (i = rawccnt - appenddense; i < rawccnt; i++) {
      for (j = 0; j < n; j++) {
         cv.xR[j] = rawc->xyR[i][j];
      }
      minqpaddlc2dense(state, &cv, rawcl->xR[i], rawcu->xR[i]);
   }
   ae_frame_leave();
}

// Randomly selects triangle of full symmetric matrix, converts it to one of
// the matrix storage formats (dense or sparse) and sets.
static void testminqpunit_randomlyselectconvertandsetquadraticterm(RMatrix *a, ae_int_t n, minqpstate *state, hqrndstate *rs) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   bool isupper;
   bool isdense;
   ae_frame_make(&_frame_block);
   NewMatrix(densea, 0, 0, DT_REAL);
   NewObj(sparsematrix, sparsea);
   isupper = hqrnduniformr(rs) > 0.5;
   isdense = hqrnduniformr(rs) > 0.5;
   if (isupper && isdense) {
      ae_matrix_set_length(&densea, n, n);
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            densea.xyR[i][j] = a->xyR[i][j];
         }
      }
      minqpsetquadraticterm(state, &densea, isupper);
      ae_frame_leave();
      return;
   }
   if (!isupper && isdense) {
      ae_matrix_set_length(&densea, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j <= i; j++) {
            densea.xyR[i][j] = a->xyR[i][j];
         }
      }
      minqpsetquadraticterm(state, &densea, isupper);
      ae_frame_leave();
      return;
   }
   if (isupper && !isdense) {
      sparsecreate(n, n, 0, &sparsea);
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            sparseset(&sparsea, i, j, a->xyR[i][j]);
         }
      }
      minqpsetquadratictermsparse(state, &sparsea, isupper);
      ae_frame_leave();
      return;
   }
   if (!isupper && !isdense) {
      sparsecreate(n, n, 0, &sparsea);
      for (i = 0; i < n; i++) {
         for (j = 0; j <= i; j++) {
            sparseset(&sparsea, i, j, a->xyR[i][j]);
         }
      }
      minqpsetquadratictermsparse(state, &sparsea, isupper);
      ae_frame_leave();
      return;
   }
   ae_frame_leave();
}

// This function returns reciprocal of condition  number  of  general  linear
// constraints.
static double testminqpunit_getconstraintrcond(RMatrix *c, ae_int_t k, ae_int_t n) {
   ae_frame _frame_block;
   bool bflag;
   double result;
   ae_frame_make(&_frame_block);
   NewVector(svdw, 0, DT_REAL);
   NewMatrix(svdu, 0, 0, DT_REAL);
   NewMatrix(svdvt, 0, 0, DT_REAL);
   bflag = rmatrixsvd(c, k, n, 0, 0, 0, &svdw, &svdu, &svdvt);
   ae_assert(bflag, "MinQPTest: integrity failure");
   if (svdw.xR[0] > 0.0) {
      result = svdw.xR[imin2(k, n) - 1] / svdw.xR[0];
   } else {
      result = 1.0;
   }
   ae_frame_leave();
   return result;
}

// Computes target function 0.5*x'*H*x+c'*x
// ALGLIB: Copyright 01.11.2019 by Sergey Bochkanov
static double testminqpunit_quadratictarget(RMatrix *a, RVector *b, ae_int_t n, RVector *x) {
   ae_int_t i;
   ae_int_t j;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      result += b->xR[i] * x->xR[i];
      for (j = 0; j < n; j++) {
         result += 0.5 * x->xR[i] * a->xyR[i][j] * x->xR[j];
      }
   }
   return result;
}

// This function tests linearly constrained QP solvers.
static bool testminqpunit_generallcqptest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t solvertype;
   double v;
   double vv;
   bool bflag;
   ae_int_t pass;
   ae_int_t rawccnt;
   ae_int_t denseccnt;
   ae_int_t sparseccnt;
   ae_int_t nactive;
   double constraintsrcond;
   double f0;
   double f1;
   double xtol;
   double ftol;
   double gtol;
   double tolconstr;
   ae_int_t bscale;
   ae_int_t akind;
   double mx;
   ae_int_t shiftkind;
   ae_int_t nnz;
   bool issemidefinite;
   bool skiptest;
   double bleicepsx;
   double aulepsx;
   double aulrho;
   ae_int_t aulits;
   double ipmeps;
   double minushuge;
   double plushuge;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(rawa, 0, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewVector(b, 0, DT_REAL);
   NewVector(b2, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(xf, 0, DT_REAL);
   NewVector(xorigin, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(da, 0, DT_REAL);
   NewVector(xstart, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(gtrial, 0, DT_REAL);
   NewVector(gs, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(tmp1, 0, DT_REAL);
   NewVector(tmp2, 0, DT_REAL);
   NewVector(lagrange, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(rawc, 0, 0, DT_REAL);
   NewVector(rawcl, 0, DT_REAL);
   NewVector(rawcu, 0, DT_REAL);
   NewVector(rawct, 0, DT_INT);
   NewMatrix(densec, 0, 0, DT_REAL);
   NewVector(densect, 0, DT_INT);
   NewObj(sparsematrix, sparsec);
   NewVector(sparsect, 0, DT_INT);
   NewMatrix(activeset, 0, 0, DT_REAL);
   NewVector(activeeq, 0, DT_BOOL);
   NewObj(snnlssolver, nnls);
   NewVector(svdw, 0, DT_REAL);
   NewMatrix(svdu, 0, 0, DT_REAL);
   NewMatrix(svdvt, 0, 0, DT_REAL);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   NewObj(minqpstate, state2);
   NewObj(minqpreport, rep2);
   NewMatrix(ce, 0, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(t2, 0, 0, DT_REAL);
   NewMatrix(t3, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewVector(lagbc, 0, DT_REAL);
   NewVector(laglc, 0, DT_REAL);
   NewVector(nonnegative, 0, DT_BOOL);
   NewMatrix(kkt, 0, 0, DT_REAL);
   NewVector(kktright, 0, DT_REAL);
   hqrndrandomize(&rs);
   bleicepsx = 1.0E-9;
   ipmeps = 1.0E-12;
   aulepsx = 1.0E-12;
   aulrho = 1.0E3;
   aulits = 15;
// SMALL-SCALE TESTS: many tests for small N's
   for (solvertype = 0; solvertype <= 3; solvertype++) {
   // Test random linearly constrained convex QP problem with known answer:
   // * generate random A and b
   // * generate random solution XS
   // * calculate unconstrained gradient GS at XS
   // * generate random box/linear constraints C, with some of them being
   //   active at XS, and some being inactive. Calculate residual gradient
   //   GP after projection of GS onto active set, add one more constraint
   //   equal to +-(GP-GS).
   //
   // We test here BLEIC and Dense-AUL solvers, with A being passed
   // in dense or sparse format, and linear constraints C being passed
   // as dense, sparse or mixed ones.
      for (n = 1; n <= 10; n++) {
      // Generate random A, b and xs
         spdmatrixrndcond(n, pow(10.0, 2.0 * randomreal()), &rawa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xs, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            xs.xR[i] = hqrndnormal(&rs);
         }
      // Generate well conditioned "raw" constraints:
      // * generate random box and CCnt-1 linear constraints
      // * determine active set, calculate its condition number
      // * repeat until condition number is good enough
      //   (better than 1E2; larger values sometimes result in
      //   spurious failures)
         ae_vector_set_length(&gs, n);
         ae_vector_set_length(&tmp, n);
         rmatrixmv(n, n, &rawa, 0, 0, 0, &xs, 0, &gs, 0);
         for (i = 0; i < n; i++) {
            gs.xR[i] += b.xR[i];
         }
         rawccnt = 1 + hqrnduniformi(&rs, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_matrix_set_length(&activeset, n, n + rawccnt);
         ae_vector_set_length(&activeeq, n + rawccnt);
         ae_matrix_set_length(&rawc, rawccnt, n + 1);
         ae_vector_set_length(&rawct, rawccnt);
         do {
            nactive = 0;
            for (i = 0; i < n; i++) {
               bndl.xR[i] = xs.xR[i] - 1.0 - hqrnduniformr(&rs);
               bndu.xR[i] = xs.xR[i] + 1.0 + hqrnduniformr(&rs);
               if (hqrnduniformr(&rs) < 0.66) {
               // I-th box constraint is inactive
                  continue;
               }
               if (hqrnduniformr(&rs) > 0.50) {
               // I-th box constraint is equality one
                  bndl.xR[i] = xs.xR[i];
                  bndu.xR[i] = xs.xR[i];
                  for (j = 0; j < n; j++) {
                     activeset.xyR[j][nactive] = 0.0;
                  }
                  activeset.xyR[i][nactive] = 1.0;
                  activeeq.xB[nactive] = true;
                  nactive++;
               } else {
               // I-th box constraint is inequality one
                  for (j = 0; j < n; j++) {
                     activeset.xyR[j][nactive] = 0.0;
                  }
                  if (gs.xR[i] > 0.0) {
                     bndl.xR[i] = xs.xR[i];
                     activeset.xyR[i][nactive] = -1.0;
                     if (hqrnduniformr(&rs) > 0.50) {
                        bndu.xR[i] = +INFINITY;
                     }
                  } else {
                     bndu.xR[i] = xs.xR[i];
                     activeset.xyR[i][nactive] = 1.0;
                     if (hqrnduniformr(&rs) > 0.50) {
                        bndl.xR[i] = -INFINITY;
                     }
                  }
                  activeeq.xB[nactive] = false;
                  nactive++;
               }
            }
            for (i = 0; i < rawccnt - 1; i++) {
               for (j = 0; j < n; j++) {
                  if (hqrnduniformr(&rs) < 0.50) {
                     rawc.xyR[i][j] = hqrndnormal(&rs);
                  } else {
                     rawc.xyR[i][j] = 0.0;
                  }
               }
               rawc.xyR[i][hqrnduniformi(&rs, n)] = hqrndnormal(&rs);
               rawc.xyR[i][n] = 0.0;
               for (j = 0; j < n; j++) {
                  rawc.xyR[i][n] += rawc.xyR[i][j] * xs.xR[j];
               }
               rawct.xZ[i] = -1;
               if (hqrnduniformr(&rs) < 0.66) {
               // I-th box constraint is inactive
                  rawc.xyR[i][n] += (1.0 + hqrnduniformr(&rs));
                  if (hqrnduniformr(&rs) > 0.50) {
                     ae_v_muld(rawc.xyR[i], 1, n + 1, -1);
                     rawct.xZ[i] = -rawct.xZ[i];
                  }
                  continue;
               }
               if (hqrnduniformr(&rs) > 0.50) {
               // I-th box constraint is equality one
                  rawct.xZ[i] = 0;
                  for (j = 0; j < n; j++) {
                     activeset.xyR[j][nactive] = rawc.xyR[i][j];
                  }
                  activeeq.xB[nactive] = true;
                  nactive++;
               } else {
               // I-th box constraint is inequality one
                  v = ae_v_dotproduct(rawc.xyR[i], 1, gs.xR, 1, n);
                  if (v > 0.0) {
                     rawct.xZ[i] = 1;
                     for (j = 0; j < n; j++) {
                        activeset.xyR[j][nactive] = -rawc.xyR[i][j];
                     }
                  } else {
                     rawct.xZ[i] = -1;
                     for (j = 0; j < n; j++) {
                        activeset.xyR[j][nactive] = rawc.xyR[i][j];
                     }
                  }
                  activeeq.xB[nactive] = false;
                  nactive++;
               }
            }
            ae_v_moveneg(tmp.xR, 1, gs.xR, 1, n);
            snnlsinit(0, 0, 0, &nnls);
            snnlssetproblem(&nnls, &activeset, &tmp, 0, nactive, n);
            for (i = 0; i < nactive; i++) {
               if (activeeq.xB[i]) {
                  snnlsdropnnc(&nnls, i);
               }
            }
            snnlssolve(&nnls, &lagrange);
            ae_v_moveneg(tmp.xR, 1, gs.xR, 1, n);
            for (i = 0; i < nactive; i++) {
               v = lagrange.xR[i];
               ae_v_subd(tmp.xR, 1, &activeset.xyR[0][i], activeset.stride, n, v);
            }
            ae_v_move(rawc.xyR[rawccnt - 1], 1, tmp.xR, 1, n);
            v = ae_v_dotproduct(tmp.xR, 1, xs.xR, 1, n);
            rawc.xyR[rawccnt - 1][n] = v;
            rawct.xZ[rawccnt - 1] = -1;
         // Calculate reciprocal condition number
            if (nactive > 0) {
               bflag = rmatrixsvd(&activeset, n, nactive, 0, 0, 0, &svdw, &svdu, &svdvt);
               ae_assert(bflag, "MinQPTest: integrity failure");
               constraintsrcond = svdw.xR[imin2(nactive, n) - 1] / svdw.xR[0];
            } else {
               constraintsrcond = 1.0;
            }
         // Check RCond
         } while (constraintsrcond < 0.01 || nactive >= n);
      // Create optimizer, solve
         minqpcreate(n, &state);
         if (solvertype == 0) {
            minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
         } else {
            if (solvertype == 1) {
               minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
            } else {
               if (solvertype == 2) {
                  minqpsetalgodenseipm(&state, ipmeps);
               } else {
                  if (solvertype == 3) {
                     minqpsetalgosparseipm(&state, ipmeps);
                  } else {
                     ae_assert(false, "unexpected solver type");
                  }
               }
            }
         }
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
         minqpsetbc(&state, &bndl, &bndu);
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
      // Test
      //
      // Because constrained problems are often ill-conditioned,
      // we do NOT compare X1 with XS directly. Instead, we:
      // a) compare function values at X1 and XS with good precision
      // b) check constraint violation with good precision
      // c) perform comparison for |X1-XS| with LOW precision
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         f0 = 0.0;
         f1 = 0.0;
         for (i = 0; i < n; i++) {
            f0 += b.xR[i] * xs.xR[i];
            f1 += b.xR[i] * x1.xR[i];
            for (j = 0; j < n; j++) {
               f0 += 0.5 * xs.xR[i] * rawa.xyR[i][j] * xs.xR[j];
               f1 += 0.5 * x1.xR[i] * rawa.xyR[i][j] * x1.xR[j];
            }
         }
         Ok = Ok && NearAtR(f0, f1, 1.0E-3);
      }
   // Inequality constrained convex problem:
   // * N*N diagonal A
   // * one inequality constraint q'*x >= 0, where q is random unit vector
   // * optimization problem has form 0.5*x'*A*x-(xs*A)*x,
   //   where xs is some random vector
   // * either:
   //   a) xs is feasible => we must stop at xs
   //   b) xs is infeasible => we must stop at the boundary q'*x == 0 and
   //      projection of gradient onto q*x == 0 must be zero
   //
   // NOTE: we make several passes because some specific kind of errors is rarely
   //       caught by this test, so we need several repetitions.
      xtol = 1.0E-4;
      gtol = 1.0E-4;
      for (n = 2; n <= 6; n++) {
         for (pass = 0; pass <= 4; pass++) {
         // Generate problem: A, b, CMatrix, x0, XStart
            spdmatrixrndcond(n, pow(10.0, 3.0 * randomreal()), &a);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&xs, n);
            ae_vector_set_length(&xstart, n);
            ae_matrix_set_length(&rawc, 1, n + 1);
            ae_vector_set_length(&rawct, 1);
            for (i = 0; i < n; i++) {
               xs.xR[i] = randommid();
               xstart.xR[i] = randommid();
            }
            do {
               v = 0.0;
               for (i = 0; i < n; i++) {
                  rawc.xyR[0][i] = randommid();
                  v += sqr(rawc.xyR[0][i]);
               }
               v = sqrt(v);
            } while (v == 0.0);
            for (i = 0; i < n; i++) {
               rawc.xyR[0][i] /= v;
            }
            rawc.xyR[0][n] = 0.0;
            rawct.xZ[0] = 1;
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xs.xR, 1, n);
               b.xR[i] = -v;
            }
         // Create optimizer, solve
            minqpcreate(n, &state);
            if (solvertype == 0) {
               minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
            } else {
               if (solvertype == 1) {
                  minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
               } else {
                  if (solvertype == 2) {
                     minqpsetalgodenseipm(&state, ipmeps);
                  } else {
                     if (solvertype == 3) {
                        minqpsetalgosparseipm(&state, ipmeps);
                     } else {
                        ae_assert(false, "unexpected solver type");
                     }
                  }
               }
            }
            minqpsetlinearterm(&state, &b);
            testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
            minqpsetstartingpoint(&state, &xstart);
            testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, 1, n, &state, &rs);
            minqpoptimize(&state);
            minqpresults(&state, &x1, &rep);
         // Test
            if (rep.terminationtype <= 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            v = ae_v_dotproduct(xs.xR, 1, rawc.xyR[0], 1, n);
            if (v >= 0.0) {
            // XS is feasible
               for (i = 0; i < n; i++) {
                  Ok = Ok && NearAtR(x1.xR[i], xs.xR[i], xtol);
               }
            } else {
            // XS is infeasible:
            // * X1 must be approximately feasible
            // * gradient projection onto c'*x == 0 must be zero
               v = ae_v_dotproduct(x1.xR, 1, rawc.xyR[0], 1, n);
               Ok = Ok && v >= -xtol;
               ae_vector_set_length(&g, n);
               ae_v_move(g.xR, 1, b.xR, 1, n);
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
                  g.xR[i] += v;
               }
               v = ae_v_dotproduct(g.xR, 1, rawc.xyR[0], 1, n);
               ae_v_subd(g.xR, 1, rawc.xyR[0], 1, n, v);
               v = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
               Ok = Ok && sqrt(v) <= gtol;
            }
         }
      }
   // Box constraints vs linear ones:
   // * N*N SPD A
   // * optimization problem has form 0.5*x'*A*x-(x1*A)*x,
   //   where x1 is some random vector from [-1,+1]
   // * K == 2*N constraints of the form ai <= x[i] or x[i] <= b[i],
   //   with ai in [-1.0,-0.1], bi in [+0.1,+1.0]
   // * initial point xstart is from [-1,+2]
   // * we solve two related QP problems:
   //   a) one with constraints posed as boundary ones
   //   b) another one with same constraints posed as general linear ones
   // both problems must have same solution.
   // Here we test that boundary constrained and linear inequality constrained
   // solvers give same results.
      xtol = 1.0E-5;
      for (n = 1; n <= 6; n++) {
      // Generate problem: A, b, x0, XStart, C, CT
         spdmatrixrndcond(n, pow(10.0, 3.0 * randomreal()), &a);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&rawc, 2 * n, n + 1);
         ae_vector_set_length(&rawct, 2 * n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            x1.xR[i] = randommid();
            xstart.xR[i] = 3.0 * randomreal() - 1.0;
            bndl.xR[i] = -(0.1 + 0.9 * randomreal());
            bndu.xR[i] = 0.1 + 0.9 * randomreal();
            for (j = 0; j < n; j++) {
               rawc.xyR[2 * i][j] = 0.0;
               rawc.xyR[2 * i + 1][j] = 0.0;
            }
            rawc.xyR[2 * i][i] = 1.0;
            rawc.xyR[2 * i][n] = bndl.xR[i];
            rawct.xZ[2 * i] = 1;
            rawc.xyR[2 * i + 1][i] = 1.0;
            rawc.xyR[2 * i + 1][n] = bndu.xR[i];
            rawct.xZ[2 * i + 1] = -1;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
            b.xR[i] = -v;
         }
      // Solve linear inequality constrained problem
         minqpcreate(n, &state);
         if (solvertype == 0) {
            minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
         } else {
            if (solvertype == 1) {
               minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
            } else {
               if (solvertype == 2) {
                  minqpsetalgodenseipm(&state, ipmeps);
               } else {
                  if (solvertype == 3) {
                     minqpsetalgosparseipm(&state, ipmeps);
                  } else {
                     ae_assert(false, "unexpected solver type");
                  }
               }
            }
         }
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
         minqpsetstartingpoint(&state, &xstart);
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, 2 * n, n, &state, &rs);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
      // Solve boundary constrained problem
         minqpcreate(n, &state2);
         if (solvertype == 0) {
            minqpsetalgobleic(&state2, 0.0, 0.0, bleicepsx, 0);
         } else {
            if (solvertype == 1) {
               minqpsetalgodenseaul(&state2, aulepsx, aulrho, aulits);
            } else {
               if (solvertype == 2) {
                  minqpsetalgodenseipm(&state2, ipmeps);
               } else {
                  if (solvertype == 3) {
                     minqpsetalgosparseipm(&state2, ipmeps);
                  } else {
                     ae_assert(false, "unexpected solver type");
                  }
               }
            }
         }
         minqpsetlinearterm(&state2, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state2, &rs);
         minqpsetstartingpoint(&state2, &xstart);
         minqpsetbc(&state2, &bndl, &bndu);
         minqpoptimize(&state2);
         minqpresults(&state2, &x2, &rep2);
      // Calculate gradient, check projection
         if (rep.terminationtype <= 0 || rep2.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && x1.xR[i] >= bndl.xR[i] - xtol;
            Ok = Ok && x1.xR[i] <= bndu.xR[i] + xtol;
            Ok = Ok && NearAtR(x1.xR[i], x2.xR[i], xtol);
         }
      }
   // Convex/nonconvex optimization problem with combination of
   // box and linear constraints:
   //
   // * N = 2..8
   // * f = 0.5*x'*A*x+b'*x
   // * b has normally distributed entries with scale 10^BScale
   // * several kinds of A are tried: zero, well conditioned SPD,
   //   well conditioned indefinite, low rank
   // * box constraints: x[i] in [-1,+1]
   // * initial point x0 = [0 0 ... 0 0]
   // * CCnt == min(3,N-1) general linear constraints of form (c,x) == 0.
   //   random mix of equality/inequality constraints is tried, moderate
   //   condition number is guaranteed, x0 is guaranteed to be feasible.
   //
   // We check that constrained gradient is close to zero at solution.
   // Inequality constraint is considered active if distance to boundary
   // is less than TolConstr. We use nonnegative least squares solver
   // in order to compute constrained gradient.
      tolconstr = -99999.0;
      for (n = 2; n <= 8; n++) {
         for (akind = 0; akind <= 4; akind++) {
            for (bscale = 1; bscale >= -1; bscale--) {
            // Dense-AUL solver has lower precision on rank-deficient
            // problems, so we skip AKind == 3.
            //
            // IPM solvers can not work with indefinite problems.
               if (solvertype == 1 && akind == 3) {
                  continue;
               }
               if ((solvertype == 2 || solvertype == 3) && (akind == 2 || akind == 4)) {
                  continue;
               }
            // Set up tolerances
               if (solvertype == 0) {
                  tolconstr = 1.0E-8;
               } else {
                  if (solvertype == 1 || solvertype == 2 || solvertype == 3) {
                     tolconstr = 1.0E-3;
                     if (akind == 3) {
                        tolconstr *= 5;
                     }
                  } else {
                     ae_assert(false, "unexpected solver type");
                  }
               }
               gtol = 1.0E-4;
            // Generate A, B and initial point
               ae_matrix_set_length(&a, n, n);
               ae_vector_set_length(&b, n);
               ae_vector_set_length(&xstart, n);
               for (i = 0; i < n; i++) {
                  b.xR[i] = pow(10.0, (double)bscale) * hqrndnormal(&rs);
                  xstart.xR[i] = 0.0;
               }
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               if (akind == 1) {
               // Dense well conditioned SPD
                  spdmatrixrndcond(n, 50.0, &a);
               }
               if (akind == 2) {
               // Dense well conditioned indefinite
                  smatrixrndcond(n, 50.0, &a);
               }
               if (akind == 3) {
               // Low rank semidefinite
                  ae_vector_set_length(&tmp, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = 0.0;
                     }
                  }
                  for (k = 1; k < imin2(4, n); k++) {
                     for (i = 0; i < n; i++) {
                        tmp.xR[i] = hqrndnormal(&rs);
                     }
                     v = pow(2.0, hqrndnormal(&rs));
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                        }
                     }
                  }
               }
               if (akind == 4) {
               // Low rank indefinite
                  ae_vector_set_length(&tmp, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = 0.0;
                     }
                  }
                  for (k = 1; k < imin2(4, n); k++) {
                     for (i = 0; i < n; i++) {
                        tmp.xR[i] = hqrndnormal(&rs);
                     }
                     v = hqrndnormal(&rs);
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                        }
                     }
                  }
               }
            // Generate constraints
               ae_vector_set_length(&bndl, n);
               ae_vector_set_length(&bndu, n);
               for (i = 0; i < n; i++) {
                  bndl.xR[i] = -1.0;
                  bndu.xR[i] = 1.0;
               }
               rawccnt = imin2(3, n - 1);
               ae_matrix_set_length(&rawc, rawccnt, n + 1);
               ae_vector_set_length(&rawct, rawccnt);
               do {
                  for (i = 0; i < rawccnt; i++) {
                     rawct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
                     rawc.xyR[i][n] = 0.0;
                     for (j = 0; j < n; j++) {
                        rawc.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                     }
                  }
               } while (testminqpunit_getconstraintrcond(&rawc, rawccnt, n) <= 0.01);
            // Create and optimize
               minqpcreate(n, &state);
               minqpsetstartingpoint(&state, &xstart);
               if (solvertype == 0) {
                  minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
               } else {
                  if (solvertype == 1) {
                     minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
                  } else {
                     if (solvertype == 2) {
                        minqpsetalgodenseipm(&state, ipmeps);
                     } else {
                        if (solvertype == 3) {
                           minqpsetalgosparseipm(&state, ipmeps);
                        } else {
                           ae_assert(false, "unexpected solver type");
                        }
                     }
                  }
               }
               minqpsetbc(&state, &bndl, &bndu);
               testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
               minqpsetlinearterm(&state, &b);
               testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
               minqpoptimize(&state);
               minqpresults(&state, &x1, &rep);
               Ok = Ok && rep.terminationtype > 0;
               if (!Ok) {
                  ae_frame_leave();
                  return Ok;
               }
            // 1. evaluate unconstrained gradient at solution
            //
            // 2. calculate constrained gradient (NNLS solver is used
            //    to evaluate gradient subject to active constraints).
            //    In order to do this we form CE matrix, matrix of active
            //    constraints (columns store constraint vectors). Then
            //    we try to approximate gradient vector by columns of CE,
            //    subject to non-negativity restriction placed on variables
            //    corresponding to inequality constraints.
            //
            //    Residual from such regression is a constrained gradient vector.
               ae_vector_set_length(&g, n);
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
                  g.xR[i] = v + b.xR[i];
               }
               ae_matrix_set_length(&ce, n, n + rawccnt);
               ae_vector_set_length(&nonnegative, n + rawccnt);
               k = 0;
               for (i = 0; i < n; i++) {
                  Ok = Ok && x1.xR[i] >= bndl.xR[i];
                  Ok = Ok && x1.xR[i] <= bndu.xR[i];
                  if (x1.xR[i] <= bndl.xR[i] + tolconstr) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = 0.0;
                     }
                     ce.xyR[i][k] = 1.0;
                     nonnegative.xB[k] = true;
                     k++;
                     continue;
                  }
                  if (x1.xR[i] >= bndu.xR[i] - tolconstr) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = 0.0;
                     }
                     ce.xyR[i][k] = -1.0;
                     nonnegative.xB[k] = true;
                     k++;
                     continue;
                  }
               }
               for (i = 0; i < rawccnt; i++) {
                  v = ae_v_dotproduct(rawc.xyR[i], 1, x1.xR, 1, n);
                  v -= rawc.xyR[i][n];
                  Ok = Ok && (rawct.xZ[i] != 0 || SmallAtR(v, tolconstr));
                  Ok = Ok && (rawct.xZ[i] <= 0 || v >= -tolconstr);
                  Ok = Ok && (rawct.xZ[i] >= 0 || v <= +tolconstr);
                  if (rawct.xZ[i] == 0) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = rawc.xyR[i][j];
                     }
                     nonnegative.xB[k] = false;
                     k++;
                     continue;
                  }
                  if (rawct.xZ[i] > 0 && v <= tolconstr || rawct.xZ[i] < 0 && v >= -tolconstr) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = sign((double)rawct.xZ[i]) * rawc.xyR[i][j];
                     }
                     nonnegative.xB[k] = true;
                     k++;
                     continue;
                  }
               }
               snnlsinit(0, 0, 0, &nnls);
               snnlssetproblem(&nnls, &ce, &g, 0, k, n);
               for (i = 0; i < k; i++) {
                  if (!nonnegative.xB[i]) {
                     snnlsdropnnc(&nnls, i);
                  }
               }
               snnlssolve(&nnls, &tmp);
               for (i = 0; i < k; i++) {
                  for (j = 0; j < n; j++) {
                     g.xR[j] -= tmp.xR[i] * ce.xyR[j][i];
                  }
               }
               vv = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
               vv = sqrt(vv);
               Ok = Ok && vv <= gtol;
            }
         }
      }
   // Boundary and linear equality/inequality constrained QP problem,
   // test for correct handling of non-zero XOrigin:
   // * N*N SPD A with moderate condtion number (up to 100)
   // * boundary constraints 0 <= x[i] <= 1
   // * K < N linear equality/inequality constraints Q*x = Q*x0, where
   //   Q is random orthogonal K*N matrix, x0 is some random vector from the
   //   inner area of the feasible hypercube (0.1 <= x0[i] <= 0.9)
   // * optimization problem has form 0.5*(x-xorigin)'*A*(x-xorigin)+b*(x-xorigin),
   //   where b is some random vector with -1 <= b[i] <= +1.
   //   (sometimes solution is in the inner area, sometimes at the boundary)
   // * every component of the initial point XStart is random from [-1,1]
   //
   // Solution of such problem is calculated using two methods:
   // a) QP with SetOrigin() call
   // b) QP with XOrigin explicitly added to the quadratic function,
   //
   // Both methods should give same results; any significant difference is
   // evidence of some error in the QP implementation.
      ftol = -99999.0;
      xtol = -99999.0;
      for (n = 2; n <= 6; n++) {
         for (k = 1; k < n; k++) {
         // Set up tolerances
            if (solvertype == 0) {
               ftol = 1.0E-5;
               xtol = 1.0E-5;
            } else {
               if (solvertype == 1 || solvertype == 2 || solvertype == 3) {
                  ftol = 1.0E-3;
                  xtol = 1.0E-3;
               } else {
                  ae_assert(false, "unexpected solver type");
               }
            }
         // Generate problem: A, b, BndL, BndU, CMatrix, x0, x1, XStart.
         // Additionally, we compute modified b: b2 = b-xorigin'*A
            rmatrixrndorthogonal(n, &q);
            spdmatrixrndcond(n, pow(10.0, 2.0 * randomreal()), &a);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&b2, n);
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&x1, n);
            ae_vector_set_length(&xorigin, n);
            ae_vector_set_length(&xstart, n);
            ae_matrix_set_length(&rawc, k, n + 1);
            ae_vector_set_length(&rawct, k);
            for (i = 0; i < n; i++) {
               x0.xR[i] = 0.1 + 0.8 * randomreal();
               b.xR[i] = randommid();
               bndl.xR[i] = 0.0;
               bndu.xR[i] = 1.0;
               xstart.xR[i] = (double)randominteger(2);
               xorigin.xR[i] = randommid();
            }
            for (i = 0; i < k; i++) {
               ae_v_move(rawc.xyR[i], 1, q.xyR[i], 1, n);
               v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
               rawc.xyR[i][n] = v;
               rawct.xZ[i] = randominteger(3) - 1;
            }
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xorigin.xR, 1, n);
               b2.xR[i] = b.xR[i] - v;
            }
         // Solve with SetOrigin() call
            minqpcreate(n, &state);
            if (solvertype == 0) {
               minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
            } else {
               if (solvertype == 1) {
                  minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
               } else {
                  if (solvertype == 2) {
                     minqpsetalgodenseipm(&state, ipmeps);
                  } else {
                     if (solvertype == 3) {
                        minqpsetalgosparseipm(&state, ipmeps);
                     } else {
                        ae_assert(false, "unexpected solver type");
                     }
                  }
               }
            }
            minqpsetlinearterm(&state, &b);
            testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
            minqpsetstartingpoint(&state, &xstart);
            minqpsetorigin(&state, &xorigin);
            minqpsetbc(&state, &bndl, &bndu);
            testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, k, n, &state, &rs);
            minqpoptimize(&state);
            minqpresults(&state, &x1, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               continue;
            }
         // Solve problem using explicit origin
            minqpcreate(n, &state2);
            if (solvertype == 0) {
               minqpsetalgobleic(&state2, 0.0, 0.0, bleicepsx, 0);
            } else {
               if (solvertype == 1) {
                  minqpsetalgodenseaul(&state2, aulepsx, aulrho, aulits);
               } else {
                  if (solvertype == 2) {
                     minqpsetalgodenseipm(&state2, ipmeps);
                  } else {
                     if (solvertype == 3) {
                        minqpsetalgosparseipm(&state2, ipmeps);
                     } else {
                        ae_assert(false, "unexpected solver type");
                     }
                  }
               }
            }
            minqpsetlinearterm(&state2, &b2);
            testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state2, &rs);
            minqpsetstartingpoint(&state2, &xstart);
            minqpsetbc(&state2, &bndl, &bndu);
            testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, k, n, &state2, &rs);
            minqpoptimize(&state2);
            minqpresults(&state2, &x2, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               continue;
            }
         // Calculate function value at X1/X2.
         // Compare solutions.
            f0 = 0.0;
            f1 = 0.0;
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  f0 += 0.5 * (x1.xR[i] - xorigin.xR[i]) * a.xyR[i][j] * (x1.xR[j] - xorigin.xR[j]);
                  f1 += 0.5 * (x2.xR[i] - xorigin.xR[i]) * a.xyR[i][j] * (x2.xR[j] - xorigin.xR[j]);
               }
               f0 += (x1.xR[i] - xorigin.xR[i]) * b.xR[i];
               f1 += (x2.xR[i] - xorigin.xR[i]) * b.xR[i];
            }
            Ok = Ok && NearAtR(f0, f1, ftol);
            for (i = 0; i < n; i++) {
               Ok = Ok && NearAtR(x1.xR[i], x2.xR[i], xtol);
            }
         }
      }
   // Test scale-invariance. Solver performs same steps on scaled and
   // unscaled problems (assuming that scale of the variables is known
   // and is 2^k for some integer k; latter guarantees that DENSE-AUL solver
   // performs EXACTLY same steps even under finite-precision arithmetics).
   //
   // We generate random scale matrix S and random well-conditioned and
   // well scaled matrix A. Then we solve two problems:
   //
   //     (1) f = 0.5*x'*A*x+b'*x
   //         (identity scale matrix is used)
   //
   // and
   //
   //     (2) f = 0.5*y'*(inv(S)*A*inv(S))*y + (inv(S)*b)'*y
   //         (scale matrix S is used)
   //
   // with correspondingly scaled constraints, origin and starting point.
   //
   // As result, we must get S*x == y
      for (n = 2; n <= 6; n++) {
         for (k = 1; k < imax2(n - 1, 2); k++) {
         // Set up tolerances:
         // * BLEIC or IPM do not guarantee that we perform steps exactly even
         //   when scale is 2^k, so we use non-zero XTol == 1E-3
         // * DENSE-AUL provides such guarantee, so XTol == 0
            if (solvertype == 0 || solvertype == 2 || solvertype == 3) {
               xtol = 1.0E-3;
            } else {
               if (solvertype == 1) {
                  xtol = 0.0;
               } else {
                  ae_assert(false, "unexpected solver type");
               }
            }
         // Generate "raw" problem: A, b, BndL, BndU, C/CT, XOrigin, XStart.
         // Solve it immediately.
         //
         // NOTE: we make sure that there exists at least one feasible point X0.
            spdmatrixrndcond(n, pow(10.0, 2.0 * randomreal()), &a);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&xstart, n);
            ae_vector_set_length(&xorigin, n);
            ae_matrix_set_length(&rawc, k, n + 1);
            ae_vector_set_length(&rawct, k);
            for (i = 0; i < n; i++) {
               x0.xR[i] = hqrnduniformr(&rs) - 0.5;
               b.xR[i] = hqrndnormal(&rs);
               bndl.xR[i] = -1.0 - hqrnduniformr(&rs);
               bndu.xR[i] = +1.0 + hqrnduniformr(&rs);
               xstart.xR[i] = hqrndnormal(&rs);
               xorigin.xR[i] = hqrndnormal(&rs);
            }
            for (i = 0; i < k; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  rawc.xyR[i][j] = hqrndnormal(&rs);
                  v += rawc.xyR[i][j] * x0.xR[j];
               }
               rawc.xyR[i][n] = v;
               rawct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
               if (rawct.xZ[i] < 0) {
                  rawc.xyR[i][n] += 0.1;
               }
               if (rawct.xZ[i] > 0) {
                  rawc.xyR[i][n] -= 0.1;
               }
            }
            testminqpunit_randomlysplitlc(&rawc, &rawct, k, n, &sparsec, &sparsect, &sparseccnt, &densec, &densect, &denseccnt, &rs);
            minqpcreate(n, &state);
            state.dbgskipconstraintnormalization = true;
            if (solvertype == 0) {
               minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
            } else {
               if (solvertype == 1) {
                  minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
               } else {
                  if (solvertype == 2) {
                     minqpsetalgodenseipm(&state, ipmeps);
                  } else {
                     if (solvertype == 3) {
                        minqpsetalgosparseipm(&state, ipmeps);
                     } else {
                        ae_assert(false, "unexpected solver type");
                     }
                  }
               }
            }
            minqpsetlinearterm(&state, &b);
            testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
            minqpsetstartingpoint(&state, &xstart);
            minqpsetorigin(&state, &xorigin);
            minqpsetbc(&state, &bndl, &bndu);
            minqpsetlcmixed(&state, &sparsec, &sparsect, sparseccnt, &densec, &densect, denseccnt);
            minqpoptimize(&state);
            minqpresults(&state, &x1, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               continue;
            }
         // Scale problem and solve one more time.
         // Randomly choose between dense and sparse versions.
            ae_vector_set_length(&s, n);
            for (i = 0; i < n; i++) {
               s.xR[i] = pow(2.0, (double)(hqrnduniformi(&rs, 7) - 3));
            }
            akind = hqrnduniformi(&rs, 2);
            if (akind == 0) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] /= s.xR[i] * s.xR[j];
                  }
               }
            } else {
               sparsecreate(n, n, 0, &sa);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     sparseset(&sa, i, j, a.xyR[i][j] / (s.xR[i] * s.xR[j]));
                  }
               }
            }
            for (i = 0; i < n; i++) {
               b.xR[i] /= s.xR[i];
               xstart.xR[i] *= s.xR[i];
               xorigin.xR[i] *= s.xR[i];
               bndl.xR[i] *= s.xR[i];
               bndu.xR[i] *= s.xR[i];
            }
            for (i = 0; i < denseccnt; i++) {
               for (j = 0; j < n; j++) {
                  densec.xyR[i][j] /= s.xR[j];
               }
            }
            for (i = 0; i < sparseccnt; i++) {
               for (j = 0; j < n; j++) {
                  sparseset(&sparsec, i, j, sparseget(&sparsec, i, j) / s.xR[j]);
               }
            }
            minqpcreate(n, &state);
            state.dbgskipconstraintnormalization = true;
            if (solvertype == 0) {
               minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
            } else {
               if (solvertype == 1) {
                  minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
               } else {
                  if (solvertype == 2) {
                     minqpsetalgodenseipm(&state, ipmeps);
                  } else {
                     if (solvertype == 3) {
                        minqpsetalgosparseipm(&state, ipmeps);
                     } else {
                        ae_assert(false, "unexpected solver type");
                     }
                  }
               }
            }
            minqpsetlinearterm(&state, &b);
            if (akind == 0) {
               minqpsetquadraticterm(&state, &a, randombool());
            }
            if (akind == 1) {
               minqpsetquadratictermsparse(&state, &sa, randombool());
            }
            minqpsetstartingpoint(&state, &xstart);
            minqpsetorigin(&state, &xorigin);
            minqpsetbc(&state, &bndl, &bndu);
            minqpsetlcmixed(&state, &sparsec, &sparsect, sparseccnt, &densec, &densect, denseccnt);
            minqpsetscale(&state, &s);
            minqpoptimize(&state);
            minqpresults(&state, &x2, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               continue;
            }
         // Compare
            mx = 0.0;
            for (i = 0; i < n; i++) {
               mx = rmax2(mx, fabs(x1.xR[i]));
            }
            mx = rmax2(mx, 1.0);
            for (i = 0; i < n; i++) {
               Ok = Ok && NearAtR(x1.xR[i], x2.xR[i] / s.xR[i], xtol * mx);
            }
         }
      }
   // General inequality constrained problem:
   // * N*N SPD diagonal A with moderate condtion number
   // * no boundary constraints
   // * K == N inequality constraints C*x >= C*x0, where C is N*N well conditioned
   //   matrix, x0 is some random vector [-1,+1]
   // * optimization problem has form 0.5*x'*A*x-b'*x,
   //   where b is random vector from [-1,+1]
   // * using duality, we can obtain solution of QP problem as follows:
   //   a) intermediate problem min(0.5*y'*B*y + d'*y) s.t. y >= 0
   //      is solved, where B = C*inv(A)*C', d = -(C*inv(A)*b + C*x0)
   //   b) after we got dual solution ys, we calculate primal solution
   //      xs = inv(A)*(C'*ys-b)
      for (n = 1; n <= 6; n++) {
      // Set up tolerances
         if (solvertype == 0) {
            xtol = 1.0E-5;
         } else {
            if (solvertype == 1 || solvertype == 2 || solvertype == 3) {
               xtol = 1.0E-3;
            } else {
               ae_assert(false, "unexpected solver type");
            }
         }
      // Generate problem
         ae_vector_set_length(&da, n);
         ae_matrix_set_length(&a, n, n);
         rmatrixrndcond(n, pow(10.0, 2.0 * randomreal()), &t2);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&rawc, n, n + 1);
         ae_vector_set_length(&rawct, n);
         for (i = 0; i < n; i++) {
            da.xR[i] = exp(3.0 * randommid());
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
            a.xyR[i][i] = da.xR[i];
         }
         for (i = 0; i < n; i++) {
            x0.xR[i] = randommid();
            b.xR[i] = randommid();
            xstart.xR[i] = randommid();
         }
         for (i = 0; i < n; i++) {
            ae_v_move(rawc.xyR[i], 1, t2.xyR[i], 1, n);
            v = ae_v_dotproduct(rawc.xyR[i], 1, x0.xR, 1, n);
            rawc.xyR[i][n] = v;
            rawct.xZ[i] = 1;
         }
      // Solve primal problem, check feasibility
         minqpcreate(n, &state);
         if (solvertype == 0) {
            minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
         } else {
            if (solvertype == 1) {
               minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
            } else {
               if (solvertype == 2) {
                  minqpsetalgodenseipm(&state, ipmeps);
               } else {
                  if (solvertype == 3) {
                     minqpsetalgosparseipm(&state, ipmeps);
                  } else {
                     ae_assert(false, "unexpected solver type");
                  }
               }
            }
         }
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
         minqpsetstartingpoint(&state, &xstart);
         minqpsetlc(&state, &rawc, &rawct, n);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            continue;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(x1.xR, 1, rawc.xyR[i], 1, n);
            Ok = Ok && v >= rawc.xyR[i][n] - xtol;
         }
      // Generate dual problem:
      // * A2 stores new quadratic term
      // * B2 stores new linear term
      // * BndL/BndU store boundary constraints
         ae_matrix_set_length(&t3, n, n);
         ae_matrix_set_length(&a2, n, n);
         rmatrixtranspose(n, n, &rawc, 0, 0, &t3, 0, 0);
         for (i = 0; i < n; i++) {
            v = 1 / sqrt(da.xR[i]);
            ae_v_muld(t3.xyR[i], 1, n, v);
         }
         rmatrixsyrk(n, n, 1.0, &t3, 0, 0, 2, 0.0, &a2, 0, 0, true);
         ae_vector_set_length(&tmp0, n);
         ae_v_move(tmp0.xR, 1, b.xR, 1, n);
         for (i = 0; i < n; i++) {
            tmp0.xR[i] /= da.xR[i];
         }
         ae_vector_set_length(&b2, n);
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(rawc.xyR[i], 1, tmp0.xR, 1, n);
            b2.xR[i] = -(v + rawc.xyR[i][n]);
         }
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            bndl.xR[i] = 0.0;
            bndu.xR[i] = +INFINITY;
         }
         minqpcreate(n, &state2);
         minqpsetalgoquickqp(&state2, 0.0, 0.0, 1.0E-9, 0, true);
         minqpsetlinearterm(&state2, &b2);
         minqpsetquadraticterm(&state2, &a2, true);
         minqpsetbc(&state2, &bndl, &bndu);
         minqpoptimize(&state2);
         minqpresults(&state2, &x2, &rep2);
         if (rep2.terminationtype <= 0) {
            Ok = false;
            continue;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(&rawc.xyR[0][i], rawc.stride, x2.xR, 1, n);
            tmp0.xR[i] = v - b.xR[i];
         }
         for (i = 0; i < n; i++) {
            tmp0.xR[i] /= da.xR[i];
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(tmp0.xR[i], x1.xR[i], xtol * rmax2(fabs(tmp0.xR[i]), 1.0));
         }
      }
   // Boundary and linear equality/inequality constrained QP problem with
   // excessive constraints:
   // * N*N SPD A with moderate condtion number (up to 100)
   // * boundary constraints 0 <= x[i] <= 1
   // * K == 2*N equality/inequality constraints Q*x = Q*x0, where Q is random matrix,
   //   x0 is some random vector from the feasible hypercube (0.1 <= x0[i] <= 0.9)
   // * optimization problem has form 0.5*x'*A*x-b*x,
   //   where b is some random vector
   // * because constraints are excessive, the main problem is to find
   //   feasible point; usually, the only existing feasible point is solution,
   //   so we have to check only feasibility
      for (n = 1; n <= 6; n++) {
      // Set up tolerances
         if (solvertype == 0) {
            xtol = 1.0E-5;
         } else {
            if (solvertype == 1 || solvertype == 2 || solvertype == 3) {
               xtol = 5.0E-3;
            } else {
               ae_assert(false, "unexpected solver type");
            }
         }
      // Generate problem: A, b, BndL, BndU, CMatrix, x0, x1, XStart
         k = 2 * n;
         spdmatrixrndcond(n, pow(10.0, 3.0 * randomreal()), &a);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&rawc, k, n + 1);
         ae_vector_set_length(&rawct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 0.1 + 0.8 * randomreal();
            x1.xR[i] = randommid();
            bndl.xR[i] = 0.0;
            bndu.xR[i] = 1.0;
            xstart.xR[i] = (double)randominteger(2);
         }
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               rawc.xyR[i][j] = randommid();
            }
            v = ae_v_dotproduct(rawc.xyR[i], 1, x0.xR, 1, n);
            rawct.xZ[i] = randominteger(3) - 1;
            if (rawct.xZ[i] == 0) {
               rawc.xyR[i][n] = v;
            }
            if (rawct.xZ[i] > 0) {
               rawc.xyR[i][n] = v - 50 * xtol;
            }
            if (rawct.xZ[i] < 0) {
               rawc.xyR[i][n] = v + 50 * xtol;
            }
         }
         for (i = 0; i < n; i++) {
            b.xR[i] = randommid();
         }
      // Create optimizer, solve
         minqpcreate(n, &state);
         if (solvertype == 0) {
            minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
         } else {
            if (solvertype == 1) {
               minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
            } else {
               if (solvertype == 2) {
                  minqpsetalgodenseipm(&state, ipmeps);
               } else {
                  if (solvertype == 3) {
                     minqpsetalgosparseipm(&state, ipmeps);
                  } else {
                     ae_assert(false, "unexpected solver type");
                  }
               }
            }
         }
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
         minqpsetstartingpoint(&state, &xstart);
         minqpsetbc(&state, &bndl, &bndu);
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, k, n, &state, &rs);
         minqpoptimize(&state);
         ae_vector_set_length(&x1, 0);
         minqpresults(&state, &x1, &rep);
      // Check feasibility properties of the solution
      // NOTE: we do not check termination type because some solvers (IPM) may return feasible X even with negative code
         if (x1.cnt != n) {
            Ok = false;
            continue;
         }
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(x1.xR, 1, rawc.xyR[i], 1, n);
            if (rawct.xZ[i] == 0) {
               Ok = Ok && NearAtR(v, rawc.xyR[i][n], xtol);
            }
            if (rawct.xZ[i] > 0) {
               Ok = Ok && v >= rawc.xyR[i][n] - xtol;
            }
            if (rawct.xZ[i] < 0) {
               Ok = Ok && v <= rawc.xyR[i][n] + xtol;
            }
         }
      }
   // Boundary constraints posed as general linear ones:
   // * no bound constraints
   // * 2*N linear constraints 0 <= x[i] <= 1
   // * F(x) = |x-x0|^P, where P == {2,4} and x0 is randomly selected from [-1,+2]^N
   // * with such simple constraints and function it is easy to find
   //   analytic form of solution: S[i] = bound(x0[i], 0, 1).
   // * however, we can't guarantee that solution is strictly feasible
   //   with respect to nonlinearity constraint, so we check
   //   for approximate feasibility.
      for (n = 1; n <= 5; n++) {
      // Set up tolerances
         if (solvertype == 0) {
            xtol = 1.0E-3;
         } else {
            if (solvertype == 1 || solvertype == 2 || solvertype == 3) {
               xtol = 1.0E-3;
            } else {
               ae_assert(false, "unexpected solver type");
            }
         }
      // Generate X, BL, BU.
         ae_matrix_set_length(&a, n, n);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xstart, n);
         ae_vector_set_length(&x0, n);
         ae_matrix_set_length(&rawc, 2 * n, n + 1);
         ae_vector_set_length(&rawct, 2 * n);
         k = 2 * n;
         for (i = 0; i < n; i++) {
            xstart.xR[i] = randomreal();
            x0.xR[i] = 3.0 * randomreal() - 1.0;
            b.xR[i] = -x0.xR[i];
            for (j = 0; j <= n; j++) {
               rawc.xyR[2 * i][j] = 0.0;
               rawc.xyR[2 * i + 1][j] = 0.0;
            }
            rawc.xyR[2 * i][i] = 1.0;
            rawc.xyR[2 * i][n] = 0.0;
            rawct.xZ[2 * i] = 1;
            rawc.xyR[2 * i + 1][i] = 1.0;
            rawc.xyR[2 * i + 1][n] = 1.0;
            rawct.xZ[2 * i + 1] = -1;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (i == j) {
                  a.xyR[i][j] = 1.0;
               } else {
                  a.xyR[i][j] = 0.0;
               }
            }
         }
      // Create and optimize
         minqpcreate(n, &state);
         if (solvertype == 0) {
            minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
         } else {
            if (solvertype == 1) {
               minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
            } else {
               if (solvertype == 2) {
                  minqpsetalgodenseipm(&state, ipmeps);
               } else {
                  if (solvertype == 3) {
                     minqpsetalgosparseipm(&state, ipmeps);
                  } else {
                     ae_assert(false, "unexpected solver type");
                  }
               }
            }
         }
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, k, n, &state, &rs);
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
         minqpsetstartingpoint(&state, &xstart);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            continue;
         }
      // * compare solution with analytic one
      // * check feasibility
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(x1.xR[i], rboundval(x0.xR[i], 0.0, 1.0), xtol);
            Ok = Ok && x1.xR[i] >= 0.0 - xtol;
            Ok = Ok && x1.xR[i] <= 1.0 + xtol;
         }
      }
   // Convex optimization problem with excessive constraints:
   //
   // * N = 2..5
   // * f = 0.5*x'*A*x+b'*x
   // * b has normally distributed entries
   // * A is diagonal with log-normally distributed entries
   // * box constraints: x[i] in [-1,+1]
   // * 2^N "excessive" general linear constraints (v_k,x) <= (v_k,v_k)+v_shift,
   //   where v_k is one of 2^N vertices of feasible hypercube, v_shift is
   //   a shift parameter:
   //   * with zero v_shift such constraints are degenerate (each vertex has
   //     N box constraints and one "redundant" linear constraint)
   //   * with positive v_shift linear constraint is always inactive
   //   * with small (about machine epsilon) but negative v_shift,
   //     constraint is close to degenerate - but not exactly
   //
   // Because A is diagonal, we can easily find out solution analytically.
   //
   // NOTE: TolConstr must be large enough so it won't conflict with
   //       perturbation introduced by v_shift
      for (n = 2; n <= 5; n++) {
         for (shiftkind = -5; shiftkind <= 1; shiftkind++) {
         // Set up tolerances
            if (solvertype == 0) {
               tolconstr = 1.0E-6;
               gtol = 1.0E-6;
            } else {
               if (solvertype == 1 || solvertype == 2 || solvertype == 3) {
                  tolconstr = 1.0E-4;
                  gtol = 1.0E-4;
               } else {
                  ae_assert(false, "unexpected solver type");
               }
            }
         // Generate A, B and initial point
            ae_matrix_set_length(&a, n, n);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&xstart, n);
            for (i = 0; i < n; i++) {
               b.xR[i] = hqrndnormal(&rs);
               xstart.xR[i] = hqrnduniformr(&rs) - 0.5;
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
               a.xyR[i][i] = pow(2.0, hqrndnormal(&rs));
            }
         // Generate constraints
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            for (i = 0; i < n; i++) {
               bndl.xR[i] = -1.0;
               bndu.xR[i] = 1.0;
            }
            rawccnt = iround(pow(2.0, (double)n));
            ae_matrix_set_length(&rawc, rawccnt, n + 1);
            ae_vector_set_length(&rawct, rawccnt);
            for (i = 0; i < rawccnt; i++) {
               rawct.xZ[i] = -1;
               k = i;
               rawc.xyR[i][n] = sign((double)shiftkind) * pow(10.0, fabs((double)shiftkind)) * machineepsilon;
               for (j = 0; j < n; j++) {
                  rawc.xyR[i][j] = (double)(2 * (k % 2) - 1);
                  rawc.xyR[i][n] += rawc.xyR[i][j] * rawc.xyR[i][j];
                  k /= 2;
               }
            }
         // Create and optimize
            minqpcreate(n, &state);
            minqpsetstartingpoint(&state, &xstart);
            if (solvertype == 0) {
               minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
            } else {
               if (solvertype == 1) {
                  minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
               } else {
                  if (solvertype == 2) {
                     minqpsetalgodenseipm(&state, ipmeps);
                  } else {
                     if (solvertype == 3) {
                        minqpsetalgosparseipm(&state, ipmeps);
                     } else {
                        ae_assert(false, "unexpected solver type");
                     }
                  }
               }
            }
            minqpsetbc(&state, &bndl, &bndu);
            testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
            minqpsetlinearterm(&state, &b);
            testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
            minqpoptimize(&state);
            minqpresults(&state, &x1, &rep);
            Ok = Ok && rep.terminationtype > 0;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Evaluate gradient at solution and test
            vv = 0.0;
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
               v += b.xR[i];
               if (x1.xR[i] <= bndl.xR[i] + tolconstr && v > 0.0) {
                  v = 0.0;
               }
               if (x1.xR[i] >= bndu.xR[i] - tolconstr && v < 0.0) {
                  v = 0.0;
               }
               vv += sqr(v);
            }
            vv = sqrt(vv);
            Ok = Ok && vv <= gtol;
         }
      }
   // Convex optimization problem with known answer (we generate constraints
   // and Lagrange coefficients, and then generate quadratic and linear term
   // which satisfy KKT conditions for given Lagrange coefficients):
   //
   // * N = 1..8
   // * f = 0.5*x'*A*x+b'*x
   // * several kinds of A are tried: zero, well conditioned SPD, low rank
   // * initial point x0 = [0 0 ... 0 0]
   // * absent bounds can be set to +-INF or to some huge number (randomly)
   // * first, we generate set of linear constraints (without bounds),
   //   solution point X and Lagrange multipliers for linear and box constraints
   // * then we determine bounds on variables and linear constraints which
   //   align with values/signs of Lagrange multipliers
   // * then, having quadratic term A and known constraints and Lagrange
   //   multipliers we determine linear term B which makes KKT conditions true
      for (n = 1; n <= 8; n++) {
         for (akind = 0; akind <= 2; akind++) {
         // Select number used for absent bounds:
         // * +- INF
         // * 1e9
         // * 1e11
            i = hqrnduniformi(&rs, 3);
            minushuge = -INFINITY;
            plushuge = +INFINITY;
            if (i == 1) {
               minushuge = -1.0E9;
               plushuge = +1.0E9;
            }
            if (i == 2) {
               minushuge = -1.0E11;
               plushuge = +1.0E11;
            }
         // Generate quadratic term A, origin and scale
            ae_matrix_set_length(&a, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
            }
            issemidefinite = true;
            if (akind == 1) {
            // Dense well conditioned SPD
               spdmatrixrndcond(n, 50.0, &a);
               issemidefinite = false;
            }
            if (akind == 2) {
            // Low rank semidefinite
               ae_vector_set_length(&tmp, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               for (k = 1; k < imin2(4, n); k++) {
                  for (i = 0; i < n; i++) {
                     tmp.xR[i] = hqrndnormal(&rs);
                  }
                  v = pow(2.0, hqrndnormal(&rs));
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                     }
                  }
               }
               issemidefinite = true;
            }
            ae_vector_set_length(&s, n);
            ae_vector_set_length(&xorigin, n);
            for (j = 0; j < n; j++) {
               xorigin.xR[j] = hqrndnormal(&rs);
               s.xR[j] = pow(2.0, hqrndnormal(&rs));
            }
         // Generate linear constraints (left parts)
            rawccnt = hqrnduniformi(&rs, 2 * n + 1);
            ae_matrix_set_length(&rawc, rawccnt, n);
            for (i = 0; i < rawccnt; i++) {
               for (j = 0; j < n; j++) {
                  rawc.xyR[i][j] = 0.0;
               }
               nnz = hqrnduniformi(&rs, n + 1);
               for (k = 0; k < nnz; k++) {
                  j = hqrnduniformi(&rs, n);
                  v = hqrndnormal(&rs);
                  v += 0.1 * possign(v);
                  rawc.xyR[i][j] = v;
               }
            }
         // Generate Lagrange multipliers, with at most NActive < N being non-zero
            ae_vector_set_length(&lagbc, n);
            ae_vector_set_length(&laglc, rawccnt);
            for (i = 0; i < n; i++) {
               lagbc.xR[i] = 0.0;
            }
            for (i = 0; i < rawccnt; i++) {
               laglc.xR[i] = 0.0;
            }
            nactive = hqrnduniformi(&rs, n);
            k = hqrnduniformi(&rs, imin2(nactive, rawccnt) + 1);
            for (i = 0; i < k; i++) {
               laglc.xR[hqrnduniformi(&rs, rawccnt)] = hqrndnormal(&rs);
            }
            for (i = k; i < nactive; i++) {
               lagbc.xR[hqrnduniformi(&rs, n)] = hqrndnormal(&rs);
            }
         // Generate solution and gradient at the solution, set B to -G
            ae_vector_set_length(&xf, n);
            for (i = 0; i < n; i++) {
               xf.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&g, n);
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += a.xyR[i][j] * (xf.xR[j] - xorigin.xR[j]);
               }
               g.xR[i] = v;
            }
            for (i = 0; i < n; i++) {
               g.xR[i] += lagbc.xR[i];
            }
            for (i = 0; i < rawccnt; i++) {
               for (j = 0; j < n; j++) {
                  g.xR[j] += laglc.xR[i] * rawc.xyR[i][j];
               }
            }
            ae_vector_set_length(&b, n);
            for (j = 0; j < n; j++) {
               b.xR[j] = -g.xR[j];
            }
         // Set up bounds according to Lagrange multipliers
         //
         // NOTE: for semidefinite problems we set all variable bounds
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            for (j = 0; j < n; j++) {
               bndl.xR[j] = minushuge;
               bndu.xR[j] = plushuge;
               if (hqrndnormal(&rs) > 0.0 || issemidefinite) {
                  bndl.xR[j] = xf.xR[j] - pow(2.0, hqrndnormal(&rs));
               }
               if (hqrndnormal(&rs) > 0.0 || issemidefinite) {
                  bndu.xR[j] = xf.xR[j] + pow(2.0, hqrndnormal(&rs));
               }
               if (lagbc.xR[j] != 0.0) {
                  if (hqrnduniformr(&rs) < 0.15) {
                     bndl.xR[j] = xf.xR[j];
                     bndu.xR[j] = xf.xR[j];
                  } else {
                     if (lagbc.xR[j] < 0.0) {
                        bndl.xR[j] = xf.xR[j];
                     }
                     if (lagbc.xR[j] > 0.0) {
                        bndu.xR[j] = xf.xR[j];
                     }
                  }
               }
            }
            ae_vector_set_length(&rawcl, rawccnt);
            ae_vector_set_length(&rawcu, rawccnt);
            for (i = 0; i < rawccnt; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += rawc.xyR[i][j] * xf.xR[j];
               }
               rawcl.xR[i] = minushuge;
               rawcu.xR[i] = plushuge;
               if (hqrndnormal(&rs) > 0.0) {
                  rawcl.xR[i] = v - pow(2.0, hqrndnormal(&rs));
               }
               if (hqrndnormal(&rs) > 0.0) {
                  rawcu.xR[i] = v + pow(2.0, hqrndnormal(&rs));
               }
               if (laglc.xR[i] != 0.0) {
                  if (hqrnduniformr(&rs) < 0.15) {
                  // Active equality constraint
                     rawcl.xR[i] = v;
                     rawcu.xR[i] = v;
                  } else {
                  // Active inequality constraint
                     if (laglc.xR[i] < 0.0) {
                        rawcl.xR[i] = v;
                     }
                     if (laglc.xR[i] > 0.0) {
                        rawcu.xR[i] = v;
                     }
                  }
               }
               if ((!isfinite(rawcl.xR[i]) || rawcl.xR[i] == minushuge) && (!isfinite(rawcu.xR[i]) || rawcu.xR[i] == plushuge)) {
               // At least one bound must be present for linear constraint
                  if (hqrndnormal(&rs) > 0.0) {
                     rawcl.xR[i] = v - 10;
                  } else {
                     rawcu.xR[i] = v + 10;
                  }
               }
            }
         // Completely skip some solvers depending on their properties:
         // * Dense-AUL solver has lower precision on rank-deficient
         //   problems, so we skip AKind == 0 and AKind == 2.
         // * BLEIC solver is always skipped
            if (solvertype == 1 && akind != 1) {
               continue;
            }
            if (solvertype == 0) {
               continue;
            }
         // Solve
            minqpcreate(n, &state);
            if (solvertype == 0) {
               minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
            } else {
               if (solvertype == 1) {
                  minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
               } else {
                  if (solvertype == 2) {
                     minqpsetalgodenseipm(&state, ipmeps);
                  } else {
                     if (solvertype == 3) {
                        minqpsetalgosparseipm(&state, ipmeps);
                     } else {
                        ae_assert(false, "unexpected solver type");
                     }
                  }
               }
            }
            minqpsetbc(&state, &bndl, &bndu);
            testminqpunit_randomlysplitandsetlc2(&rawc, &rawcl, &rawcu, rawccnt, n, &state, &rs);
            minqpsetlinearterm(&state, &b);
            testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
            minqpsetscale(&state, &s);
            minqpsetorigin(&state, &xorigin);
            minqpoptimize(&state);
            minqpresults(&state, &x1, &rep);
            Ok = Ok && rep.terminationtype > 0;
            Ok = Ok && x1.cnt >= n;
            Ok = Ok && rep.lagbc.cnt >= n;
            Ok = Ok && rep.laglc.cnt >= rawccnt;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Test function value at the solution
            f0 = testminqpunit_quadratictarget(&a, &b, n, &x1);
            f1 = testminqpunit_quadratictarget(&a, &b, n, &xf);
            Ok = Ok && NearAtR(f0, f1, rmax3(fabs(f0), fabs(f1), 1.0) * 1.0E-3);
         // Test Lagrange multipliers returned by the solver; test is skipped:
         // * for BLEIC solver
         // * for overconstrained DENSE-AUL
            skiptest = false;
            skiptest = skiptest || solvertype == 0;
            skiptest = skiptest || solvertype == 1 && nactive > 0.5 * (n - 1);
            if (!skiptest) {
               ae_vector_set_length(&gtrial, n);
               for (i = 0; i < n; i++) {
                  v = b.xR[i];
                  for (j = 0; j < n; j++) {
                     v += a.xyR[i][j] * (x1.xR[j] - xorigin.xR[j]);
                  }
                  gtrial.xR[i] = v;
               }
               for (i = 0; i < n; i++) {
                  gtrial.xR[i] += rep.lagbc.xR[i];
               }
               for (i = 0; i < rawccnt; i++) {
                  for (j = 0; j < n; j++) {
                     gtrial.xR[j] += rep.laglc.xR[i] * rawc.xyR[i][j];
                  }
               }
               for (i = 0; i < n; i++) {
                  Ok = Ok && !(fabs(gtrial.xR[i]) > 1.0E-3); //(@) This allows NAN values of gtrial to slip through.
//                Ok = Ok && SmallAtR(gtrial.xR[i], 1.0E-3); //(@) This is what it should be, instead.
               }
            }
         }
      }
   }
// Large-scale tests: a few selected tests for large N's
   for (solvertype = 0; solvertype <= 3; solvertype++) {
   // General equality constrained problem:
   // * N*N SPD (non-diagonal) A with moderate condition number
   // * no box constraints
   // * K < N equality constraints C*x = C*x0, where C is K*N well conditioned
   //   matrix, x0 is some random vector [-1,+1]
   // * optimization problem has form 0.5*x'*A*x-b'*x,
   //   where b is random vector from [-1,+1]
   // * true solution of QP problem is obtained with KKT matrix;
   //   we compare value returned by solver against one calculated
   //   via KKT conditions.
      n = 60;
      rawccnt = 40;
      if (solvertype == 0) {
         xtol = 1.0E-3;
      } else {
         if (solvertype == 1 || solvertype == 2 || solvertype == 3) {
            xtol = 1.0E-3;
         } else {
            ae_assert(false, "unexpected solver type");
         }
      }
      spdmatrixrndcond(n, pow(10.0, 2.0 * randomreal()), &a);
      rmatrixrndcond(n, pow(10.0, 2.0 * randomreal()), &t2);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&xstart, n);
      ae_matrix_set_length(&rawc, rawccnt, n + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         b.xR[i] = randommid();
         xstart.xR[i] = randommid();
      }
      for (i = 0; i < rawccnt; i++) {
         ae_v_move(rawc.xyR[i], 1, t2.xyR[i], 1, n);
         v = ae_v_dotproduct(rawc.xyR[i], 1, x0.xR, 1, n);
         rawc.xyR[i][n] = v;
         rawct.xZ[i] = 0;
      }
      minqpcreate(n, &state);
      if (solvertype == 0) {
         minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
      } else {
         if (solvertype == 1) {
            minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
         } else {
            if (solvertype == 2) {
               minqpsetalgodenseipm(&state, ipmeps);
            } else {
               if (solvertype == 3) {
                  minqpsetalgosparseipm(&state, ipmeps);
               } else {
                  ae_assert(false, "unexpected solver type");
               }
            }
         }
      }
      minqpsetlinearterm(&state, &b);
      testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
      minqpsetstartingpoint(&state, &xstart);
      testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
      minqpoptimize(&state);
      minqpresults(&state, &x1, &rep);
      if (rep.terminationtype <= 0) {
         Ok = false;
         continue;
      }
      for (i = 0; i < rawccnt; i++) {
         v = ae_v_dotproduct(x1.xR, 1, rawc.xyR[i], 1, n);
         Ok = Ok && v >= rawc.xyR[i][n] - xtol;
      }
      ae_matrix_set_length(&kkt, n + rawccnt, n + rawccnt);
      ae_vector_set_length(&kktright, n + rawccnt);
      for (i = 0; i < n + rawccnt; i++) {
         for (j = 0; j < n + rawccnt; j++) {
            kkt.xyR[i][j] = 0.0;
         }
      }
      rmatrixcopy(n, n, &a, 0, 0, &kkt, 0, 0);
      rmatrixcopy(rawccnt, n, &rawc, 0, 0, &kkt, n, 0);
      rmatrixtranspose(rawccnt, n, &rawc, 0, 0, &kkt, 0, n);
      for (i = 0; i < n; i++) {
         kktright.xR[i] = -b.xR[i];
      }
      for (i = 0; i < rawccnt; i++) {
         kktright.xR[n + i] = rawc.xyR[i][n];
      }
      fblssolvels(&kkt, &kktright, n + rawccnt, n + rawccnt, &tmp0, &tmp1, &tmp2);
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(kktright.xR[i], x1.xR[i], xtol * rmax2(fabs(kktright.xR[i]), 1.0));
      }
   // General inequality constrained problem:
   // * N*N SPD diagonal A with moderate condtion number
   // * no box constraints
   // * K < N inequality constraints C*x >= C*x0, where C is N*N well conditioned
   //   matrix, x0 is some random vector [-1,+1]
   // * optimization problem has form 0.5*x'*A*x-b'*x,
   //   where b is random vector from [-1,+1]
   // * using duality, we can obtain solution of QP problem as follows:
   //   a) intermediate problem min(0.5*y'*B*y + d'*y) s.t. y >= 0
   //      is solved, where B = C*inv(A)*C', d = -(C*inv(A)*b + C*x0)
   //   b) after we got dual solution ys, we calculate primal solution
   //      xs = inv(A)*(C'*ys-b)
      n = 60;
      rawccnt = 40;
      if (solvertype == 0) {
         xtol = 1.0E-3;
      } else {
         if (solvertype == 1 || solvertype == 2 || solvertype == 3) {
            xtol = 1.0E-3;
         } else {
            ae_assert(false, "unexpected solver type");
         }
      }
      ae_vector_set_length(&da, n);
      ae_matrix_set_length(&a, n, n);
      rmatrixrndcond(n, pow(10.0, 2.0 * randomreal()), &t2);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&xstart, n);
      ae_matrix_set_length(&rawc, rawccnt, n + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < n; i++) {
         da.xR[i] = exp(4.0 * randommid());
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = 0.0;
         }
         a.xyR[i][i] = da.xR[i];
      }
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         b.xR[i] = randommid();
         xstart.xR[i] = randommid();
      }
      for (i = 0; i < rawccnt; i++) {
         ae_v_move(rawc.xyR[i], 1, t2.xyR[i], 1, n);
         v = ae_v_dotproduct(rawc.xyR[i], 1, x0.xR, 1, n);
         rawc.xyR[i][n] = v;
         rawct.xZ[i] = 1;
      }
      minqpcreate(n, &state);
      if (solvertype == 0) {
         minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
      } else {
         if (solvertype == 1) {
            minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
         } else {
            if (solvertype == 2) {
               minqpsetalgodenseipm(&state, ipmeps);
            } else {
               if (solvertype == 3) {
                  minqpsetalgosparseipm(&state, ipmeps);
               } else {
                  ae_assert(false, "unexpected solver type");
               }
            }
         }
      }
      minqpsetlinearterm(&state, &b);
      testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
      minqpsetstartingpoint(&state, &xstart);
      testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
      minqpoptimize(&state);
      minqpresults(&state, &x1, &rep);
      if (rep.terminationtype <= 0) {
         Ok = false;
         continue;
      }
      for (i = 0; i < rawccnt; i++) {
         v = ae_v_dotproduct(x1.xR, 1, rawc.xyR[i], 1, n);
         Ok = Ok && v >= rawc.xyR[i][n] - xtol;
      }
      ae_matrix_set_length(&t3, n, rawccnt);
      ae_matrix_set_length(&a2, rawccnt, rawccnt);
      rmatrixtranspose(rawccnt, n, &rawc, 0, 0, &t3, 0, 0);
      for (i = 0; i < n; i++) {
         v = 1 / sqrt(da.xR[i]);
         ae_v_muld(t3.xyR[i], 1, rawccnt, v);
      }
      rmatrixsyrk(rawccnt, n, 1.0, &t3, 0, 0, 2, 0.0, &a2, 0, 0, true);
      ae_vector_set_length(&tmp0, n);
      ae_v_move(tmp0.xR, 1, b.xR, 1, n);
      for (i = 0; i < n; i++) {
         tmp0.xR[i] /= da.xR[i];
      }
      ae_vector_set_length(&b2, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         v = ae_v_dotproduct(rawc.xyR[i], 1, tmp0.xR, 1, n);
         b2.xR[i] = -(v + rawc.xyR[i][n]);
      }
      ae_vector_set_length(&bndl, rawccnt);
      ae_vector_set_length(&bndu, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         bndl.xR[i] = 0.0;
         bndu.xR[i] = +INFINITY;
      }
      minqpcreate(rawccnt, &state2);
      minqpsetalgoquickqp(&state2, 0.0, 0.0, 1.0E-9, 0, true);
      minqpsetlinearterm(&state2, &b2);
      minqpsetquadraticterm(&state2, &a2, true);
      minqpsetbc(&state2, &bndl, &bndu);
      minqpoptimize(&state2);
      minqpresults(&state2, &x2, &rep2);
      if (rep2.terminationtype <= 0) {
         Ok = false;
         continue;
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(&rawc.xyR[0][i], rawc.stride, x2.xR, 1, rawccnt);
         tmp0.xR[i] = v - b.xR[i];
      }
      for (i = 0; i < n; i++) {
         tmp0.xR[i] /= da.xR[i];
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(tmp0.xR[i], x1.xR[i], xtol * rmax2(fabs(tmp0.xR[i]), 1.0));
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests special inequality constrained QP problems.
static bool testminqpunit_specialicqptests() {
   ae_frame _frame_block;
   bool Ok;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(xstart, 0, DT_REAL);
   NewVector(xend, 0, DT_REAL);
   NewVector(xexact, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   Ok = true;
// Test 1: reported by Vanderlande Industries.
//         Tests algorithm ability to handle degenerate constraints.
   ae_matrix_set_length(&a, 3, 3);
   for (i = 0; i <= 2; i++) {
      for (j = 0; j <= 2; j++) {
         a.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i <= 2; i++) {
      a.xyR[i][i] = 1.0;
   }
   ae_vector_set_length(&b, 3);
   b.xR[0] = -50.0;
   b.xR[1] = -50.0;
   b.xR[2] = -75.0;
   ae_vector_set_length(&bndl, 3);
   bndl.xR[0] = 0.0;
   bndl.xR[1] = 0.0;
   bndl.xR[2] = 0.0;
   ae_vector_set_length(&bndu, 3);
   bndu.xR[0] = 100.0;
   bndu.xR[1] = 100.0;
   bndu.xR[2] = 150.0;
   ae_vector_set_length(&xstart, 3);
   xstart.xR[0] = 0.0;
   xstart.xR[1] = 100.0;
   xstart.xR[2] = 0.0;
   ae_vector_set_length(&xexact, 3);
   xexact.xR[0] = 0.0;
   xexact.xR[1] = 100.0;
   xexact.xR[2] = 50.0;
   ae_matrix_set_length(&c, 3, 4);
   c.xyR[0][0] = 1.0;
   c.xyR[0][1] = -1.0;
   c.xyR[0][2] = 0.0;
   c.xyR[0][3] = -100.0;
   c.xyR[1][0] = 1.0;
   c.xyR[1][1] = 0.0;
   c.xyR[1][2] = -1.0;
   c.xyR[1][3] = 0.0;
   c.xyR[2][0] = -1.0;
   c.xyR[2][1] = 0.0;
   c.xyR[2][2] = 1.0;
   c.xyR[2][3] = 50.0;
   ae_vector_set_length(&ct, 3);
   ct.xZ[0] = -1;
   ct.xZ[1] = -1;
   ct.xZ[2] = -1;
   minqpcreate(3, &state);
   testminqpunit_setrandomalgoconvexlc(&state);
   minqpsetlinearterm(&state, &b);
   minqpsetquadraticterm(&state, &a, true);
   minqpsetstartingpoint(&state, &xstart);
   minqpsetbc(&state, &bndl, &bndu);
   minqpsetlc(&state, &c, &ct, 3);
   minqpoptimize(&state);
   minqpresults(&state, &xend, &rep);
   if (rep.terminationtype > 0) {
      for (i = 0; i <= 2; i++) {
         Ok = Ok && NearAtR(xend.xR[i], xexact.xR[i], 1.0E6 * machineepsilon);
      }
   } else {
      Ok = false;
   }
// Test 2: reported by Vanderlande Industries.
//         Tests algorithm ability to handle degenerate constraints.
   ae_matrix_set_length(&a, 3, 3);
   for (i = 0; i <= 2; i++) {
      for (j = 0; j <= 2; j++) {
         a.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i <= 2; i++) {
      a.xyR[i][i] = 1.0;
   }
   ae_vector_set_length(&b, 3);
   b.xR[0] = -50.0;
   b.xR[1] = -50.0;
   b.xR[2] = -75.0;
   ae_vector_set_length(&bndl, 3);
   bndl.xR[0] = 0.0;
   bndl.xR[1] = 0.0;
   bndl.xR[2] = 0.0;
   ae_vector_set_length(&bndu, 3);
   bndu.xR[0] = 100.0;
   bndu.xR[1] = 100.0;
   bndu.xR[2] = 150.0;
   ae_vector_set_length(&xstart, 3);
   xstart.xR[0] = 0.0;
   xstart.xR[1] = 100.0;
   xstart.xR[2] = 150.0;
   ae_vector_set_length(&xexact, 3);
   xexact.xR[0] = 0.0;
   xexact.xR[1] = 100.0;
   xexact.xR[2] = 100.0;
   ae_matrix_set_length(&c, 3, 4);
   c.xyR[0][0] = 1.0;
   c.xyR[0][1] = -1.0;
   c.xyR[0][2] = 0.0;
   c.xyR[0][3] = -100.0;
   c.xyR[1][0] = 0.0;
   c.xyR[1][1] = 1.0;
   c.xyR[1][2] = -1.0;
   c.xyR[1][3] = 0.0;
   c.xyR[2][0] = 0.0;
   c.xyR[2][1] = -1.0;
   c.xyR[2][2] = 1.0;
   c.xyR[2][3] = 50.0;
   ae_vector_set_length(&ct, 3);
   ct.xZ[0] = -1;
   ct.xZ[1] = -1;
   ct.xZ[2] = -1;
   minqpcreate(3, &state);
   testminqpunit_setrandomalgoconvexlc(&state);
   minqpsetlinearterm(&state, &b);
   minqpsetquadraticterm(&state, &a, true);
   minqpsetstartingpoint(&state, &xstart);
   minqpsetbc(&state, &bndl, &bndu);
   minqpsetlc(&state, &c, &ct, 3);
   minqpoptimize(&state);
   minqpresults(&state, &xend, &rep);
   if (rep.terminationtype > 0) {
      for (i = 0; i <= 2; i++) {
         Ok = Ok && NearAtR(xend.xR[i], xexact.xR[i], 1.0E6 * machineepsilon);
      }
   } else {
      Ok = false;
   }
   ae_frame_leave();
   return Ok;
}

// This function tests linearly constrained DENSE-AUL solver
static bool testminqpunit_denseaultests() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   ae_int_t scaletype;
   ae_int_t rawccnt;
   double epsx;
   double xtol;
   double rho;
   ae_int_t outerits;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(rawa, 0, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(rawc, 0, 0, DT_REAL);
   NewVector(rawct, 0, DT_INT);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(xf, 0, DT_REAL);
   NewVector(r, 0, DT_REAL);
   NewVector(xsol, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   NewObj(densesolverreport, svrep);
   hqrndrandomize(&rs);
// Test that unconstrained problem is solved with high precision,
// independently of Rho and/or outer iterations count.
//
// 50% of problems are rescaled wildly (with scale being passed to
// the solver).
   epsx = 1.0E-12;
   xtol = 1.0E-7;
   for (n = 1; n <= 10; n++) {
      for (scaletype = 0; scaletype <= 1; scaletype++) {
      // Generate random A, b, X0 and XSOL
         spdmatrixrndcond(n, pow(10.0, 3.0 * hqrnduniformr(&rs)), &rawa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xsol, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
            xsol.xR[i] = hqrndnormal(&rs);
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(rawa.xyR[i], 1, xsol.xR, 1, n);
            b.xR[i] = -v;
         }
      // Generate scale vector, apply it
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            if (scaletype > 0) {
               s.xR[i] = pow(10.0, 10.0 * hqrndmiduniformr(&rs));
            } else {
               s.xR[i] = 1.0;
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rawa.xyR[i][j] /= s.xR[i] * s.xR[j];
            }
            b.xR[i] /= s.xR[i];
            x0.xR[i] *= s.xR[i];
            xsol.xR[i] *= s.xR[i];
         }
      // Create optimizer, solve
         rho = pow(10.0, 2.0 * hqrnduniformr(&rs));
         outerits = hqrnduniformi(&rs, 5);
         minqpcreate(n, &state);
         minqpsetalgodenseaul(&state, epsx, rho, outerits);
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
         minqpsetscale(&state, &s);
         minqpsetstartingpoint(&state, &x0);
         minqpoptimize(&state);
         minqpresults(&state, &xf, &rep);
      // Compare against analytically known solution
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(xf.xR[i], xsol.xR[i], s.xR[i] * xtol);
         }
      }
   }
// Test that problem with zero constraint matrix can be solved
// (with high precision). We do not perform any additional "tweaks"
// like scaling of variables, just want to test ability to handle
// zero matrices.
   epsx = 1.0E-12;
   xtol = 1.0E-7;
   for (n = 1; n <= 10; n++) {
   // Generate random A, b, X0 and XSOL
      spdmatrixrndcond(n, pow(10.0, 3.0 * hqrnduniformr(&rs)), &rawa);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&xsol, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
         xsol.xR[i] = hqrndnormal(&rs);
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(rawa.xyR[i], 1, xsol.xR, 1, n);
         b.xR[i] = -v;
      }
      rawccnt = hqrnduniformi(&rs, 2 * n);
      ae_matrix_set_length(&rawc, rawccnt, n + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         for (j = 0; j <= n; j++) {
            rawc.xyR[i][j] = 0.0;
         }
         rawct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
      }
   // Create optimizer, solve
      rho = pow(10.0, 2.0 * hqrnduniformr(&rs));
      outerits = hqrnduniformi(&rs, 5);
      minqpcreate(n, &state);
      minqpsetalgodenseaul(&state, epsx, rho, outerits);
      minqpsetlinearterm(&state, &b);
      testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
      minqpsetlc(&state, &rawc, &rawct, rawccnt);
      minqpsetstartingpoint(&state, &x0);
      minqpoptimize(&state);
      minqpresults(&state, &xf, &rep);
   // Compare against analytically known solution
      if (rep.terminationtype <= 0) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(xf.xR[i], xsol.xR[i], xtol);
      }
   }
// Test that box/linearly inequality constrained problem with ALL constraints
// being inactive at BOTH initial and final points is solved with high precision.
//
// 50% of problems are rescaled wildly (with scale being passed to
// the solver).
   epsx = 1.0E-12;
   xtol = 1.0E-7;
   for (n = 1; n <= 10; n++) {
      for (scaletype = 0; scaletype <= 1; scaletype++) {
      // Generate random A, b, X0 and XSOL
         spdmatrixrndcond(n, pow(10.0, 3.0 * hqrnduniformr(&rs)), &rawa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xsol, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
            xsol.xR[i] = hqrndnormal(&rs);
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(rawa.xyR[i], 1, xsol.xR, 1, n);
            b.xR[i] = -v;
         }
      // Generate such set of inequality constraints that ALL
      // constraints are inactive at both X0 and XSOL.
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            bndl.xR[i] = rmin2(x0.xR[i], xsol.xR[i]) - 1.0 - hqrnduniformr(&rs);
            bndu.xR[i] = rmax2(x0.xR[i], xsol.xR[i]) + 1.0 + hqrnduniformr(&rs);
         }
         rawccnt = hqrnduniformi(&rs, 2 * n);
         ae_matrix_set_length(&rawc, rawccnt, n + 1);
         ae_vector_set_length(&rawct, rawccnt);
         for (i = 0; i < rawccnt; i++) {
            v = 0.0;
            vv = 0.0;
            for (j = 0; j < n; j++) {
               rawc.xyR[i][j] = hqrndnormal(&rs);
               v += rawc.xyR[i][j] * x0.xR[j];
               vv += rawc.xyR[i][j] * xsol.xR[j];
            }
            if (hqrndnormal(&rs) > 0.0) {
               rawct.xZ[i] = 1;
               rawc.xyR[i][n] = rmin2(v, vv) - 1.0 - hqrnduniformr(&rs);
            } else {
               rawct.xZ[i] = -1;
               rawc.xyR[i][n] = rmax2(v, vv) + 1.0 + hqrnduniformr(&rs);
            }
         }
      // Generate scale vector, apply it
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            if (scaletype > 0) {
               s.xR[i] = pow(10.0, 10.0 * hqrndmiduniformr(&rs));
            } else {
               s.xR[i] = 1.0;
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rawa.xyR[i][j] /= s.xR[i] * s.xR[j];
            }
            b.xR[i] /= s.xR[i];
            x0.xR[i] *= s.xR[i];
            xsol.xR[i] *= s.xR[i];
            bndl.xR[i] *= s.xR[i];
            bndu.xR[i] *= s.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            for (j = 0; j < n; j++) {
               rawc.xyR[i][j] /= s.xR[j];
            }
         }
      // Create optimizer, solve
         rho = 100.0;
         outerits = 1;
         minqpcreate(n, &state);
         minqpsetstartingpoint(&state, &x0);
         minqpsetalgodenseaul(&state, epsx, rho, outerits);
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
         minqpsetbc(&state, &bndl, &bndu);
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
         minqpsetscale(&state, &s);
         minqpoptimize(&state);
         minqpresults(&state, &xf, &rep);
      // Compare against analytically known solution
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(xf.xR[i], xsol.xR[i], s.xR[i] * xtol);
         }
      }
   }
// Test that linear equality constrained problem is solved with high precision.
//
// 50% of problems are rescaled wildly (variable scaling, with scale being
// passed to the solver).
   epsx = 1.0E-12;
   xtol = 1.0E-6;
   for (n = 1; n <= 10; n++) {
      for (scaletype = 0; scaletype <= 1; scaletype++) {
      // Generate random A, b, X0, constraints
         spdmatrixrndcond(n, pow(10.0, 3.0 * hqrnduniformr(&rs)), &rawa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xsol, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
            b.xR[i] = hqrndnormal(&rs);
         }
         rmatrixrndcond(n, 10.0, &z);
         rawccnt = imax2(n - 2, 0);
         if (rawccnt > 0) {
            ae_matrix_set_length(&rawc, rawccnt, n + 1);
            ae_vector_set_length(&rawct, rawccnt);
            for (i = 0; i < rawccnt; i++) {
               for (j = 0; j < n; j++) {
                  rawc.xyR[i][j] = z.xyR[i][j];
               }
               rawct.xZ[i] = 0;
               rawc.xyR[i][n] = hqrndnormal(&rs);
            }
         }
      // Generate scale vector, apply it
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            if (scaletype > 0) {
               s.xR[i] = pow(10.0, 10.0 * hqrndmiduniformr(&rs));
            } else {
               s.xR[i] = 1.0;
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rawa.xyR[i][j] /= s.xR[i] * s.xR[j];
            }
            b.xR[i] /= s.xR[i];
            x0.xR[i] *= s.xR[i];
            xsol.xR[i] *= s.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            for (j = 0; j < n; j++) {
               rawc.xyR[i][j] /= s.xR[j];
            }
         }
      // Create optimizer, solve
         rho = 100.0;
         outerits = 3;
         minqpcreate(n, &state);
         minqpsetalgodenseaul(&state, epsx, rho, outerits);
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
         minqpsetscale(&state, &s);
         minqpoptimize(&state);
         minqpresults(&state, &xf, &rep);
      // Solve problem analytically using Lagrangian approach
         ae_matrix_set_length(&z, n + rawccnt, n + rawccnt);
         ae_vector_set_length(&r, n + rawccnt);
         for (i = 0; i < n + rawccnt; i++) {
            for (j = 0; j < n + rawccnt; j++) {
               z.xyR[i][j] = 0.0;
            }
            r.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               z.xyR[i][j] = rawa.xyR[i][j];
            }
         }
         for (i = 0; i < n; i++) {
            r.xR[i] = -b.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            for (j = 0; j < n; j++) {
               z.xyR[n + i][j] = rawc.xyR[i][j];
               z.xyR[j][n + i] = rawc.xyR[i][j];
            }
            r.xR[n + i] = rawc.xyR[i][n];
         }
         rmatrixsolve(&z, n + rawccnt, &r, &k, &svrep, &xsol);
         ae_assert(k > 0, "MinQPTest: integrity check failed");
      // Compare against analytically known solution
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(xf.xR[i], xsol.xR[i], s.xR[i] * xtol);
         }
      }
   }
// MEDIUM-SCALE VERSION OF PREVIOUS TEST.
//
// Test that linear equality constrained problem is solved with high precision.
//
// 50% of problems are rescaled wildly (variable scaling, with scale being
// passed to the solver).
   epsx = 1.0E-12;
   xtol = 1.0E-6;
   for (n = 99; n <= 101; n++) {
      for (scaletype = 0; scaletype <= 1; scaletype++) {
      // Generate random A, b, X0, constraints
         spdmatrixrndcond(n, pow(10.0, 3.0 * hqrnduniformr(&rs)), &rawa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xsol, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
            b.xR[i] = hqrndnormal(&rs);
         }
         rmatrixrndcond(n, 10.0, &z);
         rawccnt = imax2(n - 2, 0);
         if (rawccnt > 0) {
            ae_matrix_set_length(&rawc, rawccnt, n + 1);
            ae_vector_set_length(&rawct, rawccnt);
            for (i = 0; i < rawccnt; i++) {
               for (j = 0; j < n; j++) {
                  rawc.xyR[i][j] = z.xyR[i][j];
               }
               rawct.xZ[i] = 0;
               rawc.xyR[i][n] = hqrndnormal(&rs);
            }
         }
      // Generate scale vector, apply it
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            if (scaletype > 0) {
               s.xR[i] = pow(10.0, 10.0 * hqrndmiduniformr(&rs));
            } else {
               s.xR[i] = 1.0;
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rawa.xyR[i][j] /= s.xR[i] * s.xR[j];
            }
            b.xR[i] /= s.xR[i];
            x0.xR[i] *= s.xR[i];
            xsol.xR[i] *= s.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            for (j = 0; j < n; j++) {
               rawc.xyR[i][j] /= s.xR[j];
            }
         }
      // Create optimizer, solve
         rho = 100.0;
         outerits = 3;
         minqpcreate(n, &state);
         minqpsetalgodenseaul(&state, epsx, rho, outerits);
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
         minqpsetscale(&state, &s);
         minqpoptimize(&state);
         minqpresults(&state, &xf, &rep);
      // Solve problem analytically using Lagrangian approach
         ae_matrix_set_length(&z, n + rawccnt, n + rawccnt);
         ae_vector_set_length(&r, n + rawccnt);
         for (i = 0; i < n + rawccnt; i++) {
            for (j = 0; j < n + rawccnt; j++) {
               z.xyR[i][j] = 0.0;
            }
            r.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               z.xyR[i][j] = rawa.xyR[i][j];
            }
         }
         for (i = 0; i < n; i++) {
            r.xR[i] = -b.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            for (j = 0; j < n; j++) {
               z.xyR[n + i][j] = rawc.xyR[i][j];
               z.xyR[j][n + i] = rawc.xyR[i][j];
            }
            r.xR[n + i] = rawc.xyR[i][n];
         }
         rmatrixsolve(&z, n + rawccnt, &r, &k, &svrep, &xsol);
         ae_assert(k > 0, "MinQPTest: integrity check failed");
      // Compare against analytically known solution
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(xf.xR[i], xsol.xR[i], s.xR[i] * xtol);
         }
      }
   }
// Test that constraints are automatically scaled to adapt to problem curvature
// (that multiplication of A and b by some large/small number does not affect
// solver).
//
// We generate random well-scaled problem, and multiply A/b by some large/small number,
// and test that problem is still solved with high precision.
//
// NOTE: just to make things worse, we rescale variables randomly, but primary
//       idea of this test is to check for multiplication of A/B
   epsx = 1.0E-12;
   xtol = 1.0E-6;
   for (n = 1; n <= 10; n++) {
      for (scaletype = -1; scaletype <= 1; scaletype++) {
      // Generate random A, b, X0, constraints
         spdmatrixrndcond(n, pow(10.0, 3.0 * hqrnduniformr(&rs)), &rawa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xsol, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
            b.xR[i] = hqrndnormal(&rs);
         }
         rmatrixrndcond(n, 10.0, &z);
         rawccnt = imax2(n - 2, 0);
         if (rawccnt > 0) {
            ae_matrix_set_length(&rawc, rawccnt, n + 1);
            ae_vector_set_length(&rawct, rawccnt);
            for (i = 0; i < rawccnt; i++) {
               for (j = 0; j < n; j++) {
                  rawc.xyR[i][j] = z.xyR[i][j];
               }
               rawct.xZ[i] = 0;
               rawc.xyR[i][n] = hqrndnormal(&rs);
            }
         }
      // Solve problem analytically using Lagrangian approach
         ae_matrix_set_length(&z, n + rawccnt, n + rawccnt);
         ae_vector_set_length(&r, n + rawccnt);
         for (i = 0; i < n + rawccnt; i++) {
            for (j = 0; j < n + rawccnt; j++) {
               z.xyR[i][j] = 0.0;
            }
            r.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               z.xyR[i][j] = rawa.xyR[i][j];
            }
         }
         for (i = 0; i < n; i++) {
            r.xR[i] = -b.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            for (j = 0; j < n; j++) {
               z.xyR[n + i][j] = rawc.xyR[i][j];
               z.xyR[j][n + i] = rawc.xyR[i][j];
            }
            r.xR[n + i] = rawc.xyR[i][n];
         }
         rmatrixsolve(&z, n + rawccnt, &r, &k, &svrep, &xsol);
         ae_assert(k > 0, "MinQPTest: integrity check failed");
      // Generate scale vector, apply it
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, 10.0 * hqrndmiduniformr(&rs));
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rawa.xyR[i][j] /= s.xR[i] * s.xR[j];
            }
            b.xR[i] /= s.xR[i];
            x0.xR[i] *= s.xR[i];
            xsol.xR[i] *= s.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            for (j = 0; j < n; j++) {
               rawc.xyR[i][j] /= s.xR[j];
            }
         }
      // Multiply A/B by some coefficient with wild magnitude
         v = pow(10.0, (double)(10 * scaletype));
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rawa.xyR[i][j] *= v;
            }
            b.xR[i] *= v;
         }
      // Create optimizer, solve
         rho = 100.0;
         outerits = 3;
         minqpcreate(n, &state);
         minqpsetalgodenseaul(&state, epsx, rho, outerits);
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
         minqpsetscale(&state, &s);
         minqpoptimize(&state);
         minqpresults(&state, &xf, &rep);
      // Compare against analytically known solution
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(xf.xR[i], xsol.xR[i], s.xR[i] * xtol);
         }
      }
   }
// Test that problem with slight negative curvature f = -0.001*|x|^2
// subject to general linear (!) constraints -1 <= x[i] <= +1 is
// correctly solved. Initial point is in [-0.001,+0.001] range.
//
// NOTE: this test is mostly intended for working set selection algorithm;
//       it must correctly detect non-SPD problems and select full working
//       set; starting with zero working set will result in recognition of
//       problem as unbounded one and premature termination of algorithm.
   epsx = 1.0E-12;
   xtol = 1.0E-6;
   for (n = 1; n <= 10; n++) {
   // Generate A, b, X0, constraints
      ae_matrix_set_length(&rawa, n, n);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            rawa.xyR[i][j] = 0.0;
         }
         rawa.xyR[i][i] = -0.001;
         b.xR[i] = 0.0;
         x0.xR[i] = 0.001 * hqrndnormal(&rs);
      }
      ae_matrix_set_length(&rawc, 2 * n, n + 1);
      ae_vector_set_length(&rawct, 2 * n);
      for (i = 0; i < n; i++) {
         for (j = 0; j <= n; j++) {
            rawc.xyR[2 * i][j] = 0.0;
            rawc.xyR[2 * i + 1][j] = 0.0;
         }
         rawc.xyR[2 * i][i] = 1.0;
         rawc.xyR[2 * i + 1][i] = 1.0;
         rawc.xyR[2 * i][n] = -1.0;
         rawc.xyR[2 * i + 1][n] = 1.0;
         rawct.xZ[2 * i] = 1;
         rawct.xZ[2 * i + 1] = -1;
      }
   // Create optimizer, solve
      rho = 100.0;
      outerits = 5;
      minqpcreate(n, &state);
      minqpsetalgodenseaul(&state, epsx, rho, outerits);
      minqpsetstartingpoint(&state, &x0);
      minqpsetquadraticterm(&state, &rawa, true);
      minqpsetlinearterm(&state, &b);
      minqpsetlc(&state, &rawc, &rawct, 2 * n);
      minqpoptimize(&state);
      minqpresults(&state, &xf, &rep);
   // Test
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(fabs(xf.xR[i]), 1.0, xtol);
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests IPM QP solver
static bool testminqpunit_ipmtests() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nmain;
   ae_int_t nslack;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_int_t nnz;
   ae_int_t nactive;
   double f0;
   double f1;
   ae_int_t akind;
   ae_int_t rawccnt;
   ae_int_t sparseccnt;
   ae_int_t denseccnt;
   bool issemidefinite;
   ae_int_t repterminationtype;
   double epsx;
   double xtol;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(maina, 0, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(xorigin, 0, DT_REAL);
   NewVector(xf, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(gtrial, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(rawc, 0, 0, DT_REAL);
   NewVector(rawcl, 0, DT_REAL);
   NewVector(rawcu, 0, DT_REAL);
   NewObj(sparsematrix, sparsec);
   NewMatrix(densec, 0, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewVector(lagbc, 0, DT_REAL);
   NewVector(laglc, 0, DT_REAL);
   NewObj(sparsematrix, dummysparse);
   NewObj(vipmstate, vsolver);
   NewVector(replagbc, 0, DT_REAL);
   NewVector(replaglc, 0, DT_REAL);
   NewVector(xsol, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(rawct, 0, DT_INT);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   hqrndrandomize(&rs);
// Test handling of slack variables by IPM solver. We use IPM directly,
// without wrapping it with MinQP interface layer.
//
// Convex optimization problem with known answer (we generate constraints
// and Lagrange coefficients, and then generate quadratic and linear term
// which satisfy KKT conditions for given Lagrange coefficients):
//
// * N = 1..8
// * f = 0.5*x'*A*x+b'*x
// * several kinds of A are tried: zero, well conditioned SPD, low rank
// * initial point x0 = [0 0 ... 0 0]
// * first, we generate set of linear constraints (without bounds),
//   solution point X and Lagrange multipliers for linear and box constraints
// * then we determine bounds on variables and linear constraints which
//   align with values/signs of Lagrange multipliers
// * then, having quadratic term A and known constraints and Lagrange
//   multipliers we determine linear term B which makes KKT conditions true
   epsx = 1.0E-12;
   for (nmain = 1; nmain <= 8; nmain++) {
      for (nslack = 0; nslack <= 8; nslack++) {
         for (akind = 0; akind <= 2; akind++) {
            n = nmain + nslack;
         // Generate quadratic term A, origin and scale
            ae_matrix_set_length(&maina, nmain, nmain);
            for (i = 0; i < nmain; i++) {
               for (j = 0; j < nmain; j++) {
                  maina.xyR[i][j] = 0.0;
               }
            }
            issemidefinite = true;
            if (akind == 1) {
            // Dense well conditioned SPD
               spdmatrixrndcond(nmain, 50.0, &maina);
               issemidefinite = false;
            }
            if (akind == 2) {
            // Low rank semidefinite
               ae_vector_set_length(&tmp, nmain);
               for (i = 0; i < nmain; i++) {
                  for (j = 0; j < nmain; j++) {
                     maina.xyR[i][j] = 0.0;
                  }
               }
               for (k = 1; k < imin2(4, nmain); k++) {
                  for (i = 0; i < nmain; i++) {
                     tmp.xR[i] = hqrndnormal(&rs);
                  }
                  v = pow(2.0, hqrndnormal(&rs));
                  for (i = 0; i < nmain; i++) {
                     for (j = 0; j < nmain; j++) {
                        maina.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                     }
                  }
               }
               issemidefinite = true;
            }
            issemidefinite = issemidefinite || nslack > 0;
            ae_matrix_set_length(&fulla, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  fulla.xyR[i][j] = 0.0;
               }
            }
            for (i = 0; i < nmain; i++) {
               for (j = 0; j < nmain; j++) {
                  fulla.xyR[i][j] = maina.xyR[i][j];
               }
            }
            ae_vector_set_length(&s, n);
            ae_vector_set_length(&xorigin, n);
            for (j = 0; j < n; j++) {
               xorigin.xR[j] = hqrndnormal(&rs);
               s.xR[j] = pow(2.0, hqrndnormal(&rs));
            }
         // Generate linear constraints (left parts)
            rawccnt = hqrnduniformi(&rs, 2 * n + 1);
            if (rawccnt > 0) {
               ae_matrix_set_length(&rawc, rawccnt, n);
               for (i = 0; i < rawccnt; i++) {
                  for (j = 0; j < n; j++) {
                     rawc.xyR[i][j] = 0.0;
                  }
                  nnz = hqrnduniformi(&rs, nmain + 1);
                  for (k = 0; k < nnz; k++) {
                     j = hqrnduniformi(&rs, nmain);
                     v = hqrndnormal(&rs);
                     v += 0.1 * possign(v);
                     rawc.xyR[i][j] = v;
                  }
               }
               for (j = nmain; j < n; j++) {
                  if (hqrndnormal(&rs) > 0.0) {
                     v = hqrndnormal(&rs);
                     v += 0.1 * possign(v);
                     rawc.xyR[hqrnduniformi(&rs, rawccnt)][j] = v;
                  }
               }
            }
         // Generate Lagrange multipliers, with 0 <= NActive <= N-1 being non-zero
            ae_vector_set_length(&lagbc, n);
            ae_vector_set_length(&laglc, rawccnt);
            for (i = 0; i < n; i++) {
               lagbc.xR[i] = 0.0;
            }
            for (i = 0; i < rawccnt; i++) {
               laglc.xR[i] = 0.0;
            }
            nactive = hqrnduniformi(&rs, n);
            k = hqrnduniformi(&rs, imin2(nactive, rawccnt) + 1);
            for (i = 0; i < k; i++) {
               v = hqrndnormal(&rs);
               v += 0.01 * possign(v);
               laglc.xR[hqrnduniformi(&rs, rawccnt)] = v;
            }
            for (i = k; i < nactive; i++) {
               v = hqrndnormal(&rs);
               v += 0.01 * possign(v);
               lagbc.xR[hqrnduniformi(&rs, n)] = v;
            }
         // Generate solution and gradient at the solution, set B to -G
            ae_vector_set_length(&xf, n);
            for (i = 0; i < n; i++) {
               xf.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&g, n);
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += fulla.xyR[i][j] * (xf.xR[j] - xorigin.xR[j]);
               }
               g.xR[i] = v;
            }
            for (i = 0; i < n; i++) {
               g.xR[i] += lagbc.xR[i];
            }
            for (i = 0; i < rawccnt; i++) {
               for (j = 0; j < n; j++) {
                  g.xR[j] += laglc.xR[i] * rawc.xyR[i][j];
               }
            }
            ae_vector_set_length(&b, n);
            for (j = 0; j < n; j++) {
               b.xR[j] = -g.xR[j];
            }
         // Set up bounds according to Lagrange multipliers
         //
         // NOTE: for semidefinite problems we set all variable bounds
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            for (j = 0; j < n; j++) {
               bndl.xR[j] = -INFINITY;
               bndu.xR[j] = +INFINITY;
               if (hqrndnormal(&rs) > 0.0 || issemidefinite || j >= nmain) {
                  bndl.xR[j] = xf.xR[j] - pow(2.0, hqrndnormal(&rs));
               }
               if (hqrndnormal(&rs) > 0.0 || issemidefinite || j >= nmain) {
                  bndu.xR[j] = xf.xR[j] + pow(2.0, hqrndnormal(&rs));
               }
               if (lagbc.xR[j] != 0.0) {
                  if (hqrnduniformr(&rs) < 0.15) {
                     bndl.xR[j] = xf.xR[j];
                     bndu.xR[j] = xf.xR[j];
                  } else {
                     if (lagbc.xR[j] < 0.0) {
                        bndl.xR[j] = xf.xR[j];
                     }
                     if (lagbc.xR[j] > 0.0) {
                        bndu.xR[j] = xf.xR[j];
                     }
                  }
               }
            }
            ae_vector_set_length(&rawcl, rawccnt);
            ae_vector_set_length(&rawcu, rawccnt);
            for (i = 0; i < rawccnt; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += rawc.xyR[i][j] * xf.xR[j];
               }
               rawcl.xR[i] = -INFINITY;
               rawcu.xR[i] = +INFINITY;
               if (hqrndnormal(&rs) > 0.0) {
                  rawcl.xR[i] = v - pow(2.0, hqrndnormal(&rs));
               }
               if (hqrndnormal(&rs) > 0.0) {
                  rawcu.xR[i] = v + pow(2.0, hqrndnormal(&rs));
               }
               if (laglc.xR[i] != 0.0) {
                  if (hqrnduniformr(&rs) < 0.15) {
                  // Active equality constraint
                     rawcl.xR[i] = v;
                     rawcu.xR[i] = v;
                  } else {
                  // Active inequality constraint
                     if (laglc.xR[i] < 0.0) {
                        rawcl.xR[i] = v;
                     }
                     if (laglc.xR[i] > 0.0) {
                        rawcu.xR[i] = v;
                     }
                  }
               }
               if (!isfinite(rawcl.xR[i]) && !isfinite(rawcu.xR[i])) {
               // At least one bound must be present for linear constraint
                  if (hqrndnormal(&rs) > 0.0) {
                     rawcl.xR[i] = v - 10;
                  } else {
                     rawcu.xR[i] = v + 10;
                  }
               }
            }
         // Randomly split constraints into dense and sparse parts
            sparseccnt = hqrnduniformi(&rs, rawccnt + 1);
            denseccnt = rawccnt - sparseccnt;
            if (sparseccnt > 0) {
               sparsecreate(sparseccnt, n, 0, &sparsec);
               for (i = 0; i < sparseccnt; i++) {
                  for (j = 0; j < n; j++) {
                     sparseset(&sparsec, i, j, rawc.xyR[i][j]);
                  }
               }
               sparseconverttocrs(&sparsec);
            }
            if (denseccnt > 0) {
               ae_matrix_set_length(&densec, denseccnt, n);
               for (i = 0; i < denseccnt; i++) {
                  for (j = 0; j < n; j++) {
                     densec.xyR[i][j] = rawc.xyR[i + sparseccnt][j];
                  }
               }
            }
         // Solve
            vipminitdensewithslacks(&vsolver, &s, &xorigin, nmain, n);
            vipmsetquadraticlinear(&vsolver, &fulla, &dummysparse, 0, hqrndnormal(&rs) > 0.0, &b);
            vipmsetconstraints(&vsolver, &bndl, &bndu, &sparsec, sparseccnt, &densec, denseccnt, &rawcl, &rawcu);
            vipmsetcond(&vsolver, epsx, epsx, epsx);
            vipmoptimize(&vsolver, false, &x1, &replagbc, &replaglc, &repterminationtype);
            Ok = Ok && repterminationtype > 0;
            Ok = Ok && x1.cnt >= n;
            Ok = Ok && replagbc.cnt >= n;
            Ok = Ok && replaglc.cnt >= rawccnt;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Test function value at the solution
            f0 = testminqpunit_quadratictarget(&fulla, &b, n, &x1);
            f1 = testminqpunit_quadratictarget(&fulla, &b, n, &xf);
            Ok = Ok && NearAtR(f0, f1, rmax3(fabs(f0), fabs(f1), 1.0) * 1.0E-3);
         // Test Lagrange multipliers returned by the solver
            ae_vector_set_length(&gtrial, n);
            for (i = 0; i < n; i++) {
               v = b.xR[i];
               for (j = 0; j < n; j++) {
                  v += fulla.xyR[i][j] * (x1.xR[j] - xorigin.xR[j]);
               }
               gtrial.xR[i] = v;
            }
            for (i = 0; i < n; i++) {
               gtrial.xR[i] += replagbc.xR[i];
            }
            for (i = 0; i < rawccnt; i++) {
               for (j = 0; j < n; j++) {
                  gtrial.xR[j] += replaglc.xR[i] * rawc.xyR[i][j];
               }
            }
            for (i = 0; i < n; i++) {
               Ok = Ok && SmallAtR(gtrial.xR[i], 1.0E-3);
            }
         }
      }
   }
// Test that problem with zero constraint matrix can be solved
// (with high precision). We do not perform any additional "tweaks"
// like scaling of variables, just want to test ability to handle
// zero matrices.
   epsx = 1.0E-8;
   xtol = 1.0E-5;
   for (n = 1; n <= 10; n++) {
   // Generate random A, b, X0 and XSOL
      spdmatrixrndcond(n, pow(10.0, 3.0 * hqrnduniformr(&rs)), &fulla);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&xsol, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
         xsol.xR[i] = hqrndnormal(&rs);
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(fulla.xyR[i], 1, xsol.xR, 1, n);
         b.xR[i] = -v;
      }
      rawccnt = hqrnduniformi(&rs, 2 * n);
      ae_matrix_set_length(&rawc, rawccnt, n + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         for (j = 0; j <= n; j++) {
            rawc.xyR[i][j] = 0.0;
         }
         rawct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
      }
   // Create optimizer, solve
      minqpcreate(n, &state);
      if (hqrndnormal(&rs) > 0.0) {
         minqpsetalgodenseipm(&state, epsx);
      } else {
         minqpsetalgosparseipm(&state, epsx);
      }
      minqpsetlinearterm(&state, &b);
      testminqpunit_randomlyselectconvertandsetquadraticterm(&fulla, n, &state, &rs);
      minqpsetlc(&state, &rawc, &rawct, rawccnt);
      minqpsetstartingpoint(&state, &x0);
      minqpoptimize(&state);
      minqpresults(&state, &xf, &rep);
   // Compare against analytically known solution
      if (rep.terminationtype <= 0) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(xf.xR[i], xsol.xR[i], xtol);
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests various special properties
static bool testminqpunit_spectests() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   double xtol;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   NewMatrix(rawa, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(xs2, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   hqrndrandomize(&rs);
// Test correctness of MinQPSetScaleDiagAuto():
// * that it correctly handles matrices with positive diagonals
// * that it correctly handles non-positive elements
//
// First test is performed by comparing one step of automatically
// scaled QP-BLEIC with one step of manually scaled QP-BLEIC.
   xtol = 1.0E-6;
   for (n = 1; n <= 10; n++) {
   // Generate random box constrained QP problem with specially
   // crafted diagonal.
      ae_matrix_set_length(&rawa, n, n);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            rawa.xyR[i][j] = hqrndnormal(&rs);
         }
         rawa.xyR[i][i] = pow(2.0, (double)(hqrnduniformi(&rs, 9) - 4));
         b.xR[i] = hqrndnormal(&rs);
         bndl.xR[i] = -1.0;
         bndu.xR[i] = 1.0;
         x0.xR[i] = 0.0;
      }
   // Create solver
      minqpcreate(n, &state);
      minqpsetalgobleic(&state, 0.0, 0.0, 0.0, 1);
      minqpsetlinearterm(&state, &b);
      testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
      minqpsetbc(&state, &bndl, &bndu);
      minqpsetstartingpoint(&state, &x0);
   // Solve with automatic scaling
   // Solve with manual scaling
   // Compare
      ae_vector_set_length(&xs, 0);
      minqpsetscaleautodiag(&state);
      minqpoptimize(&state);
      minqpresults(&state, &xs, &rep);
      Ok = Ok && rep.terminationtype > 0;
      Ok = Ok && xs.cnt == n;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 1 / sqrt(rawa.xyR[i][i]);
      }
      minqpsetscale(&state, &s);
      minqpoptimize(&state);
      minqpresults(&state, &xs2, &rep);
      Ok = Ok && rep.terminationtype > 0;
      Ok = Ok && xs2.cnt == n;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(xs.xR[i], xs2.xR[i], xtol);
      }
   // Check that automatic scaling fails for matrices with zero or negative elements
      i = hqrnduniformi(&rs, n);
      j = hqrnduniformi(&rs, 2) - 1;
      rawa.xyR[i][i] = (double)j;
      testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
      minqpsetscaleautodiag(&state);
      minqpoptimize(&state);
      minqpresults(&state, &xs, &rep);
      Ok = Ok && rep.terminationtype == -9;
   }
   ae_frame_leave();
   return Ok;
}

bool testminqp() {
// The VERY basic tests for Cholesky and BLEIC
   bool simpleOk = simpletest();
   bool func1Ok = functest1();
   bool func2Ok = functest2();
// Solver-specific tests
   bool quickqpOk = quickqptests();
   bool bleicOk = bleictests();
   bool denseaulOk = testminqpunit_denseaultests();
   bool ipmOk = testminqpunit_ipmtests();
//
   bool bcqpOk = testminqpunit_bcqptest();
   bool ecqpOk = testminqpunit_ecqptest(); //(@)
   bool icqpOk = testminqpunit_icqptest(); //(@)
   icqpOk = icqpOk && testminqpunit_specialicqptests();
   bool lcqpOk = testminqpunit_generallcqptest();
   bool linOk = ecqpOk && icqpOk && lcqpOk;
   bool specOk = testminqpunit_spectests();
// The final report.
   bool Ok = simpleOk && func1Ok && func2Ok && bcqpOk && linOk && quickqpOk && bleicOk && denseaulOk && ipmOk && specOk;
   if (!Ok || !silent) {
      printf("MinQP Optimization Tests\n");
      printf("Basic Tests:\n");
      printf("* Simple Test:                            %s\n", simpleOk? "Ok": "Failed");
      printf("* Func1 Test:                             %s\n", func1Ok? "Ok": "Failed");
      printf("* Func2 Test:                             %s\n", func2Ok? "Ok": "Failed");
      printf("Generic QP Tests:\n");
      printf("* Box Constrained:                        %s\n", bcqpOk? "Ok": "Failed");
      printf("* Linearly Constrained:                   %s\n", linOk? "Ok": "Failed");
      if (!linOk) {
         printf("* - EC:                                   %s\n", ecqpOk? "Ok": "Failed");
         printf("* - IC:                                   %s\n", icqpOk? "Ok": "Failed");
         printf("* - LC:                                   %s\n", lcqpOk? "Ok": "Failed");
      }
      printf("Solver-Specific Tests:\n");
      printf("* QuickQP Solver Tests:                   %s\n", quickqpOk? "Ok": "Failed");
      printf("* BLEIC Solver Tests:                     %s\n", bleicOk? "Ok": "Failed");
      printf("* Dense-AUL Solver Tests:                 %s\n", denseaulOk? "Ok": "Failed");
      printf("* IPM Solver Tests:                       %s\n", ipmOk? "Ok": "Failed");
      printf("Special Properties:                       %s\n", specOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === minlm testing unit ===
// Asserts that State fields are consistent with RKind.
// Returns False otherwise.
//
// RKind is an algorithm selector:
// * -2 = V, AccType == 1
// * -1 = V, AccType == 0
// *  0 = FJ
// *  1 = FGJ
// *  2 = FGH
// *  3 = VJ, AccType == 0
// *  4 = VJ, AccType == 1
// *  5 = VJ, AccType == 2
//
static bool testminlmunit_rkindvsstatecheck(ae_int_t rkind, minlmstate *state) {
   ae_int_t nset;
   bool result;
   nset = 0;
   if (state->needfi) {
      nset++;
   }
   if (state->needf) {
      nset++;
   }
#if 0
   if (state->needfg) {
      nset++;
   }
#endif
   if (state->needfij) {
      nset++;
   }
   if (state->needfgh) {
      nset++;
   }
   if (state->xupdated) {
      nset++;
   }
   if (nset != 1) {
      result = false;
      return result;
   }
   if (rkind == -2) {
      result = state->needfi || state->xupdated;
      return result;
   }
   if (rkind == -1) {
      result = state->needfi || state->xupdated;
      return result;
   }
   if (rkind == 0) {
      result = state->needf || state->needfij || state->xupdated;
      return result;
   }
   if (rkind == 1) {
      result = state->needf || state->needfij || /*state->needfg || */state->xupdated;
      return result;
   }
   if (rkind == 2) {
      result = state->needf || /*state->needfg || */state->needfgh || state->xupdated;
      return result;
   }
   if (rkind == 3) {
      result = state->needfi || state->needfij || state->xupdated;
      return result;
   }
   if (rkind == 4) {
      result = state->needfi || state->needfij || state->xupdated;
      return result;
   }
   if (rkind == 5) {
      result = state->needfi || state->needfij || state->xupdated;
      return result;
   }
   result = false;
   return result;
}

// Calculates FI/F/G/H for problem min(||Ax-b||)
static void testminlmunit_axmb(minlmstate *state, RMatrix *a, RVector *b, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   if (state->needf || /*state->needfg || */state->needfgh) {
      state->f = 0.0;
   }
   if (/*state->needfg || */state->needfgh) {
      for (i = 0; i < n; i++) {
         state->g.xR[i] = 0.0;
      }
   }
   if (state->needfgh) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            state->h.xyR[i][j] = 0.0;
         }
      }
   }
   for (i = 0; i < n; i++) {
      v = ae_v_dotproduct(a->xyR[i], 1, state->x.xR, 1, n);
      if (state->needf || /*state->needfg || */state->needfgh) {
         state->f += sqr(v - b->xR[i]);
      }
      if (/*state->needfg || */state->needfgh) {
         for (j = 0; j < n; j++) {
            state->g.xR[j] += 2 * (v - b->xR[i]) * a->xyR[i][j];
         }
      }
      if (state->needfgh) {
         for (j = 0; j < n; j++) {
            for (k = 0; k < n; k++) {
               state->h.xyR[j][k] += 2 * a->xyR[i][j] * a->xyR[i][k];
            }
         }
      }
      if (state->needfi) {
         state->fi.xR[i] = v - b->xR[i];
      }
      if (state->needfij) {
         state->fi.xR[i] = v - b->xR[i];
         ae_v_move(state->j.xyR[i], 1, a->xyR[i], 1, n);
      }
   }
}

// Test for unconstrained problems.
static bool testminlmunit_testu(bool *StateFieldConsistencyOkP) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   double h;
   ae_int_t rkind;
   double v;
   double s;
   double eps;
   double epsx;
   ae_int_t maxits;
   ae_int_t ckind;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(minlmstate, state);
   NewObj(minlmreport, rep);
// Reference problem.
// See comments for RKindVsStateCheck() for more info about RKind.
//
// NOTES: we also test negative RKind's corresponding to "inexact" schemes
// which use approximate finite difference Jacobian.
   ae_vector_set_length(&x, 3);
   n = 3;
   m = 3;
   h = 0.0001;
   for (rkind = -2; rkind <= 5; rkind++) {
      x.xR[0] = 50.0 * randommid();
      x.xR[1] = 50.0 * randommid();
      x.xR[2] = 50.0 * randommid();
      if (rkind == -2) {
         minlmcreatev(n, m, &x, h, &state);
         minlmsetacctype(&state, 1);
      }
      if (rkind == -1) {
         minlmcreatev(n, m, &x, h, &state);
         minlmsetacctype(&state, 0);
      }
      if (rkind == 0) {
         minlmcreatefj(n, m, &x, &state);
      }
      if (rkind == 1) {
         minlmcreatefgj(n, m, &x, &state);
      }
      if (rkind == 2) {
         minlmcreatefgh(n, &x, &state);
      }
      if (rkind == 3) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 0);
      }
      if (rkind == 4) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 1);
      }
      if (rkind == 5) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 2);
      }
      while (minlmiteration(&state)) {
      // (x-2)^2 + y^2 + (z-x)^2
         if (state.needfi || state.needfij) {
            state.fi.xR[0] = state.x.xR[0] - 2;
            state.fi.xR[1] = state.x.xR[1];
            state.fi.xR[2] = state.x.xR[2] - state.x.xR[0];
         }
         if (state.needfij) {
            state.j.xyR[0][0] = 1.0;
            state.j.xyR[0][1] = 0.0;
            state.j.xyR[0][2] = 0.0;
            state.j.xyR[1][0] = 0.0;
            state.j.xyR[1][1] = 1.0;
            state.j.xyR[1][2] = 0.0;
            state.j.xyR[2][0] = -1.0;
            state.j.xyR[2][1] = 0.0;
            state.j.xyR[2][2] = 1.0;
         }
         if (state.needf || /*state.needfg || */state.needfgh) {
            state.f = sqr(state.x.xR[0] - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
         }
         if (/*state.needfg || */state.needfgh) {
            state.g.xR[0] = 2 * (state.x.xR[0] - 2) + 2 * (state.x.xR[0] - state.x.xR[2]);
            state.g.xR[1] = 2 * state.x.xR[1];
            state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
         }
         if (state.needfgh) {
            state.h.xyR[0][0] = 4.0;
            state.h.xyR[0][1] = 0.0;
            state.h.xyR[0][2] = -2.0;
            state.h.xyR[1][0] = 0.0;
            state.h.xyR[1][1] = 2.0;
            state.h.xyR[1][2] = 0.0;
            state.h.xyR[2][0] = -2.0;
            state.h.xyR[2][1] = 0.0;
            state.h.xyR[2][2] = 2.0;
         }
         *StateFieldConsistencyOkP = *StateFieldConsistencyOkP && testminlmunit_rkindvsstatecheck(rkind, &state);
      }
      minlmresults(&state, &x, &rep);
      Ok = Ok && rep.terminationtype > 0;
      Ok = Ok && NearAtR(x.xR[0], 2, 0.001);
      Ok = Ok && SmallAtR(x.xR[1], 0.001);
      Ok = Ok && NearAtR(x.xR[2], 2, 0.001);
   }
// 1D problem #1
//
// NOTES: we also test negative RKind's corresponding to "inexact" schemes
// which use approximate finite difference Jacobian.
   for (rkind = -2; rkind <= 5; rkind++) {
      ae_vector_set_length(&x, 1);
      n = 1;
      m = 1;
      h = 0.00001;
      x.xR[0] = 50.0 * randommid();
      if (rkind == -2) {
         minlmcreatev(n, m, &x, h, &state);
         minlmsetacctype(&state, 1);
      }
      if (rkind == -1) {
         minlmcreatev(n, m, &x, h, &state);
         minlmsetacctype(&state, 0);
      }
      if (rkind == 0) {
         minlmcreatefj(n, m, &x, &state);
      }
      if (rkind == 1) {
         minlmcreatefgj(n, m, &x, &state);
      }
      if (rkind == 2) {
         minlmcreatefgh(n, &x, &state);
      }
      if (rkind == 3) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 0);
      }
      if (rkind == 4) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 1);
      }
      if (rkind == 5) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 2);
      }
      while (minlmiteration(&state)) {
         if (state.needfi || state.needfij) {
            state.fi.xR[0] = sin(state.x.xR[0]);
         }
         if (state.needfij) {
            state.j.xyR[0][0] = cos(state.x.xR[0]);
         }
         if (state.needf || /*state.needfg || */state.needfgh) {
            state.f = sqr(sin(state.x.xR[0]));
         }
         if (/*state.needfg || */state.needfgh) {
            state.g.xR[0] = 2 * sin(state.x.xR[0]) * cos(state.x.xR[0]);
         }
         if (state.needfgh) {
            state.h.xyR[0][0] = 2 * (cos(state.x.xR[0]) * cos(state.x.xR[0]) - sin(state.x.xR[0]) * sin(state.x.xR[0]));
         }
         *StateFieldConsistencyOkP = *StateFieldConsistencyOkP && testminlmunit_rkindvsstatecheck(rkind, &state);
      }
      minlmresults(&state, &x, &rep);
      Ok = Ok && rep.terminationtype > 0;
      Ok = Ok && NearAtR(x.xR[0] / pi, round(x.xR[0] / pi), 0.001);
   }
// Linear equations: test normal optimization and optimization with restarts
   for (n = 1; n <= 10; n++) {
   // Prepare task
      h = 0.00001;
      rmatrixrndcond(n, 100.0, &a);
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xe, n);
      ae_vector_set_length(&b, n);
      for (i = 0; i < n; i++) {
         xe.xR[i] = randommid();
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(a.xyR[i], 1, xe.xR, 1, n);
         b.xR[i] = v;
      }
   // Test different RKind
   //
   // NOTES: we also test negative RKind's corresponding to "inexact" schemes
   // which use approximate finite difference Jacobian.
      for (rkind = -2; rkind <= 5; rkind++) {
      // Solve task (first attempt)
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         if (rkind == -2) {
            minlmcreatev(n, n, &x, h, &state);
            minlmsetacctype(&state, 1);
         }
         if (rkind == -1) {
            minlmcreatev(n, n, &x, h, &state);
            minlmsetacctype(&state, 0);
         }
         if (rkind == 0) {
            minlmcreatefj(n, n, &x, &state);
         }
         if (rkind == 1) {
            minlmcreatefgj(n, n, &x, &state);
         }
         if (rkind == 2) {
            minlmcreatefgh(n, &x, &state);
         }
         if (rkind == 3) {
            minlmcreatevj(n, n, &x, &state);
            minlmsetacctype(&state, 0);
         }
         if (rkind == 4) {
            minlmcreatevj(n, n, &x, &state);
            minlmsetacctype(&state, 1);
         }
         if (rkind == 5) {
            minlmcreatevj(n, n, &x, &state);
            minlmsetacctype(&state, 2);
         }
         while (minlmiteration(&state)) {
            testminlmunit_axmb(&state, &a, &b, n);
            *StateFieldConsistencyOkP = *StateFieldConsistencyOkP && testminlmunit_rkindvsstatecheck(rkind, &state);
         }
         minlmresults(&state, &x, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(x.xR[i], xe.xR[i], 0.001);
         }
      // Now we try to restart algorithm from new point
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         for (minlmrestartfrom(&state, &x); minlmiteration(&state); ) {
            testminlmunit_axmb(&state, &a, &b, n);
            *StateFieldConsistencyOkP = *StateFieldConsistencyOkP && testminlmunit_rkindvsstatecheck(rkind, &state);
         }
         minlmresults(&state, &x, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(x.xR[i], xe.xR[i], 0.001);
         }
      }
   }
// Testing convergence properties using
// different optimizer types and different conditions.
//
// Only limited subset of optimizers is tested because some
// optimizers converge too quickly.
   s = 100.0;
   for (rkind = 0; rkind <= 5; rkind++) {
   // Skip FGH optimizer - it converges too quickly
      if (rkind == 2) {
         continue;
      }
   // Test
      for (ckind = 0; ckind <= 1; ckind++) {
         eps = 0.0;
         epsx = 0.0;
         maxits = 0;
         if (ckind == 0) {
            epsx = 1.0E-6;
            eps = 1.0E-4;
         }
         if (ckind == 1) {
            maxits = 2;
            eps = 0.05;
         }
         ae_vector_set_length(&x, 3);
         n = 3;
         m = 3;
         for (i = 0; i <= 2; i++) {
            x.xR[i] = 6.0;
         }
         if (rkind == 0) {
            minlmcreatefj(n, m, &x, &state);
         }
         if (rkind == 1) {
            minlmcreatefgj(n, m, &x, &state);
         }
         ae_assert(rkind != 2, "Assertion failed");
         if (rkind == 3) {
            minlmcreatevj(n, m, &x, &state);
            minlmsetacctype(&state, 0);
         }
         if (rkind == 4) {
            minlmcreatevj(n, m, &x, &state);
            minlmsetacctype(&state, 1);
         }
         if (rkind == 5) {
            minlmcreatevj(n, m, &x, &state);
            minlmsetacctype(&state, 2);
         }
         minlmsetcond(&state, epsx, maxits);
         while (minlmiteration(&state)) {
            if (state.needfi || state.needfij) {
               state.fi.xR[0] = s * (exp(state.x.xR[0]) - 2);
               state.fi.xR[1] = sqr(state.x.xR[1]) + 1;
               state.fi.xR[2] = state.x.xR[2] - state.x.xR[0];
            }
            if (state.needfij) {
               state.j.xyR[0][0] = s * exp(state.x.xR[0]);
               state.j.xyR[0][1] = 0.0;
               state.j.xyR[0][2] = 0.0;
               state.j.xyR[1][0] = 0.0;
               state.j.xyR[1][1] = 2 * state.x.xR[1];
               state.j.xyR[1][2] = 0.0;
               state.j.xyR[2][0] = -1.0;
               state.j.xyR[2][1] = 0.0;
               state.j.xyR[2][2] = 1.0;
            }
            if (state.needf || /*state.needfg || */state.needfgh) {
               state.f = s * sqr(exp(state.x.xR[0]) - 2) + sqr(sqr(state.x.xR[1]) + 1) + sqr(state.x.xR[2] - state.x.xR[0]);
            }
            if (/*state.needfg || */state.needfgh) {
               state.g.xR[0] = s * 2 * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[0] - state.x.xR[2]);
               state.g.xR[1] = 2 * (sqr(state.x.xR[1]) + 1) * 2 * state.x.xR[1];
               state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
            }
            if (state.needfgh) {
               state.h.xyR[0][0] = s * (4 * sqr(exp(state.x.xR[0])) - 4 * exp(state.x.xR[0])) + 2;
               state.h.xyR[0][1] = 0.0;
               state.h.xyR[0][2] = -2.0;
               state.h.xyR[1][0] = 0.0;
               state.h.xyR[1][1] = 12 * sqr(state.x.xR[1]) + 4;
               state.h.xyR[1][2] = 0.0;
               state.h.xyR[2][0] = -2.0;
               state.h.xyR[2][1] = 0.0;
               state.h.xyR[2][2] = 2.0;
            }
            *StateFieldConsistencyOkP = *StateFieldConsistencyOkP && testminlmunit_rkindvsstatecheck(rkind, &state);
         }
         minlmresults(&state, &x, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         if (ckind == 0) {
            Ok = Ok && NearAtR(x.xR[0], log(2.0), eps);
            Ok = Ok && SmallAtR(x.xR[1], eps);
            Ok = Ok && NearAtR(x.xR[2], log(2.0), eps);
            Ok = Ok && rep.terminationtype == 2;
         }
         if (ckind == 1) {
            Ok = Ok && rep.terminationtype == 5;
            Ok = Ok && rep.iterationscount == maxits;
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test function 1:
//
//     F(N, M, C, X) = SUM( f_i^2 )
//     f_i = SUM( (power(x_j,3)+alpha*x_j)*c_ij )
static void testminlmunit_testfunc1(ae_int_t n, ae_int_t m, RMatrix *c, RVector *x, double *f, bool needf, RVector *fi, bool needfi, RMatrix *jac, bool needjac) {
   ae_int_t i;
   ae_int_t j;
   double v;
   double alpha;
   alpha = 0.01;
   if (needf) {
      *f = 0.0;
   }
   for (i = 0; i < m; i++) {
      v = c->xyR[i][n];
      for (j = 0; j < n; j++) {
         v += (alpha * x->xR[j] + pow(x->xR[j], 3.0)) * c->xyR[i][j];
         if (needjac) {
            jac->xyR[i][j] = (alpha + 3 * pow(x->xR[j], 2.0)) * c->xyR[i][j];
         }
      }
      if (needfi) {
         fi->xR[i] = v;
      }
      if (needf) {
         *f += v * v;
      }
   }
}

// Test for box constrained problems.
static bool testminlmunit_testbc() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   double v;
   double h;
   ae_int_t tmpkind;
   double epsx;
   double tolf;
   double f0;
   double f1;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(minlmstate, state);
   NewObj(minlmreport, rep);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Reference box constrained problem:
//
//     min sum((x[i]-xe[i])^4) subject to 0 <= x[i] <= 1
//
// NOTES:
// 1. we test only two optimization modes - V and FGH,
//    because from algorithm internals we can assume that actual
//    mode being used doesn't matter for bound constrained optimization
//    process.
   for (tmpkind = 0; tmpkind <= 1; tmpkind++) {
      for (n = 1; n <= 5; n++) {
         ae_vector_set_length(&bl, n);
         ae_vector_set_length(&bu, n);
         ae_vector_set_length(&xe, n);
         ae_vector_set_length(&x, n);
         for (i = 0; i < n; i++) {
            bl.xR[i] = 0.0;
            bu.xR[i] = 1.0;
            xe.xR[i] = 3.0 * randomreal() - 1.0;
            x.xR[i] = randomreal();
         }
         if (tmpkind == 0) {
            minlmcreatefgh(n, &x, &state);
         }
         if (tmpkind == 1) {
            minlmcreatev(n, n, &x, 1.0E-5, &state);
         }
         minlmsetcond(&state, 1.0E-6, 0);
         minlmsetbc(&state, &bl, &bu);
         while (minlmiteration(&state)) {
            if (state.needfi) {
               for (i = 0; i < n; i++) {
                  state.fi.xR[i] = pow(state.x.xR[i] - xe.xR[i], 2.0);
               }
            }
            if (state.needf ||/* state.needfg ||*/ state.needfgh) {
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  state.f += pow(state.x.xR[i] - xe.xR[i], 4.0);
               }
            }
            if (/*state.needfg ||*/ state.needfgh) {
               for (i = 0; i < n; i++) {
                  state.g.xR[i] = 4 * pow(state.x.xR[i] - xe.xR[i], 3.0);
               }
            }
            if (state.needfgh) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     state.h.xyR[i][j] = 0.0;
                  }
               }
               for (i = 0; i < n; i++) {
                  state.h.xyR[i][i] = 12 * pow(state.x.xR[i] - xe.xR[i], 2.0);
               }
            }
         }
         minlmresults(&state, &x, &rep);
         if (rep.terminationtype > 0) {
            for (i = 0; i < n; i++) {
               Ok = Ok && NearAtR(x.xR[i], rboundval(xe.xR[i], bl.xR[i], bu.xR[i]), 5.0E-2);
            }
         } else {
            Ok = false;
         }
      }
   }
// Minimize
//
//          [      [                   ]2  ]
//     SUM_i[ SUM_j[ power(x_j,3)*c_ij ]   ]
//          [      [                   ]   ]
//
// subject to non-negativity constraints on x_j
   epsx = 1.0E-9;
   tolf = 1.0E-10;
   for (tmpkind = 0; tmpkind <= 1; tmpkind++) {
      for (n = 1; n <= 20; n++) {
         m = n + hqrnduniformi(&rs, n);
         ae_vector_set_length(&bl, n);
         ae_vector_set_length(&bu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            bl.xR[i] = 0.0;
            bu.xR[i] = +INFINITY;
            x0.xR[i] = 1.0 + hqrnduniformr(&rs);
         }
         ae_matrix_set_length(&c, m, n + 1);
         for (i = 0; i < m; i++) {
            for (j = 0; j <= n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
            }
         }
         if (tmpkind == 0) {
            minlmcreatev(n, m, &x0, 10 * epsx, &state);
         }
         if (tmpkind == 1) {
            minlmcreatevj(n, m, &x0, &state);
         }
         minlmsetcond(&state, epsx, 0);
         minlmsetbc(&state, &bl, &bu);
         while (minlmiteration(&state)) {
            for (i = 0; i < n; i++) {
               Ok = Ok && state.x.xR[i] >= bl.xR[i];
               Ok = Ok && state.x.xR[i] <= bu.xR[i];
            }
            if (state.needfi) {
               testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, false);
            } else if (state.needfij) {
               testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, true);
            } else ae_assert(false, "minlm test: integrity check failed");
         }
         minlmresults(&state, &x, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         testminlmunit_testfunc1(n, m, &c, &x, &f0, true, &state.fi, false, &state.j, false);
         ae_vector_set_length(&x1, n);
         h = 0.001;
         for (i = 0; i < n; i++) {
            Ok = Ok && x.xR[i] >= bl.xR[i];
            Ok = Ok && x.xR[i] <= bu.xR[i];
            if (x.xR[i] + h >= bl.xR[i]) {
               for (j = 0; j < n; j++) {
                  x1.xR[j] = x.xR[j];
               }
               x1.xR[i] = x.xR[i] + h;
               testminlmunit_testfunc1(n, m, &c, &x1, &f1, true, &state.fi, false, &state.j, false);
               Ok = Ok && f1 >= f0 * (1 - tolf);
            }
            if (x.xR[i] - h >= bl.xR[i]) {
               for (j = 0; j < n; j++) {
                  x1.xR[j] = x.xR[j];
               }
               x1.xR[i] = x.xR[i] - h;
               testminlmunit_testfunc1(n, m, &c, &x1, &f1, true, &state.fi, false, &state.j, false);
               Ok = Ok && f1 >= f0 * (1 - tolf);
            }
         }
      }
   }
// Minimize
//
//          [      [                   ]2  ]
//     SUM_i[ SUM_j[ power(x_j,3)*c_ij ]   ]
//          [      [                   ]   ]
//
// subject to random box constraints on x_j
   epsx = 1.0E-9;
   tolf = 1.0E-10;
   for (tmpkind = 0; tmpkind <= 1; tmpkind++) {
      for (n = 1; n <= 20; n++) {
         m = n + hqrnduniformi(&rs, n);
         ae_vector_set_length(&bl, n);
         ae_vector_set_length(&bu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            bl.xR[i] = hqrndnormal(&rs);
            bu.xR[i] = bl.xR[i] + hqrnduniformr(&rs);
            x0.xR[i] = 1.0 + hqrnduniformr(&rs);
         }
         ae_matrix_set_length(&c, m, n + 1);
         for (i = 0; i < m; i++) {
            for (j = 0; j <= n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
            }
         }
         if (tmpkind == 0) {
            minlmcreatev(n, m, &x0, 10 * epsx, &state);
         }
         if (tmpkind == 1) {
            minlmcreatevj(n, m, &x0, &state);
         }
         minlmsetcond(&state, epsx, 0);
         minlmsetbc(&state, &bl, &bu);
         while (minlmiteration(&state)) {
            for (i = 0; i < n; i++) {
               Ok = Ok && state.x.xR[i] >= bl.xR[i];
               Ok = Ok && state.x.xR[i] <= bu.xR[i];
            }
            if (state.needfi) {
               testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, false);
            } else if (state.needfij) {
               testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, true);
            } else ae_assert(false, "minlm test: integrity check failed");
         }
         minlmresults(&state, &x, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         testminlmunit_testfunc1(n, m, &c, &x, &f0, true, &state.fi, false, &state.j, false);
         ae_vector_set_length(&x1, n);
         h = 0.001;
         for (i = 0; i < n; i++) {
            Ok = Ok && x.xR[i] >= bl.xR[i];
            Ok = Ok && x.xR[i] <= bu.xR[i];
            if (x.xR[i] + h >= bl.xR[i] && x.xR[i] + h <= bu.xR[i]) {
               for (j = 0; j < n; j++) {
                  x1.xR[j] = x.xR[j];
               }
               x1.xR[i] = x.xR[i] + h;
               testminlmunit_testfunc1(n, m, &c, &x1, &f1, true, &state.fi, false, &state.j, false);
               Ok = Ok && f1 >= f0 * (1 - tolf);
            }
            if (x.xR[i] - h >= bl.xR[i] && x.xR[i] - h <= bu.xR[i]) {
               for (j = 0; j < n; j++) {
                  x1.xR[j] = x.xR[j];
               }
               x1.xR[i] = x.xR[i] - h;
               testminlmunit_testfunc1(n, m, &c, &x1, &f1, true, &state.fi, false, &state.j, false);
               Ok = Ok && f1 >= f0 * (1 - tolf);
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test for linearly constrained problems.
static bool testminlmunit_testlc() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t m1;
   ae_int_t m2;
   ae_int_t rawccnt;
   ae_int_t trialidx;
   ae_int_t i;
   ae_int_t j;
   double v;
   double h;
   ae_int_t optkind;
   double epsx;
   double xtol;
   double tolf;
   double f0;
   double f1;
   bool bflag;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(minlmstate, state);
   NewObj(minlmreport, rep);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x12, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewMatrix(rawc, 0, 0, DT_REAL);
   NewVector(rawct, 0, DT_INT);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(c12, 0, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Minimize
//
//          [      [                             ]2  ]
//     SUM_i[ SUM_j[ (0.1*x_j+power(x_j,3))*c_ij ]   ]
//          [      [                             ]   ]
//
// subject to mix of box and linear inequality constraints on x_j
//
// We check correctness of solution by sampling a few random points
// around one returned by optimizer, and comparing function value
// with target. Sampling is performed with respect to inequality
// constraints.
   epsx = 1.0E-12;
   xtol = 1.0E-8;
   tolf = 1.0E-10;
   for (optkind = 0; optkind <= 1; optkind++) {
      for (n = 5; n <= 20; n++) {
      // Generate problem
         m = n + hqrnduniformi(&rs, n);
         ae_vector_set_length(&bl, n);
         ae_vector_set_length(&bu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            bl.xR[i] = hqrndnormal(&rs);
            bu.xR[i] = bl.xR[i] + hqrnduniformr(&rs);
            x0.xR[i] = bl.xR[i] + (bu.xR[i] - bl.xR[i]) * hqrnduniformr(&rs);
         }
         ae_matrix_set_length(&c, m, n + 1);
         for (i = 0; i < m; i++) {
            for (j = 0; j <= n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
            }
         }
         ae_assert(n >= 5, "Assertion failed");
         rawccnt = 3;
         ae_matrix_set_length(&rawc, rawccnt, n + 1);
         ae_vector_set_length(&rawct, rawccnt);
         for (i = 0; i < rawccnt; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               rawc.xyR[i][j] = hqrndnormal(&rs);
               v += x0.xR[j] * rawc.xyR[i][j];
            }
            rawc.xyR[i][n] = v;
            rawct.xZ[i] = 2 * hqrnduniformi(&rs, 2) - 1;
         }
      // Solve
         if (optkind == 0) {
            minlmcreatev(n, m, &x0, 10 * epsx, &state);
         }
         if (optkind == 1) {
            minlmcreatevj(n, m, &x0, &state);
         }
         minlmsetcond(&state, epsx, 0);
         minlmsetbc(&state, &bl, &bu);
         minlmsetlc(&state, &rawc, &rawct, rawccnt);
         while (minlmiteration(&state)) {
            for (i = 0; i < n; i++) {
               Ok = Ok && state.x.xR[i] >= bl.xR[i];
               Ok = Ok && state.x.xR[i] <= bu.xR[i];
            }
            if (state.needfi) {
               testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, false);
            } else if (state.needfij) {
               testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, true);
            } else ae_assert(false, "minlm test: integrity check failed");
         }
         minlmresults(&state, &x, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Test feasibility w.r.t. box and linear inequality constraints
         for (i = 0; i < n; i++) {
            Ok = Ok && x.xR[i] >= bl.xR[i];
            Ok = Ok && x.xR[i] <= bu.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            v = ae_v_dotproduct(rawc.xyR[i], 1, x.xR, 1, n);
            v -= rawc.xyR[i][n];
            if (rawct.xZ[i] > 0) {
               Ok = Ok && v >= -xtol;
            }
            if (rawct.xZ[i] < 0) {
               Ok = Ok && v <= xtol;
            }
         }
      // Make several random trial steps and:
      // 0) generate small random trial step
      // 1) if step is infeasible, skip to next trial
      // 2) compare function value in the trial point against one in other points
         testminlmunit_testfunc1(n, m, &c, &x, &f0, true, &state.fi, false, &state.j, false);
         ae_vector_set_length(&x1, n);
         for (trialidx = 0; trialidx <= 10 * n; trialidx++) {
            h = 0.001;
            for (i = 0; i < n; i++) {
               do {
                  x1.xR[i] = x.xR[i] + hqrndmiduniformr(&rs) * h;
               } while (x1.xR[i] < bl.xR[i] || x1.xR[i] > bu.xR[i]);
            }
            bflag = false;
            for (i = 0; i < rawccnt; i++) {
               ae_assert(rawct.xZ[i] != 0, "Assertion failed");
               v = ae_v_dotproduct(rawc.xyR[i], 1, x1.xR, 1, n);
               v -= rawc.xyR[i][n];
               bflag = bflag || rawct.xZ[i] > 0 && v < 0.0;
               bflag = bflag || rawct.xZ[i] < 0 && v > 0.0;
            }
            if (bflag) {
               continue;
            }
            testminlmunit_testfunc1(n, m, &c, &x1, &f1, true, &state.fi, false, &state.j, false);
            Ok = Ok && f1 >= f0 * (1 - tolf);
         }
      }
   }
// Minimize
//
//          [      [                             ]2  ]
//     SUM_i[ SUM_j[ (0.1*x_j+power(x_j,3))*c_ij ]   ]
//          [      [                             ]   ]
//
// subject to linear EQUALITY constraints on x_j.
//
// We check correctness of solution by sampling a few random points
// around one returned by optimizer, and comparing function value
// with target. Sampling is performed with respect to equality
// constraints. In order to simplify algorithm we use orthogonal
// equality constraints.
//
// NOTE: we solve problem using VJ mode (analytic Jacobian) because
//       roundoff errors from numerical differentiation sometimes
//       prevent us from converging with good precision.
   epsx = 1.0E-12;
   xtol = 1.0E-8;
   tolf = 1.0E-10;
   optkind = 1;
   for (n = 10; n <= 20; n++) {
   // Generate problem
      m = n + hqrnduniformi(&rs, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_matrix_set_length(&c, m, n + 1);
      for (i = 0; i < m; i++) {
         for (j = 0; j <= n; j++) {
            c.xyR[i][j] = hqrndnormal(&rs);
         }
      }
      ae_assert(n >= 5, "Assertion failed");
      rawccnt = 1 + hqrnduniformi(&rs, 5);
      rmatrixrndorthogonal(n, &z);
      ae_matrix_set_length(&rawc, rawccnt, n + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         v = 0.0;
         for (j = 0; j < n; j++) {
            rawc.xyR[i][j] = z.xyR[i][j];
            v += x0.xR[j] * rawc.xyR[i][j];
         }
         rawc.xyR[i][n] = v;
         rawct.xZ[i] = 0;
      }
   // Solve
      if (optkind == 0) {
         minlmcreatev(n, m, &x0, 1.0E-12, &state);
      }
      if (optkind == 1) {
         minlmcreatevj(n, m, &x0, &state);
      }
      minlmsetcond(&state, epsx, 0);
      minlmsetlc(&state, &rawc, &rawct, rawccnt);
      while (minlmiteration(&state))
         if (state.needfi) {
            testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, false);
         } else if (state.needfij) {
            testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, true);
         } else ae_assert(false, "minlm test: integrity check failed");
      minlmresults(&state, &x, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Test feasibility w.r.t. linear equality constraints
      for (i = 0; i < rawccnt; i++) {
         v = ae_v_dotproduct(rawc.xyR[i], 1, x.xR, 1, n);
         v -= rawc.xyR[i][n];
         Ok = Ok && SmallAtR(v, xtol);
      }
   // Make several random trial steps and:
   // 0) generate small random trial step
   // 1) project it onto equality constrained subspace
   // 2) compare function value in the trial point against one in other points
      testminlmunit_testfunc1(n, m, &c, &x, &f0, true, &state.fi, false, &state.j, false);
      ae_vector_set_length(&x1, n);
      for (trialidx = 0; trialidx <= 10 * n; trialidx++) {
         h = 0.001;
         for (i = 0; i < n; i++) {
            x1.xR[i] = hqrndnormal(&rs);
         }
         for (i = 0; i < rawccnt; i++) {
            v = ae_v_dotproduct(rawc.xyR[i], 1, x1.xR, 1, n);
            ae_v_subd(x1.xR, 1, rawc.xyR[i], 1, n, v);
         }
         v = ae_v_dotproduct(x1.xR, 1, x1.xR, 1, n);
         ae_assert(v > 0.0, "Assertion failed");
         v = h / sqrt(v);
         ae_v_muld(x1.xR, 1, n, v);
         ae_v_add(x1.xR, 1, x.xR, 1, n);
         testminlmunit_testfunc1(n, m, &c, &x1, &f1, true, &state.fi, false, &state.j, false);
         Ok = Ok && f1 >= f0 * (1 - tolf);
      }
   }
// Minimize
//
//          [      [                               ]2  ]        [      [                               ]2  ]
//     SUM_i[ SUM_j[ (0.1*x_j+power(x0_j,3))*c0_ij ]   ] + SUM_i[ SUM_j[ (0.1*x_j+power(x1_j,3))*c1_ij ]   ]
//          [      [                               ]   ]        [      [                               ]   ]
//
// for two sets of unknowns (x0_j and x1_j) and two sets of
// coefficients (c0_ij and c1_ij, M1*N and M2*N matrices) subject
// to equality constraint
//
//     x0_j == x1_j for all j
//
// Such optimization problem arises when we fit same model to
// two distinct datasets and want to share SOME of coefficients
// between fits. If we share ALL coefficients, it is equal to
// fitting one model to combination of two datasets.
//
// Our test checks that such "combined" 2N-dimensional problem
// solved with general linear constraints which "glue" two datasets
// together returns same answer as N-dimensional problem on (M1+M2)-point
// dataset.
//
// NOTE: we solve problem using VJ mode (analytic Jacobian) because
//       roundoff errors from numerical differentiation prevent us
//       from converging with good precision.
   epsx = 1.0E-12;
   for (n = 5; n <= 20; n++) {
   // Generate problems
      m1 = n + hqrnduniformi(&rs, n);
      m2 = n + hqrnduniformi(&rs, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&x12, 2 * n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
         x12.xR[2 * i] = hqrndnormal(&rs);
         x12.xR[2 * i + 1] = hqrndnormal(&rs);
      }
      ae_matrix_set_length(&c, m1 + m2, n + 1);
      ae_matrix_set_length(&c12, m1 + m2, 2 * n + 1);
      for (i = 0; i < m1 + m2; i++) {
         for (j = 0; j <= 2 * n; j++) {
            c12.xyR[i][j] = 0.0;
         }
      }
      for (i = 0; i < m1 + m2; i++) {
         for (j = 0; j < n; j++) {
            c.xyR[i][j] = hqrndnormal(&rs);
            if (i < m1) {
               c12.xyR[i][j] = c.xyR[i][j];
            } else {
               c12.xyR[i][n + j] = c.xyR[i][j];
            }
         }
         c.xyR[i][n] = hqrndnormal(&rs);
         c12.xyR[i][2 * n] = c.xyR[i][n];
      }
      rawccnt = n;
      ae_matrix_set_length(&rawc, rawccnt, 2 * n + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         for (j = 0; j <= 2 * n; j++) {
            rawc.xyR[i][j] = 0.0;
         }
         rawc.xyR[i][i] = 1.0;
         rawc.xyR[i][n + i] = -1.0;
         rawct.xZ[i] = 0;
      }
   // Solve N-dimensional "combined" problem, store result to X1
      minlmcreatevj(n, m1 + m2, &x0, &state);
      minlmsetcond(&state, epsx, 0);
      while (minlmiteration(&state))
         if (state.needfi) {
            testminlmunit_testfunc1(n, m1 + m2, &c, &state.x, &v, false, &state.fi, true, &state.j, false);
         } else if (state.needfij) {
            testminlmunit_testfunc1(n, m1 + m2, &c, &state.x, &v, false, &state.fi, true, &state.j, true);
         } else ae_assert(false, "minlm test: integrity check failed");
      minlmresults(&state, &x, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Solve N-dimensional "glued" problem, store result to X12
      minlmcreatevj(2 * n, m1 + m2, &x12, &state);
      minlmsetcond(&state, epsx, 0);
      minlmsetlc(&state, &rawc, &rawct, rawccnt);
      while (minlmiteration(&state))
         if (state.needfi) {
            testminlmunit_testfunc1(2 * n, m1 + m2, &c12, &state.x, &v, false, &state.fi, true, &state.j, false);
         } else if (state.needfij) {
            testminlmunit_testfunc1(2 * n, m1 + m2, &c12, &state.x, &v, false, &state.fi, true, &state.j, true);
         } else ae_assert(false, "minlm test: integrity check failed");
      minlmresults(&state, &x12, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Compare solutions
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(x.xR[i], x12.xR[i], 1.0E-3);
         Ok = Ok && NearAtR(x.xR[i], x12.xR[n + i], 1.0E-3);
         Ok = Ok && NearAtR(x12.xR[i], x12.xR[n + i], 1.0E-6);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test other properties
static bool testminlmunit_testother(bool *StateFieldConsistencyOkP) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   double v;
   double s;
   ae_int_t i;
   ae_int_t j;
   ae_int_t rkind;
   double fprev;
   double xprev;
   double stpmax;
   ae_int_t stopcallidx;
   ae_int_t callidx;
   ae_int_t maxits;
   bool terminationrequested;
   ae_int_t pass;
   ae_int_t spoilcnt;
   double mx;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(minlmstate, state);
   NewObj(minlmreport, rep);
   NewVector(x, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
// Other properties:
// 1. test reports (F should form monotone sequence)
// 2. test maximum step
   for (rkind = 0; rkind <= 5; rkind++) {
   // reports:
   // * check that first report is initial point
   // * check that F is monotone decreasing
   // * check that last report is final result
      n = 3;
      m = 3;
      s = 100.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 6 + randomreal();
      }
      if (rkind == 0) {
         minlmcreatefj(n, m, &x, &state);
      }
      if (rkind == 1) {
         minlmcreatefgj(n, m, &x, &state);
      }
      if (rkind == 2) {
         minlmcreatefgh(n, &x, &state);
      }
      if (rkind == 3) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 0);
      }
      if (rkind == 4) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 1);
      }
      if (rkind == 5) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 2);
      }
      minlmsetcond(&state, 0.0, 4);
      minlmsetxrep(&state, true);
      fprev = maxrealnumber;
      while (minlmiteration(&state)) {
         if (state.needfi || state.needfij) {
            state.fi.xR[0] = sqrt(s) * (exp(state.x.xR[0]) - 2);
            state.fi.xR[1] = state.x.xR[1];
            state.fi.xR[2] = state.x.xR[2] - state.x.xR[0];
         }
         if (state.needfij) {
            state.j.xyR[0][0] = sqrt(s) * exp(state.x.xR[0]);
            state.j.xyR[0][1] = 0.0;
            state.j.xyR[0][2] = 0.0;
            state.j.xyR[1][0] = 0.0;
            state.j.xyR[1][1] = 1.0;
            state.j.xyR[1][2] = 0.0;
            state.j.xyR[2][0] = -1.0;
            state.j.xyR[2][1] = 0.0;
            state.j.xyR[2][2] = 1.0;
         }
         if (state.needf ||/* state.needfg ||*/ state.needfgh) {
            state.f = s * sqr(exp(state.x.xR[0]) - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
         }
         if (/*state.needfg ||*/ state.needfgh) {
            state.g.xR[0] = s * 2 * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[0] - state.x.xR[2]);
            state.g.xR[1] = 2 * state.x.xR[1];
            state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
         }
         if (state.needfgh) {
            state.h.xyR[0][0] = s * (4 * sqr(exp(state.x.xR[0])) - 4 * exp(state.x.xR[0])) + 2;
            state.h.xyR[0][1] = 0.0;
            state.h.xyR[0][2] = -2.0;
            state.h.xyR[1][0] = 0.0;
            state.h.xyR[1][1] = 2.0;
            state.h.xyR[1][2] = 0.0;
            state.h.xyR[2][0] = -2.0;
            state.h.xyR[2][1] = 0.0;
            state.h.xyR[2][2] = 2.0;
         }
         *StateFieldConsistencyOkP = *StateFieldConsistencyOkP && testminlmunit_rkindvsstatecheck(rkind, &state);
         if (state.xupdated) {
            Ok = Ok && state.f <= fprev;
            if (fprev == maxrealnumber) {
               for (i = 0; i < n; i++) {
                  Ok = Ok && state.x.xR[i] == x.xR[i];
               }
            }
            fprev = state.f;
            ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
         }
      }
      minlmresults(&state, &x, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && x.xR[i] == xlast.xR[i];
      }
   }
   n = 1;
   ae_vector_set_length(&x, n);
   x.xR[0] = 100.0;
   stpmax = 0.05 + 0.05 * randomreal();
   minlmcreatefgh(n, &x, &state);
   minlmsetcond(&state, 1.0E-12, 0);
   minlmsetstpmax(&state, stpmax);
   minlmsetxrep(&state, true);
   xprev = x.xR[0];
   while (minlmiteration(&state)) {
      if (state.needf ||/* state.needfg ||*/ state.needfgh) {
         state.f = exp(state.x.xR[0]) + exp(-state.x.xR[0]);
      }
      if (/*state.needfg ||*/ state.needfgh) {
         state.g.xR[0] = exp(state.x.xR[0]) - exp(-state.x.xR[0]);
      }
      if (state.needfgh) {
         state.h.xyR[0][0] = exp(state.x.xR[0]) + exp(-state.x.xR[0]);
      }
      Ok = Ok && NearAtR(state.x.xR[0], xprev, (1 + sqrt(machineepsilon)) * stpmax);
      if (state.xupdated) {
         xprev = state.x.xR[0];
      }
   }
// Check algorithm ability to handle request for termination:
// * to terminate with correct return code = 8
// * to return point which was "current" at the moment of termination
   for (pass = 1; pass <= 50; pass++) {
      n = 3;
      m = 3;
      s = 100.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 6 + randomreal();
      }
      stopcallidx = randominteger(20);
      maxits = 25;
      minlmcreatevj(n, m, &x, &state);
      minlmsetcond(&state, 0.0, maxits);
      minlmsetxrep(&state, true);
      callidx = 0;
      terminationrequested = false;
      ae_v_move(xlast.xR, 1, x.xR, 1, n);
      while (minlmiteration(&state))
         if (state.needfi || state.needfij) {
            state.fi.xR[0] = sqrt(s) * (exp(state.x.xR[0]) - 2);
            state.fi.xR[1] = state.x.xR[1];
            state.fi.xR[2] = state.x.xR[2] - state.x.xR[0];
            if (state.needfij) {
               state.j.xyR[0][0] = sqrt(s) * exp(state.x.xR[0]);
               state.j.xyR[0][1] = 0.0;
               state.j.xyR[0][2] = 0.0;
               state.j.xyR[1][0] = 0.0;
               state.j.xyR[1][1] = 1.0;
               state.j.xyR[1][2] = 0.0;
               state.j.xyR[2][0] = -1.0;
               state.j.xyR[2][1] = 0.0;
               state.j.xyR[2][2] = 1.0;
            }
            if (callidx == stopcallidx) {
               minlmrequesttermination(&state);
               terminationrequested = true;
            }
            callidx++;
         } else if (state.xupdated) {
            if (!terminationrequested) {
               ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
            }
         } else ae_assert(false, "Assertion failed");
      minlmresults(&state, &x, &rep);
      Ok = Ok && rep.terminationtype == 8;
      for (i = 0; i < n; i++) {
         Ok = Ok && x.xR[i] == xlast.xR[i];
      }
   }
// Test ability to detect NAN/INF values.
//
// We use Rosenbrock's function which is modified to return
// NAN/INF (randomly) when near solution. Algorithm should set
// appropriate error code (-8) on exit.
   n = 10;
   m = 2 * (n - 1);
   s = 10.0;
   ae_vector_set_length(&x, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = 0.0;
   }
   minlmcreatevj(n, m, &x, &state);
   minlmsetcond(&state, 1.0E-12, 0);
   spoilcnt = 0;
   while (minlmiteration(&state))
      if (state.needfij) {
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               state.j.xyR[i][j] = 0.0;
            }
         }
         for (i = 0; i < n - 1; i++) {
            state.fi.xR[2 * i] = s * (state.x.xR[i + 1] - sqr(state.x.xR[i]));
            state.j.xyR[2 * i][i] = -s * 2 * state.x.xR[i];
            state.j.xyR[2 * i][i + 1] = s;
            state.fi.xR[2 * i + 1] = 1 - state.x.xR[i];
            state.j.xyR[2 * i + 1][i] = -1.0;
         }
         mx = 0.0;
         for (i = 0; i < n; i++) {
            mx = rmax2(mx, fabs(state.x.xR[i] - 1));
         }
         if (mx < 1.0E-2) {
            i = randominteger(3);
            v = NAN;
            if (i == 1) {
               v = +INFINITY;
            }
            if (i == 2) {
               v = -INFINITY;
            }
            if (randombool()) {
               state.fi.xR[randominteger(m)] = v;
            } else {
               state.j.xyR[randominteger(m)][randominteger(n)] = v;
            }
            spoilcnt++;
         }
      } else if (state.needfi) {
         for (i = 0; i < n - 1; i++) {
            state.fi.xR[2 * i] = s * (state.x.xR[i + 1] - sqr(state.x.xR[i]));
            state.fi.xR[2 * i + 1] = 1 - state.x.xR[i];
         }
         mx = 0.0;
         for (i = 0; i < n; i++) {
            mx = rmax2(mx, fabs(state.x.xR[i] - 1));
         }
         if (mx < 1.0E-2) {
            i = randominteger(3);
            v = NAN;
            if (i == 1) {
               v = +INFINITY;
            }
            if (i == 2) {
               v = -INFINITY;
            }
            state.fi.xR[randominteger(m)] = v;
            spoilcnt++;
         }
      } else ae_assert(false, "Assertion failed");
   minlmresults(&state, &x, &rep);
   Ok = Ok && rep.terminationtype == -8;
   Ok = Ok && spoilcnt == 1;
   ae_frame_leave();
   return Ok;
}

// This function tests OptGuard
static bool testminlmunit_testoptguard() {
   ae_frame _frame_block;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   double diffstep;
   ae_int_t defecttype;
   ae_int_t funcidx;
   ae_int_t varidx;
   ae_int_t skind;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minlmstate, state);
   NewObj(minlmreport, rep);
   NewObj(optguardreport, ogrep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(jactrue, 0, 0, DT_REAL);
   NewMatrix(jacdefect, 0, 0, DT_REAL);
   hqrndrandomize(&rs);
// Check that gradient verification is disabled by default:
// gradient checking for bad problem must return nothing
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = 1.0 + 0.1 * i;
   }
   spdmatrixrndcond(n, 1.0E3, &a);
   spdmatrixrndcond(n, 1.0E3, &a1);
   minlmcreatevj(n, 1, &x0, &state);
   minlmsetcond(&state, 1.0E-9, 10);
   while (minlmiteration(&state))
      if (state.needfij) {
         state.fi.xR[0] = 0.0;
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.fi.xR[0] += 0.5 * state.x.xR[i] * v;
         }
         for (i = 0; i < n; i++) {
            state.j.xyR[0][i] = 0.0;
         }
      } else ae_assert(false, "Assertion failed");
   minlmresults(&state, &x1, &rep);
   minlmoptguardresults(&state, &ogrep);
   Ok = Ok && rep.terminationtype > 0;
   Ok = Ok && isfinitevector(&x1, n);
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && ogrep.badgradxbase.cnt == 0;
   Ok = Ok && ogrep.badgraduser.rows == 0;
   Ok = Ok && ogrep.badgraduser.cols == 0;
   Ok = Ok && ogrep.badgradnum.rows == 0;
   Ok = Ok && ogrep.badgradnum.cols == 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && !ogrep.badgradsuspected;
   Ok = Ok && ogrep.badgradfidx == -1;
   Ok = Ok && ogrep.badgradvidx == -1;
// Test gradient checking functionality, try various
// defect types:
// * accidental zeroing of some gradient component
// * accidental addition of 1.0 to some component
// * accidental multiplication by 2.0
// Try distorting both target and constraints.
   diffstep = 0.001;
   n = 10;
   for (skind = 0; skind <= 1; skind++) {
      for (funcidx = 0; funcidx <= 1; funcidx++) {
         for (defecttype = -1; defecttype <= 2; defecttype++) {
            varidx = hqrnduniformi(&rs, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&s, n);
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            for (i = 0; i < n; i++) {
               s.xR[i] = pow(10.0, skind * 15.0 * hqrndmiduniformr(&rs));
               x0.xR[i] = (1.0 + 0.1 * i) * s.xR[i];
               j = hqrnduniformi(&rs, 3);
               bndl.xR[i] = -100 * s.xR[i];
               bndu.xR[i] = 100 * s.xR[i];
               if (j == 1) {
                  bndl.xR[i] = x0.xR[i];
               }
               if (j == 2) {
                  bndu.xR[i] = x0.xR[i];
               }
            }
            spdmatrixrndcond(n, 1.0E3, &a);
            spdmatrixrndcond(n, 1.0E3, &a1);
            minlmcreatevj(n, 2, &x0, &state);
            minlmoptguardgradient(&state, diffstep);
            minlmsetcond(&state, 1.0E-9, 10);
            minlmsetscale(&state, &s);
            minlmsetbc(&state, &bndl, &bndu);
            while (minlmiteration(&state))
               if (state.needfi || state.needfij) {
                  for (i = 0; i < n; i++) {
                     Ok = Ok && state.x.xR[i] >= bndl.xR[i];
                     Ok = Ok && state.x.xR[i] <= bndu.xR[i];
                  }
                  state.fi.xR[0] = 0.0;
                  for (i = 0; i < n; i++) {
                     v = 0.0;
                     for (j = 0; j < n; j++) {
                        v += state.x.xR[j] / s.xR[j] * a.xyR[i][j];
                     }
                     state.fi.xR[0] += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                     if (state.needfij) {
                        state.j.xyR[0][i] = v;
                     }
                  }
                  state.fi.xR[1] = 0.0;
                  for (i = 0; i < n; i++) {
                     v = 0.0;
                     for (j = 0; j < n; j++) {
                        v += state.x.xR[j] / s.xR[j] * a1.xyR[i][j];
                     }
                     state.fi.xR[1] += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                     if (state.needfij) {
                        state.j.xyR[1][i] = v;
                     }
                  }
                  if (state.needfij) {
                     if (defecttype == 0) {
                        state.j.xyR[funcidx][varidx] = 0.0;
                     }
                     if (defecttype == 1) {
                        state.j.xyR[funcidx][varidx]++;
                     }
                     if (defecttype == 2) {
                        state.j.xyR[funcidx][varidx] *= 2;
                     }
                  }
                  if (state.needfij) {
                     for (i = 0; i < n; i++) {
                        state.j.xyR[0][i] /= s.xR[i];
                        state.j.xyR[1][i] /= s.xR[i];
                     }
                  }
               } else ae_assert(false, "Assertion failed");
            minlmresults(&state, &x1, &rep);
            minlmoptguardresults(&state, &ogrep);
         // Check that something is returned
            Ok = Ok && rep.terminationtype > 0;
            Ok = Ok && isfinitevector(&x1, n);
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Compute reference values for true and spoiled Jacobian at X0
            Ok = Ok && isfinitevector(&ogrep.badgradxbase, n);
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            ae_matrix_set_length(&jactrue, 2, n);
            ae_matrix_set_length(&jacdefect, 2, n);
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += ogrep.badgradxbase.xR[j] / s.xR[j] * a.xyR[i][j];
               }
               jactrue.xyR[0][i] = v;
               jacdefect.xyR[0][i] = v;
            }
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += ogrep.badgradxbase.xR[j] / s.xR[j] * a1.xyR[i][j];
               }
               jactrue.xyR[1][i] = v;
               jacdefect.xyR[1][i] = v;
            }
            if (defecttype == 0) {
               jacdefect.xyR[funcidx][varidx] = 0.0;
            }
            if (defecttype == 1) {
               jacdefect.xyR[funcidx][varidx]++;
            }
            if (defecttype == 2) {
               jacdefect.xyR[funcidx][varidx] *= 2;
            }
            for (i = 0; i < n; i++) {
               jactrue.xyR[0][i] /= s.xR[i];
               jactrue.xyR[1][i] /= s.xR[i];
               jacdefect.xyR[0][i] /= s.xR[i];
               jacdefect.xyR[1][i] /= s.xR[i];
            }
         // Check OptGuard report
            Ok = Ok && apservisfinitematrix(&ogrep.badgraduser, 2, n);
            Ok = Ok && apservisfinitematrix(&ogrep.badgradnum, 2, n);
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            if (defecttype >= 0) {
               Ok = Ok && ogrep.badgradsuspected;
               Ok = Ok && ogrep.badgradfidx == funcidx;
               Ok = Ok && ogrep.badgradvidx == varidx;
            } else {
               Ok = Ok && !ogrep.badgradsuspected;
               Ok = Ok && ogrep.badgradfidx == -1;
               Ok = Ok && ogrep.badgradvidx == -1;
            }
            for (i = 0; i <= 1; i++) {
               for (j = 0; j < n; j++) {
                  Ok = Ok && NearAtR(jactrue.xyR[i][j], ogrep.badgradnum.xyR[i][j], 0.01 / s.xR[j]);
                  Ok = Ok && NearAtR(jacdefect.xyR[i][j], ogrep.badgraduser.xyR[i][j], 0.01 / s.xR[j]);
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tries to reproduce previously fixed bugs; in case of bug
static bool testminlmunit_tryreproducefixedbugs() {
   ae_frame _frame_block;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(minlmstate, s);
   NewObj(minlmreport, rep);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
// Reproduce bug reported by ISS:
// when solving bound constrained problem with numerical differentiation
// and starting from infeasible point, we won't stop at the feasible point
   ae_vector_set_length(&x, 2);
   ae_vector_set_length(&bl, 2);
   ae_vector_set_length(&bu, 2);
   x.xR[0] = 2.0;
   bl.xR[0] = -1.0;
   bu.xR[0] = 1.0;
   x.xR[1] = 2.0;
   bl.xR[1] = -1.0;
   bu.xR[1] = 1.0;
   minlmcreatev(2, 2, &x, 0.001, &s);
   minlmsetbc(&s, &bl, &bu);
   while (minlmiteration(&s))
      if (s.needfi) {
         s.fi.xR[0] = sqr(s.x.xR[0]);
         s.fi.xR[1] = sqr(s.x.xR[1]);
      }
   minlmresults(&s, &x, &rep);
   Ok = Ok && x.xR[0] >= bl.xR[0] && x.xR[0] <= bu.xR[0] && x.xR[1] >= bl.xR[1] && x.xR[1] <= bu.xR[1];
   ae_frame_leave();
   return Ok;
}

bool testminlm() {
   bool Ok;
   bool uOk;
   bool bcOk;
   bool lcOk;
   bool scOk;
   bool otherOk;
   bool optguardOk;
   Ok = true;
   scOk = true;
   otherOk = true;
   uOk = true;
   bcOk = true;
   lcOk = true;
// Various tests
   otherOk = otherOk && testminlmunit_testother(&scOk);
// Tests sorted by constraint types
   uOk = uOk && testminlmunit_testu(&scOk);
   bcOk = bcOk && testminlmunit_testbc();
   lcOk = lcOk && testminlmunit_testlc();
// Try to reproduce previously fixed bugs
   otherOk = otherOk && testminlmunit_tryreproducefixedbugs();
// Test for MinLMGradientCheck
   optguardOk = true;
   optguardOk = optguardOk && testminlmunit_testoptguard();
// The final report.
   Ok = uOk && bcOk && lcOk && scOk && otherOk && optguardOk;
   if (!Ok || !silent) {
      printf("Testing Levenberg-Marquardt Optimization\n");
      printf("Problem Types:\n");
      printf("* Unconstrained:                          %s\n", uOk? "Ok": "Failed");
      printf("* Box Constrained:                        %s\n", bcOk? "Ok": "Failed");
      printf("* Linearly Constrained:                   %s\n", lcOk? "Ok": "Failed");
      printf("State Fields Consistency:                 %s\n", scOk? "Ok": "Failed");
      printf("Other Properties:                         %s\n", otherOk? "Ok": "Failed");
      printf("OptGuard:                                 %s\n", optguardOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === mincg testing unit ===
static const ae_int_t testmincgunit_maxoptguardlevel = 1;

// Other properties
static bool testother() {
   ae_frame _frame_block;
   ae_int_t n;
   double fprev;
   double xprev;
   double stpmax;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t cgtype;
   double tmpeps;
   double epsg;
   double v;
   double r;
   bool hasxlast;
   double lastscaledstep;
   ae_int_t pkind;
   ae_int_t ckind;
   ae_int_t mkind;
   ae_int_t dkind;
   double diffstep;
   double vc;
   double vm;
   bool wasf;
   bool wasfg;
   ae_int_t spoiliteration;
   ae_int_t stopiteration;
   ae_int_t spoilvar;
   double spoilval;
   ae_int_t pass;
   double ss;
   ae_int_t callidx;
   ae_int_t stopcallidx;
   ae_int_t maxits;
   bool terminationrequested;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(a, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(h, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewObj(mincgstate, state);
   NewObj(mincgreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   for (cgtype = -1; cgtype <= 1; cgtype++) {
   // Test reports (F should form monotone sequence)
      n = 50;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 1.0;
      }
      mincgcreate(n, &x, &state);
      mincgsetcond(&state, 0.0, 0.0, 0.0, 100);
      mincgsetxrep(&state, true);
      fprev = maxrealnumber;
      while (mincgiteration(&state))
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += sqr((1 + i) * state.x.xR[i]);
               state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
            }
         } else if (state.xupdated) {
            Ok = Ok && state.f <= fprev;
            if (fprev == maxrealnumber) {
               for (i = 0; i < n; i++) {
                  Ok = Ok && state.x.xR[i] == x.xR[i];
               }
            }
            fprev = state.f;
            ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
         }
      mincgresults(&state, &x, &rep);
      for (i = 0; i < n; i++) {
         Ok = Ok && x.xR[i] == xlast.xR[i];
      }
   // Test differentiation vs. analytic gradient
   // (first one issues NeedF requests, second one issues NeedFG requests)
      n = 50;
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xlast, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 1.0;
         }
         if (dkind == 0) {
            mincgcreate(n, &x, &state);
         }
         if (dkind == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcond(&state, 0.0, 0.0, 0.0, n / 2);
         wasf = false;
         wasfg = false;
         while (mincgiteration(&state))
            if (state.needf || state.needfg) {
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  state.f += sqr((1 + i) * state.x.xR[i]);
                  if (state.needfg) {
                     state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
                  }
               }
               wasf = wasf || state.needf;
               wasfg = wasfg || state.needfg;
            }
         mincgresults(&state, &x, &rep);
         if (dkind == 0) {
            Ok = Ok && !wasf && wasfg;
         }
         if (dkind == 1) {
            Ok = Ok && wasf && !wasfg;
         }
      }
   // Test that numerical differentiation uses scaling.
   //
   // In order to test that we solve simple optimization
   // problem: min(x^2) with initial x equal to 0.0.
   //
   // We choose random DiffStep and S, then we check that
   // optimizer evaluates function at +-DiffStep*S only.
      ae_vector_set_length(&x, 1);
      ae_vector_set_length(&s, 1);
      diffstep = randomreal() * 1.0E-6;
      s.xR[0] = exp(2.0*randommid());
      x.xR[0] = 0.0;
      mincgcreatef(1, &x, diffstep, &state);
      mincgsetcond(&state, 1.0E-6, 0.0, 0.0, 0);
      mincgsetscale(&state, &s);
      v = 0.0;
      while (mincgiteration(&state)) {
         state.f = sqr(state.x.xR[0]);
         v = rmax2(v, fabs(state.x.xR[0]));
      }
      mincgresults(&state, &x, &rep);
      r = v / (s.xR[0] * diffstep);
      Ok = Ok && SmallAtR(log(r), log(1.0 + 1000.0 * machineepsilon));
   // Test maximum step
      n = 1;
      ae_vector_set_length(&x, n);
      x.xR[0] = 100.0;
      stpmax = 0.05 + 0.05 * randomreal();
      mincgcreate(n, &x, &state);
      mincgsetcond(&state, 1.0E-9, 0.0, 0.0, 0);
      mincgsetstpmax(&state, stpmax);
      mincgsetxrep(&state, true);
      xprev = x.xR[0];
      while (mincgiteration(&state))
         if (state.needfg) {
            state.f = exp(state.x.xR[0]) + exp(-state.x.xR[0]);
            state.g.xR[0] = exp(state.x.xR[0]) - exp(-state.x.xR[0]);
            Ok = Ok && NearAtR(state.x.xR[0], xprev, (1 + sqrt(machineepsilon)) * stpmax);
         } else if (state.xupdated) {
            Ok = Ok && NearAtR(state.x.xR[0], xprev, (1 + sqrt(machineepsilon)) * stpmax);
            xprev = state.x.xR[0];
         }
   // Test correctness of the scaling:
   // * initial point is random point from [+1,+2]^N
   // * f(x) = SUM(A[i]*x[i]^4), C[i] is random from [0.01,100]
   // * we use random scaling matrix
   // * we test different variants of the preconditioning:
   //   0) unit preconditioner
   //   1) random diagonal from [0.01,100]
   //   2) scale preconditioner
   // * we set stringent stopping conditions (we try EpsG and EpsX)
   // * and we test that in the extremum stopping conditions are
   //   satisfied subject to the current scaling coefficients.
      tmpeps = 1.0E-10;
      for (n = 1; n <= 10; n++) {
         for (pkind = 0; pkind <= 2; pkind++) {
            ae_vector_set_length(&x, n);
            ae_vector_set_length(&xlast, n);
            ae_vector_set_length(&a, n);
            ae_vector_set_length(&s, n);
            ae_vector_set_length(&h, n);
            for (i = 0; i < n; i++) {
               x.xR[i] = randomreal() + 1;
               a.xR[i] = exp(log(100.0) * randommid());
               s.xR[i] = exp(log(100.0) * randommid());
               h.xR[i] = exp(log(100.0) * randommid());
            }
            mincgcreate(n, &x, &state);
            mincgsetscale(&state, &s);
            mincgsetxrep(&state, true);
            if (pkind == 1) {
               mincgsetprecdiag(&state, &h);
            }
            if (pkind == 2) {
               mincgsetprecscale(&state);
            }
         // Test gradient-based stopping condition
            for (i = 0; i < n; i++) {
               x.xR[i] = randomreal() + 1;
            }
            mincgsetcond(&state, tmpeps, 0.0, 0.0, 0);
            for (mincgrestartfrom(&state, &x); mincgiteration(&state); )
               if (state.needfg) {
                  state.f = 0.0;
                  for (i = 0; i < n; i++) {
                     state.f += a.xR[i] * pow(state.x.xR[i], 4.0);
                     state.g.xR[i] = 4 * a.xR[i] * pow(state.x.xR[i], 3.0);
                  }
               }
            mincgresults(&state, &x, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            v = 0.0;
            for (i = 0; i < n; i++) {
               v += sqr(s.xR[i] * 4 * a.xR[i] * pow(x.xR[i], 3.0));
            }
            v = sqrt(v);
            Ok = Ok && v <= tmpeps;
         // Test step-based stopping condition
            for (i = 0; i < n; i++) {
               x.xR[i] = randomreal() + 1;
            }
            hasxlast = false;
            mincgsetcond(&state, 0.0, 0.0, tmpeps, 0);
            lastscaledstep = 0.0;
            for (mincgrestartfrom(&state, &x); mincgiteration(&state); )
               if (state.needfg) {
                  state.f = 0.0;
                  for (i = 0; i < n; i++) {
                     state.f += a.xR[i] * pow(state.x.xR[i], 4.0);
                     state.g.xR[i] = 4 * a.xR[i] * pow(state.x.xR[i], 3.0);
                  }
               } else if (state.xupdated) {
                  if (hasxlast) {
                     lastscaledstep = 0.0;
                     for (i = 0; i < n; i++) {
                        lastscaledstep += sqr(state.x.xR[i] - xlast.xR[i]) / sqr(s.xR[i]);
                     }
                     lastscaledstep = sqrt(lastscaledstep);
                  } else {
                     lastscaledstep = 0.0;
                  }
                  ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
                  hasxlast = true;
               }
            mincgresults(&state, &x, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            Ok = Ok && lastscaledstep <= tmpeps;
         }
      }
   // Check correctness of the "trimming".
   //
   // Trimming is a technique which is used to help algorithm
   // cope with unbounded functions. In order to check this
   // technique we will try to solve following optimization
   // problem:
   //
   //     min f(x) subject to no constraints on X
   //            { 1/(1-x) + 1/(1+x) + c*x, if -0.999999 < x < 0.999999
   //     f(x) = {
   //            { M, if x <= -0.999999 or x >= 0.999999
   //
   // where c is either 1.0 or 1.0E+6, M is either 1.0E8, 1.0E20 or +INF
   // (we try different combinations)
      for (ckind = 0; ckind <= 1; ckind++) {
         for (mkind = 0; mkind <= 2; mkind++) {
         // Choose c and M
            vc = 1.0;
            vm = 1.0E+8;
            if (ckind == 1) {
               vc = 1.0E+6;
            }
            if (mkind == 1) {
               vm = 1.0E+20;
            }
            if (mkind == 2) {
               vm = +INFINITY;
            }
         // Create optimizer, solve optimization problem
            epsg = 1.0E-6 * vc;
            ae_vector_set_length(&x, 1);
            x.xR[0] = 0.0;
            mincgcreate(1, &x, &state);
            mincgsetcond(&state, epsg, 0.0, 0.0, 0);
            mincgsetcgtype(&state, cgtype);
            while (mincgiteration(&state))
               if (state.needfg) {
                  if (-0.999999 < state.x.xR[0] && state.x.xR[0] < 0.999999) {
                     state.f = 1 / (1 - state.x.xR[0]) + 1 / (1 + state.x.xR[0]) + vc * state.x.xR[0];
                     state.g.xR[0] = 1 / sqr(1 - state.x.xR[0]) - 1 / sqr(1 + state.x.xR[0]) + vc;
                  } else {
                     state.f = vm;
                  }
               }
            mincgresults(&state, &x, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            Ok = Ok && NearAtR(1.0 / sqr(1.0 - x.xR[0]), 1.0 / sqr(1.0 + x.xR[0]) - vc, epsg);
         }
      }
   }
// Test integrity checks for NAN/INF:
// * algorithm solves optimization problem, which is normal for some time (quadratic)
// * after 5-th step we choose random component of gradient and consistently spoil
//   it by NAN or INF.
// * we check that correct termination code is returned (-8)
   n = 100;
   for (pass = 1; pass <= 10; pass++) {
      spoiliteration = 5;
      stopiteration = 8;
      if (hqrndnormal(&rs) > 0.0) {
      // Gradient can be spoiled by +INF, -INF, NAN
         spoilvar = hqrnduniformi(&rs, n);
         i = hqrnduniformi(&rs, 3);
         spoilval = NAN;
         if (i == 0) {
            spoilval = -INFINITY;
         }
         if (i == 1) {
            spoilval = +INFINITY;
         }
      } else {
      // Function value can be spoiled only by NAN
      // (+INF can be recognized as legitimate value during optimization)
         spoilvar = -1;
         spoilval = NAN;
      }
      spdmatrixrndcond(n, 1.0E5, &fulla);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         b.xR[i] = hqrndnormal(&rs);
         x0.xR[i] = hqrndnormal(&rs);
      }
      mincgcreate(n, &x0, &state);
      mincgsetcond(&state, 0.0, 0.0, 0.0, stopiteration);
      mincgsetxrep(&state, true);
      k = -1;
      while (mincgiteration(&state))
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += b.xR[i] * state.x.xR[i];
               state.g.xR[i] = b.xR[i];
               for (j = 0; j < n; j++) {
                  state.f += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                  state.g.xR[i] += fulla.xyR[i][j] * state.x.xR[j];
               }
            }
            if (k >= spoiliteration) {
               if (spoilvar < 0) {
                  state.f = spoilval;
               } else {
                  state.g.xR[spoilvar] = spoilval;
               }
            }
         } else if (state.xupdated) {
            k++;
         } else ae_assert(false, "Assertion failed");
      mincgresults(&state, &x1, &rep);
      Ok = Ok && rep.terminationtype == -8;
   }
// Check algorithm ability to handle request for termination:
// * to terminate with correct return code = 8
// * to return point which was "current" at the moment of termination
   for (pass = 1; pass <= 50; pass++) {
      n = 3;
      ss = 100.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 6 + randomreal();
      }
      stopcallidx = randominteger(20);
      maxits = 25;
      mincgcreate(n, &x, &state);
      mincgsetcond(&state, 0.0, 0.0, 0.0, maxits);
      mincgsetxrep(&state, true);
      callidx = 0;
      terminationrequested = false;
      ae_v_move(xlast.xR, 1, x.xR, 1, n);
      while (mincgiteration(&state))
         if (state.needfg) {
            state.f = ss * sqr(exp(state.x.xR[0]) - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
            state.g.xR[0] = 2 * ss * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[2] - state.x.xR[0]) * (-1);
            state.g.xR[1] = 2 * state.x.xR[1];
            state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
            if (callidx == stopcallidx) {
               mincgrequesttermination(&state);
               terminationrequested = true;
            }
            callidx++;
         } else if (state.xupdated) {
            if (!terminationrequested) {
               ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
            }
         } else ae_assert(false, "Assertion failed");
      mincgresults(&state, &x, &rep);
      Ok = Ok && rep.terminationtype == 8;
      for (i = 0; i < n; i++) {
         Ok = Ok && x.xR[i] == xlast.xR[i];
      }
   }
   ae_frame_leave();
   return Ok;
}

// Calculate test function #2
//
// Simple variation of #1, much more nonlinear, which makes unlikely premature
// convergence of algorithm .
static void testmincgunit_testfunc2(mincgstate *state) {
   if (state->x.xR[0] < 100.0) {
      if (state->needf || state->needfg) {
         state->f = sqr(exp(state->x.xR[0]) - 2) + sqr(sqr(state->x.xR[1])) + sqr(state->x.xR[2] - state->x.xR[0]);
         if (state->needfg) {
            state->g.xR[0] = 2 * (exp(state->x.xR[0]) - 2) * exp(state->x.xR[0]) + 2 * (state->x.xR[0] - state->x.xR[2]);
            state->g.xR[1] = 4 * state->x.xR[1] * sqr(state->x.xR[1]);
            state->g.xR[2] = 2 * (state->x.xR[2] - state->x.xR[0]);
         }
      }
   } else {
      if (state->needf || state->needfg) {
         state->f = sqrt(maxrealnumber);
         if (state->needfg) {
            state->g.xR[0] = sqrt(maxrealnumber);
            state->g.xR[1] = 0.0;
            state->g.xR[2] = 0.0;
         }
      }
   }
}

// Calculate test function #3
//
// Simple variation of #1, much more nonlinear, with non-zero value at minimum.
// It achieve two goals:
// * makes unlikely premature convergence of algorithm .
// * solves some issues with EpsF stopping condition which arise when
//   F(minimum) is zero
//
static void testmincgunit_testfunc3(mincgstate *state) {
   double s;
   s = 0.001;
   if (state->x.xR[0] < 100.0) {
      if (state->needf || state->needfg) {
         state->f = sqr(exp(state->x.xR[0]) - 2) + sqr(sqr(state->x.xR[1]) + s) + sqr(state->x.xR[2] - state->x.xR[0]);
         if (state->needfg) {
            state->g.xR[0] = 2 * (exp(state->x.xR[0]) - 2) * exp(state->x.xR[0]) + 2 * (state->x.xR[0] - state->x.xR[2]);
            state->g.xR[1] = 2 * (sqr(state->x.xR[1]) + s) * 2 * state->x.xR[1];
            state->g.xR[2] = 2 * (state->x.xR[2] - state->x.xR[0]);
         }
      }
   } else {
      if (state->needf || state->needfg) {
         state->f = sqrt(maxrealnumber);
         if (state->needfg) {
            state->g.xR[0] = sqrt(maxrealnumber);
            state->g.xR[1] = 0.0;
            state->g.xR[2] = 0.0;
         }
      }
   }
}

// Calculate test function IIP2
//
// f(x) = sum( ((i*i+1)*x[i])^2, i = 0..N-1)
//
// It has high condition number which makes fast convergence unlikely without
// good preconditioner.
//
static void testmincgunit_calciip2(mincgstate *state, ae_int_t n) {
   ae_int_t i;
   if (state->needf || state->needfg) {
      state->f = 0.0;
      for (i = 0; i < n; i++) {
         state->f += sqr(i * i + 1) * sqr(state->x.xR[i]);
         if (state->needfg) {
            state->g.xR[i] = sqr(i * i + 1) * 2 * state->x.xR[i];
         }
      }
   }
}

// Calculate test function f(x) = 0.5*(x-x0)'*A*(x-x0), A = D+V'*Vd*V
static void testmincgunit_calclowrank(mincgstate *state, ae_int_t n, ae_int_t vcnt, RVector *d, RMatrix *v, RVector *vd, RVector *x0) {
   ae_int_t i;
   ae_int_t j;
   double dx;
   double t;
   double t2;
   state->f = 0.0;
   for (i = 0; i < n; i++) {
      state->g.xR[i] = 0.0;
   }
   for (i = 0; i < n; i++) {
      dx = state->x.xR[i] - x0->xR[i];
      state->f += 0.5 * dx * d->xR[i] * dx;
      state->g.xR[i] += d->xR[i] * dx;
   }
   for (i = 0; i < vcnt; i++) {
      t = 0.0;
      for (j = 0; j < n; j++) {
         t += v->xyR[i][j] * (state->x.xR[j] - x0->xR[j]);
      }
      state->f += 0.5 * t * vd->xR[i] * t;
      t2 = t * vd->xR[i];
      ae_v_addd(state->g.xR, 1, v->xyR[i], 1, n, t2);
   }
}

// This function tests preconditioning
static bool testmincgunit_testpreconditioning() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t vs;
   ae_int_t cntb1;
   ae_int_t cntg1;
   ae_int_t cntb2;
   ae_int_t cntg2;
   ae_int_t cgtype;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewVector(vd, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(diagh, 0, DT_REAL);
   NewObj(mincgstate, state);
   NewObj(mincgreport, rep);
   k = 50;
   for (cgtype = -1; cgtype <= 1; cgtype++) {
   // Preconditioner test 1.
   //
   // If
   // * B1 is default preconditioner
   // * G1 is diagonal precomditioner based on approximate diagonal of Hessian matrix
   // then "bad" preconditioner is worse than "good" one.
   // "Worse" means more iterations to converge.
   //
   //
   // We test it using f(x) = sum( ((i*i+1)*x[i])^2, i = 0..N-1).
   //
   // N        - problem size
   // K        - number of repeated passes (should be large enough to average out random factors)
      for (n = 10; n <= 15; n++) {
         ae_vector_set_length(&x, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 0.0;
         }
         mincgcreate(n, &x, &state);
         mincgsetcgtype(&state, cgtype);
      // Test it with default preconditioner
         mincgsetprecdefault(&state);
         cntb1 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            for (mincgrestartfrom(&state, &x); mincgiteration(&state); ) testmincgunit_calciip2(&state, n);
            mincgresults(&state, &x, &rep);
            cntb1 += rep.iterationscount;
            Ok = Ok && rep.terminationtype > 0;
         }
      // Test it with perturbed diagonal preconditioner
         ae_vector_set_length(&diagh, n);
         for (i = 0; i < n; i++) {
            diagh.xR[i] = 2 * sqr(i * i + 1) * (0.8 + 0.4 * randomreal());
         }
         mincgsetprecdiag(&state, &diagh);
         cntg1 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            for (mincgrestartfrom(&state, &x); mincgiteration(&state); ) testmincgunit_calciip2(&state, n);
            mincgresults(&state, &x, &rep);
            cntg1 += rep.iterationscount;
            Ok = Ok && rep.terminationtype > 0;
         }
      // Compare
         Ok = Ok && cntb1 >= cntg1;
      }
   // Preconditioner test 2.
   //
   // If
   // * B1 is default preconditioner
   // * G1 is low rank exact preconditioner
   // then "bad" preconditioner is worse than "good" one.
   // "Worse" means more iterations to converge.
   //
   // Target function is f(x) = 0.5*(x-x0)'*A*(x-x0), A = D+V'*Vd*V
   //
   // N        - problem size
   // K        - number of repeated passes (should be large enough to average out random factors)
      for (n = 10; n <= 15; n++) {
         for (vs = 0; vs <= 5; vs++) {
            ae_vector_set_length(&x, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&d, n);
            for (i = 0; i < n; i++) {
               x.xR[i] = 0.0;
               x0.xR[i] = randommid();
               d.xR[i] = exp(2 * randomreal());
            }
            if (vs > 0) {
               ae_matrix_set_length(&v, vs, n);
               ae_vector_set_length(&vd, vs);
               for (i = 0; i < vs; i++) {
                  for (j = 0; j < n; j++) {
                     v.xyR[i][j] = randommid();
                  }
                  vd.xR[i] = exp(2 * randomreal());
               }
            }
            mincgcreate(n, &x, &state);
            mincgsetcgtype(&state, cgtype);
         // Test it with default preconditioner
            mincgsetprecdefault(&state);
            cntb1 = 0;
            for (pass = 0; pass < k; pass++) {
               for (i = 0; i < n; i++) {
                  x.xR[i] = randommid();
               }
               for (mincgrestartfrom(&state, &x); mincgiteration(&state); ) testmincgunit_calclowrank(&state, n, vs, &d, &v, &vd, &x0);
               mincgresults(&state, &x, &rep);
               cntb1 += rep.iterationscount;
               Ok = Ok && rep.terminationtype > 0;
            }
         // Test it with low rank preconditioner
            mincgsetpreclowrankfast(&state, &d, &vd, &v, vs);
            cntg1 = 0;
            for (pass = 0; pass < k; pass++) {
               for (i = 0; i < n; i++) {
                  x.xR[i] = randommid();
               }
               for (mincgrestartfrom(&state, &x); mincgiteration(&state); ) testmincgunit_calclowrank(&state, n, vs, &d, &v, &vd, &x0);
               mincgresults(&state, &x, &rep);
               cntg1 += rep.iterationscount;
               Ok = Ok && rep.terminationtype > 0;
            }
         // Compare
            Ok = Ok && cntb1 >= cntg1;
         }
      }
   // Preconditioner test 3.
   //
   // If
   // * B2 is default preconditioner with non-unit scale S[i] == 1/sqrt(h[i])
   // * G2 is scale-based preconditioner with non-unit scale S[i] == 1/sqrt(h[i])
   // then B2 is worse than G2.
   // "Worse" means more iterations to converge.
      for (n = 10; n <= 15; n++) {
         ae_vector_set_length(&x, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 0.0;
         }
         mincgcreate(n, &x, &state);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = 1 / sqrt(2 * pow((double)(i * i + 1), 2.0) * (0.8 + 0.4 * randomreal()));
         }
         mincgsetprecdefault(&state);
         mincgsetscale(&state, &s);
         cntb2 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            for (mincgrestartfrom(&state, &x); mincgiteration(&state); ) testmincgunit_calciip2(&state, n);
            mincgresults(&state, &x, &rep);
            cntb2 += rep.iterationscount;
            Ok = Ok && rep.terminationtype > 0;
         }
         mincgsetprecscale(&state);
         mincgsetscale(&state, &s);
         cntg2 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            for (mincgrestartfrom(&state, &x); mincgiteration(&state); ) testmincgunit_calciip2(&state, n);
            mincgresults(&state, &x, &rep);
            cntg2 += rep.iterationscount;
            Ok = Ok && rep.terminationtype > 0;
         }
         Ok = Ok && cntb2 >= cntg2;
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests report of "non-C1" test #0 for task #0
// given by matrix A.
static bool testmincgunit_testoptguardc1test0reportfortask0(optguardnonc1test0report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool hasc1discontinuities;
   bool Ok = true;
   if (rep->positive) {
   // Check positive report, first checks
      Ok = Ok && rep->fidx == 0;
      Ok = Ok && rep->n == n;
      Ok = Ok && 0 <= rep->stpidxa;
      Ok = Ok && rep->stpidxa < rep->stpidxb;
      Ok = Ok && rep->stpidxb < rep->cnt;
      Ok = Ok && rep->x0.cnt == rep->n;
      Ok = Ok && rep->d.cnt == rep->n;
      Ok = Ok && rep->stp.cnt == rep->cnt;
      Ok = Ok && rep->f.cnt == rep->cnt;
      Ok = Ok && isfinitevector(&rep->x0, n);
      Ok = Ok && isfinitevector(&rep->d, n);
      Ok = Ok && isfinitevector(&rep->stp, rep->cnt);
      Ok = Ok && isfinitevector(&rep->f, rep->cnt);
      if (!Ok) {
         return Ok;
      }
   // Check consistency of X0, D, Stp and F
      for (k = 0; k < rep->cnt - 1; k++) {
         Ok = Ok && rep->stp.xR[k] < rep->stp.xR[k + 1];
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += fabs(vv);
         }
         Ok = Ok && NearAtR(v, rep->f.xR[k], 1.0E-6 * rmax2(fabs(v), 1.0));
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      Ok = Ok && hasc1discontinuities;
   } else {
   // Check negative report: fields must be empty
      Ok = Ok && rep->stpidxa == -1;
      Ok = Ok && rep->stpidxb == -1;
      Ok = Ok && rep->fidx == -1;
      Ok = Ok && rep->cnt == 0;
      Ok = Ok && rep->n == 0;
      Ok = Ok && rep->x0.cnt == 0;
      Ok = Ok && rep->d.cnt == 0;
      Ok = Ok && rep->stp.cnt == 0;
      Ok = Ok && rep->f.cnt == 0;
   }
   return Ok;
}

// This function tests report of "non-C1" test #1 for task #0
// given by matrix A.
static bool testmincgunit_testoptguardc1test1reportfortask0(optguardnonc1test1report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool tooclose;
   bool hasc1discontinuities;
   bool Ok = true;
   if (rep->positive) {
   // Check positive report, first checks
      Ok = Ok && rep->fidx == 0;
      Ok = Ok && rep->vidx >= 0;
      Ok = Ok && rep->vidx <= n;
      Ok = Ok && rep->n == n;
      Ok = Ok && 0 <= rep->stpidxa;
      Ok = Ok && rep->stpidxa < rep->stpidxb;
      Ok = Ok && rep->stpidxb < rep->cnt;
      Ok = Ok && rep->x0.cnt == rep->n;
      Ok = Ok && rep->d.cnt == rep->n;
      Ok = Ok && rep->stp.cnt == rep->cnt;
      Ok = Ok && rep->g.cnt == rep->cnt;
      Ok = Ok && isfinitevector(&rep->x0, n);
      Ok = Ok && isfinitevector(&rep->d, n);
      Ok = Ok && isfinitevector(&rep->stp, rep->cnt);
      Ok = Ok && isfinitevector(&rep->g, rep->cnt);
      if (!Ok) {
         return Ok;
      }
   // Check consistency of X0, D, Stp and G
      for (k = 0; k < rep->cnt - 1; k++) {
         Ok = Ok && rep->stp.xR[k] < rep->stp.xR[k + 1];
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         tooclose = false;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += sign(vv) * a->xyR[i][rep->vidx];
            tooclose = tooclose || SmallR(vv, 1.0E-4);
         }
         if (!tooclose) {
            Ok = Ok && NearAtR(v, rep->g.xR[k], 1.0E-6 * rmax2(fabs(v), 1.0));
         }
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      tooclose = false;
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         tooclose = tooclose || SmallR(va, 1.0E-8) || SmallR(vb, 1.0E-8);
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      if (!tooclose) {
         Ok = Ok && hasc1discontinuities;
      }
   } else {
   // Check negative report: fields must be empty
      Ok = Ok && rep->stpidxa == -1;
      Ok = Ok && rep->stpidxb == -1;
      Ok = Ok && rep->fidx == -1;
      Ok = Ok && rep->vidx == -1;
      Ok = Ok && rep->cnt == 0;
      Ok = Ok && rep->n == 0;
      Ok = Ok && rep->x0.cnt == 0;
      Ok = Ok && rep->d.cnt == 0;
      Ok = Ok && rep->stp.cnt == 0;
      Ok = Ok && rep->g.cnt == 0;
   }
   return Ok;
}

// This function tests OptGuard
static bool testmincgunit_testoptguard() {
   ae_frame _frame_block;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   double diffstep;
   ae_int_t pass;
   ae_int_t defecttype;
   bool failed;
   ae_int_t passcount;
   ae_int_t maxfails;
   ae_int_t failurecounter;
   ae_int_t maxc1test0fails;
   ae_int_t maxc1test1fails;
   ae_int_t c1test0fails;
   ae_int_t c1test1fails;
   double avgstr0len;
   double avglng0len;
   double avgstr1len;
   double avglng1len;
   ae_int_t varidx;
   ae_int_t skind;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(mincgstate, state);
   NewObj(mincgreport, rep);
   NewObj(optguardreport, ogrep);
   NewObj(optguardnonc1test0report, ognonc1test0strrep);
   NewObj(optguardnonc1test0report, ognonc1test0lngrep);
   NewObj(optguardnonc1test1report, ognonc1test1strrep);
   NewObj(optguardnonc1test1report, ognonc1test1lngrep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewMatrix(jactrue, 0, 0, DT_REAL);
   NewMatrix(jacdefect, 0, 0, DT_REAL);
   hqrndrandomize(&rs);
// Check that gradient verification is disabled by default:
// gradient checking for bad problem must return nothing
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = 1.0 + 0.1 * i;
   }
   spdmatrixrndcond(n, 1.0E3, &a);
   spdmatrixrndcond(n, 1.0E3, &a1);
   mincgcreate(n, &x0, &state);
   mincgsetcond(&state, 0.0, 0.0, 1.0E-9, 10);
   while (mincgiteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += 0.5 * state.x.xR[i] * v;
         }
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
      } else ae_assert(false, "Assertion failed");
   mincgresults(&state, &x1, &rep);
   mincgoptguardresults(&state, &ogrep);
   Ok = Ok && rep.terminationtype > 0;
   Ok = Ok && isfinitevector(&x1, n);
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && ogrep.badgradxbase.cnt == 0;
   Ok = Ok && ogrep.badgraduser.rows == 0;
   Ok = Ok && ogrep.badgraduser.cols == 0;
   Ok = Ok && ogrep.badgradnum.rows == 0;
   Ok = Ok && ogrep.badgradnum.cols == 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && !ogrep.badgradsuspected;
   Ok = Ok && ogrep.badgradfidx == -1;
   Ok = Ok && ogrep.badgradvidx == -1;
// Test that C0/C1 continuity monitoring is disabled by default;
// we solve nonsmooth problem and test that nothing is returned
// by OptGuard.
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = hqrndnormal(&rs);
   }
   ae_matrix_set_length(&a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a.xyR[i][j] = hqrndnormal(&rs);
      }
   }
   mincgcreate(n, &x0, &state);
   mincgsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
   while (mincgiteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += fabs(v);
            v = (double)sign(v);
            for (j = 0; j < n; j++) {
               state.g.xR[j] += v * a.xyR[i][j];
            }
         }
      } else ae_assert(false, "Assertion failed");
   mincgresults(&state, &x1, &rep);
   mincgoptguardresults(&state, &ogrep);
   Ok = Ok && isfinitevector(&x1, n);
   Ok = Ok && rep.terminationtype > 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && !ogrep.nonc0suspected;
   Ok = Ok && !ogrep.nonc1suspected;
   Ok = Ok && optguardallclear(&ogrep);
   Ok = Ok && ogrep.nonc0fidx < 0;
   Ok = Ok && ogrep.nonc1fidx < 0;
   Ok = Ok && !ogrep.nonc1test0positive;
   Ok = Ok && !ogrep.nonc1test1positive;
// Test gradient checking functionality, try various
// defect types:
// * accidental zeroing of some gradient component
// * accidental addition of 1.0 to some component
// * accidental multiplication by 2.0
// Try distorting both target and constraints.
   diffstep = 0.001;
   n = 10;
   for (skind = 0; skind <= 1; skind++) {
      for (defecttype = -1; defecttype <= 2; defecttype++) {
         varidx = hqrnduniformi(&rs, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, skind * 15.0 * hqrndmiduniformr(&rs));
            x0.xR[i] = (1.0 + 0.1 * i) * s.xR[i];
         }
         spdmatrixrndcond(n, 1.0E3, &a);
         spdmatrixrndcond(n, 1.0E3, &a1);
         mincgcreate(n, &x0, &state);
         mincgoptguardgradient(&state, diffstep);
         mincgsetcond(&state, 0.0, 0.0, 1.0E-9, 10);
         mincgsetscale(&state, &s);
         while (mincgiteration(&state))
            if (state.needfg) {
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += state.x.xR[j] / s.xR[j] * a.xyR[i][j];
                  }
                  state.f += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                  state.g.xR[i] = v;
               }
               if (defecttype == 0) {
                  state.g.xR[varidx] = 0.0;
               }
               if (defecttype == 1) {
                  state.g.xR[varidx]++;
               }
               if (defecttype == 2) {
                  state.g.xR[varidx] *= 2;
               }
               for (i = 0; i < n; i++) {
                  state.g.xR[i] /= s.xR[i];
               }
            } else ae_assert(false, "Assertion failed");
         mincgresults(&state, &x1, &rep);
         mincgoptguardresults(&state, &ogrep);
      // Check that something is returned
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && isfinitevector(&x1, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Compute reference values for true and spoiled Jacobian at X0
         Ok = Ok && isfinitevector(&ogrep.badgradxbase, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         ae_matrix_set_length(&jactrue, 1, n);
         ae_matrix_set_length(&jacdefect, 1, n);
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += ogrep.badgradxbase.xR[j] / s.xR[j] * a.xyR[i][j];
            }
            jactrue.xyR[0][i] = v;
            jacdefect.xyR[0][i] = v;
         }
         if (defecttype == 0) {
            jacdefect.xyR[0][varidx] = 0.0;
         }
         if (defecttype == 1) {
            jacdefect.xyR[0][varidx]++;
         }
         if (defecttype == 2) {
            jacdefect.xyR[0][varidx] *= 2;
         }
         for (i = 0; i < n; i++) {
            jactrue.xyR[0][i] /= s.xR[i];
            jacdefect.xyR[0][i] /= s.xR[i];
         }
      // Check OptGuard report
         Ok = Ok && apservisfinitematrix(&ogrep.badgraduser, 1, n);
         Ok = Ok && apservisfinitematrix(&ogrep.badgradnum, 1, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         if (defecttype >= 0) {
            Ok = Ok && ogrep.badgradsuspected;
            Ok = Ok && ogrep.badgradfidx == 0;
            Ok = Ok && ogrep.badgradvidx == varidx;
         } else {
            Ok = Ok && !ogrep.badgradsuspected;
            Ok = Ok && ogrep.badgradfidx == -1;
            Ok = Ok && ogrep.badgradvidx == -1;
         }
         for (j = 0; j < n; j++) {
            Ok = Ok && NearAtR(jactrue.xyR[0][j], ogrep.badgradnum.xyR[0][j], 0.01 / s.xR[j]);
            Ok = Ok && NearAtR(jacdefect.xyR[0][j], ogrep.badgraduser.xyR[0][j], 0.01 / s.xR[j]);
         }
      }
   }
// A test for detection of C1 continuity violations in the target.
//
// Target function is a sum of |(x,c_i)| for i = 1..N.
// No constraints is present.
// Analytic gradient is provided.
//
// OptGuard should be able to detect violations in more than
// 99.9% of runs; it means that 100 runs should have no more than 4
// failures in all cases (even after multiple repeated tests; according
// to the binomial distribution quantiles).
//
// We select some N and perform exhaustive search for this N.
   passcount = 100;
   maxfails = 4;
   maxc1test0fails = 10;
   maxc1test1fails = 10;
   n = 1 + hqrnduniformi(&rs, 10);
   failurecounter = 0;
   c1test0fails = 0;
   c1test1fails = 0;
   avgstr0len = 0.0;
   avglng0len = 0.0;
   avgstr1len = 0.0;
   avglng1len = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = pow(2.0, hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      mincgcreate(n, &x0, &state);
      mincgsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      mincgsetscale(&state, &s);
      mincgoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testmincgunit_maxoptguardlevel));
      while (mincgiteration(&state))
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.g.xR[i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
               v = (double)sign(v);
               for (j = 0; j < n; j++) {
                  state.g.xR[j] += v * a.xyR[i][j];
               }
            }
         } else ae_assert(false, "Assertion failed");
      mincgresults(&state, &x1, &rep);
      mincgoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Check generic OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      Ok = Ok && !ogrep.nonc0suspected;
      Ok = Ok && ogrep.nonc0fidx < 0;
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   // Check C1 continuity test #0
      mincgoptguardnonc1test0results(&state, &ognonc1test0strrep, &ognonc1test0lngrep);
      mincgoptguardnonc1test1results(&state, &ognonc1test1strrep, &ognonc1test1lngrep);
      if (ogrep.nonc1test0positive) {
         Ok = Ok && ogrep.nonc1suspected;
         Ok = Ok && ognonc1test0strrep.positive;
         Ok = Ok && ognonc1test0lngrep.positive;
         Ok = Ok && ogrep.nonc1fidx == 0;
         Ok = Ok && testmincgunit_testoptguardc1test0reportfortask0(&ognonc1test0strrep, &a, n);
         Ok = Ok && testmincgunit_testoptguardc1test0reportfortask0(&ognonc1test0lngrep, &a, n);
         avgstr0len += (double)ognonc1test0strrep.cnt / passcount;
         avglng0len += (double)ognonc1test0lngrep.cnt / passcount;
      } else {
         Ok = Ok && !ognonc1test0strrep.positive;
         Ok = Ok && !ognonc1test0lngrep.positive;
         Ok = Ok && testmincgunit_testoptguardc1test0reportfortask0(&ognonc1test0strrep, &a, n);
         Ok = Ok && testmincgunit_testoptguardc1test0reportfortask0(&ognonc1test0lngrep, &a, n);
         c1test0fails++;
      }
      if (ogrep.nonc1test1positive) {
         Ok = Ok && ogrep.nonc1suspected;
         Ok = Ok && ognonc1test1strrep.positive;
         Ok = Ok && ognonc1test1lngrep.positive;
         Ok = Ok && ogrep.nonc1fidx == 0;
         Ok = Ok && testmincgunit_testoptguardc1test1reportfortask0(&ognonc1test1strrep, &a, n);
         Ok = Ok && testmincgunit_testoptguardc1test1reportfortask0(&ognonc1test1lngrep, &a, n);
         avgstr1len += (double)ognonc1test1strrep.cnt / passcount;
         avglng1len += (double)ognonc1test1lngrep.cnt / passcount;
      } else {
         Ok = Ok && !ognonc1test1strrep.positive;
         Ok = Ok && !ognonc1test1lngrep.positive;
         Ok = Ok && testmincgunit_testoptguardc1test1reportfortask0(&ognonc1test1strrep, &a, n);
         Ok = Ok && testmincgunit_testoptguardc1test1reportfortask0(&ognonc1test1lngrep, &a, n);
         c1test1fails++;
      }
   }
   Ok = Ok && failurecounter <= maxfails;
   Ok = Ok && c1test0fails <= maxc1test0fails;
   Ok = Ok && c1test1fails <= maxc1test1fails;
   Ok = Ok && avglng0len > avgstr0len;
   Ok = Ok && avglng1len > avgstr1len;
// Detection of C1 continuity violations in the target under numerical differentiation:
// * target function is a sum of |(x,c_i)| for i = 1..N.
// * no constraints is present.
// * analytic gradient is provided.
//
// OptGuard should always be able to detect violations in more than
// 99% of runs (note: reduced strength when compared with analytic gradient);
// it means that 100 runs should have no more than 10 failures in all cases
// (even after multiple repeated tests; according to the binomial distribution
// quantiles).
//
// We select some N and perform exhaustive search for this N.
   diffstep = 0.0001;
   passcount = 100;
   maxfails = 10;
   n = 1 + hqrnduniformi(&rs, 10);
   failurecounter = 0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 0.01 * pow(2.0, 0.33 * hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      mincgcreatef(n, &x0, diffstep, &state);
      mincgsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      mincgoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testmincgunit_maxoptguardlevel));
      while (mincgiteration(&state))
         if (state.needf) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
            }
         } else ae_assert(false, "Assertion failed");
      mincgresults(&state, &x1, &rep);
      mincgoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Check OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      Ok = Ok && !ogrep.nonc0suspected;
      Ok = Ok && ogrep.nonc0fidx < 0;
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   }
   Ok = Ok && failurecounter <= maxfails;
// Make sure than no false positives are reported for larger
// problems where numerical noise can be an issue:
// * N == 100 dimensions
// * positive-definite quadratic programming problem
// * upper limit on iterations count, MaxIts == 25
// We simply test that OptGuard does not return error code.
   n = 100;
   spdmatrixrndcond(n, 1.0E2, &a);
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = hqrndnormal(&rs);
      x0.xR[i] = pow(2.0, hqrndnormal(&rs));
   }
   mincgcreate(n, &x0, &state);
   mincgoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testmincgunit_maxoptguardlevel));
   mincgsetcond(&state, 0.0, 0.0, 1.0E-9, 25);
   while (mincgiteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += b.xR[i] * state.x.xR[i];
            state.g.xR[i] = b.xR[i];
            for (j = 0; j < n; j++) {
               state.f += 0.5 * state.x.xR[i] * a.xyR[i][j] * state.x.xR[j];
               state.g.xR[i] += a.xyR[i][j] * state.x.xR[j];
            }
         }
      } else ae_assert(false, "Assertion failed");
   mincgresults(&state, &x1, &rep);
   Ok = Ok && isfinitevector(&x1, n);
   Ok = Ok && rep.terminationtype > 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   mincgoptguardresults(&state, &ogrep);
   Ok = Ok && optguardallclear(&ogrep);
   ae_frame_leave();
   return Ok;
}

bool testmincg() {
   ae_frame _frame_block;
   bool Ok;
   bool refOk;
   bool eqOk;
   bool lin1Ok;
   bool lin2Ok;
   bool restartsOk;
   bool precOk;
   bool convOk;
   bool otherOk;
   bool optguardOk;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_int_t cgtype;
   ae_int_t difftype;
   double diffstep;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(diagh, 0, DT_REAL);
   NewObj(mincgstate, state);
   NewObj(mincgreport, rep);
   Ok = true;
   refOk = true;
   lin1Ok = true;
   lin2Ok = true;
   eqOk = true;
   convOk = true;
   restartsOk = true;
   otherOk = true;
   precOk = true;
   precOk = precOk && testmincgunit_testpreconditioning();
   otherOk = otherOk && testother();
   for (difftype = 0; difftype <= 1; difftype++) {
      for (cgtype = -1; cgtype <= 1; cgtype++) {
      // Reference problem
         ae_vector_set_length(&x, 2 + 1);
         n = 3;
         diffstep = 1.0E-6;
         x.xR[0] = 50.0 * randommid();
         x.xR[1] = 50.0 * randommid();
         x.xR[2] = 50.0 * randommid();
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcgtype(&state, cgtype);
         while (mincgiteration(&state)) {
            if (state.needf || state.needfg) {
               state.f = sqr(state.x.xR[0] - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
            }
            if (state.needfg) {
               state.g.xR[0] = 2 * (state.x.xR[0] - 2) + 2 * (state.x.xR[0] - state.x.xR[2]);
               state.g.xR[1] = 2 * state.x.xR[1];
               state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
            }
         }
         mincgresults(&state, &x, &rep);
         refOk = refOk && rep.terminationtype > 0 && NearAtR(x.xR[0], 2, 0.001) && SmallAtR(x.xR[1], 0.001) && NearAtR(x.xR[2], 2, 0.001);
      // F2 problem with restarts:
      // * make several iterations and restart BEFORE termination
      // * iterate and restart AFTER termination
      //
      // NOTE: step is bounded from above to avoid premature convergence
         ae_vector_set_length(&x, 3);
         n = 3;
         diffstep = 1.0E-6;
         x.xR[0] = 10 + 10.0 * randomreal();
         x.xR[1] = 10 + 10.0 * randomreal();
         x.xR[2] = 10 + 10.0 * randomreal();
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcgtype(&state, cgtype);
         mincgsetstpmax(&state, 0.1);
         mincgsetcond(&state, 0.0000001, 0.0, 0.0, 0);
         for (i = 0; i <= 10 && mincgiteration(&state); i++) testmincgunit_testfunc2(&state);
         x.xR[0] = 10 + 10.0 * randomreal();
         x.xR[1] = 10 + 10.0 * randomreal();
         x.xR[2] = 10 + 10.0 * randomreal();
         for (mincgrestartfrom(&state, &x); mincgiteration(&state); ) testmincgunit_testfunc2(&state);
         mincgresults(&state, &x, &rep);
         restartsOk = restartsOk && rep.terminationtype > 0 && NearAtR(x.xR[0], log(2.0), 0.01) && SmallAtR(x.xR[1], 0.01) && NearAtR(x.xR[2], log(2.0), 0.01);
         x.xR[0] = 10 + 10.0 * randomreal();
         x.xR[1] = 10 + 10.0 * randomreal();
         x.xR[2] = 10 + 10.0 * randomreal();
         for (mincgrestartfrom(&state, &x); mincgiteration(&state); ) testmincgunit_testfunc2(&state);
         mincgresults(&state, &x, &rep);
         restartsOk = restartsOk && rep.terminationtype > 0 && NearAtR(x.xR[0], log(2.0), 0.01) && SmallAtR(x.xR[1], 0.01) && NearAtR(x.xR[2], log(2.0), 0.01);
      // 1D problem #1
         ae_vector_set_length(&x, 0 + 1);
         n = 1;
         diffstep = 1.0E-6;
         x.xR[0] = 50.0 * randommid();
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcgtype(&state, cgtype);
         while (mincgiteration(&state)) {
            if (state.needf || state.needfg) {
               state.f = -cos(state.x.xR[0]);
            }
            if (state.needfg) {
               state.g.xR[0] = sin(state.x.xR[0]);
            }
         }
         mincgresults(&state, &x, &rep);
         lin1Ok = lin1Ok && rep.terminationtype > 0 && NearAtR(x.xR[0] / pi, round(x.xR[0] / pi), 0.001);
      // 1D problem #2
         ae_vector_set_length(&x, 0 + 1);
         n = 1;
         diffstep = 1.0E-6;
         x.xR[0] = 50.0 * randommid();
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcgtype(&state, cgtype);
         while (mincgiteration(&state)) {
            if (state.needf || state.needfg) {
               state.f = sqr(state.x.xR[0]) / (1 + sqr(state.x.xR[0]));
            }
            if (state.needfg) {
               state.g.xR[0] = (2 * state.x.xR[0] * (1 + sqr(state.x.xR[0])) - sqr(state.x.xR[0]) * 2 * state.x.xR[0]) / sqr(1 + sqr(state.x.xR[0]));
            }
         }
         mincgresults(&state, &x, &rep);
         lin2Ok = lin2Ok && rep.terminationtype > 0 && SmallAtR(x.xR[0], 0.001);
      // Linear equations
         diffstep = 1.0E-6;
         for (n = 1; n <= 10; n++) {
         // Prepare task
            ae_matrix_set_length(&a, n, n);
            ae_vector_set_length(&x, n);
            ae_vector_set_length(&xe, n);
            ae_vector_set_length(&b, n);
            for (i = 0; i < n; i++) {
               xe.xR[i] = randommid();
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = randommid();
               }
               a.xyR[i][i] += 3 * sign(a.xyR[i][i]);
            }
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xe.xR, 1, n);
               b.xR[i] = v;
            }
         // Solve task
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            if (difftype == 0) {
               mincgcreate(n, &x, &state);
            }
            if (difftype == 1) {
               mincgcreatef(n, &x, diffstep, &state);
            }
            mincgsetcgtype(&state, cgtype);
            while (mincgiteration(&state)) {
               if (state.needf || state.needfg) {
                  state.f = 0.0;
               }
               if (state.needfg) {
                  for (i = 0; i < n; i++) {
                     state.g.xR[i] = 0.0;
                  }
               }
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
                  if (state.needf || state.needfg) {
                     state.f += sqr(v - b.xR[i]);
                  }
                  if (state.needfg) {
                     for (j = 0; j < n; j++) {
                        state.g.xR[j] += 2 * (v - b.xR[i]) * a.xyR[i][j];
                     }
                  }
               }
            }
            mincgresults(&state, &x, &rep);
            eqOk = eqOk && rep.terminationtype > 0;
            for (i = 0; i < n; i++) {
               eqOk = eqOk && NearAtR(x.xR[i], xe.xR[i], 0.001);
            }
         }
      // Testing convergence properties
         diffstep = 1.0E-6;
         n = 3;
         ae_vector_set_length(&x, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 3.0 * randommid();
         }
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcond(&state, 0.001, 0.0, 0.0, 0);
         mincgsetcgtype(&state, cgtype);
         while (mincgiteration(&state)) testmincgunit_testfunc3(&state);
         mincgresults(&state, &x, &rep);
         convOk = convOk && rep.terminationtype == 4;
         for (i = 0; i < n; i++) {
            x.xR[i] = 3.0 * randommid();
         }
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcond(&state, 0.0, 0.001, 0.0, 0);
         mincgsetcgtype(&state, cgtype);
         while (mincgiteration(&state)) testmincgunit_testfunc3(&state);
         mincgresults(&state, &x, &rep);
         convOk = convOk && rep.terminationtype == 1;
         for (i = 0; i < n; i++) {
            x.xR[i] = 3.0 * randommid();
         }
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcond(&state, 0.0, 0.0, 0.001, 0);
         mincgsetcgtype(&state, cgtype);
         while (mincgiteration(&state)) testmincgunit_testfunc3(&state);
         mincgresults(&state, &x, &rep);
         convOk = convOk && rep.terminationtype == 2;
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcond(&state, 0.0, 0.0, 0.0, 10);
         mincgsetcgtype(&state, cgtype);
         while (mincgiteration(&state)) testmincgunit_testfunc3(&state);
         mincgresults(&state, &x, &rep);
         convOk = convOk && (rep.terminationtype == 5 && rep.iterationscount == 10 || rep.terminationtype == 7);
      }
   }
// Test for MinCGGradientCheck
   optguardOk = true;
   optguardOk = optguardOk && testmincgunit_testoptguard();
// The final report.
   Ok = refOk && eqOk && lin1Ok && lin2Ok && convOk && otherOk && restartsOk && precOk && optguardOk;
   if (!Ok || !silent) {
      printf("ConjGrad Tests\n");
      printf("Reference Problem:                        %s\n", refOk? "Ok": "Failed");
      printf("Lin-1 Problem:                            %s\n", lin1Ok? "Ok": "Failed");
      printf("Lin-2 Problem:                            %s\n", lin2Ok? "Ok": "Failed");
      printf("Linear Equations:                         %s\n", eqOk? "Ok": "Failed");
      printf("Restarts:                                 %s\n", restartsOk? "Ok": "Failed");
      printf("Preconditioning:                          %s\n", precOk? "Ok": "Failed");
      printf("Convergence Properties:                   %s\n", convOk? "Ok": "Failed");
      printf("Other Properties:                         %s\n", otherOk? "Ok": "Failed");
      printf("OptGuard:                                 %s\n", optguardOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === minlp testing unit ===
static const ae_int_t testminlpunit_solverscount = 2;

// This function validates solution returned by LP solver. It returns  primal
// and dual feasibility errors for this solution.
//
// SolverType:
// * 0 for dual simplex solver; additional test relying on explicit information
//   about constraint statuses is performed
// * 1 for interior point method; only straightforward dual  feasibility is
//   tested
//
static void testminlpunit_validatesolution(RVector *c, RVector *bndl, RVector *bndu, ae_int_t n, RMatrix *a, RVector *al, RVector *au, ae_int_t m, RVector *xcand, minlpreport *rep, ae_int_t solvertype, double *errprim, double *errdual, double *errslack) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   bool checkstats;
   ae_frame_make(&_frame_block);
   *errprim = 0;
   *errdual = 0;
   *errslack = 0;
   NewVector(d, 0, DT_REAL);
   checkstats = solvertype == 0;
   *errprim = 0.0;
   *errdual = 0.0;
   *errslack = 0.0;
// Test primal feasibility
   for (i = 0; i < n; i++) {
      if (isfinite(bndl->xR[i])) {
         *errprim = rmax2(*errprim, bndl->xR[i] - xcand->xR[i]);
      }
      if (isfinite(bndu->xR[i])) {
         *errprim = rmax2(*errprim, xcand->xR[i] - bndu->xR[i]);
      }
   }
   for (i = 0; i < m; i++) {
      v = rdotvr(n, xcand, a, i);
      if (isfinite(al->xR[i])) {
         *errprim = rmax2(*errprim, al->xR[i] - v);
      }
      if (isfinite(au->xR[i])) {
         *errprim = rmax2(*errprim, v - au->xR[i]);
      }
   }
// Test dual feasibility using Lagrange multipliers
   ae_vector_set_length(&d, n);
   for (i = 0; i < n; i++) {
      d.xR[i] = c->xR[i];
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         d.xR[j] += rep->laglc.xR[i] * a->xyR[i][j];
      }
   }
   for (i = 0; i < n; i++) {
      d.xR[i] += rep->lagbc.xR[i];
   }
   *errdual = rmax2(*errdual, rmaxabsv(n, &d));
// Test complementary slackness
   for (i = 0; i < n; i++) {
      if (isfinite(bndl->xR[i])) {
         *errslack = rmax2(*errslack, rmax2(xcand->xR[i] - bndl->xR[i], 0.0) * rmax2(-rep->lagbc.xR[i], 0.0));
      }
      if (isfinite(bndu->xR[i])) {
         *errslack = rmax2(*errslack, rmax2(bndu->xR[i] - xcand->xR[i], 0.0) * rmax2(rep->lagbc.xR[i], 0.0));
      }
   }
   for (i = 0; i < m; i++) {
      v = rdotvr(n, xcand, a, i);
      if (isfinite(al->xR[i])) {
         *errslack = rmax2(*errslack, rmax2(v - al->xR[i], 0.0) * rmax2(-rep->laglc.xR[i], 0.0));
      }
      if (isfinite(au->xR[i])) {
         *errslack = rmax2(*errslack, rmax2(au->xR[i] - v, 0.0) * rmax2(rep->laglc.xR[i], 0.0));
      }
   }
// Test dual feasibility using Stats[] array
   if (checkstats) {
   }
   ae_frame_leave();
}

// This function selects random LP solver
static void testminlpunit_selectrandomsolver(minlpstate *state) {
   ae_int_t k;
   k = randominteger(2);
   if (k == 0) {
      minlpsetalgodss(state, 0.0);
   }
   if (k == 1) {
      minlpsetalgoipm(state, 0.0);
   }
}

// This function selects specific LP solver.
//
// Reg parameter is used to regularize IPM algo, ignore for DSS
static void testminlpunit_selectsolver(minlpstate *state, ae_int_t st) {
   if (st == 0) {
      minlpsetalgodss(state, 0.0);
      return;
   }
   if (st == 1) {
      minlpsetalgoipm(state, 0.0);
      return;
   }
   ae_assert(false, "SelectSolver: unexpected solver");
}

// Shifts nonzero elements of C[] away from zero
static void testminlpunit_shiftfromzero(RVector *c, ae_int_t n, double s) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      c->xR[i] += sign(c->xR[i]) * s;
   }
}

// Basic tests.
static bool testminlpunit_basictests() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t ccnt;
   ae_int_t pass;
   double v0;
   double v1;
   double errslack;
   double primtol;
   double dualtol;
   bool Ok = true;
   double slacktol;
   ae_int_t solvertype;
   ae_frame_make(&_frame_block);
   NewObj(minlpstate, state);
   NewObj(minlpreport, rep);
   NewVector(c, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(al, 0, DT_REAL);
   NewVector(au, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   primtol = 1.0E-4;
   dualtol = 1.0E-4;
   slacktol = 1.0E-4;
   hqrndrandomize(&rs);
// Test default state of the solver
   for (pass = 1; pass <= 5; pass++) {
      n = 1 + hqrnduniformi(&rs, 10);
      minlpcreate(n, &state);
      testminlpunit_selectrandomsolver(&state);
      minlpoptimize(&state);
      minlpresults(&state, &x, &rep);
      Ok = Ok && rep.terminationtype > 0;
      Ok = Ok && x.cnt >= n;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && x.xR[i] == 0.0;
      }
   }
// Test box constrained problems without linear constraints
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 20; pass++) {
         solvertype = hqrnduniformi(&rs, testminlpunit_solverscount);
         ae_vector_set_length(&c, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
      // Feasible bounded problems
         for (i = 0; i < n; i++) {
            c.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = hqrndnormal(&rs);
            bndu.xR[i] = bndl.xR[i] + hqrnduniformi(&rs, 3);
         }
         testminlpunit_shiftfromzero(&c, n, 0.01);
         minlpcreate(n, &state);
         testminlpunit_selectsolver(&state, solvertype);
         minlpsetcost(&state, &c);
         minlpsetbc(&state, &bndl, &bndu);
         minlpoptimize(&state);
         minlpresults(&state, &x, &rep);
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && x.cnt >= n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && (c.xR[i] <= 0.0 || x.xR[i] >= bndl.xR[i] && x.xR[i] <= bndl.xR[i] + primtol);
            Ok = Ok && (c.xR[i] >= 0.0 || x.xR[i] <= bndu.xR[i] && x.xR[i] >= bndu.xR[i] - primtol);
            Ok = Ok && (c.xR[i] <= 0.0 || solvertype != 0 || x.xR[i] == bndl.xR[i]);
            Ok = Ok && (c.xR[i] >= 0.0 || solvertype != 0 || x.xR[i] == bndu.xR[i]);
         }
         for (i = 0; i < n; i++) {
            c.xR[i] = hqrndnormal(&rs);
            v0 = hqrndnormal(&rs);
            v1 = hqrndnormal(&rs);
            bndl.xR[i] = rmin2(v0, v1);
            bndu.xR[i] = rmax2(v0, v1);
            if (c.xR[i] > 0.0) {
               bndu.xR[i] = +INFINITY;
            }
            if (c.xR[i] < 0.0) {
               bndl.xR[i] = -INFINITY;
            }
         }
         testminlpunit_shiftfromzero(&c, n, 0.01);
         minlpcreate(n, &state);
         testminlpunit_selectsolver(&state, solvertype);
         minlpsetcost(&state, &c);
         minlpsetbc(&state, &bndl, &bndu);
         minlpoptimize(&state);
         minlpresults(&state, &x, &rep);
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && x.cnt >= n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && (c.xR[i] <= 0.0 || x.xR[i] >= bndl.xR[i] && x.xR[i] <= bndl.xR[i] + primtol);
            Ok = Ok && (c.xR[i] >= 0.0 || x.xR[i] <= bndu.xR[i] && x.xR[i] >= bndu.xR[i] - primtol);
            Ok = Ok && (c.xR[i] <= 0.0 || solvertype != 0 || x.xR[i] == bndl.xR[i]);
            Ok = Ok && (c.xR[i] >= 0.0 || solvertype != 0 || x.xR[i] == bndu.xR[i]);
         }
      // Feasible bounded problems with zeros in cost vector
         for (i = 0; i < n; i++) {
            c.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = hqrndnormal(&rs);
            bndu.xR[i] = bndl.xR[i] + hqrnduniformi(&rs, 3);
         }
         testminlpunit_shiftfromzero(&c, n, 0.01);
         k = hqrnduniformi(&rs, n);
         c.xR[k] = 0.0;
         bndl.xR[k] = -INFINITY;
         bndu.xR[k] = +INFINITY;
         minlpcreate(n, &state);
         testminlpunit_selectsolver(&state, solvertype);
         minlpsetcost(&state, &c);
         minlpsetbc(&state, &bndl, &bndu);
         minlpoptimize(&state);
         minlpresults(&state, &x, &rep);
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && x.cnt >= n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && (c.xR[i] <= 0.0 || x.xR[i] >= bndl.xR[i] && x.xR[i] <= bndl.xR[i] + primtol);
            Ok = Ok && (c.xR[i] >= 0.0 || x.xR[i] <= bndu.xR[i] && x.xR[i] >= bndu.xR[i] - primtol);
            Ok = Ok && (c.xR[i] <= 0.0 || solvertype != 0 || x.xR[i] == bndl.xR[i]);
            Ok = Ok && (c.xR[i] >= 0.0 || solvertype != 0 || x.xR[i] == bndu.xR[i]);
         }
         Ok = Ok && x.xR[k] == 0.0;
         bndl.xR[k] = hqrndnormal(&rs);
         bndu.xR[k] = +INFINITY;
         minlpsetbc(&state, &bndl, &bndu);
         minlpoptimize(&state);
         minlpresults(&state, &x, &rep);
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && x.cnt >= n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && (c.xR[i] <= 0.0 || x.xR[i] >= bndl.xR[i] && x.xR[i] <= bndl.xR[i] + primtol);
            Ok = Ok && (c.xR[i] >= 0.0 || x.xR[i] <= bndu.xR[i] && x.xR[i] >= bndu.xR[i] - primtol);
            Ok = Ok && (c.xR[i] <= 0.0 || solvertype != 0 || x.xR[i] == bndl.xR[i]);
            Ok = Ok && (c.xR[i] >= 0.0 || solvertype != 0 || x.xR[i] == bndu.xR[i]);
         }
         Ok = Ok && x.xR[k] >= bndl.xR[k];
         Ok = Ok && (solvertype != 0 || x.xR[k] == bndl.xR[k]);
         bndl.xR[k] = -INFINITY;
         bndu.xR[k] = hqrndnormal(&rs);
         minlpsetbc(&state, &bndl, &bndu);
         minlpoptimize(&state);
         minlpresults(&state, &x, &rep);
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && x.cnt >= n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && (c.xR[i] <= 0.0 || x.xR[i] >= bndl.xR[i] && x.xR[i] <= bndl.xR[i] + primtol);
            Ok = Ok && (c.xR[i] >= 0.0 || x.xR[i] <= bndu.xR[i] && x.xR[i] >= bndu.xR[i] - primtol);
            Ok = Ok && (c.xR[i] <= 0.0 || solvertype != 0 || x.xR[i] == bndl.xR[i]);
            Ok = Ok && (c.xR[i] >= 0.0 || solvertype != 0 || x.xR[i] == bndu.xR[i]);
         }
         Ok = Ok && x.xR[k] <= bndu.xR[k];
         Ok = Ok && (solvertype != 0 || x.xR[k] == bndu.xR[k]);
      // Infeasible problems
         ae_vector_set_length(&x, 0);
         for (i = 0; i < n; i++) {
            c.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = hqrndnormal(&rs);
            bndu.xR[i] = bndl.xR[i] + hqrnduniformi(&rs, 3);
         }
         k = hqrnduniformi(&rs, n);
         bndu.xR[k] = bndl.xR[k] - 1;
         minlpcreate(n, &state);
         testminlpunit_selectsolver(&state, solvertype);
         minlpsetcost(&state, &c);
         minlpsetbc(&state, &bndl, &bndu);
         minlpoptimize(&state);
         minlpresults(&state, &x, &rep);
         Ok = Ok && rep.terminationtype == -3;
         Ok = Ok && x.cnt >= n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Unbounded problems
      //
      // NOTE: we solve it without regularization, because with regularizer any LP problem is bounded
         if (solvertype != 1) {
            ae_vector_set_length(&x, 0);
            for (i = 0; i < n; i++) {
               do {
                  c.xR[i] = hqrndnormal(&rs);
               } while (c.xR[i] == 0.0);
               bndl.xR[i] = hqrndnormal(&rs);
               bndu.xR[i] = bndl.xR[i] + hqrnduniformi(&rs, 3);
            }
            k = hqrnduniformi(&rs, n);
            if (c.xR[k] > 0.0) {
               bndl.xR[k] = -INFINITY;
            } else {
               bndu.xR[k] = +INFINITY;
            }
            minlpcreate(n, &state);
            testminlpunit_selectsolver(&state, solvertype);
            minlpsetcost(&state, &c);
            minlpsetbc(&state, &bndl, &bndu);
            minlpoptimize(&state);
            minlpresults(&state, &x, &rep);
            Ok = Ok && rep.terminationtype == -4;
            Ok = Ok && x.cnt >= n;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
// Test linearly constrained problems with all variables being boxed ones
// and with all linear constraints being inequality ones satisfied in the
// box internals.
   for (n = 1; n <= 10; n++) {
      solvertype = hqrnduniformi(&rs, testminlpunit_solverscount);
      ccnt = 1 + hqrnduniformi(&rs, 10);
      ae_vector_set_length(&c, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_matrix_set_length(&a, ccnt, n);
      ae_vector_set_length(&al, ccnt);
      ae_vector_set_length(&au, ccnt);
      for (i = 0; i < n; i++) {
         c.xR[i] = hqrndnormal(&rs);
         bndl.xR[i] = -0.5 - 0.5 * hqrnduniformr(&rs);
         bndu.xR[i] = +0.5 + 0.5 * hqrnduniformr(&rs);
      }
      testminlpunit_shiftfromzero(&c, n, 0.01);
      for (i = 0; i < ccnt; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndmiduniformr(&rs);
         }
         al.xR[i] = (double)(-2 * n);
         au.xR[i] = (double)(+2 * n);
      }
      minlpcreate(n, &state);
      testminlpunit_selectsolver(&state, solvertype);
      minlpsetcost(&state, &c);
      minlpsetbc(&state, &bndl, &bndu);
      minlpsetlc2dense(&state, &a, &al, &au, ccnt);
      minlpoptimize(&state);
      minlpresults(&state, &x, &rep);
      Ok = Ok && rep.terminationtype > 0;
      Ok = Ok && x.cnt >= n;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && (c.xR[i] <= 0.0 || x.xR[i] >= bndl.xR[i] && x.xR[i] <= bndl.xR[i] + primtol);
         Ok = Ok && (c.xR[i] >= 0.0 || x.xR[i] <= bndu.xR[i] && x.xR[i] >= bndu.xR[i] - primtol);
         Ok = Ok && (c.xR[i] <= 0.0 || solvertype != 0 || x.xR[i] == bndl.xR[i]);
         Ok = Ok && (c.xR[i] >= 0.0 || solvertype != 0 || x.xR[i] == bndu.xR[i]);
      }
   }
// Test linearly constrained problems with all variables being boxed ones
// and with random linear constraints, with at least one feasible point
// in the box internals.
   for (n = 1; n <= 10; n++) {
      solvertype = hqrnduniformi(&rs, testminlpunit_solverscount);
      ccnt = 1 + hqrnduniformi(&rs, 10);
      ae_vector_set_length(&c, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_matrix_set_length(&a, ccnt, n);
      ae_vector_set_length(&al, ccnt);
      ae_vector_set_length(&au, ccnt);
      for (i = 0; i < n; i++) {
         c.xR[i] = hqrndnormal(&rs);
         bndl.xR[i] = -0.5 - 0.5 * hqrnduniformr(&rs);
         bndu.xR[i] = +0.5 + 0.5 * hqrnduniformr(&rs);
         x0.xR[i] = 0.5 * (bndl.xR[i] + bndu.xR[i]);
      }
      for (i = 0; i < ccnt; i++) {
         v0 = 0.0;
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
            v0 += a.xyR[i][j] * x0.xR[j];
         }
         al.xR[i] = v0 - 0.25 * hqrnduniformr(&rs);
         au.xR[i] = v0 + 0.25 * hqrnduniformr(&rs);
      }
      minlpcreate(n, &state);
      testminlpunit_selectsolver(&state, solvertype);
      minlpsetcost(&state, &c);
      minlpsetbc(&state, &bndl, &bndu);
      minlpsetlc2dense(&state, &a, &al, &au, ccnt);
      minlpoptimize(&state);
      minlpresults(&state, &x, &rep);
      Ok = Ok && rep.terminationtype > 0;
      Ok = Ok && x.cnt == n;
      Ok = Ok && rep.y.cnt == ccnt;
      Ok = Ok && rep.stats.cnt == n + ccnt;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      testminlpunit_validatesolution(&c, &bndl, &bndu, n, &a, &al, &au, ccnt, &x, &rep, solvertype, &v0, &v1, &errslack);
      Ok = Ok && SmallAtR(v0, primtol);
      Ok = Ok && SmallAtR(v1, dualtol);
      Ok = Ok && SmallAtR(errslack, slacktol);
   }
   ae_frame_leave();
   return Ok;
}

// This function generates random C[] and A[] as well as feasible point XX[N+M],
// with XX[0..N-1] being structural variables and XX[N..N+M-1] being values
// of logical variables.
//
// It also splits structural/logical variables into basic/nonbasic  ones  and
// generates BasicNonbasic[] array, with indexes of basic variables being stored in
// first M positions, and indexes of non-basic variables being stored in the
// next N positions.
static void testminlpunit_generatecabxd(hqrndstate *rs, ae_int_t n, ae_int_t m, RVector *c, RMatrix *a, RVector *xx, RVector *d, ZVector *basicnonbasic) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double mincoeff;
   ae_frame_make(&_frame_block);
   SetVector(c);
   SetMatrix(a);
   SetVector(xx);
   SetVector(d);
   SetVector(basicnonbasic);
   NewVector(y, 0, DT_REAL);
   NewVector(cx, 0, DT_REAL);
   NewMatrix(ax, 0, 0, DT_REAL);
   NewVector(pivots, 0, DT_INT);
   mincoeff = 0.001;
// Randomly partition columns into basic and nonbasic ones
   ae_vector_set_length(basicnonbasic, n + m);
   for (i = 0; i < n + m; i++) {
      basicnonbasic->xZ[i] = i;
   }
   for (i = 0; i < m; i++) {
      k = i + hqrnduniformi(rs, n + m - i);
      swapi(&basicnonbasic->xZ[i], &basicnonbasic->xZ[k]);
   }
// Generate constraint matrix A
   ae_matrix_set_length(a, m, n);
   ae_matrix_set_length(&ax, m, n + m);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         ax.xyR[i][j] = hqrndnormal(rs);
         ax.xyR[i][j] += sign(ax.xyR[i][j]) * mincoeff;
         a->xyR[i][j] = ax.xyR[i][j];
      }
      for (j = 0; j < m; j++) {
         ax.xyR[i][n + j] = 0.0;
      }
      ax.xyR[i][n + i] = -1.0;
   }
// Generate feasible point
   ae_vector_set_length(xx, n + m);
   for (i = 0; i < n; i++) {
      xx->xR[i] = hqrndnormal(rs);
   }
   for (i = n; i < n + m; i++) {
      xx->xR[i] = 0.0;
   }
   for (i = 0; i < m; i++) {
      v = 0.0;
      for (j = 0; j < n; j++) {
         v += xx->xR[j] * ax.xyR[i][j];
      }
      xx->xR[n + i] = v;
   }
// Generate random Y.
// Entries corresponding to basic constraints must be zero.
   ae_vector_set_length(&y, m);
   for (i = 0; i < m; i++) {
      y.xR[i] = hqrndnormal(rs);
   }
   for (i = 0; i < m; i++) {
      if (basicnonbasic->xZ[i] >= n) {
         y.xR[basicnonbasic->xZ[i] - n] = 0.0;
      }
   }
// Generate D and C
   ae_vector_set_length(d, n + m);
   rmatrixgemv(n + m, m, -1.0, &ax, 0, 0, 1, &y, 0, 0.0, d, 0);
   ae_vector_set_length(&cx, n + m);
   for (i = 0; i < n; i++) {
      cx.xR[i] = hqrndnormal(rs);
   }
   for (i = n; i < n + m; i++) {
      cx.xR[i] = 0.0;
   }
   for (i = 0; i < m; i++) {
      cx.xR[basicnonbasic->xZ[i]] = -d->xR[basicnonbasic->xZ[i]];
   }
   raddv(n + m, 1.0, &cx, d);
   ae_vector_set_length(c, n);
   rcopyv(n, &cx, c);
   ae_frame_leave();
}

// This function generates random non-degenerate bounds for given XX and D.
static void testminlpunit_generatebounds(hqrndstate *rs, ae_int_t n, ae_int_t m, RVector *xx, RVector *d, ZVector *basicnonbasic, RVector *bndl, RVector *bndu, RVector *al, RVector *au) {
   double v0;
   double v1;
   double q;
   ae_int_t i;
   ae_int_t kk;
   SetVector(bndl);
   SetVector(bndu);
   SetVector(al);
   SetVector(au);
   ae_vector_set_length(bndl, n);
   ae_vector_set_length(bndu, n);
   ae_vector_set_length(al, m);
   ae_vector_set_length(au, m);
// Choose bounds in such a way that non-basic variables are
// strictly at the bounds and dual feasible, and all basic
// variables are strictly within bounds.
   q = 5.0;
   for (kk = 0; kk < n + m; kk++) {
      i = basicnonbasic->xZ[kk];
      v0 = xx->xR[i] - pow(q, hqrndnormal(rs));
      v1 = xx->xR[i] + pow(q, hqrndnormal(rs));
      if (hqrndnormal(rs) > 0.0) {
         v0 = -INFINITY;
      }
      if (hqrndnormal(rs) > 0.0) {
         v1 = +INFINITY;
      }
      if (kk >= m) {
         if (d->xR[i] >= 0.0) {
            v0 = xx->xR[i];
            if (hqrnduniformr(rs) < 0.05) {
               v1 = v0;
            }
         } else {
            v1 = xx->xR[i];
            if (hqrnduniformr(rs) < 0.05) {
               v0 = v1;
            }
         }
      }
      if (i < n) {
         bndl->xR[i] = v0;
         bndu->xR[i] = v1;
      } else {
         al->xR[i - n] = v0;
         au->xR[i - n] = v1;
      }
   }
}

// This function generates random LP problem with  user-specified  number  of
// variables, with several problem types being randomly chosen internally.
//
// Constraint counts and types are generated randomly; it  is  possible  that
// zero amount of constraints is generated.
static void testminlpunit_generatelpproblem(hqrndstate *rs, ae_int_t n, RVector *c, RVector *bndl, RVector *bndu, RMatrix *a, RVector *al, RVector *au, ae_int_t *m) {
   ae_frame _frame_block;
   ae_int_t ptype;
   ae_int_t pcount;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t kk;
   ae_int_t kt;
   double v;
   double q;
   double big;
   double mincoeff;
   ae_int_t nprimal;
   ae_int_t ndual;
   ae_frame_make(&_frame_block);
   SetVector(c);
   SetVector(bndl);
   SetVector(bndu);
   SetMatrix(a);
   SetVector(al);
   SetVector(au);
   *m = 0;
   NewVector(x0, 0, DT_REAL);
   NewVector(xx, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(basicnonbasic, 0, DT_INT);
   ae_vector_set_length(&x0, n);
   ae_vector_set_length(c, n);
   ae_vector_set_length(bndl, n);
   ae_vector_set_length(bndu, n);
// Choose problem type
   pcount = 4;
   ptype = hqrnduniformi(rs, pcount);
   mincoeff = 0.001;
// A linearly constrained LP problem with all variables/linear constraints
// being boxed (easy start).
   if (ptype == 0) {
      q = 5.0;
      *m = 1 + hqrnduniformi(rs, 2 * n);
      ae_matrix_set_length(a, *m, n);
      ae_vector_set_length(al, *m);
      ae_vector_set_length(au, *m);
      for (i = 0; i < n; i++) {
         c->xR[i] = hqrndnormal(rs);
         bndl->xR[i] = pow(q, hqrndnormal(rs)) - pow(q, hqrndnormal(rs));
         bndu->xR[i] = bndl->xR[i] + pow(q, hqrndnormal(rs));
         v = 0.01 + 0.98 * hqrnduniformr(rs);
         x0.xR[i] = (1 - v) * bndl->xR[i] + v * bndu->xR[i];
      }
      for (i = 0; i < *m; i++) {
         v = 0.0;
         for (j = 0; j < n; j++) {
            a->xyR[i][j] = hqrndnormal(rs) * hqrnduniformi(rs, 2);
            a->xyR[i][j] += sign(a->xyR[i][j]) * mincoeff;
            v += a->xyR[i][j] * x0.xR[j];
         }
         al->xR[i] = v - pow(q, hqrndnormal(rs));
         au->xR[i] = v + pow(q, hqrndnormal(rs));
      }
      ae_frame_leave();
      return;
   }
// A linearly constrained LP problem with up to M variables (linear
// constraints) being non-boxed (free or having just one constraint).
// A bit harder than all-boxed version.
//
// NOTE: components of C[] corresponding to these non-boxed variables
//       are chosen in a way which guarantees dual feasibility of the
//       problem.
   if (ptype == 1) {
      q = 2.0;
      big = 100.00;
      *m = 1 + hqrnduniformi(rs, 2 * n);
      ae_matrix_set_length(a, *m, n);
      ae_vector_set_length(al, *m);
      ae_vector_set_length(au, *m);
      for (i = 0; i < n; i++) {
         c->xR[i] = hqrndnormal(rs);
         bndl->xR[i] = pow(q, hqrndnormal(rs)) - pow(q, hqrndnormal(rs));
         bndu->xR[i] = bndl->xR[i] + pow(q, hqrndnormal(rs));
         v = 0.01 + 0.98 * hqrnduniformr(rs);
         x0.xR[i] = (1 - v) * bndl->xR[i] + v * bndu->xR[i];
      }
      for (i = 0; i < *m; i++) {
         v = 0.0;
         for (j = 0; j < n; j++) {
            a->xyR[i][j] = hqrndnormal(rs);
            a->xyR[i][j] += sign(a->xyR[i][j]) * mincoeff;
            v += a->xyR[i][j] * x0.xR[j];
         }
         al->xR[i] = v - pow(q, hqrndnormal(rs));
         au->xR[i] = v + pow(q, hqrndnormal(rs));
      }
      kk = 1 + hqrnduniformi(rs, *m);
      for (k = 0; k < kk; k++) {
         i = hqrnduniformi(rs, n + (*m));
         if (i < n) {
            kt = hqrnduniformi(rs, 3);
            if (kt == 0) {
               bndl->xR[i] = -INFINITY;
               c->xR[i] = -big * (1.0 + hqrnduniformr(rs));
            }
            if (kt == 1) {
               bndu->xR[i] = +INFINITY;
               c->xR[i] = +big * (1.0 + hqrnduniformr(rs));
            }
            if (kt == 2) {
               bndl->xR[i] = -INFINITY;
               bndu->xR[i] = +INFINITY;
            }
         } else {
            kt = hqrnduniformi(rs, 3);
            if (kt == 0) {
               au->xR[i - n] = +INFINITY;
            }
            if (kt == 1) {
               al->xR[i - n] = -INFINITY;
            }
            if (kt == 2) {
               al->xR[i - n] = -INFINITY;
               au->xR[i - n] = +INFINITY;
            }
         }
      }
      ae_frame_leave();
      return;
   }
// A randomly generated non-degenerate LP problem. A mix of fixed,
// range, upper/lower bounds and free variables.
   if (ptype == 2) {
      *m = 1 + hqrnduniformi(rs, 2 * n);
      testminlpunit_generatecabxd(rs, n, *m, c, a, &xx, &d, &basicnonbasic);
      testminlpunit_generatebounds(rs, n, *m, &xx, &d, &basicnonbasic, bndl, bndu, al, au);
      ae_frame_leave();
      return;
   }
// A randomly generated primal/dual degenerate LP problem. A mix of
// fixed, range, upper/lower bounds and free variables.
   if (ptype == 3) {
      *m = 1 + hqrnduniformi(rs, 2 * n);
      testminlpunit_generatecabxd(rs, n, *m, c, a, &xx, &d, &basicnonbasic);
      testminlpunit_generatebounds(rs, n, *m, &xx, &d, &basicnonbasic, bndl, bndu, al, au);
      ndual = 1 + hqrnduniformi(rs, *m);
      for (i = 0; i < ndual; i++) {
         j = basicnonbasic.xZ[*m + hqrnduniformi(rs, n)];
         if (j < n) {
            c->xR[j] -= d.xR[j];
            d.xR[j] = 0.0;
         }
      }
      nprimal = 1 + hqrnduniformi(rs, *m);
      for (i = 0; i < nprimal; i++) {
         j = basicnonbasic.xZ[hqrnduniformi(rs, *m)];
         if (j < n) {
            if (hqrndnormal(rs) > 0.0) {
               bndl->xR[j] = xx.xR[j];
            } else {
               bndu->xR[j] = xx.xR[j];
            }
         } else {
            if (hqrndnormal(rs) > 0.0) {
               al->xR[j - n] = xx.xR[j];
            } else {
               au->xR[j - n] = xx.xR[j];
            }
         }
      }
      ae_frame_leave();
      return;
   }
   ae_assert(false, "GenerateLPProblem failed");
   ae_frame_leave();
}

// This function generates random primal unbounded LP problem.
static void testminlpunit_generateunboundedlpproblem(hqrndstate *rs, ae_int_t n, RVector *c, RVector *bndl, RVector *bndu, RMatrix *a, RVector *al, RVector *au, ae_int_t *m) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ptype;
   ae_int_t pcount;
   double v;
   double vv;
   double q;
   ae_frame_make(&_frame_block);
   SetVector(c);
   SetVector(bndl);
   SetVector(bndu);
   SetMatrix(a);
   SetVector(al);
   SetVector(au);
   *m = 0;
   NewVector(x0, 0, DT_REAL);
   ae_vector_set_length(c, n);
   ae_vector_set_length(bndl, n);
   ae_vector_set_length(bndu, n);
// Choose problem type
   pcount = 2;
   ptype = hqrnduniformi(rs, pcount);
// Boundary-only constraints, can be easily made primal unbounded
   if (ptype == 0) {
      q = 5.0;
      *m = 0;
      ae_matrix_set_length(a, 0, 0);
      ae_vector_set_length(al, 0);
      ae_vector_set_length(au, 0);
      for (i = 0; i < n; i++) {
         c->xR[i] = hqrndnormal(rs);
         v = pow(q, hqrndnormal(rs)) - pow(q, hqrndnormal(rs));
         if (c->xR[i] > 0.0) {
            bndl->xR[i] = v;
            bndu->xR[i] = +INFINITY;
         } else {
            bndl->xR[i] = -INFINITY;
            bndu->xR[i] = v;
         }
      }
      i = hqrnduniformi(rs, n);
      do {
         c->xR[i] = hqrndnormal(rs);
      } while (c->xR[i] == 0.0);
      c->xR[i] += 0.1 * sign(c->xR[i]);
      v = pow(q, hqrndnormal(rs)) - pow(q, hqrndnormal(rs));
      if (c->xR[i] < 0.0) {
         bndl->xR[i] = v;
         bndu->xR[i] = +INFINITY;
      } else {
         bndl->xR[i] = -INFINITY;
         bndu->xR[i] = v;
      }
      ae_frame_leave();
      return;
   }
// Boundary and single-sided linear constraints; a bit more tricky to make it primal unbounded
   if (ptype == 1) {
      q = 5.0;
      *m = 1 + hqrnduniformi(rs, 2 * n);
      ae_matrix_set_length(a, *m, n);
      ae_vector_set_length(al, *m);
      ae_vector_set_length(au, *m);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         c->xR[i] = hqrndnormal(rs);
         x0.xR[i] = hqrndnormal(rs);
         if (c->xR[i] >= 0.0) {
            bndl->xR[i] = -INFINITY;
            bndu->xR[i] = x0.xR[i];
         } else {
            bndl->xR[i] = x0.xR[i];
            bndu->xR[i] = +INFINITY;
         }
      }
      for (i = 0; i < *m; i++) {
         v = 0.0;
         vv = 0.0;
         for (j = 0; j < n; j++) {
            a->xyR[i][j] = hqrndnormal(rs);
            v += a->xyR[i][j] * x0.xR[j];
            vv += a->xyR[i][j] * c->xR[j];
         }
         if (vv >= 0.0) {
            al->xR[i] = -INFINITY;
            au->xR[i] = v;
         } else {
            al->xR[i] = v;
            au->xR[i] = +INFINITY;
         }
      }
      ae_frame_leave();
      return;
   }
   ae_assert(false, "GenerateUnboundedLPProblem failed");
   ae_frame_leave();
}

// This function generates random primal infeasible LP problem
static void testminlpunit_generateinfeasiblelpproblem(hqrndstate *rs, ae_int_t n, RVector *c, RVector *bndl, RVector *bndu, RMatrix *a, RVector *al, RVector *au, ae_int_t *m) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t ptype;
   ae_int_t pcount;
   double v;
   double q;
   double minerr;
   ae_frame_make(&_frame_block);
   SetVector(c);
   SetVector(bndl);
   SetVector(bndu);
   SetMatrix(a);
   SetVector(al);
   SetVector(au);
   *m = 0;
   NewVector(xx, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(tmpi, 0, DT_INT);
   ae_vector_set_length(c, n);
   ae_vector_set_length(bndl, n);
   ae_vector_set_length(bndu, n);
// Choose problem type
   pcount = 3;
   ptype = hqrnduniformi(rs, pcount);
// Boundary-only constraints, can be easily made primal infeasible
   if (ptype == 0) {
      q = 5.0;
      *m = 0;
      ae_matrix_set_length(a, 0, 0);
      ae_vector_set_length(al, 0);
      ae_vector_set_length(au, 0);
      for (i = 0; i < n; i++) {
         c->xR[i] = hqrndnormal(rs);
         v = pow(q, hqrndnormal(rs)) - pow(q, hqrndnormal(rs));
         bndl->xR[i] = v - pow(q, hqrndnormal(rs));
         bndu->xR[i] = v + pow(q, hqrndnormal(rs));
      }
      i = hqrnduniformi(rs, n);
      swapr(&bndl->xR[i], &bndu->xR[i]);
      ae_frame_leave();
      return;
   }
// Linearly constrained problem with infeasible box constraints
   if (ptype == 1) {
      q = 5.0;
      *m = 1 + hqrnduniformi(rs, 2 * n);
      testminlpunit_generatecabxd(rs, n, *m, c, a, &xx, &d, &tmpi);
      testminlpunit_generatebounds(rs, n, *m, &xx, &d, &tmpi, bndl, bndu, al, au);
      i = hqrnduniformi(rs, n);
      v = pow(q, hqrndnormal(rs)) - pow(q, hqrndnormal(rs));
      bndl->xR[i] = v + pow(q, hqrndnormal(rs));
      bndu->xR[i] = v - pow(q, hqrndnormal(rs));
      ae_frame_leave();
      return;
   }
// Linearly constrained problem with infeasible linear constraints
   if (ptype == 2) {
      q = 5.0;
      minerr = 0.01;
      *m = 1 + hqrnduniformi(rs, 2 * n);
      testminlpunit_generatecabxd(rs, n, *m, c, a, &xx, &d, &tmpi);
      testminlpunit_generatebounds(rs, n, *m, &xx, &d, &tmpi, bndl, bndu, al, au);
      rmatrixresize(a, a->rows + 1, a->cols);
      rvectorresize(al, al->cnt + 1);
      rvectorresize(au, au->cnt + 1);
      for (i = 0; i < n; i++) {
         a->xyR[*m][i] = a->xyR[*m - 1][i];
      }
      v = minerr + pow(q, hqrndnormal(rs));
      v *= rmax2(1.0, sqrt(rdotrr(n, a, *m, a, *m)));
      if (isfinite(al->xR[*m - 1]) && isfinite(au->xR[*m - 1])) {
         al->xR[*m] = au->xR[*m - 1] + v;
         au->xR[*m] = al->xR[*m] + pow(q, hqrndnormal(rs));
      }
      if (isfinite(al->xR[*m - 1]) && !isfinite(au->xR[*m - 1])) {
         au->xR[*m] = al->xR[*m - 1] - v;
         al->xR[*m] = au->xR[*m] - pow(q, hqrndnormal(rs));
      }
      if (!isfinite(al->xR[*m - 1]) && isfinite(au->xR[*m - 1])) {
         al->xR[*m] = au->xR[*m - 1] + v;
         au->xR[*m] = al->xR[*m] + pow(q, hqrndnormal(rs));
      }
      if (!isfinite(al->xR[*m - 1]) && !isfinite(au->xR[*m - 1])) {
         al->xR[*m] = v;
         au->xR[*m] = v - pow(q, hqrndnormal(rs));
      }
      ++*m;
      ae_frame_leave();
      return;
   }
   ae_assert(false, "GenerateUnboundedLPProblem failed");
   ae_frame_leave();
}

// This function sets linear constraints using randomly  chosen  sequence  of
// SetLC/AddLC calls.
//
// It may also modify constraints:
// * split two-sided constraint into two one-sided constraints
// * create duplicates
// * insert zero dummies
//
// Thus, you should not use this function when you want to test  things  like
// correctness of Lagrange multipliers and so on.
static void testminlpunit_modifyandsendconstraintsto(ae_int_t n, RMatrix *a, RVector *al, RVector *au, ae_int_t m, hqrndstate *rs, minlpstate *state) {
   ae_frame _frame_block;
   ae_int_t stype;
   ae_int_t nz;
   ae_int_t nzmod;
   ae_int_t ccnt;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t minit;
   ae_int_t nadd;
   ae_int_t ndup;
   double v;
   ae_frame_make(&_frame_block);
   NewVector(ai, 0, DT_REAL);
   NewVector(idxi, 0, DT_INT);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewVector(ct, 0, DT_INT);
// Choose sequence type
   stype = hqrnduniformi(rs, 4);
// Straightforward SetLC2() call
   if (stype == 0) {
      minlpsetlc2dense(state, a, al, au, m);
      ae_frame_leave();
      return;
   }
// SetLC1() call (conversion to other format)
   if (stype == 1) {
      ae_matrix_set_length(&a1, 2 * m, n + 1);
      ae_vector_set_length(&ct, 2 * m);
      ccnt = 0;
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            a1.xyR[ccnt][j] = a->xyR[i][j];
            a1.xyR[ccnt + 1][j] = a->xyR[i][j];
         }
         if (isfinite(al->xR[i]) && isfinite(au->xR[i]) && al->xR[i] == au->xR[i]) {
            a1.xyR[ccnt][n] = al->xR[i];
            ct.xZ[ccnt] = 0;
            ccnt++;
         } else {
            if (isfinite(al->xR[i])) {
               a1.xyR[ccnt][n] = al->xR[i];
               ct.xZ[ccnt] = 1;
               ccnt++;
            }
            if (isfinite(au->xR[i])) {
               a1.xyR[ccnt][n] = au->xR[i];
               ct.xZ[ccnt] = -1;
               ccnt++;
            }
         }
      }
      minlpsetlc(state, &a1, &ct, ccnt);
      ae_frame_leave();
      return;
   }
// Straightforward SetLC2Sparse() call
   if (stype == 2) {
      if (m == 0) {
         minlpsetlc2(state, &sa, al, au, 0);
         ae_frame_leave();
         return;
      }
      sparsecreate(m, n, 0, &sa);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            if (a->xyR[i][j] != 0.0) {
               sparseset(&sa, i, j, a->xyR[i][j]);
            }
         }
      }
      if (hqrndnormal(rs) > 0.0) {
         sparseconverttocrs(&sa);
      }
      minlpsetlc2(state, &sa, al, au, m);
      ae_frame_leave();
      return;
   }
// A few rows are added with SetLC2Dense() call, the rest
// is processed with random mix of AddLC2Dense()/AddLC2()
   if (stype == 3) {
      if (m == 0) {
         minlpsetlc2(state, &sa, al, au, 0);
         ae_frame_leave();
         return;
      }
      minit = hqrnduniformi(rs, m);
      minlpsetlc2dense(state, a, al, au, minit);
      for (i = minit; i < m; i++) {
         if (hqrnduniformi(rs, 2) == 0) {
         // Add as dense row
            ae_vector_set_length(&ai, n);
            for (j = 0; j < n; j++) {
               ai.xR[j] = a->xyR[i][j];
            }
            minlpaddlc2dense(state, &ai, al->xR[i], au->xR[i]);
         } else {
         // Add as sparse row with shuffle and possible duplicates
            ae_vector_set_length(&ai, n);
            ae_vector_set_length(&idxi, n);
            nz = 0;
            for (j = 0; j < n; j++) {
               if (a->xyR[i][j] != 0.0) {
                  ai.xR[nz] = a->xyR[i][j];
                  idxi.xZ[nz] = j;
                  nz++;
               }
            }
            rvectorresize(&ai, nz);
            ivectorresize(&idxi, nz);
         // Already existing elements are split in two
            nadd = 0;
            if (nz != 0) {
               nadd = hqrnduniformi(rs, 2) * hqrnduniformi(rs, 4);
               rvectorresize(&ai, nz + nadd);
               ivectorresize(&idxi, nz + nadd);
               for (j = 0; j < nadd; j++) {
                  k = hqrnduniformi(rs, nz);
                  v = hqrndnormal(rs);
                  idxi.xZ[nz + j] = idxi.xZ[k];
                  ai.xR[nz + j] = v;
                  ai.xR[k] -= v;
               }
            }
         // Possibly nonexistent elements are added as +V and -V
         // Do not performed for NZ == 0 rows because it may introduce slightly nonzero coefficients
         // to exactly zero row (constraint normalization goes crazy).
            ndup = hqrnduniformi(rs, 2) * hqrnduniformi(rs, 4);
            if (nz == 0) {
               ndup = 0;
            }
            rvectorresize(&ai, nz + nadd + 2 * ndup);
            ivectorresize(&idxi, nz + nadd + 2 * ndup);
            for (j = 0; j < ndup; j++) {
               k = hqrnduniformi(rs, n);
               v = hqrndnormal(rs);
               idxi.xZ[nz + nadd + 2 * j] = k;
               idxi.xZ[nz + nadd + 2 * j + 1] = k;
               ai.xR[nz + nadd + 2 * j] = v;
               ai.xR[nz + nadd + 2 * j + 1] = -v;
            }
            nzmod = nz + nadd + 2 * ndup;
            for (j = 0; j < nzmod; j++) {
               k = j + hqrnduniformi(rs, nzmod - j);
               swapi(&idxi.xZ[j], &idxi.xZ[k]);
               swapr(&ai.xR[j], &ai.xR[k]);
            }
            minlpaddlc2(state, &idxi, &ai, nzmod, al->xR[i], au->xR[i]);
         }
      }
      ae_frame_leave();
      return;
   }
   ae_assert(false, "MINLPTest: integrity check failed");
   ae_frame_leave();
}

// Single-call tests.
static bool testminlpunit_singlecalltests() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t m;
   ae_int_t n0;
   double v0;
   double v1;
   double primtol;
   double dualtol;
   double slacktol;
   double etol;
   double ftol;
   double f;
   double f1;
   double errp;
   double errd;
   double errs;
   double alpha;
   ae_int_t solvertype;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(minlpstate, state0);
   NewObj(minlpreport, rep0);
   NewObj(minlpstate, state1);
   NewObj(minlpreport, rep1);
   NewVector(c, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(al, 0, DT_REAL);
   NewVector(au, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(bndls, 0, DT_REAL);
   NewVector(bndus, 0, DT_REAL);
   NewVector(cs, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   primtol = 1.0E-3;
   dualtol = 1.0E-3;
   slacktol = 1.0E-3;
   etol = 1.0E-8;
   ftol = 1.0E-3;
   hqrndrandomize(&rs);
// Try different feasible problems
   for (n = 1; n <= 50; n++) {
      for (pass = 1; pass <= 30; pass++) {
         solvertype = hqrnduniformi(&rs, testminlpunit_solverscount);
      // Generate random feasible problem and solve it using basic MinLPSetLC2Dense() API
         testminlpunit_generatelpproblem(&rs, n, &c, &bndl, &bndu, &a, &al, &au, &m);
         minlpcreate(n, &state0);
         testminlpunit_selectsolver(&state0, solvertype);
         minlpsetcost(&state0, &c);
         minlpsetbc(&state0, &bndl, &bndu);
         minlpsetlc2dense(&state0, &a, &al, &au, m);
         minlpoptimize(&state0);
         minlpresults(&state0, &x0, &rep0);
         Ok = Ok && rep0.terminationtype > 0;
         Ok = Ok && x0.cnt == n && isfinitevector(&x0, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         testminlpunit_validatesolution(&c, &bndl, &bndu, n, &a, &al, &au, m, &x0, &rep0, solvertype, &errp, &errd, &errs);
         Ok = Ok && SmallAtR(errp, primtol);
         Ok = Ok && SmallAtR(errd, dualtol);
         Ok = Ok && SmallAtR(errs, slacktol);
         Ok = Ok && NearAtR(errp, rep0.primalerror, etol * rmax2(errp, 1.0));
         Ok = Ok && NearAtR(errd, rep0.dualerror, etol * rmax2(errd, 1.0));
         Ok = Ok && NearAtR(errs, rep0.slackerror, etol * rmax2(errs, 1.0));
      // Apply random modification to the problem (and to the way
      // we pass constraints to the solver), try solving one more time
      // and compare with the original solution.
      //
      // NOTE: because our test suite has degenerate problems, we do
      //       not compare points returned - only target values are
      //       compared.
         ae_vector_set_length(&x1, 0);
         minlpcreate(n, &state1);
         testminlpunit_selectsolver(&state1, solvertype);
         minlpsetcost(&state1, &c);
         minlpsetbc(&state1, &bndl, &bndu);
         testminlpunit_modifyandsendconstraintsto(n, &a, &al, &au, m, &rs, &state1);
         minlpoptimize(&state1);
         minlpresults(&state1, &x1, &rep1);
         Ok = Ok && rep1.terminationtype > 0;
         Ok = Ok && x1.cnt == n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         f = 0.0;
         f1 = 0.0;
         for (i = 0; i < n; i++) {
            f += x0.xR[i] * c.xR[i];
            f1 += x1.xR[i] * c.xR[i];
         }
         Ok = Ok && NearAtR(f1, f, ftol);
      // Test scaling (random scale is applied, target values for
      // original and scaled problems are compared).
      //
      // NOTE: because our test suite has degenerate problems, we do
      //       not compare points returned - only target values.
         ae_vector_set_length(&x1, 0);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&cs, n);
         ae_vector_set_length(&bndls, n);
         ae_vector_set_length(&bndus, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(2.0, (double)(hqrnduniformi(&rs, 21) - 10));
            cs.xR[i] = c.xR[i] / s.xR[i];
            bndls.xR[i] = bndl.xR[i] * s.xR[i];
            bndus.xR[i] = bndu.xR[i] * s.xR[i];
         }
         ae_matrix_set_length(&a1, m, n);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               a1.xyR[i][j] = a.xyR[i][j] / s.xR[j];
            }
         }
         minlpcreate(n, &state1);
         testminlpunit_selectsolver(&state1, solvertype);
         minlpsetscale(&state1, &s);
         minlpsetcost(&state1, &cs);
         minlpsetbc(&state1, &bndls, &bndus);
         minlpsetlc2dense(&state1, &a1, &al, &au, m);
         minlpoptimize(&state1);
         minlpresults(&state1, &x1, &rep1);
         Ok = Ok && rep1.terminationtype > 0;
         Ok = Ok && x1.cnt == n;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(x0.xR[i], x1.xR[i] / s.xR[i], 1000.0 * machineepsilon);
         }
      }
   }
// Test infeasible/unbounded problems
   for (n = 1; n <= 50; n++) {
      for (pass = 1; pass <= 30; pass++) {
         solvertype = hqrnduniformi(&rs, testminlpunit_solverscount);
      // Generate random primal unbounded
      //
      // NOTE: because we use constraint validation code, we can not
      //       use ModifyAndSendConstraintsTo() function - it permutes
      //       constraints order and prevents correct validation.
         ae_vector_set_length(&x0, 0);
         testminlpunit_generateunboundedlpproblem(&rs, n, &c, &bndl, &bndu, &a, &al, &au, &m);
         minlpcreate(n, &state0);
         testminlpunit_selectsolver(&state0, solvertype);
         minlpsetcost(&state0, &c);
         minlpsetbc(&state0, &bndl, &bndu);
         minlpsetlc2dense(&state0, &a, &al, &au, m);
         minlpoptimize(&state0);
         minlpresults(&state0, &x0, &rep0);
         Ok = Ok && (rep0.terminationtype == -4 || rep0.terminationtype == -2);
         Ok = Ok && x0.cnt == n && isfinitevector(&x0, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         testminlpunit_validatesolution(&c, &bndl, &bndu, n, &a, &al, &au, m, &x0, &rep0, solvertype, &errp, &errd, &errs);
         Ok = Ok && NearAtR(errp, rep0.primalerror, etol * rmax2(errp, 1.0));
         Ok = Ok && NearAtR(errd, rep0.dualerror, etol * rmax2(errd, 1.0));
         Ok = Ok && NearAtR(errs, rep0.slackerror, etol * rmax2(errs, 1.0));
      // Generate random primal infeasible
      //
      // NOTE: because we use constraint validation code, we can not
      //       use ModifyAndSendConstraintsTo() function - it permutes
      //       constraints order and prevents correct validation.
         ae_vector_set_length(&x0, 0);
         testminlpunit_generateinfeasiblelpproblem(&rs, n, &c, &bndl, &bndu, &a, &al, &au, &m);
         minlpcreate(n, &state0);
         testminlpunit_selectsolver(&state0, solvertype);
         minlpsetcost(&state0, &c);
         minlpsetbc(&state0, &bndl, &bndu);
         minlpsetlc2dense(&state0, &a, &al, &au, m);
         minlpoptimize(&state0);
         minlpresults(&state0, &x0, &rep0);
         Ok = Ok && (rep0.terminationtype == -3 || rep0.terminationtype == -2);
         Ok = Ok && x0.cnt == n && isfinitevector(&x0, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         testminlpunit_validatesolution(&c, &bndl, &bndu, n, &a, &al, &au, m, &x0, &rep0, solvertype, &errp, &errd, &errs);
         Ok = Ok && NearAtR(errp, rep0.primalerror, etol * rmax2(rep0.primalerror, 1.0));
         Ok = Ok && NearAtR(errd, rep0.dualerror, etol * rmax2(rep0.dualerror, 1.0));
         Ok = Ok && NearAtR(errs, rep0.slackerror, etol * rmax2(errs, 1.0));
      }
   }
   for (n = 2; n <= 50; n++) {
      for (pass = 1; pass <= 30; pass++) {
         solvertype = hqrnduniformi(&rs, testminlpunit_solverscount); //(@) Was not present in the original: solvertype was left dangling from the previous set of loops.
      // Special test for simplex solver.
      //
      // Generate carefully crafted primal infeasible - the problem is ALMOST feasible.
      // So, we expect simplex solver to stop at the best point possible. We also test
      // that X and Y are correctly unscaled on return.
         ae_assert(n >= 2, "LPTEST: integrity check failed");
         n0 = n / 2;
         ae_assert(n0 < n, "LPTEST: integrity check failed");
         alpha = 0.0001;
         ae_vector_set_length(&x0, 0);
         ae_vector_set_length(&c, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            if (i < n0) {
               c.xR[i] = -pow(2.0, 2.0 * hqrndmiduniformr(&rs));
            } else {
               c.xR[i] = hqrnduniformr(&rs) - 0.5;
            }
            bndl.xR[i] = -pow(2.0, hqrndnormal(&rs));
            bndu.xR[i] = 1.0;
            s.xR[i] = pow(2.0, hqrndmiduniformr(&rs));
         }
         m = 1 + hqrnduniformi(&rs, n);
         ae_matrix_set_length(&a, m, n);
         ae_vector_set_length(&al, m);
         ae_vector_set_length(&au, m);
         for (i = 0; i < m - 1; i++) {
            for (j = 0; j < n0; j++) {
               a.xyR[i][j] = 0.0;
            }
            v0 = 0.0;
            for (j = n0; j < n; j++) {
               a.xyR[i][j] = hqrndnormal(&rs);
               v0 += 0.5 * a.xyR[i][j];
            }
            al.xR[i] = v0 - pow(2.0, hqrndnormal(&rs));
            au.xR[i] = v0 + pow(2.0, hqrndnormal(&rs));
         }
         v0 = 0.0;
         for (i = 0; i < n; i++) {
            if (i < n0) {
               a.xyR[m - 1][i] = pow(2.0, hqrndnormal(&rs));
            } else {
               a.xyR[m - 1][i] = 0.0;
            }
            v0 += a.xyR[m - 1][i];
         }
         al.xR[m - 1] = v0 + alpha;
         au.xR[m - 1] = al.xR[m - 1];
         minlpcreate(n, &state0);
         minlpsetalgodss(&state0, 0.0);
         minlpsetcost(&state0, &c);
         if (hqrndnormal(&rs) > 0.0) {
            minlpsetscale(&state0, &s);
         }
         minlpsetbc(&state0, &bndl, &bndu);
         minlpsetlc2dense(&state0, &a, &al, &au, m);
         minlpoptimize(&state0);
         minlpresults(&state0, &x0, &rep0);
         Ok = Ok && (rep0.terminationtype == -3 || rep0.terminationtype == -2);
         Ok = Ok && x0.cnt == n && isfinitevector(&x0, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n0; i++) {
            Ok = Ok && x0.xR[i] >= 1.0;
         }
         testminlpunit_validatesolution(&c, &bndl, &bndu, n, &a, &al, &au, m, &x0, &rep0, solvertype, &errp, &errd, &errs);
         Ok = Ok && SmallAtR(errd, 0.001);
         Ok = Ok && NearAtR(errp, rep0.primalerror, etol * rmax2(errp, 1.0));
         Ok = Ok && NearAtR(errd, rep0.dualerror, etol * rmax2(errd, 1.0));
         Ok = Ok && NearAtR(errs, rep0.slackerror, etol * rmax2(errs, 1.0));
      }
   }
// Check SetBCAll() and SetBCi()
//
// We generate random problem with box constraints
// L <= x[i] <= U, with L < 0 < U, and random linear constraints
// feasible at x == 0.
//
// In order to test SetBCAll() we solve it two times,
// first one with box constraints specified via setbc(),
// second one with setbcall(). Both solutions are compared.
//
// After that we rewrite box constraints to be different
// for each variable, and send them to the first solver
// via setbc() and to the second one via sequential setbci().
// Both solutions are compared.
   for (n = 1; n <= 30; n++) {
      solvertype = hqrnduniformi(&rs, testminlpunit_solverscount);
      v0 = -pow(2.0, hqrndnormal(&rs));
      v1 = pow(2.0, hqrndnormal(&rs));
      m = hqrnduniformi(&rs, 2 * n);
      ae_vector_set_length(&c, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_matrix_set_length(&a, m, n);
      ae_vector_set_length(&al, m);
      ae_vector_set_length(&au, m);
      for (i = 0; i < n; i++) {
         c.xR[i] = hqrndnormal(&rs);
         bndl.xR[i] = v0;
         bndu.xR[i] = v1;
      }
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrnduniformi(&rs, 2) * hqrndnormal(&rs);
         }
         al.xR[i] = -pow(2.0, hqrndnormal(&rs));
         au.xR[i] = pow(2.0, hqrndnormal(&rs));
      }
   // SetBCAll() vs SetBC()
      ae_vector_set_length(&x0, hqrnduniformi(&rs, 2 * n));
      ae_vector_set_length(&x1, hqrnduniformi(&rs, 2 * n));
      minlpcreate(n, &state0);
      testminlpunit_selectsolver(&state0, solvertype);
      minlpsetcost(&state0, &c);
      minlpsetbc(&state0, &bndl, &bndu);
      minlpsetlc2dense(&state0, &a, &al, &au, m);
      minlpoptimize(&state0);
      minlpresults(&state0, &x0, &rep0);
      Ok = Ok && rep0.terminationtype > 0;
      Ok = Ok && x0.cnt == n;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      minlpcreate(n, &state1);
      testminlpunit_selectsolver(&state1, solvertype);
      minlpsetcost(&state1, &c);
      minlpsetbcall(&state1, v0, v1);
      minlpsetlc2dense(&state1, &a, &al, &au, m);
      minlpoptimize(&state1);
      minlpresults(&state1, &x1, &rep1);
      Ok = Ok && rep1.terminationtype > 0;
      Ok = Ok && x1.cnt == n;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && x0.xR[i] == x1.xR[i];
      }
   // SetBCi() vs SetBC()
      ae_vector_set_length(&x0, hqrnduniformi(&rs, 2 * n));
      ae_vector_set_length(&x1, hqrnduniformi(&rs, 2 * n));
      for (i = 0; i < n; i++) {
         bndl.xR[i] = -pow(2.0, hqrndnormal(&rs));
         bndu.xR[i] = pow(2.0, hqrndnormal(&rs));
         minlpsetbci(&state1, i, bndl.xR[i], bndu.xR[i]);
      }
      minlpsetbc(&state0, &bndl, &bndu);
      minlpoptimize(&state0);
      minlpresults(&state0, &x0, &rep0);
      Ok = Ok && rep0.terminationtype > 0;
      Ok = Ok && x0.cnt == n;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      minlpoptimize(&state1);
      minlpresults(&state1, &x1, &rep1);
      Ok = Ok && rep1.terminationtype > 0;
      Ok = Ok && x1.cnt == n;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && x0.xR[i] == x1.xR[i];
      }
   }
   ae_frame_leave();
   return Ok;
}

bool testminlp() {
   bool basicOk;
   bool singlecallOk;
   bool Ok;
   basicOk = true;
   singlecallOk = true;
   basicOk = basicOk && testminlpunit_basictests();
   singlecallOk = singlecallOk && testminlpunit_singlecalltests();
// The final report.
   Ok = basicOk && singlecallOk;
   if (!Ok || !silent) {
      printf("MinLP Optimization Tests\n");
      printf("Basic Tests:                              %s\n", basicOk? "Ok": "Failed");
      printf("Common Tests:\n");
      printf("* Single Call Usage:                      %s\n", singlecallOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === minnlc testing unit ===
static const ae_int_t testminnlcunit_maxsolvertype = 2;
static const ae_int_t testminnlcunit_maxoptguardlevel = 1;

// This function tests bound constrained quadratic programming algorithm.
static bool testminnlcunit_testbc() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aulits;
   double tolx;
   double tolg;
   ae_int_t scaletype;
   double rho;
   ae_int_t solvertype;
   double gnorm;
   double g;
   ae_int_t prectype;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(minnlcstate, state);
   NewObj(minnlcreport, rep);
   NewObj(optguardreport, ogrep);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   for (solvertype = 0; solvertype <= testminnlcunit_maxsolvertype; solvertype++) {
   // Convex test:
   // * N dimensions
   // * random number (0..N) of random boundary constraints
   // * positive-definite quadratic programming problem
   // * initial point is random (maybe infeasible!)
   // * random scale (unit or non-unit)
      aulits = 10;
      rho = 200.0;
      tolx = 0.0005;
      tolg = 0.01;
      for (n = 1; n <= 10; n++) {
         for (pass = 1; pass <= 10; pass++) {
            for (prectype = 0; prectype <= 2; prectype++) {
            // Generate well-conditioned problem with unit scale
               spdmatrixrndcond(n, 1.0E2, &fulla);
               ae_vector_set_length(&b, n);
               ae_vector_set_length(&bndl, n);
               ae_vector_set_length(&bndu, n);
               ae_vector_set_length(&x0, n);
               for (i = 0; i < n; i++) {
                  b.xR[i] = hqrndnormal(&rs);
                  bndl.xR[i] = -INFINITY;
                  bndu.xR[i] = +INFINITY;
                  x0.xR[i] = hqrndnormal(&rs);
                  j = hqrnduniformi(&rs, 5);
                  if (j == 0) {
                     bndl.xR[i] = 0.0;
                  }
                  if (j == 1) {
                     bndu.xR[i] = 0.0;
                  }
                  if (j == 2) {
                     bndl.xR[i] = hqrndnormal(&rs);
                     bndu.xR[i] = bndl.xR[i];
                  }
                  if (j == 3) {
                     bndl.xR[i] = -0.1;
                     bndu.xR[i] = 0.1;
                  }
               }
            // Apply scaling to quadratic/linear term, so problem becomes
            // well-conditioned in the scaled coordinates.
               scaletype = hqrnduniformi(&rs, 2);
               ae_vector_set_length(&s, n);
               for (i = 0; i < n; i++) {
                  if (scaletype == 0) {
                     s.xR[i] = 1.0;
                  } else {
                     s.xR[i] = exp(5 * hqrndnormal(&rs));
                  }
               }
               for (i = 0; i < n; i++) {
                  x0.xR[i] *= s.xR[i];
                  bndl.xR[i] *= s.xR[i];
                  bndu.xR[i] *= s.xR[i];
                  b.xR[i] /= s.xR[i];
                  for (j = 0; j < n; j++) {
                     fulla.xyR[i][j] /= s.xR[i] * s.xR[j];
                  }
               }
            // Solve problem
               minnlccreate(n, &x0, &state);
               if (solvertype == 0) {
                  minnlcsetalgoaul(&state, rho, aulits);
                  if (prectype == 1) {
                     minnlcsetprecexactlowrank(&state, 0);
                  }
                  if (prectype == 2) {
                     minnlcsetprecexactrobust(&state, 0);
                  }
               } else {
                  if (solvertype == 1) {
                     minnlcsetalgoslp(&state);
                  } else {
                     if (solvertype == 2) {
                        minnlcsetalgosqp(&state);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
               }
               if (scaletype != 0) {
                  minnlcsetscale(&state, &s);
               }
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
               }
               minnlcsetbc(&state, &bndl, &bndu);
               minnlcsetcond(&state, 1.0E-7, 0);
               while (minnlciteration(&state))
                  if (state.needfij) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                        state.j.xyR[0][i] = b.xR[i];
                        for (j = 0; j < n; j++) {
                           state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                           state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                        }
                     }
                  } else ae_assert(false, "Assertion failed");
               minnlcresults(&state, &x1, &rep);
               Ok = Ok && isfinitevector(&x1, n);
               Ok = Ok && rep.terminationtype > 0;
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardresults(&state, &ogrep);
                  Ok = Ok && optguardallclear(&ogrep);
               }
               if (!Ok) {
                  ae_frame_leave();
                  return Ok;
               }
            // Check constraint violation reports
               Ok = Ok && rep.bcerr <= tolx;
               Ok = Ok && rep.bcidx < n;
               Ok = Ok && rep.lcerr <= 0.0;
               Ok = Ok && rep.lcidx < 0;
            // Check feasibility properties
               for (i = 0; i < n; i++) {
                  Ok = Ok && (!isfinite(bndl.xR[i]) || x1.xR[i] > bndl.xR[i] - tolx * s.xR[i]);
                  Ok = Ok && (!isfinite(bndu.xR[i]) || x1.xR[i] < bndu.xR[i] + tolx * s.xR[i]);
               }
            // Test - calculate scaled constrained gradient at solution,
            // check its norm.
               gnorm = 0.0;
               for (i = 0; i < n; i++) {
                  g = b.xR[i];
                  for (j = 0; j < n; j++) {
                     g += fulla.xyR[i][j] * x1.xR[j];
                  }
                  g *= s.xR[i];
                  if (isfinite(bndl.xR[i]) && NearR(x1.xR[i], bndl.xR[i], tolx * s.xR[i]) && g > 0.0) {
                     g = 0.0;
                  }
                  if (isfinite(bndu.xR[i]) && NearR(x1.xR[i], bndu.xR[i], tolx * s.xR[i]) && g < 0.0) {
                     g = 0.0;
                  }
                  gnorm += sqr(g);
               }
               gnorm = sqrt(gnorm);
               Ok = Ok && gnorm <= tolg;
            }
         }
      }
   // Non-convex test:
   // * N dimensions, N >= 2
   // * box constraints, x[i] in [-1,+1]
   // * A is symmetric indefinite with condition number 50.0
   // * random B with normal entries
   // * initial point is random, feasible
   // * scale is always unit
   //
   // We check that constrained problem can be successfully solved.
   // We do not check ability to detect unboundedness of unconstrained
   // problem because there is such functionality in MinNLC.
      aulits = 50;
      rho = 200.0;
      tolx = 0.0005;
      tolg = 0.01;
      for (n = 2; n <= 10; n++) {
         for (pass = 1; pass <= 10; pass++) {
            for (prectype = 0; prectype <= 2; prectype++) {
            // Generate problem
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     fulla.xyR[i][j] = 0.0;
                  }
               }
               for (i = 0; i < n; i++) {
                  fulla.xyR[i][i] = -1.0 - hqrnduniformr(&rs);
               }
               ae_vector_set_length(&b, n);
               ae_vector_set_length(&bndl, n);
               ae_vector_set_length(&bndu, n);
               ae_vector_set_length(&x0, n);
               for (i = 0; i < n; i++) {
                  b.xR[i] = 0.05 * hqrndnormal(&rs);
                  bndl.xR[i] = -1.0;
                  bndu.xR[i] = +1.0;
                  x0.xR[i] = hqrndmiduniformr(&rs);
               }
            // Solve problem:
            // * without constraints we expect failure
            // * with constraints algorithm must succeed
               minnlccreate(n, &x0, &state);
               if (solvertype == 0) {
                  minnlcsetalgoaul(&state, rho, aulits);
                  if (prectype == 0) {
                     minnlcsetprecinexact(&state);
                  }
                  if (prectype == 1) {
                     minnlcsetprecexactlowrank(&state, 0);
                  }
                  if (prectype == 2) {
                     minnlcsetprecexactrobust(&state, 0);
                  }
               } else {
                  if (solvertype == 1) {
                     minnlcsetalgoslp(&state);
                  } else {
                     if (solvertype == 2) {
                        minnlcsetalgosqp(&state);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
               }
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
               }
               minnlcsetbc(&state, &bndl, &bndu);
               minnlcsetcond(&state, 1.0E-7, 0);
               while (minnlciteration(&state))
                  if (state.needfij) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                        state.j.xyR[0][i] = b.xR[i];
                        for (j = 0; j < n; j++) {
                           state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                           state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                        }
                     }
                  } else ae_assert(false, "Assertion failed");
               minnlcresults(&state, &x1, &rep);
               Ok = Ok && isfinitevector(&x1, n);
               Ok = Ok && rep.terminationtype > 0;
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardresults(&state, &ogrep);
                  Ok = Ok && optguardallclear(&ogrep);
               }
               if (!Ok) {
                  ae_frame_leave();
                  return Ok;
               }
            // Check feasibility properties
               for (i = 0; i < n; i++) {
                  Ok = Ok && (!isfinite(bndl.xR[i]) || x1.xR[i] > bndl.xR[i] - tolx);
                  Ok = Ok && (!isfinite(bndu.xR[i]) || x1.xR[i] < bndu.xR[i] + tolx);
               }
            // Test - calculate scaled constrained gradient at solution,
            // check its norm.
               gnorm = 0.0;
               for (i = 0; i < n; i++) {
                  g = b.xR[i];
                  for (j = 0; j < n; j++) {
                     g += fulla.xyR[i][j] * x1.xR[j];
                  }
                  if (isfinite(bndl.xR[i]) && NearR(x1.xR[i], bndl.xR[i], tolx) && g > 0.0) {
                     g = 0.0;
                  }
                  if (isfinite(bndu.xR[i]) && NearR(x1.xR[i], bndu.xR[i], tolx) && g < 0.0) {
                     g = 0.0;
                  }
                  gnorm += sqr(g);
               }
               gnorm = sqrt(gnorm);
               Ok = Ok && gnorm <= tolg;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests linearly constrained quadratic programming algorithm.
static bool testminnlcunit_testlc() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t k;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   double v;
   double vv;
   double tolx;
   double tolg;
   double tolf;
   ae_int_t aulits;
   double rho;
   ae_int_t scaletype;
   double f0;
   double f1;
   double tolconstr;
   ae_int_t bscale;
   ae_int_t akind;
   ae_int_t ccnt;
   ae_int_t shiftkind;
   ae_int_t prectype;
   ae_int_t solvertype;
   double gnrm2;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xs0, 0, DT_REAL);
   NewVector(xstart, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(xm, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(ce, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewVector(nonnegative, 0, DT_BOOL);
   NewObj(minnlcstate, state);
   NewObj(minnlcreport, rep);
   NewObj(optguardreport, ogrep);
   NewObj(hqrndstate, rs);
   NewObj(snnlssolver, nnls);
   hqrndrandomize(&rs);
   for (solvertype = 0; solvertype <= testminnlcunit_maxsolvertype; solvertype++) {
   // First test:
   // * K < N equality constraints Q*x = Q*x0, where Q is random
   //   orthogonal K*N matrix, x0 is some random vector
   // * quadratic programming problem with identity quadratic term A and
   //   linear term equal to xm*A, where xm is some random vector such
   //   that Q*xm == 0. It is always possible to find such xm, because K < N
   //   Thus, optimization problem has form 0.5*x'*I*x-xm'*x.
   // * exact solution must be equal to x0
   //
   // NOTE: this test is important because it is the only linearly constrained one
   //       which uses non-unit scaling!
      rho = 200.0;
      tolx = 0.0005;
      tolf = 0.0001;
      aulits = 50;
      for (n = 2; n <= 6; n++) {
         for (k = 1; k < n; k++) {
            for (prectype = -1; prectype <= 2; prectype++) {
            // Generate problem: A, b, CMatrix, x0, XStart
               rmatrixrndorthogonal(n, &q);
               ae_vector_set_length(&b, n);
               ae_vector_set_length(&x0, n);
               ae_vector_set_length(&xm, n);
               ae_vector_set_length(&xstart, n);
               ae_matrix_set_length(&c, k, n + 1);
               ae_vector_set_length(&ct, k);
               for (i = 0; i < n; i++) {
                  x0.xR[i] = randommid();
                  xm.xR[i] = x0.xR[i];
                  xstart.xR[i] = randommid();
               }
               for (i = 0; i < k; i++) {
                  ae_v_move(c.xyR[i], 1, q.xyR[i], 1, n);
                  v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
                  c.xyR[i][n] = v;
                  ct.xZ[i] = 0;
                  v = randommid();
                  ae_v_addd(xm.xR, 1, q.xyR[i], 1, n, v);
               }
               for (i = 0; i < n; i++) {
                  b.xR[i] = -xm.xR[i];
               }
            // Apply scaling to linear term and known solution,
            // so problem becomes well-conditioned in the scaled coordinates.
               scaletype = hqrnduniformi(&rs, 2);
               ae_vector_set_length(&s, n);
               for (i = 0; i < n; i++) {
                  if (scaletype == 0) {
                     s.xR[i] = 1.0;
                  } else {
                     s.xR[i] = exp(5 * hqrndnormal(&rs));
                  }
               }
               for (i = 0; i < n; i++) {
                  x0.xR[i] *= s.xR[i];
                  xstart.xR[i] *= s.xR[i];
                  b.xR[i] /= s.xR[i];
               }
               for (i = 0; i < k; i++) {
                  for (j = 0; j < n; j++) {
                     c.xyR[i][j] /= s.xR[j];
                  }
               }
            // Create optimizer, solve
               minnlccreate(n, &xstart, &state);
               minnlcsetscale(&state, &s);
               minnlcsetcond(&state, 1.0E-7, 0);
               minnlcsetlc(&state, &c, &ct, k);
               if (solvertype == 0) {
                  minnlcsetalgoaul(&state, rho, aulits);
                  if (prectype == 0) {
                     minnlcsetprecinexact(&state);
                  }
                  if (prectype == 1) {
                     minnlcsetprecexactlowrank(&state, 0);
                  }
                  if (prectype == 2) {
                     minnlcsetprecexactrobust(&state, 0);
                  }
               } else {
                  if (solvertype == 1) {
                     minnlcsetalgoslp(&state);
                  } else {
                     if (solvertype == 2) {
                        minnlcsetalgosqp(&state);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
               }
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
               }
               while (minnlciteration(&state))
                  if (state.needfij) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += b.xR[i] * state.x.xR[i] + 0.5 * sqr(state.x.xR[i]) / sqr(s.xR[i]);
                        state.j.xyR[0][i] = b.xR[i] + state.x.xR[i] / sqr(s.xR[i]);
                     }
                  } else ae_assert(false, "Assertion failed");
               minnlcresults(&state, &x1, &rep);
               Ok = Ok && isfinitevector(&x1, n);
               Ok = Ok && rep.terminationtype > 0;
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardresults(&state, &ogrep);
                  Ok = Ok && optguardallclear(&ogrep);
               }
               if (!Ok) {
                  ae_frame_leave();
                  return Ok;
               }
            // Check constraint violation reports
               Ok = Ok && rep.bcerr <= 0.0;
               Ok = Ok && rep.bcidx < 0;
               Ok = Ok && rep.lcerr <= tolx;
               Ok = Ok && rep.lcidx < n;
            // Compare with analytic solution
               f0 = 0.0;
               f1 = 0.0;
               for (i = 0; i < n; i++) {
                  f0 += b.xR[i] * x0.xR[i] + 0.5 * sqr(x0.xR[i] / s.xR[i]);
                  f1 += b.xR[i] * x1.xR[i] + 0.5 * sqr(x1.xR[i] / s.xR[i]);
               }
               Ok = Ok && NearAtR(f1, f0, tolf);
            }
         }
      }
   // Inequality constrained problem:
   // * N*N diagonal A
   // * one inequality constraint q'*x >= 0, where q is random unit vector
   // * optimization problem has form 0.5*x'*A*x-(x1*A)*x,
   //   where x1 is some random vector
   // * either:
   //   a) x1 is feasible => we must stop at x1
   //   b) x1 is infeasible => we must stop at the boundary q'*x == 0 and
   //      projection of gradient onto q*x == 0 must be zero
   //
   // NOTE: we make several passes because some specific kind of errors is rarely
   //       caught by this test, so we need several repetitions.
      rho = 200.0;
      tolx = 0.0005;
      tolg = 0.01;
      aulits = 50;
      for (n = 2; n <= 6; n++) {
         for (pass = 0; pass <= 4; pass++) {
         // Generate problem: A, b, CMatrix, x0, XStart
            spdmatrixrndcond(n, 1.0E2, &fulla);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&xm, n);
            ae_vector_set_length(&xstart, n);
            ae_matrix_set_length(&c, 1, n + 1);
            ae_vector_set_length(&ct, 1);
            for (i = 0; i < n; i++) {
               xm.xR[i] = randommid();
               xstart.xR[i] = randommid();
            }
            do {
               v = 0.0;
               for (i = 0; i < n; i++) {
                  c.xyR[0][i] = randommid();
                  v += sqr(c.xyR[0][i]);
               }
               v = sqrt(v);
            } while (v == 0.0);
            for (i = 0; i < n; i++) {
               c.xyR[0][i] /= v;
            }
            c.xyR[0][n] = 0.0;
            ct.xZ[0] = 1;
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(fulla.xyR[i], 1, xm.xR, 1, n);
               b.xR[i] = -v;
            }
         // Apply scaling to linear term and known solution,
         // so problem becomes well-conditioned in the scaled coordinates.
            scaletype = hqrnduniformi(&rs, 2);
            ae_vector_set_length(&s, n);
            for (i = 0; i < n; i++) {
               if (scaletype == 0) {
                  s.xR[i] = 1.0;
               } else {
                  s.xR[i] = exp(hqrndnormal(&rs));
               }
            }
            for (i = 0; i < n; i++) {
               xm.xR[i] *= s.xR[i];
               xstart.xR[i] *= s.xR[i];
               b.xR[i] /= s.xR[i];
               for (j = 0; j < n; j++) {
                  fulla.xyR[i][j] /= s.xR[i] * s.xR[j];
               }
            }
            for (j = 0; j < n; j++) {
               c.xyR[0][j] /= s.xR[j];
            }
         // Create optimizer, solve
            minnlccreate(n, &xstart, &state);
            if (solvertype == 0) {
               minnlcsetalgoaul(&state, rho, aulits);
            } else {
               if (solvertype == 1) {
                  minnlcsetalgoslp(&state);
               } else {
                  if (solvertype == 2) {
                     minnlcsetalgosqp(&state);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            }
            minnlcsetlc(&state, &c, &ct, 1);
            minnlcsetscale(&state, &s);
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
            }
            while (minnlciteration(&state))
               if (state.needfij) {
                  state.fi.xR[0] = 0.0;
                  for (i = 0; i < n; i++) {
                     state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                     state.j.xyR[0][i] = b.xR[i];
                     for (j = 0; j < n; j++) {
                        state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                        state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                     }
                  }
               } else ae_assert(false, "Assertion failed");
            minnlcresults(&state, &x1, &rep);
            Ok = Ok && isfinitevector(&x1, n);
            Ok = Ok && rep.terminationtype > 0;
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardresults(&state, &ogrep);
               Ok = Ok && optguardallclear(&ogrep);
            }
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Check constraint violation reports
            Ok = Ok && rep.bcerr <= 0.0;
            Ok = Ok && rep.bcidx < 0;
            Ok = Ok && rep.lcerr <= tolx;
            Ok = Ok && rep.lcidx < n;
         // Test solution
            ae_vector_set_length(&g, n);
            ae_v_move(g.xR, 1, b.xR, 1, n);
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(fulla.xyR[i], 1, x1.xR, 1, n);
               g.xR[i] += v;
            }
            v = ae_v_dotproduct(x1.xR, 1, c.xyR[0], 1, n);
            Ok = Ok && v >= -tolx;
            if (v < tolx) {
            // Point at the boundary, project gradient into
            // equality-constrained subspace.
               v = 0.0;
               vv = 0.0;
               for (i = 0; i < n; i++) {
                  v += g.xR[i] * c.xyR[0][i];
                  vv += c.xyR[0][i] * c.xyR[0][i];
               }
               v /= vv;
               ae_v_subd(g.xR, 1, c.xyR[0], 1, n, v);
            }
            v = 0.0;
            for (i = 0; i < n; i++) {
               v += sqr(g.xR[i] * s.xR[i]);
            }
            Ok = Ok && sqrt(v) <= tolg;
         }
      }
   // Equality-constrained test:
   // * N*N SPD A
   // * K < N equality constraints Q*x = Q*x0, where Q is random
   //   orthogonal K*N matrix, x0 is some random vector
   // * optimization problem has form 0.5*x'*A*x-(xm*A)*x,
   //   where xm is some random vector
   // * we check feasibility properties of the solution
   // * we do not know analytic form of the exact solution,
   //   but we know that projection of gradient into equality constrained
   //   subspace must be zero at the solution
      rho = 200.0;
      tolx = 0.0005;
      tolg = 0.01;
      aulits = 50;
      for (n = 2; n <= 6; n++) {
         for (k = 1; k < n; k++) {
         // Generate problem: A, b, CMatrix, x0, XStart
            rmatrixrndorthogonal(n, &q);
            spdmatrixrndcond(n, 1.0E2, &fulla);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&xm, n);
            ae_vector_set_length(&xstart, n);
            ae_matrix_set_length(&c, k, n + 1);
            ae_vector_set_length(&ct, k);
            for (i = 0; i < n; i++) {
               x0.xR[i] = randommid();
               xm.xR[i] = randommid();
               xstart.xR[i] = randommid();
            }
            for (i = 0; i < k; i++) {
               ae_v_move(c.xyR[i], 1, q.xyR[i], 1, n);
               v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
               c.xyR[i][n] = v;
               ct.xZ[i] = 0;
            }
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(fulla.xyR[i], 1, xm.xR, 1, n);
               b.xR[i] = -v;
            }
         // Create optimizer, solve
            minnlccreate(n, &xstart, &state);
            if (solvertype == 0) {
               minnlcsetalgoaul(&state, rho, aulits);
            } else {
               if (solvertype == 1) {
                  minnlcsetalgoslp(&state);
               } else {
                  if (solvertype == 2) {
                     minnlcsetalgosqp(&state);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            }
            minnlcsetcond(&state, 1.0E-7, 0);
            minnlcsetlc(&state, &c, &ct, k);
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
            }
            while (minnlciteration(&state))
               if (state.needfij) {
                  state.fi.xR[0] = 0.0;
                  for (i = 0; i < n; i++) {
                     state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                     state.j.xyR[0][i] = b.xR[i];
                     for (j = 0; j < n; j++) {
                        state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                        state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                     }
                  }
               } else ae_assert(false, "Assertion failed");
            minnlcresults(&state, &x1, &rep);
            Ok = Ok && isfinitevector(&x1, n);
            Ok = Ok && rep.terminationtype > 0;
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardresults(&state, &ogrep);
               Ok = Ok && optguardallclear(&ogrep);
            }
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Check constraint violation reports
            Ok = Ok && rep.bcerr <= 0.0;
            Ok = Ok && rep.bcidx < 0;
            Ok = Ok && rep.lcerr <= tolx;
            Ok = Ok && rep.lcidx < n;
         // Check feasibility properties and gradient projection
            for (i = 0; i < k; i++) {
               v = ae_v_dotproduct(x1.xR, 1, c.xyR[i], 1, n);
               Ok = Ok && NearAtR(v, c.xyR[i][n], tolx);
            }
            ae_vector_set_length(&g, n);
            ae_v_move(g.xR, 1, b.xR, 1, n);
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(fulla.xyR[i], 1, x1.xR, 1, n);
               g.xR[i] += v;
            }
            for (i = 0; i < k; i++) {
               v = ae_v_dotproduct(g.xR, 1, c.xyR[i], 1, n);
               ae_v_subd(g.xR, 1, c.xyR[i], 1, n, v);
            }
            v = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
            Ok = Ok && sqrt(v) <= tolg;
         }
      }
   // Boundary constraints vs linear ones:
   // * N*N SPD A
   // * optimization problem has form 0.5*x'*A*x-(xm*A)*x,
   //   where xm is some random vector from [-1,+1]
   // * K == 2*N constraints of the form ai <= x[i] or x[i] <= b[i],
   //   with ai in [-1.0,-0.1], bi in [+0.1,+1.0]
   // * initial point xstart is from [-1,+2]
   // * we solve two related QP problems:
   //   a) one with constraints posed as boundary ones
   //   b) another one with same constraints posed as general linear ones
   // both problems must have same solution.
   // Here we test that boundary constrained and linear inequality constrained
   // solvers give same results.
      rho = 200.0;
      tolx = 0.0005;
      tolf = 0.00001;
      aulits = 50;
      for (n = 1; n <= 6; n++) {
      // Generate problem: A, b, x0, XStart, C, CT
         spdmatrixrndcond(n, 1.0E2, &fulla);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xm, n);
         ae_vector_set_length(&x0, n);
         ae_matrix_set_length(&c, 2 * n, n + 1);
         ae_vector_set_length(&ct, 2 * n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            xm.xR[i] = randommid();
            x0.xR[i] = 3.0 * randomreal() - 1.0;
            bndl.xR[i] = -(0.1 + 0.9 * randomreal());
            bndu.xR[i] = 0.1 + 0.9 * randomreal();
            for (j = 0; j < n; j++) {
               c.xyR[2 * i][j] = 0.0;
               c.xyR[2 * i + 1][j] = 0.0;
            }
            c.xyR[2 * i][i] = 1.0;
            c.xyR[2 * i][n] = bndl.xR[i];
            ct.xZ[2 * i] = 1;
            c.xyR[2 * i + 1][i] = 1.0;
            c.xyR[2 * i + 1][n] = bndu.xR[i];
            ct.xZ[2 * i + 1] = -1;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(fulla.xyR[i], 1, xm.xR, 1, n);
            b.xR[i] = -v;
         }
      // Solve linear inequality constrained problem
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, rho, aulits);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetlc(&state, &c, &ct, 2 * n);
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
         }
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardresults(&state, &ogrep);
            Ok = Ok && optguardallclear(&ogrep);
         }
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Solve boundary constrained problem
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, rho, aulits);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetbc(&state, &bndl, &bndu);
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x2, &rep);
         Ok = Ok && isfinitevector(&x2, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Compare solutions
         f0 = 0.0;
         f1 = 0.0;
         for (i = 0; i < n; i++) {
            f0 += b.xR[i] * x1.xR[i];
            f1 += b.xR[i] * x2.xR[i];
            for (j = 0; j < n; j++) {
               f0 += 0.5 * x1.xR[i] * fulla.xyR[i][j] * x1.xR[j];
               f1 += 0.5 * x2.xR[i] * fulla.xyR[i][j] * x2.xR[j];
            }
         }
         Ok = Ok && NearAtR(f0, f1, tolf);
      }
   // Boundary and linear equality constrained QP problem with excessive
   // equality constraints:
   // * N*N SPD A with moderate condtion number (up to 100)
   // * boundary constraints 0 <= x[i] <= 1
   // * K == 2*N equality constraints Q*x = Q*x0, where Q is random matrix,
   //   x0 is some random vector from the feasible hypercube (0.1 <= x0[i] <= 0.9)
   // * optimization problem has form 0.5*x'*A*x-b*x,
   //   where b is some random vector
   // * because constraints are excessive, the main problem is to find
   //   feasible point; the only existing feasible point is solution,
   //   so we have to check only feasibility
      rho = 1000.0;
      tolx = 0.0005;
      aulits = 10;
      for (n = 1; n <= 6; n++) {
      // Generate problem: A, b, BndL, BndU, CMatrix, x0, xm, XStart
         k = 2 * n;
         spdmatrixrndcond(n, 1.0E2, &fulla);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xm, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 0.1 + 0.8 * randomreal();
            xm.xR[i] = randommid();
            bndl.xR[i] = 0.0;
            bndu.xR[i] = 1.0;
            xstart.xR[i] = (double)randominteger(2);
         }
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = randommid();
            }
            v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
         }
         for (i = 0; i < n; i++) {
            b.xR[i] = randommid();
         }
      // Create optimizer, solve
         minnlccreate(n, &xstart, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, rho, aulits);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 1.0E-7, 0);
         minnlcsetlc(&state, &c, &ct, k);
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
         }
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardresults(&state, &ogrep);
            Ok = Ok && optguardallclear(&ogrep);
         }
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(x1.xR, 1, c.xyR[i], 1, n);
            Ok = Ok && NearAtR(v, c.xyR[i][n], tolx);
         }
      }
   // Boundary and linear equality/inequality constrained QP problem with
   // excessive constraints:
   // * N*N SPD A with moderate condtion number (up to 100)
   // * boundary constraints 0 <= x[i] <= 1
   // * K == 2*N equality/inequality constraints:
   //   * N/2 equality ones q'*x = q'*xm for random vector q
   //   * the rest are inequality ones, feasible at xm (xm is an inner point for these constraints)
   //   where xm is some random vector from the feasible hypercube (0.1 <= xm[i] <= 0.9)
   // * optimization problem has form 0.5*x'*A*x-b*x,
   //   where b is some random vector
   // * because constraints are excessive, the main problem is to find
   //   feasible point; we do not check that algorithm found a solution,
   //   we just check that it found feasible point.
   //
   // NOTE: this problem is difficult one (estimates of Lagrange multipliers converge
   //       slowly), so we use relaxed tolerances - 0.010 for AUL solver
      rho = 1000.0;
      aulits = 30;
      for (n = 1; n <= 6; n++) {
      // Generate problem: A, b, BndL, BndU, CMatrix, xm, x1, XStart
         k = 2 * n;
         spdmatrixrndcond(n, 1.0E2, &fulla);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&xm, n);
         ae_vector_set_length(&x0, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            xm.xR[i] = 0.1 + 0.8 * randomreal();
            bndl.xR[i] = 0.0;
            bndu.xR[i] = 1.0;
            x0.xR[i] = (double)randominteger(2);
            b.xR[i] = randommid();
         }
         for (i = 0; i < n / 2; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
               v += c.xyR[i][j] * xm.xR[j];
            }
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
         }
         for (i = n / 2; i < k; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs) / sqrt(n);
               v += c.xyR[i][j] * xm.xR[j];
            }
            c.xyR[i][n] = v;
            ct.xZ[i] = 2 * hqrnduniformi(&rs, 2) - 1;
            if (ct.xZ[i] > 0) {
               c.xyR[i][n] -= 0.1;
            } else {
               c.xyR[i][n] += 0.1;
            }
         }
      // Create optimizer, solve
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, rho, aulits);
            tolx = 0.0050;
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
               tolx = 0.0010;
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
                  tolx = 0.0010;
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetbc(&state, &bndl, &bndu);
         minnlcsetlc(&state, &c, &ct, k);
         minnlcsetcond(&state, 1.0E-7, 0);
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
         }
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardresults(&state, &ogrep);
            Ok = Ok && optguardallclear(&ogrep);
         }
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(x1.xR, 1, c.xyR[i], 1, n);
            if (ct.xZ[i] == 0) {
               Ok = Ok && NearAtR(v, c.xyR[i][n], tolx);
            }
            if (ct.xZ[i] > 0) {
               Ok = Ok && v >= c.xyR[i][n] - tolx;
            }
            if (ct.xZ[i] < 0) {
               Ok = Ok && v <= c.xyR[i][n] + tolx;
            }
         }
      }
   // Boundary and linear equality constrained QP problem,
   // test checks that different starting points yield same final point:
   // * random N from [1..6], random K from [1..N-1]
   // * N*N SPD A with moderate condtion number (important!)
   // * boundary constraints 0 <= x[i] <= 1
   // * K < N random linear equality constraints C*x = C*x0,
   //   where x0 is some random vector from the inner area of the
   //   feasible hypercube (0.1 <= x0[i] <= 0.9)
   // * optimization problem has form 0.5*x'*A*x+b*x,
   //   where b is some random vector with -5 <= b[i] <= +5
   //
   // We solve this problem two times:
   // * each time from different initial point XStart in [-2,+2]
   // * we compare values of the target function (although final points
   //   may be slightly different, function values should match each other)
   //
   // Both points should give same results; any significant difference is
   // evidence of some error in the QP implementation.
      rho = 1000.0;
      tolf = 0.0001;
      aulits = 10;
      for (pass = 1; pass <= 50; pass++) {
      // Generate problem: N, K, A, b, BndL, BndU, CMatrix, x0, xm, XStart.
         n = randominteger(5) + 2;
         k = 1 + randominteger(n - 1);
         spdmatrixrndcond(n, 1.0E2, &fulla);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 0.1 + 0.8 * randomreal();
            b.xR[i] = randommid();
            bndl.xR[i] = 0.0;
            bndu.xR[i] = 1.0;
         }
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = randommid();
            }
            c.xyR[i][i] += 4;
            v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
         }
      // Start from first point
         for (i = 0; i < n; i++) {
            xstart.xR[i] = 2.0 * randommid();
         }
         minnlccreate(n, &xstart, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, rho, aulits);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 1.0E-7, 0);
         minnlcsetbc(&state, &bndl, &bndu);
         minnlcsetlc(&state, &c, &ct, k);
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
         }
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x0, &rep);
         Ok = Ok && isfinitevector(&x0, n);
         Ok = Ok && rep.terminationtype > 0;
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardresults(&state, &ogrep);
            Ok = Ok && optguardallclear(&ogrep);
         }
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Start from another point
         for (i = 0; i < n; i++) {
            xstart.xR[i] = 2.0 * randommid();
         }
         for (minnlcrestartfrom(&state, &xstart); minnlciteration(&state); )
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Calculate function value at X0 and X1, compare solutions
         f0 = 0.0;
         f1 = 0.0;
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               f0 += 0.5 * x0.xR[i] * fulla.xyR[i][j] * x0.xR[j];
               f1 += 0.5 * x1.xR[i] * fulla.xyR[i][j] * x1.xR[j];
            }
            f0 += x0.xR[i] * b.xR[i];
            f1 += x1.xR[i] * b.xR[i];
         }
         Ok = Ok && NearAtR(f0, f1, tolf);
      }
   // Convex/nonconvex optimization problem with excessive
   // (degenerate constraints):
   //
   // * N = 2..7
   // * f = 0.5*x'*A*x+b'*x
   // * b has normally distributed entries with scale 10^BScale
   // * several kinds of A are tried: zero, well conditioned SPD, well conditioned indefinite, low rank
   // * box constraints: x[i] in [-1,+1]
   // * 2^N "excessive" general linear constraints (v_k,x) <= (v_k,v_k)+v_shift,
   //   where v_k is one of 2^N vertices of feasible hypercube, v_shift is
   //   a shift parameter:
   //   * with zero v_shift such constraints are degenerate (each vertex has
   //     N box constraints and one "redundant" linear constraint)
   //   * with positive v_shift linear constraint is always inactive
   //   * with small (about machine epsilon) but negative v_shift,
   //     constraint is close to degenerate - but not exactly
   //
   // We check that constrained gradient is close to zero at solution.
   // Box constraint is considered active if distance to boundary is less
   // than TolConstr.
   //
   // NOTE: because AUL algorithm is less exact than its active set counterparts,
   //       VERY loose tolerances are used for this test.
      tolconstr = 1.0E-2;
      for (n = 2; n <= 6; n++) {
         for (akind = 0; akind <= 3; akind++) {
         // Choose random parameters
            shiftkind = hqrnduniformi(&rs, 7) - 5;
            bscale = hqrnduniformi(&rs, 3) - 2;
         // Generate A, B and initial point
            ae_matrix_set_length(&a, n, n);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&x, n);
            for (i = 0; i < n; i++) {
               b.xR[i] = pow(10.0, (double)bscale) * hqrndnormal(&rs);
               x.xR[i] = hqrnduniformr(&rs) - 0.5;
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
            }
            if (akind == 1) {
            // Dense well conditioned SPD
               spdmatrixrndcond(n, 50.0, &a);
            }
            if (akind == 2) {
            // Dense well conditioned indefinite
               smatrixrndcond(n, 50.0, &a);
            }
            if (akind == 3) {
            // Low rank
               ae_vector_set_length(&tmp, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
                  a.xyR[i][i] = 1.0E-9;
               }
               for (k = 1; k < imin2(4, n); k++) {
                  for (i = 0; i < n; i++) {
                     tmp.xR[i] = hqrndnormal(&rs);
                  }
                  v = hqrndnormal(&rs);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                     }
                  }
               }
            }
         // Generate constraints
            ae_vector_set_length(&bl, n);
            ae_vector_set_length(&bu, n);
            for (i = 0; i < n; i++) {
               bl.xR[i] = -1.0;
               bu.xR[i] = 1.0;
            }
            ccnt = iround(pow(2.0, (double)n));
            ae_matrix_set_length(&c, ccnt, n + 1);
            ae_vector_set_length(&ct, ccnt);
            for (i = 0; i < ccnt; i++) {
               ct.xZ[i] = -1;
               k = i;
               c.xyR[i][n] = sign((double)shiftkind) * pow(10.0, fabs((double)shiftkind)) * machineepsilon;
               for (j = 0; j < n; j++) {
                  c.xyR[i][j] = (double)(2 * (k % 2) - 1);
                  c.xyR[i][n] += c.xyR[i][j] * c.xyR[i][j];
                  k /= 2;
               }
            }
         // Create and optimize
            minnlccreate(n, &x, &state);
            minnlcsetbc(&state, &bl, &bu);
            minnlcsetlc(&state, &c, &ct, ccnt);
            minnlcsetcond(&state, 1.0E-12, 0);
            if (solvertype == 0) {
               minnlcsetalgoaul(&state, rho, aulits);
            } else {
               if (solvertype == 1) {
                  minnlcsetalgoslp(&state);
               } else {
                  if (solvertype == 2) {
                     minnlcsetalgosqp(&state);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            }
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
            }
            while (minnlciteration(&state))
               if (state.needfij) {
                  state.fi.xR[0] = 0.0;
                  for (i = 0; i < n; i++) {
                     state.fi.xR[0] += state.x.xR[i] * b.xR[i];
                     state.j.xyR[0][i] = b.xR[i];
                  }
                  for (i = 0; i < n; i++) {
                     v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * v;
                     state.j.xyR[0][i] += v;
                  }
               } else ae_assert(false, "Assertion failed");
            minnlcresults(&state, &xs0, &rep);
            Ok = Ok && rep.terminationtype > 0;
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardresults(&state, &ogrep);
               Ok = Ok && optguardallclear(&ogrep);
            }
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Evaluate gradient at solution and test
            vv = 0.0;
            gnrm2 = 0.0;
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xs0.xR, 1, n);
               v += b.xR[i];
               gnrm2 += v * v;
               if (xs0.xR[i] <= bl.xR[i] + tolconstr && v > 0.0) {
                  v = 0.0;
               }
               if (xs0.xR[i] >= bu.xR[i] - tolconstr && v < 0.0) {
                  v = 0.0;
               }
               vv += sqr(v);
            }
            vv = sqrt(vv / (gnrm2 + 1.0));
            Ok = Ok && vv <= 1.0E-2;
         }
      }
   // Linear/convex optimization problem with combination of
   // box and linear constraints:
   //
   // * N = 2..8
   // * f = 0.5*x'*A*x+b'*x
   // * b has normally distributed entries with scale 10^BScale
   // * several kinds of A are tried: zero, well conditioned SPD
   // * box constraints: x[i] in [-1,+1]
   // * initial point x0 = [0 0 ... 0 0]
   // * CCnt == min(3,N-1) general linear constraints of form (c,x) == 0.
   //   random mix of equality/inequality constraints is tried.
   //   x0 is guaranteed to be feasible.
   //
   // We check that constrained gradient is close to zero at solution.
   // Inequality constraint is considered active if distance to boundary
   // is less than TolConstr. We use nonnegative least squares solver
   // in order to compute constrained gradient.
      tolconstr = 1.0E-2;
      for (n = 2; n <= 8; n++) {
         for (akind = 0; akind <= 1; akind++) {
            for (bscale = 0; bscale >= -2; bscale--) {
            // Generate A, B and initial point
               ae_matrix_set_length(&a, n, n);
               ae_vector_set_length(&b, n);
               ae_vector_set_length(&x, n);
               for (i = 0; i < n; i++) {
                  b.xR[i] = pow(10.0, (double)bscale) * hqrndnormal(&rs);
                  x.xR[i] = 0.0;
               }
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               if (akind == 1) {
               // Dense well conditioned SPD
                  spdmatrixrndcond(n, 50.0, &a);
               }
               if (solvertype != 0) {
               // AUL performs poorly on such problems,
               // but SLP works goo.
                  if (akind == 2) {
                  // Dense well conditioned indefinite
                     smatrixrndcond(n, 50.0, &a);
                  }
                  if (akind == 3) {
                  // Low rank
                     ae_vector_set_length(&tmp, n);
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] = 0.0;
                        }
                        a.xyR[i][i] = 1.0E-9;
                     }
                     for (k = 1; k < imin2(4, n); k++) {
                        for (i = 0; i < n; i++) {
                           tmp.xR[i] = hqrndnormal(&rs);
                        }
                        v = hqrndnormal(&rs);
                        for (i = 0; i < n; i++) {
                           for (j = 0; j < n; j++) {
                              a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                           }
                        }
                     }
                  }
               }
            // Generate constraints
               ae_vector_set_length(&bl, n);
               ae_vector_set_length(&bu, n);
               for (i = 0; i < n; i++) {
                  bl.xR[i] = -1.0;
                  bu.xR[i] = 1.0;
               }
               ccnt = imin2(3, n - 1);
               ae_matrix_set_length(&c, ccnt, n + 1);
               ae_vector_set_length(&ct, ccnt);
               for (i = 0; i < ccnt; i++) {
                  ct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
                  c.xyR[i][n] = 0.0;
                  for (j = 0; j < n; j++) {
                     c.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                  }
                  c.xyR[i][i] += 4;
               }
            // Create and optimize
               minnlccreate(n, &x, &state);
               minnlcsetbc(&state, &bl, &bu);
               minnlcsetlc(&state, &c, &ct, ccnt);
               minnlcsetcond(&state, 1.0E-7, 0);
               if (solvertype == 0) {
                  minnlcsetalgoaul(&state, 1000.0, 10);
               } else {
                  if (solvertype == 1) {
                     minnlcsetalgoslp(&state);
                  } else {
                     if (solvertype == 2) {
                        minnlcsetalgosqp(&state);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
               }
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
               }
               while (minnlciteration(&state))
                  if (state.needfij) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += state.x.xR[i] * b.xR[i];
                        state.j.xyR[0][i] = b.xR[i];
                     }
                     for (i = 0; i < n; i++) {
                        v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
                        state.fi.xR[0] += 0.5 * state.x.xR[i] * v;
                        state.j.xyR[0][i] += v;
                     }
                  } else ae_assert(false, "Assertion failed");
               minnlcresults(&state, &xs0, &rep);
               Ok = Ok && rep.terminationtype > 0;
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardresults(&state, &ogrep);
                  Ok = Ok && optguardallclear(&ogrep);
               }
               if (!Ok) {
                  ae_frame_leave();
                  return Ok;
               }
            // 1. evaluate unconstrained gradient at solution
            //
            // 2. calculate constrained gradient (NNLS solver is used
            //    to evaluate gradient subject to active constraints).
            //    In order to do this we form CE matrix, matrix of active
            //    constraints (columns store constraint vectors). Then
            //    we try to approximate gradient vector by columns of CE,
            //    subject to non-negativity restriction placed on variables
            //    corresponding to inequality constraints.
            //
            //    Residual from such regression is a constrained gradient vector.
               ae_vector_set_length(&g, n);
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, xs0.xR, 1, n);
                  g.xR[i] = v + b.xR[i];
               }
               ae_matrix_set_length(&ce, n, n + ccnt);
               ae_vector_set_length(&nonnegative, n + ccnt);
               k = 0;
               for (i = 0; i < n; i++) {
                  Ok = Ok && xs0.xR[i] >= bl.xR[i] - tolconstr;
                  Ok = Ok && xs0.xR[i] <= bu.xR[i] + tolconstr;
                  if (xs0.xR[i] <= bl.xR[i] + tolconstr) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = 0.0;
                     }
                     ce.xyR[i][k] = 1.0;
                     nonnegative.xB[k] = true;
                     k++;
                     continue;
                  }
                  if (xs0.xR[i] >= bu.xR[i] - tolconstr) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = 0.0;
                     }
                     ce.xyR[i][k] = -1.0;
                     nonnegative.xB[k] = true;
                     k++;
                     continue;
                  }
               }
               for (i = 0; i < ccnt; i++) {
                  v = ae_v_dotproduct(c.xyR[i], 1, xs0.xR, 1, n);
                  v -= c.xyR[i][n];
                  Ok = Ok && (ct.xZ[i] != 0 || SmallAtR(v, tolconstr));
                  Ok = Ok && (ct.xZ[i] <= 0 || v >= -tolconstr);
                  Ok = Ok && (ct.xZ[i] >= 0 || v <= +tolconstr);
                  if (ct.xZ[i] == 0) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = c.xyR[i][j];
                     }
                     nonnegative.xB[k] = false;
                     k++;
                     continue;
                  }
                  if (ct.xZ[i] > 0 && v <= tolconstr || ct.xZ[i] < 0 && v >= -tolconstr) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = sign((double)ct.xZ[i]) * c.xyR[i][j];
                     }
                     nonnegative.xB[k] = true;
                     k++;
                     continue;
                  }
               }
               snnlsinit(0, 0, 0, &nnls);
               snnlssetproblem(&nnls, &ce, &g, 0, k, n);
               for (i = 0; i < k; i++) {
                  if (!nonnegative.xB[i]) {
                     snnlsdropnnc(&nnls, i);
                  }
               }
               snnlssolve(&nnls, &tmp);
               for (i = 0; i < k; i++) {
                  for (j = 0; j < n; j++) {
                     g.xR[j] -= tmp.xR[i] * ce.xyR[j][i];
                  }
               }
               vv = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
               vv = sqrt(vv);
               Ok = Ok && vv <= 1.0E-3;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests nonlinearly constrained quadratic programming algorithm.
static bool testminnlcunit_testnlc() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t n2;
   double tolx;
   double tolg;
   ae_int_t aulits;
   double rho;
   ae_int_t scaletype;
   ae_int_t cntbc;
   ae_int_t cntlc;
   ae_int_t cntnlec;
   ae_int_t cntnlic;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t pass;
   ae_int_t klc;
   ae_int_t knlec;
   ae_int_t knlic;
   double v;
   double vv;
   double vx;
   double vy;
   double gnorm2;
   double rawgnorm2;
   ae_int_t prectype;
   ae_int_t solvertype;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(minnlcstate, state);
   NewObj(minnlcreport, rep);
   NewObj(optguardreport, ogrep);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(rnlc, 0, DT_REAL);
   NewVector(ckind, 0, DT_INT);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   for (solvertype = 0; solvertype <= testminnlcunit_maxsolvertype; solvertype++) {
   // Basic test:
   // * 2-dimensional problem
   // * target function F(x0,x1) = (x0-1)^2 + (x1-1)^2
   // * one nonlinear constraint Z(x0,x1) = x0^2+x1^2-1,
   //   which is tried as equality and inequality one
      rho = 200.0;
      tolx = 0.0005;
      aulits = 50;
      n = 2;
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
      }
      minnlccreate(n, &x0, &state);
      if (solvertype == 0) {
         minnlcsetalgoaul(&state, rho, aulits);
      } else {
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
      }
      minnlcsetcond(&state, 1.0E-7, 0);
      minnlcsetnlc(&state, 0, 1);
      while (minnlciteration(&state))
         if (state.needfij) {
            state.fi.xR[0] = sqr(state.x.xR[0] - 1) + sqr(state.x.xR[1] - 1);
            state.j.xyR[0][0] = 2 * (state.x.xR[0] - 1);
            state.j.xyR[0][1] = 2 * (state.x.xR[1] - 1);
            state.fi.xR[1] = sqr(state.x.xR[0]) + sqr(state.x.xR[1]) - 1;
            state.j.xyR[1][0] = 2 * state.x.xR[0];
            state.j.xyR[1][1] = 2 * state.x.xR[1];
         } else ae_assert(false, "Assertion failed");
      minnlcresults(&state, &x1, &rep);
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      Ok = Ok && NearAtR(x1.xR[0], sqrt(0.5), tolx);
      Ok = Ok && NearAtR(x1.xR[1], sqrt(0.5), tolx);
      minnlcsetnlc(&state, 1, 0);
      minnlcrestartfrom(&state, &x0);
      if (hqrndnormal(&rs) > 0.0) {
         minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
      }
      while (minnlciteration(&state))
         if (state.needfij) {
            state.fi.xR[0] = sqr(state.x.xR[0] - 1) + sqr(state.x.xR[1] - 1);
            state.j.xyR[0][0] = 2 * (state.x.xR[0] - 1);
            state.j.xyR[0][1] = 2 * (state.x.xR[1] - 1);
            state.fi.xR[1] = sqr(state.x.xR[0]) + sqr(state.x.xR[1]) - 1;
            state.j.xyR[1][0] = 2 * state.x.xR[0];
            state.j.xyR[1][1] = 2 * state.x.xR[1];
         } else ae_assert(false, "Assertion failed");
      minnlcresults(&state, &x1, &rep);
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && rep.terminationtype > 0;
      if (hqrndnormal(&rs) > 0.0) {
         minnlcoptguardresults(&state, &ogrep);
         Ok = Ok && optguardallclear(&ogrep);
      }
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      Ok = Ok && NearAtR(x1.xR[0], sqrt(0.5), tolx);
      Ok = Ok && NearAtR(x1.xR[1], sqrt(0.5), tolx);
   // This test checks correctness of scaling being applied to nonlinear
   // constraints. We solve bound constrained scaled problem and check
   // that solution is correct.
      aulits = 50;
      rho = 200.0;
      tolx = 0.0005;
      tolg = 0.01;
      for (n = 1; n <= 10; n++) {
         for (pass = 1; pass <= 10; pass++) {
         // Generate well-conditioned problem with unit scale
            spdmatrixrndcond(n, 1.0E2, &fulla);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            ae_vector_set_length(&x0, n);
            for (i = 0; i < n; i++) {
               b.xR[i] = hqrndnormal(&rs);
               x0.xR[i] = hqrndnormal(&rs);
            }
            cntnlec = hqrnduniformi(&rs, n);
            cntnlic = n - cntnlec;
            for (i = 0; i < cntnlec; i++) {
               bndl.xR[i] = hqrndnormal(&rs);
               bndu.xR[i] = bndl.xR[i];
            }
            for (i = cntnlec; i < n; i++) {
               bndl.xR[i] = hqrndnormal(&rs);
               bndu.xR[i] = bndl.xR[i] + 0.5;
            }
         // Apply scaling to quadratic/linear term, so problem becomes
         // well-conditioned in the scaled coordinates.
            scaletype = hqrnduniformi(&rs, 2);
            ae_vector_set_length(&s, n);
            for (i = 0; i < n; i++) {
               if (scaletype == 0) {
                  s.xR[i] = 1.0;
               } else {
                  s.xR[i] = exp(5 * hqrndnormal(&rs));
               }
            }
            for (i = 0; i < n; i++) {
               x0.xR[i] *= s.xR[i];
               bndl.xR[i] *= s.xR[i];
               bndu.xR[i] *= s.xR[i];
               b.xR[i] /= s.xR[i];
               for (j = 0; j < n; j++) {
                  fulla.xyR[i][j] /= s.xR[i] * s.xR[j];
               }
            }
         // Solve problem with boundary constraints posed as nonlinear ones
            minnlccreate(n, &x0, &state);
            if (solvertype == 0) {
               minnlcsetalgoaul(&state, rho, aulits);
            } else {
               if (solvertype == 1) {
                  minnlcsetalgoslp(&state);
               } else {
                  if (solvertype == 2) {
                     minnlcsetalgosqp(&state);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            }
            minnlcsetscale(&state, &s);
            minnlcsetnlc(&state, cntnlec, 2 * cntnlic);
            minnlcsetcond(&state, 1.0E-7, 0);
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
            }
            while (minnlciteration(&state))
               if (state.needfij) {
                  for (i = 0; i <= cntnlec + 2 * cntnlic; i++) {
                     state.fi.xR[i] = 0.0;
                     for (j = 0; j < n; j++) {
                        state.j.xyR[i][j] = 0.0;
                     }
                  }
               // Function itself
                  for (i = 0; i < n; i++) {
                     state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                     state.j.xyR[0][i] = b.xR[i];
                     for (j = 0; j < n; j++) {
                        state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                        state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                     }
                  }
               // Equality constraints
                  for (i = 0; i < cntnlec; i++) {
                     state.fi.xR[1 + i] = (state.x.xR[i] - bndl.xR[i]) / s.xR[i];
                     state.j.xyR[1 + i][i] = 1 / s.xR[i];
                  }
               // Inequality constraints
                  for (i = 0; i < cntnlic; i++) {
                     k = cntnlec + i;
                     state.fi.xR[1 + cntnlec + 2 * i] = (bndl.xR[k] - state.x.xR[k]) / s.xR[k];
                     state.j.xyR[1 + cntnlec + 2 * i][k] = -1 / s.xR[k];
                     state.fi.xR[1 + cntnlec + 2 * i + 1] = (state.x.xR[k] - bndu.xR[k]) / s.xR[k];
                     state.j.xyR[1 + cntnlec + 2 * i + 1][k] = 1 / s.xR[k];
                  }
               } else ae_assert(false, "Assertion failed");
            minnlcresults(&state, &x1, &rep);
            Ok = Ok && isfinitevector(&x1, n);
            Ok = Ok && rep.terminationtype > 0;
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardresults(&state, &ogrep);
               Ok = Ok && optguardallclear(&ogrep);
            }
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Check feasibility properties
            for (i = 0; i < n; i++) {
               Ok = Ok && (!isfinite(bndl.xR[i]) || x1.xR[i] > bndl.xR[i] - tolx * s.xR[i]);
               Ok = Ok && (!isfinite(bndu.xR[i]) || x1.xR[i] < bndu.xR[i] + tolx * s.xR[i]);
            }
         // Test - calculate scaled constrained gradient at solution,
         // check its norm.
            ae_vector_set_length(&g, n);
            gnorm2 = 0.0;
            for (i = 0; i < n; i++) {
               g.xR[i] = b.xR[i];
               for (j = 0; j < n; j++) {
                  g.xR[i] += fulla.xyR[i][j] * x1.xR[j];
               }
               g.xR[i] *= s.xR[i];
               if (isfinite(bndl.xR[i]) && NearR(x1.xR[i], bndl.xR[i], tolx * s.xR[i]) && g.xR[i] > 0.0) {
                  g.xR[i] = 0.0;
               }
               if (isfinite(bndu.xR[i]) && NearR(x1.xR[i], bndu.xR[i], tolx * s.xR[i]) && g.xR[i] < 0.0) {
                  g.xR[i] = 0.0;
               }
               gnorm2 += sqr(g.xR[i]);
            }
            Ok = Ok && gnorm2 <= sqr(tolg);
         }
      }
   // Complex problem with mix of boundary, linear and nonlinear constraints:
   // * quadratic target function f(x) = 0.5*x'*A*x + b'*x
   // * unit scaling is used
   // * problem size N is even
   // * all variables are divided into pairs: x[0] and x[1], x[2] and x[3], ...
   // * constraints are set for pairs of variables, i.e. each constraint involves
   //   only pair of adjacent variables (x0/x1, x2/x3, x4/x5 and so on), and each
   //   pair of variables has at most one constraint which binds them
   // * for variables u and v following kinds of constraints can be randomly set:
   //   * CKind == 0      no constraint
   //   * CKind == 1      boundary equality constraint:    u == a, v == b
   //   * CKind == 2      boundary inequality constraint:  a0 <= u <= b0, a1 <= v <= b1
   //   * CKind == 3      linear equality constraint:      a*u+b*v  = c
   //   * CKind == 4      linear inequality constraint:    a*u+b*v <= c
   //   * CKind == 5      nonlinear equality constraint:   u^2+v^2  = 1
   //   * CKind == 6      nonlinear inequality constraint: u^2+v^2 <= 1
   // * it is relatively easy to calculated projected gradient for such problem
      aulits = 50;
      rho = 200.0;
      tolx = 0.0005;
      tolg = 0.005;
      n = 20;
      n2 = n / 2;
      for (pass = 1; pass <= 5; pass++) {
         for (prectype = 1; prectype <= 2; prectype++) {
         // Generate well-conditioned problem with unit scale
            spdmatrixrndcond(n, 1.0E2, &fulla);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            ae_matrix_set_length(&c, n, n + 1);
            ae_vector_set_length(&ct, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&ckind, n2);
            ae_vector_set_length(&rnlc, n2);
            cntbc = 0;
            cntlc = 0;
            cntnlec = 0;
            cntnlic = 0;
            for (i = 0; i < n; i++) {
               bndl.xR[i] = -INFINITY;
               bndu.xR[i] = +INFINITY;
               x0.xR[i] = hqrndnormal(&rs);
               b.xR[i] = 10 * hqrndnormal(&rs);
            }
            for (i = 0; i < n2; i++) {
               ckind.xZ[i] = hqrnduniformi(&rs, 7);
               rnlc.xR[i] = 0.0;
               if (ckind.xZ[i] == 0) {
               // Unconstrained
                  continue;
               }
               if (ckind.xZ[i] == 1) {
               // Bound equality constrained
                  bndl.xR[2 * i] = hqrnduniformr(&rs) - 0.5;
                  bndu.xR[2 * i] = bndl.xR[2 * i];
                  bndl.xR[2 * i + 1] = hqrnduniformr(&rs) - 0.5;
                  bndu.xR[2 * i + 1] = bndl.xR[2 * i + 1];
                  cntbc++;
                  continue;
               }
               if (ckind.xZ[i] == 2) {
               // Bound inequality constrained
                  bndl.xR[2 * i] = hqrnduniformr(&rs) - 0.5;
                  bndu.xR[2 * i] = bndl.xR[2 * i] + 0.5;
                  bndl.xR[2 * i + 1] = hqrnduniformr(&rs) - 0.5;
                  bndu.xR[2 * i + 1] = bndl.xR[2 * i + 1] + 0.5;
                  cntbc++;
                  continue;
               }
               if (ckind.xZ[i] == 3) {
               // Linear equality constrained
                  for (j = 0; j <= n; j++) {
                     c.xyR[cntlc][j] = 0.0;
                  }
                  vx = hqrnduniformr(&rs) - 0.5;
                  vy = hqrnduniformr(&rs) - 0.5;
                  c.xyR[cntlc][2 * i] = vx;
                  c.xyR[cntlc][2 * i + 1] = vy;
                  c.xyR[cntlc][n] = hqrnduniformr(&rs) - 0.5;
                  ct.xZ[cntlc] = 0;
                  cntlc++;
                  continue;
               }
               if (ckind.xZ[i] == 4) {
               // Linear inequality constrained
                  for (j = 0; j <= n; j++) {
                     c.xyR[cntlc][j] = 0.0;
                  }
                  vx = hqrnduniformr(&rs) - 0.5;
                  vy = hqrnduniformr(&rs) - 0.5;
                  c.xyR[cntlc][2 * i] = vx;
                  c.xyR[cntlc][2 * i + 1] = vy;
                  c.xyR[cntlc][n] = hqrnduniformr(&rs) - 0.5;
                  ct.xZ[cntlc] = -1;
                  cntlc++;
                  continue;
               }
               if (ckind.xZ[i] == 5) {
               // Nonlinear equality constrained
                  rnlc.xR[i] = 0.5 + hqrnduniformr(&rs);
                  cntnlec++;
                  continue;
               }
               if (ckind.xZ[i] == 6) {
               // Nonlinear inequality constrained
                  rnlc.xR[i] = 0.5 + hqrnduniformr(&rs);
                  cntnlic++;
                  continue;
               }
               ae_assert(false, "Assertion failed");
            }
         // Solve problem
            minnlccreate(n, &x0, &state);
            if (solvertype == 0) {
               minnlcsetalgoaul(&state, rho, aulits);
               minnlcsetcond(&state, 1.0E-7, 0);
               if (prectype == 0) {
                  minnlcsetprecinexact(&state);
               }
               if (prectype == 1) {
                  minnlcsetprecexactlowrank(&state, 0);
               }
               if (prectype == 2) {
                  minnlcsetprecexactrobust(&state, 0);
               }
            } else {
               if (solvertype == 1) {
                  minnlcsetalgoslp(&state);
                  minnlcsetcond(&state, 1.0E-6, 0);
               } else {
                  if (solvertype == 2) {
                     minnlcsetalgosqp(&state);
                     minnlcsetcond(&state, 1.0E-6, 0);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            }
            minnlcsetbc(&state, &bndl, &bndu);
            minnlcsetlc(&state, &c, &ct, cntlc);
            minnlcsetnlc(&state, cntnlec, cntnlic);
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
            }
            while (minnlciteration(&state))
               if (state.needfij) {
               // Evaluate target function
                  state.fi.xR[0] = 0.0;
                  for (i = 0; i < n; i++) {
                     state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                     state.j.xyR[0][i] = b.xR[i];
                     for (j = 0; j < n; j++) {
                        state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                        state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                     }
                  }
               // Evaluate constraint functions
                  knlec = 1;
                  knlic = 1 + cntnlec;
                  for (i = 0; i < n2; i++) {
                     if (ckind.xZ[i] == 5) {
                        state.fi.xR[knlec] = 0.0;
                        for (j = 0; j < n; j++) {
                           state.j.xyR[knlec][j] = 0.0;
                        }
                        state.fi.xR[knlec] = sqr(state.x.xR[2 * i]) + sqr(state.x.xR[2 * i + 1]) - rnlc.xR[i];
                        state.j.xyR[knlec][2 * i] = 2 * state.x.xR[2 * i];
                        state.j.xyR[knlec][2 * i + 1] = 2 * state.x.xR[2 * i + 1];
                        knlec++;
                        continue;
                     }
                     if (ckind.xZ[i] == 6) {
                        state.fi.xR[knlic] = 0.0;
                        for (j = 0; j < n; j++) {
                           state.j.xyR[knlic][j] = 0.0;
                        }
                        state.fi.xR[knlic] = sqr(state.x.xR[2 * i]) + sqr(state.x.xR[2 * i + 1]) - rnlc.xR[i];
                        state.j.xyR[knlic][2 * i] = 2 * state.x.xR[2 * i];
                        state.j.xyR[knlic][2 * i + 1] = 2 * state.x.xR[2 * i + 1];
                        knlic++;
                        continue;
                     }
                  }
                  ae_assert(knlec == 1 + cntnlec, "Assertion failed");
                  ae_assert(knlic == 1 + cntnlec + cntnlic, "Assertion failed");
               } else ae_assert(false, "Assertion failed");
            minnlcresults(&state, &x1, &rep);
            Ok = Ok && isfinitevector(&x1, n);
            Ok = Ok && rep.terminationtype > 0;
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardresults(&state, &ogrep);
               Ok = Ok && optguardallclear(&ogrep);
            }
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Check feasibility properties
            klc = 0;
            for (i = 0; i < n2; i++) {
               if (ckind.xZ[i] == 0) {
               // Unconstrained
                  continue;
               }
               if (ckind.xZ[i] == 1) {
               // Bound equality constrained
                  Ok = Ok && NearAtR(x1.xR[2 * i], bndl.xR[2 * i], tolx);
                  Ok = Ok && NearAtR(x1.xR[2 * i + 1], bndl.xR[2 * i + 1], tolx);
                  continue;
               }
               if (ckind.xZ[i] == 2) {
               // Bound inequality constrained
                  Ok = Ok && x1.xR[2 * i] >= bndl.xR[2 * i] - tolx;
                  Ok = Ok && x1.xR[2 * i] <= bndu.xR[2 * i] + tolx;
                  Ok = Ok && x1.xR[2 * i + 1] >= bndl.xR[2 * i + 1] - tolx;
                  Ok = Ok && x1.xR[2 * i + 1] <= bndu.xR[2 * i + 1] + tolx;
                  continue;
               }
               if (ckind.xZ[i] == 3) {
               // Linear equality constrained
                  v = x1.xR[2 * i] * c.xyR[klc][2 * i] + x1.xR[2 * i + 1] * c.xyR[klc][2 * i + 1] - c.xyR[klc][n];
                  Ok = Ok && SmallAtR(v, tolx);
                  klc++;
                  continue;
               }
               if (ckind.xZ[i] == 4) {
               // Linear inequality constrained
                  v = x1.xR[2 * i] * c.xyR[klc][2 * i] + x1.xR[2 * i + 1] * c.xyR[klc][2 * i + 1] - c.xyR[klc][n];
                  Ok = Ok && v <= tolx;
                  klc++;
                  continue;
               }
               if (ckind.xZ[i] == 5) {
               // Nonlinear equality constrained
                  v = sqr(x1.xR[2 * i]) + sqr(x1.xR[2 * i + 1]) - rnlc.xR[i];
                  Ok = Ok && SmallAtR(v, tolx);
                  continue;
               }
               if (ckind.xZ[i] == 6) {
               // Nonlinear inequality constrained
                  v = sqr(x1.xR[2 * i]) + sqr(x1.xR[2 * i + 1]) - rnlc.xR[i];
                  Ok = Ok && v <= tolx;
                  continue;
               }
               ae_assert(false, "Assertion failed");
            }
         // Test - calculate scaled constrained gradient at solution,
         // check its norm.
            gnorm2 = 0.0;
            rawgnorm2 = 0.0;
            ae_vector_set_length(&g, n);
            for (i = 0; i < n; i++) {
               v = b.xR[i];
               for (j = 0; j < n; j++) {
                  v += fulla.xyR[i][j] * x1.xR[j];
               }
               g.xR[i] = v;
               rawgnorm2 += v * v;
            }
            klc = 0;
            for (i = 0; i < n2; i++) {
               if (ckind.xZ[i] == 0) {
               // Unconstrained
                  gnorm2 += sqr(g.xR[2 * i]) + sqr(g.xR[2 * i + 1]);
                  Ok = Ok && gnorm2 <= sqr(tolg) * rmax2(rawgnorm2, 1.0);
                  continue;
               }
               if (ckind.xZ[i] == 1) {
               // Bound equality constrained, unconditionally set gradient to zero
                  g.xR[2 * i] = 0.0;
                  g.xR[2 * i + 1] = 0.0;
                  gnorm2 += sqr(g.xR[2 * i]) + sqr(g.xR[2 * i + 1]);
                  Ok = Ok && gnorm2 <= sqr(tolg) * rmax2(rawgnorm2, 1.0);
                  continue;
               }
               if (ckind.xZ[i] == 2) {
               // Bound inequality constrained, conditionally set gradient to zero
               // (when constraint is active)
                  if (x1.xR[2 * i] < bndl.xR[2 * i] + tolx || x1.xR[2 * i] > bndu.xR[2 * i] - tolx) {
                     g.xR[2 * i] = 0.0;
                  }
                  if (x1.xR[2 * i + 1] < bndl.xR[2 * i + 1] + tolx || x1.xR[2 * i + 1] > bndu.xR[2 * i + 1] - tolx) {
                     g.xR[2 * i + 1] = 0.0;
                  }
                  gnorm2 += sqr(g.xR[2 * i]) + sqr(g.xR[2 * i + 1]);
                  Ok = Ok && gnorm2 <= sqr(tolg) * rmax2(rawgnorm2, 1.0);
                  continue;
               }
               if (ckind.xZ[i] == 3) {
               // Linear equality constrained, unconditionally project gradient into
               // equality constrained subspace
                  v = g.xR[2 * i] * c.xyR[klc][2 * i] + g.xR[2 * i + 1] * c.xyR[klc][2 * i + 1];
                  vv = sqr(c.xyR[klc][2 * i]) + sqr(c.xyR[klc][2 * i + 1]);
                  g.xR[2 * i] -= c.xyR[klc][2 * i] * (v / vv);
                  g.xR[2 * i + 1] -= c.xyR[klc][2 * i + 1] * (v / vv);
                  klc++;
                  gnorm2 += sqr(g.xR[2 * i]) + sqr(g.xR[2 * i + 1]);
                  Ok = Ok && gnorm2 <= sqr(tolg) * rmax2(rawgnorm2, 1.0);
                  continue;
               }
               if (ckind.xZ[i] == 4) {
               // Linear inequality constrained, conditionally project gradient
               // (when constraint is active)
                  v = x1.xR[2 * i] * c.xyR[klc][2 * i] + x1.xR[2 * i + 1] * c.xyR[klc][2 * i + 1] - c.xyR[klc][n];
                  if (v > -tolx) {
                     v = g.xR[2 * i] * c.xyR[klc][2 * i] + g.xR[2 * i + 1] * c.xyR[klc][2 * i + 1];
                     vv = sqr(c.xyR[klc][2 * i]) + sqr(c.xyR[klc][2 * i + 1]);
                     g.xR[2 * i] -= c.xyR[klc][2 * i] * (v / vv);
                     g.xR[2 * i + 1] -= c.xyR[klc][2 * i + 1] * (v / vv);
                  }
                  klc++;
                  gnorm2 += sqr(g.xR[2 * i]) + sqr(g.xR[2 * i + 1]);
                  Ok = Ok && gnorm2 <= sqr(tolg) * rmax2(rawgnorm2, 1.0);
                  continue;
               }
               if (ckind.xZ[i] == 5) {
               // Nonlinear equality constrained, unconditionally project gradient
               //
               // NOTE: here we rely on the fact that corresponding components of X
               //       sum to one.
                  v = coalesce(sqrt(sqr(x1.xR[2 * i]) + sqr(x1.xR[2 * i + 1])), 1.0);
                  vx = x1.xR[2 * i] / v;
                  vy = x1.xR[2 * i + 1] / v;
                  v = g.xR[2 * i] * vx + g.xR[2 * i + 1] * vy;
                  g.xR[2 * i] -= vx * v;
                  g.xR[2 * i + 1] -= vy * v;
                  gnorm2 += sqr(g.xR[2 * i]) + sqr(g.xR[2 * i + 1]);
                  Ok = Ok && gnorm2 <= sqr(tolg) * rmax2(rawgnorm2, 1.0);
                  continue;
               }
               if (ckind.xZ[i] == 6) {
               // Nonlinear inequality constrained, conditionally project gradient
               // (when constraint is active)
               //
               // NOTE: here we rely on the fact that corresponding components of X
               //       sum to one.
                  v = sqr(x1.xR[2 * i]) + sqr(x1.xR[2 * i + 1]) - rnlc.xR[i];
                  if (v > -tolx) {
                     v = coalesce(sqrt(sqr(x1.xR[2 * i]) + sqr(x1.xR[2 * i + 1])), 1.0);
                     vx = x1.xR[2 * i] / v;
                     vy = x1.xR[2 * i + 1] / v;
                     v = g.xR[2 * i] * vx + g.xR[2 * i + 1] * vy;
                     g.xR[2 * i] -= vx * v;
                     g.xR[2 * i + 1] -= vy * v;
                  }
                  gnorm2 += sqr(g.xR[2 * i]) + sqr(g.xR[2 * i + 1]);
                  Ok = Ok && gnorm2 <= sqr(tolg) * rmax2(rawgnorm2, 1.0);
                  continue;
               }
               ae_assert(false, "Assertion failed");
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function performs additional tests
static bool testminnlcunit_testother() {
   ae_frame _frame_block;
   double v;
   double h;
   double fl;
   double fr;
   double fl2;
   double fr2;
   double dfl;
   double dfr;
   double dfl2;
   double dfr2;
   double d2fl;
   double d2fr;
   double d2fl2;
   double d2fr2;
   double f0;
   double df;
   double d2f;
   double ndf;
   double nd2f;
   double dtol;
   double diffstep;
   double rho;
   ae_int_t aulits;
   double tolx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   double condv;
   ae_int_t nlbfgs;
   ae_int_t nexactlowrank;
   ae_int_t nexactrobust;
   ae_int_t nnone;
   ae_int_t prectype;
   ae_int_t ctype;
   ae_int_t trialidx;
   ae_int_t blocksize;
   ae_int_t blockcnt;
   ae_int_t maxits;
   ae_int_t spoiliteration;
   ae_int_t stopiteration;
   ae_int_t spoilvar;
   double spoilval;
   ae_int_t pass;
   ae_int_t solvertype;
   ae_int_t badidx0;
   ae_int_t badidx1;
   ae_int_t nlec;
   ae_int_t nlic;
   double ss;
   ae_int_t stopcallidx;
   ae_int_t callidx;
   bool terminationrequested;
   bool firstrep;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minnlcstate, state);
   NewObj(minnlcreport, rep);
   NewObj(optguardreport, ogrep);
   NewVector(s, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(x3, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(xu, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   hqrndrandomize(&rs);
// Test equality penalty function (correctly calculated and smooth)
   h = 1.0E-4;
   v = -0.98;
   dtol = 1.0E-3;
   while (v <= 0.98) {
   // Test numerical derivative; this test also checks continuity of the
   // function
      minnlcequalitypenaltyfunction(v - 2 * h, &fl2, &dfl2, &d2fl2);
      minnlcequalitypenaltyfunction(v - h, &fl, &dfl, &d2fl);
      minnlcequalitypenaltyfunction(v + h, &fr, &dfr, &d2fr);
      minnlcequalitypenaltyfunction(v + 2 * h, &fr2, &dfr2, &d2fr2);
      minnlcequalitypenaltyfunction(v, &f0, &df, &d2f);
      ndf = (-fr2 + 8 * fr - 8 * fl + fl2) / (12 * h);
      Ok = Ok && NearAtR(ndf, df, dtol * rmax2(fabs(ndf), 1.0));
      nd2f = (-dfr2 + 8 * dfr - 8 * dfl + dfl2) / (12 * h);
      Ok = Ok && NearAtR(nd2f, d2f, dtol * rmax2(fabs(nd2f), 1.0));
   // Next point
      v += h;
   }
   minnlcequalitypenaltyfunction(0.0, &f0, &df, &d2f);
   Ok = Ok && f0 == 0.0;
   Ok = Ok && df == 0.0;
// Test inequality penalty function (correctly calculated and smooth)
   h = 1.0E-4;
   v = 0.02;
   dtol = 1.0E-3;
   while (v <= 2.00) {
   // Test numerical derivative; this test also checks continuity of the
   // function
      minnlcinequalityshiftfunction(v - 2 * h, &fl2, &dfl2, &d2fl2);
      minnlcinequalityshiftfunction(v - h, &fl, &dfl, &d2fl);
      minnlcinequalityshiftfunction(v + h, &fr, &dfr, &d2fr);
      minnlcinequalityshiftfunction(v + 2 * h, &fr2, &dfr2, &d2fr2);
      minnlcinequalityshiftfunction(v, &f0, &df, &d2f);
      ndf = (-fr2 + 8 * fr - 8 * fl + fl2) / (12 * h);
      Ok = Ok && NearAtR(ndf, df, dtol * rmax2(fabs(ndf), 1.0));
      nd2f = (-dfr2 + 8 * dfr - 8 * dfl + dfl2) / (12 * h);
      Ok = Ok && NearAtR(nd2f, d2f, dtol * rmax2(fabs(nd2f), 1.0));
   // Next point
      v += h;
   }
   minnlcinequalityshiftfunction(1.0, &f0, &df, &d2f);
   Ok = Ok && SmallAtR(f0, 1.0E-6);
   Ok = Ok && NearAtR(df, -1.0, 1.0E-6);
// Test different properties shared by all solvers
   for (solvertype = 0; solvertype <= testminnlcunit_maxsolvertype; solvertype++) {
   // Test location reports
      aulits = 50;
      rho = 200.0;
      n = 2;
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&xlast, n);
      x0.xR[0] = 0.1 + 0.1 * hqrnduniformr(&rs);
      x0.xR[1] = 0.2 + 0.1 * hqrnduniformr(&rs);
      xlast.xR[0] = 0.0;
      xlast.xR[1] = 0.0;
      firstrep = true;
      minnlccreate(n, &x0, &state);
      if (solvertype == 0) {
         minnlcsetalgoaul(&state, rho, aulits);
      } else {
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
      }
      minnlcsetcond(&state, 1.0E-7, 0);
      minnlcsetnlc(&state, 0, 1);
      minnlcsetxrep(&state, true);
      while (minnlciteration(&state))
         if (state.needfij) {
            state.fi.xR[0] = sqr(state.x.xR[0] - 1) + sqr(state.x.xR[1] - 1);
            state.j.xyR[0][0] = 2 * (state.x.xR[0] - 1);
            state.j.xyR[0][1] = 2 * (state.x.xR[1] - 1);
            state.fi.xR[1] = sqr(state.x.xR[0]) + sqr(state.x.xR[1]) - 1;
            state.j.xyR[1][0] = 2 * state.x.xR[0];
            state.j.xyR[1][1] = 2 * state.x.xR[1];
         } else if (state.xupdated) {
         // If first point reported, compare with initial one
            if (firstrep) {
               Ok = Ok && NearAtR(state.x.xR[0], x0.xR[0], 1.0E4 * machineepsilon);
               Ok = Ok && NearAtR(state.x.xR[1], x0.xR[1], 1.0E4 * machineepsilon);
            }
            firstrep = false;
         // Save last point
            xlast.xR[0] = state.x.xR[0];
            xlast.xR[1] = state.x.xR[1];
         } else ae_assert(false, "Assertion failed");
      minnlcresults(&state, &x1, &rep);
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      Ok = Ok && NearAtR(x1.xR[0], xlast.xR[0], 1.0E4 * machineepsilon);
      Ok = Ok && NearAtR(x1.xR[1], xlast.xR[1], 1.0E4 * machineepsilon);
   // Test numerical differentiation
      aulits = 50;
      rho = 200.0;
      tolx = 0.001;
      diffstep = 0.0001;
      n = 2;
      ae_vector_set_length(&x0, n);
      x0.xR[0] = 0.1;
      x0.xR[1] = 0.2;
      minnlccreatef(n, &x0, diffstep, &state);
      if (solvertype == 0) {
         minnlcsetalgoaul(&state, rho, aulits);
      } else {
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
      }
      minnlcsetcond(&state, 1.0E-7, 0);
      minnlcsetnlc(&state, 0, 1);
      while (minnlciteration(&state))
         if (state.needfi) {
            state.fi.xR[0] = sqr(state.x.xR[0] - 1) + sqr(state.x.xR[1] - 1);
            state.fi.xR[1] = sqr(state.x.xR[0]) + sqr(state.x.xR[1]) - 1;
         } else ae_assert(false, "Assertion failed");
      minnlcresults(&state, &x1, &rep);
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      Ok = Ok && NearAtR(x1.xR[0], sqrt(0.5), tolx);
      Ok = Ok && NearAtR(x1.xR[1], sqrt(0.5), tolx);
   // Check handling of general linear constraints: solve linearly
   // constrained twice, first time with constraints posed as linear
   // ones, second time with constraints posed as nonlinear ones.
   //
   // Linear constraints are normalized because we know that optimizer
   // normalizes them internally.
   //
   // We perform small amount of inner iterations - just 3 steps.
   // Only one outer iteration is performed. Such small number of
   // iterations allows to reduce influence of round-off errors
   // and compare results returned by different control paths within
   // optimizer (control path for linear constraints and one for
   // nonlinear constraints).
   //
   // We test following kinds of preconditioners:
   // * "none"
   // * "exact low rank", restart frequency is 1
   // * "exact robust", restart frequency is 1
   // Inexact LBFGS-based preconditioner is not tested because its
   // behavior greatly depends on order of equations.
      n = 15;
      k = 5;
      maxits = 1;
      ae_vector_set_length(&x0, n);
      ae_matrix_set_length(&c, k, n + 1);
      ae_vector_set_length(&ct, k);
      for (prectype = 0; prectype <= 2; prectype++) {
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
         }
         for (i = 0; i < k; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
               v += sqr(c.xyR[i][j]);
            }
            v = 1 / sqrt(v);
            ae_v_muld(c.xyR[i], 1, n, v);
            v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
         }
         minnlccreate(n, &x0, &state);
         minnlcsetcond(&state, 0.0, maxits);
         if (solvertype == 0) {
            aulits = 1;
            rho = 1.0E3;
            minnlcsetalgoaul(&state, rho, aulits);
            if (prectype == 0) {
               minnlcsetprecnone(&state);
            }
            if (prectype == 1) {
               minnlcsetprecexactlowrank(&state, 1);
            }
            if (prectype == 2) {
               minnlcsetprecexactrobust(&state, 1);
            }
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetlc(&state, &c, &ct, k);
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += sqr(state.x.xR[i]);
                  state.j.xyR[0][i] = 2 * state.x.xR[i];
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            aulits = 1;
            rho = 1.0E3;
            minnlcsetalgoaul(&state, rho, aulits);
            if (prectype == 0) {
               minnlcsetprecnone(&state);
            }
            if (prectype == 1) {
               minnlcsetprecexactlowrank(&state, 1);
            }
            if (prectype == 2) {
               minnlcsetprecexactrobust(&state, 1);
            }
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 0.0, maxits);
         minnlcsetnlc(&state, k, 0);
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += sqr(state.x.xR[i]);
                  state.j.xyR[0][i] = 2 * state.x.xR[i];
               }
               for (i = 0; i < k; i++) {
                  v = ae_v_dotproduct(c.xyR[i], 1, state.x.xR, 1, n);
                  state.fi.xR[1 + i] = v - c.xyR[i][n];
                  ae_v_move(state.j.xyR[1 + i], 1, c.xyR[i], 1, n);
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x2, &rep);
         Ok = Ok && isfinitevector(&x2, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && NearAtR(x1.xR[i], x2.xR[i], 1.0E-3);
         }
      }
   // Test integrity checks for NAN/INF:
   // * algorithm solves optimization problem, which is normal for some time (quadratic)
   // * after 5-th step we choose random component of gradient and consistently spoil
   //   it by NAN or INF.
   // * we check that correct termination code is returned (-8)
      n = 100;
      for (pass = 1; pass <= 10; pass++) {
         spoiliteration = 5;
         stopiteration = 8;
         if (hqrndnormal(&rs) > 0.0) {
         // Gradient can be spoiled by +INF, -INF, NAN
            spoilvar = hqrnduniformi(&rs, n);
            i = hqrnduniformi(&rs, 3);
            spoilval = NAN;
            if (i == 0) {
               spoilval = -INFINITY;
            }
            if (i == 1) {
               spoilval = +INFINITY;
            }
         } else {
         // Function value can be spoiled only by NAN
         // (+INF can be recognized as legitimate value during optimization)
            spoilvar = -1;
            spoilval = NAN;
         }
         spdmatrixrndcond(n, 1.0E5, &fulla);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            x0.xR[i] = hqrndnormal(&rs);
         }
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            aulits = 5;
            rho = 1.0E3;
            minnlcsetalgoaul(&state, rho, aulits);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 0.0, stopiteration);
         minnlcsetxrep(&state, true);
         k = -1;
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
               if (k >= spoiliteration) {
                  if (spoilvar < 0) {
                     state.fi.xR[0] = spoilval;
                  } else {
                     state.j.xyR[0][spoilvar] = spoilval;
                  }
               }
            } else if (state.xupdated) {
               k++;
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype == -8;
      }
   // Test that optimizer respects box constraints in all
   // intermediate points:
   // * test that analytic Jacobian respects them
   // * test that numerical Jacobian respects them
   //
   // NOTE: we skip SolverType == 0 (AUL) because AUL optimizer
   //       does not provide such guarantee
      if (solvertype != 0) {
         n = 10;
         spdmatrixrndcond(n, 1.0E3, &fulla);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            x0.xR[i] = hqrndnormal(&rs);
            if (hqrndnormal(&rs) > 0.0) {
               bndl.xR[i] = 0.0;
               bndu.xR[i] = +INFINITY;
            } else {
               bndl.xR[i] = -INFINITY;
               bndu.xR[i] = 0.0;
            }
         }
      // Check analytic Jacobian
         minnlccreate(n, &x0, &state);
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
         minnlcsetbc(&state, &bndl, &bndu);
         minnlcsetcond(&state, 1.0E-8, 0);
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  Ok = Ok && state.x.xR[i] >= bndl.xR[i];
                  Ok = Ok && state.x.xR[i] <= bndu.xR[i];
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
      // Check numerical Jacobian
         minnlccreatef(n, &x0, 1.0E-4, &state);
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
         minnlcsetbc(&state, &bndl, &bndu);
         minnlcsetcond(&state, 1.0E-8, 0);
         while (minnlciteration(&state))
            if (state.needfi) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  Ok = Ok && state.x.xR[i] >= bndl.xR[i];
                  Ok = Ok && state.x.xR[i] <= bndu.xR[i];
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
      }
   // Test constraint violation reports for completely unconstrained
   // problems and problems with all constraints being satisfied exactly
      tolx = 0.01;
      for (pass = 1; pass <= 10; pass++) {
         n = 1 + hqrnduniformi(&rs, 5);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
         }
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 10);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 1.0E-7, 200);
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += pow(state.x.xR[i], 4.0);
                  state.j.xyR[0][i] = 4 * pow(state.x.xR[i], 3.0);
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
      // Check solution itself
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && SmallAtR(x1.xR[i], tolx);
         }
      // Check constraint violation reports
         Ok = Ok && rep.bcerr == 0.0;
         Ok = Ok && rep.bcidx == -1;
         Ok = Ok && rep.lcerr == 0.0;
         Ok = Ok && rep.lcidx == -1;
         Ok = Ok && rep.nlcerr == 0.0;
         Ok = Ok && rep.nlcidx == -1;
      }
      for (pass = 1; pass <= 10; pass++) {
         n = 1 + hqrnduniformi(&rs, 5);
         k = 1 + hqrnduniformi(&rs, 5);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xu, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
            xu.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = -1000.0;
            bndu.xR[i] = 1000.0;
         }
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
            }
            if (hqrndnormal(&rs) > 0.0) {
               c.xyR[i][n] = 1000.0;
               ct.xZ[i] = -1;
            } else {
               c.xyR[i][n] = -1000.0;
               ct.xZ[i] = 1;
            }
         }
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 20);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetbc(&state, &bndl, &bndu);
         minnlcsetlc(&state, &c, &ct, k);
         minnlcsetcond(&state, 1.0E-7, 0);
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += pow(state.x.xR[i] - xu.xR[i], 2.0);
                  state.j.xyR[0][i] = 2 * (state.x.xR[i] - xu.xR[i]);
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
      // Check solution itself, calculate reference violation values
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Check constraint violation reports
         Ok = Ok && rep.bcerr == 0.0;
         Ok = Ok && rep.bcidx == -1;
         Ok = Ok && rep.lcerr == 0.0;
         Ok = Ok && rep.lcidx == -1;
         Ok = Ok && rep.nlcerr == 0.0;
         Ok = Ok && rep.nlcidx == -1;
      }
   // Test constraint violation reports for box/linearly constrained
   // problems. We generate a problem which can not satisfy one (and
   // just one) general linear constraint.
      tolx = 0.001;
      for (pass = 1; pass <= 10; pass++) {
      // Formulate problem with inconsistent constraints
         n = 2 + hqrnduniformi(&rs, 5);
         k = 1 + hqrnduniformi(&rs, 5);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xu, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(2.0, hqrndnormal(&rs));
            x0.xR[i] = hqrndnormal(&rs);
            xu.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = -0.5 * hqrnduniformr(&rs) - 0.1;
            bndu.xR[i] = +0.5 * hqrnduniformr(&rs) + 0.1;
         }
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
            }
            if (hqrndnormal(&rs) > 0.0) {
               c.xyR[i][n] = 1000.0;
               ct.xZ[i] = -1;
            } else {
               c.xyR[i][n] = -1000.0;
               ct.xZ[i] = 1;
            }
         }
         ae_assert(n >= 2, "NLCTest: integrity check failed");
         badidx0 = hqrnduniformi(&rs, k);
         badidx1 = hqrnduniformi(&rs, n);
         for (j = 0; j < n; j++) {
            c.xyR[badidx0][j] = 0.0;
         }
         for (j = 0; j < k; j++) {
            c.xyR[j][badidx1] = 0.0;
         }
         c.xyR[badidx0][badidx1] = 1.0;
         c.xyR[badidx0][n] = (double)(10 * (2 * hqrnduniformi(&rs, 2) - 1));
         if (hqrndnormal(&rs) > 0.0) {
            ct.xZ[badidx0] = 0;
         } else {
            ct.xZ[badidx0] = sign(c.xyR[badidx0][n]);
         }
      // Create and try to solve
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 20);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetbc(&state, &bndl, &bndu);
         minnlcsetlc(&state, &c, &ct, k);
         minnlcsetscale(&state, &s);
         minnlcsetcond(&state, 1.0E-7, 0);
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += pow(state.x.xR[i] - xu.xR[i], 2.0);
                  state.j.xyR[0][i] = 2 * (state.x.xR[i] - xu.xR[i]);
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
      // Check solution itself, calculate reference violation values
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Check constraint violation reports
         if (rep.bcerr > 0.0) {
            v = rmax2(bndl.xR[badidx1] - x1.xR[badidx1], x1.xR[badidx1] - bndu.xR[badidx1]);
            v /= s.xR[badidx1];
            Ok = Ok && rep.bcidx == badidx1;
            Ok = Ok && NearAtR(rep.bcerr, v, 1.0E3 * machineepsilon);
         } else {
            Ok = Ok && rep.bcerr == 0.0;
            Ok = Ok && rep.bcidx == -1;
            Ok = Ok && x1.xR[badidx1] >= bndl.xR[badidx1] && x1.xR[badidx1] <= bndu.xR[badidx1];
         }
         Ok = Ok && rep.lcidx == badidx0;
         Ok = Ok && NearAtR(rep.lcerr, fabs(x1.xR[badidx1] - c.xyR[badidx0][n]) / s.xR[badidx1], 1.0E3 * machineepsilon);
         Ok = Ok && rep.nlcerr == 0.0;
         Ok = Ok && rep.nlcidx == -1;
      }
   // Test constraint violation reports for box/nonlinearly constrained
   // problems. We generate a problem which can not satisfy one (and
   // just one) general linear constraint.
   //
   // NOTE: it is important to have N >= NLEC+NLIC
      tolx = 0.001;
      for (pass = 1; pass <= 10; pass++) {
      // Formulate problem with inconsistent constraints
         nlec = 1 + hqrnduniformi(&rs, 5);
         nlic = 1 + hqrnduniformi(&rs, 5);
         k = nlec + nlic;
         n = k + hqrnduniformi(&rs, 5);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xu, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_matrix_set_length(&c, k, n + 1);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(2.0, hqrndnormal(&rs));
            x0.xR[i] = hqrndnormal(&rs);
            xu.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = -0.5 * hqrnduniformr(&rs) - 0.1;
            bndu.xR[i] = +0.5 * hqrnduniformr(&rs) + 0.1;
         }
         for (i = 0; i < nlec; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = 0.0;
            }
            c.xyR[i][i] = 1.0;
            c.xyR[i][n] = bndl.xR[i] + hqrnduniformr(&rs) * (bndu.xR[i] - bndl.xR[i]);
         }
         for (i = nlec; i < k; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = 0.0;
            }
            c.xyR[i][i] = 1.0;
            c.xyR[i][n] = 1000.0;
         }
         badidx0 = hqrnduniformi(&rs, k);
         if (badidx0 < nlec) {
            if (hqrndnormal(&rs) > 0.0) {
               c.xyR[badidx0][n] = bndu.xR[badidx0] + 10;
            } else {
               c.xyR[badidx0][n] = bndl.xR[badidx0] - 10;
            }
         } else {
            c.xyR[badidx0][n] = -1000.0;
         }
      // Create and try to solve
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 20);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetbc(&state, &bndl, &bndu);
         minnlcsetnlc(&state, nlec, nlic);
         minnlcsetscale(&state, &s);
         minnlcsetcond(&state, 1.0E-7, 0);
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += pow(state.x.xR[i] - xu.xR[i], 2.0);
                  state.j.xyR[0][i] = 2 * (state.x.xR[i] - xu.xR[i]);
               }
               for (i = 0; i < k; i++) {
                  state.fi.xR[i + 1] = -c.xyR[i][n];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[i + 1] += c.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[i + 1][j] = c.xyR[i][j];
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
      // Check solution itself, calculate reference violation values
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Check constraint violation reports
         if (badidx0 < nlec) {
            if (rep.bcerr > 0.0) {
               v = rmax2(bndl.xR[badidx0] - x1.xR[badidx0], x1.xR[badidx0] - bndu.xR[badidx0]);
               v /= s.xR[badidx0];
               Ok = Ok && rep.bcidx == badidx0;
               Ok = Ok && NearAtR(rep.bcerr, v, 1.0E3 * machineepsilon);
            } else {
               Ok = Ok && rep.bcerr == 0.0;
               Ok = Ok && rep.bcidx == -1;
               Ok = Ok && x1.xR[badidx0] >= bndl.xR[badidx0] && x1.xR[badidx0] <= bndu.xR[badidx0];
            }
         }
         Ok = Ok && rep.lcidx == -1;
         Ok = Ok && rep.lcerr == 0.0;
         Ok = Ok && rep.nlcidx == badidx0;
         Ok = Ok && NearAtR(rep.nlcerr, fabs(x1.xR[badidx0] - c.xyR[badidx0][n]), 1.0E4 * machineepsilon);
      }
   // Test support for termination requests:
   // * to terminate with correct return code = 8
   // * to return point which was "current" at the moment of termination
      for (pass = 1; pass <= 50; pass++) {
         n = 3;
         ss = 100.0;
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xlast, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 6.0 + hqrnduniformr(&rs);
         }
         stopcallidx = hqrnduniformi(&rs, 20);
         maxits = 25;
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 20);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 0.0, maxits);
         minnlcsetxrep(&state, true);
         callidx = 0;
         terminationrequested = false;
         ae_v_move(xlast.xR, 1, x0.xR, 1, n);
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = ss * sqr(exp(state.x.xR[0]) - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
               state.j.xyR[0][0] = 2 * ss * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[2] - state.x.xR[0]) * (-1);
               state.j.xyR[0][1] = 2 * state.x.xR[1];
               state.j.xyR[0][2] = 2 * (state.x.xR[2] - state.x.xR[0]);
               if (callidx == stopcallidx) {
                  minnlcrequesttermination(&state);
                  terminationrequested = true;
               }
               callidx++;
            } else if (state.xupdated) {
               if (!terminationrequested) {
                  ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype == 8;
         for (i = 0; i < n; i++) {
            Ok = Ok && x1.xR[i] == xlast.xR[i];
         }
      }
   }
// AUL-specific test.
//
// Test preconditioning:
// * compare number of iterations required to solve problem with
//   different preconditioners (LBFGS, exact, none)
// * a set of trials is performed (100 trials)
// * each trial is a solution of boundary/linearly constrained problem
//   (linear constraints may be posed as nonlinear ones) with normalized
//   constraint matrix. Normalization is essential for reproducibility
//   of results .
//
// Outer loop checks handling of different types of constraints
// (posed as linear or nonlinear ones)
   n = 30;
   blocksize = 3;
   blockcnt = 3;
   rho = 1.0E3;
   aulits = 5;
   condv = 1.0E2;
   ae_vector_set_length(&x0, n);
   ae_vector_set_length(&bndl, n);
   ae_vector_set_length(&bndu, n);
   ae_matrix_set_length(&c, blocksize * blockcnt, n + 1);
   ae_vector_set_length(&ct, blocksize * blockcnt);
   for (ctype = 0; ctype <= 1; ctype++) {
   // First, initialize iteration counters
      nlbfgs = 0;
      nexactlowrank = 0;
      nexactrobust = 0;
      nnone = 0;
   // Perform trials
      for (trialidx = 0; trialidx <= 99; trialidx++) {
      // Generate:
      // * boundary constraints BndL/BndU and initial point X0
      // * block-diagonal matrix of linear constraints C such
      //   that X0 is feasible w.r.t. constraints given by C
         for (i = 0; i < n; i++) {
            if (hqrndnormal(&rs) > 0.0) {
               bndl.xR[i] = 0.0;
               bndu.xR[i] = +INFINITY;
               x0.xR[i] = hqrnduniformr(&rs);
            } else {
               bndl.xR[i] = 0.0;
               bndu.xR[i] = 0.0;
               x0.xR[i] = 0.0;
            }
         }
         for (i = 0; i < blocksize * blockcnt; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = 0.0;
            }
         }
         for (k = 0; k < blockcnt; k++) {
            rmatrixrndcond(blocksize, condv, &a);
            for (i = 0; i < blocksize; i++) {
               for (j = 0; j < blocksize; j++) {
                  c.xyR[k * blocksize + i][k * blocksize + j] = a.xyR[i][j];
               }
            }
         }
         for (i = 0; i < blocksize * blockcnt; i++) {
            v = ae_v_dotproduct(c.xyR[i], 1, c.xyR[i], 1, n);
            v = 1 / sqrt(v);
            ae_v_muld(c.xyR[i], 1, n, v);
            v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
         }
      // Test unpreconditioned iteration
         minnlccreate(n, &x0, &state);
         minnlcsetalgoaul(&state, rho, aulits);
         minnlcsetcond(&state, 1.0E-7, 0);
         if (ctype == 0) {
            minnlcsetlc(&state, &c, &ct, blocksize * blockcnt);
         } else {
            minnlcsetnlc(&state, blocksize * blockcnt, 0);
         }
         minnlcsetprecnone(&state);
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += sqr(state.x.xR[i]);
                  state.j.xyR[0][i] = 2 * state.x.xR[i];
               }
               if (ctype == 1) {
                  for (i = 0; i < blocksize * blockcnt; i++) {
                     v = ae_v_dotproduct(c.xyR[i], 1, state.x.xR, 1, n);
                     state.fi.xR[1 + i] = v - c.xyR[i][n];
                     ae_v_move(state.j.xyR[1 + i], 1, c.xyR[i], 1, n);
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         nnone += rep.iterationscount;
      // Test LBFGS preconditioned iteration
         minnlccreate(n, &x0, &state);
         minnlcsetalgoaul(&state, rho, aulits);
         minnlcsetcond(&state, 1.0E-7, 0);
         if (ctype == 0) {
            minnlcsetlc(&state, &c, &ct, blocksize * blockcnt);
         } else {
            minnlcsetnlc(&state, blocksize * blockcnt, 0);
         }
         minnlcsetprecinexact(&state);
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += sqr(state.x.xR[i]);
                  state.j.xyR[0][i] = 2 * state.x.xR[i];
               }
               if (ctype == 1) {
                  for (i = 0; i < blocksize * blockcnt; i++) {
                     v = ae_v_dotproduct(c.xyR[i], 1, state.x.xR, 1, n);
                     state.fi.xR[1 + i] = v - c.xyR[i][n];
                     ae_v_move(state.j.xyR[1 + i], 1, c.xyR[i], 1, n);
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         nlbfgs += rep.iterationscount;
      // Test exact low rank preconditioner
         minnlccreate(n, &x0, &state);
         minnlcsetalgoaul(&state, rho, aulits);
         minnlcsetcond(&state, 1.0E-7, 0);
         if (ctype == 0) {
            minnlcsetlc(&state, &c, &ct, blocksize * blockcnt);
         } else {
            minnlcsetnlc(&state, blocksize * blockcnt, 0);
         }
         minnlcsetprecexactlowrank(&state, 3);
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += sqr(state.x.xR[i]);
                  state.j.xyR[0][i] = 2 * state.x.xR[i];
               }
               if (ctype == 1) {
                  for (i = 0; i < blocksize * blockcnt; i++) {
                     v = ae_v_dotproduct(c.xyR[i], 1, state.x.xR, 1, n);
                     state.fi.xR[1 + i] = v - c.xyR[i][n];
                     ae_v_move(state.j.xyR[1 + i], 1, c.xyR[i], 1, n);
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         nexactlowrank += rep.iterationscount;
      // Test exact robust preconditioner
         minnlccreate(n, &x0, &state);
         minnlcsetalgoaul(&state, rho, aulits);
         minnlcsetcond(&state, 1.0E-7, 0);
         if (ctype == 0) {
            minnlcsetlc(&state, &c, &ct, blocksize * blockcnt);
         } else {
            minnlcsetnlc(&state, blocksize * blockcnt, 0);
         }
         minnlcsetprecexactrobust(&state, 3);
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += sqr(state.x.xR[i]);
                  state.j.xyR[0][i] = 2 * state.x.xR[i];
               }
               if (ctype == 1) {
                  for (i = 0; i < blocksize * blockcnt; i++) {
                     v = ae_v_dotproduct(c.xyR[i], 1, state.x.xR, 1, n);
                     state.fi.xR[1 + i] = v - c.xyR[i][n];
                     ae_v_move(state.j.xyR[1 + i], 1, c.xyR[i], 1, n);
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         nexactrobust += rep.iterationscount;
      }
   // Compare.
   //
   // Preconditioners must be significantly different,
   // with exact being best one, inexact being second,
   // "none" being worst option.
      Ok = Ok && nexactlowrank < 0.9 * nlbfgs;
      Ok = Ok && nexactrobust < 0.9 * nlbfgs;
      Ok = Ok && nlbfgs < 0.9 * nnone;
   }
   ae_frame_leave();
   return Ok;
}

// This function performs tests for fixed bugs
static bool testminnlcunit_testbugs() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t aulits;
   ae_int_t maxits;
   double rho;
   ae_int_t ckind;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t solvertype;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minnlcstate, state);
   NewObj(minnlcreport, rep);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewMatrix(c, 0, 0, DT_REAL);
   hqrndrandomize(&rs);
// Bug description (fixed): sometimes on non-convex problems, when
// Lagrange coefficient for inequality constraint becomes small,
// algorithm performs VERY deep step into infeasible area (step is 1E50),
// which de-stabilizes it and prevents from converging back to feasible area.
//
// Very rare situation, but must be fixed with additional "convexifying" term.
// This test reproduces situation with convexified term turned off, then
// checks that introduction of term solves issue.
//
// We perform three kinds of tests:
// * with box inequality constraint
// * with linear inequality constraint
// * with nonlinear inequality constraint
//
// In all three cases we:
// * first time solve non-convex problem with artificially moved stabilizing
//   point and decreased initial value of Lagrange multiplier.
// * second time we solve problem with good stabilizing point, but zero Lagrange multiplier
// * last time solve same problem, but with default settings
   aulits = 1;
   maxits = 1;
   rho = 100.0;
   n = 1;
   ae_vector_set_length(&x0, n);
   x0.xR[0] = 0.0;
   ae_vector_set_length(&bndl, n);
   ae_vector_set_length(&bndu, n);
   bndl.xR[0] = 0.0;
   bndu.xR[0] = +INFINITY;
   ae_matrix_set_length(&c, 1, 2);
   ae_vector_set_length(&ct, 1);
   c.xyR[0][0] = 1.0;
   c.xyR[0][1] = 0.0;
   ct.xZ[0] = 1;
   for (ckind = 0; ckind <= 2; ckind++) {
      minnlccreate(n, &x0, &state);
      state.stabilizingpoint = -1.0E300;
      state.initialinequalitymultiplier = 1.0E-12;
      minnlcsetalgoaul(&state, rho, aulits);
      minnlcsetcond(&state, 0.0, maxits);
      if (ckind == 0) {
         minnlcsetbc(&state, &bndl, &bndu);
      }
      if (ckind == 1) {
         minnlcsetlc(&state, &c, &ct, 1);
      }
      if (ckind == 2) {
         minnlcsetnlc(&state, 0, 1);
      }
      while (minnlciteration(&state))
         if (state.needfij) {
            state.fi.xR[0] = state.x.xR[0] - sqr(state.x.xR[0]);
            state.j.xyR[0][0] = 1 - 2 * state.x.xR[0];
            if (ckind == 2) {
               state.fi.xR[1] = -state.x.xR[0];
               state.j.xyR[1][0] = -1.0;
            }
         } else ae_assert(false, "Assertion failed");
      minnlcresults(&state, &x1, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      Ok = Ok && x1.xR[0] <= -1.0E6;
      minnlccreate(n, &x0, &state);
      state.stabilizingpoint = -1.0E2;
      state.initialinequalitymultiplier = 1.0E-12;
      minnlcsetalgoaul(&state, rho, aulits);
      minnlcsetcond(&state, 0.0, maxits);
      if (ckind == 0) {
         minnlcsetbc(&state, &bndl, &bndu);
      }
      if (ckind == 1) {
         minnlcsetlc(&state, &c, &ct, 1);
      }
      if (ckind == 2) {
         minnlcsetnlc(&state, 0, 1);
      }
      while (minnlciteration(&state))
         if (state.needfij) {
            state.fi.xR[0] = state.x.xR[0] - sqr(state.x.xR[0]);
            state.j.xyR[0][0] = 1 - 2 * state.x.xR[0];
            if (ckind == 2) {
               state.fi.xR[1] = -state.x.xR[0];
               state.j.xyR[1][0] = -1.0;
            }
         } else ae_assert(false, "Assertion failed");
      minnlcresults(&state, &x1, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      Ok = Ok && x1.xR[0] >= 3 * state.stabilizingpoint;
      minnlccreate(n, &x0, &state);
      minnlcsetalgoaul(&state, rho, aulits);
      minnlcsetcond(&state, 0.0, maxits);
      if (ckind == 0) {
         minnlcsetbc(&state, &bndl, &bndu);
      }
      if (ckind == 1) {
         minnlcsetlc(&state, &c, &ct, 1);
      }
      if (ckind == 2) {
         minnlcsetnlc(&state, 0, 1);
      }
      while (minnlciteration(&state))
         if (state.needfij) {
            state.fi.xR[0] = state.x.xR[0] - sqr(state.x.xR[0]);
            state.j.xyR[0][0] = 1 - 2 * state.x.xR[0];
            if (ckind == 2) {
               state.fi.xR[1] = -state.x.xR[0];
               state.j.xyR[1][0] = -1.0;
            }
         } else ae_assert(false, "Assertion failed");
      minnlcresults(&state, &x1, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      Ok = Ok && x1.xR[0] >= 3 * state.stabilizingpoint;
   }
// This test checks report by E. Pozamantir. Relevant for SLP
// and related methods, but we test it for all algorithms.
//
// Description:
//
// The sequential linear programming solver performs warm-start
// at each iteration, i.e. it reuses previously found LP basis.
// However, when some initially non-zero Jacobian entries become
// exactly zero (possible with constraints which are nonsmooth
// at some distance from the boundary), our warm-start strategy
// may fail because warm-start basis becomes exactly degenerate.
//
// In order to test that this bug was fixed we solve carefully
// designed noisy test problem with Jacobian entries being randomly
// turned on and off. Simply being able to return from the solver
// without triggering critical exception is enough.
   for (solvertype = 0; solvertype <= testminnlcunit_maxsolvertype; solvertype++) {
      for (n = 6; n <= 15; n++) {
      // Setup problem
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&d, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
            d.xR[i] = sqr(hqrndnormal(&rs));
         }
         k = 1 + hqrnduniformi(&rs, n / 3);
         ae_matrix_set_length(&c, 2 * k, n + 1);
         for (i = 0; i < 2 * k; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
            }
         }
         for (i = 0; i < k; i++) {
            c.xyR[i][n] = 0.0;
         }
         for (i = k; i < 2 * k; i++) {
            c.xyR[i][n] = 0.1 + hqrnduniformr(&rs);
         }
      // Create solver and solve problem
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 200.0, 20);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 1.0E-7, 20);
         minnlcsetnlc(&state, k, k);
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (j = 0; j < n; j++) {
                  state.fi.xR[0] += 0.5 * d.xR[j] * sqr(state.x.xR[j]);
                  state.j.xyR[0][j] = d.xR[j] * state.x.xR[j];
               }
               for (i = 0; i < 2 * k; i++) {
                  state.fi.xR[1 + i] = -c.xyR[i][n];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[1 + i] += c.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[1 + i][j] = hqrnduniformi(&rs, 2) * c.xyR[i][j];
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests report of "non-C1" test #0 for task #0
// given by matrix A.
static bool testminnlcunit_testoptguardc1test0reportfortask0(optguardnonc1test0report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double va;
   double vb;
   bool hasc1discontinuities;
   bool Ok = true;
   if (rep->positive) {
   // Check positive report, first checks
      Ok = Ok && rep->fidx == 0;
      Ok = Ok && rep->n == n;
      Ok = Ok && 0 <= rep->stpidxa;
      Ok = Ok && rep->stpidxa < rep->stpidxb;
      Ok = Ok && rep->stpidxb < rep->cnt;
      Ok = Ok && rep->x0.cnt == rep->n;
      Ok = Ok && rep->d.cnt == rep->n;
      Ok = Ok && rep->stp.cnt == rep->cnt;
      Ok = Ok && rep->f.cnt == rep->cnt;
      Ok = Ok && isfinitevector(&rep->x0, n);
      Ok = Ok && isfinitevector(&rep->d, n);
      Ok = Ok && isfinitevector(&rep->stp, rep->cnt);
      Ok = Ok && isfinitevector(&rep->f, rep->cnt);
      if (!Ok) {
         return Ok;
      }
   // Check consistency of Stp.
      for (k = 0; k < rep->cnt - 1; k++) {
         Ok = Ok && rep->stp.xR[k] < rep->stp.xR[k + 1];
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      Ok = Ok && hasc1discontinuities;
   } else {
   // Check negative report: fields must be empty
      Ok = Ok && rep->stpidxa == -1;
      Ok = Ok && rep->stpidxb == -1;
      Ok = Ok && rep->fidx == -1;
      Ok = Ok && rep->cnt == 0;
      Ok = Ok && rep->n == 0;
      Ok = Ok && rep->x0.cnt == 0;
      Ok = Ok && rep->d.cnt == 0;
      Ok = Ok && rep->stp.cnt == 0;
      Ok = Ok && rep->f.cnt == 0;
   }
   return Ok;
}

// This function tests report of "non-C1" test #1 for task #0
// given by matrix A.
static bool testminnlcunit_testoptguardc1test1reportfortask0(optguardnonc1test1report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double va;
   double vb;
   bool tooclose;
   bool hasc1discontinuities;
   bool Ok = true;
   if (rep->positive) {
   // Check positive report, first checks
      Ok = Ok && rep->fidx == 0;
      Ok = Ok && rep->vidx >= 0;
      Ok = Ok && rep->vidx <= n;
      Ok = Ok && rep->n == n;
      Ok = Ok && 0 <= rep->stpidxa;
      Ok = Ok && rep->stpidxa < rep->stpidxb;
      Ok = Ok && rep->stpidxb < rep->cnt;
      Ok = Ok && rep->x0.cnt == rep->n;
      Ok = Ok && rep->d.cnt == rep->n;
      Ok = Ok && rep->stp.cnt == rep->cnt;
      Ok = Ok && rep->g.cnt == rep->cnt;
      Ok = Ok && isfinitevector(&rep->x0, n);
      Ok = Ok && isfinitevector(&rep->d, n);
      Ok = Ok && isfinitevector(&rep->stp, rep->cnt);
      Ok = Ok && isfinitevector(&rep->g, rep->cnt);
      if (!Ok) {
         return Ok;
      }
   // Check consistency of Stp
      for (k = 0; k < rep->cnt - 1; k++) {
         Ok = Ok && rep->stp.xR[k] < rep->stp.xR[k + 1];
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      tooclose = false;
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         tooclose = tooclose || SmallR(va, 1.0E-8) || SmallR(vb, 1.0E-8);
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      if (!tooclose) {
         Ok = Ok && hasc1discontinuities;
      }
   } else {
   // Check negative report: fields must be empty
      Ok = Ok && rep->stpidxa == -1;
      Ok = Ok && rep->stpidxb == -1;
      Ok = Ok && rep->fidx == -1;
      Ok = Ok && rep->vidx == -1;
      Ok = Ok && rep->cnt == 0;
      Ok = Ok && rep->n == 0;
      Ok = Ok && rep->x0.cnt == 0;
      Ok = Ok && rep->d.cnt == 0;
      Ok = Ok && rep->stp.cnt == 0;
      Ok = Ok && rep->g.cnt == 0;
   }
   return Ok;
}

// This function tests report of "non-C1" test #0 for task #1
// given by matrix A.
static bool testminnlcunit_testoptguardc1test0reportfortask1(optguardnonc1test0report *rep, RMatrix *a, ae_int_t n, ae_int_t goodidx) {
   bool Ok = true;
   if (rep->positive) {
   // Check positive report, first checks
      Ok = Ok && rep->fidx != goodidx + 1;
      Ok = Ok && rep->n == n;
      Ok = Ok && 0 <= rep->stpidxa;
      Ok = Ok && rep->stpidxa < rep->stpidxb;
      Ok = Ok && rep->stpidxb < rep->cnt;
      Ok = Ok && rep->x0.cnt == rep->n;
      Ok = Ok && rep->d.cnt == rep->n;
      Ok = Ok && rep->stp.cnt == rep->cnt;
      Ok = Ok && rep->f.cnt == rep->cnt;
      Ok = Ok && isfinitevector(&rep->x0, n);
      Ok = Ok && isfinitevector(&rep->d, n);
      Ok = Ok && isfinitevector(&rep->stp, rep->cnt);
      Ok = Ok && isfinitevector(&rep->f, rep->cnt);
      if (!Ok) {
         return Ok;
      }
   } else {
   // Check negative report: fields must be empty
      Ok = Ok && rep->stpidxa == -1;
      Ok = Ok && rep->stpidxb == -1;
      Ok = Ok && rep->fidx == -1;
      Ok = Ok && rep->cnt == 0;
      Ok = Ok && rep->n == 0;
      Ok = Ok && rep->x0.cnt == 0;
      Ok = Ok && rep->d.cnt == 0;
      Ok = Ok && rep->stp.cnt == 0;
      Ok = Ok && rep->f.cnt == 0;
   }
   return Ok;
}

// This function tests report of "non-C1" test #1 for task #1 given by matrix A.
static bool testminnlcunit_testoptguardc1test1reportfortask1(optguardnonc1test1report *rep, RMatrix *a, ae_int_t n, ae_int_t goodidx) {
   bool Ok = true;
   if (rep->positive) {
   // Check positive report, first checks
      Ok = Ok && rep->fidx != goodidx + 1;
      Ok = Ok && rep->vidx >= 0;
      Ok = Ok && rep->vidx <= n;
      Ok = Ok && rep->n == n;
      Ok = Ok && 0 <= rep->stpidxa;
      Ok = Ok && rep->stpidxa < rep->stpidxb;
      Ok = Ok && rep->stpidxb < rep->cnt;
      Ok = Ok && rep->x0.cnt == rep->n;
      Ok = Ok && rep->d.cnt == rep->n;
      Ok = Ok && rep->stp.cnt == rep->cnt;
      Ok = Ok && rep->g.cnt == rep->cnt;
      Ok = Ok && isfinitevector(&rep->x0, n);
      Ok = Ok && isfinitevector(&rep->d, n);
      Ok = Ok && isfinitevector(&rep->stp, rep->cnt);
      Ok = Ok && isfinitevector(&rep->g, rep->cnt);
      if (!Ok) {
         return Ok;
      }
   } else {
   // Check negative report: fields must be empty
      Ok = Ok && rep->stpidxa == -1;
      Ok = Ok && rep->stpidxb == -1;
      Ok = Ok && rep->fidx == -1;
      Ok = Ok && rep->vidx == -1;
      Ok = Ok && rep->cnt == 0;
      Ok = Ok && rep->n == 0;
      Ok = Ok && rep->x0.cnt == 0;
      Ok = Ok && rep->d.cnt == 0;
      Ok = Ok && rep->stp.cnt == 0;
      Ok = Ok && rep->g.cnt == 0;
   }
   return Ok;
}

// This function tests OptGuard
static bool testminnlcunit_testoptguard() {
   ae_frame _frame_block;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   double diffstep;
   ae_int_t pass;
   ae_int_t solvertype;
   double vbnd;
   double fscale;
   ae_int_t defecttype;
   double vshift;
   double vpower;
   ae_int_t cntabove;
   ae_int_t cntbelow;
   bool linesearchstarted;
   bool wasgoodlinesearch0;
   bool wasgoodlinesearch1;
   ae_int_t shortsessions;
   ae_int_t maxshortsessions;
   double stplen;
   double shortstplen;
   bool failed;
   ae_int_t passcount;
   ae_int_t maxfails;
   ae_int_t failurecounter;
   ae_int_t maxc1test0fails;
   ae_int_t maxc1test1fails;
   ae_int_t c1test0fails;
   ae_int_t c1test1fails;
   ae_int_t goodidx;
   double avgstr0len;
   double avglng0len;
   double avgstr1len;
   double avglng1len;
   ae_int_t funcidx;
   ae_int_t varidx;
   ae_int_t skind;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minnlcstate, state);
   NewObj(minnlcreport, rep);
   NewObj(optguardreport, ogrep);
   NewObj(optguardnonc1test0report, ognonc1test0strrep);
   NewObj(optguardnonc1test0report, ognonc1test0lngrep);
   NewObj(optguardnonc1test1report, ognonc1test1strrep);
   NewObj(optguardnonc1test1report, ognonc1test1lngrep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(xu, 0, DT_REAL);
   NewMatrix(jactrue, 0, 0, DT_REAL);
   NewMatrix(jacdefect, 0, 0, DT_REAL);
   hqrndrandomize(&rs);
// Test functionality which should work in all NLC solvers
   for (solvertype = 0; solvertype <= testminnlcunit_maxsolvertype; solvertype++) {
   // Check that gradient verification is disabled by default:
   // gradient checking for bad problem must return nothing
      n = 10;
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = 1.0 + 0.1 * i;
      }
      spdmatrixrndcond(n, 1.0E3, &a);
      spdmatrixrndcond(n, 1.0E3, &a1);
      minnlccreate(n, &x0, &state);
      if (solvertype == 0) {
         minnlcsetalgoaul(&state, 1000.0, 5);
      } else {
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
      }
      minnlcsetcond(&state, 1.0E-7, 10);
      minnlcsetnlc(&state, 0, 1);
      while (minnlciteration(&state))
         if (state.needfij) {
            state.fi.xR[0] = 0.0;
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.fi.xR[0] += 0.5 * state.x.xR[i] * v;
            }
            state.fi.xR[1] = 0.0;
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a1.xyR[i][j];
               }
               state.fi.xR[1] += 0.5 * state.x.xR[i] * v;
            }
            for (i = 0; i < n; i++) {
               state.j.xyR[0][i] = 0.0;
               state.j.xyR[1][i] = 0.0;
            }
         } else ae_assert(false, "Assertion failed");
      minnlcresults(&state, &x1, &rep);
      minnlcoptguardresults(&state, &ogrep);
      Ok = Ok && rep.terminationtype > 0;
      Ok = Ok && isfinitevector(&x1, n);
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      Ok = Ok && ogrep.badgradxbase.cnt == 0;
      Ok = Ok && ogrep.badgraduser.rows == 0;
      Ok = Ok && ogrep.badgraduser.cols == 0;
      Ok = Ok && ogrep.badgradnum.rows == 0;
      Ok = Ok && ogrep.badgradnum.cols == 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      Ok = Ok && !ogrep.badgradsuspected;
      Ok = Ok && ogrep.badgradfidx == -1;
      Ok = Ok && ogrep.badgradvidx == -1;
   // Test that C0/C1 continuity monitoring is disabled by default;
   // we solve nonsmooth problem and test that nothing is returned
   // by OptGuard.
      n = 10;
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
      minnlccreate(n, &x0, &state);
      if (solvertype == 0) {
         minnlcsetalgoaul(&state, 1000.0, 1);
      } else {
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
      }
      minnlcsetcond(&state, 1.0E-9, 50);
      while (minnlciteration(&state))
         if (state.needfij) {
            state.fi.xR[0] = 0.0;
            for (i = 0; i < n; i++) {
               state.j.xyR[0][i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.fi.xR[0] += fabs(v);
               v = (double)sign(v);
               for (j = 0; j < n; j++) {
                  state.j.xyR[0][j] += v * a.xyR[i][j];
               }
            }
         } else ae_assert(false, "Assertion failed");
      minnlcresults(&state, &x1, &rep);
      minnlcoptguardresults(&state, &ogrep);
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      Ok = Ok && !ogrep.nonc0suspected;
      Ok = Ok && !ogrep.nonc1suspected;
      Ok = Ok && optguardallclear(&ogrep);
      Ok = Ok && ogrep.nonc0fidx < 0;
      Ok = Ok && ogrep.nonc1fidx < 0;
      Ok = Ok && !ogrep.nonc1test0positive;
      Ok = Ok && !ogrep.nonc1test1positive;
   // Test gradient checking functionality, try various
   // defect types:
   // * accidental zeroing of some gradient component
   // * accidental addition of 1.0 to some component
   // * accidental multiplication by 2.0
   // Try distorting both target and constraints.
      diffstep = 0.001;
      n = 10;
      for (skind = 0; skind <= 1; skind++) {
         for (funcidx = 0; funcidx <= 1; funcidx++) {
            for (defecttype = -1; defecttype <= 2; defecttype++) {
               varidx = hqrnduniformi(&rs, n);
               ae_vector_set_length(&x0, n);
               ae_vector_set_length(&s, n);
               ae_vector_set_length(&bndl, n);
               ae_vector_set_length(&bndu, n);
               for (i = 0; i < n; i++) {
                  s.xR[i] = pow(10.0, skind * 15.0 * hqrndmiduniformr(&rs));
                  x0.xR[i] = (1.0 + 0.1 * i) * s.xR[i];
                  j = hqrnduniformi(&rs, 3);
                  bndl.xR[i] = -100 * s.xR[i];
                  bndu.xR[i] = 100 * s.xR[i];
                  if (j == 1) {
                     bndl.xR[i] = x0.xR[i];
                  }
                  if (j == 2) {
                     bndu.xR[i] = x0.xR[i];
                  }
               }
               spdmatrixrndcond(n, 1.0E3, &a);
               spdmatrixrndcond(n, 1.0E3, &a1);
               minnlccreate(n, &x0, &state);
               if (solvertype == 0) {
                  minnlcsetalgoaul(&state, 1000.0, 5);
               } else {
                  if (solvertype == 1) {
                     minnlcsetalgoslp(&state);
                  } else {
                     if (solvertype == 2) {
                        minnlcsetalgosqp(&state);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
               }
               minnlcoptguardgradient(&state, diffstep);
               minnlcsetcond(&state, 1.0E-7, 10);
               minnlcsetscale(&state, &s);
               minnlcsetbc(&state, &bndl, &bndu);
               minnlcsetnlc(&state, 0, 1);
               while (minnlciteration(&state))
                  if (state.needfij) {
                     if (solvertype != 0) {
                        for (i = 0; i < n; i++) {
                           Ok = Ok && state.x.xR[i] >= bndl.xR[i];
                           Ok = Ok && state.x.xR[i] <= bndu.xR[i];
                        }
                     }
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        v = 0.0;
                        for (j = 0; j < n; j++) {
                           v += state.x.xR[j] / s.xR[j] * a.xyR[i][j];
                        }
                        state.fi.xR[0] += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                        state.j.xyR[0][i] = v;
                     }
                     state.fi.xR[1] = 0.0;
                     for (i = 0; i < n; i++) {
                        v = 0.0;
                        for (j = 0; j < n; j++) {
                           v += state.x.xR[j] / s.xR[j] * a1.xyR[i][j];
                        }
                        state.fi.xR[1] += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                        state.j.xyR[1][i] = v;
                     }
                     if (defecttype == 0) {
                        state.j.xyR[funcidx][varidx] = 0.0;
                     }
                     if (defecttype == 1) {
                        state.j.xyR[funcidx][varidx]++;
                     }
                     if (defecttype == 2) {
                        state.j.xyR[funcidx][varidx] *= 2;
                     }
                     for (i = 0; i < n; i++) {
                        state.j.xyR[0][i] /= s.xR[i];
                        state.j.xyR[1][i] /= s.xR[i];
                     }
                  } else ae_assert(false, "Assertion failed");
               minnlcresults(&state, &x1, &rep);
               minnlcoptguardresults(&state, &ogrep);
            // Check that something is returned
               Ok = Ok && rep.terminationtype > 0;
               Ok = Ok && isfinitevector(&x1, n);
               if (!Ok) {
                  ae_frame_leave();
                  return Ok;
               }
            // Compute reference values for true and spoiled Jacobian at X0
               Ok = Ok && isfinitevector(&ogrep.badgradxbase, n);
               if (!Ok) {
                  ae_frame_leave();
                  return Ok;
               }
               ae_matrix_set_length(&jactrue, 2, n);
               ae_matrix_set_length(&jacdefect, 2, n);
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += ogrep.badgradxbase.xR[j] / s.xR[j] * a.xyR[i][j];
                  }
                  jactrue.xyR[0][i] = v;
                  jacdefect.xyR[0][i] = v;
               }
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += ogrep.badgradxbase.xR[j] / s.xR[j] * a1.xyR[i][j];
                  }
                  jactrue.xyR[1][i] = v;
                  jacdefect.xyR[1][i] = v;
               }
               if (defecttype == 0) {
                  jacdefect.xyR[funcidx][varidx] = 0.0;
               }
               if (defecttype == 1) {
                  jacdefect.xyR[funcidx][varidx]++;
               }
               if (defecttype == 2) {
                  jacdefect.xyR[funcidx][varidx] *= 2;
               }
               for (i = 0; i < n; i++) {
                  jactrue.xyR[0][i] /= s.xR[i];
                  jactrue.xyR[1][i] /= s.xR[i];
                  jacdefect.xyR[0][i] /= s.xR[i];
                  jacdefect.xyR[1][i] /= s.xR[i];
               }
            // Check OptGuard report
               Ok = Ok && apservisfinitematrix(&ogrep.badgraduser, 2, n);
               Ok = Ok && apservisfinitematrix(&ogrep.badgradnum, 2, n);
               if (!Ok) {
                  ae_frame_leave();
                  return Ok;
               }
               if (defecttype >= 0) {
                  Ok = Ok && ogrep.badgradsuspected;
                  Ok = Ok && ogrep.badgradfidx == funcidx;
                  Ok = Ok && ogrep.badgradvidx == varidx;
               } else {
                  Ok = Ok && !ogrep.badgradsuspected;
                  Ok = Ok && ogrep.badgradfidx == -1;
                  Ok = Ok && ogrep.badgradvidx == -1;
               }
               for (i = 0; i <= 1; i++) {
                  for (j = 0; j < n; j++) {
                     Ok = Ok && NearAtR(jactrue.xyR[i][j], ogrep.badgradnum.xyR[i][j], 0.01 / s.xR[j]);
                     Ok = Ok && NearAtR(jacdefect.xyR[i][j], ogrep.badgraduser.xyR[i][j], 0.01 / s.xR[j]);
                  }
               }
            }
         }
      }
   // Make sure than no false positives are reported for larger
   // problems where numerical noise can be an issue:
   // * N == 100 dimensions
   // * nonnegativity constraints
   // * positive-definite quadratic programming problem
   // * upper limit on iterations count, MaxIts == 25
   // We simply test that OptGuard does not return error code.
      n = 100;
      spdmatrixrndcond(n, 1.0E2, &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         b.xR[i] = hqrndnormal(&rs);
         bndl.xR[i] = 0.0;
         bndu.xR[i] = +INFINITY;
         x0.xR[i] = pow(2.0, hqrndnormal(&rs));
      }
      minnlccreate(n, &x0, &state);
      if (solvertype == 0) {
         minnlcsetalgoaul(&state, 1000.0, 3);
      } else {
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
      }
      minnlcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel));
      minnlcsetbc(&state, &bndl, &bndu);
      minnlcsetcond(&state, 1.0E-7, 25);
      while (minnlciteration(&state))
         if (state.needfij) {
            state.fi.xR[0] = 0.0;
            for (i = 0; i < n; i++) {
               state.fi.xR[0] += b.xR[i] * state.x.xR[i];
               state.j.xyR[0][i] = b.xR[i];
               for (j = 0; j < n; j++) {
                  state.fi.xR[0] += 0.5 * state.x.xR[i] * a.xyR[i][j] * state.x.xR[j];
                  state.j.xyR[0][i] += a.xyR[i][j] * state.x.xR[j];
               }
            }
         } else ae_assert(false, "Assertion failed");
      minnlcresults(&state, &x1, &rep);
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      minnlcoptguardresults(&state, &ogrep);
      Ok = Ok && optguardallclear(&ogrep);
   }
// Test functionality which works only in some NLC solvers
   for (solvertype = 0; solvertype <= testminnlcunit_maxsolvertype; solvertype++) {
   // Skip
      if (solvertype == 2) {
         continue;
      }
   // Test detection of discontinuities in the target function
   // and its gradient (analytic gradient is used).
   //
   // Target function is convex quadratic modified by addition of
   // nonsmooth/discontinuous (depending on DefectType) perturbation.
   //
   // This test is complicated because OptGuard does NOT guarantee
   // that C0/C1 violations are ALWAYS caught. OptGuard needs line
   // search to perform
   // * at least 4 function evaluations, with discontinuity in the
   //   middle of them (at least two function values from the left,
   //   at least two from the right)
   // * at least 7 function evaluations to catch C1 violation
   //
   // Furthermore, it is possible that optimizer will perform a few
   // function evaluations BEFORE and AFTER line search starts,
   // which complicates everything.
   //
   // N, VPower and VBnd are selected randomly at the start of the test.
      for (defecttype = 0; defecttype <= 1; defecttype++) {
         n = 1 + hqrnduniformi(&rs, 10);
         vpower = 10 * pow(10.0, -0.2 * hqrnduniformr(&rs));
         vbnd = 1 * pow(10.0, -0.2 * hqrnduniformr(&rs));
         fscale = 0.1;
         maxshortsessions = 4;
         shortstplen = 1.0E-6;
         shortsessions = 0;
         for (pass = 1; pass <= 100; pass++) {
         // Formulate problem
            ae_vector_set_length(&s, n);
            ae_vector_set_length(&xlast, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&xu, n);
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            do {
               v = 0.0;
               for (i = 0; i < n; i++) {
                  xu.xR[i] = 0.1 + hqrnduniformr(&rs);
                  v += sqr(xu.xR[i]);
               }
               v = sqrt(v);
            } while (v <= 0.0);
            for (i = 0; i < n; i++) {
               xu.xR[i] /= v;
            }
            for (i = 0; i < n; i++) {
               xlast.xR[i] = 0.0;
               x0.xR[i] = 2 * xu.xR[i] + 0.1 * hqrnduniformr(&rs);
               bndl.xR[i] = 0.0;
               bndu.xR[i] = +INFINITY;
               s.xR[i] = pow(2.0, 0.1 * hqrndnormal(&rs));
            }
            if (defecttype == 0) {
               vshift = 1.0;
            } else {
               vshift = 0.0;
            }
         // Prepare code which detects "good" (long enough) line searches
            cntbelow = 0;
            cntabove = 0;
            wasgoodlinesearch0 = false;
            wasgoodlinesearch1 = false;
            linesearchstarted = false;
         // Create and try to solve
            minnlccreate(n, &x0, &state);
            if (solvertype == 0) {
               minnlcsetalgoaul(&state, 1000.0, 5);
            } else {
               if (solvertype == 1) {
                  minnlcsetalgoslp(&state);
               } else {
                  if (solvertype == 2) {
                     minnlcsetalgosqp(&state);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            }
            minnlcsetbc(&state, &bndl, &bndu);
            minnlcsetscale(&state, &s);
            minnlcsetcond(&state, 1.0E-7, 1000);
            minnlcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel));
            minnlcsetxrep(&state, true);
            while (minnlciteration(&state))
               if (state.needfij) {
                  state.fi.xR[0] = 0.0;
                  for (i = 0; i < n; i++) {
                     state.fi.xR[0] += fscale * pow(state.x.xR[i], 2.0);
                     state.j.xyR[0][i] = 2 * fscale * state.x.xR[i];
                  }
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     v += state.x.xR[i] * xu.xR[i];
                  }
                  if (v < vbnd) {
                     state.fi.xR[0] += vshift + vpower * (vbnd - v);
                     for (i = 0; i < n; i++) {
                        state.j.xyR[0][i] -= vpower * xu.xR[i];
                     }
                     if (linesearchstarted) {
                        cntbelow++;
                     }
                  } else {
                     if (linesearchstarted) {
                        cntabove++;
                     }
                  }
               } else if (state.xupdated) {
               // Finalize previous line search
                  if (linesearchstarted) {
                     stplen = 0.0;
                     for (i = 0; i < n; i++) {
                        stplen += sqr(state.x.xR[i] - xlast.xR[i]);
                     }
                     stplen = sqrt(stplen);
                     wasgoodlinesearch0 = wasgoodlinesearch0 || cntbelow >= 2 && cntabove >= 2 && stplen >= shortstplen;
                     wasgoodlinesearch1 = wasgoodlinesearch1 || cntbelow >= 2 && cntabove >= 2 && stplen >= shortstplen;
                  }
               // Start new line search
                  linesearchstarted = true;
                  cntbelow = 0;
                  cntabove = 0;
                  for (i = 0; i < n; i++) {
                     xlast.xR[i] = state.x.xR[i];
                  }
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     v += state.x.xR[i] * xu.xR[i];
                  }
                  if (v < vbnd) {
                     cntbelow++;
                  } else {
                     cntabove++;
                  }
               } else ae_assert(false, "Assertion failed");
            minnlcresults(&state, &x1, &rep);
            minnlcoptguardresults(&state, &ogrep);
         // Check basic properties of the solution
            Ok = Ok && isfinitevector(&x1, n);
            Ok = Ok && rep.terminationtype > 0;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         // Check OptGuard report, increase
            if (defecttype == 0) {
               if (wasgoodlinesearch0) {
                  Ok = Ok && !optguardallclear(&ogrep);
                  Ok = Ok && ogrep.nonc0suspected;
                  Ok = Ok && ogrep.nonc0fidx == 0;
               } else {
                  shortsessions++;
               }
            }
            if (defecttype == 1) {
               if (wasgoodlinesearch1) {
                  Ok = Ok && !optguardallclear(&ogrep);
                  Ok = Ok && ogrep.nonc1suspected;
                  Ok = Ok && ogrep.nonc1fidx == 0;
               } else {
                  shortsessions++;
               }
            }
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         }
      // Check that short optimization sessions are rare.
         Ok = Ok && shortsessions <= maxshortsessions;
      }
   // One more test for detection of C1 continuity violations in the target.
   //
   // Target function is a sum of |(x,c_i)| for i = 1..N.
   // No constraints is present.
   // Analytic gradient is provided.
   //
   // OptGuard should be able to detect violations in more than
   // 99.9% of runs; it means that 100 runs should have no more than 4
   // failures in all cases (even after multiple repeated tests; according
   // to the binomial distribution quantiles).
   //
   // We select some N and perform exhaustive search for this N.
   //
   // NOTE: we skip SQP for this test
      passcount = 100;
      maxfails = 4;
      maxc1test0fails = 10;
      maxc1test1fails = 10;
      n = 1 + hqrnduniformi(&rs, 10);
      failurecounter = 0;
      c1test0fails = 0;
      c1test1fails = 0;
      avgstr0len = 0.0;
      avglng0len = 0.0;
      avgstr1len = 0.0;
      avglng1len = 0.0;
      for (pass = 1; pass <= passcount; pass++) {
      // Formulate problem
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(2.0, hqrndnormal(&rs));
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = hqrndnormal(&rs);
            }
         }
      // Create and try to solve
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 1);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 1.0E-7, 50);
         minnlcsetscale(&state, &s);
         minnlcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel));
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.j.xyR[0][i] = 0.0;
               }
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += state.x.xR[j] * a.xyR[i][j];
                  }
                  state.fi.xR[0] += fabs(v);
                  v = (double)sign(v);
                  for (j = 0; j < n; j++) {
                     state.j.xyR[0][j] += v * a.xyR[i][j];
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         minnlcoptguardresults(&state, &ogrep);
      // Check basic properties of the solution
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Check generic OptGuard report: distinguish between "hard"
      // failures which result in immediate termination
      // (C0 violation being reported) and "soft" ones
      // (C1 violation is NOT reported) which accumulate
      // until we exhaust limit.
         Ok = Ok && !ogrep.nonc0suspected;
         Ok = Ok && ogrep.nonc0fidx < 0;
         failed = false;
         failed = failed || optguardallclear(&ogrep);
         failed = failed || !ogrep.nonc1suspected;
         failed = failed || ogrep.nonc1fidx != 0;
         if (failed) {
            failurecounter++;
         }
      // Check C1 continuity test #0
         minnlcoptguardnonc1test0results(&state, &ognonc1test0strrep, &ognonc1test0lngrep);
         minnlcoptguardnonc1test1results(&state, &ognonc1test1strrep, &ognonc1test1lngrep);
         if (ogrep.nonc1test0positive) {
            Ok = Ok && ogrep.nonc1suspected;
            Ok = Ok && ognonc1test0strrep.positive;
            Ok = Ok && ognonc1test0lngrep.positive;
            Ok = Ok && ogrep.nonc1fidx == 0;
            Ok = Ok && testminnlcunit_testoptguardc1test0reportfortask0(&ognonc1test0strrep, &a, n);
            Ok = Ok && testminnlcunit_testoptguardc1test0reportfortask0(&ognonc1test0lngrep, &a, n);
            avgstr0len += (double)ognonc1test0strrep.cnt / passcount;
            avglng0len += (double)ognonc1test0lngrep.cnt / passcount;
         } else {
            Ok = Ok && !ognonc1test0strrep.positive;
            Ok = Ok && !ognonc1test0lngrep.positive;
            Ok = Ok && testminnlcunit_testoptguardc1test0reportfortask0(&ognonc1test0strrep, &a, n);
            Ok = Ok && testminnlcunit_testoptguardc1test0reportfortask0(&ognonc1test0lngrep, &a, n);
            c1test0fails++;
         }
         if (ogrep.nonc1test1positive) {
            Ok = Ok && ogrep.nonc1suspected;
            Ok = Ok && ognonc1test1strrep.positive;
            Ok = Ok && ognonc1test1lngrep.positive;
            Ok = Ok && ogrep.nonc1fidx == 0;
            Ok = Ok && testminnlcunit_testoptguardc1test1reportfortask0(&ognonc1test1strrep, &a, n);
            Ok = Ok && testminnlcunit_testoptguardc1test1reportfortask0(&ognonc1test1lngrep, &a, n);
            avgstr1len += (double)ognonc1test1strrep.cnt / passcount;
            avglng1len += (double)ognonc1test1lngrep.cnt / passcount;
         } else {
            Ok = Ok && !ognonc1test1strrep.positive;
            Ok = Ok && !ognonc1test1lngrep.positive;
            Ok = Ok && testminnlcunit_testoptguardc1test1reportfortask0(&ognonc1test1strrep, &a, n);
            Ok = Ok && testminnlcunit_testoptguardc1test1reportfortask0(&ognonc1test1lngrep, &a, n);
            c1test1fails++;
         }
      }
      Ok = Ok && failurecounter <= maxfails;
      Ok = Ok && c1test0fails <= maxc1test0fails;
      Ok = Ok && c1test1fails <= maxc1test1fails;
      Ok = Ok && avglng0len > avgstr0len;
      Ok = Ok && avglng1len > avgstr1len;
   // Detection of C1 continuity violations in the target under numerical differentiation:
   // * target function is a sum of |(x,c_i)| for i = 1..N.
   // * no constraints is present.
   // * analytic gradient is provided.
   //
   // OptGuard should always be able to detect violations in more than
   // 99% of runs (note: reduced strength when compared with analytic gradient);
   // it means that 100 runs should have no more than 10 failures in all cases
   // (even after multiple repeated tests; according to the binomial distribution
   // quantiles).
   //
   // We select some N and perform exhaustive search for this N.
   //
   // NOTE: we skip SQP solver for this test
      diffstep = 0.0001;
      passcount = 100;
      maxfails = 10;
      n = 1 + hqrnduniformi(&rs, 10);
      failurecounter = 0;
      for (pass = 1; pass <= passcount; pass++) {
      // Formulate problem
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = 0.01 * pow(2.0, 0.33 * hqrndnormal(&rs));
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = hqrndnormal(&rs);
            }
         }
      // Create and try to solve
         minnlccreatef(n, &x0, diffstep, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 1);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 1.0E-7, 50);
         minnlcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel));
         while (minnlciteration(&state))
            if (state.needfi) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += state.x.xR[j] * a.xyR[i][j];
                  }
                  state.fi.xR[0] += fabs(v);
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         minnlcoptguardresults(&state, &ogrep);
      // Check basic properties of the solution
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Check OptGuard report: distinguish between "hard"
      // failures which result in immediate termination
      // (C0 violation being reported) and "soft" ones
      // (C1 violation is NOT reported) which accumulate
      // until we exhaust limit.
         Ok = Ok && !ogrep.nonc0suspected;
         Ok = Ok && ogrep.nonc0fidx < 0;
         failed = false;
         failed = failed || optguardallclear(&ogrep);
         failed = failed || !ogrep.nonc1suspected;
         failed = failed || ogrep.nonc1fidx != 0;
         if (failed) {
            failurecounter++;
         }
      }
      Ok = Ok && failurecounter <= maxfails;
   // Detection of C1 continuity violations in the nonlinear constraints.
   //
   // This test is a bit tricky because optimizers are less sensitive to
   // continuity violations in constraints, so we may have hard time collecting
   // enough statistics. In order to do so we solve carefully designed hard
   // problem with MULTIPLE bad constraints and only one good constraint.
   //
   // Optimizer may report any of bad constraints, but not good one.
   //
   // We select some N and perform exhaustive search for this N.
      passcount = 100;
      maxfails = 20;
      n = 5;
      failurecounter = 0;
      c1test0fails = 0;
      c1test1fails = 0;
      for (pass = 1; pass <= passcount; pass++) {
      // Formulate problem, select constraint index to perturb with
      // nonsmoothness; make sure that this constraint is active at
      // the solution
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&b, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrnduniformr(&rs) - 0.5;
            s.xR[i] = pow(2.0, hqrndnormal(&rs));
            b.xR[i] = hqrndnormal(&rs);
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = pow(2.0, 0.01 * hqrndnormal(&rs));
            }
         }
         goodidx = hqrnduniformi(&rs, n);
      // Create and try to solve
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 3);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 1.0E-7, 50);
         minnlcsetnlc(&state, 0, n);
         minnlcsetscale(&state, &s);
         minnlcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel));
         while (minnlciteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
               }
               for (i = 0; i < n; i++) {
                  state.fi.xR[1 + i] = -1.0;
                  for (j = 0; j < n; j++) {
                     state.fi.xR[1 + i] += a.xyR[i][j] * sqr(state.x.xR[j]);
                     state.j.xyR[1 + i][j] = 2 * a.xyR[i][j] * state.x.xR[j];
                  }
                  if (i != goodidx) {
                     state.fi.xR[1 + i] = rmax2(state.fi.xR[1 + i], 0.0);
                     for (j = 0; j < n; j++) {
                        state.j.xyR[1 + i][j] *= sign(state.fi.xR[1 + i]);
                     }
                  }
               }
            } else ae_assert(false, "Assertion failed");
         minnlcresults(&state, &x1, &rep);
         minnlcoptguardresults(&state, &ogrep);
      // Check basic properties of the solution
         Ok = Ok && isfinitevector(&x1, n);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Check generic OptGuard report: distinguish between "hard"
      // failures which result in immediate termination
      // (C0 violation being reported) and "soft" ones
      // (C1 violation is NOT reported) which accumulate
      // until we exhaust limit.
         Ok = Ok && !ogrep.nonc0suspected;
         Ok = Ok && ogrep.nonc0fidx < 0;
         Ok = Ok && ogrep.nonc1fidx != goodidx + 1;
         failed = false;
         failed = failed || optguardallclear(&ogrep);
         failed = failed || !ogrep.nonc1suspected;
         if (failed) {
            failurecounter++;
         }
      // Check C1 continuity tests #0 and #1
         minnlcoptguardnonc1test0results(&state, &ognonc1test0strrep, &ognonc1test0lngrep);
         minnlcoptguardnonc1test1results(&state, &ognonc1test1strrep, &ognonc1test1lngrep);
         if (ogrep.nonc1test0positive) {
            Ok = Ok && ogrep.nonc1suspected;
            Ok = Ok && ognonc1test0strrep.positive;
            Ok = Ok && ognonc1test0lngrep.positive;
            Ok = Ok && ogrep.nonc1fidx >= 1;
            Ok = Ok && ogrep.nonc1fidx <= n;
            Ok = Ok && ogrep.nonc1fidx != goodidx + 1;
            Ok = Ok && testminnlcunit_testoptguardc1test0reportfortask1(&ognonc1test0strrep, &a, n, goodidx);
            Ok = Ok && testminnlcunit_testoptguardc1test0reportfortask1(&ognonc1test0lngrep, &a, n, goodidx);
         } else {
            Ok = Ok && !ognonc1test0strrep.positive;
            Ok = Ok && !ognonc1test0lngrep.positive;
            Ok = Ok && testminnlcunit_testoptguardc1test0reportfortask1(&ognonc1test0strrep, &a, n, goodidx);
            Ok = Ok && testminnlcunit_testoptguardc1test0reportfortask1(&ognonc1test0lngrep, &a, n, goodidx);
            c1test0fails++;
         }
         if (ogrep.nonc1test1positive) {
            Ok = Ok && ogrep.nonc1suspected;
            Ok = Ok && ognonc1test1strrep.positive;
            Ok = Ok && ognonc1test1lngrep.positive;
            Ok = Ok && ogrep.nonc1fidx >= 1;
            Ok = Ok && ogrep.nonc1fidx <= n;
            Ok = Ok && ogrep.nonc1fidx != goodidx + 1;
            Ok = Ok && testminnlcunit_testoptguardc1test1reportfortask1(&ognonc1test1strrep, &a, n, goodidx);
            Ok = Ok && testminnlcunit_testoptguardc1test1reportfortask1(&ognonc1test1lngrep, &a, n, goodidx);
         } else {
            Ok = Ok && !ognonc1test1strrep.positive;
            Ok = Ok && !ognonc1test1lngrep.positive;
            Ok = Ok && testminnlcunit_testoptguardc1test1reportfortask1(&ognonc1test1strrep, &a, n, goodidx);
            Ok = Ok && testminnlcunit_testoptguardc1test1reportfortask1(&ognonc1test1lngrep, &a, n, goodidx);
            c1test1fails++;
         }
      }
      Ok = Ok && failurecounter <= maxfails;
   }
   ae_frame_leave();
   return Ok;
}

bool testminnlc() {
   bool Ok;
   bool bcOk;
   bool lcOk;
   bool nlcOk;
   bool otherOk;
   bool optguardOk;
   bool bugsOk;
   Ok = true;
   bcOk = true;
   lcOk = true;
   nlcOk = true;
   otherOk = true;
   optguardOk = true;
   bugsOk = true;
   bugsOk = bugsOk && testminnlcunit_testbugs();
   bcOk = bcOk && testminnlcunit_testbc();
   lcOk = lcOk && testminnlcunit_testlc();
   nlcOk = nlcOk && testminnlcunit_testnlc();
   otherOk = otherOk && testminnlcunit_testother();
   optguardOk = optguardOk && testminnlcunit_testoptguard();
// The final report.
   Ok = bcOk && lcOk && nlcOk && otherOk && bugsOk && optguardOk;
   if (!Ok || !silent) {
      printf("MinNLC Optimization Tests\n");
      printf("* Box Constrained:                        %s\n", bcOk? "Ok": "Failed");
      printf("* Linearly Constrained:                   %s\n", lcOk? "Ok": "Failed");
      printf("* Non-Linearly Constrained:               %s\n", nlcOk? "Ok": "Failed");
      printf("* Other Properties:                       %s\n", otherOk? "Ok": "Failed");
      printf("* OptGuard Integrity Monitor:             %s\n", optguardOk? "Ok": "Failed");
      printf("* Fixed Bugs:                             %s\n", bugsOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === minns testing unit ===
static const double testminnsunit_scalingtesttol = 1.0E-6;
static const ae_int_t testminnsunit_scalingtestcnt = 5;

// Basic unconstrained test
static bool testminnsunit_basictest0uc() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   double sumits;
   double sumnfev;
   ae_int_t pass;
   ae_int_t passcount;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewObj(minnsstate, s);
   NewObj(minnsreport, rep);
   n = 5;
   passcount = 10;
   sumits = 0.0;
   sumnfev = 0.0;
   ae_vector_set_length(&x0, n);
   ae_vector_set_length(&d, n);
   for (pass = 1; pass <= 10; pass++) {
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         d.xR[i] = pow(10.0, randommid());
      }
      minnscreate(n, &x0, &s);
      minnssetalgoags(&s, 0.1, 0.0);
      while (minnsiteration(&s))
         if (s.needfij) {
            s.fi.xR[0] = 0.0;
            for (i = 0; i < n; i++) {
               s.fi.xR[0] += d.xR[i] * fabs(s.x.xR[i]);
               s.j.xyR[0][i] = d.xR[i] * sign(s.x.xR[i]);
            }
         } else ae_assert(false, "Assertion failed");
      minnsresults(&s, &x1, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && isfinite(x1.xR[i]) && SmallAtR(x1.xR[i], 0.001);
      }
      sumits += (double)rep.iterationscount / passcount;
      sumnfev += (double)rep.nfev / passcount;
   }
   ae_frame_leave();
   return Ok;
}

// Basic unconstrained test: nonsmooth Rosenbrock posed as unconstrained problem.
//
//              [                                                                       ]
//     minimize [ 10*|x0^2-x1| + (1-x0)^2 + 100*max(sqrt(2)*x0-1,0) + 100*max(2*x1-1,0) ]
//              [                                                                       ]
//
// Its exact solution is x0 == 1/sqrt(2), x1 == 1/2
static bool testminnsunit_basictest1uc() {
   ae_frame _frame_block;
   ae_int_t n;
   double v0;
   double v1;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewObj(minnsstate, s);
   NewObj(minnsreport, rep);
   n = 2;
   ae_vector_set_length(&x0, n);
   x0.xR[0] = 0.0;
   x0.xR[1] = 0.0;
   minnscreate(n, &x0, &s);
   minnssetalgoags(&s, 0.1, 0.0);
   while (minnsiteration(&s))
      if (s.needfij) {
         v0 = s.x.xR[0];
         v1 = s.x.xR[1];
         s.fi.xR[0] = 10 * fabs(sqr(v0) - v1) + sqr(v0 - 1);
         s.j.xyR[0][0] = 10 * sign(sqr(v0) - v1) * 2 * v0 + 2 * (v0 - 1);
         s.j.xyR[0][1] = (double)(10 * sign(sqr(v0) - v1) * (-1));
         if (sqrt(2.0) * v0 - 1 > 0.0) {
            s.fi.xR[0] += 100 * (sqrt(2.0) * v0 - 1);
            s.j.xyR[0][0] += 100 * sqrt(2.0);
         }
         if (2 * v1 - 1 > 0.0) {
            s.fi.xR[0] += 100 * (2 * v1 - 1);
            s.j.xyR[0][1] += 100 * 2;
         }
      } else ae_assert(false, "Assertion failed");
   minnsresults(&s, &x1, &rep);
   Ok = Ok && rep.terminationtype > 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && isfinite(x1.xR[0]) && NearAtR(x1.xR[0], sqrt(0.5), 0.001);
   Ok = Ok && isfinite(x1.xR[1]) && NearAtR(x1.xR[1], 0.5, 0.001);
   ae_frame_leave();
   return Ok;
}

// Basic box constrained test
static bool testminnsunit_basictest0bc() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   double sumits;
   double sumnfev;
   ae_int_t pass;
   ae_int_t passcount;
   double v0;
   double v1;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewObj(minnsstate, s);
   NewObj(minnsreport, rep);
   n = 5;
   passcount = 10;
   sumits = 0.0;
   sumnfev = 0.0;
   ae_vector_set_length(&x0, n);
   ae_vector_set_length(&bl, n);
   ae_vector_set_length(&bu, n);
   ae_vector_set_length(&d, n);
   for (pass = 1; pass <= 10; pass++) {
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         d.xR[i] = pow(10.0, randommid());
         v0 = randommid();
         v1 = randommid();
         bl.xR[i] = rmin2(v0, v1);
         bu.xR[i] = rmax2(v0, v1);
      }
      minnscreate(n, &x0, &s);
      minnssetalgoags(&s, 0.1, 0.0);
      minnssetbc(&s, &bl, &bu);
      while (minnsiteration(&s))
         if (s.needfij) {
            s.fi.xR[0] = 0.0;
            for (i = 0; i < n; i++) {
               s.fi.xR[0] += d.xR[i] * fabs(s.x.xR[i]);
               s.j.xyR[0][i] = d.xR[i] * sign(s.x.xR[i]);
            }
         } else ae_assert(false, "Assertion failed");
      minnsresults(&s, &x1, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && isfinite(x1.xR[i]) && NearAtR(x1.xR[i], rboundval(0.0, bl.xR[i], bu.xR[i]), 0.001);
      }
      sumits += (double)rep.iterationscount / passcount;
      sumnfev += (double)rep.nfev / passcount;
   }
   ae_frame_leave();
   return Ok;
}

// Basic constrained test: nonsmooth Rosenbrock posed as box constrained problem.
//
//              [                         ]
//     minimize [ 10*|x0^2-x1| + (1-x0)^2 ]
//              [                         ]
//
//     s.t. x0 <= 1/sqrt(2), x1 <= 0.5
//
// Its exact solution is x0 == 1/sqrt(2), x1 == 1/2
static bool testminnsunit_basictest1bc() {
   ae_frame _frame_block;
   ae_int_t n;
   double v0;
   double v1;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewObj(minnsstate, s);
   NewObj(minnsreport, rep);
   n = 2;
   ae_vector_set_length(&x0, n);
   ae_vector_set_length(&bndl, n);
   ae_vector_set_length(&bndu, n);
   x0.xR[0] = 0.0;
   x0.xR[1] = 0.0;
   bndl.xR[0] = -INFINITY;
   bndl.xR[1] = -INFINITY;
   bndu.xR[0] = 1 / sqrt(2.0);
   bndu.xR[1] = 1.0 / 2.0;
   minnscreate(n, &x0, &s);
   minnssetbc(&s, &bndl, &bndu);
   minnssetalgoags(&s, 0.1, 0.0);
   while (minnsiteration(&s))
      if (s.needfij) {
         v0 = s.x.xR[0];
         v1 = s.x.xR[1];
         s.fi.xR[0] = 10 * fabs(sqr(v0) - v1) + sqr(v0 - 1);
         s.j.xyR[0][0] = 10 * sign(sqr(v0) - v1) * 2 * v0 + 2 * (v0 - 1);
         s.j.xyR[0][1] = (double)(10 * sign(sqr(v0) - v1) * (-1));
      } else ae_assert(false, "Assertion failed");
   minnsresults(&s, &x1, &rep);
   Ok = Ok && rep.terminationtype > 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && isfinite(x1.xR[0]) && NearAtR(x1.xR[0], sqrt(0.5), 0.001);
   Ok = Ok && isfinite(x1.xR[1]) && NearAtR(x1.xR[1], 0.5, 0.001);
   ae_frame_leave();
   return Ok;
}

// Basic linearly constrained test
static bool testminnsunit_basictest0lc() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   double d;
   double sumits;
   double sumnfev;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t nc;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(minnsstate, s);
   NewObj(minnsreport, rep);
   d = -10.0;
   n = 5;
   passcount = 10;
   sumits = 0.0;
   sumnfev = 0.0;
   ae_vector_set_length(&x0, n);
   ae_matrix_set_length(&c, 2 * n, n + 1);
   ae_vector_set_length(&ct, 2 * n);
   for (pass = 1; pass <= 10; pass++) {
      nc = 0;
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         if (randombool()) {
            for (j = 0; j <= n; j++) {
               c.xyR[nc][j] = 0.0;
            }
            c.xyR[nc][i] = 1.0 + randomreal();
            ct.xZ[nc] = 0;
            nc++;
         } else {
            for (j = 0; j <= n; j++) {
               c.xyR[nc][j] = 0.0;
               c.xyR[nc + 1][j] = 0.0;
            }
            c.xyR[nc][i] = 1.0 + randomreal();
            c.xyR[nc + 1][i] = 1.0 + randomreal();
            ct.xZ[nc] = 1;
            ct.xZ[nc + 1] = -1;
            nc += 2;
         }
      }
      minnscreate(n, &x0, &s);
      minnssetalgoags(&s, 0.1, 0.0);
      minnssetlc(&s, &c, &ct, nc);
      while (minnsiteration(&s))
         if (s.needfij) {
            s.fi.xR[0] = 0.0;
            for (i = 0; i < n; i++) {
               s.fi.xR[0] = d * sqr(s.x.xR[i]);
               s.j.xyR[0][i] = d * 2 * s.x.xR[i];
            }
         } else ae_assert(false, "Assertion failed");
      minnsresults(&s, &x1, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && isfinite(x1.xR[i]) && SmallAtR(x1.xR[i], 0.001);
      }
      sumits += (double)rep.iterationscount / passcount;
      sumnfev += (double)rep.nfev / passcount;
   }
   ae_frame_leave();
   return Ok;
}

// Basic constrained test: nonsmooth Rosenbrock posed as linearly constrained problem.
//
//              [                         ]
//     minimize [ 10*|x0^2-x1| + (1-x0)^2 ]
//              [                         ]
//
//     s.t. x0 <= 1/sqrt(2), x1 <= 0.5
//
// Its exact solution is x0 == 1/sqrt(2), x1 == 1/2
static bool testminnsunit_basictest1lc() {
   ae_frame _frame_block;
   ae_int_t n;
   double v0;
   double v1;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(minnsstate, s);
   NewObj(minnsreport, rep);
   n = 2;
   ae_vector_set_length(&x0, n);
   ae_matrix_set_length(&c, 2, n + 1);
   ae_vector_set_length(&ct, 2);
   x0.xR[0] = 0.0;
   x0.xR[1] = 0.0;
   c.xyR[0][0] = 1.0;
   c.xyR[0][1] = 0.0;
   c.xyR[0][2] = 1 / sqrt(2.0);
   c.xyR[1][0] = 0.0;
   c.xyR[1][1] = 1.0;
   c.xyR[1][2] = 1.0 / 2.0;
   ct.xZ[0] = -1;
   ct.xZ[1] = -1;
   minnscreate(n, &x0, &s);
   minnssetlc(&s, &c, &ct, 2);
   minnssetalgoags(&s, 0.1, 0.0);
   while (minnsiteration(&s))
      if (s.needfij) {
         v0 = s.x.xR[0];
         v1 = s.x.xR[1];
         s.fi.xR[0] = 10 * fabs(sqr(v0) - v1) + sqr(v0 - 1);
         s.j.xyR[0][0] = 10 * sign(sqr(v0) - v1) * 2 * v0 + 2 * (v0 - 1);
         s.j.xyR[0][1] = (double)(10 * sign(sqr(v0) - v1) * (-1));
      } else ae_assert(false, "Assertion failed");
   minnsresults(&s, &x1, &rep);
   Ok = Ok && rep.terminationtype > 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && isfinite(x1.xR[0]) && NearAtR(x1.xR[0], sqrt(0.5), 0.001);
   Ok = Ok && isfinite(x1.xR[1]) && NearAtR(x1.xR[1], 0.5, 0.001);
   ae_frame_leave();
   return Ok;
}

// Basic nonlinearly constrained test
static bool testminnsunit_basictest0nlc() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t nec;
   ae_int_t nic;
   double d;
   double sumits;
   double sumnfev;
   ae_int_t pass;
   ae_int_t passcount;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewMatrix(ec, 0, 0, DT_REAL);
   NewMatrix(ic, 0, 0, DT_REAL);
   NewObj(minnsstate, s);
   NewObj(minnsreport, rep);
   d = -10.0;
   n = 5;
   passcount = 10;
   sumits = 0.0;
   sumnfev = 0.0;
   ae_vector_set_length(&x0, n);
   ae_matrix_set_length(&ec, 2 * n, n + 1);
   ae_matrix_set_length(&ic, 2 * n, n + 1);
   for (pass = 1; pass <= 10; pass++) {
      nec = 0;
      nic = 0;
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         if (randombool()) {
            for (j = 0; j <= n; j++) {
               ec.xyR[nec][j] = 0.0;
            }
            ec.xyR[nec][i] = 1.0 + randomreal();
            nec++;
         } else {
            for (j = 0; j <= n; j++) {
               ic.xyR[nic][j] = 0.0;
               ic.xyR[nic + 1][j] = 0.0;
            }
            ic.xyR[nic][i] = 1.0 + randomreal();
            ic.xyR[nic + 1][i] = -1.0 - randomreal();
            nic += 2;
         }
      }
      minnscreate(n, &x0, &s);
      minnssetalgoags(&s, 0.1, 100.0);
      minnssetnlc(&s, nec, nic);
      while (minnsiteration(&s))
         if (s.needfij) {
            s.fi.xR[0] = 0.0;
            for (j = 0; j < n; j++) {
               s.fi.xR[0] = d * sqr(s.x.xR[j]);
               s.j.xyR[0][j] = d * 2 * s.x.xR[j];
            }
            for (i = 0; i < nec; i++) {
               s.fi.xR[1 + i] = -ec.xyR[i][n];
               for (j = 0; j < n; j++) {
                  s.fi.xR[1 + i] += s.x.xR[j] * ec.xyR[i][j];
                  s.j.xyR[1 + i][j] = ec.xyR[i][j];
               }
            }
            for (i = 0; i < nic; i++) {
               s.fi.xR[1 + nec + i] = -ic.xyR[i][n];
               for (j = 0; j < n; j++) {
                  s.fi.xR[1 + nec + i] += s.x.xR[j] * ic.xyR[i][j];
                  s.j.xyR[1 + nec + i][j] = ic.xyR[i][j];
               }
            }
         } else ae_assert(false, "Assertion failed");
      minnsresults(&s, &x1, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < n; i++) {
         Ok = Ok && isfinite(x1.xR[i]) && SmallAtR(x1.xR[i], 0.001);
      }
      sumits += (double)rep.iterationscount / passcount;
      sumnfev += (double)rep.nfev / passcount;
   }
   ae_frame_leave();
   return Ok;
}

// Unconstrained test
static bool testminnsunit_testuc(bool *OtherOkP) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   double v;
   ae_int_t pass;
   bool requirexrep;
   double epsrad;
   bool werexreports;
   double repferr;
   double xtol;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x0s, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x1s, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(xrfirst, 0, DT_REAL);
   NewVector(xrlast, 0, DT_REAL);
   NewObj(minnsstate, state);
   NewObj(minnsreport, rep);
   for (pass = 1; pass <= 10; pass++) {
      for (n = 1; n <= 5; n++) {
      // First test:
      // * test that problem is successfully solved
      // * test that X-reports are performed correctly - present
      //   when requested, return first and last points correctly,
      //   not present by default, function value is reported
      //   correctly.
      // * we use non-unit scale, randomly chosen one, which results
      //   in badly conditioned problems (to check robustness)
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&xrfirst, n);
         ae_vector_set_length(&xrlast, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 10.0 * randommid();
            xc.xR[i] = randommid();
            d.xR[i] = pow(10.0, 2.0 * randommid());
            s.xR[i] = pow(10.0, 2.0 * randommid());
         }
         requirexrep = randombool();
         epsrad = 0.01 * pow(10.0, -2 * randomreal());
         xtol = 15.0 * epsrad;
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, epsrad, 0);
         minnssetscale(&state, &s);
         if (requirexrep) {
            minnssetxrep(&state, true);
         }
         werexreports = false;
         repferr = 0.0;
         while (minnsiteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] - xc.xR[i]);
               }
            } else if (state.xupdated) {
               if (!werexreports) {
                  ae_v_move(xrfirst.xR, 1, state.x.xR, 1, n);
               }
               ae_v_move(xrlast.xR, 1, state.x.xR, 1, n);
               werexreports = true;
               v = 0.0;
               for (i = 0; i < n; i++) {
                  v += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
               }
               repferr = rmax2(repferr, fabs(v - state.f));
            } else ae_assert(false, "Assertion failed");
         minnsresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         *OtherOkP = *OtherOkP && werexreports == requirexrep;
         *OtherOkP = *OtherOkP && repferr <= 10000.0 * machineepsilon;
         if (!Ok || !*OtherOkP) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && isfinite(x1.xR[i]) && NearAtR(x1.xR[i], xc.xR[i], s.xR[i] * xtol);
            if (requirexrep) {
               *OtherOkP = *OtherOkP && isfinite(xrfirst.xR[i]) && NearAtR(x0.xR[i], xrfirst.xR[i], 100.0 * machineepsilon);
               *OtherOkP = *OtherOkP && isfinite(xrlast.xR[i]) && NearAtR(x1.xR[i], xrlast.xR[i], 100.0 * machineepsilon);
            }
         }
      // Test numerical differentiation:
      // * test that problem is successfully solved
      // * test that correct function value is reported
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&xrlast, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 10.0 * randommid();
            xc.xR[i] = randommid();
            d.xR[i] = pow(10.0, 2.0 * randommid());
            s.xR[i] = pow(10.0, 2.0 * randommid());
         }
         epsrad = 0.01 * pow(10.0, -2 * randomreal());
         xtol = 15.0 * epsrad;
         minnscreatef(n, &x0, epsrad / 100, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, epsrad, 0);
         minnssetscale(&state, &s);
         minnssetxrep(&state, true);
         repferr = 0.0;
         while (minnsiteration(&state))
            if (state.needfi) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
               }
            } else if (state.xupdated) {
               v = 0.0;
               for (i = 0; i < n; i++) {
                  v += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
               }
               repferr = rmax2(repferr, fabs(v - state.f));
            } else ae_assert(false, "Assertion failed");
         minnsresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         *OtherOkP = *OtherOkP && repferr <= 10000.0 * machineepsilon;
         if (!Ok || !*OtherOkP) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && isfinite(x1.xR[i]) && NearAtR(x1.xR[i], xc.xR[i], s.xR[i] * xtol);
         }
      // Test scaling: we perform several steps on unit-scale problem,
      // then we perform same amount of steps on re-scaled problem,
      // starting from same point (but scaled according to chosen scale).
      //
      // Correctly written optimizer should perform essentially same steps
      // (up to scale) on both problems. At least, it holds within first
      // several steps, before rounding errors start to accumulate.
      //
      // NOTE: we also check that correctly scaled points are reported.
      //       And, as side effect, we check MinNSRestartFrom().
      //
      // NOTE: we use moderate scale and diagonal coefficients in order
      //       to have well-conditioned system. We test correctness of
      //       formulae here, not robustness of algorithm.
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&x0s, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&xrlast, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, randommid());
            d.xR[i] = pow(10.0, randommid());
            x0.xR[i] = randommid();
            xc.xR[i] = randommid();
            x0s.xR[i] = x0.xR[i] * s.xR[i];
         }
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, 0.0, testminnsunit_scalingtestcnt);
         minnssetxrep(&state, false);
         while (minnsiteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] - xc.xR[i]);
               }
            } else ae_assert(false, "Assertion failed");
         minnsresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok || !*OtherOkP) {
            ae_frame_leave();
            return Ok;
         }
         minnssetscale(&state, &s);
         minnssetxrep(&state, true);
         werexreports = false;
         for (minnsrestartfrom(&state, &x0s); minnsiteration(&state); )
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] / s.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] / s.xR[i] - xc.xR[i]) / s.xR[i];
               }
            } else if (state.xupdated) {
               ae_v_move(xrlast.xR, 1, state.x.xR, 1, n);
               werexreports = true;
            } else ae_assert(false, "Assertion failed");
         minnsresults(&state, &x1s, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok || !*OtherOkP) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && isfinite(x1.xR[i]) && isfinite(x1s.xR[i]) && NearAtR(x1.xR[i], x1s.xR[i] / s.xR[i], 1.0E-4);
            *OtherOkP = *OtherOkP && isfinite(xrlast.xR[i]) && NearAtR(x1s.xR[i], xrlast.xR[i], testminnsunit_scalingtesttol);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Box constrained test
static bool testminnsunit_testbc(bool *OtherOkP) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double v0;
   double v1;
   ae_int_t pass;
   ae_int_t passcount;
   bool requirexrep;
   double epsrad;
   bool werexreports;
   double repferr;
   double xtol;
   ae_int_t maxn;
   double conda;
   double gnorm;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x0s, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x1s, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(scaledbndl, 0, DT_REAL);
   NewVector(scaledbndu, 0, DT_REAL);
   NewVector(xrfirst, 0, DT_REAL);
   NewVector(xrlast, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(minnsstate, state);
   NewObj(minnsreport, rep);
   passcount = 10;
   maxn = 5;
// First test:
// * sparse function
// * test that problem is successfully solved
// * non-unit scale is used, which results in badly conditioned problem
// * check that all iterates are feasible (box-constrained)
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&xrfirst, n);
         ae_vector_set_length(&xrlast, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 10.0 * randommid();
            xc.xR[i] = randommid();
            d.xR[i] = pow(10.0, 2.0 * randommid());
            s.xR[i] = pow(10.0, 2.0 * randommid());
            bndl.xR[i] = -INFINITY;
            bndu.xR[i] = +INFINITY;
            k = randominteger(5);
            if (k == 1) {
               bndl.xR[i] = randommid();
            }
            if (k == 2) {
               bndu.xR[i] = randommid();
            }
            if (k == 3) {
               v0 = randommid();
               v1 = randommid();
               bndl.xR[i] = rmin2(v0, v1);
               bndu.xR[i] = rmax2(v0, v1);
            }
            if (k == 4) {
               bndl.xR[i] = randommid();
               bndu.xR[i] = bndl.xR[i];
            }
         }
         requirexrep = randombool();
         epsrad = 0.01 * pow(10.0, -2 * randomreal());
         xtol = 15.0 * epsrad;
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, epsrad, 0);
         minnssetbc(&state, &bndl, &bndu);
         minnssetscale(&state, &s);
         if (requirexrep) {
            minnssetxrep(&state, true);
         }
         werexreports = false;
         repferr = 0.0;
         while (minnsiteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] - xc.xR[i]);
               }
            } else if (state.xupdated) {
               if (!werexreports) {
                  ae_v_move(xrfirst.xR, 1, state.x.xR, 1, n);
               }
               ae_v_move(xrlast.xR, 1, state.x.xR, 1, n);
               werexreports = true;
               v = 0.0;
               for (i = 0; i < n; i++) {
                  v += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
               }
               repferr = rmax2(repferr, fabs(v - state.f));
               for (i = 0; i < n; i++) {
                  Ok = Ok && state.x.xR[i] >= bndl.xR[i];
                  Ok = Ok && state.x.xR[i] <= bndu.xR[i];
               }
            } else ae_assert(false, "Assertion failed");
         minnsresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         *OtherOkP = *OtherOkP && werexreports == requirexrep;
         *OtherOkP = *OtherOkP && repferr <= 10000.0 * machineepsilon;
         if (!Ok || !*OtherOkP) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && isfinite(x1.xR[i]) && NearAtR(x1.xR[i], rboundval(xc.xR[i], bndl.xR[i], bndu.xR[i]), s.xR[i] * xtol);
            Ok = Ok && x1.xR[i] >= bndl.xR[i];
            Ok = Ok && x1.xR[i] <= bndu.xR[i];
            if (requirexrep) {
               *OtherOkP = *OtherOkP && isfinite(xrfirst.xR[i]) && NearAtR(rboundval(x0.xR[i], bndl.xR[i], bndu.xR[i]), xrfirst.xR[i], 100.0 * machineepsilon);
               *OtherOkP = *OtherOkP && isfinite(xrlast.xR[i]) && NearAtR(x1.xR[i], xrlast.xR[i], 100.0 * machineepsilon);
            }
         }
      }
   }
// A bit harder test:
// * dense quadratic function (smooth), may be prone to different
//   rounding-related issues
// * non-negativity box constraints
// * unit scale is used
// * extreme stopping criteria (EpsX == 1.0E-12)
// * single pass for each problem size
// * check that constrained gradient at solution is small
   conda = 1.0E3;
   epsrad = 1.0E-12;
   for (n = 1; n <= 10; n++) {
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&b, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = 1.0;
         b.xR[i] = randomreal() - 0.5;
         bndl.xR[i] = 0.0;
         bndu.xR[i] = +INFINITY;
      }
      spdmatrixrndcond(n, conda, &a);
      minnscreate(n, &x0, &state);
      minnssetalgoags(&state, 0.1, 0.0);
      minnssetcond(&state, epsrad, 0);
      minnssetbc(&state, &bndl, &bndu);
      while (minnsiteration(&state))
         if (state.needfij) {
            state.fi.xR[0] = 0.0;
            for (i = 0; i < n; i++) {
               state.j.xyR[0][i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               state.fi.xR[0] += b.xR[i] * state.x.xR[i];
               for (j = 0; j < n; j++) {
                  state.fi.xR[0] += 0.5 * state.x.xR[i] * a.xyR[i][j] * state.x.xR[j];
               }
            }
            for (i = 0; i < n; i++) {
               state.j.xyR[0][i] += b.xR[i];
               for (j = 0; j < n; j++) {
                  state.j.xyR[0][i] += a.xyR[i][j] * state.x.xR[j];
               }
            }
         } else ae_assert(false, "Assertion failed");
      minnsresults(&state, &x1, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok || !*OtherOkP) {
         ae_frame_leave();
         return Ok;
      }
      gnorm = 0.0;
      for (i = 0; i < n; i++) {
         v = b.xR[i];
         for (j = 0; j < n; j++) {
            v += a.xyR[i][j] * x1.xR[j];
         }
         if (x1.xR[i] == bndl.xR[i] && v > 0.0) {
            v = 0.0;
         }
         if (x1.xR[i] == bndu.xR[i] && v < 0.0) {
            v = 0.0;
         }
         gnorm += sqr(v);
         Ok = Ok && x1.xR[i] >= bndl.xR[i];
         Ok = Ok && x1.xR[i] <= bndu.xR[i];
      }
      gnorm = sqrt(gnorm);
      Ok = Ok && gnorm <= 1.0E-5;
   }
// Test on HIGHLY nonconvex bound constrained problem.
// Algorithm should be able to stop.
//
// NOTE: because algorithm can be attracted to saddle points,
//       x[i] may be -1, +1 or approximately zero.
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = randomreal() - 0.5;
            bndl.xR[i] = -1.0;
            bndu.xR[i] = 1.0;
         }
         epsrad = 0.0001;
         xtol = 15.0 * epsrad;
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, epsrad, 0);
         minnssetbc(&state, &bndl, &bndu);
         v = -1000.0;
         while (minnsiteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  v0 = fabs(state.x.xR[i]);
                  v1 = (double)sign(state.x.xR[i]);
                  state.fi.xR[0] += v * (v0 + v0 * v0);
                  state.j.xyR[0][i] = v * (v1 + 2 * v0 * v1);
               }
            } else ae_assert(false, "Assertion failed");
         minnsresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         for (i = 0; i < n; i++) {
            v = fabs(x1.xR[i]);
            Ok = Ok && isfinite(x1.xR[i]);
            Ok = Ok && (v == 1.0 || v <= xtol);
         }
      }
   }
// Test numerical differentiation:
// * test that problem is successfully solved
// * test that correct function value is reported
// * test that all iterates are within bound-constrained area
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&xrlast, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 10.0 * randommid();
            xc.xR[i] = randommid();
            d.xR[i] = pow(10.0, 2.0 * randommid());
            s.xR[i] = pow(10.0, 2.0 * randommid());
            bndl.xR[i] = -INFINITY;
            bndu.xR[i] = +INFINITY;
            k = randominteger(5);
            if (k == 1) {
               bndl.xR[i] = randommid();
            }
            if (k == 2) {
               bndu.xR[i] = randommid();
            }
            if (k == 3) {
               v0 = randommid();
               v1 = randommid();
               bndl.xR[i] = rmin2(v0, v1);
               bndu.xR[i] = rmax2(v0, v1);
            }
            if (k == 4) {
               bndl.xR[i] = randommid();
               bndu.xR[i] = bndl.xR[i];
            }
         }
         epsrad = 0.01 * pow(10.0, -2 * randomreal());
         xtol = 15.0 * epsrad;
         minnscreatef(n, &x0, epsrad / 100, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, epsrad, 0);
         minnssetscale(&state, &s);
         minnssetbc(&state, &bndl, &bndu);
         minnssetxrep(&state, true);
         repferr = 0.0;
         while (minnsiteration(&state))
            if (state.needfi) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                  Ok = Ok && state.x.xR[i] >= bndl.xR[i];
                  Ok = Ok && state.x.xR[i] <= bndu.xR[i];
               }
            } else if (state.xupdated) {
               v = 0.0;
               for (i = 0; i < n; i++) {
                  v += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                  Ok = Ok && state.x.xR[i] >= bndl.xR[i];
                  Ok = Ok && state.x.xR[i] <= bndu.xR[i];
               }
               repferr = rmax2(repferr, fabs(v - state.f));
            } else ae_assert(false, "Assertion failed");
         minnsresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         *OtherOkP = *OtherOkP && repferr <= 10000.0 * machineepsilon;
         if (!Ok || !*OtherOkP) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && isfinite(x1.xR[i]) && NearAtR(x1.xR[i], rboundval(xc.xR[i], bndl.xR[i], bndu.xR[i]), s.xR[i] * xtol);
         }
      }
   }
// Test scaling: we perform several steps on unit-scale problem,
// then we perform same amount of steps on re-scaled problem,
// starting from same point (but scaled according to chosen scale).
//
// Correctly written optimizer should perform essentially same steps
// (up to scale) on both problems. At least, it holds within first
// several steps, before rounding errors start to accumulate.
//
// NOTE: we also check that correctly scaled points are reported.
//       And, as side effect, we check MinNSRestartFrom().
//
// NOTE: we use very low scale and diagonal coefficients in order
//       to have well-conditioned system. We test correctness of
//       formulae here, not robustness of algorithm.
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&x0s, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&xrlast, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&scaledbndl, n);
         ae_vector_set_length(&scaledbndu, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, randomreal() - 0.5);
            d.xR[i] = pow(10.0, randomreal() - 0.5);
            x0.xR[i] = randommid();
            xc.xR[i] = randommid();
            x0s.xR[i] = x0.xR[i] * s.xR[i];
            bndl.xR[i] = -INFINITY;
            bndu.xR[i] = +INFINITY;
            k = randominteger(5);
            if (k == 1) {
               bndl.xR[i] = randommid();
            }
            if (k == 2) {
               bndu.xR[i] = randommid();
            }
            if (k == 3) {
               v0 = randommid();
               v1 = randommid();
               bndl.xR[i] = rmin2(v0, v1);
               bndu.xR[i] = rmax2(v0, v1);
            }
            if (k == 4) {
               bndl.xR[i] = randommid();
               bndu.xR[i] = bndl.xR[i];
            }
            scaledbndl.xR[i] = bndl.xR[i] * s.xR[i];
            scaledbndu.xR[i] = bndu.xR[i] * s.xR[i];
         }
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.01, 0.0);
         minnssetcond(&state, 0.0, testminnsunit_scalingtestcnt);
         minnssetbc(&state, &bndl, &bndu);
         minnssetxrep(&state, false);
         while (minnsiteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] - xc.xR[i]);
               }
            } else ae_assert(false, "Assertion failed");
         minnsresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok || !*OtherOkP) {
            ae_frame_leave();
            return Ok;
         }
         minnssetscale(&state, &s);
         minnssetbc(&state, &scaledbndl, &scaledbndu);
         for (minnsrestartfrom(&state, &x0s); minnsiteration(&state); )
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] / s.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] / s.xR[i] - xc.xR[i]) / s.xR[i];
               }
            } else ae_assert(false, "Assertion failed");
         minnsresults(&state, &x1s, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok || !*OtherOkP) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && isfinite(x1.xR[i]) && isfinite(x1s.xR[i]) && NearAtR(x1.xR[i], x1s.xR[i] / s.xR[i], testminnsunit_scalingtesttol);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Linearly constrained test
static bool testminnsunit_testlc(bool *OtherOkP) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t nc;
   double v;
   double v0;
   double v1;
   double vv;
   double flast0;
   double flast1;
   ae_int_t pass;
   double epsrad;
   double repferr;
   double xtol;
   double ftol;
   double rho;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x0s, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(x1s, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(scaledc, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewVector(scaledbndl, 0, DT_REAL);
   NewVector(scaledbndu, 0, DT_REAL);
   NewVector(xrfirst, 0, DT_REAL);
   NewVector(xrlast, 0, DT_REAL);
   NewObj(minnsstate, state);
   NewObj(minnsreport, rep);
   for (pass = 1; pass <= 10; pass++) {
      for (n = 1; n <= 5; n++) {
      // First test:
      // * smooth problem
      // * subject to random linear constraints
      // * with non-unit scale
      //
      // We:
      // * compare function value at constrained solution with function
      //   value for penalized unconstrained problem. We do not compare
      //   actual X-values returned, because they are highly unstable -
      //   function values at minimum show better stability.
      // * check that correct function values are reported
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 10.0 * randommid();
            xc.xR[i] = randommid();
            d.xR[i] = 1 + randomreal();
            s.xR[i] = 1 + randomreal();
         }
         nc = randominteger((n + 1) / 2);
         if (nc > 0) {
            ae_matrix_set_length(&c, nc, n + 1);
            ae_vector_set_length(&ct, nc);
            for (i = 0; i < nc; i++) {
               ct.xZ[i] = randominteger(3) - 1;
               for (j = 0; j <= n; j++) {
                  c.xyR[i][j] = randomreal() - 0.5;
               }
            }
         }
         epsrad = 0.00001;
         ftol = 0.01;
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, epsrad, 0);
         minnssetscale(&state, &s);
         minnssetxrep(&state, true);
         minnssetlc(&state, &c, &ct, nc);
         repferr = 0.0;
         flast0 = NAN;
         while (minnsiteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * sqr(state.x.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * (2 * (state.x.xR[i] - xc.xR[i]));
               }
            } else if (state.xupdated) {
               flast0 = 0.0;
               for (i = 0; i < n; i++) {
                  flast0 += d.xR[i] * sqr(state.x.xR[i] - xc.xR[i]);
               }
               repferr = rmax2(repferr, fabs(flast0 - state.f));
            } else ae_assert(false, "Assertion failed");
         minnsresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && isfinite(flast0);
         *OtherOkP = *OtherOkP && repferr <= 10000.0 * machineepsilon;
         if (!Ok || !*OtherOkP) {
            ae_frame_leave();
            return Ok;
         }
         minnssetlc(&state, &c, &ct, 0);
         rho = 1000.0;
         repferr = 0.0;
         flast1 = NAN;
         for (minnsrestartfrom(&state, &x0); minnsiteration(&state); )
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * sqr(state.x.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * (2 * (state.x.xR[i] - xc.xR[i]));
               }
               for (i = 0; i < nc; i++) {
                  v = ae_v_dotproduct(state.x.xR, 1, c.xyR[i], 1, n);
                  v -= c.xyR[i][n];
                  vv = 0.0;
                  if (ct.xZ[i] < 0) {
                     vv = (double)sign(rmax2(v, 0.0));
                     v = rmax2(v, 0.0);
                  }
                  if (ct.xZ[i] == 0) {
                     vv = (double)sign(v);
                     v = fabs(v);
                  }
                  if (ct.xZ[i] > 0) {
                     vv = (double)-sign(rmax2(-v, 0.0));
                     v = rmax2(-v, 0.0);
                  }
                  state.fi.xR[0] += rho * v;
                  for (j = 0; j < n; j++) {
                     state.j.xyR[0][j] += rho * vv * c.xyR[i][j];
                  }
               }
            } else if (state.xupdated) {
               flast1 = 0.0;
               for (i = 0; i < n; i++) {
                  flast1 += d.xR[i] * sqr(state.x.xR[i] - xc.xR[i]);
               }
            } else ae_assert(false, "Assertion failed");
         minnsresults(&state, &x2, &rep);
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && isfinite(flast1);
         if (!Ok || !*OtherOkP) {
            ae_frame_leave();
            return Ok;
         }
         Ok = Ok && NearAtR(flast0, flast1, ftol);
      // Test on HIGHLY nonconvex linearly constrained problem.
      // Algorithm should be able to stop at the bounds.
         ae_vector_set_length(&x0, n);
         ae_matrix_set_length(&c, 2 * n, n + 1);
         ae_vector_set_length(&ct, 2 * n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = randomreal() - 0.5;
            for (j = 0; j < n; j++) {
               c.xyR[2 * i][j] = 0.0;
               c.xyR[2 * i + 1][j] = 0.0;
            }
            c.xyR[2 * i][i] = 1.0;
            c.xyR[2 * i][n] = -1.0;
            ct.xZ[2 * i] = 1;
            c.xyR[2 * i + 1][i] = 1.0;
            c.xyR[2 * i + 1][n] = 1.0;
            ct.xZ[2 * i + 1] = -1;
         }
         epsrad = 0.0001;
         xtol = 15.0 * epsrad;
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, epsrad, 0);
         minnssetlc(&state, &c, &ct, 2 * n);
         v = -1000.0;
         while (minnsiteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  v0 = fabs(state.x.xR[i]);
                  v1 = (double)sign(state.x.xR[i]);
                  state.fi.xR[0] += v * (v0 + v0 * v0);
                  state.j.xyR[0][i] = v * (v1 + 2 * v0 * v1);
               }
            } else ae_assert(false, "Assertion failed");
         minnsresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         for (i = 0; i < n; i++) {
            Ok = Ok && isfinite(x1.xR[i]);
            Ok = Ok && (NearAtR(x1.xR[i], 1.0, xtol) || SmallAtR(x1.xR[i], xtol) || NearAtR(x1.xR[i], -1.0, xtol));
         }
      // Test scaling: we perform several steps on unit-scale problem,
      // then we perform same amount of steps on re-scaled problem,
      // starting from same point (but scaled according to chosen scale).
      //
      // Correctly written optimizer should perform essentially same steps
      // (up to scale) on both problems. At least, it holds within first
      // several steps, before rounding errors start to accumulate.
      //
      // NOTE: we also check that correctly scaled points are reported.
      //       And, as side effect, we check MinNSRestartFrom().
      //
      // NOTE: we use moderate scale and diagonal coefficients in order
      //       to have well-conditioned system. We test correctness of
      //       formulae here, not robustness of algorithm.
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&x0s, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&xrlast, n);
         ae_matrix_set_length(&c, 2 * n, n + 1);
         ae_matrix_set_length(&scaledc, 2 * n, n + 1);
         ae_vector_set_length(&ct, 2 * n);
         for (i = 0; i < 2 * n; i++) {
            ct.xZ[i] = 0;
            for (j = 0; j <= n; j++) {
               c.xyR[i][j] = 0.0;
            }
         }
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, randommid());
            d.xR[i] = pow(10.0, randommid());
            x0.xR[i] = randommid();
            xc.xR[i] = randommid();
            x0s.xR[i] = x0.xR[i] * s.xR[i];
            k = randominteger(5);
            if (k == 1) {
               c.xyR[2 * i][i] = 1.0;
               c.xyR[2 * i][n] = randommid();
               ct.xZ[2 * i] = 1;
            }
            if (k == 2) {
               c.xyR[2 * i][i] = 1.0;
               c.xyR[2 * i][n] = randommid();
               ct.xZ[2 * i] = -1;
            }
            if (k == 3) {
               v0 = randommid();
               v1 = randommid();
               c.xyR[2 * i][i] = 1.0;
               c.xyR[2 * i][n] = rmin2(v0, v1);
               c.xyR[2 * i + 1][i] = 1.0;
               c.xyR[2 * i + 1][n] = rmax2(v0, v1);
               ct.xZ[2 * i] = 1;
               ct.xZ[2 * i + 1] = -1;
            }
            if (k == 4) {
               c.xyR[2 * i][i] = 1.0;
               c.xyR[2 * i][n] = randommid();
               ct.xZ[2 * i] = 0;
            }
         }
         for (i = 0; i < 2 * n; i++) {
            for (j = 0; j < n; j++) {
               scaledc.xyR[i][j] = c.xyR[i][j] / s.xR[j];
            }
            scaledc.xyR[i][n] = c.xyR[i][n];
         }
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, 0.0, testminnsunit_scalingtestcnt);
         minnssetlc(&state, &c, &ct, 2 * n);
         minnssetxrep(&state, false);
         while (minnsiteration(&state))
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] - xc.xR[i]);
               }
            } else ae_assert(false, "Assertion failed");
         minnsresults(&state, &x1, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok || !*OtherOkP) {
            ae_frame_leave();
            return Ok;
         }
         minnssetscale(&state, &s);
         minnssetlc(&state, &scaledc, &ct, 2 * n);
         for (minnsrestartfrom(&state, &x0s); minnsiteration(&state); )
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] / s.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] / s.xR[i] - xc.xR[i]) / s.xR[i];
               }
            } else ae_assert(false, "Assertion failed");
         minnsresults(&state, &x1s, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok || !*OtherOkP) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && isfinite(x1.xR[i]) && isfinite(x1s.xR[i]) && NearAtR(x1.xR[i], x1s.xR[i] / s.xR[i], testminnsunit_scalingtesttol);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Nonlinearly constrained test
static bool testminnsunit_testnlc(bool *OtherOkP) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t nc;
   ae_int_t nec;
   double v;
   ae_int_t pass;
   ae_int_t passcount;
   double epsrad;
   double xtol;
   double rho;
   ae_int_t maxn;
   double diffstep;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x0s, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(x1s, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(r, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(scaledc, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewVector(scaledbndl, 0, DT_REAL);
   NewVector(scaledbndu, 0, DT_REAL);
   NewVector(xrfirst, 0, DT_REAL);
   NewVector(xrlast, 0, DT_REAL);
   NewObj(minnsstate, state);
   NewObj(minnsreport, rep);
   passcount = 10;
   maxn = 5;
   rho = 100.0;
// First test:
// * simple problem
// * subject to random nonlinear constraints of form r[i]*x[i] OPERATION 0.0,
//   where OPERATION is <= or =
// * with non-unit scale
//
// We:
// * compare numerical solution with analytic one, which can be
//   easily calculated
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (nc = 1; nc <= n; nc++) {
            for (nec = 0; nec <= nc; nec++) {
               ae_vector_set_length(&x0, n);
               ae_vector_set_length(&xc, n);
               ae_vector_set_length(&d, n);
               ae_vector_set_length(&r, n);
               ae_vector_set_length(&s, n);
               for (i = 0; i < n; i++) {
                  x0.xR[i] = randommid();
                  xc.xR[i] = randommid();
                  d.xR[i] = pow(10.0, randomreal() - 0.5);
                  s.xR[i] = pow(10.0, randomreal() - 0.5);
                  r.xR[i] = (2 * randominteger(2) - 1) * (0.1 + randomreal());
               }
               epsrad = 0.001;
               xtol = 0.01;
               minnscreate(n, &x0, &state);
               minnssetalgoags(&state, 0.1, rho);
               minnssetcond(&state, epsrad, 0);
               minnssetscale(&state, &s);
               minnssetnlc(&state, nec, nc - nec);
               while (minnsiteration(&state))
                  if (state.needfij) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                        state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] - xc.xR[i]);
                     }
                     for (i = 1; i <= nc; i++) {
                        state.fi.xR[i] = state.x.xR[i - 1] * r.xR[i - 1];
                        for (j = 0; j < n; j++) {
                           state.j.xyR[i][j] = 0.0;
                        }
                        state.j.xyR[i][i - 1] = r.xR[i - 1];
                     }
                  } else ae_assert(false, "Assertion failed");
               minnsresults(&state, &x1, &rep);
               Ok = Ok && rep.terminationtype > 0;
               if (!Ok || !*OtherOkP) {
                  ae_frame_leave();
                  return Ok;
               }
               for (i = 0; i < n; i++) {
                  v = xc.xR[i];
                  if (i < nec) {
                     v = 0.0;
                  }
                  if (i >= nec && i < nc) {
                     if (r.xR[i] > 0.0) {
                        v = rmin2(v, 0.0);
                     }
                     if (r.xR[i] < 0.0) {
                        v = rmax2(v, 0.0);
                     }
                  }
                  Ok = Ok && isfinite(x1.xR[i]);
                  Ok = Ok && NearAtR(x1.xR[i], v, xtol * s.xR[i]);
               }
            }
         }
      }
   }
// Numerical differentiation test.
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (nc = 1; nc <= n; nc++) {
            for (nec = 0; nec <= nc; nec++) {
               ae_vector_set_length(&x0, n);
               ae_vector_set_length(&xc, n);
               ae_vector_set_length(&d, n);
               ae_vector_set_length(&r, n);
               ae_vector_set_length(&s, n);
               for (i = 0; i < n; i++) {
                  x0.xR[i] = randommid();
                  xc.xR[i] = randommid();
                  d.xR[i] = pow(10.0, randomreal() - 0.5);
                  s.xR[i] = pow(10.0, randomreal() - 0.5);
                  r.xR[i] = (2 * randominteger(2) - 1) * (0.1 + randomreal());
               }
               epsrad = 0.001;
               xtol = 0.01;
               diffstep = 0.001;
               minnscreatef(n, &x0, diffstep, &state);
               minnssetalgoags(&state, 0.1, rho);
               minnssetcond(&state, epsrad, 0);
               minnssetscale(&state, &s);
               minnssetnlc(&state, nec, nc - nec);
               while (minnsiteration(&state))
                  if (state.needfi) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                     }
                     for (i = 1; i <= nc; i++) {
                        state.fi.xR[i] = state.x.xR[i - 1] * r.xR[i - 1];
                     }
                  } else ae_assert(false, "Assertion failed");
               minnsresults(&state, &x1, &rep);
               Ok = Ok && rep.terminationtype > 0;
               if (!Ok || !*OtherOkP) {
                  ae_frame_leave();
                  return Ok;
               }
               for (i = 0; i < n; i++) {
                  v = xc.xR[i];
                  if (i < nec) {
                     v = 0.0;
                  }
                  if (i >= nec && i < nc) {
                     if (r.xR[i] > 0.0) {
                        v = rmin2(v, 0.0);
                     }
                     if (r.xR[i] < 0.0) {
                        v = rmax2(v, 0.0);
                     }
                  }
                  Ok = Ok && isfinite(x1.xR[i]);
                  Ok = Ok && NearAtR(x1.xR[i], v, xtol * s.xR[i]);
               }
            }
         }
      }
   }
// Test scaling: we perform several steps on unit-scale problem,
// then we perform same amount of steps on re-scaled problem,
// starting from same point (but scaled according to chosen scale).
//
// Correctly written optimizer should perform essentially same steps
// (up to scale) on both problems. At least, it holds within first
// several steps, before rounding errors start to accumulate.
//
// NOTE: we use moderate scale and diagonal coefficients in order
//       to have well-conditioned system. We test correctness of
//       formulae here, not robustness of algorithm.
//
// NOTE: we have to use very relaxed thresholds for this test because
//       each AGS iteration involves solution of several nested QP
//       subproblems, so rounding errors accumulate too quickly.
//       It does not mean that algorithm is inexact, just that two
//       almost identical optimization sessions diverge too fast to
//       compare them.
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (nc = 1; nc <= n; nc++) {
            for (nec = 0; nec <= nc; nec++) {
               ae_vector_set_length(&x0, n);
               ae_vector_set_length(&x0s, n);
               ae_vector_set_length(&xc, n);
               ae_vector_set_length(&d, n);
               ae_vector_set_length(&r, n);
               ae_vector_set_length(&s, n);
               for (i = 0; i < n; i++) {
                  x0.xR[i] = randommid();
                  xc.xR[i] = randommid();
                  d.xR[i] = pow(10.0, randomreal() - 0.5);
                  s.xR[i] = pow(10.0, randomreal() - 0.5);
                  r.xR[i] = (2 * randominteger(2) - 1) * (0.1 + randomreal());
                  x0s.xR[i] = x0.xR[i] * s.xR[i];
               }
               minnscreate(n, &x0, &state);
               minnssetalgoags(&state, 0.1, 1.0);
               minnssetcond(&state, 0.0, testminnsunit_scalingtestcnt);
               minnssetnlc(&state, nec, nc - nec);
               while (minnsiteration(&state))
                  if (state.needfij) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                        state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] - xc.xR[i]);
                     }
                     for (i = 1; i <= nc; i++) {
                        state.fi.xR[i] = state.x.xR[i - 1] * r.xR[i - 1];
                        for (j = 0; j < n; j++) {
                           state.j.xyR[i][j] = 0.0;
                        }
                        state.j.xyR[i][i - 1] = r.xR[i - 1];
                     }
                  } else ae_assert(false, "Assertion failed");
               minnsresults(&state, &x1, &rep);
               Ok = Ok && rep.terminationtype > 0;
               if (!Ok || !*OtherOkP) {
                  ae_frame_leave();
                  return Ok;
               }
               minnssetscale(&state, &s);
               for (minnsrestartfrom(&state, &x0s); minnsiteration(&state); )
                  if (state.needfij) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] / s.xR[i] - xc.xR[i]);
                        state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] / s.xR[i] - xc.xR[i]) / s.xR[i];
                     }
                     for (i = 1; i <= nc; i++) {
                        state.fi.xR[i] = state.x.xR[i - 1] / s.xR[i - 1] * r.xR[i - 1];
                        for (j = 0; j < n; j++) {
                           state.j.xyR[i][j] = 0.0;
                        }
                        state.j.xyR[i][i - 1] = r.xR[i - 1] / s.xR[i - 1];
                     }
                  } else ae_assert(false, "Assertion failed");
               minnsresults(&state, &x1s, &rep);
               for (i = 0; i < n; i++) {
                  Ok = Ok && isfinite(x1.xR[i]) && isfinite(x1s.xR[i]) && NearAtR(x1.xR[i], x1s.xR[i] / s.xR[i], testminnsunit_scalingtesttol);
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Special tests
static bool testminnsunit_testother() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t k;
   double v0;
   double v1;
   double v;
   double xtol;
   double epsrad;
   double rho;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewObj(minnsstate, state);
   NewObj(minnsreport, rep);
// First test:
// * 2D problem, minimization of F(x0,x1) == x1
// * two constraints, with wildly different magnitudes
//   * G0(x0,x1) == Rho*Abs(x0+x1) == 0
//   * H0(x0,x1) == Rho*(x0-1000) <= 0
//   where Rho is some large value
//
// Optimizer should be able to deal with situation when
// magnitude of Jacobian components is so wildly different.
   n = 2;
   ae_vector_set_length(&x0, n);
   x0.xR[0] = 0.1;
   x0.xR[1] = 1.0;
   epsrad = 0.00001;
   xtol = 0.01;
   for (k = 0; k <= 6; k++) {
      rho = pow(10.0, (double)k);
      minnscreate(n, &x0, &state);
      minnssetalgoags(&state, 0.1, 10.0);
      minnssetcond(&state, epsrad, 0);
      minnssetnlc(&state, 1, 1);
      v = 1000.0;
      while (minnsiteration(&state))
         if (state.needfij) {
            v0 = state.x.xR[0];
            v1 = state.x.xR[1];
            state.fi.xR[0] = v1;
            state.j.xyR[0][0] = 0.0;
            state.j.xyR[0][1] = 1.0;
            state.fi.xR[1] = rho * fabs(v0 + v1);
            state.j.xyR[1][0] = rho * sign(v0 + v1);
            state.j.xyR[1][1] = rho * sign(v0 + v1);
            state.fi.xR[2] = rho * (v0 - v);
            state.j.xyR[2][0] = rho;
            state.j.xyR[2][1] = 0.0;
         } else ae_assert(false, "Assertion failed");
      minnsresults(&state, &x1, &rep);
      Ok = Ok && rep.terminationtype > 0;
      Ok = Ok && isfinite(x1.xR[0]);
      Ok = Ok && isfinite(x1.xR[1]);
      Ok = Ok && NearAtR(x1.xR[0], v, xtol);
      Ok = Ok && NearAtR(x1.xR[1], -v, xtol);
   }
   ae_frame_leave();
   return Ok;
}

bool testminns() {
   bool Ok;
   bool ucOk;
   bool bcOk;
   bool lcOk;
   bool nlcOk;
   bool otherOk;
   Ok = true;
   ucOk = true;
   bcOk = true;
   lcOk = true;
   nlcOk = true;
   otherOk = true;
// Basic tests
   nlcOk = nlcOk && testminnsunit_basictest0nlc();
   ucOk = ucOk && testminnsunit_basictest0uc();
   ucOk = ucOk && testminnsunit_basictest1uc();
   bcOk = bcOk && testminnsunit_basictest0bc();
   bcOk = bcOk && testminnsunit_basictest1bc();
   lcOk = lcOk && testminnsunit_basictest0lc();
   lcOk = lcOk && testminnsunit_basictest1lc();
// Special tests
   otherOk = otherOk && testminnsunit_testother();
// Full scale tests
   ucOk = ucOk && testminnsunit_testuc(&otherOk);
   bcOk = bcOk && testminnsunit_testbc(&otherOk);
   lcOk = lcOk && testminnsunit_testlc(&otherOk);
   nlcOk = nlcOk && testminnsunit_testnlc(&otherOk);
// The final report.
   Ok = ucOk && bcOk && lcOk && nlcOk && otherOk;
   if (!Ok || !silent) {
      printf("MinNS Optimization Tests\n");
      printf("* Unconstrained:                          %s\n", ucOk? "Ok": "Failed");
      printf("* Bound Constrained:                      %s\n", bcOk? "Ok": "Failed");
      printf("* Linearly Constrained:                   %s\n", lcOk? "Ok": "Failed");
      printf("* Non-Linearly Constrained:               %s\n", nlcOk? "Ok": "Failed");
      printf("* Other Properties:                       %s\n", otherOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === minbc testing unit ===
static const ae_int_t testminbcunit_maxoptguardlevel = 1;

// Calculate test function IIP2
//
// f(x) = sum( ((i*i+1)^FK*x[i])^2, i = 0..N-1)
//
// It has high condition number which makes fast convergence unlikely without
// good preconditioner.
//
static void testminbcunit_calciip2(minbcstate *state, ae_int_t n, ae_int_t fk) {
   ae_int_t i;
   if (state->needfg) {
      state->f = 0.0;
      for (i = 0; i < n; i++) {
         state->f += pow((double)(i * i + 1), (double)(2 * fk)) * sqr(state->x.xR[i]);
         state->g.xR[i] = pow((double)(i * i + 1), (double)(2 * fk)) * 2 * state->x.xR[i];
      }
   }
}

// This function sets random preconditioner:
// * unit one, for PrecKind == 0
// * diagonal-based one, for PrecKind == 1
// * scale-based one, for PrecKind == 2
static void testminbcunit_setrandompreconditioner(minbcstate *state, ae_int_t n, ae_int_t preckind) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewVector(p, 0, DT_REAL);
   if (preckind == 1) {
      ae_vector_set_length(&p, n);
      for (i = 0; i < n; i++) {
         p.xR[i] = exp(3.0 * randommid());
      }
      minbcsetprecdiag(state, &p);
   } else {
      minbcsetprecdefault(state);
   }
   ae_frame_leave();
}

// This function test feasibility properties.
// It launches a sequence of problems and examines their solutions.
// Most of the attention is directed towards feasibility properties,
// although we make some quick checks to ensure that actual solution is found.
//
// *ConvOkP is set to true on conversion errors, and is left unchanged otherwise.
// *IntOkP is set to true on internal errors (errors in the control flow).
static bool testminbcunit_testfeasibility(bool *ConvOkP, bool *IntOkP) {
   ae_frame _frame_block;
   ae_int_t pkind;
   ae_int_t preckind;
   ae_int_t passcount;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t nmax;
   ae_int_t i;
   ae_int_t p;
   double v;
   double weakepsg;
   ae_int_t dkind;
   double diffstep;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(svdw, 0, DT_REAL);
   NewMatrix(csvdu, 0, 0, DT_REAL);
   NewMatrix(svdvt, 0, 0, DT_REAL);
   NewObj(minbcstate, state);
   NewObj(minbcreport, rep);
   nmax = 5;
   weakepsg = 1.0E-4;
   passcount = 10;
   for (pass = 1; pass <= passcount; pass++) {
   // Another simple problem:
   // * bound constraints 0 <= x[i] <= 1
   // * no linear constraints
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P == {2,4} and x0 is randomly selected from [-1,+2]^N
   // * with such simple boundaries and function it is easy to find
   //   analytic form of solution: S[i] = bound(x0[i], 0, 1)
   // * we also check that both final solution and subsequent iterates
   //   are strictly feasible
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         for (preckind = 0; preckind <= 2; preckind++) {
            for (pkind = 1; pkind <= 2; pkind++) {
               for (n = 1; n <= nmax; n++) {
               // Generate X, BL, BU.
                  p = 2 * pkind;
                  ae_vector_set_length(&bl, n);
                  ae_vector_set_length(&bu, n);
                  ae_vector_set_length(&x, n);
                  ae_vector_set_length(&x0, n);
                  for (i = 0; i < n; i++) {
                     bl.xR[i] = 0.0;
                     bu.xR[i] = 1.0;
                     x.xR[i] = randomreal();
                     x0.xR[i] = 3.0 * randomreal() - 1.0;
                  }
               // Create and optimize
                  if (dkind == 0) {
                     minbccreate(n, &x, &state);
                  }
                  if (dkind == 1) {
                     minbccreatef(n, &x, diffstep, &state);
                  }
                  minbcsetbc(&state, &bl, &bu);
                  minbcsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbcunit_setrandompreconditioner(&state, n, preckind);
                  while (minbciteration(&state)) {
                     if (state.needf || state.needfg) {
                        state.f = 0.0;
                        for (i = 0; i < n; i++) {
                           state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                           if (state.needfg) {
                              state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                           }
                        }
                     }
                     for (i = 0; i < n; i++) {
                        Ok = Ok && state.x.xR[i] >= 0.0;
                        Ok = Ok && state.x.xR[i] <= 1.0;
                     }
                  }
                  minbcresults(&state, &x, &rep);
                  if (rep.terminationtype <= 0) {
                     *ConvOkP = false;
                     ae_frame_leave();
                     return Ok;
                  }
               // * compare solution with analytic one
               // * check feasibility
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     if (x.xR[i] > 0.0 && x.xR[i] < 1.0) {
                        v += sqr(p * pow(x.xR[i] - x0.xR[i], (double)(p - 1)));
                     }
                     Ok = Ok && x.xR[i] >= 0.0;
                     Ok = Ok && x.xR[i] <= 1.0;
                  }
                  *ConvOkP = *ConvOkP && sqrt(v) <= weakepsg;
               }
            }
         }
      }
   // Same as previous problem, but with minor modifications:
   // * some bound constraints are 0 <= x[i] <= 1, some are Ci == x[i] == Ci
   // * no linear constraints
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P == {2,4} and x0 is randomly selected from [-1,+2]^N
   // * with such simple boundaries and function it is easy to find
   //   analytic form of solution: S[i] = bound(x0[i], 0, 1)
   // * we also check that both final solution and subsequent iterates
   //   are strictly feasible
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         for (preckind = 0; preckind <= 2; preckind++) {
            for (pkind = 1; pkind <= 2; pkind++) {
               for (n = 1; n <= nmax; n++) {
               // Generate X, BL, BU.
                  p = 2 * pkind;
                  ae_vector_set_length(&bl, n);
                  ae_vector_set_length(&bu, n);
                  ae_vector_set_length(&x, n);
                  ae_vector_set_length(&x0, n);
                  for (i = 0; i < n; i++) {
                     if (randombool()) {
                        bl.xR[i] = 0.0;
                        bu.xR[i] = 1.0;
                     } else {
                        bl.xR[i] = randomreal();
                        bu.xR[i] = bl.xR[i];
                     }
                     x.xR[i] = randomreal();
                     x0.xR[i] = 3.0 * randomreal() - 1.0;
                  }
               // Create and optimize
                  if (dkind == 0) {
                     minbccreate(n, &x, &state);
                  }
                  if (dkind == 1) {
                     minbccreatef(n, &x, diffstep, &state);
                  }
                  minbcsetbc(&state, &bl, &bu);
                  minbcsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbcunit_setrandompreconditioner(&state, n, preckind);
                  while (minbciteration(&state)) {
                     if (state.needf || state.needfg) {
                        state.f = 0.0;
                        for (i = 0; i < n; i++) {
                           state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                           if (state.needfg) {
                              state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                           }
                        }
                     }
                     for (i = 0; i < n; i++) {
                        Ok = Ok && state.x.xR[i] >= bl.xR[i];
                        Ok = Ok && state.x.xR[i] <= bu.xR[i];
                     }
                  }
                  minbcresults(&state, &x, &rep);
                  if (rep.terminationtype <= 0) {
                     *ConvOkP = false;
                     ae_frame_leave();
                     return Ok;
                  }
               // * compare solution with analytic one
               // * check feasibility
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     if (x.xR[i] > bl.xR[i] && x.xR[i] < bu.xR[i]) {
                        v += sqr(p * pow(x.xR[i] - x0.xR[i], (double)(p - 1)));
                     }
                     Ok = Ok && x.xR[i] >= bl.xR[i];
                     Ok = Ok && x.xR[i] <= bu.xR[i];
                  }
                  *ConvOkP = *ConvOkP && sqrt(v) <= weakepsg;
               }
            }
         }
      }
   // Infeasible problem:
   // * all bound constraints are 0 <= x[i] <= 1 except for one
   // * that one is 0 >= x[i] >= 1
   // * no linear constraints
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from detecting
   //   infeasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P == {2,4} and x0 is randomly selected from [-1,+2]^N
   // * algorithm must return correct error code on such problem
      for (preckind = 0; preckind <= 2; preckind++) {
         for (pkind = 1; pkind <= 2; pkind++) {
            for (n = 1; n <= nmax; n++) {
            // Generate X, BL, BU.
               p = 2 * pkind;
               ae_vector_set_length(&bl, n);
               ae_vector_set_length(&bu, n);
               ae_vector_set_length(&x, n);
               ae_vector_set_length(&x0, n);
               for (i = 0; i < n; i++) {
                  bl.xR[i] = 0.0;
                  bu.xR[i] = 1.0;
                  x.xR[i] = randomreal();
                  x0.xR[i] = 3.0 * randomreal() - 1.0;
               }
               i = randominteger(n);
               bl.xR[i] = 1.0;
               bu.xR[i] = 0.0;
            // Create and optimize
               minbccreate(n, &x, &state);
               minbcsetbc(&state, &bl, &bu);
               minbcsetcond(&state, weakepsg, 0.0, 0.0, 0);
               testminbcunit_setrandompreconditioner(&state, n, preckind);
               while (minbciteration(&state))
                  if (state.needfg) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                        state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                     }
                  } else {
                  // Unknown protocol specified
                     *IntOkP = false;
                     ae_frame_leave();
                     return Ok;
                  }
               minbcresults(&state, &x, &rep);
               Ok = Ok && rep.terminationtype == -3;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function additional properties.
static bool testminbcunit_testother() {
   ae_frame _frame_block;
   ae_int_t passcount;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double fprev;
   double xprev;
   double stpmax;
   double v;
   ae_int_t pkind;
   ae_int_t ckind;
   ae_int_t mkind;
   double vc;
   double vm;
   double epsx;
   double epsg;
   double eps;
   double tmpeps;
   double diffstep;
   ae_int_t dkind;
   bool wasf;
   bool wasfg;
   double r;
   ae_int_t spoiliteration;
   ae_int_t stopiteration;
   ae_int_t spoilvar;
   double spoilval;
   double ss;
   ae_int_t stopcallidx;
   ae_int_t callidx;
   ae_int_t maxits;
   bool terminationrequested;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(xf, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewVector(a, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(h, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewObj(minbcstate, state);
   NewObj(minbcreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   epsx = 1.0E-4;
   epsg = 1.0E-8;
   passcount = 10;
// Try to reproduce bug 570 (optimizer hangs on problems where it is required
// to perform very small step - less than 1E-50 - in order to activate constraints).
//
// The problem being solved is:
//
//     min x[0]+x[1]+...+x[n-1]
//
// subject to
//
//     x[i] >= 0, for i = 0..n-1
//
// with initial point
//
//     x[0] = 1.0E-100, x[1] == x[2] == ... == 0.5
//
// We try to reproduce this problem in different settings:
// * boundary-only constraints - we test that completion code is positive,
//   and all x[] are EXACTLY zero
// * boundary constraints posed as general linear ones - we test that
//   completion code is positive, and all x[] are APPROXIMATELY zero.
   n = 10;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&bl, n);
   ae_vector_set_length(&bu, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = 0.5;
      bl.xR[i] = 0.0;
      bu.xR[i] = +INFINITY;
   }
   x.xR[0] = 1.0E-100;
   minbccreate(n, &x, &state);
   minbcsetbc(&state, &bl, &bu);
   minbcsetcond(&state, 0.0, 0.0, 0.0, 2 * n);
   while (minbciteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += state.x.xR[i];
            state.g.xR[i] = 1.0;
         }
      }
   minbcresults(&state, &xf, &rep);
   Ok = Ok && rep.terminationtype > 0;
   if (rep.terminationtype > 0) {
      for (i = 0; i < n; i++) {
         Ok = Ok && xf.xR[i] == 0.0;
      }
   }
// Test reports:
// * first value must be starting point
// * last value must be last point
   for (pass = 1; pass <= passcount; pass++) {
      n = 50;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      ae_vector_set_length(&bl, n);
      ae_vector_set_length(&bu, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 10.0;
         bl.xR[i] = randommid();
         bu.xR[i] = +INFINITY;
      }
      minbccreate(n, &x, &state);
      minbcsetbc(&state, &bl, &bu);
      minbcsetcond(&state, 1.0E-64, 0.0, 0.0, 10);
      minbcsetxrep(&state, true);
      fprev = maxrealnumber;
      while (minbciteration(&state))
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += sqr((1 + i) * state.x.xR[i]);
               state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
            }
         } else if (state.xupdated) {
            if (fprev == maxrealnumber) {
               for (i = 0; i < n; i++) {
                  Ok = Ok && state.x.xR[i] == x.xR[i];
               }
            }
            fprev = state.f;
            ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
         }
      minbcresults(&state, &x, &rep);
      for (i = 0; i < n; i++) {
         Ok = Ok && x.xR[i] == xlast.xR[i];
      }
   }
// Test differentiation vs. analytic gradient
// (first one issues NeedF requests, second one issues NeedFG requests)
   for (pass = 1; pass <= passcount; pass++) {
      n = 10;
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xlast, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 1.0;
         }
         if (dkind == 0) {
            minbccreate(n, &x, &state);
         }
         if (dkind == 1) {
            minbccreatef(n, &x, diffstep, &state);
         }
         minbcsetcond(&state, 1.0E-6, 0.0, epsx, 0);
         wasf = false;
         wasfg = false;
         while (minbciteration(&state))
            if (state.needf || state.needfg) {
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  state.f += sqr((1 + i) * state.x.xR[i]);
                  if (state.needfg) {
                     state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
                  }
               }
               wasf = wasf || state.needf;
               wasfg = wasfg || state.needfg;
            }
         minbcresults(&state, &x, &rep);
         if (dkind == 0) {
            Ok = Ok && !wasf && wasfg;
         }
         if (dkind == 1) {
            Ok = Ok && wasf && !wasfg;
         }
      }
   }
// Test that numerical differentiation uses scaling.
//
// In order to test that we solve simple optimization
// problem: min(x^2) with initial x equal to 0.0.
//
// We choose random DiffStep and S, then we check that
// optimizer evaluates function at +-DiffStep*S only.
   for (pass = 1; pass <= passcount; pass++) {
      ae_vector_set_length(&x, 1);
      ae_vector_set_length(&s, 1);
      diffstep = randomreal() * 1.0E-6;
      s.xR[0] = exp(2.0*randommid());
      x.xR[0] = 0.0;
      minbccreatef(1, &x, diffstep, &state);
      minbcsetcond(&state, 1.0E-6, 0.0, epsx, 0);
      minbcsetscale(&state, &s);
      v = 0.0;
      while (minbciteration(&state)) {
         state.f = sqr(state.x.xR[0]);
         v = rmax2(v, fabs(state.x.xR[0]));
      }
      minbcresults(&state, &x, &rep);
      r = v / (s.xR[0] * diffstep);
      Ok = Ok && SmallAtR(log(r), log(1.0 + 1000.0 * machineepsilon));
   }
// Test stpmax
   for (pass = 1; pass <= passcount; pass++) {
      n = 1;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&bl, n);
      ae_vector_set_length(&bu, n);
      x.xR[0] = 100.0;
      bl.xR[0] = randommid();
      bu.xR[0] = +INFINITY;
      stpmax = 0.05 + 0.05 * randomreal();
      minbccreate(n, &x, &state);
      minbcsetbc(&state, &bl, &bu);
      minbcsetcond(&state, epsg, 0.0, epsx, 0);
      minbcsetxrep(&state, true);
      minbcsetstpmax(&state, stpmax);
      xprev = x.xR[0];
      while (minbciteration(&state))
         if (state.needfg) {
            state.f = exp(state.x.xR[0]) + exp(-state.x.xR[0]);
            state.g.xR[0] = exp(state.x.xR[0]) - exp(-state.x.xR[0]);
            Ok = Ok && NearAtR(state.x.xR[0], xprev, (1 + sqrt(machineepsilon)) * stpmax);
         } else if (state.xupdated) {
            Ok = Ok && NearAtR(state.x.xR[0], xprev, (1 + sqrt(machineepsilon)) * stpmax);
            xprev = state.x.xR[0];
         }
   }
// Ability to solve problems with function which is unbounded from below
   for (pass = 1; pass <= passcount; pass++) {
      n = 1;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&bl, n);
      ae_vector_set_length(&bu, n);
      bl.xR[0] = 4.0 * randomreal() + 1;
      bu.xR[0] = bl.xR[0] + 1;
      x.xR[0] = 0.5 * (bl.xR[0] + bu.xR[0]);
      minbccreate(n, &x, &state);
      minbcsetbc(&state, &bl, &bu);
      minbcsetcond(&state, epsg, 0.0, epsx, 0);
      while (minbciteration(&state))
         if (state.needfg) {
            state.f = -1.0E8 * sqr(state.x.xR[0]);
            state.g.xR[0] = -2.0E8 * state.x.xR[0];
         }
      minbcresults(&state, &x, &rep);
      Ok = Ok && NearAtR(x.xR[0], bu.xR[0], epsx);
   }
// Test correctness of the scaling:
// * initial point is random point from [+1,+2]^N
// * f(x) = SUM(A[i]*x[i]^4), C[i] is random from [0.01,100]
// * function is EFFECTIVELY unconstrained; it has formal constraints,
//   but they are inactive at the solution; we try different variants
//   in order to explore different control paths of the optimizer:
//   0) absense of constraints
//   1) bound constraints -100000 <= x[i] <= 100000
// * we use random scaling matrix
// * we test different variants of the preconditioning:
//   0) unit preconditioner
//   1) random diagonal from [0.01,100]
//   2) scale preconditioner
// * we set very stringent stopping conditions
// * and we test that in the extremum stopping conditions are
//   satisfied subject to the current scaling coefficients.
   for (pass = 1; pass <= passcount; pass++) {
      tmpeps = 1.0E-5;
      for (n = 1; n <= 10; n++) {
         for (ckind = 0; ckind <= 1; ckind++) {
            for (pkind = 0; pkind <= 2; pkind++) {
               ae_vector_set_length(&x, n);
               ae_vector_set_length(&a, n);
               ae_vector_set_length(&s, n);
               ae_vector_set_length(&h, n);
               ae_vector_set_length(&bl, n);
               ae_vector_set_length(&bu, n);
               for (i = 0; i < n; i++) {
                  x.xR[i] = randomreal() + 1;
                  bl.xR[i] = -100000.0;
                  bu.xR[i] = 100000.0;
                  a.xR[i] = exp(log(10.0) * randommid());
                  s.xR[i] = exp(log(10.0) * randommid());
                  h.xR[i] = exp(log(10.0) * randommid());
               }
               minbccreate(n, &x, &state);
               if (ckind == 1) {
                  minbcsetbc(&state, &bl, &bu);
               }
               if (pkind == 1) {
                  minbcsetprecdiag(&state, &h);
               }
               if (pkind == 2) {
                  minbcsetprecscale(&state);
               }
               minbcsetcond(&state, tmpeps, 0.0, 0.0, 0);
               minbcsetscale(&state, &s);
               while (minbciteration(&state))
                  if (state.needfg) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += a.xR[i] * sqr(state.x.xR[i]);
                        state.g.xR[i] = 2 * a.xR[i] * state.x.xR[i];
                     }
                  }
               minbcresults(&state, &x, &rep);
               if (rep.terminationtype <= 0) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
               v = 0.0;
               for (i = 0; i < n; i++) {
                  v += sqr(s.xR[i] * 2 * a.xR[i] * x.xR[i]);
               }
               v = sqrt(v);
               Ok = Ok && v <= tmpeps;
            }
         }
      }
   }
// Check correctness of the "trimming".
//
// Trimming is a technique which is used to help algorithm
// cope with unbounded functions. In order to check this
// technique we will try to solve following optimization
// problem:
//
//     min f(x) subject to no constraints on X
//            { 1/(1-x) + 1/(1+x) + c*x, if -0.999999 < x < 0.999999
//     f(x) = {
//            { M, if x <= -0.999999 or x >= 0.999999
//
// where c is either 1.0 or 1.0E+4, M is either 1.0E8, 1.0E20 or +INF
// (we try different combinations)
   for (pass = 1; pass <= passcount; pass++) {
      for (ckind = 0; ckind <= 1; ckind++) {
         for (mkind = 0; mkind <= 2; mkind++) {
         // Choose c and M
            vc = 1.0;
            vm = 1.0;
            if (ckind == 0) {
               vc = 1.0;
            }
            if (ckind == 1) {
               vc = 1.0E+4;
            }
            if (mkind == 0) {
               vm = 1.0E+8;
            }
            if (mkind == 1) {
               vm = 1.0E+20;
            }
            if (mkind == 2) {
               vm = +INFINITY;
            }
         // Create optimizer, solve optimization problem
            epsg = 1.0E-6 * vc;
            ae_vector_set_length(&x, 1);
            x.xR[0] = 0.0;
            minbccreate(1, &x, &state);
            minbcsetcond(&state, epsg, 0.0, 0.0, 0);
            while (minbciteration(&state))
               if (state.needfg) {
                  if (-0.999999 < state.x.xR[0] && state.x.xR[0] < 0.999999) {
                     state.f = 1 / (1 - state.x.xR[0]) + 1 / (1 + state.x.xR[0]) + vc * state.x.xR[0];
                     state.g.xR[0] = 1 / sqr(1 - state.x.xR[0]) - 1 / sqr(1 + state.x.xR[0]) + vc;
                  } else {
                     state.f = vm;
                     state.g.xR[0] = 0.0;
                  }
               }
            minbcresults(&state, &x, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            Ok = Ok && NearAtR(1.0 / sqr(1 - x.xR[0]), 1.0 / sqr(1 + x.xR[0]) - vc, epsg);
         }
      }
   }
// Test behaviour on noisy functions.
//
// Consider following problem:
// * f(x,y) = (x+1)^2 + (y+1)^2 + 10000*MachineEpsilon*RandomReal()
// * boundary constraints x >= 0, y >= 0
// * starting point (x0,y0) == (10*MachineEpsilon,1.0)
//
// Such problem contains small numerical noise. Without noise its
// solution is (xs,ys) == (0,0), which is easy to find. However, presence
// of the noise makes it hard to solve:
// * noisy f(x,y) is monotonically decreasing only when we perform
//   steps orders of magnitude larger than 10000*MachineEpsilon
// * at small scales f(x,y) is non-monotonic and non-convex
// * however, our first step must be done towards
//   (x1,y1) = (0,1-some_small_value), and length of such step is
//   many times SMALLER than 10000*MachineEpsilon
// * second step, from (x1,y1) to (xs,ys), will be large enough to
//   ignore numerical noise, so the only problem is to perform
//   first step
//
// Naive implementation of BC should fail sometimes (sometimes -
// due to non-deterministic nature of noise) on such problem. However,
// our improved implementation should solve it correctly. We test
// several variations of inner stopping criteria.
   for (pass = 1; pass <= passcount; pass++) {
      eps = 1.0E-9;
      ae_vector_set_length(&x, 2);
      ae_vector_set_length(&bl, 2);
      ae_vector_set_length(&bu, 2);
      x.xR[0] = 10.0 * machineepsilon;
      x.xR[1] = 1.0;
      bl.xR[0] = 0.0;
      bu.xR[0] = +INFINITY;
      bl.xR[1] = 0.0;
      bu.xR[1] = +INFINITY;
      for (ckind = 0; ckind <= 2; ckind++) {
         minbccreate(2, &x, &state);
         minbcsetbc(&state, &bl, &bu);
         if (ckind == 0) {
            minbcsetcond(&state, eps, 0.0, 0.0, 0);
         }
         if (ckind == 1) {
            minbcsetcond(&state, 0.0, eps, 0.0, 0);
         }
         if (ckind == 2) {
            minbcsetcond(&state, 0.0, 0.0, eps, 0);
         }
         while (minbciteration(&state))
            if (state.needfg) {
               state.f = sqr(state.x.xR[0] + 1) + sqr(state.x.xR[1] + 1) + 10000.0 * machineepsilon * randomreal();
               state.g.xR[0] = 2 * (state.x.xR[0] + 1);
               state.g.xR[1] = 2 * (state.x.xR[1] + 1);
            }
         minbcresults(&state, &xf, &rep);
         if (rep.terminationtype <= 0 || xf.xR[0] != 0.0 || xf.xR[1] != 0.0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   }
// Deterministic variation of the previous problem.
//
// Consider following problem:
// * boundary constraints x >= 0, y >= 0
// * starting point (x0,y0) == (10*MachineEpsilon,1.0)
//            / (x+1)^2 + (y+1)^2,        for (x,y) != (x0,y0)
// * f(x,y) = |
//            \ (x+1)^2 + (y+1)^2 - 0.1,  for (x,y) == (x0,y0)
//
// Such problem contains deterministic numerical noise (-0.1 at
// starting point). Without noise its solution is easy to find.
// However, presence of the noise makes it hard to solve:
// * our first step must be done towards (x1,y1) = (0,1-some_small_value),
//   but such step will increase function valye by approximately 0.1  -
//   instead of decreasing it.
//
// Naive implementation of BC should fail on such problem. However,
// our improved implementation should solve it correctly. We test
// several variations of inner stopping criteria.
   for (pass = 1; pass <= passcount; pass++) {
      eps = 1.0E-9;
      ae_vector_set_length(&x, 2);
      ae_vector_set_length(&bl, 2);
      ae_vector_set_length(&bu, 2);
      x.xR[0] = 10.0 * machineepsilon;
      x.xR[1] = 1.0;
      bl.xR[0] = 0.0;
      bu.xR[0] = +INFINITY;
      bl.xR[1] = 0.0;
      bu.xR[1] = +INFINITY;
      for (ckind = 0; ckind <= 2; ckind++) {
         minbccreate(2, &x, &state);
         minbcsetbc(&state, &bl, &bu);
         if (ckind == 0) {
            minbcsetcond(&state, eps, 0.0, 0.0, 0);
         }
         if (ckind == 1) {
            minbcsetcond(&state, 0.0, eps, 0.0, 0);
         }
         if (ckind == 2) {
            minbcsetcond(&state, 0.0, 0.0, eps, 0);
         }
         while (minbciteration(&state))
            if (state.needfg) {
               state.f = sqr(state.x.xR[0] + 1) + sqr(state.x.xR[1] + 1);
               if (state.x.xR[0] == x.xR[0] && state.x.xR[1] == x.xR[1]) {
                  state.f -= 0.1;
               }
               state.g.xR[0] = 2 * (state.x.xR[0] + 1);
               state.g.xR[1] = 2 * (state.x.xR[1] + 1);
            }
         minbcresults(&state, &xf, &rep);
         if (rep.terminationtype <= 0 || xf.xR[0] != 0.0 || xf.xR[1] != 0.0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   }
// Test integrity checks for NAN/INF:
// * algorithm solves optimization problem, which is normal for some time (quadratic)
// * after 5-th step we choose random component of gradient and consistently spoil
//   it by NAN or INF.
// * we check that correct termination code is returned (-8)
   n = 100;
   for (pass = 1; pass <= 10; pass++) {
      spoiliteration = 5;
      stopiteration = 8;
      if (hqrndnormal(&rs) > 0.0) {
      // Gradient can be spoiled by +INF, -INF, NAN
         spoilvar = hqrnduniformi(&rs, n);
         i = hqrnduniformi(&rs, 3);
         spoilval = NAN;
         if (i == 0) {
            spoilval = -INFINITY;
         }
         if (i == 1) {
            spoilval = +INFINITY;
         }
      } else {
      // Function value can be spoiled only by NAN
      // (+INF can be recognized as legitimate value during optimization)
         spoilvar = -1;
         spoilval = NAN;
      }
      spdmatrixrndcond(n, 1.0E5, &fulla);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         b.xR[i] = hqrndnormal(&rs);
         x0.xR[i] = hqrndnormal(&rs);
      }
      minbccreate(n, &x0, &state);
      minbcsetcond(&state, 0.0, 0.0, 0.0, stopiteration);
      minbcsetxrep(&state, true);
      k = -1;
      while (minbciteration(&state))
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += b.xR[i] * state.x.xR[i];
               state.g.xR[i] = b.xR[i];
               for (j = 0; j < n; j++) {
                  state.f += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                  state.g.xR[i] += fulla.xyR[i][j] * state.x.xR[j];
               }
            }
            if (k >= spoiliteration) {
               if (spoilvar < 0) {
                  state.f = spoilval;
               } else {
                  state.g.xR[spoilvar] = spoilval;
               }
            }
         } else if (state.xupdated) {
            k++;
         } else ae_assert(false, "Assertion failed");
      minbcresults(&state, &x1, &rep);
      Ok = Ok && rep.terminationtype == -8;
   }
// Check algorithm ability to handle request for termination:
// * to terminate with correct return code = 8
// * to return point which was "current" at the moment of termination
//
// NOTE: we solve problem with "corrupted" preconditioner which makes it hard
//       to converge in less than StopCallIdx iterations
   for (pass = 1; pass <= 50; pass++) {
      n = 3;
      ss = 100.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 6 + randomreal();
      }
      ae_vector_set_length(&s, 3);
      s.xR[0] = 0.00001;
      s.xR[1] = 0.00001;
      s.xR[2] = 10000.0;
      stopcallidx = randominteger(20);
      maxits = 25;
      minbccreate(n, &x, &state);
      minbcsetcond(&state, 0.0, 0.0, 0.0, maxits);
      minbcsetxrep(&state, true);
      minbcsetprecdiag(&state, &s);
      callidx = 0;
      terminationrequested = false;
      ae_v_move(xlast.xR, 1, x.xR, 1, n);
      while (minbciteration(&state))
         if (state.needfg) {
            state.f = ss * sqr(exp(state.x.xR[0]) - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
            state.g.xR[0] = 2 * ss * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[2] - state.x.xR[0]) * (-1);
            state.g.xR[1] = 2 * state.x.xR[1];
            state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
            if (callidx == stopcallidx) {
               minbcrequesttermination(&state);
               terminationrequested = true;
            }
            callidx++;
         } else if (state.xupdated) {
            if (!terminationrequested) {
               ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
            }
         } else ae_assert(false, "Assertion failed");
      minbcresults(&state, &x, &rep);
      Ok = Ok && rep.terminationtype == 8;
      for (i = 0; i < n; i++) {
         Ok = Ok && x.xR[i] == xlast.xR[i];
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests preconditioning
static bool testminbcunit_testpreconditioning() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t i;
   ae_int_t k;
   ae_int_t cntb1;
   ae_int_t cntb2;
   ae_int_t cntg1;
   ae_int_t cntg2;
   double epsg;
   ae_int_t ckind;
   ae_int_t fk;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(vd, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(units, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(diagh, 0, DT_REAL);
   NewObj(minbcstate, state);
   NewObj(minbcreport, rep);
// Preconditioner test 1.
//
// If
// * B1 is default preconditioner with unit scale
// * G1 is diagonal preconditioner based on approximate diagonal of Hessian matrix
// * B2 is default preconditioner with non-unit scale S[i] == 1/sqrt(h[i])
// * G2 is scale-based preconditioner with non-unit scale S[i] == 1/sqrt(h[i])
// then B1 is worse than G1, B2 is worse than G2.
// "Worse" means more iterations to converge.
//
// Test problem setup:
// * f(x) = sum( ((i*i+1)*x[i])^2, i = 0..N-1)
// * constraints:
//   0) absent
//   1) box
//
// N        - problem size
// K        - number of repeated passes (should be large enough to average out random factors)
   k = 100;
   epsg = 1.0E-8;
   for (n = 10; n <= 10; n++) {
      for (ckind = 0; ckind <= 1; ckind++) {
         fk = 1;
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&units, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 0.0;
            units.xR[i] = 1.0;
         }
         minbccreate(n, &x, &state);
         minbcsetcond(&state, epsg, 0.0, 0.0, 0);
         if (ckind == 1) {
            ae_vector_set_length(&bl, n);
            ae_vector_set_length(&bu, n);
            for (i = 0; i < n; i++) {
               bl.xR[i] = -1.0;
               bu.xR[i] = 1.0;
            }
            minbcsetbc(&state, &bl, &bu);
         }
      // Test it with default preconditioner VS. perturbed diagonal preconditioner
         minbcsetprecdefault(&state);
         minbcsetscale(&state, &units);
         cntb1 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            for (minbcrestartfrom(&state, &x); minbciteration(&state); ) testminbcunit_calciip2(&state, n, fk);
            minbcresults(&state, &x, &rep);
            cntb1 += rep.iterationscount;
            Ok = Ok && rep.terminationtype > 0;
         }
         ae_vector_set_length(&diagh, n);
         for (i = 0; i < n; i++) {
            diagh.xR[i] = 2 * pow((double)(i * i + 1), (double)(2 * fk)) * (0.8 + 0.4 * randomreal());
         }
         minbcsetprecdiag(&state, &diagh);
         minbcsetscale(&state, &units);
         cntg1 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            for (minbcrestartfrom(&state, &x); minbciteration(&state); ) testminbcunit_calciip2(&state, n, fk);
            minbcresults(&state, &x, &rep);
            cntg1 += rep.iterationscount;
            Ok = Ok && rep.terminationtype > 0;
         }
         Ok = Ok && cntb1 >= cntg1;
      // Test it with scale-based preconditioner
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = 1 / sqrt(2 * pow((double)(i * i + 1), (double)(2 * fk)) * (0.8 + 0.4 * randomreal()));
         }
         minbcsetprecdefault(&state);
         minbcsetscale(&state, &s);
         cntb2 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            for (minbcrestartfrom(&state, &x); minbciteration(&state); ) testminbcunit_calciip2(&state, n, fk);
            minbcresults(&state, &x, &rep);
            cntb2 += rep.iterationscount;
            Ok = Ok && rep.terminationtype > 0;
         }
         minbcsetprecscale(&state);
         minbcsetscale(&state, &s);
         cntg2 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            for (minbcrestartfrom(&state, &x); minbciteration(&state); ) testminbcunit_calciip2(&state, n, fk);
            minbcresults(&state, &x, &rep);
            cntg2 += rep.iterationscount;
            Ok = Ok && rep.terminationtype > 0;
         }
         Ok = Ok && cntb2 >= cntg2;
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests report of "non-C1" test #0 for task #0
// given by matrix A.
static bool testminbcunit_testoptguardc1test0reportfortask0(optguardnonc1test0report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool hasc1discontinuities;
   bool Ok = true;
   if (rep->positive) {
   // Check positive report, first checks
      Ok = Ok && rep->fidx == 0;
      Ok = Ok && rep->n == n;
      Ok = Ok && 0 <= rep->stpidxa;
      Ok = Ok && rep->stpidxa < rep->stpidxb;
      Ok = Ok && rep->stpidxb < rep->cnt;
      Ok = Ok && rep->x0.cnt == rep->n;
      Ok = Ok && rep->d.cnt == rep->n;
      Ok = Ok && rep->stp.cnt == rep->cnt;
      Ok = Ok && rep->f.cnt == rep->cnt;
      Ok = Ok && isfinitevector(&rep->x0, n);
      Ok = Ok && isfinitevector(&rep->d, n);
      Ok = Ok && isfinitevector(&rep->stp, rep->cnt);
      Ok = Ok && isfinitevector(&rep->f, rep->cnt);
      if (!Ok) {
         return Ok;
      }
   // Check consistency of X0, D, Stp and F
      for (k = 0; k < rep->cnt - 1; k++) {
         Ok = Ok && rep->stp.xR[k] < rep->stp.xR[k + 1];
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += fabs(vv);
         }
         Ok = Ok && NearAtR(v, rep->f.xR[k], 1.0E-6 * rmax2(fabs(v), 1.0));
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      Ok = Ok && hasc1discontinuities;
   } else {
   // Check negative report: fields must be empty
      Ok = Ok && rep->stpidxa == -1;
      Ok = Ok && rep->stpidxb == -1;
      Ok = Ok && rep->fidx == -1;
      Ok = Ok && rep->cnt == 0;
      Ok = Ok && rep->n == 0;
      Ok = Ok && rep->x0.cnt == 0;
      Ok = Ok && rep->d.cnt == 0;
      Ok = Ok && rep->stp.cnt == 0;
      Ok = Ok && rep->f.cnt == 0;
   }
   return Ok;
}

// This function tests report of "non-C1" test #1 for task #0
// given by matrix A.
static bool testminbcunit_testoptguardc1test1reportfortask0(optguardnonc1test1report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool tooclose;
   bool hasc1discontinuities;
   bool Ok = true;
   if (rep->positive) {
   // Check positive report, first checks
      Ok = Ok && rep->fidx == 0;
      Ok = Ok && rep->vidx >= 0;
      Ok = Ok && rep->vidx <= n;
      Ok = Ok && rep->n == n;
      Ok = Ok && 0 <= rep->stpidxa;
      Ok = Ok && rep->stpidxa < rep->stpidxb;
      Ok = Ok && rep->stpidxb < rep->cnt;
      Ok = Ok && rep->x0.cnt == rep->n;
      Ok = Ok && rep->d.cnt == rep->n;
      Ok = Ok && rep->stp.cnt == rep->cnt;
      Ok = Ok && rep->g.cnt == rep->cnt;
      Ok = Ok && isfinitevector(&rep->x0, n);
      Ok = Ok && isfinitevector(&rep->d, n);
      Ok = Ok && isfinitevector(&rep->stp, rep->cnt);
      Ok = Ok && isfinitevector(&rep->g, rep->cnt);
      if (!Ok) {
         return Ok;
      }
   // Check consistency of X0, D, Stp and G
      for (k = 0; k < rep->cnt - 1; k++) {
         Ok = Ok && rep->stp.xR[k] < rep->stp.xR[k + 1];
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         tooclose = false;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += sign(vv) * a->xyR[i][rep->vidx];
            tooclose = tooclose || SmallR(vv, 1.0E-4);
         }
         if (!tooclose) {
            Ok = Ok && NearAtR(v, rep->g.xR[k], 1.0E-6 * rmax2(fabs(v), 1.0));
         }
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      tooclose = false;
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         tooclose = tooclose || SmallR(va, 1.0E-8) || SmallR(vb, 1.0E-8);
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      if (!tooclose) {
         Ok = Ok && hasc1discontinuities;
      }
   } else {
   // Check negative report: fields must be empty
      Ok = Ok && rep->stpidxa == -1;
      Ok = Ok && rep->stpidxb == -1;
      Ok = Ok && rep->fidx == -1;
      Ok = Ok && rep->vidx == -1;
      Ok = Ok && rep->cnt == 0;
      Ok = Ok && rep->n == 0;
      Ok = Ok && rep->x0.cnt == 0;
      Ok = Ok && rep->d.cnt == 0;
      Ok = Ok && rep->stp.cnt == 0;
      Ok = Ok && rep->g.cnt == 0;
   }
   return Ok;
}

// This function tests OptGuard
static bool testminbcunit_testoptguard() {
   ae_frame _frame_block;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   double diffstep;
   ae_int_t pass;
   ae_int_t defecttype;
   bool failed;
   ae_int_t passcount;
   ae_int_t maxfails;
   ae_int_t failurecounter;
   ae_int_t maxc1test0fails;
   ae_int_t maxc1test1fails;
   ae_int_t c1test0fails;
   ae_int_t c1test1fails;
   double avgstr0len;
   double avglng0len;
   double avgstr1len;
   double avglng1len;
   ae_int_t varidx;
   ae_int_t skind;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minbcstate, state);
   NewObj(minbcreport, rep);
   NewObj(optguardreport, ogrep);
   NewObj(optguardnonc1test0report, ognonc1test0strrep);
   NewObj(optguardnonc1test0report, ognonc1test0lngrep);
   NewObj(optguardnonc1test1report, ognonc1test1strrep);
   NewObj(optguardnonc1test1report, ognonc1test1lngrep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(jactrue, 0, 0, DT_REAL);
   NewMatrix(jacdefect, 0, 0, DT_REAL);
   hqrndrandomize(&rs);
// Check that gradient verification is disabled by default:
// gradient checking for bad problem must return nothing
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = 1.0 + 0.1 * i;
   }
   spdmatrixrndcond(n, 1.0E3, &a);
   spdmatrixrndcond(n, 1.0E3, &a1);
   minbccreate(n, &x0, &state);
   minbcsetcond(&state, 0.0, 0.0, 1.0E-9, 10);
   while (minbciteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += 0.5 * state.x.xR[i] * v;
         }
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
      } else ae_assert(false, "Assertion failed");
   minbcresults(&state, &x1, &rep);
   minbcoptguardresults(&state, &ogrep);
   Ok = Ok && rep.terminationtype > 0;
   Ok = Ok && isfinitevector(&x1, n);
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && ogrep.badgradxbase.cnt == 0;
   Ok = Ok && ogrep.badgraduser.rows == 0;
   Ok = Ok && ogrep.badgraduser.cols == 0;
   Ok = Ok && ogrep.badgradnum.rows == 0;
   Ok = Ok && ogrep.badgradnum.cols == 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && !ogrep.badgradsuspected;
   Ok = Ok && ogrep.badgradfidx == -1;
   Ok = Ok && ogrep.badgradvidx == -1;
// Test that C0/C1 continuity monitoring is disabled by default;
// we solve nonsmooth problem and test that nothing is returned
// by OptGuard.
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = hqrndnormal(&rs);
   }
   ae_matrix_set_length(&a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a.xyR[i][j] = hqrndnormal(&rs);
      }
   }
   minbccreate(n, &x0, &state);
   minbcsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
   while (minbciteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += fabs(v);
            v = (double)sign(v);
            for (j = 0; j < n; j++) {
               state.g.xR[j] += v * a.xyR[i][j];
            }
         }
      } else ae_assert(false, "Assertion failed");
   minbcresults(&state, &x1, &rep);
   minbcoptguardresults(&state, &ogrep);
   Ok = Ok && isfinitevector(&x1, n);
   Ok = Ok && rep.terminationtype > 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && !ogrep.nonc0suspected;
   Ok = Ok && !ogrep.nonc1suspected;
   Ok = Ok && optguardallclear(&ogrep);
   Ok = Ok && ogrep.nonc0fidx < 0;
   Ok = Ok && ogrep.nonc1fidx < 0;
   Ok = Ok && !ogrep.nonc1test0positive;
   Ok = Ok && !ogrep.nonc1test1positive;
// Test gradient checking functionality, try various
// defect types:
// * accidental zeroing of some gradient component
// * accidental addition of 1.0 to some component
// * accidental multiplication by 2.0
// Try distorting both target and constraints.
   diffstep = 0.001;
   n = 10;
   for (skind = 0; skind <= 1; skind++) {
      for (defecttype = -1; defecttype <= 2; defecttype++) {
         varidx = hqrnduniformi(&rs, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, skind * 15.0 * hqrndmiduniformr(&rs));
            x0.xR[i] = (1.0 + 0.1 * i) * s.xR[i];
            j = hqrnduniformi(&rs, 3);
            bndl.xR[i] = -100 * s.xR[i];
            bndu.xR[i] = 100 * s.xR[i];
            if (j == 1) {
               bndl.xR[i] = x0.xR[i];
            }
            if (j == 2) {
               bndu.xR[i] = x0.xR[i];
            }
         }
         spdmatrixrndcond(n, 1.0E3, &a);
         spdmatrixrndcond(n, 1.0E3, &a1);
         minbccreate(n, &x0, &state);
         minbcoptguardgradient(&state, diffstep);
         minbcsetcond(&state, 0.0, 0.0, 1.0E-9, 10);
         minbcsetscale(&state, &s);
         minbcsetbc(&state, &bndl, &bndu);
         while (minbciteration(&state))
            if (state.needfg) {
               for (i = 0; i < n; i++) {
                  Ok = Ok && state.x.xR[i] >= bndl.xR[i];
                  Ok = Ok && state.x.xR[i] <= bndu.xR[i];
               }
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += state.x.xR[j] / s.xR[j] * a.xyR[i][j];
                  }
                  state.f += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                  state.g.xR[i] = v;
               }
               if (defecttype == 0) {
                  state.g.xR[varidx] = 0.0;
               }
               if (defecttype == 1) {
                  state.g.xR[varidx]++;
               }
               if (defecttype == 2) {
                  state.g.xR[varidx] *= 2;
               }
               for (i = 0; i < n; i++) {
                  state.g.xR[i] /= s.xR[i];
               }
            } else ae_assert(false, "Assertion failed");
         minbcresults(&state, &x1, &rep);
         minbcoptguardresults(&state, &ogrep);
      // Check that something is returned
         Ok = Ok && rep.terminationtype > 0;
         Ok = Ok && isfinitevector(&x1, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Compute reference values for true and spoiled Jacobian at X0
         Ok = Ok && isfinitevector(&ogrep.badgradxbase, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         ae_matrix_set_length(&jactrue, 1, n);
         ae_matrix_set_length(&jacdefect, 1, n);
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += ogrep.badgradxbase.xR[j] / s.xR[j] * a.xyR[i][j];
            }
            jactrue.xyR[0][i] = v;
            jacdefect.xyR[0][i] = v;
         }
         if (defecttype == 0) {
            jacdefect.xyR[0][varidx] = 0.0;
         }
         if (defecttype == 1) {
            jacdefect.xyR[0][varidx]++;
         }
         if (defecttype == 2) {
            jacdefect.xyR[0][varidx] *= 2;
         }
         for (i = 0; i < n; i++) {
            jactrue.xyR[0][i] /= s.xR[i];
            jacdefect.xyR[0][i] /= s.xR[i];
         }
      // Check OptGuard report
         Ok = Ok && apservisfinitematrix(&ogrep.badgraduser, 1, n);
         Ok = Ok && apservisfinitematrix(&ogrep.badgradnum, 1, n);
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         if (defecttype >= 0) {
            Ok = Ok && ogrep.badgradsuspected;
            Ok = Ok && ogrep.badgradfidx == 0;
            Ok = Ok && ogrep.badgradvidx == varidx;
         } else {
            Ok = Ok && !ogrep.badgradsuspected;
            Ok = Ok && ogrep.badgradfidx == -1;
            Ok = Ok && ogrep.badgradvidx == -1;
         }
         for (j = 0; j < n; j++) {
            Ok = Ok && NearAtR(jactrue.xyR[0][j], ogrep.badgradnum.xyR[0][j], 0.01 / s.xR[j]);
            Ok = Ok && NearAtR(jacdefect.xyR[0][j], ogrep.badgraduser.xyR[0][j], 0.01 / s.xR[j]);
         }
      }
   }
// A test for detection of C1 continuity violations in the target.
//
// Target function is a sum of |(x,c_i)| for i = 1..N.
// No constraints is present.
// Analytic gradient is provided.
//
// OptGuard should be able to detect violations in more than
// 99.9% of runs; it means that 100 runs should have no more than 4
// failures in all cases (even after multiple repeated tests; according
// to the binomial distribution quantiles).
//
// We select some N and perform exhaustive search for this N.
   passcount = 100;
   maxfails = 4;
   maxc1test0fails = 10;
   maxc1test1fails = 10;
   n = 1 + hqrnduniformi(&rs, 10);
   failurecounter = 0;
   c1test0fails = 0;
   c1test1fails = 0;
   avgstr0len = 0.0;
   avglng0len = 0.0;
   avgstr1len = 0.0;
   avglng1len = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = pow(2.0, hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      minbccreate(n, &x0, &state);
      minbcsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      minbcsetscale(&state, &s);
      minbcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminbcunit_maxoptguardlevel));
      while (minbciteration(&state))
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.g.xR[i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
               v = (double)sign(v);
               for (j = 0; j < n; j++) {
                  state.g.xR[j] += v * a.xyR[i][j];
               }
            }
         } else ae_assert(false, "Assertion failed");
      minbcresults(&state, &x1, &rep);
      minbcoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Check generic OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      Ok = Ok && !ogrep.nonc0suspected;
      Ok = Ok && ogrep.nonc0fidx < 0;
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   // Check C1 continuity test #0
      minbcoptguardnonc1test0results(&state, &ognonc1test0strrep, &ognonc1test0lngrep);
      minbcoptguardnonc1test1results(&state, &ognonc1test1strrep, &ognonc1test1lngrep);
      if (ogrep.nonc1test0positive) {
         Ok = Ok && ogrep.nonc1suspected;
         Ok = Ok && ognonc1test0strrep.positive;
         Ok = Ok && ognonc1test0lngrep.positive;
         Ok = Ok && ogrep.nonc1fidx == 0;
         Ok = Ok && testminbcunit_testoptguardc1test0reportfortask0(&ognonc1test0strrep, &a, n);
         Ok = Ok && testminbcunit_testoptguardc1test0reportfortask0(&ognonc1test0lngrep, &a, n);
         avgstr0len += (double)ognonc1test0strrep.cnt / passcount;
         avglng0len += (double)ognonc1test0lngrep.cnt / passcount;
      } else {
         Ok = Ok && !ognonc1test0strrep.positive;
         Ok = Ok && !ognonc1test0lngrep.positive;
         Ok = Ok && testminbcunit_testoptguardc1test0reportfortask0(&ognonc1test0strrep, &a, n);
         Ok = Ok && testminbcunit_testoptguardc1test0reportfortask0(&ognonc1test0lngrep, &a, n);
         c1test0fails++;
      }
      if (ogrep.nonc1test1positive) {
         Ok = Ok && ogrep.nonc1suspected;
         Ok = Ok && ognonc1test1strrep.positive;
         Ok = Ok && ognonc1test1lngrep.positive;
         Ok = Ok && ogrep.nonc1fidx == 0;
         Ok = Ok && testminbcunit_testoptguardc1test1reportfortask0(&ognonc1test1strrep, &a, n);
         Ok = Ok && testminbcunit_testoptguardc1test1reportfortask0(&ognonc1test1lngrep, &a, n);
         avgstr1len += (double)ognonc1test1strrep.cnt / passcount;
         avglng1len += (double)ognonc1test1lngrep.cnt / passcount;
      } else {
         Ok = Ok && !ognonc1test1strrep.positive;
         Ok = Ok && !ognonc1test1lngrep.positive;
         Ok = Ok && testminbcunit_testoptguardc1test1reportfortask0(&ognonc1test1strrep, &a, n);
         Ok = Ok && testminbcunit_testoptguardc1test1reportfortask0(&ognonc1test1lngrep, &a, n);
         c1test1fails++;
      }
   }
   Ok = Ok && failurecounter <= maxfails;
   Ok = Ok && c1test0fails <= maxc1test0fails;
   Ok = Ok && c1test1fails <= maxc1test1fails;
   Ok = Ok && avglng0len > avgstr0len;
   Ok = Ok && avglng1len > avgstr1len;
// Detection of C1 continuity violations in the target under numerical differentiation:
// * target function is a sum of |(x,c_i)| for i = 1..N.
// * no constraints is present.
// * analytic gradient is provided.
//
// OptGuard should always be able to detect violations in more than
// 99% of runs (note: reduced strength when compared with analytic gradient);
// it means that 100 runs should have no more than 10 failures in all cases
// (even after multiple repeated tests; according to the binomial distribution
// quantiles).
//
// We select some N and perform exhaustive search for this N.
   diffstep = 0.0001;
   passcount = 100;
   maxfails = 10;
   n = 1 + hqrnduniformi(&rs, 10);
   failurecounter = 0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 0.01 * pow(2.0, 0.33 * hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      minbccreatef(n, &x0, diffstep, &state);
      minbcsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      minbcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminbcunit_maxoptguardlevel));
      while (minbciteration(&state))
         if (state.needf) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
            }
         } else ae_assert(false, "Assertion failed");
      minbcresults(&state, &x1, &rep);
      minbcoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      Ok = Ok && isfinitevector(&x1, n);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Check OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      Ok = Ok && !ogrep.nonc0suspected;
      Ok = Ok && ogrep.nonc0fidx < 0;
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   }
   Ok = Ok && failurecounter <= maxfails;
// Make sure than no false positives are reported for larger
// problems where numerical noise can be an issue:
// * N == 100 dimensions
// * positive-definite quadratic programming problem
// * upper limit on iterations count, MaxIts == 25
// We simply test that OptGuard does not return error code.
   n = 100;
   spdmatrixrndcond(n, 1.0E2, &a);
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = hqrndnormal(&rs);
      x0.xR[i] = pow(2.0, hqrndnormal(&rs));
   }
   minbccreate(n, &x0, &state);
   minbcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminbcunit_maxoptguardlevel));
   minbcsetcond(&state, 0.0, 0.0, 1.0E-9, 25);
   while (minbciteration(&state))
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += b.xR[i] * state.x.xR[i];
            state.g.xR[i] = b.xR[i];
            for (j = 0; j < n; j++) {
               state.f += 0.5 * state.x.xR[i] * a.xyR[i][j] * state.x.xR[j];
               state.g.xR[i] += a.xyR[i][j] * state.x.xR[j];
            }
         }
      } else ae_assert(false, "Assertion failed");
   minbcresults(&state, &x1, &rep);
   Ok = Ok && isfinitevector(&x1, n);
   Ok = Ok && rep.terminationtype > 0;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   minbcoptguardresults(&state, &ogrep);
   Ok = Ok && optguardallclear(&ogrep);
   ae_frame_leave();
   return Ok;
}

bool testminbc() {
   bool Ok;
   bool feasibilityOk;
   bool otherOk;
   bool precOk;
   bool intOk;
   bool convOk;
   bool optguardOk;
   Ok = true;
   feasibilityOk = true;
   otherOk = true;
   precOk = true;
   intOk = true;
   convOk = true;
   optguardOk = true;
   feasibilityOk = feasibilityOk && testminbcunit_testfeasibility(&convOk, &intOk);
   otherOk = otherOk && testminbcunit_testother();
   precOk = precOk && testminbcunit_testpreconditioning();
   optguardOk = optguardOk && testminbcunit_testoptguard();
// The final report.
   Ok = feasibilityOk && otherOk && convOk && intOk && precOk && optguardOk;
   if (!Ok || !silent) {
      printf("MinBC Optimization Tests\n");
      printf("Feasibility Properties:                   %s\n", feasibilityOk? "Ok": "Failed");
      printf("Preconditioning:                          %s\n", precOk? "Ok": "Failed");
      printf("Other Properties:                         %s\n", otherOk? "Ok": "Failed");
      printf("Convergence Properties:                   %s\n", convOk? "Ok": "Failed");
      printf("Internal Errors:                          %s\n", intOk? "Ok": "Failed");
      printf("OptGuard:                                 %s\n", optguardOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === nearestneighbor testing unit ===
// Compare results from different queries:
// * X     just X-values
// * XY    X-values and Y-values
// * XT    X-values and tag values
static bool testnearestneighborunit_kdtresultsdifferent(RMatrix *refxy, ae_int_t ntotal, RMatrix *qx, RMatrix *qxy, ZVector *qt, ae_int_t n, ae_int_t nx, ae_int_t ny) {
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   Ok = true;
   for (i = 0; i < n; i++) {
      if (qt->xZ[i] < 0 || qt->xZ[i] >= ntotal) {
         Ok = false;
         return Ok;
      }
      for (j = 0; j < nx; j++) {
         Ok = Ok && qx->xyR[i][j] == refxy->xyR[qt->xZ[i]][j];
         Ok = Ok && qxy->xyR[i][j] == refxy->xyR[qt->xZ[i]][j];
      }
      for (j = 0; j < ny; j++) {
         Ok = Ok && qxy->xyR[i][nx + j] == refxy->xyR[qt->xZ[i]][nx + j];
      }
   }
   return Ok;
}

// Returns norm
static double testnearestneighborunit_vnorm(RVector *x, ae_int_t n, ae_int_t normtype) {
   ae_int_t i;
   double result;
   result = randomreal();
   if (normtype == 0) {
      result = 0.0;
      for (i = 0; i < n; i++) {
         result = rmax2(result, fabs(x->xR[i]));
      }
      return result;
   }
   if (normtype == 1) {
      result = 0.0;
      for (i = 0; i < n; i++) {
         result += fabs(x->xR[i]);
      }
      return result;
   }
   if (normtype == 2) {
      result = 0.0;
      for (i = 0; i < n; i++) {
         result += sqr(x->xR[i]);
      }
      result = sqrt(result);
      return result;
   }
   return result;
}

// Testing Nearest Neighbor Search on uniformly distributed hypercube
//
// NormType: 0, 1, 2
// D: space dimension
// N: points count
static bool testnearestneighborunit_testkdtuniform(RMatrix *xy, ae_int_t n, ae_int_t nx, ae_int_t ny, ae_int_t normtype) {
   ae_frame _frame_block;
   double errtol;
   double spread;
   ae_int_t kx;
   ae_int_t kxy;
   ae_int_t kt;
   double eps;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t task;
   bool isequal;
   double r;
   ae_int_t q;
   ae_int_t qcount;
   double v;
   bool inthebox;
   bool orderedrnn;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(tags, 0, DT_INT);
   NewVector(ptx, 0, DT_REAL);
   NewVector(tmpx, 0, DT_REAL);
   NewVector(tmpb, 0, DT_BOOL);
   NewObj(kdtree, treex);
   NewObj(kdtree, treexy);
   NewObj(kdtree, treext);
   NewObj(kdtreerequestbuffer, bufx);
   NewObj(kdtreerequestbuffer, bufxy);
   NewObj(kdtreerequestbuffer, bufxt);
   NewMatrix(qx, 0, 0, DT_REAL);
   NewMatrix(qxy, 0, 0, DT_REAL);
   NewVector(qtags, 0, DT_INT);
   NewVector(qr, 0, DT_REAL);
   NewVector(boxmin, 0, DT_REAL);
   NewVector(boxmax, 0, DT_REAL);
   NewVector(qmin, 0, DT_REAL);
   NewVector(qmax, 0, DT_REAL);
   qcount = 10;
   ae_assert(n > 0, "Assertion failed");
// Tol - roundoff error tolerance (for '>=' comparisons)
   errtol = 100000.0 * machineepsilon;
// Evaluate bounding box and spread.
   ae_vector_set_length(&boxmin, nx);
   ae_vector_set_length(&boxmax, nx);
   for (j = 0; j < nx; j++) {
      boxmin.xR[j] = xy->xyR[0][j];
      boxmax.xR[j] = xy->xyR[0][j];
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < nx; j++) {
         boxmin.xR[j] = rmin2(boxmin.xR[j], xy->xyR[i][j]);
         boxmax.xR[j] = rmax2(boxmax.xR[j], xy->xyR[i][j]);
      }
   }
   spread = 0.0;
   for (j = 0; j < nx; j++) {
      spread = rmax2(spread, boxmax.xR[j] - boxmin.xR[j]);
   }
   if (spread == 0.0) {
      spread = 1.0;
   }
// fill tags
   ae_vector_set_length(&tags, n);
   for (i = 0; i < n; i++) {
      tags.xZ[i] = i;
   }
// build trees
   kdtreebuild(xy, n, nx, 0, normtype, &treex);
   kdtreebuild(xy, n, nx, ny, normtype, &treexy);
   kdtreebuildtagged(xy, &tags, n, nx, 0, normtype, &treext);
// allocate arrays
   ae_vector_set_length(&tmpx, nx);
   ae_vector_set_length(&tmpb, n);
   ae_matrix_set_length(&qx, n, nx);
   ae_matrix_set_length(&qxy, n, nx + ny);
   ae_vector_set_length(&qtags, n);
   ae_vector_set_length(&qr, n);
   ae_vector_set_length(&ptx, nx);
// test general K-NN queries (with self-matches):
// * compare results from different trees (must be equal) and
//   check that correct (value,tag) pairs are returned
// * test results from XT tree - let R be radius of query result.
//   then all points not in result must be not closer than R.
   for (q = 1; q <= qcount; q++) {
   // Select K: 1..N
      if (randombool()) {
         k = 1 + randominteger(n);
      } else {
         k = 1;
      }
   // Select point (either one of the points, or random)
      if (randombool()) {
         i = randominteger(n);
         ae_v_move(ptx.xR, 1, xy->xyR[i], 1, nx);
      } else {
         for (i = 0; i < nx; i++) {
            ptx.xR[i] = randommid();
         }
      }
   // Test functions which use internal buffer:
   // * consistency of results from different queries
   // * points in query are IN the R-sphere (or at the boundary),
   //   and points not in query are outside of the R-sphere (or at the boundary)
   // * distances are correct and are ordered
      kx = kdtreequeryknn(&treex, &ptx, k, true);
      kxy = kdtreequeryknn(&treexy, &ptx, k, true);
      kt = kdtreequeryknn(&treext, &ptx, k, true);
      if (kx != k || kxy != k || kt != k) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreequeryresultsxi(&treex, &qx);
      kdtreequeryresultsxyi(&treexy, &qxy);
      kdtreequeryresultstagsi(&treext, &qtags);
      kdtreequeryresultsdistancesi(&treext, &qr);
      Ok = Ok && testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreequeryresultsx(&treex, &qx);
      kdtreequeryresultsxy(&treexy, &qxy);
      kdtreequeryresultstags(&treext, &qtags);
      kdtreequeryresultsdistances(&treext, &qr);
      Ok = Ok && testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = true;
      }
      r = 0.0;
      for (i = 0; i < k; i++) {
         tmpb.xB[qtags.xZ[i]] = false;
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, qx.xyR[i], 1, nx);
         r = rmax2(r, testnearestneighborunit_vnorm(&tmpx, nx, normtype));
      }
      for (i = 0; i < n; i++) {
         if (tmpb.xB[i]) {
            ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
            ae_v_sub(tmpx.xR, 1, xy->xyR[i], 1, nx);
            Ok = Ok && testnearestneighborunit_vnorm(&tmpx, nx, normtype) >= r * (1 - errtol);
         }
      }
      for (i = 0; i < k - 1; i++) {
         Ok = Ok && qr.xR[i] <= qr.xR[i + 1];
      }
      for (i = 0; i < k; i++) {
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, xy->xyR[qtags.xZ[i]], 1, nx);
         Ok = Ok && NearAtR(testnearestneighborunit_vnorm(&tmpx, nx, normtype), qr.xR[i], errtol);
      }
   // Test functions which use external buffer:
   // * create external request buffer, perform buffered request
   // * reset status of internal buffer by performing 1-NN query, it is essential
   //   to test the fact that external buffer is used
   // * check consistency of results from different queries
   // * check that points in query are IN the R-sphere (or at the boundary),
   //   and points not in query are outside of the R-sphere (or at the boundary)
   // * check that distances are correct and are ordered
      kdtreecreaterequestbuffer(&treex, &bufx);
      kdtreecreaterequestbuffer(&treexy, &bufxy);
      kdtreecreaterequestbuffer(&treext, &bufxt);
      kx = kdtreetsqueryknn(&treex, &bufx, &ptx, k, true);
      kxy = kdtreetsqueryknn(&treexy, &bufxy, &ptx, k, true);
      kt = kdtreetsqueryknn(&treext, &bufxt, &ptx, k, true);
      kdtreequeryknn(&treex, &ptx, 1, true);
      kdtreequeryknn(&treexy, &ptx, 1, true);
      kdtreequeryknn(&treext, &ptx, 1, true);
      if (kx != k || kxy != k || kt != k) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreetsqueryresultsx(&treex, &bufx, &qx);
      kdtreetsqueryresultsxy(&treexy, &bufxy, &qxy);
      kdtreetsqueryresultstags(&treext, &bufxt, &qtags);
      kdtreetsqueryresultsdistances(&treext, &bufxt, &qr);
      Ok = Ok && testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = true;
      }
      r = 0.0;
      for (i = 0; i < k; i++) {
         tmpb.xB[qtags.xZ[i]] = false;
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, qx.xyR[i], 1, nx);
         r = rmax2(r, testnearestneighborunit_vnorm(&tmpx, nx, normtype));
      }
      for (i = 0; i < n; i++) {
         if (tmpb.xB[i]) {
            ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
            ae_v_sub(tmpx.xR, 1, xy->xyR[i], 1, nx);
            Ok = Ok && testnearestneighborunit_vnorm(&tmpx, nx, normtype) >= r * (1 - errtol);
         }
      }
      for (i = 0; i < k - 1; i++) {
         Ok = Ok && qr.xR[i] <= qr.xR[i + 1];
      }
      for (i = 0; i < k; i++) {
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, xy->xyR[qtags.xZ[i]], 1, nx);
         Ok = Ok && NearAtR(testnearestneighborunit_vnorm(&tmpx, nx, normtype), qr.xR[i], errtol);
      }
   // Test reallocation properties: functions must automatically
   // resize array which is too small, but leave unchanged array which is
   // too large.
      if (n >= 2) {
      // First step: array is too small, two elements are required
         k = 2;
         kx = kdtreequeryknn(&treex, &ptx, k, true);
         kxy = kdtreequeryknn(&treexy, &ptx, k, true);
         kt = kdtreequeryknn(&treext, &ptx, k, true);
         if (kx != k || kxy != k || kt != k) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         ae_matrix_set_length(&qx, 1, 1);
         ae_matrix_set_length(&qxy, 1, 1);
         ae_vector_set_length(&qtags, 1);
         ae_vector_set_length(&qr, 1);
         kdtreequeryresultsx(&treex, &qx);
         kdtreequeryresultsxy(&treexy, &qxy);
         kdtreequeryresultstags(&treext, &qtags);
         kdtreequeryresultsdistances(&treext, &qr);
         Ok = Ok && testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
      // Second step: array is one row larger than needed, so only first
      // row is overwritten. Test it.
         k = 1;
         kx = kdtreequeryknn(&treex, &ptx, k, true);
         kxy = kdtreequeryknn(&treexy, &ptx, k, true);
         kt = kdtreequeryknn(&treext, &ptx, k, true);
         if (kx != k || kxy != k || kt != k) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < nx; i++) {
            qx.xyR[1][i] = NAN;
         }
         for (i = 0; i < nx + ny; i++) {
            qxy.xyR[1][i] = NAN;
         }
         qtags.xZ[1] = 999;
         qr.xR[1] = NAN;
         kdtreequeryresultsx(&treex, &qx);
         kdtreequeryresultsxy(&treexy, &qxy);
         kdtreequeryresultstags(&treext, &qtags);
         kdtreequeryresultsdistances(&treext, &qr);
         Ok = Ok && testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
         for (i = 0; i < nx; i++) {
            Ok = Ok && isnan(qx.xyR[1][i]);
         }
         for (i = 0; i < nx + ny; i++) {
            Ok = Ok && isnan(qxy.xyR[1][i]);
         }
         Ok = Ok && qtags.xZ[1] == 999;
         Ok = Ok && isnan(qr.xR[1]);
      }
   // Test reallocation properties: 'interactive' functions must allocate
   // new array on each call.
      if (n >= 2) {
      // On input array is either too small or too large
         for (k = 1; k <= 2; k++) {
            ae_assert(k == 1 || k == 2, "KNN: internal error (unexpected K)!");
            kx = kdtreequeryknn(&treex, &ptx, k, true);
            kxy = kdtreequeryknn(&treexy, &ptx, k, true);
            kt = kdtreequeryknn(&treext, &ptx, k, true);
            if (kx != k || kxy != k || kt != k) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            ae_matrix_set_length(&qx, 3 - k, 3 - k);
            ae_matrix_set_length(&qxy, 3 - k, 3 - k);
            ae_vector_set_length(&qtags, 3 - k);
            ae_vector_set_length(&qr, 3 - k);
            kdtreequeryresultsxi(&treex, &qx);
            kdtreequeryresultsxyi(&treexy, &qxy);
            kdtreequeryresultstagsi(&treext, &qtags);
            kdtreequeryresultsdistancesi(&treext, &qr);
            Ok = Ok && testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
            Ok = Ok && qx.rows == k && qx.cols == nx;
            Ok = Ok && qxy.rows == k && qxy.cols == nx + ny;
            Ok = Ok && qtags.cnt == k;
            Ok = Ok && qr.cnt == k;
         }
      }
   }
// test general approximate K-NN queries (with self-matches):
// * compare results from different trees (must be equal) and
//   check that correct (value,tag) pairs are returned
// * test results from XT tree - let R be radius of query result.
//   then all points not in result must be not closer than R/(1+Eps).
   for (q = 1; q <= qcount; q++) {
   // Select K: 1..N
      if (randombool()) {
         k = 1 + randominteger(n);
      } else {
         k = 1;
      }
   // Select Eps
      eps = 0.5 + randomreal();
   // Select point (either one of the points, or random)
      if (randombool()) {
         i = randominteger(n);
         ae_v_move(ptx.xR, 1, xy->xyR[i], 1, nx);
      } else {
         for (i = 0; i < nx; i++) {
            ptx.xR[i] = randommid();
         }
      }
   // Test functions which use internal buffer:
   // * consistency of results from different queries
   // * points in query are IN the R-sphere (or at the boundary),
   //   and points not in query are outside of the R-sphere (or at the boundary)
   // * distances are correct and are ordered
      kx = kdtreequeryaknn(&treex, &ptx, k, true, eps);
      kxy = kdtreequeryaknn(&treexy, &ptx, k, true, eps);
      kt = kdtreequeryaknn(&treext, &ptx, k, true, eps);
      if (kx != k || kxy != k || kt != k) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreequeryresultsxi(&treex, &qx);
      kdtreequeryresultsxyi(&treexy, &qxy);
      kdtreequeryresultstagsi(&treext, &qtags);
      kdtreequeryresultsdistancesi(&treext, &qr);
      Ok = Ok && testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreequeryresultsx(&treex, &qx);
      kdtreequeryresultsxy(&treexy, &qxy);
      kdtreequeryresultstags(&treext, &qtags);
      kdtreequeryresultsdistances(&treext, &qr);
      Ok = Ok && testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = true;
      }
      r = 0.0;
      for (i = 0; i < k; i++) {
         tmpb.xB[qtags.xZ[i]] = false;
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, qx.xyR[i], 1, nx);
         r = rmax2(r, testnearestneighborunit_vnorm(&tmpx, nx, normtype));
      }
      for (i = 0; i < n; i++) {
         if (tmpb.xB[i]) {
            ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
            ae_v_sub(tmpx.xR, 1, xy->xyR[i], 1, nx);
            Ok = Ok && testnearestneighborunit_vnorm(&tmpx, nx, normtype) >= r * (1 - errtol) / (1 + eps);
         }
      }
      for (i = 0; i < k - 1; i++) {
         Ok = Ok && qr.xR[i] <= qr.xR[i + 1];
      }
      for (i = 0; i < k; i++) {
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, xy->xyR[qtags.xZ[i]], 1, nx);
         Ok = Ok && NearAtR(testnearestneighborunit_vnorm(&tmpx, nx, normtype), qr.xR[i], errtol);
      }
   // Test functions which use external buffer:
   // * create external request buffer, perform buffered request
   // * reset status of internal buffer by performing 1-NN query, it is essential
   //   to test the fact that external buffer is used
   // * check consistency of results from different queries
   // * check that points in query are IN the R-sphere (or at the boundary),
   //   and points not in query are outside of the R-sphere (or at the boundary)
   // * check that distances are correct and are ordered
      kdtreecreaterequestbuffer(&treex, &bufx);
      kdtreecreaterequestbuffer(&treexy, &bufxy);
      kdtreecreaterequestbuffer(&treext, &bufxt);
      kx = kdtreetsqueryaknn(&treex, &bufx, &ptx, k, true, eps);
      kxy = kdtreetsqueryaknn(&treexy, &bufxy, &ptx, k, true, eps);
      kt = kdtreetsqueryaknn(&treext, &bufxt, &ptx, k, true, eps);
      kdtreequeryknn(&treex, &ptx, 1, true);
      kdtreequeryknn(&treexy, &ptx, 1, true);
      kdtreequeryknn(&treext, &ptx, 1, true);
      if (kx != k || kxy != k || kt != k) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreetsqueryresultsx(&treex, &bufx, &qx);
      kdtreetsqueryresultsxy(&treexy, &bufxy, &qxy);
      kdtreetsqueryresultstags(&treext, &bufxt, &qtags);
      kdtreetsqueryresultsdistances(&treext, &bufxt, &qr);
      Ok = Ok && testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = true;
      }
      r = 0.0;
      for (i = 0; i < k; i++) {
         tmpb.xB[qtags.xZ[i]] = false;
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, qx.xyR[i], 1, nx);
         r = rmax2(r, testnearestneighborunit_vnorm(&tmpx, nx, normtype));
      }
      for (i = 0; i < n; i++) {
         if (tmpb.xB[i]) {
            ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
            ae_v_sub(tmpx.xR, 1, xy->xyR[i], 1, nx);
            Ok = Ok && testnearestneighborunit_vnorm(&tmpx, nx, normtype) >= r * (1 - errtol) / (1 + eps);
         }
      }
      for (i = 0; i < k - 1; i++) {
         Ok = Ok && qr.xR[i] <= qr.xR[i + 1];
      }
      for (i = 0; i < k; i++) {
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, xy->xyR[qtags.xZ[i]], 1, nx);
         Ok = Ok && NearAtR(testnearestneighborunit_vnorm(&tmpx, nx, normtype), qr.xR[i], errtol);
      }
   }
// test ordered/unordered R-NN queries  (with self-matches):
// * compare results from different trees (must be equal) and
//   check that correct (value,tag) pairs are returned
// * test results from XT tree - let R be radius of query result.
//   then all points not in result must be not closer than R.
   for (q = 1; q <= qcount; q++) {
   // Use ordering?
      orderedrnn = randombool();
   // Select R
      if (randombool(0.3)) {
         r = machineepsilon;
      } else {
         r = rmax2(randomreal(), machineepsilon);
      }
   // Select point (either one of the points, or random)
      if (randombool()) {
         i = randominteger(n);
         ae_v_move(ptx.xR, 1, xy->xyR[i], 1, nx);
      } else {
         for (i = 0; i < nx; i++) {
            ptx.xR[i] = randommid();
         }
      }
   // Test functions which use internal buffer:
   // * consistency of results from different queries
   // * points in query are IN the R-sphere (or at the boundary),
   //   and points not in query are outside of the R-sphere (or at the boundary)
   // * distances are correct and are ordered
      if (orderedrnn) {
         kx = kdtreequeryrnn(&treex, &ptx, r, true);
         kxy = kdtreequeryrnn(&treexy, &ptx, r, true);
         kt = kdtreequeryrnn(&treext, &ptx, r, true);
      } else {
         kx = kdtreequeryrnnu(&treex, &ptx, r, true);
         kxy = kdtreequeryrnnu(&treexy, &ptx, r, true);
         kt = kdtreequeryrnnu(&treext, &ptx, r, true);
      }
      if (kxy != kx || kt != kx) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreequeryresultsxi(&treex, &qx);
      kdtreequeryresultsxyi(&treexy, &qxy);
      kdtreequeryresultstagsi(&treext, &qtags);
      kdtreequeryresultsdistancesi(&treext, &qr);
      Ok = Ok && testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, kx, nx, ny);
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreequeryresultsx(&treex, &qx);
      kdtreequeryresultsxy(&treexy, &qxy);
      kdtreequeryresultstags(&treext, &qtags);
      kdtreequeryresultsdistances(&treext, &qr);
      Ok = Ok && testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, kx, nx, ny);
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = true;
      }
      for (i = 0; i < kx; i++) {
         tmpb.xB[qtags.xZ[i]] = false;
      }
      for (i = 0; i < n; i++) {
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, xy->xyR[i], 1, nx);
         if (tmpb.xB[i]) {
            Ok = Ok && testnearestneighborunit_vnorm(&tmpx, nx, normtype) >= r * (1 - errtol);
         } else {
            Ok = Ok && testnearestneighborunit_vnorm(&tmpx, nx, normtype) <= r * (1 + errtol);
         }
      }
      if (orderedrnn) {
         for (i = 0; i < kx - 1; i++) {
            Ok = Ok && qr.xR[i] <= qr.xR[i + 1];
         }
      }
   // Test functions which use external buffer:
   // * create external request buffer, perform buffered request
   // * reset status of internal buffer by performing 1-NN query, it is essential
   //   to test the fact that external buffer is used
   // * check consistency of results from different queries
   // * check that points in query are IN the R-sphere (or at the boundary),
   //   and points not in query are outside of the R-sphere (or at the boundary)
   // * check that distances are correct and are ordered
      kdtreecreaterequestbuffer(&treex, &bufx);
      kdtreecreaterequestbuffer(&treexy, &bufxy);
      kdtreecreaterequestbuffer(&treext, &bufxt);
      if (orderedrnn) {
         kx = kdtreetsqueryrnn(&treex, &bufx, &ptx, r, true);
         kxy = kdtreetsqueryrnn(&treexy, &bufxy, &ptx, r, true);
         kt = kdtreetsqueryrnn(&treext, &bufxt, &ptx, r, true);
      } else {
         kx = kdtreetsqueryrnnu(&treex, &bufx, &ptx, r, true);
         kxy = kdtreetsqueryrnnu(&treexy, &bufxy, &ptx, r, true);
         kt = kdtreetsqueryrnnu(&treext, &bufxt, &ptx, r, true);
      }
      kdtreequeryknn(&treex, &ptx, 1, true);
      kdtreequeryknn(&treexy, &ptx, 1, true);
      kdtreequeryknn(&treext, &ptx, 1, true);
      if (kxy != kx || kt != kx) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreetsqueryresultsx(&treex, &bufx, &qx);
      kdtreetsqueryresultsxy(&treexy, &bufxy, &qxy);
      kdtreetsqueryresultstags(&treext, &bufxt, &qtags);
      kdtreetsqueryresultsdistances(&treext, &bufxt, &qr);
      Ok = Ok && testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, kx, nx, ny);
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = true;
      }
      for (i = 0; i < kx; i++) {
         tmpb.xB[qtags.xZ[i]] = false;
      }
      for (i = 0; i < n; i++) {
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, xy->xyR[i], 1, nx);
         if (tmpb.xB[i]) {
            Ok = Ok && testnearestneighborunit_vnorm(&tmpx, nx, normtype) >= r * (1 - errtol);
         } else {
            Ok = Ok && testnearestneighborunit_vnorm(&tmpx, nx, normtype) <= r * (1 + errtol);
         }
      }
      if (orderedrnn) {
         for (i = 0; i < kx - 1; i++) {
            Ok = Ok && qr.xR[i] <= qr.xR[i + 1];
         }
      }
   }
// test box queries
   ae_vector_set_length(&qmin, nx);
   ae_vector_set_length(&qmax, nx);
   for (q = 1; q <= qcount; q++) {
   // Test for box exactly equal to one of the points.
   // More than one exactly equal point may be found.
   // Only thread-safe version is tested.
      kdtreecreaterequestbuffer(&treext, &bufxt);
      k = randominteger(n);
      for (j = 0; j < nx; j++) {
         qmin.xR[j] = xy->xyR[k][j];
         qmax.xR[j] = xy->xyR[k][j];
      }
      kx = kdtreetsquerybox(&treext, &bufxt, &qmin, &qmax);
      if (kx < 1) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      SetMatrix(&qx);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreetsqueryresultsx(&treext, &bufxt, &qx);
      kdtreetsqueryresultstags(&treext, &bufxt, &qtags);
      kdtreetsqueryresultsdistances(&treext, &bufxt, &qr);
      for (i = 0; i < kx; i++) {
         Ok = Ok && qr.xR[i] == 0.0;
      }
      for (i = 0; i < kx; i++) {
         for (j = 0; j < nx; j++) {
            Ok = Ok && qx.xyR[i][j] == xy->xyR[k][j];
            Ok = Ok && qx.xyR[i][j] == xy->xyR[qtags.xZ[i]][j];
         }
      }
   // Test for randomly generated box (thread-safe version)
      for (j = 0; j < nx; j++) {
         qmin.xR[j] = boxmin.xR[j] + randomreal() * (boxmax.xR[j] - boxmin.xR[j]);
         qmax.xR[j] = qmin.xR[j];
         v = spread * pow(10.0, -2 * randomreal());
         qmin.xR[j] -= v;
         qmax.xR[j] += v;
      }
      kx = kdtreetsquerybox(&treext, &bufxt, &qmin, &qmax);
      SetMatrix(&qx);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreetsqueryresultsx(&treext, &bufxt, &qx);
      kdtreetsqueryresultstags(&treext, &bufxt, &qtags);
      kdtreetsqueryresultsdistances(&treext, &bufxt, &qr);
      for (i = 0; i < kx; i++) {
         Ok = Ok && qr.xR[i] == 0.0;
      }
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = false;
      }
      for (i = 0; i < kx; i++) {
         tmpb.xB[qtags.xZ[i]] = true;
      }
      for (i = 0; i < n; i++) {
         inthebox = true;
         for (j = 0; j < nx; j++) {
            inthebox = inthebox && xy->xyR[i][j] >= qmin.xR[j];
            inthebox = inthebox && xy->xyR[i][j] <= qmax.xR[j];
         }
         if (tmpb.xB[i]) {
            Ok = Ok && inthebox;
         } else {
            Ok = Ok && !inthebox;
         }
      }
   // Test for randomly generated box (non-thread-safe version)
      for (j = 0; j < nx; j++) {
         qmin.xR[j] = boxmin.xR[j] + randomreal() * (boxmax.xR[j] - boxmin.xR[j]);
         qmax.xR[j] = qmin.xR[j];
         v = spread * pow(10.0, -2 * randomreal());
         qmin.xR[j] -= v;
         qmax.xR[j] += v;
      }
      kx = kdtreequerybox(&treext, &qmin, &qmax);
      SetMatrix(&qx);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreequeryresultsx(&treext, &qx);
      kdtreequeryresultstags(&treext, &qtags);
      kdtreequeryresultsdistances(&treext, &qr);
      for (i = 0; i < kx; i++) {
         Ok = Ok && qr.xR[i] == 0.0;
      }
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = false;
      }
      for (i = 0; i < kx; i++) {
         tmpb.xB[qtags.xZ[i]] = true;
      }
      for (i = 0; i < n; i++) {
         inthebox = true;
         for (j = 0; j < nx; j++) {
            inthebox = inthebox && xy->xyR[i][j] >= qmin.xR[j];
            inthebox = inthebox && xy->xyR[i][j] <= qmax.xR[j];
         }
         if (tmpb.xB[i]) {
            Ok = Ok && inthebox;
         } else {
            Ok = Ok && !inthebox;
         }
      }
   }
// Test self-matching:
// * self-match - nearest neighbor of each point in XY is the point itself
// * no self-match - nearest neighbor is NOT the point itself
   if (n > 1) {
   // test for N == 1 have non-general form, but it is not really needed
      for (task = 0; task <= 1; task++) {
         for (i = 0; i < n; i++) {
            ae_v_move(ptx.xR, 1, xy->xyR[i], 1, nx);
            kx = kdtreequeryknn(&treex, &ptx, 1, task == 0);
            kdtreequeryresultsxi(&treex, &qx);
            if (kx != 1) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            isequal = true;
            for (j = 0; j < nx; j++) {
               isequal = isequal && qx.xyR[0][j] == ptx.xR[j];
            }
            if (task == 0) {
               Ok = Ok && isequal;
            } else {
               Ok = Ok && !isequal;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Testing serialization of KD trees
static bool testnearestneighborunit_testkdtreeserialization() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t normtype;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t q;
   double threshold;
   ae_int_t k0;
   ae_int_t k1;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(tags, 0, DT_INT);
   NewVector(qsizes, 0, DT_INT);
   NewObj(kdtree, tree0);
   NewObj(kdtree, tree1);
   NewMatrix(xy0, 0, 0, DT_REAL);
   NewMatrix(xy1, 0, 0, DT_REAL);
   NewVector(tags0, 0, DT_INT);
   NewVector(tags1, 0, DT_INT);
   threshold = 100.0 * machineepsilon;
// different N, NX, NY, NormType
   n = 1;
   while (n <= 51) {
   // prepare array with query sizes
      ae_vector_set_length(&qsizes, 4);
      qsizes.xZ[0] = 1;
      qsizes.xZ[1] = imin2(2, n);
      qsizes.xZ[2] = imin2(4, n);
      qsizes.xZ[3] = n;
   // different NX/NY/NormType
      for (nx = 1; nx <= 2; nx++) {
         for (ny = 0; ny <= 2; ny++) {
            for (normtype = 0; normtype <= 2; normtype++) {
            // Prepare data
               ae_matrix_set_length(&xy, n, nx + ny);
               ae_vector_set_length(&tags, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < nx + ny; j++) {
                     xy.xyR[i][j] = randomreal();
                  }
                  tags.xZ[i] = randominteger(100);
               }
            // Build tree, pass it through serializer
               kdtreebuildtagged(&xy, &tags, n, nx, ny, normtype, &tree0);
               {
               // This code passes data structure through serializers
               // (serializes it to string and loads back)
                  ae_frame _local_frame_block;
                  ae_frame_make(&_local_frame_block);
                  NewSerializer(_local_serializer);
                  ae_serializer_alloc_start(&_local_serializer);
                  kdtreealloc(&_local_serializer, &tree0);
                  ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                  NewBlock(_local_dynamic_block, _local_ssize + 1);
                  ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  kdtreeserialize(&_local_serializer, &tree0);
                  ae_serializer_stop(&_local_serializer);
                  ae_serializer_init(&_local_serializer);
                  ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  kdtreeunserialize(&_local_serializer, &tree1);
                  ae_serializer_stop(&_local_serializer);
                  ae_frame_leave();
               }
            // For each point of XY we make queries with different sizes
               ae_vector_set_length(&x, nx);
               for (k = 0; k < n; k++) {
                  for (q = 0; q < qsizes.cnt; q++) {
                     ae_v_move(x.xR, 1, xy.xyR[k], 1, nx);
                     k0 = kdtreequeryknn(&tree0, &x, qsizes.xZ[q], true);
                     k1 = kdtreequeryknn(&tree1, &x, qsizes.xZ[q], true);
                     if (k0 != k1) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                     kdtreequeryresultsxy(&tree0, &xy0);
                     kdtreequeryresultsxy(&tree1, &xy1);
                     for (i = 0; i < k0; i++) {
                        for (j = 0; j < nx + ny; j++) {
                           if (!NearAtR(xy0.xyR[i][j], xy1.xyR[i][j], threshold)) {
                              Ok = false;
                              ae_frame_leave();
                              return Ok;
                           }
                        }
                     }
                     kdtreequeryresultstags(&tree0, &tags0);
                     kdtreequeryresultstags(&tree1, &tags1);
                     for (i = 0; i < k0; i++) {
                        if (tags0.xZ[i] != tags1.xZ[i]) {
                           Ok = false;
                           ae_frame_leave();
                           return Ok;
                        }
                     }
                  }
               }
            }
         }
      }
   // Next N
      n += 25;
   }
   ae_frame_leave();
   return Ok;
}

// This function tests different special cases:
// * Kd-tree for a zero number of points
// * Kd-tree for array with a lot of duplicates (early versions of ALGLIB
//   raised stack overflow on such datasets)
static bool testnearestneighborunit_testspecialcases() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nk;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t normtype;
   ae_int_t i;
   ae_int_t j;
   double v;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(kdtree, kdt);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(tags, 0, DT_INT);
   NewVector(x, 0, DT_REAL);
   Ok = true;
   for (nx = 1; nx <= 3; nx++) {
      for (ny = 0; ny <= 3; ny++) {
         for (normtype = 0; normtype <= 2; normtype++) {
         // Build tree
            if (randombool()) {
               kdtreebuildtagged(&xy, &tags, 0, nx, ny, normtype, &kdt);
            } else {
               kdtreebuild(&xy, 0, nx, ny, normtype, &kdt);
            }
         // Test different queries
            ae_vector_set_length(&x, nx);
            for (i = 0; i < nx; i++) {
               x.xR[i] = randomreal();
            }
            Ok = Ok && kdtreequeryknn(&kdt, &x, 1, true) <= 0;
            Ok = Ok && kdtreequeryrnn(&kdt, &x, 1.0E6, true) <= 0;
            Ok = Ok && kdtreequeryaknn(&kdt, &x, 1, true, 2.0) <= 0;
         }
      }
   }
// Ability to handle array with a lot of duplicates without causing
// stack overflow.
//
// Two situations are handled:
// * array where ALL N elements are duplicates
// * array where there are NK distinct elements and N-NK duplicates
   nx = 2;
   ny = 1;
   n = 100000;
   nk = 100;
   v = randomreal();
   ae_matrix_set_length(&xy, n, nx + ny);
   ae_vector_set_length(&x, nx);
   for (i = 0; i < n; i++) {
      for (j = 0; j < nx + ny; j++) {
         xy.xyR[i][j] = v;
      }
   }
   kdtreebuild(&xy, n, nx, ny, 2, &kdt);
   for (j = 0; j < nx; j++) {
      x.xR[j] = v;
   }
   Ok = Ok && kdtreequeryrnn(&kdt, &x, 0.0001, true) == n;
   for (i = 0; i < nk; i++) {
      for (j = 0; j < nx + ny; j++) {
         xy.xyR[i][j] = randomreal();
      }
   }
   kdtreebuild(&xy, n, nx, ny, 2, &kdt);
   Ok = Ok && kdtreequeryrnn(&kdt, &x, 0.0001, true) >= n - nk;
   ae_frame_leave();
   return Ok;
}

// Testing Nearest Neighbor Search
bool testnearestneighbor() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_int_t normtype;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t n;
   ae_int_t smalln;
   ae_int_t largen;
   ae_int_t passcount;
   ae_int_t pass;
   bool Ok;
   bool kdtOk;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   kdtOk = true;
   passcount = 2;
   smalln = 256;
   largen = 2048;
   ny = 3;
//
   kdtOk = kdtOk && testnearestneighborunit_testkdtreeserialization();
   for (pass = 1; pass <= passcount; pass++) {
      for (normtype = 0; normtype <= 2; normtype++) {
         for (nx = 1; nx <= 3; nx++) {
         // Test in hypercube
            ae_matrix_set_length(&xy, largen, nx + ny);
            for (i = 0; i < largen; i++) {
               for (j = 0; j < nx + ny; j++) {
                  xy.xyR[i][j] = 5.0 * randommid();
               }
            }
            for (n = 1; n <= 10; n++) {
               kdtOk = kdtOk && testnearestneighborunit_testkdtuniform(&xy, n, nx, randominteger(ny + 1), normtype);
            }
            kdtOk = kdtOk && testnearestneighborunit_testkdtuniform(&xy, largen, nx, randominteger(ny + 1), normtype);
         // Test clustered (2*N points, pairs of equal points)
            ae_matrix_set_length(&xy, 2 * smalln, nx + ny);
            for (i = 0; i < smalln; i++) {
               for (j = 0; j < nx + ny; j++) {
                  xy.xyR[2 * i][j] = 5.0 * randommid();
                  xy.xyR[2 * i + 1][j] = xy.xyR[2 * i][j];
               }
            }
            kdtOk = kdtOk && testnearestneighborunit_testkdtuniform(&xy, 2 * smalln, nx, randominteger(ny + 1), normtype);
         // Test degenerate case: all points are same except for one
            ae_matrix_set_length(&xy, smalln, nx + ny);
            v = randomreal();
            for (i = 0; i < smalln - 1; i++) {
               for (j = 0; j < nx + ny; j++) {
                  xy.xyR[i][j] = v;
               }
            }
            for (j = 0; j < nx + ny; j++) {
               xy.xyR[smalln - 1][j] = 5.0 * randommid();
            }
            kdtOk = kdtOk && testnearestneighborunit_testkdtuniform(&xy, smalln, nx, randominteger(ny + 1), normtype);
         }
      }
   }
   kdtOk = kdtOk && testnearestneighborunit_testspecialcases();
// The final report.
   Ok = kdtOk;
   if (!Ok || !silent) {
      printf("Nearest Neighbor Search Test\n");
      printf("* KD Trees:                               %s\n", kdtOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === odesolver testing unit ===
// Test
bool testodesolver() {
   ae_frame _frame_block;
   ae_int_t passcount;
   bool curerrors;
   bool rkckOk;
   bool Ok;
   double h;
   double eps;
   ae_int_t solver;
   ae_int_t pass;
   ae_int_t mynfev;
   double v;
   ae_int_t m;
   ae_int_t m2;
   ae_int_t i;
   double err;
   ae_frame_make(&_frame_block);
   NewVector(xtbl, 0, DT_REAL);
   NewMatrix(ytbl, 0, 0, DT_REAL);
   NewObj(odesolverreport, rep);
   NewVector(xg, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(odesolverstate, state);
   rkckOk = true;
   Ok = true;
   passcount = 10;
// simple test: just A*sin(x)+B*cos(x)
   ae_assert(passcount >= 2, "Assertion failed");
   for (pass = 0; pass < passcount; pass++) {
      for (solver = 0; solver <= 0; solver++) {
      // prepare
         h = 1.0E-2;
         eps = 1.0E-5;
         if (pass % 2 == 0) {
            eps = -eps;
         }
         ae_vector_set_length(&y, 2);
         for (i = 0; i <= 1; i++) {
            y.xR[i] = randommid();
         }
         m = 2 + randominteger(10);
         ae_vector_set_length(&xg, m);
         xg.xR[0] = (m - 1) * randomreal();
         for (i = 1; i < m; i++) {
            xg.xR[i] = xg.xR[i - 1] + randomreal();
         }
         v = 2 * pi / (xg.xR[m - 1] - xg.xR[0]);
         ae_v_muld(xg.xR, 1, m, v);
         if (randombool()) {
            ae_v_muld(xg.xR, 1, m, -1);
         }
         mynfev = 0;
      // choose solver
         if (solver == 0) {
            odesolverrkck(&y, 2, &xg, m, eps, h, &state);
         }
      // solve
         while (odesolveriteration(&state)) {
            state.dy.xR[0] = state.y.xR[1];
            state.dy.xR[1] = -state.y.xR[0];
            mynfev++;
         }
         odesolverresults(&state, &m2, &xtbl, &ytbl, &rep);
      // check results
         curerrors = false;
         if (rep.terminationtype <= 0) {
            curerrors = true;
         } else {
            curerrors = curerrors || m2 != m;
            err = 0.0;
            for (i = 0; i < m; i++) {
               err = rmax2(err, fabs(ytbl.xyR[i][0] - (y.xR[0] * cos(xtbl.xR[i] - xtbl.xR[0]) + y.xR[1] * sin(xtbl.xR[i] - xtbl.xR[0]))));
               err = rmax2(err, fabs(ytbl.xyR[i][1] - (-y.xR[0] * sin(xtbl.xR[i] - xtbl.xR[0]) + y.xR[1] * cos(xtbl.xR[i] - xtbl.xR[0]))));
            }
            curerrors = curerrors || err > 10 * fabs(eps);
            curerrors = curerrors || mynfev != rep.nfev;
         }
         if (solver == 0) {
            rkckOk = rkckOk && !curerrors;
         }
      }
   }
// another test:
//
//     y(0)   = 0
//     dy/dx  = f(x,y)
//     f(x,y) = 0,   x < 1
//              x-1, x >= 1
//
// with BOTH absolute and fractional tolerances.
// Starting from zero will be real challenge for
// fractional tolerance.
   ae_assert(passcount >= 2, "Assertion failed");
   for (pass = 0; pass < passcount; pass++) {
      h = 1.0E-4;
      eps = 1.0E-4;
      if (pass % 2 == 0) {
         eps = -eps;
      }
      ae_vector_set_length(&y, 1);
      y.xR[0] = 0.0;
      m = 21;
      ae_vector_set_length(&xg, m);
      for (i = 0; i < m; i++) {
         xg.xR[i] = (double)(2 * i) / (m - 1);
      }
      mynfev = 0;
      odesolverrkck(&y, 1, &xg, m, eps, h, &state);
      while (odesolveriteration(&state)) {
         state.dy.xR[0] = rmax2(state.x - 1, 0.0);
         mynfev++;
      }
      odesolverresults(&state, &m2, &xtbl, &ytbl, &rep);
      if (rep.terminationtype <= 0) {
         rkckOk = false;
      } else {
         rkckOk = rkckOk && m2 == m;
         err = 0.0;
         for (i = 0; i < m; i++) {
            err = rmax2(err, fabs(ytbl.xyR[i][0] - sqr(rmax2(xg.xR[i] - 1, 0.0)) / 2));
         }
         rkckOk = rkckOk && err <= fabs(eps);
         rkckOk = rkckOk && mynfev == rep.nfev;
      }
   }
// The final report.
   Ok = rkckOk;
   if (!Ok || !silent) {
      printf("ODE Solver Test\n");
      printf("* Runge-Kutta Cash-Karp:                  %s\n", rkckOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === inverseupdate testing unit ===
// Copy
static void testinverseupdateunit_makeacopy(RMatrix *a, ae_int_t m, ae_int_t n, RMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyR[i][j] = a->xyR[i][j];
      }
   }
}

// LU decomposition
static void testinverseupdateunit_matlu(RMatrix *a, ae_int_t m, ae_int_t n, ZVector *pivots) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t jp;
   double s;
   ae_frame_make(&_frame_block);
   SetVector(pivots);
   NewVector(t1, 0, DT_REAL);
   ae_vector_set_length(pivots, imin2(m - 1, n - 1) + 1);
   ae_vector_set_length(&t1, imax2(m - 1, n - 1) + 1);
   ae_assert(m >= 0 && n >= 0, "Error in LUDecomposition: incorrect function arguments");
// Quick return if possible
   if (m == 0 || n == 0) {
      ae_frame_leave();
      return;
   }
   for (j = 0; j < imin2(m, n); j++) {
   // Find pivot and test for singularity.
      jp = j;
      for (i = j + 1; i < m; i++) {
         if (fabs(a->xyR[i][j]) > fabs(a->xyR[jp][j])) {
            jp = i;
         }
      }
      pivots->xZ[j] = jp;
      if (a->xyR[jp][j] != 0.0) {
      // Apply the interchange to rows
         if (jp != j) {
            ae_v_move(t1.xR, 1, a->xyR[j], 1, n);
            ae_v_move(a->xyR[j], 1, a->xyR[jp], 1, n);
            ae_v_move(a->xyR[jp], 1, t1.xR, 1, n);
         }
      // Compute elements J+1:M of J-th column.
         if (j + 1 < m) {
            jp = j + 1;
            s = 1 / a->xyR[j][j];
            ae_v_muld(&a->xyR[jp][j], a->stride, m - jp, s);
         }
      }
      if (j < imin2(m, n) - 1) {
      // Update trailing submatrix.
         jp = j + 1;
         for (i = j + 1; i < m; i++) {
            s = a->xyR[i][j];
            ae_v_subd(&a->xyR[i][jp], 1, &a->xyR[j][jp], 1, n - jp, s);
         }
      }
   }
   ae_frame_leave();
}

// Generate matrix with given condition number C (2-norm)
static void testinverseupdateunit_generaterandomorthogonalmatrix(RMatrix *a0, ae_int_t n) {
   ae_frame _frame_block;
   double t;
   double lambdav;
   ae_int_t s;
   ae_int_t i;
   ae_int_t j;
   double u1;
   double u2;
   double sm;
   ae_frame_make(&_frame_block);
   NewVector(w, 0, DT_REAL);
   NewVector(v, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   if (n <= 0) {
      ae_frame_leave();
      return;
   }
   ae_vector_set_length(&w, n + 1);
   ae_vector_set_length(&v, n + 1);
   ae_matrix_set_length(&a, n + 1, n + 1);
   ae_matrix_set_length(a0, n, n);
// Prepare A
   for (i = 1; i <= n; i++) {
      for (j = 1; j <= n; j++) {
         if (i == j) {
            a.xyR[i][j] = 1.0;
         } else {
            a.xyR[i][j] = 0.0;
         }
      }
   }
// Calculate A using Stewart algorithm
   for (s = 2; s <= n; s++) {
   // Prepare v and Lambda = v'*v
      do {
         i = 1;
         while (i <= s) {
            u1 = randommid();
            u2 = randommid();
            sm = u1 * u1 + u2 * u2;
            if (sm == 0.0 || sm > 1.0) {
               continue;
            }
            sm = sqrt(-2 * log(sm) / sm);
            v.xR[i] = u1 * sm;
            if (i + 1 <= s) {
               v.xR[i + 1] = u2 * sm;
            }
            i += 2;
         }
         lambdav = ae_v_dotproduct(&v.xR[1], 1, &v.xR[1], 1, s);
      } while (lambdav == 0.0);
      lambdav = 2 / lambdav;
   // A * (I - 2 vv'/v'v ) =
   //   = A - (2/v'v) * A * v * v' =
   //   = A - (2/v'v) * w * v'
   // where w = Av
      for (i = 1; i <= s; i++) {
         t = ae_v_dotproduct(&a.xyR[i][1], 1, &v.xR[1], 1, s);
         w.xR[i] = t;
      }
      for (i = 1; i <= s; i++) {
         t = w.xR[i] * lambdav;
         ae_v_subd(&a.xyR[i][1], 1, &v.xR[1], 1, s, t);
      }
   }
//
   for (i = 1; i <= n; i++) {
      for (j = 1; j <= n; j++) {
         a0->xyR[i - 1][j - 1] = a.xyR[i][j];
      }
   }
   ae_frame_leave();
}

static void testinverseupdateunit_generaterandommatrixcond(RMatrix *a0, ae_int_t n, double c) {
   ae_frame _frame_block;
   double l1;
   double l2;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_frame_make(&_frame_block);
   NewMatrix(q1, 0, 0, DT_REAL);
   NewMatrix(q2, 0, 0, DT_REAL);
   NewVector(cc, 0, DT_REAL);
   testinverseupdateunit_generaterandomorthogonalmatrix(&q1, n);
   testinverseupdateunit_generaterandomorthogonalmatrix(&q2, n);
   ae_vector_set_length(&cc, n);
   l1 = 0.0;
   l2 = log(1 / c);
   cc.xR[0] = exp(l1);
   for (i = 1; i < n - 1; i++) {
      cc.xR[i] = exp(randomreal() * (l2 - l1) + l1);
   }
   cc.xR[n - 1] = exp(l2);
   ae_matrix_set_length(a0, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a0->xyR[i][j] = 0.0;
         for (k = 0; k < n; k++) {
            a0->xyR[i][j] += q1.xyR[i][k] * cc.xR[k] * q2.xyR[j][k];
         }
      }
   }
   ae_frame_leave();
}

// triangular inverse
static bool testinverseupdateunit_invmattr(RMatrix *a, ae_int_t n, bool isupper, bool isunittriangular) {
   ae_frame _frame_block;
   bool nounit;
   ae_int_t i;
   ae_int_t j;
   double v;
   double ajj;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(t, 0, DT_REAL);
   Ok = true;
   ae_vector_set_length(&t, n);
// Test the input parameters.
   nounit = !isunittriangular;
   if (isupper) {
   // Compute inverse of upper triangular matrix.
      for (j = 0; j < n; j++) {
         if (nounit) {
            if (a->xyR[j][j] == 0.0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            a->xyR[j][j] = 1 / a->xyR[j][j];
            ajj = -a->xyR[j][j];
         } else {
            ajj = -1.0;
         }
      // Compute elements 1:j-1 of j-th column.
         if (j > 0) {
            ae_v_move(t.xR, 1, &a->xyR[0][j], a->stride, j);
            for (i = 0; i < j; i++) {
               if (i < j - 1) {
                  v = ae_v_dotproduct(&a->xyR[i][i + 1], 1, &t.xR[i + 1], 1, j - i - 1);
               } else {
                  v = 0.0;
               }
               if (nounit) {
                  a->xyR[i][j] = v + a->xyR[i][i] * t.xR[i];
               } else {
                  a->xyR[i][j] = v + t.xR[i];
               }
            }
            ae_v_muld(&a->xyR[0][j], a->stride, j, ajj);
         }
      }
   } else {
   // Compute inverse of lower triangular matrix.
      for (j = n - 1; j >= 0; j--) {
         if (nounit) {
            if (a->xyR[j][j] == 0.0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            a->xyR[j][j] = 1 / a->xyR[j][j];
            ajj = -a->xyR[j][j];
         } else {
            ajj = -1.0;
         }
         if (j < n - 1) {
         // Compute elements j+1:n of j-th column.
            ae_v_move(&t.xR[j + 1], 1, &a->xyR[j + 1][j], a->stride, n - j - 1);
            for (i = j + 1; i < n; i++) {
               if (i > j + 1) {
                  v = ae_v_dotproduct(&a->xyR[i][j + 1], 1, &t.xR[j + 1], 1, i - j - 1);
               } else {
                  v = 0.0;
               }
               if (nounit) {
                  a->xyR[i][j] = v + a->xyR[i][i] * t.xR[i];
               } else {
                  a->xyR[i][j] = v + t.xR[i];
               }
            }
            ae_v_muld(&a->xyR[j + 1][j], a->stride, n - j - 1, ajj);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// LU inverse
static bool testinverseupdateunit_invmatlu(RMatrix *a, ZVector *pivots, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t jp;
   double v;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(work, 0, DT_REAL);
   Ok = true;
// Quick return if possible
   if (n == 0) {
      ae_frame_leave();
      return Ok;
   }
   ae_vector_set_length(&work, n);
// Form inv(U)
   if (!testinverseupdateunit_invmattr(a, n, true, false)) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
// Solve the equation inv(A)*L = inv(U) for inv(A).
   for (j = n - 1; j >= 0; j--) {
   // Copy current column of L to WORK and replace with zeros.
      for (i = j + 1; i < n; i++) {
         work.xR[i] = a->xyR[i][j];
         a->xyR[i][j] = 0.0;
      }
   // Compute current column of inv(A).
      if (j < n - 1) {
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(&a->xyR[i][j + 1], 1, &work.xR[j + 1], 1, n - j - 1);
            a->xyR[i][j] -= v;
         }
      }
   }
// Apply column interchanges.
   for (j = n - 2; j >= 0; j--) {
      jp = pivots->xZ[j];
      if (jp != j) {
         ae_v_move(work.xR, 1, &a->xyR[0][j], a->stride, n);
         ae_v_move(&a->xyR[0][j], a->stride, &a->xyR[0][jp], a->stride, n);
         ae_v_move(&a->xyR[0][jp], a->stride, work.xR, 1, n);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Matrix inverse
static bool testinverseupdateunit_invmat(RMatrix *a, ae_int_t n) {
   ae_frame _frame_block;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(pivots, 0, DT_INT);
   testinverseupdateunit_matlu(a, n, n, &pivots);
   Ok = testinverseupdateunit_invmatlu(a, &pivots, n);
   ae_frame_leave();
   return Ok;
}

// Diff
static double testinverseupdateunit_matrixdiff(RMatrix *a, RMatrix *b, ae_int_t m, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   double result;
   result = 0.0;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         result = rmax2(result, fabs(b->xyR[i][j] - a->xyR[i][j]));
      }
   }
   return result;
}

// Update and inverse
static bool testinverseupdateunit_updandinv(RMatrix *a, RVector *u, RVector *v, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   double r;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(pivots, 0, DT_INT);
   for (i = 0; i < n; i++) {
      r = u->xR[i];
      ae_v_addd(a->xyR[i], 1, v->xR, 1, n, r);
   }
   testinverseupdateunit_matlu(a, n, n, &pivots);
   Ok = testinverseupdateunit_invmatlu(a, &pivots, n);
   ae_frame_leave();
   return Ok;
}

bool testinverseupdate() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t i;
   ae_int_t updrow;
   ae_int_t updcol;
   double val;
   ae_int_t pass;
   ae_int_t passcount;
   bool Ok;
   double threshold;
   double c;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(inva, 0, 0, DT_REAL);
   NewMatrix(b1, 0, 0, DT_REAL);
   NewMatrix(b2, 0, 0, DT_REAL);
   NewVector(u, 0, DT_REAL);
   NewVector(v, 0, DT_REAL);
   Ok = true;
   maxn = 10;
   passcount = 100;
   threshold = 1.0E-6;
// process
   for (n = 1; n <= maxn; n++) {
      ae_matrix_set_length(&a, n, n);
      ae_matrix_set_length(&b1, n, n);
      ae_matrix_set_length(&b2, n, n);
      ae_vector_set_length(&u, n);
      ae_vector_set_length(&v, n);
      for (pass = 1; pass <= passcount; pass++) {
         c = exp(randomreal() * log(10.0));
         testinverseupdateunit_generaterandommatrixcond(&a, n, c);
         testinverseupdateunit_makeacopy(&a, n, n, &inva);
         if (!testinverseupdateunit_invmat(&inva, n)) {
            Ok = false;
            break;
         }
      // Test simple update
         updrow = randominteger(n);
         updcol = randominteger(n);
         val = 0.1 * randommid();
         for (i = 0; i < n; i++) {
            if (i == updrow) {
               u.xR[i] = val;
            } else {
               u.xR[i] = 0.0;
            }
            if (i == updcol) {
               v.xR[i] = 1.0;
            } else {
               v.xR[i] = 0.0;
            }
         }
         testinverseupdateunit_makeacopy(&a, n, n, &b1);
         if (!testinverseupdateunit_updandinv(&b1, &u, &v, n)) {
            Ok = false;
            break;
         }
         testinverseupdateunit_makeacopy(&inva, n, n, &b2);
         rmatrixinvupdatesimple(&b2, n, updrow, updcol, val);
         Ok = Ok && testinverseupdateunit_matrixdiff(&b1, &b2, n, n) <= threshold;
      // Test row update
         updrow = randominteger(n);
         for (i = 0; i < n; i++) {
            if (i == updrow) {
               u.xR[i] = 1.0;
            } else {
               u.xR[i] = 0.0;
            }
            v.xR[i] = 0.1 * randommid();
         }
         testinverseupdateunit_makeacopy(&a, n, n, &b1);
         if (!testinverseupdateunit_updandinv(&b1, &u, &v, n)) {
            Ok = false;
            break;
         }
         testinverseupdateunit_makeacopy(&inva, n, n, &b2);
         rmatrixinvupdaterow(&b2, n, updrow, &v);
         Ok = Ok && testinverseupdateunit_matrixdiff(&b1, &b2, n, n) <= threshold;
      // Test column update
         updcol = randominteger(n);
         for (i = 0; i < n; i++) {
            if (i == updcol) {
               v.xR[i] = 1.0;
            } else {
               v.xR[i] = 0.0;
            }
            u.xR[i] = 0.1 * randommid();
         }
         testinverseupdateunit_makeacopy(&a, n, n, &b1);
         if (!testinverseupdateunit_updandinv(&b1, &u, &v, n)) {
            Ok = false;
            break;
         }
         testinverseupdateunit_makeacopy(&inva, n, n, &b2);
         rmatrixinvupdatecolumn(&b2, n, updcol, &u);
         Ok = Ok && testinverseupdateunit_matrixdiff(&b1, &b2, n, n) <= threshold;
      // Test full update
         for (i = 0; i < n; i++) {
            v.xR[i] = 0.1 * randommid();
            u.xR[i] = 0.1 * randommid();
         }
         testinverseupdateunit_makeacopy(&a, n, n, &b1);
         if (!testinverseupdateunit_updandinv(&b1, &u, &v, n)) {
            Ok = false;
            break;
         }
         testinverseupdateunit_makeacopy(&inva, n, n, &b2);
         rmatrixinvupdateuv(&b2, n, &u, &v);
         Ok = Ok && testinverseupdateunit_matrixdiff(&b1, &b2, n, n) <= threshold;
      }
   }
// The final report.
   if (!Ok || !silent) {
      printf("Inverse Update (Real) Test\n");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === schur testing unit ===
static void testschurunit_testschurproblem(RMatrix *a, ae_int_t n, double *materr, double *orterr, bool *SortOkP, bool *ConvOkP) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double locerr;
   ae_frame_make(&_frame_block);
   NewMatrix(s, 0, 0, DT_REAL);
   NewMatrix(t, 0, 0, DT_REAL);
   NewVector(sr, 0, DT_REAL);
   NewVector(astc, 0, DT_REAL);
   NewVector(sastc, 0, DT_REAL);
   ae_vector_set_length(&sr, n);
   ae_vector_set_length(&astc, n);
   ae_vector_set_length(&sastc, n);
// Schur decomposition, convergence test
   ae_matrix_set_length(&t, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         t.xyR[i][j] = a->xyR[i][j];
      }
   }
   if (!rmatrixschur(&t, n, &s)) {
      *ConvOkP = false;
      ae_frame_leave();
      return;
   }
// decomposition error
   locerr = 0.0;
   for (j = 0; j < n; j++) {
      ae_v_move(sr.xR, 1, s.xyR[j], 1, n);
      for (k = 0; k < n; k++) {
         v = ae_v_dotproduct(t.xyR[k], 1, sr.xR, 1, n);
         astc.xR[k] = v;
      }
      for (k = 0; k < n; k++) {
         v = ae_v_dotproduct(s.xyR[k], 1, astc.xR, 1, n);
         sastc.xR[k] = v;
      }
      for (k = 0; k < n; k++) {
         locerr = rmax2(locerr, fabs(sastc.xR[k] - a->xyR[k][j]));
      }
   }
   *materr = rmax2(*materr, locerr);
// orthogonality error
   locerr = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(&s.xyR[0][i], s.stride, &s.xyR[0][j], s.stride, n);
         if (i != j) {
            locerr = rmax2(locerr, fabs(v));
         } else {
            locerr = rmax2(locerr, fabs(v - 1));
         }
      }
   }
   *orterr = rmax2(*orterr, locerr);
// T matrix structure
   for (j = 0; j < n; j++) {
      for (i = j + 2; i < n; i++) {
         if (t.xyR[i][j] != 0.0) {
            *SortOkP = false;
         }
      }
   }
   ae_frame_leave();
}

// Testing Schur decomposition subroutine
bool testschur() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   ae_int_t passcount;
   bool Ok;
   bool structOk;
   bool convOk;
   double materr;
   double orterr;
   double threshold;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   materr = 0.0;
   orterr = 0.0;
   structOk = true;
   convOk = true;
   Ok = true;
   maxn = 70;
   passcount = 1;
   threshold = 5.0 * 100.0 * machineepsilon;
   ae_matrix_set_length(&a, maxn, maxn);
// zero matrix, several cases
   for (i = 0; i < maxn; i++) {
      for (j = 0; j < maxn; j++) {
         a.xyR[i][j] = 0.0;
      }
   }
   for (n = 1; n <= maxn; n++) {
      if (n > 30 && n % 2 == 0) {
         continue;
      }
      testschurunit_testschurproblem(&a, n, &materr, &orterr, &structOk, &convOk);
   }
// Dense matrix
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         if (n > 30 && n % 2 == 0) {
            continue;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = randommid();
            }
         }
         testschurunit_testschurproblem(&a, n, &materr, &orterr, &structOk, &convOk);
      }
   }
// The final report.
   Ok = materr <= threshold && orterr <= threshold && structOk && convOk;
   if (!Ok || !silent) {
      printf("Schur Decomposition Tests\n");
      printf("Schur Decomposition Error:                %5.3e\n", materr);
      printf("Schur Orthogonality Error:                %5.3e\n", orterr);
      printf("T Matrix Structure:                       %s\n", structOk? "Ok": "Failed");
      printf("Always converged:                         %s\n", convOk? "Ok": "Failed");
      printf("Threshold:                                %5.3e\n", threshold);
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === spdgevd testing unit ===
// Testing bidiagonal SVD decomposition subroutine
bool testspdgevd() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t passcount;
   ae_int_t maxn;
   ae_int_t atask;
   ae_int_t btask;
   bool isuppera;
   bool isupperb;
   ae_int_t i;
   ae_int_t j;
   ae_int_t minij;
   double v;
   double v1;
   double v2;
   double err;
   double valerr;
   double threshold;
   bool Ok;
   bool convOk;
   bool sortOk;
   ae_frame_make(&_frame_block);
   NewVector(d, 0, DT_REAL);
   NewVector(t1, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewMatrix(afull, 0, 0, DT_REAL);
   NewMatrix(bfull, 0, 0, DT_REAL);
   NewMatrix(l, 0, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   threshold = 10000.0 * machineepsilon;
   valerr = 0.0;
   convOk = true;
   sortOk = true;
   maxn = 20;
   passcount = 5;
// Main cycle
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
         for (atask = 0; atask <= 1; atask++) {
            for (btask = 0; btask <= 1; btask++) {
               isuppera = atask == 0;
               isupperb = btask == 0;
            // Initialize A, B, AFull, BFull
               ae_vector_set_length(&t1, n);
               ae_matrix_set_length(&a, n, n);
               ae_matrix_set_length(&b, n, n);
               ae_matrix_set_length(&afull, n, n);
               ae_matrix_set_length(&bfull, n, n);
               ae_matrix_set_length(&l, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = randommid();
                     a.xyR[j][i] = a.xyR[i][j];
                     afull.xyR[i][j] = a.xyR[i][j];
                     afull.xyR[j][i] = a.xyR[i][j];
                  }
               }
               for (i = 0; i < n; i++) {
                  for (j = i + 1; j < n; j++) {
                     l.xyR[i][j] = randomreal();
                     l.xyR[j][i] = l.xyR[i][j];
                  }
                  l.xyR[i][i] = 1.5 + randomreal();
               }
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     minij = imin2(i, j);
                     v = ae_v_dotproduct(l.xyR[i], 1, &l.xyR[0][j], l.stride, minij + 1);
                     b.xyR[i][j] = v;
                     b.xyR[j][i] = v;
                     bfull.xyR[i][j] = v;
                     bfull.xyR[j][i] = v;
                  }
               }
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     if (isuppera) {
                        if (j < i) {
                           a.xyR[i][j] = randommid();
                        }
                     } else {
                        if (i < j) {
                           a.xyR[i][j] = randommid();
                        }
                     }
                     if (isupperb) {
                        if (j < i) {
                           b.xyR[i][j] = randommid();
                        }
                     } else {
                        if (i < j) {
                           b.xyR[i][j] = randommid();
                        }
                     }
                  }
               }
            // Problem 1
               if (!smatrixgevd(&a, n, isuppera, &b, isupperb, 1, 1, &d, &z)) {
                  convOk = false;
                  continue;
               }
               err = 0.0;
               for (j = 0; j < n; j++) {
                  for (i = 0; i < n; i++) {
                     v1 = ae_v_dotproduct(afull.xyR[i], 1, &z.xyR[0][j], z.stride, n);
                     v2 = ae_v_dotproduct(bfull.xyR[i], 1, &z.xyR[0][j], z.stride, n);
                     err = rmax2(err, fabs(v1 - d.xR[j] * v2));
                  }
               }
               valerr = rmax2(err, valerr);
            // Problem 2
               if (!smatrixgevd(&a, n, isuppera, &b, isupperb, 1, 2, &d, &z)) {
                  convOk = false;
                  continue;
               }
               err = 0.0;
               for (j = 0; j < n; j++) {
                  for (i = 0; i < n; i++) {
                     v1 = ae_v_dotproduct(bfull.xyR[i], 1, &z.xyR[0][j], z.stride, n);
                     t1.xR[i] = v1;
                  }
                  for (i = 0; i < n; i++) {
                     v2 = ae_v_dotproduct(afull.xyR[i], 1, t1.xR, 1, n);
                     err = rmax2(err, fabs(v2 - d.xR[j] * z.xyR[i][j]));
                  }
               }
               valerr = rmax2(err, valerr);
            // Test problem 3
               if (!smatrixgevd(&a, n, isuppera, &b, isupperb, 1, 3, &d, &z)) {
                  convOk = false;
                  continue;
               }
               err = 0.0;
               for (j = 0; j < n; j++) {
                  for (i = 0; i < n; i++) {
                     v1 = ae_v_dotproduct(afull.xyR[i], 1, &z.xyR[0][j], z.stride, n);
                     t1.xR[i] = v1;
                  }
                  for (i = 0; i < n; i++) {
                     v2 = ae_v_dotproduct(bfull.xyR[i], 1, t1.xR, 1, n);
                     err = rmax2(err, fabs(v2 - d.xR[j] * z.xyR[i][j]));
                  }
               }
               valerr = rmax2(err, valerr);
            }
         }
      }
   }
// The final report.
   Ok = valerr <= threshold && convOk && sortOk;
   if (!Ok || !silent) {
      printf("Symmetric GEVD Tests\n");
      printf("Average LambdaV Error (Generalized):      %5.3e\n", valerr);
      printf("Eigenvalues Order:                        %s\n", sortOk? "Ok": "Failed");
      printf("Always converged:                         %s\n", convOk? "Yes": "No");
      printf("Threshold:                                %5.3e\n", threshold);
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === gammafunc testing unit ===
bool testgammafunc() {
   double threshold;
   double v;
   double s;
   bool Ok;
   bool gammaOk;
   bool lngammaOk;
   gammaOk = true;
   lngammaOk = true;
   Ok = true;
   threshold = 100.0 * machineepsilon;
//
   gammaOk = gammaOk && NearAtR(gammafunction(0.5), sqrt(pi), threshold);
   gammaOk = gammaOk && NearAtR(gammafunction(1.5), 0.5 * sqrt(pi), threshold);
   v = lngamma(0.5, &s);
   lngammaOk = lngammaOk && NearAtR(v, log(sqrt(pi)), threshold) && s == 1.0;
   v = lngamma(1.5, &s);
   lngammaOk = lngammaOk && NearAtR(v, log(0.5 * sqrt(pi)), threshold) && s == 1.0;
// The final report.
   Ok = gammaOk && lngammaOk;
   if (!Ok || !silent) {
      printf("Gamma Function Tests\n");
      printf("Gamma:                                    %s\n", gammaOk? "Ok": "Failed");
      printf("LN Gamma:                                 %s\n", lngammaOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
// end
   return Ok;
}

// === gq testing unit ===
// Maps:
//     0   =>  -0.9
//     1   =>  -0.5
//     2   =>  -0.1
//     3   =>   0.0
//     4   =>  +0.1
//     5   =>  +0.5
//     6   =>  +0.9
//     7   =>  +1.0
//     8   =>  +1.5
//     9   =>  +2.0
static double testgqunit_mapkind(ae_int_t k) {
   double result;
   result = 0.0;
   if (k == 0) {
      result = -0.9;
   }
   if (k == 1) {
      result = -0.5;
   }
   if (k == 2) {
      result = -0.1;
   }
   if (k == 3) {
      result = 0.0;
   }
   if (k == 4) {
      result = 0.1;
   }
   if (k == 5) {
      result = 0.5;
   }
   if (k == 6) {
      result = 0.9;
   }
   if (k == 7) {
      result = 1.0;
   }
   if (k == 8) {
      result = 1.5;
   }
   if (k == 9) {
      result = 2.0;
   }
   return result;
}

// Gauss-Legendre, another variant
static void testgqunit_buildgausslegendrequadrature(ae_int_t n, RVector *x, RVector *w) {
   ae_int_t i;
   ae_int_t j;
   double r;
   double r1;
   double p1;
   double p2;
   double p3;
   double dp3;
   SetVector(x);
   SetVector(w);
   ae_vector_set_length(x, n);
   ae_vector_set_length(w, n);
   for (i = 0; i < (n + 1) / 2; i++) {
      r = cos(pi * (4 * i + 3) / (4 * n + 2));
      do {
         p2 = 0.0;
         p3 = 1.0;
         for (j = 0; j < n; j++) {
            p1 = p2;
            p2 = p3;
            p3 = ((2 * j + 1) * r * p2 - j * p1) / (j + 1);
         }
         dp3 = n * (r * p3 - p2) / (r * r - 1);
         r1 = r;
         r -= p3 / dp3;
      } while (!NearR(r, r1, machineepsilon * (1 + fabs(r)) * 100));
      x->xR[i] = r;
      x->xR[n - 1 - i] = -r;
      w->xR[i] = 2 / ((1 - r * r) * dp3 * dp3);
      w->xR[n - 1 - i] = 2 / ((1 - r * r) * dp3 * dp3);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n - 1 - i; j++) {
         if (x->xR[j] >= x->xR[j + 1]) {
            swapr(&x->xR[j], &x->xR[j + 1]);
            swapr(&w->xR[j], &w->xR[j + 1]);
         }
      }
   }
}

// Gauss-Jacobi, another variant
static void testgqunit_buildgaussjacobiquadrature(ae_int_t n, double alpha, double beta, RVector *x, RVector *w) {
   ae_int_t i;
   ae_int_t j;
   double r;
   double r1;
   double t1;
   double t2;
   double t3;
   double p1;
   double p2;
   double p3;
   double pp;
   double an;
   double bn;
   double a;
   double b;
   double c;
   double tmpsgn;
   double alfbet;
   double temp;
   SetVector(x);
   SetVector(w);
   ae_vector_set_length(x, n);
   ae_vector_set_length(w, n);
   r = 0.0;
   for (i = 0; i < n; i++) {
      if (i == 0) {
         an = alpha / n;
         bn = beta / n;
         t1 = (1 + alpha) * (2.78 / (4 + n * n) + 0.768 * an / n);
         t2 = 1 + 1.48 * an + 0.96 * bn + 0.452 * an * an + 0.83 * an * bn;
         r = (t2 - t1) / t2;
      } else {
         if (i == 1) {
            t1 = (4.1 + alpha) / ((1 + alpha) * (1 + 0.156 * alpha));
            t2 = 1 + 0.06 * (n - 8) * (1 + 0.12 * alpha) / n;
            t3 = 1 + 0.012 * beta * (1 + 0.25 * fabs(alpha)) / n;
            r -= t1 * t2 * t3 * (1 - r);
         } else {
            if (i == 2) {
               t1 = (1.67 + 0.28 * alpha) / (1 + 0.37 * alpha);
               t2 = 1 + 0.22 * (n - 8) / n;
               t3 = 1 + 8 * beta / ((6.28 + beta) * n * n);
               r -= t1 * t2 * t3 * (x->xR[0] - r);
            } else {
               if (i < n - 2) {
                  r = 3 * x->xR[i - 1] - 3 * x->xR[i - 2] + x->xR[i - 3];
               } else {
                  if (i == n - 2) {
                     t1 = (1 + 0.235 * beta) / (0.766 + 0.119 * beta);
                     t2 = 1 / (1 + 0.639 * (n - 4) / (1 + 0.71 * (n - 4)));
                     t3 = 1 / (1 + 20 * alpha / ((7.5 + alpha) * n * n));
                     r += t1 * t2 * t3 * (r - x->xR[i - 2]);
                  } else {
                     if (i == n - 1) {
                        t1 = (1 + 0.37 * beta) / (1.67 + 0.28 * beta);
                        t2 = 1 / (1 + 0.22 * (n - 8) / n);
                        t3 = 1 / (1 + 8 * alpha / ((6.28 + alpha) * n * n));
                        r += t1 * t2 * t3 * (r - x->xR[i - 2]);
                     }
                  }
               }
            }
         }
      }
      alfbet = alpha + beta;
      do {
         temp = 2 + alfbet;
         p1 = (alpha - beta + temp * r) * 0.5;
         p2 = 1.0;
         for (j = 2; j <= n; j++) {
            p3 = p2;
            p2 = p1;
            temp = 2 * j + alfbet;
            a = 2 * j * (j + alfbet) * (temp - 2);
            b = (temp - 1) * (alpha * alpha - beta * beta + temp * (temp - 2) * r);
            c = 2 * (j - 1 + alpha) * (j - 1 + beta) * temp;
            p1 = (b * p2 - c * p3) / a;
         }
         pp = (n * (alpha - beta - temp * r) * p1 + 2 * (n + alpha) * (n + beta) * p2) / (temp * (1 - r * r));
         r1 = r;
         r = r1 - p1 / pp;
      } while (!NearR(r, r1, machineepsilon * (1 + fabs(r)) * 100));
      x->xR[i] = r;
      w->xR[i] = exp(lngamma(alpha + n, &tmpsgn) + lngamma(beta + n, &tmpsgn) - lngamma((double)(n + 1), &tmpsgn) - lngamma(n + alfbet + 1, &tmpsgn)) * temp * pow(2.0, alfbet) / (pp * p2);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n - 1 - i; j++) {
         if (x->xR[j] >= x->xR[j + 1]) {
            swapr(&x->xR[j], &x->xR[j + 1]);
            swapr(&w->xR[j], &w->xR[j + 1]);
         }
      }
   }
}

// Gauss-Laguerre, another variant
static void testgqunit_buildgausslaguerrequadrature(ae_int_t n, double alpha, RVector *x, RVector *w) {
   ae_int_t i;
   ae_int_t j;
   double r;
   double r1;
   double p1;
   double p2;
   double p3;
   double dp3;
   double tsg;
   SetVector(x);
   SetVector(w);
   ae_vector_set_length(x, n);
   ae_vector_set_length(w, n);
   r = 0.0;
   for (i = 0; i < n; i++) {
      if (i == 0) {
         r = (1 + alpha) * (3 + 0.92 * alpha) / (1 + 2.4 * n + 1.8 * alpha);
      } else {
         if (i == 1) {
            r += (15 + 6.25 * alpha) / (1 + 0.9 * alpha + 2.5 * n);
         } else {
            r += ((1 + 2.55 * (i - 1)) / (1.9 * (i - 1)) + 1.26 * (i - 1) * alpha / (1 + 3.5 * (i - 1))) / (1 + 0.3 * alpha) * (r - x->xR[i - 2]);
         }
      }
      do {
         p2 = 0.0;
         p3 = 1.0;
         for (j = 0; j < n; j++) {
            p1 = p2;
            p2 = p3;
            p3 = ((-r + 2 * j + alpha + 1) * p2 - (j + alpha) * p1) / (j + 1);
         }
         dp3 = (n * p3 - (n + alpha) * p2) / r;
         r1 = r;
         r -= p3 / dp3;
      } while (!NearR(r, r1, machineepsilon * (1 + fabs(r)) * 100));
      x->xR[i] = r;
      w->xR[i] = -exp(lngamma(alpha + n, &tsg) - lngamma((double)n, &tsg)) / (dp3 * n * p2);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n - 1 - i; j++) {
         if (x->xR[j] >= x->xR[j + 1]) {
            swapr(&x->xR[j], &x->xR[j + 1]);
            swapr(&w->xR[j], &w->xR[j + 1]);
         }
      }
   }
}

// Gauss-Hermite, another variant
static void testgqunit_buildgausshermitequadrature(ae_int_t n, RVector *x, RVector *w) {
   ae_int_t i;
   ae_int_t j;
   double r;
   double r1;
   double p1;
   double p2;
   double p3;
   double dp3;
   double pipm4;
   SetVector(x);
   SetVector(w);
   ae_vector_set_length(x, n);
   ae_vector_set_length(w, n);
   pipm4 = pow(pi, -0.25);
   r = 0.0;
   for (i = 0; i < (n + 1) / 2; i++) {
      if (i == 0) {
         r = sqrt(2 * n + 1) - 1.85575 * pow((double)(2 * n + 1), -1.0 / 6.0);
      } else {
         if (i == 1) {
            r -= 1.14 * pow((double)n, 0.426) / r;
         } else {
            if (i == 2) {
               r = 1.86 * r - 0.86 * x->xR[0];
            } else {
               if (i == 3) {
                  r = 1.91 * r - 0.91 * x->xR[1];
               } else {
                  r = 2 * r - x->xR[i - 2];
               }
            }
         }
      }
      do {
         p2 = 0.0;
         p3 = pipm4;
         for (j = 0; j < n; j++) {
            p1 = p2;
            p2 = p3;
            p3 = p2 * r * sqrt(2.0 / (j + 1)) - p1 * sqrt((double)j / (j + 1));
         }
         dp3 = sqrt(2 * j) * p2;
         r1 = r;
         r -= p3 / dp3;
      } while (!NearR(r, r1, machineepsilon * (1 + fabs(r)) * 100));
      x->xR[i] = r;
      w->xR[i] = 2 / (dp3 * dp3);
      x->xR[n - 1 - i] = -x->xR[i];
      w->xR[n - 1 - i] = w->xR[i];
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n - 1 - i; j++) {
         if (x->xR[j] >= x->xR[j + 1]) {
            swapr(&x->xR[j], &x->xR[j + 1]);
            swapr(&w->xR[j], &w->xR[j + 1]);
         }
      }
   }
}

// Test
bool testgq() {
   ae_frame _frame_block;
   double err;
   ae_int_t n;
   ae_int_t i;
   ae_int_t info;
   ae_int_t akind;
   ae_int_t bkind;
   double alphac;
   double betac;
   double errtol;
   double nonstricterrtol;
   double stricterrtol;
   bool recOk;
   bool specOk;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(alpha, 0, DT_REAL);
   NewVector(beta, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   recOk = true;
   specOk = true;
   Ok = true;
   errtol = 1.0E-12;
   nonstricterrtol = 1.0E-6;
   stricterrtol = 1000.0 * machineepsilon;
// Three tests for rec-based Gauss quadratures with known weights/nodes:
// 1. Gauss-Legendre with N == 2
// 2. Gauss-Legendre with N == 5
// 3. Gauss-Chebyshev with N == 1, 2, 4, 8, ..., 512
   err = 0.0;
   ae_vector_set_length(&alpha, 2);
   ae_vector_set_length(&beta, 2);
   alpha.xR[0] = 0.0;
   alpha.xR[1] = 0.0;
   beta.xR[1] = 1.0 / (4 * 1 * 1 - 1);
   gqgeneraterec(&alpha, &beta, 2.0, 2, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[0] + sqrt(3.0) / 3));
      err = rmax2(err, fabs(x.xR[1] - sqrt(3.0) / 3));
      err = rmax2(err, fabs(w.xR[0] - 1));
      err = rmax2(err, fabs(w.xR[1] - 1));
      for (i = 0; i <= 0; i++) {
         recOk = recOk && x.xR[i] < x.xR[i + 1];
      }
   } else {
      recOk = false;
   }
   ae_vector_set_length(&alpha, 5);
   ae_vector_set_length(&beta, 5);
   alpha.xR[0] = 0.0;
   for (i = 1; i <= 4; i++) {
      alpha.xR[i] = 0.0;
      beta.xR[i] = sqr(i) / (4 * sqr(i) - 1);
   }
   gqgeneraterec(&alpha, &beta, 2.0, 5, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[0] + sqrt(245 + 14 * sqrt(70.0)) / 21));
      err = rmax2(err, fabs(x.xR[0] + x.xR[4]));
      err = rmax2(err, fabs(x.xR[1] + sqrt(245 - 14 * sqrt(70.0)) / 21));
      err = rmax2(err, fabs(x.xR[1] + x.xR[3]));
      err = rmax2(err, fabs(x.xR[2]));
      err = rmax2(err, fabs(w.xR[0] - (322 - 13 * sqrt(70.0)) / 900));
      err = rmax2(err, fabs(w.xR[0] - w.xR[4]));
      err = rmax2(err, fabs(w.xR[1] - (322 + 13 * sqrt(70.0)) / 900));
      err = rmax2(err, fabs(w.xR[1] - w.xR[3]));
      err = rmax2(err, fabs(w.xR[2] - 128.0 / 225.0));
      for (i = 0; i <= 3; i++) {
         recOk = recOk && x.xR[i] < x.xR[i + 1];
      }
   } else {
      recOk = false;
   }
   n = 1;
   while (n <= 512) {
      ae_vector_set_length(&alpha, n);
      ae_vector_set_length(&beta, n);
      for (i = 0; i < n; i++) {
         alpha.xR[i] = 0.0;
         if (i == 0) {
            beta.xR[i] = 0.0;
         }
         if (i == 1) {
            beta.xR[i] = 1.0 / 2.0;
         }
         if (i > 1) {
            beta.xR[i] = 1.0 / 4.0;
         }
      }
      gqgeneraterec(&alpha, &beta, pi, n, &info, &x, &w);
      if (info > 0) {
         for (i = 0; i < n; i++) {
            err = rmax2(err, fabs(x.xR[i] - cos(pi * (n - i - 0.5) / n)));
            err = rmax2(err, fabs(w.xR[i] - pi / n));
         }
         for (i = 0; i < n - 1; i++) {
            recOk = recOk && x.xR[i] < x.xR[i + 1];
         }
      } else {
         recOk = false;
      }
      n *= 2;
   }
   recOk = recOk && err <= errtol;
// Three tests for rec-based Gauss-Lobatto quadratures with known weights/nodes:
// 1. Gauss-Lobatto with N == 3
// 2. Gauss-Lobatto with N == 4
// 3. Gauss-Lobatto with N == 6
   err = 0.0;
   ae_vector_set_length(&alpha, 2);
   ae_vector_set_length(&beta, 2);
   alpha.xR[0] = 0.0;
   alpha.xR[1] = 0.0;
   beta.xR[0] = 0.0;
   beta.xR[1] = (double)(1 * 1) / (4 * 1 * 1 - 1);
   gqgenerategausslobattorec(&alpha, &beta, 2.0, -1.0, 1.0, 3, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[0] + 1));
      err = rmax2(err, fabs(x.xR[1]));
      err = rmax2(err, fabs(x.xR[2] - 1));
      err = rmax2(err, fabs(w.xR[0] - 1.0 / 3.0));
      err = rmax2(err, fabs(w.xR[1] - 4.0 / 3.0));
      err = rmax2(err, fabs(w.xR[2] - 1.0 / 3.0));
      for (i = 0; i <= 1; i++) {
         recOk = recOk && x.xR[i] < x.xR[i + 1];
      }
   } else {
      recOk = false;
   }
   ae_vector_set_length(&alpha, 3);
   ae_vector_set_length(&beta, 3);
   alpha.xR[0] = 0.0;
   alpha.xR[1] = 0.0;
   alpha.xR[2] = 0.0;
   beta.xR[0] = 0.0;
   beta.xR[1] = (double)(1 * 1) / (4 * 1 * 1 - 1);
   beta.xR[2] = (double)(2 * 2) / (4 * 2 * 2 - 1);
   gqgenerategausslobattorec(&alpha, &beta, 2.0, -1.0, 1.0, 4, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[0] + 1));
      err = rmax2(err, fabs(x.xR[1] + sqrt(5.0) / 5));
      err = rmax2(err, fabs(x.xR[2] - sqrt(5.0) / 5));
      err = rmax2(err, fabs(x.xR[3] - 1));
      err = rmax2(err, fabs(w.xR[0] - 1.0 / 6.0));
      err = rmax2(err, fabs(w.xR[1] - 5.0 / 6.0));
      err = rmax2(err, fabs(w.xR[2] - 5.0 / 6.0));
      err = rmax2(err, fabs(w.xR[3] - 1.0 / 6.0));
      for (i = 0; i <= 2; i++) {
         recOk = recOk && x.xR[i] < x.xR[i + 1];
      }
   } else {
      recOk = false;
   }
   ae_vector_set_length(&alpha, 5);
   ae_vector_set_length(&beta, 5);
   alpha.xR[0] = 0.0;
   alpha.xR[1] = 0.0;
   alpha.xR[2] = 0.0;
   alpha.xR[3] = 0.0;
   alpha.xR[4] = 0.0;
   beta.xR[0] = 0.0;
   beta.xR[1] = (double)(1 * 1) / (4 * 1 * 1 - 1);
   beta.xR[2] = (double)(2 * 2) / (4 * 2 * 2 - 1);
   beta.xR[3] = (double)(3 * 3) / (4 * 3 * 3 - 1);
   beta.xR[4] = (double)(4 * 4) / (4 * 4 * 4 - 1);
   gqgenerategausslobattorec(&alpha, &beta, 2.0, -1.0, 1.0, 6, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[0] + 1));
      err = rmax2(err, fabs(x.xR[1] + sqrt((7 + 2 * sqrt(7.0)) / 21)));
      err = rmax2(err, fabs(x.xR[2] + sqrt((7 - 2 * sqrt(7.0)) / 21)));
      err = rmax2(err, fabs(x.xR[3] - sqrt((7 - 2 * sqrt(7.0)) / 21)));
      err = rmax2(err, fabs(x.xR[4] - sqrt((7 + 2 * sqrt(7.0)) / 21)));
      err = rmax2(err, fabs(x.xR[5] - 1));
      err = rmax2(err, fabs(w.xR[0] - 1.0 / 15.0));
      err = rmax2(err, fabs(w.xR[1] - (14 - sqrt(7.0)) / 30));
      err = rmax2(err, fabs(w.xR[2] - (14 + sqrt(7.0)) / 30));
      err = rmax2(err, fabs(w.xR[3] - (14 + sqrt(7.0)) / 30));
      err = rmax2(err, fabs(w.xR[4] - (14 - sqrt(7.0)) / 30));
      err = rmax2(err, fabs(w.xR[5] - 1.0 / 15.0));
      for (i = 0; i <= 4; i++) {
         recOk = recOk && x.xR[i] < x.xR[i + 1];
      }
   } else {
      recOk = false;
   }
   recOk = recOk && err <= errtol;
// Three tests for rec-based Gauss-Radau quadratures with known weights/nodes:
// 1. Gauss-Radau with N == 2
// 2. Gauss-Radau with N == 3
// 3. Gauss-Radau with N == 3 (another case)
   err = 0.0;
   ae_vector_set_length(&alpha, 1);
   ae_vector_set_length(&beta, 2);
   alpha.xR[0] = 0.0;
   beta.xR[0] = 0.0;
   beta.xR[1] = (double)(1 * 1) / (4 * 1 * 1 - 1);
   gqgenerategaussradaurec(&alpha, &beta, 2.0, -1.0, 2, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[0] + 1));
      err = rmax2(err, fabs(x.xR[1] - 1.0 / 3.0));
      err = rmax2(err, fabs(w.xR[0] - 0.5));
      err = rmax2(err, fabs(w.xR[1] - 1.5));
      for (i = 0; i <= 0; i++) {
         recOk = recOk && x.xR[i] < x.xR[i + 1];
      }
   } else {
      recOk = false;
   }
   ae_vector_set_length(&alpha, 2);
   ae_vector_set_length(&beta, 3);
   alpha.xR[0] = 0.0;
   alpha.xR[1] = 0.0;
   for (i = 0; i <= 2; i++) {
      beta.xR[i] = sqr(i) / (4 * sqr(i) - 1);
   }
   gqgenerategaussradaurec(&alpha, &beta, 2.0, -1.0, 3, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[0] + 1));
      err = rmax2(err, fabs(x.xR[1] - (1 - sqrt(6.0)) / 5));
      err = rmax2(err, fabs(x.xR[2] - (1 + sqrt(6.0)) / 5));
      err = rmax2(err, fabs(w.xR[0] - 2.0 / 9.0));
      err = rmax2(err, fabs(w.xR[1] - (16 + sqrt(6.0)) / 18));
      err = rmax2(err, fabs(w.xR[2] - (16 - sqrt(6.0)) / 18));
      for (i = 0; i <= 1; i++) {
         recOk = recOk && x.xR[i] < x.xR[i + 1];
      }
   } else {
      recOk = false;
   }
   ae_vector_set_length(&alpha, 2);
   ae_vector_set_length(&beta, 3);
   alpha.xR[0] = 0.0;
   alpha.xR[1] = 0.0;
   for (i = 0; i <= 2; i++) {
      beta.xR[i] = sqr(i) / (4 * sqr(i) - 1);
   }
   gqgenerategaussradaurec(&alpha, &beta, 2.0, 1.0, 3, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[2] - 1));
      err = rmax2(err, fabs(x.xR[1] + (1 - sqrt(6.0)) / 5));
      err = rmax2(err, fabs(x.xR[0] + (1 + sqrt(6.0)) / 5));
      err = rmax2(err, fabs(w.xR[2] - 2.0 / 9.0));
      err = rmax2(err, fabs(w.xR[1] - (16 + sqrt(6.0)) / 18));
      err = rmax2(err, fabs(w.xR[0] - (16 - sqrt(6.0)) / 18));
      for (i = 0; i <= 1; i++) {
         recOk = recOk && x.xR[i] < x.xR[i + 1];
      }
   } else {
      recOk = false;
   }
   recOk = recOk && err <= errtol;
// test recurrence-based special cases (Legendre, Jacobi, Hermite, ...)
// against another implementation (polynomial root-finder)
   for (n = 1; n <= 20; n++) {
   // test gauss-legendre
      err = 0.0;
      gqgenerategausslegendre(n, &info, &x, &w);
      if (info > 0) {
         testgqunit_buildgausslegendrequadrature(n, &x2, &w2);
         for (i = 0; i < n; i++) {
            err = rmax2(err, fabs(x.xR[i] - x2.xR[i]));
            err = rmax2(err, fabs(w.xR[i] - w2.xR[i]));
         }
      } else {
         specOk = false;
      }
      specOk = specOk && err <= errtol;
   // Test Gauss-Jacobi.
   // Since task is much more difficult we will use less strict
   // threshold.
      err = 0.0;
      for (akind = 0; akind <= 9; akind++) {
         for (bkind = 0; bkind <= 9; bkind++) {
            alphac = testgqunit_mapkind(akind);
            betac = testgqunit_mapkind(bkind);
            gqgenerategaussjacobi(n, alphac, betac, &info, &x, &w);
            if (info > 0) {
               testgqunit_buildgaussjacobiquadrature(n, alphac, betac, &x2, &w2);
               for (i = 0; i < n; i++) {
                  err = rmax2(err, fabs(x.xR[i] - x2.xR[i]));
                  err = rmax2(err, fabs(w.xR[i] - w2.xR[i]));
               }
            } else {
               specOk = false;
            }
         }
      }
      specOk = specOk && err <= nonstricterrtol;
   // special test for Gauss-Jacobi (Chebyshev weight
   // function with analytically known nodes/weights)
      err = 0.0;
      gqgenerategaussjacobi(n, -0.5, -0.5, &info, &x, &w);
      if (info > 0) {
         for (i = 0; i < n; i++) {
            err = rmax2(err, fabs(x.xR[i] + cos(pi * (i + 0.5) / n)));
            err = rmax2(err, fabs(w.xR[i] - pi / n));
         }
      } else {
         specOk = false;
      }
      specOk = specOk && err <= stricterrtol;
   // Test Gauss-Laguerre
      err = 0.0;
      for (akind = 0; akind <= 9; akind++) {
         alphac = testgqunit_mapkind(akind);
         gqgenerategausslaguerre(n, alphac, &info, &x, &w);
         if (info > 0) {
            testgqunit_buildgausslaguerrequadrature(n, alphac, &x2, &w2);
            for (i = 0; i < n; i++) {
               err = rmax2(err, fabs(x.xR[i] - x2.xR[i]));
               err = rmax2(err, fabs(w.xR[i] - w2.xR[i]));
            }
         } else {
            specOk = false;
         }
      }
      specOk = specOk && err <= nonstricterrtol;
   // Test Gauss-Hermite
      err = 0.0;
      gqgenerategausshermite(n, &info, &x, &w);
      if (info > 0) {
         testgqunit_buildgausshermitequadrature(n, &x2, &w2);
         for (i = 0; i < n; i++) {
            err = rmax2(err, fabs(x.xR[i] - x2.xR[i]));
            err = rmax2(err, fabs(w.xR[i] - w2.xR[i]));
         }
      } else {
         specOk = false;
      }
      specOk = specOk && err <= nonstricterrtol;
   }
// The final report.
   Ok = recOk && specOk;
   if (!Ok || !silent) {
      printf("Gauss Quadrature Tests\n");
      printf("* Special Cases (Legendre/Jacobi/..):     %s\n", specOk? "Ok": "Failed");
      printf("* Recurrence-Based:                       %s\n", recOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === gkq testing unit ===
// Maps:
//     0   =>  -0.9
//     1   =>  -0.5
//     2   =>  -0.1
//     3   =>   0.0
//     4   =>  +0.1
//     5   =>  +0.5
//     6   =>  +0.9
//     7   =>  +1.0
//     8   =>  +1.5
//     9   =>  +2.0
static double testgkqunit_mapkind(ae_int_t k) {
   double result;
   result = 0.0;
   if (k == 0) {
      result = -0.9;
   }
   if (k == 1) {
      result = -0.5;
   }
   if (k == 2) {
      result = -0.1;
   }
   if (k == 3) {
      result = 0.0;
   }
   if (k == 4) {
      result = 0.1;
   }
   if (k == 5) {
      result = 0.5;
   }
   if (k == 6) {
      result = 0.9;
   }
   if (k == 7) {
      result = 1.0;
   }
   if (k == 8) {
      result = 1.5;
   }
   if (k == 9) {
      result = 2.0;
   }
   return result;
}

// Test
bool testgkq() {
   ae_frame _frame_block;
   ae_int_t pkind;
   double errtol;
   double eps;
   ae_int_t n;
   ae_int_t i;
   ae_int_t k;
   ae_int_t info;
   double err;
   ae_int_t akind;
   ae_int_t bkind;
   double alphac;
   double betac;
   ae_int_t info1;
   ae_int_t info2;
   bool successatleastonce;
   bool intblOk;
   bool vstblOk;
   bool genOk;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(x1, 0, DT_REAL);
   NewVector(wg1, 0, DT_REAL);
   NewVector(wk1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(wg2, 0, DT_REAL);
   NewVector(wk2, 0, DT_REAL);
   intblOk = true;
   vstblOk = true;
   genOk = true;
   Ok = true;
   errtol = 10000.0 * machineepsilon;
// test recurrence-based Legendre nodes against the precalculated table
   for (pkind = 0; pkind <= 5; pkind++) {
      n = 0;
      if (pkind == 0) {
         n = 15;
      }
      if (pkind == 1) {
         n = 21;
      }
      if (pkind == 2) {
         n = 31;
      }
      if (pkind == 3) {
         n = 41;
      }
      if (pkind == 4) {
         n = 51;
      }
      if (pkind == 5) {
         n = 61;
      }
      gkqlegendrecalc(n, &info, &x1, &wk1, &wg1);
      gkqlegendretbl(n, &x2, &wk2, &wg2, &eps);
      if (info <= 0) {
         genOk = false;
         break;
      }
      for (i = 0; i < n; i++) {
         vstblOk = vstblOk && NearAtR(x1.xR[i], x2.xR[i], errtol);
         vstblOk = vstblOk && NearAtR(wk1.xR[i], wk2.xR[i], errtol);
         vstblOk = vstblOk && NearAtR(wg1.xR[i], wg2.xR[i], errtol);
      }
   }
// Test recurrence-baced Gauss-Kronrod nodes against Gauss-only nodes
// calculated with subroutines from GQ unit.
   for (k = 1; k <= 30; k++) {
      n = 2 * k + 1;
   // Gauss-Legendre
      err = 0.0;
      gkqgenerategausslegendre(n, &info1, &x1, &wk1, &wg1);
      gqgenerategausslegendre(k, &info2, &x2, &wg2);
      if (info1 > 0 && info2 > 0) {
         for (i = 0; i < k; i++) {
            err = rmax2(err, fabs(x1.xR[2 * i + 1] - x2.xR[i]));
            err = rmax2(err, fabs(wg1.xR[2 * i + 1] - wg2.xR[i]));
         }
      } else {
         genOk = false;
      }
      genOk = genOk && err <= errtol;
   }
   for (k = 1; k <= 15; k++) {
      n = 2 * k + 1;
   // Gauss-Jacobi
      successatleastonce = false;
      err = 0.0;
      for (akind = 0; akind <= 9; akind++) {
         for (bkind = 0; bkind <= 9; bkind++) {
            alphac = testgkqunit_mapkind(akind);
            betac = testgkqunit_mapkind(bkind);
            gkqgenerategaussjacobi(n, alphac, betac, &info1, &x1, &wk1, &wg1);
            gqgenerategaussjacobi(k, alphac, betac, &info2, &x2, &wg2);
            if (info1 > 0 && info2 > 0) {
               successatleastonce = true;
               for (i = 0; i < k; i++) {
                  err = rmax2(err, fabs(x1.xR[2 * i + 1] - x2.xR[i]));
                  err = rmax2(err, fabs(wg1.xR[2 * i + 1] - wg2.xR[i]));
               }
            } else {
               genOk = genOk && info1 == -5;
            }
         }
      }
      genOk = genOk && err <= errtol && successatleastonce;
   }
// The final report.
   Ok = intblOk && vstblOk && genOk;
   if (!Ok || !silent) {
      printf("Gauss-Kronrod Quadrature Tests\n");
      printf("* Pre-Calculated Table:                   %s\n", intblOk? "Ok": "Failed");
      printf("* Calculated Against The Table:           %s\n", vstblOk? "Ok": "Failed");
      printf("* General Properties:                     %s\n", genOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === autogk testing unit ===
// Test
bool testautogk() {
   ae_frame _frame_block;
   double a;
   double b;
   double v;
   double exact;
   double eabs;
   double alpha;
   ae_int_t pkind;
   double errtol;
   bool simpleOk;
   bool sngendOk;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(autogkstate, state);
   NewObj(autogkreport, rep);
   simpleOk = true;
   sngendOk = true;
   Ok = true;
   errtol = 10000.0 * machineepsilon;
// Simple test: integral(exp(x),+-1,+-2), no maximum width requirements
   a = (2 * randominteger(2) - 1) * 1.0;
   b = (2 * randominteger(2) - 1) * 2.0;
   for (autogksmooth(a, b, &state); autogkiteration(&state); ) {
      state.f = exp(state.x);
   }
   autogkresults(&state, &v, &rep);
   exact = exp(b) - exp(a);
   eabs = fabs(exp(b) - exp(a));
   if (rep.terminationtype <= 0) {
      simpleOk = false;
   } else {
      simpleOk = simpleOk && NearAtR(exact, v, errtol * eabs);
   }
// Simple test: integral(exp(x),+-1,+-2), XWidth == 0.1
   a = (2 * randominteger(2) - 1) * 1.0;
   b = (2 * randominteger(2) - 1) * 2.0;
   for (autogksmoothw(a, b, 0.1, &state); autogkiteration(&state); ) {
      state.f = exp(state.x);
   }
   autogkresults(&state, &v, &rep);
   exact = exp(b) - exp(a);
   eabs = fabs(exp(b) - exp(a));
   if (rep.terminationtype <= 0) {
      simpleOk = false;
   } else {
      simpleOk = simpleOk && NearAtR(exact, v, errtol * eabs);
   }
// Simple test: integral(cos(100*x),0,2*pi), no maximum width requirements
   a = 0.0;
   b = 2 * pi;
   for (autogksmooth(a, b, &state); autogkiteration(&state); ) {
      state.f = cos(100 * state.x);
   }
   autogkresults(&state, &v, &rep);
   exact = 0.0;
   eabs = 4.0;
   if (rep.terminationtype <= 0) {
      simpleOk = false;
   } else {
      simpleOk = simpleOk && NearAtR(exact, v, errtol * eabs);
   }
// Simple test: integral(cos(100*x),0,2*pi), XWidth == 0.3
   a = 0.0;
   b = 2 * pi;
   for (autogksmoothw(a, b, 0.3, &state); autogkiteration(&state); ) {
      state.f = cos(100 * state.x);
   }
   autogkresults(&state, &v, &rep);
   exact = 0.0;
   eabs = 4.0;
   if (rep.terminationtype <= 0) {
      simpleOk = false;
   } else {
      simpleOk = simpleOk && NearAtR(exact, v, errtol * eabs);
   }
// singular problem on [a,b] = [0.1, 0.5]
//     f2(x) = (1+x)*(b-x)^alpha, -1 < alpha < 1
   for (pkind = 0; pkind <= 6; pkind++) {
      a = 0.1;
      b = 0.5;
      alpha = 0.0;
      if (pkind == 0) {
         alpha = -0.9;
      }
      if (pkind == 1) {
         alpha = -0.5;
      }
      if (pkind == 2) {
         alpha = -0.1;
      }
      if (pkind == 3) {
         alpha = 0.0;
      }
      if (pkind == 4) {
         alpha = 0.1;
      }
      if (pkind == 5) {
         alpha = 0.5;
      }
      if (pkind == 6) {
         alpha = 0.9;
      }
   // f1(x) = (1+x)*(x-a)^alpha, -1 < alpha < 1
   // 1. use singular integrator for [a,b]
   // 2. use singular integrator for [b,a]
      exact = pow(b - a, alpha + 2) / (alpha + 2) + (1 + a) * pow(b - a, alpha + 1) / (alpha + 1);
      eabs = fabs(exact);
      for (autogksingular(a, b, alpha, 0.0, &state); autogkiteration(&state); ) {
         if (state.xminusa < 0.01) {
            state.f = pow(state.xminusa, alpha) * (1 + state.x);
         } else {
            state.f = pow(state.x - a, alpha) * (1 + state.x);
         }
      }
      autogkresults(&state, &v, &rep);
      if (rep.terminationtype <= 0) {
         sngendOk = false;
      } else {
         sngendOk = sngendOk && NearAtR(v, exact, errtol * eabs);
      }
      for (autogksingular(b, a, 0.0, alpha, &state); autogkiteration(&state); ) {
         if (state.bminusx > -0.01) {
            state.f = pow(-state.bminusx, alpha) * (1 + state.x);
         } else {
            state.f = pow(state.x - a, alpha) * (1 + state.x);
         }
      }
      autogkresults(&state, &v, &rep);
      if (rep.terminationtype <= 0) {
         sngendOk = false;
      } else {
         sngendOk = sngendOk && NearAtR(-v, exact, errtol * eabs);
      }
   // f1(x) = (1+x)*(b-x)^alpha, -1 < alpha < 1
   // 1. use singular integrator for [a,b]
   // 2. use singular integrator for [b,a]
      exact = (1 + b) * pow(b - a, alpha + 1) / (alpha + 1) - pow(b - a, alpha + 2) / (alpha + 2);
      eabs = fabs(exact);
      for (autogksingular(a, b, 0.0, alpha, &state); autogkiteration(&state); ) {
         if (state.bminusx < 0.01) {
            state.f = pow(state.bminusx, alpha) * (1 + state.x);
         } else {
            state.f = pow(b - state.x, alpha) * (1 + state.x);
         }
      }
      autogkresults(&state, &v, &rep);
      if (rep.terminationtype <= 0) {
         sngendOk = false;
      } else {
         sngendOk = sngendOk && NearAtR(v, exact, errtol * eabs);
      }
      for (autogksingular(b, a, alpha, 0.0, &state); autogkiteration(&state); ) {
         if (state.xminusa > -0.01) {
            state.f = pow(-state.xminusa, alpha) * (1 + state.x);
         } else {
            state.f = pow(b - state.x, alpha) * (1 + state.x);
         }
      }
      autogkresults(&state, &v, &rep);
      if (rep.terminationtype <= 0) {
         sngendOk = false;
      } else {
         sngendOk = sngendOk && NearAtR(-v, exact, errtol * eabs);
      }
   }
// The final report.
   Ok = simpleOk && sngendOk;
   if (!Ok || !silent) {
      printf("Auto GK Tests\n");
      printf("Integration With Given Accuracy:\n");
      printf("* Simple Problems:                        %s\n", simpleOk? "Ok": "Failed");
      printf("* Singular Problems (Ends Of Interval):   %s\n", sngendOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === normaldistr testing unit ===
// Normal test
// ALGLIB: Copyright 15.11.2019 by Sergey Bochkanov
static bool testnormaldistrunit_testnormal() {
   ae_frame _frame_block;
   double v0;
   double v1;
   double x;
   double h;
   ae_int_t k;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Test that PDF is roughly equal to derivative of CDF
   for (k = 0; k < 1000; k++) {
      x = hqrndnormal(&rs);
      h = 1.0E-5;
      v0 = normalpdf(x);
      v1 = (normalcdf(x + h) - normalcdf(x - h)) / (2 * h);
      Ok = Ok && NearAtR(v0, v1, 1.0E-4);
   }
   ae_frame_leave();
   return Ok;
}

// Bivariate normal test
// ALGLIB: Copyright 15.11.2019 by Sergey Bochkanov
static bool testnormaldistrunit_testbvn() {
   ae_frame _frame_block;
   double v0;
   double v1;
   double err;
   double x;
   double y;
   double rho;
   double h;
   ae_int_t k;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Test bivariate normal CDF values (small Rho and hard Rho)
   err = 0.0;
   err = rmax2(err, fabs(0.142221121370770000 - bivariatenormalcdf(-1.060937077356340000, 1.523763953950230000, 0.344134938671007000)));
   err = rmax2(err, fabs(0.001090824383322160 - bivariatenormalcdf(-3.034280037001620000, 0.633583566571867000, 0.196737644948391000)));
   err = rmax2(err, fabs(0.000063428666799461 - bivariatenormalcdf(-3.577198111015300000, -2.584892928002350000, 0.603284544092224000)));
   err = rmax2(err, fabs(0.000000019144648137 - bivariatenormalcdf(-1.053171728048290000, -2.987017621703680000, -0.659498170394145000)));
   err = rmax2(err, fabs(0.972551066792029000 - bivariatenormalcdf(4.785178416287600000, 1.919693671247900000, 0.261346800934746000)));
   err = rmax2(err, fabs(0.000000608605272790 - bivariatenormalcdf(-4.852815283224590000, 2.398320119295830000, 0.662485812586403000)));
   err = rmax2(err, fabs(0.576135824931800000 - bivariatenormalcdf(0.192020298597275000, 4.695461487450740000, -0.110028699320946000)));
   err = rmax2(err, fabs(0.876357061322732000 - bivariatenormalcdf(2.095780141251770000, 1.211768206209080000, 0.397007061864995000)));
   err = rmax2(err, fabs(0.002969212104812400 - bivariatenormalcdf(-2.654007687508430000, 1.340051767837440000, -0.233916559318503000)));
   err = rmax2(err, fabs(0.000377048151161364 - bivariatenormalcdf(1.128363097510700000, -2.781006578069910000, -0.642877478801918000)));
   err = rmax2(err, fabs(0.995657061734790000 - bivariatenormalcdf(3.966506850977000000, 2.626841258388710000, 0.291409185863929000)));
   err = rmax2(err, fabs(0.003282876365551870 - bivariatenormalcdf(-2.717530641700190000, 3.217920162027340000, -0.101773464540366000)));
   err = rmax2(err, fabs(0.002099371685469470 - bivariatenormalcdf(-1.811681729272450000, -2.262911120125770000, 0.361735313431128000)));
   err = rmax2(err, fabs(0.648944114852307000 - bivariatenormalcdf(1.861468373436860000, 0.432740073549983000, 0.092845182466246300)));
   err = rmax2(err, fabs(0.000000000094851728 - bivariatenormalcdf(-4.898527851968480000, -3.491204153631050000, -0.010492822687090300)));
   err = rmax2(err, fabs(0.000416778593465223 - bivariatenormalcdf(-3.341356669094100000, 1.862802982022170000, 0.398642687655347000)));
   err = rmax2(err, fabs(0.741640376816388000 - bivariatenormalcdf(4.687494092358740000, 0.648415139929991000, -0.692925257444683000)));
   err = rmax2(err, fabs(0.868844042717264000 - bivariatenormalcdf(2.369093655782270000, 1.148153167494120000, 0.297877516862745000)));
   err = rmax2(err, fabs(0.999356215351682000 - bivariatenormalcdf(4.352384277131720000, 3.221749932900420000, -0.257163446680127000)));
   err = rmax2(err, fabs(0.998760969813713000 - bivariatenormalcdf(3.422289814750960000, 3.111433954663520000, 0.198012195099628000)));
   Ok = Ok && err <= 1.0E-12;
   err = 0.0;
   err = rmax2(err, fabs(0.080575405379940000 - bivariatenormalcdf(-1.060937077356340000, 1.523763953950230000, -0.999999999999000000)));
   err = rmax2(err, fabs(0.000000000000000007 - bivariatenormalcdf(-1.060937077356340000, -1.060937077356340000, -0.999999999999000000)));
   err = rmax2(err, fabs(0.000000000000000007 - bivariatenormalcdf(-1.060937077356340000, -1.060937077354570000, -0.999999999999000000)));
   err = rmax2(err, fabs(0.000000000000000016 - bivariatenormalcdf(-3.034280037001620000, 0.633583566571867000, -0.999999999990000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-3.034280037001620000, -3.034280037001620000, -0.999999999990000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-3.034280037001620000, -3.034280036974940000, -0.999999999990000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-3.577198111015300000, -2.584892928002350000, -0.999999999900000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-3.577198111015300000, -3.577198111015300000, -0.999999999900000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-3.577198111015300000, -3.577198111015280000, -0.999999999900000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-1.053171728048290000, -2.987017621703680000, -0.999999999000000000)));
   err = rmax2(err, fabs(0.000000000000000021 - bivariatenormalcdf(-1.053171728048290000, -1.053171728048290000, -0.999999999000000000)));
   err = rmax2(err, fabs(0.000000000000000014 - bivariatenormalcdf(-1.053171728048290000, -1.052982935276290000, -0.999999999000000000)));
   err = rmax2(err, fabs(0.972550843757766000 - bivariatenormalcdf(4.785178416287600000, 1.919693671247900000, -0.999999990000000000)));
   err = rmax2(err, fabs(0.999998291644901000 - bivariatenormalcdf(4.785178416287600000, 4.785178416287600000, -0.999999990000000000)));
   err = rmax2(err, fabs(0.999998291644901000 - bivariatenormalcdf(4.785178416287600000, 4.785178416295720000, -0.999999990000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-4.852815283224590000, 2.398320119295830000, -0.999999900000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-4.852815283224590000, -4.852815283224590000, -0.999999900000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-4.852815283224590000, -4.852815283224590000, -0.999999900000000000)));
   err = rmax2(err, fabs(0.576135517318684000 - bivariatenormalcdf(0.192020298597275000, 4.695461487450740000, -0.999999000000000000)));
   err = rmax2(err, fabs(0.152273694692214000 - bivariatenormalcdf(0.192020298597275000, 0.192020298597275000, -0.999999000000000000)));
   err = rmax2(err, fabs(0.152273697664791000 - bivariatenormalcdf(0.192020298597275000, 0.192020306187062000, -0.999999000000000000)));
   err = rmax2(err, fabs(0.869148589647661000 - bivariatenormalcdf(2.095780141251770000, 1.211768206209080000, -0.999990000000000000)));
   err = rmax2(err, fabs(0.963898301217005000 - bivariatenormalcdf(2.095780141251770000, 2.095780141251770000, -0.999990000000000000)));
   err = rmax2(err, fabs(0.963898301217035000 - bivariatenormalcdf(2.095780141251770000, 2.095780141252440000, -0.999990000000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-2.654007687508430000, 1.340051767837440000, -0.999900000000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-2.654007687508430000, -2.654007687508430000, -0.999900000000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-2.654007687508430000, -2.654007613149620000, -0.999900000000000000)));
   err = rmax2(err, fabs(0.000000000000000019 - bivariatenormalcdf(1.128363097510700000, -2.781006578069910000, -0.999000000000000000)));
   err = rmax2(err, fabs(0.740833394117601000 - bivariatenormalcdf(1.128363097510700000, 1.128363097510700000, -0.999000000000000000)));
   err = rmax2(err, fabs(0.740862731628071000 - bivariatenormalcdf(1.128363097510700000, 1.128502099120660000, -0.999000000000000000)));
   err = rmax2(err, fabs(0.995654456762395000 - bivariatenormalcdf(3.966506850977000000, 2.626841258388710000, -0.990000000000000000)));
   err = rmax2(err, fabs(0.999927066319845000 - bivariatenormalcdf(3.966506850977000000, 3.966506850977000000, -0.990000000000000000)));
   err = rmax2(err, fabs(0.999927066319846000 - bivariatenormalcdf(3.966506850977000000, 3.966506850981670000, -0.990000000000000000)));
   err = rmax2(err, fabs(0.002769246133985220 - bivariatenormalcdf(-2.717530641700190000, 3.217920162027340000, -0.900000000000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-2.717530641700190000, -2.717530641700190000, -0.900000000000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-2.717530641700190000, -2.717530635181090000, -0.900000000000000000)));
   err = rmax2(err, fabs(0.010079636581695100 - bivariatenormalcdf(-1.811681729272450000, -2.262911120125770000, 0.900000000000000000)));
   err = rmax2(err, fabs(0.021493462833838000 - bivariatenormalcdf(-1.811681729272450000, -1.811681729272450000, 0.900000000000000000)));
   err = rmax2(err, fabs(0.021493462833871500 - bivariatenormalcdf(-1.811681729272450000, -1.811681729271170000, 0.900000000000000000)));
   err = rmax2(err, fabs(0.667398193291227000 - bivariatenormalcdf(1.861468373436860000, 0.432740073549983000, 0.990000000000000000)));
   err = rmax2(err, fabs(0.964688949692122000 - bivariatenormalcdf(1.861468373436860000, 1.861468373436860000, 0.990000000000000000)));
   err = rmax2(err, fabs(0.964688949699170000 - bivariatenormalcdf(1.861468373436860000, 1.861468373617680000, 0.990000000000000000)));
   err = rmax2(err, fabs(0.000000482786767864 - bivariatenormalcdf(-4.898527851968480000, -3.491204153631050000, 0.999000000000000000)));
   err = rmax2(err, fabs(0.000000439041574222 - bivariatenormalcdf(-4.898527851968480000, -4.898527851968480000, 0.999000000000000000)));
   err = rmax2(err, fabs(0.000000439041575582 - bivariatenormalcdf(-4.898527851968480000, -4.898527850755250000, 0.999000000000000000)));
   err = rmax2(err, fabs(0.000416850246666766 - bivariatenormalcdf(-3.341356669094100000, 1.862802982022170000, 0.999900000000000000)));
   err = rmax2(err, fabs(0.000408379488679640 - bivariatenormalcdf(-3.341356669094100000, -3.341356669094100000, 0.999900000000000000)));
   err = rmax2(err, fabs(0.000408379488680111 - bivariatenormalcdf(-3.341356669094100000, -3.341356669093450000, 0.999900000000000000)));
   err = rmax2(err, fabs(0.741641759669778000 - bivariatenormalcdf(4.687494092358740000, 0.648415139929991000, 0.999990000000000000)));
   err = rmax2(err, fabs(0.999998605095178000 - bivariatenormalcdf(4.687494092358740000, 4.687494092358740000, 0.999990000000000000)));
   err = rmax2(err, fabs(0.999998606247630000 - bivariatenormalcdf(4.687494092358740000, 4.687843556049730000, 0.999990000000000000)));
   err = rmax2(err, fabs(0.874547330614982000 - bivariatenormalcdf(2.369093655782270000, 1.148153167494120000, 0.999999000000000000)));
   err = rmax2(err, fabs(0.991070530231016000 - bivariatenormalcdf(2.369093655782270000, 2.369093655782270000, 0.999999000000000000)));
   err = rmax2(err, fabs(0.991070530231065000 - bivariatenormalcdf(2.369093655782270000, 2.369093655786410000, 0.999999000000000000)));
   err = rmax2(err, fabs(0.999362948580782000 - bivariatenormalcdf(4.352384277131720000, 3.221749932900420000, 0.999999900000000000)));
   err = rmax2(err, fabs(0.999993261271150000 - bivariatenormalcdf(4.352384277131720000, 4.352384277131720000, 0.999999900000000000)));
   err = rmax2(err, fabs(0.999993261272904000 - bivariatenormalcdf(4.352384277131720000, 4.352384391237480000, 0.999999900000000000)));
   err = rmax2(err, fabs(0.999069094420465000 - bivariatenormalcdf(3.422289814750960000, 3.111433954663520000, 0.999999990000000000)));
   err = rmax2(err, fabs(0.999689455134645000 - bivariatenormalcdf(3.422289814750960000, 3.422289814750960000, 0.999999990000000000)));
   err = rmax2(err, fabs(0.999689455134658000 - bivariatenormalcdf(3.422289814750960000, 3.422289814777010000, 0.999999990000000000)));
   err = rmax2(err, fabs(0.294719708527162000 - bivariatenormalcdf(-0.539648565868907000, 2.177679562057720000, 0.999999999000000000)));
   err = rmax2(err, fabs(0.294713555379044000 - bivariatenormalcdf(-0.539648565868907000, -0.539648565868907000, 0.999999999000000000)));
   err = rmax2(err, fabs(0.294718518285085000 - bivariatenormalcdf(-0.539648565868907000, -0.539602058260055000, 0.999999999000000000)));
   err = rmax2(err, fabs(0.000002811467986141 - bivariatenormalcdf(-4.540093229575050000, 2.436946780486250000, 0.999999999900000000)));
   err = rmax2(err, fabs(0.000002811392754616 - bivariatenormalcdf(-4.540093229575050000, -4.540093229575050000, 0.999999999900000000)));
   err = rmax2(err, fabs(0.000002811467986126 - bivariatenormalcdf(-4.540093229575050000, -4.540001786779430000, 0.999999999900000000)));
   err = rmax2(err, fabs(0.565106870340374000 - bivariatenormalcdf(0.163929988133744000, 3.995097146641120000, 0.999999999990000000)));
   err = rmax2(err, fabs(0.565106168077456000 - bivariatenormalcdf(0.163929988133744000, 0.163929988133744000, 0.999999999990000000)));
   err = rmax2(err, fabs(0.565106168096292000 - bivariatenormalcdf(0.163929988133744000, 0.163929988229317000, 0.999999999990000000)));
   err = rmax2(err, fabs(0.000064751025417698 - bivariatenormalcdf(3.421155338081630000, -3.827403648909790000, 0.999999999999000000)));
   err = rmax2(err, fabs(0.999688220825439000 - bivariatenormalcdf(3.421155338081630000, 3.421155338081630000, 0.999999999999000000)));
   err = rmax2(err, fabs(0.999688221472430000 - bivariatenormalcdf(3.421155338081630000, 3.421174755498880000, 0.999999999999000000)));
   Ok = Ok && err <= 1.0E-12;
// Test that BVN PDF is roughly equal to derivative of BVN CDF
   for (k = 0; k < 1000; k++) {
   // Generate trial point
      x = hqrndnormal(&rs);
      y = hqrndnormal(&rs);
      rho = 0.0;
   // Compare two values: normal PDF and differentiation of normal CDF with step H
      h = 1.0E-5;
      v0 = bivariatenormalpdf(x, y, rho);
      v1 = (bivariatenormalcdf(x + h, y + h, rho) + bivariatenormalcdf(x - h, y - h, rho) - bivariatenormalcdf(x + h, y - h, rho) - bivariatenormalcdf(x - h, y + h, rho)) / sqr(2 * h);
      Ok = Ok && NearAtR(v0, v1, 1.0E-4);
   }
   ae_frame_leave();
   return Ok;
}

bool testnormaldistr() {
   bool nrmOk;
   bool bvnOk;
   bool Ok;
   nrmOk = true;
   bvnOk = true;
   nrmOk = nrmOk && testnormaldistrunit_testnormal();
   bvnOk = bvnOk && testnormaldistrunit_testbvn();
// The final report.
   Ok = bvnOk && nrmOk;
   if (!Ok || !silent) {
      printf("Normal Distribution Tests\n");
      printf("Normal Distribution:                      %s\n", nrmOk? "Ok": "Failed");
      printf("Bi-Variate Normals:                       %s\n", bvnOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
// end
   return Ok;
}

// === basestat testing unit ===
// This function tests ranking functionality.
static bool testbasestatunit_testranking() {
   ae_frame _frame_block;
   ae_int_t testk;
   ae_int_t npoints;
   ae_int_t nfeatures;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy0, 0, 0, DT_REAL);
   NewMatrix(xy1, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
// Test 1 - large array, unique ranks, each row is obtained as follows:
// * we generate X[i = 0..N-1] = I
// * we add random noise: X[i] = X[i] + 0.2*randomreal()-0.1
// * we perform random permutation
//
// Such dataset has following properties:
// * all data are unique within their rows
// * rank(X[i]) = round(X[i])
//
// We perform several tests with different NPoints/NFeatures.
   for (testk = 0; testk <= 2; testk++) {
   // Select problem size
      if (testk == 0) {
         npoints = 200;
         nfeatures = 1000;
      } else {
         if (testk == 1) {
            npoints = 1000;
            nfeatures = 200;
         } else {
            npoints = iround(sqrt(smpactivationlevel()));
            nfeatures = iround(sqrt(smpactivationlevel()));
         }
      }
   // Generate XY0, XY1, XY2
      ae_matrix_set_length(&xy0, npoints, nfeatures);
      ae_matrix_set_length(&xy1, npoints, nfeatures);
      ae_matrix_set_length(&xy2, npoints, nfeatures);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nfeatures; j++) {
            xy0.xyR[i][j] = j + 0.1 * randommid();
         }
         for (j = 0; j < nfeatures - 1; j++) {
            k = randominteger(nfeatures - j);
            if (k != 0) {
               swapr(&xy0.xyR[i][j], &xy0.xyR[i][j + k]);
            }
         }
         for (j = 0; j < nfeatures; j++) {
            xy1.xyR[i][j] = xy0.xyR[i][j];
            xy2.xyR[i][j] = xy0.xyR[i][j];
         }
      }
   // Test uncentered ranks
      rankdata(&xy0, npoints, nfeatures);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nfeatures; j++) {
            if (xy0.xyR[i][j] != round(xy2.xyR[i][j])) {
               Ok = false;
            }
         }
      }
   // Test centered ranks:
   // they must be equal to uncentered ranks minus (NFeatures-1)/2
      rankdatacentered(&xy1, npoints, nfeatures);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nfeatures; j++) {
            if (xy1.xyR[i][j] != round(xy2.xyR[i][j]) - (nfeatures - 1) / 2.0) {
               Ok = false;
            }
         }
      }
   }
// Test correct handling of tied ranks
   npoints = 3;
   nfeatures = 4;
   ae_matrix_set_length(&xy0, npoints, nfeatures);
   ae_matrix_set_length(&xy1, npoints, nfeatures);
   xy0.xyR[0][0] = 2.25;
   xy0.xyR[0][1] = 3.75;
   xy0.xyR[0][2] = 3.25;
   xy0.xyR[0][3] = 2.25;
   xy0.xyR[1][0] = 2.0;
   xy0.xyR[1][1] = 2.0;
   xy0.xyR[1][2] = 2.0;
   xy0.xyR[1][3] = 7.0;
   xy0.xyR[2][0] = 9.0;
   xy0.xyR[2][1] = 9.0;
   xy0.xyR[2][2] = 9.0;
   xy0.xyR[2][3] = 9.0;
   for (i = 0; i < npoints; i++) {
      for (j = 0; j < nfeatures; j++) {
         xy1.xyR[i][j] = xy0.xyR[i][j];
      }
   }
   rankdata(&xy0, npoints, nfeatures);
   if (!NearAtR(xy0.xyR[0][0], 0.5, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy0.xyR[0][1], 3.0, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy0.xyR[0][2], 2.0, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy0.xyR[0][3], 0.5, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy0.xyR[1][0], 1.0, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy0.xyR[1][1], 1.0, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy0.xyR[1][2], 1.0, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy0.xyR[1][3], 3.0, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy0.xyR[2][0], 1.5, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy0.xyR[2][1], 1.5, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy0.xyR[2][2], 1.5, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy0.xyR[2][3], 1.5, 10.0 * machineepsilon)) {
      Ok = false;
   }
   rankdatacentered(&xy1, npoints, nfeatures);
   if (!NearAtR(xy1.xyR[0][0], -1.0, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy1.xyR[0][1], 1.5, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy1.xyR[0][2], 0.5, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy1.xyR[0][3], -1.0, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy1.xyR[1][0], -0.5, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy1.xyR[1][1], -0.5, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy1.xyR[1][2], -0.5, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (!NearAtR(xy1.xyR[1][3], 1.5, 10.0 * machineepsilon)) {
      Ok = false;
   }
   if (xy1.xyR[2][0] != 0.0) {
      Ok = false;
   }
   if (xy1.xyR[2][1] != 0.0) {
      Ok = false;
   }
   if (xy1.xyR[2][2] != 0.0) {
      Ok = false;
   }
   if (xy1.xyR[2][3] != 0.0) {
      Ok = false;
   }
   ae_frame_leave();
   return Ok;
}

bool testbasestat() {
   ae_frame _frame_block;
   bool Ok;
   bool s1Ok;
   bool covcorrOk;
   bool rankOk;
   double threshold;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t kx;
   ae_int_t ky;
   ae_int_t ctype;
   ae_int_t cidxx;
   ae_int_t cidxy;
   double mean;
   double variance;
   double skewness;
   double kurtosis;
   double adev;
   double median;
   double pv;
   double v;
   double tmean;
   double tvariance;
   double tskewness;
   double tkurtosis;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(mx, 0, 0, DT_REAL);
   NewMatrix(my, 0, 0, DT_REAL);
   NewMatrix(cc, 0, 0, DT_REAL);
   NewMatrix(cp, 0, 0, DT_REAL);
   NewMatrix(cs, 0, 0, DT_REAL);
// Primary settings
   Ok = true;
   s1Ok = true;
   covcorrOk = true;
   rankOk = true;
   threshold = 1000.0 * machineepsilon;
// Ranking
   rankOk = rankOk && testbasestatunit_testranking();
// * prepare X and Y - two test samples
// * test 1-sample coefficients
// * test for SampleMean, SampleVariance,
//   SampleSkewness, SampleKurtosis.
   n = 10;
   ae_vector_set_length(&x, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = sqr(i);
   }
   samplemoments(&x, n, &mean, &variance, &skewness, &kurtosis);
   s1Ok = s1Ok && NearAtR(mean, 28.5, 0.001);
   s1Ok = s1Ok && NearAtR(variance, 801.1667, 0.001);
   s1Ok = s1Ok && NearAtR(skewness, 0.5751, 0.001);
   s1Ok = s1Ok && NearAtR(kurtosis, -1.2666, 0.001);
   tmean = samplemean(&x, n);
   tvariance = samplevariance(&x, n);
   tskewness = sampleskewness(&x, n);
   tkurtosis = samplekurtosis(&x, n);
   s1Ok = s1Ok && NearAtR(mean, tmean, 1.0E-15);
   s1Ok = s1Ok && NearAtR(variance, tvariance, 1.0E-15);
   s1Ok = s1Ok && NearAtR(skewness, tskewness, 1.0E-15);
   s1Ok = s1Ok && NearAtR(kurtosis, tkurtosis, 1.0E-15);
   sampleadev(&x, n, &adev);
   s1Ok = s1Ok && NearAtR(adev, 23.2000, 0.001);
   samplemedian(&x, n, &median);
   s1Ok = s1Ok && NearAtR(median, 0.5 * (16 + 25), 0.001);
   for (i = 0; i < n; i++) {
      samplepercentile(&x, n, (double)i / (n - 1), &pv);
      s1Ok = s1Ok && NearAtR(pv, x.xR[i], 0.001);
   }
   samplepercentile(&x, n, 0.5, &pv);
   s1Ok = s1Ok && NearAtR(pv, 0.5 * (16 + 25), 0.001);
// test covariance/correlation:
// * 2-sample coefficients
//
// We generate random matrices MX and MY
   n = 10;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&y, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = sqr(i);
      y.xR[i] = (double)i;
   }
   covcorrOk = covcorrOk && NearAtR(pearsoncorr2(&x, &y, n), 0.9627, 0.0001);
   covcorrOk = covcorrOk && NearAtR(spearmancorr2(&x, &y, n), 1.0000, 0.0001);
   covcorrOk = covcorrOk && NearAtR(cov2(&x, &y, n), 82.5000, 0.0001);
   for (i = 0; i < n; i++) {
      x.xR[i] = sqr(i - 0.5 * n);
      y.xR[i] = (double)i;
   }
   covcorrOk = covcorrOk && NearAtR(pearsoncorr2(&x, &y, n), -0.3676, 0.0001);
   covcorrOk = covcorrOk && NearAtR(spearmancorr2(&x, &y, n), -0.2761, 0.0001);
   covcorrOk = covcorrOk && NearAtR(cov2(&x, &y, n), -9.1667, 0.0001);
// test covariance/correlation:
// * matrix covariance/correlation
// * matrix cross-covariance/cross-correlation
//
// We generate random matrices MX and MY which contain KX (KY)
// columns, all except one are random, one of them is constant.
// We test that function (a) do not crash on constant column,
// and (b) return variances/correlations that are exactly zero
// for this column.
//
// CType control variable controls type of constant: 0 - no constant
// column, 1 - zero column, 2 - nonzero column with value whose
// binary representation contains many non-zero bits. Using such
// type of constant column we are able to ensure than even in the
// presense of roundoff error functions correctly detect constant
// columns.
   for (n = 0; n <= 10; n++) {
      if (n > 0) {
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
      }
      for (ctype = 0; ctype <= 2; ctype++) {
         for (kx = 1; kx <= 10; kx++) {
            for (ky = 1; ky <= 10; ky++) {
            // Fill matrices, add constant column (when CType == 1 or == 2)
               cidxx = -1;
               cidxy = -1;
               if (n > 0) {
                  ae_matrix_set_length(&mx, n, kx);
                  ae_matrix_set_length(&my, n, ky);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < kx; j++) {
                        mx.xyR[i][j] = randommid();
                     }
                     for (j = 0; j < ky; j++) {
                        my.xyR[i][j] = randommid();
                     }
                  }
                  if (ctype == 1) {
                     cidxx = randominteger(kx);
                     cidxy = randominteger(ky);
                     for (i = 0; i < n; i++) {
                        mx.xyR[i][cidxx] = 0.0;
                        my.xyR[i][cidxy] = 0.0;
                     }
                  }
                  if (ctype == 2) {
                     cidxx = randominteger(kx);
                     cidxy = randominteger(ky);
                     v = sqrt((double)(randominteger(kx) + 1) / kx);
                     for (i = 0; i < n; i++) {
                        mx.xyR[i][cidxx] = v;
                        my.xyR[i][cidxy] = v;
                     }
                  }
               }
            // test covariance/correlation matrix using
            // 2-sample functions as reference point.
            //
            // We also test that coefficients for constant variables
            // are exactly zero.
               covm(&mx, n, kx, &cc);
               pearsoncorrm(&mx, n, kx, &cp);
               spearmancorrm(&mx, n, kx, &cs);
               for (i = 0; i < kx; i++) {
                  for (j = 0; j < kx; j++) {
                     if (n > 0) {
                        ae_v_move(x.xR, 1, &mx.xyR[0][i], mx.stride, n);
                        ae_v_move(y.xR, 1, &mx.xyR[0][j], mx.stride, n);
                     }
                     covcorrOk = covcorrOk && NearAtR(cov2(&x, &y, n), cc.xyR[i][j], threshold);
                     covcorrOk = covcorrOk && NearAtR(pearsoncorr2(&x, &y, n), cp.xyR[i][j], threshold);
                     covcorrOk = covcorrOk && NearAtR(spearmancorr2(&x, &y, n), cs.xyR[i][j], threshold);
                  }
               }
               if (ctype != 0 && n > 0) {
                  for (i = 0; i < kx; i++) {
                     covcorrOk = covcorrOk && cc.xyR[i][cidxx] == 0.0;
                     covcorrOk = covcorrOk && cc.xyR[cidxx][i] == 0.0;
                     covcorrOk = covcorrOk && cp.xyR[i][cidxx] == 0.0;
                     covcorrOk = covcorrOk && cp.xyR[cidxx][i] == 0.0;
                     covcorrOk = covcorrOk && cs.xyR[i][cidxx] == 0.0;
                     covcorrOk = covcorrOk && cs.xyR[cidxx][i] == 0.0;
                  }
               }
            // test cross-covariance/cross-correlation matrix using
            // 2-sample functions as reference point.
            //
            // We also test that coefficients for constant variables
            // are exactly zero.
               covm2(&mx, &my, n, kx, ky, &cc);
               pearsoncorrm2(&mx, &my, n, kx, ky, &cp);
               spearmancorrm2(&mx, &my, n, kx, ky, &cs);
               for (i = 0; i < kx; i++) {
                  for (j = 0; j < ky; j++) {
                     if (n > 0) {
                        ae_v_move(x.xR, 1, &mx.xyR[0][i], mx.stride, n);
                        ae_v_move(y.xR, 1, &my.xyR[0][j], my.stride, n);
                     }
                     covcorrOk = covcorrOk && NearAtR(cov2(&x, &y, n), cc.xyR[i][j], threshold);
                     covcorrOk = covcorrOk && NearAtR(pearsoncorr2(&x, &y, n), cp.xyR[i][j], threshold);
                     covcorrOk = covcorrOk && NearAtR(spearmancorr2(&x, &y, n), cs.xyR[i][j], threshold);
                  }
               }
               if (ctype != 0 && n > 0) {
                  for (i = 0; i < kx; i++) {
                     covcorrOk = covcorrOk && cc.xyR[i][cidxy] == 0.0;
                     covcorrOk = covcorrOk && cp.xyR[i][cidxy] == 0.0;
                     covcorrOk = covcorrOk && cs.xyR[i][cidxy] == 0.0;
                  }
                  for (j = 0; j < ky; j++) {
                     covcorrOk = covcorrOk && cc.xyR[cidxx][j] == 0.0;
                     covcorrOk = covcorrOk && cp.xyR[cidxx][j] == 0.0;
                     covcorrOk = covcorrOk && cs.xyR[cidxx][j] == 0.0;
                  }
               }
            }
         }
      }
   }
// The final report.
   Ok = s1Ok && covcorrOk && rankOk;
   if (!Ok || !silent) {
      printf("Descriptive Statistics Tests\n");
      printf("Total Results:                            %s\n", Ok? "Ok": "Failed");
      printf("* 1-Sample Functionality:                 %s\n", s1Ok? "Ok": "Failed");
      printf("* Correlation/Covariation:                %s\n", covcorrOk? "Ok": "Failed");
      printf("* Ranking:                                %s\n", rankOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === wsr testing unit ===
bool testwsr() {
   ae_frame _frame_block;
   bool Ok;
   ae_int_t n;
   ae_int_t i;
   double taill;
   double tailr;
   double tailb;
   double taillprev;
   double tailrprev;
   double ebase;
   double eshift;
   ae_frame_make(&_frame_block);
   NewVector(xa, 0, DT_REAL);
   Ok = true;
// Test monotonicity of tail values for moving value of E
   for (n = 5; n <= 50; n++) {
   // Generate uniform and sorted X spanning [0,1]
      ae_vector_set_length(&xa, n);
      for (i = 0; i < n; i++) {
         xa.xR[i] = (double)i / (n - 1);
      }
   // Test N+1 values of E
      ebase = -0.5 / (n - 1);
      eshift = 1.0 / (n - 1);
      tailrprev = 0.0;
      taillprev = 1.0;
      for (i = 0; i <= n; i++) {
         wilcoxonsignedranktest(&xa, n, ebase + eshift * i, &tailb, &taill, &tailr);
         Ok = Ok && tailb == 2 * rmin2(taill, tailr);
         Ok = Ok && tailrprev <= tailr;
         Ok = Ok && taillprev >= taill;
         tailrprev = tailr;
         taillprev = taill;
      }
   }
// Test for integer overflow in the function: if one crucial
// calculation step is performed in 32-bit integer arithmetics,
// it will return incorrect results.
//
// We use special handcrafted N, such that in 32-bit integer
// arithmetics int32(N*N) < 0. Such negative N leads to domain
// error in the sqrt() function.
   n = 50000;
   ae_vector_set_length(&xa, n);
   for (i = 0; i < n; i++) {
      xa.xR[i] = sin((double)(10 * i));
   }
   wilcoxonsignedranktest(&xa, n, 0.0, &tailb, &taill, &tailr);
   Ok = Ok && isfinite(tailb);
   Ok = Ok && isfinite(taill);
   Ok = Ok && isfinite(tailr);
// The final report.
   if (!Ok || !silent) {
      printf("WSR Test\n");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === mannwhitneyu testing unit ===
bool testmannwhitneyu() {
   ae_frame _frame_block;
   bool Ok;
   ae_int_t testmin;
   ae_int_t testmax;
   ae_int_t testcnt;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t k;
   double taill;
   double tailr;
   double tailb;
   double taill1;
   double tailr1;
   double tailb1;
   double taillprev;
   double tailrprev;
   double ebase;
   double eshift;
   ae_int_t ecnt;
   double worsterr;
   double v;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   Ok = true;
   hqrndrandomize(&rs);
// Test monotonicity of tail values for monotinically moving distributions.
   for (n = 5; n <= 20; n++) {
      for (m = 5; m <= 20; m++) {
      // Generate uniform and sorted X/Y spanning [0,1]
         ae_vector_set_length(&x, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = (double)i / (n - 1) + 100.0 * machineepsilon * hqrndnormal(&rs);
         }
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            y.xR[i] = (double)i / (m - 1) + 100.0 * machineepsilon * hqrndnormal(&rs);
         }
      // Test 100 values of E
         ecnt = 100;
         ebase = -1.1;
         eshift = -2 * ebase / (ecnt - 1);
         tailrprev = 0.0;
         taillprev = 1.0;
         for (i = 0; i < m; i++) {
            y.xR[i] += ebase;
         }
         for (k = 0; k < ecnt; k++) {
            mannwhitneyutest(&x, n, &y, m, &tailb, &taill, &tailr);
            Ok = Ok && tailb == 2 * rmin2(taill, tailr);
            Ok = Ok && tailrprev <= tailr;
            Ok = Ok && taillprev >= taill;
            tailrprev = tailr;
            taillprev = taill;
            for (i = 0; i < m; i++) {
               y.xR[i] += eshift;
            }
         }
      }
   }
// Test frequency of p-value 0.05
   testmin = 5;
   testmax = 50;
   testcnt = 10000;
   worsterr = 0.0;
   for (n = testmin; n <= testmax; n++) {
      m = n + hqrnduniformi(&rs, testmax - n + 1);
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, m);
   // Generate two uniformly distributed values, calculate p-value for both-tails, repeat
      k = 0;
      for (pass = 0; pass < testcnt; pass++) {
         for (i = 0; i < n; i++) {
            x.xR[i] = hqrnduniformr(&rs);
         }
         for (i = 0; i < m; i++) {
            y.xR[i] = hqrnduniformr(&rs);
         }
         mannwhitneyutest(&x, n, &y, m, &tailb, &taill, &tailr);
         if (tailb < 0.05) {
            k++;
         }
      }
      v = fabs((double)k / testcnt - 0.05);
      worsterr = rmax2(worsterr, v);
   // Test error in quantile; for different N's we have different tolerances
      if (n < 10) {
         Ok = Ok && v <= 0.030;
      } else {
         if (n < 15) {
            Ok = Ok && v <= 0.020;
         } else {
            if (n < 30) {
               Ok = Ok && v <= 0.015;
            } else {
               Ok = Ok && v <= 0.010;
            }
         }
      }
   }
// Test symmetry properties
   for (n = 5; n <= 50; n++) {
      for (m = 5; m <= 50; m++) {
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, m);
         for (i = 0; i < n; i++) {
            x.xR[i] = hqrnduniformr(&rs);
         }
         for (i = 0; i < m; i++) {
            y.xR[i] = hqrnduniformr(&rs);
         }
         mannwhitneyutest(&x, n, &y, m, &tailb, &taill, &tailr);
         mannwhitneyutest(&y, m, &x, n, &tailb1, &taill1, &tailr1);
         Ok = Ok && NearAtR(tailb, tailb1, 1.0E-12);
         Ok = Ok && NearAtR(taill, tailr1, 1.0E-12);
         Ok = Ok && NearAtR(tailr, taill1, 1.0E-12);
      }
   }
// Test for integer overflow in the function: if one crucial
// calculation step is performed in 32-bit integer arithmetics,
// it will return incorrect results.
//
// We use special handcrafted N, such that in 32-bit integer
// arithmetics int32(N*N) < 0. Such negative N leads to domain
// error in the sqrt() function.
   n = 50000;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&y, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = sin((double)(10 * i));
      y.xR[i] = sin((double)(13 * i));
   }
   mannwhitneyutest(&x, n, &y, n, &tailb, &taill, &tailr);
   Ok = Ok && isfinite(tailb);
   Ok = Ok && isfinite(taill);
   Ok = Ok && isfinite(tailr);
// The final report.
   if (!Ok || !silent) {
      printf("Mann-Whitney U Test\n");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === stest testing unit ===
bool teststest() {
   ae_frame _frame_block;
   double taill;
   double tailr;
   double tailb;
   bool Ok;
   double eps;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   Ok = true;
   eps = 1.0E-3;
// Test 1
   ae_vector_set_length(&x, 6);
   x.xR[0] = -3.0;
   x.xR[1] = -2.0;
   x.xR[2] = -1.0;
   x.xR[3] = 1.0;
   x.xR[4] = 2.0;
   x.xR[5] = 3.0;
   onesamplesigntest(&x, 6, 0.0, &tailb, &taill, &tailr);
   Ok = Ok && NearAtR(taill, 0.65625, eps);
   Ok = Ok && NearAtR(tailr, 0.65625, eps);
   Ok = Ok && NearAtR(tailb, 1.00000, eps);
   onesamplesigntest(&x, 6, -1.0, &tailb, &taill, &tailr);
   Ok = Ok && NearAtR(taill, 0.81250, eps);
   Ok = Ok && NearAtR(tailr, 0.50000, eps);
   Ok = Ok && NearAtR(tailb, 1.00000, eps);
   onesamplesigntest(&x, 6, -1.5, &tailb, &taill, &tailr);
   Ok = Ok && NearAtR(taill, 0.89062, eps);
   Ok = Ok && NearAtR(tailr, 0.34375, eps);
   Ok = Ok && NearAtR(tailb, 0.68750, eps);
   onesamplesigntest(&x, 6, -3.0, &tailb, &taill, &tailr);
   Ok = Ok && NearAtR(taill, 1.00000, eps);
   Ok = Ok && NearAtR(tailr, 0.03125, eps);
   Ok = Ok && NearAtR(tailb, 0.06250, eps);
// Test 2
   ae_vector_set_length(&x, 3);
   x.xR[0] = 2.0;
   x.xR[1] = 2.0;
   x.xR[2] = 2.0;
   onesamplesigntest(&x, 3, 2.0, &tailb, &taill, &tailr);
   Ok = Ok && taill == 1.0;
   Ok = Ok && tailr == 1.0;
   Ok = Ok && tailb == 1.0;
// The final report.
   if (!Ok || !silent) {
      printf("Sign Test:\n");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === studentttests testing unit ===
bool teststudentttests() {
   ae_frame _frame_block;
   bool Ok;
   double eps;
   ae_int_t n;
   ae_int_t i;
   double taill;
   double tailr;
   double tailb;
   double taill1;
   double tailr1;
   double tailb1;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(xa, 0, DT_REAL);
   NewVector(ya, 0, DT_REAL);
   NewVector(xb, 0, DT_REAL);
   NewVector(yb, 0, DT_REAL);
   Ok = true;
   eps = 0.001;
// 1-sample test
   n = 8;
   ae_vector_set_length(&x, 8);
   x.xR[0] = -3.0;
   x.xR[1] = -1.5;
   x.xR[2] = -1.0;
   x.xR[3] = -0.5;
   x.xR[4] = 0.5;
   x.xR[5] = 1.0;
   x.xR[6] = 1.5;
   x.xR[7] = 3.0;
   studentttest1(&x, n, 0.0, &tailb, &taill, &tailr);
   Ok = Ok && NearAtR(tailb, 1.00000, eps);
   Ok = Ok && NearAtR(taill, 0.50000, eps);
   Ok = Ok && NearAtR(tailr, 0.50000, eps);
   studentttest1(&x, n, 1.0, &tailb, &taill, &tailr);
   Ok = Ok && NearAtR(tailb, 0.17816, eps);
   Ok = Ok && NearAtR(taill, 0.08908, eps);
   Ok = Ok && NearAtR(tailr, 0.91092, eps);
   studentttest1(&x, n, -1.0, &tailb, &taill, &tailr);
   Ok = Ok && NearAtR(tailb, 0.17816, eps);
   Ok = Ok && NearAtR(taill, 0.91092, eps);
   Ok = Ok && NearAtR(tailr, 0.08908, eps);
   x.xR[0] = 1.1;
   x.xR[1] = 1.1;
   x.xR[2] = 1.1;
   x.xR[3] = 1.1;
   x.xR[4] = 1.1;
   x.xR[5] = 1.1;
   x.xR[6] = 1.1;
   x.xR[7] = 1.1;
   studentttest1(&x, n, 1.1, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 1.0;
   Ok = Ok && taill == 1.0;
   Ok = Ok && tailr == 1.0;
   studentttest1(&x, n, 0.0, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 0.0;
   Ok = Ok && taill == 1.0;
   Ok = Ok && tailr == 0.0;
   x.xR[7] = 1.1;
   studentttest1(&x, 1, 1.1, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 1.0;
   Ok = Ok && taill == 1.0;
   Ok = Ok && tailr == 1.0;
   studentttest1(&x, 1, 0.0, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 0.0;
   Ok = Ok && taill == 1.0;
   Ok = Ok && tailr == 0.0;
// 2-sample pooled (equal variance) test
   n = 8;
   ae_vector_set_length(&x, 8);
   ae_vector_set_length(&y, 8);
   x.xR[0] = -3.0;
   x.xR[1] = -1.5;
   x.xR[2] = -1.0;
   x.xR[3] = -0.5;
   x.xR[4] = 0.5;
   x.xR[5] = 1.0;
   x.xR[6] = 1.5;
   x.xR[7] = 3.0;
   y.xR[0] = -2.0;
   y.xR[1] = -0.5;
   y.xR[2] = 0.0;
   y.xR[3] = 0.5;
   y.xR[4] = 1.5;
   y.xR[5] = 2.0;
   y.xR[6] = 2.5;
   y.xR[7] = 4.0;
   studentttest2(&x, n, &y, n, &tailb, &taill, &tailr);
   Ok = Ok && NearAtR(tailb, 0.30780, eps);
   Ok = Ok && NearAtR(taill, 0.15390, eps);
   Ok = Ok && NearAtR(tailr, 0.84610, eps);
   studentttest2(&x, n, &y, n - 1, &tailb, &taill, &tailr);
   Ok = Ok && NearAtR(tailb, 0.53853, eps);
   Ok = Ok && NearAtR(taill, 0.26927, eps);
   Ok = Ok && NearAtR(tailr, 0.73074, eps);
   studentttest2(&x, n - 1, &y, n, &tailb, &taill, &tailr);
   Ok = Ok && NearAtR(tailb, 0.13829, eps);
   Ok = Ok && NearAtR(taill, 0.06915, eps);
   Ok = Ok && NearAtR(tailr, 0.93086, eps);
   x.xR[0] = -1.0;
   x.xR[1] = -1.0;
   x.xR[2] = -1.0;
   x.xR[3] = -1.0;
   x.xR[4] = -1.0;
   x.xR[5] = -1.0;
   x.xR[6] = -1.0;
   x.xR[7] = -1.0;
   y.xR[0] = 1.0;
   y.xR[1] = 1.0;
   y.xR[2] = 1.0;
   y.xR[3] = 1.0;
   y.xR[4] = 1.0;
   y.xR[5] = 1.0;
   y.xR[6] = 1.0;
   y.xR[7] = 1.0;
   studentttest2(&x, n, &y, n, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 0.0;
   Ok = Ok && taill == 0.0;
   Ok = Ok && tailr == 1.0;
   studentttest2(&x, n, &y, n - 1, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 0.0;
   Ok = Ok && taill == 0.0;
   Ok = Ok && tailr == 1.0;
   studentttest2(&x, n, &y, 1, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 0.0;
   Ok = Ok && taill == 0.0;
   Ok = Ok && tailr == 1.0;
   studentttest2(&x, n - 1, &y, n, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 0.0;
   Ok = Ok && taill == 0.0;
   Ok = Ok && tailr == 1.0;
   studentttest2(&x, 1, &y, n, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 0.0;
   Ok = Ok && taill == 0.0;
   Ok = Ok && tailr == 1.0;
   studentttest2(&x, 1, &y, 1, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 0.0;
   Ok = Ok && taill == 0.0;
   Ok = Ok && tailr == 1.0;
   studentttest2(&y, 1, &x, 1, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 0.0;
   Ok = Ok && taill == 1.0;
   Ok = Ok && tailr == 0.0;
   x.xR[0] = 1.1;
   x.xR[1] = 1.1;
   x.xR[2] = 1.1;
   x.xR[3] = 1.1;
   x.xR[4] = 1.1;
   x.xR[5] = 1.1;
   x.xR[6] = 1.1;
   x.xR[7] = 1.1;
   y.xR[0] = 1.1;
   y.xR[1] = 1.1;
   y.xR[2] = 1.1;
   y.xR[3] = 1.1;
   y.xR[4] = 1.1;
   y.xR[5] = 1.1;
   y.xR[6] = 1.1;
   y.xR[7] = 1.1;
   studentttest2(&x, n, &y, n, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 1.0;
   Ok = Ok && taill == 1.0;
   Ok = Ok && tailr == 1.0;
   studentttest2(&x, n, &y, n - 1, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 1.0;
   Ok = Ok && taill == 1.0;
   Ok = Ok && tailr == 1.0;
   studentttest2(&x, n, &y, 1, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 1.0;
   Ok = Ok && taill == 1.0;
   Ok = Ok && tailr == 1.0;
   studentttest2(&x, n - 1, &y, n, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 1.0;
   Ok = Ok && taill == 1.0;
   Ok = Ok && tailr == 1.0;
   studentttest2(&x, 1, &y, n, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 1.0;
   Ok = Ok && taill == 1.0;
   Ok = Ok && tailr == 1.0;
   studentttest2(&x, 1, &y, 1, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 1.0;
   Ok = Ok && taill == 1.0;
   Ok = Ok && tailr == 1.0;
// 2-sample unpooled (unequal variance) test:
// * test on two non-constant samples
// * tests on different combinations of non-constant and constant samples
   n = 8;
   ae_vector_set_length(&xa, 8);
   ae_vector_set_length(&ya, 8);
   ae_vector_set_length(&xb, 8);
   ae_vector_set_length(&yb, 8);
   xa.xR[0] = -3.0;
   xa.xR[1] = -1.5;
   xa.xR[2] = -1.0;
   xa.xR[3] = -0.5;
   xa.xR[4] = 0.5;
   xa.xR[5] = 1.0;
   xa.xR[6] = 1.5;
   xa.xR[7] = 3.0;
   ya.xR[0] = -1.0;
   ya.xR[1] = -0.5;
   ya.xR[2] = 0.0;
   ya.xR[3] = 0.5;
   ya.xR[4] = 1.5;
   ya.xR[5] = 2.0;
   ya.xR[6] = 2.5;
   ya.xR[7] = 3.0;
   xb.xR[0] = -1.1;
   xb.xR[1] = -1.1;
   xb.xR[2] = -1.1;
   xb.xR[3] = -1.1;
   xb.xR[4] = -1.1;
   xb.xR[5] = -1.1;
   xb.xR[6] = -1.1;
   xb.xR[7] = -1.1;
   yb.xR[0] = 1.1;
   yb.xR[1] = 1.1;
   yb.xR[2] = 1.1;
   yb.xR[3] = 1.1;
   yb.xR[4] = 1.1;
   yb.xR[5] = 1.1;
   yb.xR[6] = 1.1;
   yb.xR[7] = 1.1;
   unequalvariancettest(&xa, n, &ya, n, &tailb, &taill, &tailr);
   Ok = Ok && NearAtR(tailb, 0.25791, eps);
   Ok = Ok && NearAtR(taill, 0.12896, eps);
   Ok = Ok && NearAtR(tailr, 0.87105, eps);
   unequalvariancettest(&xa, n, &yb, n, &tailb, &taill, &tailr);
   studentttest1(&xa, n, 1.1, &tailb1, &taill1, &tailr1);
   Ok = Ok && NearAtR(tailb, tailb1, eps);
   Ok = Ok && NearAtR(taill, taill1, eps);
   Ok = Ok && NearAtR(tailr, tailr1, eps);
   unequalvariancettest(&xa, n, &yb, 1, &tailb, &taill, &tailr);
   studentttest1(&xa, n, 1.1, &tailb1, &taill1, &tailr1);
   Ok = Ok && NearAtR(tailb, tailb1, eps);
   Ok = Ok && NearAtR(taill, taill1, eps);
   Ok = Ok && NearAtR(tailr, tailr1, eps);
   unequalvariancettest(&xb, n, &ya, n, &tailb, &taill, &tailr);
   studentttest1(&ya, n, -1.1, &tailb1, &taill1, &tailr1);
   Ok = Ok && NearAtR(tailb, tailb1, eps);
   Ok = Ok && NearAtR(taill, tailr1, eps);
   Ok = Ok && NearAtR(tailr, taill1, eps);
   unequalvariancettest(&xb, 1, &ya, n, &tailb, &taill, &tailr);
   studentttest1(&ya, n, -1.1, &tailb1, &taill1, &tailr1);
   Ok = Ok && NearAtR(tailb, tailb1, eps);
   Ok = Ok && NearAtR(taill, tailr1, eps);
   Ok = Ok && NearAtR(tailr, taill1, eps);
   unequalvariancettest(&xb, 1, &yb, 1, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 0.0;
   Ok = Ok && taill == 0.0;
   Ok = Ok && tailr == 1.0;
   unequalvariancettest(&yb, 1, &xb, 1, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 0.0;
   Ok = Ok && taill == 1.0;
   Ok = Ok && tailr == 0.0;
   unequalvariancettest(&xb, 1, &xb, 1, &tailb, &taill, &tailr);
   Ok = Ok && tailb == 1.0;
   Ok = Ok && taill == 1.0;
   Ok = Ok && tailr == 1.0;
// Test for integer overflow in the function: if one crucial
// calculation step is performed in 32-bit integer arithmetics,
// it will return incorrect results.
//
// We use special handcrafted N, such that in 32-bit integer
// arithmetics int32(N*N) < 0. Such negative N leads to domain
// error in the incomplete beta function.
   n = 50000;
   ae_vector_set_length(&xa, n);
   ae_vector_set_length(&ya, n);
   for (i = 0; i < n; i++) {
      xa.xR[i] = randomreal();
      ya.xR[i] = randomreal();
   }
   unequalvariancettest(&xa, n, &ya, n, &tailb, &taill, &tailr);
// The final report.
   if (!Ok || !silent) {
      printf("Student T-Test Calculation Test\n");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === ratint testing unit ===
static void testratintunit_poldiff2(RVector *x, RVector *f, ae_int_t n, double t, double *p, double *dp, double *d2p) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   DupVector(f);
   *p = 0;
   *dp = 0;
   *d2p = 0;
   NewVector(df, 0, DT_REAL);
   NewVector(d2f, 0, DT_REAL);
   n--;
   ae_vector_set_length(&df, n + 1);
   ae_vector_set_length(&d2f, n + 1);
   for (i = 0; i <= n; i++) {
      d2f.xR[i] = 0.0;
      df.xR[i] = 0.0;
   }
   for (m = 1; m <= n; m++) {
      for (i = 0; i <= n - m; i++) {
         d2f.xR[i] = ((t - x->xR[i + m]) * d2f.xR[i] + (x->xR[i] - t) * d2f.xR[i + 1] + 2 * df.xR[i] - 2 * df.xR[i + 1]) / (x->xR[i] - x->xR[i + m]);
         df.xR[i] = ((t - x->xR[i + m]) * df.xR[i] + f->xR[i] + (x->xR[i] - t) * df.xR[i + 1] - f->xR[i + 1]) / (x->xR[i] - x->xR[i + m]);
         f->xR[i] = ((t - x->xR[i + m]) * f->xR[i] + (x->xR[i] - t) * f->xR[i + 1]) / (x->xR[i] - x->xR[i + m]);
      }
   }
   *p = f->xR[0];
   *dp = df.xR[0];
   *d2p = d2f.xR[0];
   ae_frame_leave();
}

static void testratintunit_brcunset(barycentricinterpolant *b) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   ae_vector_set_length(&x, 1);
   ae_vector_set_length(&y, 1);
   ae_vector_set_length(&w, 1);
   x.xR[0] = 0.0;
   y.xR[0] = 0.0;
   w.xR[0] = 1.0;
   barycentricbuildxyw(&x, &y, &w, 1, b);
   ae_frame_leave();
}

bool testratint() {
   ae_frame _frame_block;
   bool Ok;
   bool bcOk;
   bool npOk;
   double threshold;
   double lipschitztol;
   ae_int_t passcount;
   double h;
   double s1;
   double s2;
   ae_int_t n;
   ae_int_t n2;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t d;
   ae_int_t pass;
   double maxerr;
   double t;
   double a;
   double b;
   double s;
   double v0;
   double v1;
   double v2;
   double v3;
   double d0;
   double d1;
   double d2;
   ae_frame_make(&_frame_block);
   NewObj(barycentricinterpolant, b1);
   NewObj(barycentricinterpolant, b2);
   NewVector(x, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewVector(dc, 0, DT_INT);
   npOk = true;
   bcOk = true;
   Ok = true;
// PassCount        number of repeated passes
// Threshold        error tolerance
// LipschitzTol     Lipschitz constant increase allowed
//                  when calculating constant on a twice denser grid
   passcount = 5;
   threshold = 1000000.0 * machineepsilon;
   lipschitztol = 1.3;
// Basic barycentric functions
   for (n = 1; n <= 10; n++) {
   // randomized tests
      for (pass = 1; pass <= passcount; pass++) {
      // generate weights from polynomial interpolation
         v0 = 1.0 + 0.2 * randommid();
         v1 = randommid();
         v2 = randommid();
         v3 = randommid();
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
         ae_vector_set_length(&w, n);
         for (i = 0; i < n; i++) {
            if (n == 1) {
               x.xR[i] = 0.0;
            } else {
               x.xR[i] = v0 * cos(i * pi / (n - 1));
            }
            y.xR[i] = sin(v1 * x.xR[i]) + cos(v2 * x.xR[i]) + exp(v3 * x.xR[i]);
         }
         for (j = 0; j < n; j++) {
            w.xR[j] = 1.0;
            for (k = 0; k < n; k++) {
               if (k != j) {
                  w.xR[j] /= x.xR[j] - x.xR[k];
               }
            }
         }
         barycentricbuildxyw(&x, &y, &w, n, &b1);
      // unpack, then pack again and compare
         testratintunit_brcunset(&b2);
         barycentricunpack(&b1, &n2, &x2, &y2, &w2);
         bcOk = bcOk && n2 == n;
         barycentricbuildxyw(&x2, &y2, &w2, n2, &b2);
         t = randommid();
         bcOk = bcOk && NearAtR(barycentriccalc(&b1, t), barycentriccalc(&b2, t), threshold);
      // copy, compare
         testratintunit_brcunset(&b2);
         barycentriccopy(&b1, &b2);
         t = randommid();
         bcOk = bcOk && NearAtR(barycentriccalc(&b1, t), barycentriccalc(&b2, t), threshold);
      // test interpolation properties
         for (i = 0; i < n; i++) {
         // test interpolation at nodes
            bcOk = bcOk && NearAtR(barycentriccalc(&b1, x.xR[i]), y.xR[i], threshold * fabs(y.xR[i]));
         // compare with polynomial interpolation
            t = randommid();
            testratintunit_poldiff2(&x, &y, n, t, &v0, &v1, &v2);
            bcOk = bcOk && NearAtR(barycentriccalc(&b1, t), v0, threshold * rmax2(fabs(v0), 1.0));
         // test continuity between nodes
         // calculate Lipschitz constant on two grids -
         // dense and even more dense. If Lipschitz constant
         // on a denser grid is significantly increased,
         // continuity test is failed
            t = 3.0;
            k = 100;
            s1 = 0.0;
            for (j = 0; j < k; j++) {
               v1 = x.xR[i] + (t - x.xR[i]) * j / k;
               v2 = x.xR[i] + (t - x.xR[i]) * (j + 1) / k;
               s1 = rmax2(s1, fabs(barycentriccalc(&b1, v2) - barycentriccalc(&b1, v1)) / fabs(v2 - v1));
            }
            k *= 2;
            s2 = 0.0;
            for (j = 0; j < k; j++) {
               v1 = x.xR[i] + (t - x.xR[i]) * j / k;
               v2 = x.xR[i] + (t - x.xR[i]) * (j + 1) / k;
               s2 = rmax2(s2, fabs(barycentriccalc(&b1, v2) - barycentriccalc(&b1, v1)) / fabs(v2 - v1));
            }
            bcOk = bcOk && (s2 <= lipschitztol * s1 || s1 <= threshold * k);
         }
      // test differentiation properties
         for (i = 0; i < n; i++) {
            t = randommid();
            testratintunit_poldiff2(&x, &y, n, t, &v0, &v1, &v2);
            d0 = 0.0;
            d1 = 0.0;
            d2 = 0.0;
            barycentricdiff1(&b1, t, &d0, &d1);
            bcOk = bcOk && NearAtR(v0, d0, threshold * rmax2(fabs(v0), 1.0));
            bcOk = bcOk && NearAtR(v1, d1, threshold * rmax2(fabs(v1), 1.0));
            d0 = 0.0;
            d1 = 0.0;
            d2 = 0.0;
            barycentricdiff2(&b1, t, &d0, &d1, &d2);
            bcOk = bcOk && NearAtR(v0, d0, threshold * rmax2(fabs(v0), 1.0));
            bcOk = bcOk && NearAtR(v1, d1, threshold * rmax2(fabs(v1), 1.0));
            bcOk = bcOk && NearAtR(v2, d2, sqrt(threshold) * rmax2(fabs(v2), 1.0));
         }
      // test linear translation
         t = randommid();
         a = randommid();
         b = randommid();
         testratintunit_brcunset(&b2);
         barycentriccopy(&b1, &b2);
         barycentriclintransx(&b2, a, b);
         bcOk = bcOk && NearAtR(barycentriccalc(&b1, a * t + b), barycentriccalc(&b2, t), threshold);
         a = 0.0;
         b = randommid();
         testratintunit_brcunset(&b2);
         barycentriccopy(&b1, &b2);
         barycentriclintransx(&b2, a, b);
         bcOk = bcOk && NearAtR(barycentriccalc(&b1, a * t + b), barycentriccalc(&b2, t), threshold);
         a = randommid();
         b = randommid();
         testratintunit_brcunset(&b2);
         barycentriccopy(&b1, &b2);
         barycentriclintransy(&b2, a, b);
         bcOk = bcOk && NearAtR(a * barycentriccalc(&b1, t) + b, barycentriccalc(&b2, t), threshold);
      }
   }
   for (pass = 0; pass <= 3; pass++) {
   // Crash-test: small numbers, large numbers
      ae_vector_set_length(&x, 4);
      ae_vector_set_length(&y, 4);
      ae_vector_set_length(&w, 4);
      h = 1.0;
      if (pass % 2 == 0) {
         h = 100 * minrealnumber;
      }
      if (pass % 2 == 1) {
         h = 0.01 * maxrealnumber;
      }
      x.xR[0] = 0 * h;
      x.xR[1] = 1 * h;
      x.xR[2] = 2 * h;
      x.xR[3] = 3 * h;
      y.xR[0] = 0 * h;
      y.xR[1] = 1 * h;
      y.xR[2] = 2 * h;
      y.xR[3] = 3 * h;
      w.xR[0] = -1 / (x.xR[1] - x.xR[0]);
      w.xR[1] = 1 * (1 / (x.xR[1] - x.xR[0]) + 1 / (x.xR[2] - x.xR[1]));
      w.xR[2] = -1 * (1 / (x.xR[2] - x.xR[1]) + 1 / (x.xR[3] - x.xR[2]));
      w.xR[3] = 1 / (x.xR[3] - x.xR[2]);
      v0 = 0.0;
      if (pass / 2 == 0) {
         v0 = 0.0;
      }
      if (pass / 2 == 1) {
         v0 = 0.6 * h;
      }
      barycentricbuildxyw(&x, &y, &w, 4, &b1);
      t = barycentriccalc(&b1, v0);
      d0 = 0.0;
      d1 = 0.0;
      d2 = 0.0;
      barycentricdiff1(&b1, v0, &d0, &d1);
      bcOk = bcOk && NearAtR(t, v0, threshold * v0);
      bcOk = bcOk && NearAtR(d0, v0, threshold * v0);
      bcOk = bcOk && NearAtR(d1, 1, 1000 * threshold);
   }
// crash test: large abscissas, small argument
//
// test for errors in D0 is not very strict
// because renormalization used in Diff1()
// destroys part of precision.
   ae_vector_set_length(&x, 4);
   ae_vector_set_length(&y, 4);
   ae_vector_set_length(&w, 4);
   h = 0.01 * maxrealnumber;
   x.xR[0] = 0 * h;
   x.xR[1] = 1 * h;
   x.xR[2] = 2 * h;
   x.xR[3] = 3 * h;
   y.xR[0] = 0 * h;
   y.xR[1] = 1 * h;
   y.xR[2] = 2 * h;
   y.xR[3] = 3 * h;
   w.xR[0] = -1 / (x.xR[1] - x.xR[0]);
   w.xR[1] = 1 * (1 / (x.xR[1] - x.xR[0]) + 1 / (x.xR[2] - x.xR[1]));
   w.xR[2] = -1 * (1 / (x.xR[2] - x.xR[1]) + 1 / (x.xR[3] - x.xR[2]));
   w.xR[3] = 1 / (x.xR[3] - x.xR[2]);
   v0 = 100 * minrealnumber;
   barycentricbuildxyw(&x, &y, &w, 4, &b1);
   t = barycentriccalc(&b1, v0);
   d0 = 0.0;
   d1 = 0.0;
   d2 = 0.0;
   barycentricdiff1(&b1, v0, &d0, &d1);
   bcOk = bcOk && SmallAtR(t, v0 * (1 + threshold));
   bcOk = bcOk && SmallAtR(d0, v0 * (1 + threshold));
   bcOk = bcOk && NearAtR(d1, 1, 1000 * threshold);
// crash test: test safe barycentric formula
   ae_vector_set_length(&x, 4);
   ae_vector_set_length(&y, 4);
   ae_vector_set_length(&w, 4);
   h = 2 * minrealnumber;
   x.xR[0] = 0 * h;
   x.xR[1] = 1 * h;
   x.xR[2] = 2 * h;
   x.xR[3] = 3 * h;
   y.xR[0] = 0 * h;
   y.xR[1] = 1 * h;
   y.xR[2] = 2 * h;
   y.xR[3] = 3 * h;
   w.xR[0] = -1 / (x.xR[1] - x.xR[0]);
   w.xR[1] = 1 * (1 / (x.xR[1] - x.xR[0]) + 1 / (x.xR[2] - x.xR[1]));
   w.xR[2] = -1 * (1 / (x.xR[2] - x.xR[1]) + 1 / (x.xR[3] - x.xR[2]));
   w.xR[3] = 1 / (x.xR[3] - x.xR[2]);
   v0 = minrealnumber;
   barycentricbuildxyw(&x, &y, &w, 4, &b1);
   t = barycentriccalc(&b1, v0);
   bcOk = bcOk && NearAtR(t, v0, v0 * threshold);
// Testing "No Poles" interpolation
   maxerr = 0.0;
   for (pass = 0; pass < passcount; pass++) { //(@) Was originally for (pass = 1; ...).
      ae_vector_set_length(&x, 1);
      ae_vector_set_length(&y, 1);
      x.xR[0] = randommid();
      y.xR[0] = randommid();
      barycentricbuildfloaterhormann(&x, &y, 1, 1, &b1);
      maxerr = rmax2(maxerr, fabs(barycentriccalc(&b1, randommid()) - y.xR[0]));
   }
   for (n = 2; n <= 10; n++) {
   // compare interpolant built by subroutine
   // with interpolant built by hands
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      ae_vector_set_length(&w, n);
      ae_vector_set_length(&w2, n);
   // D == 1, non-equidistant nodes
      for (pass = 1; pass <= passcount; pass++) {
      // Initialize X, Y, W
         a = -1.0 - randomreal();
         b = +1.0 + randomreal();
         for (i = 0; i < n; i++) {
            x.xR[i] = atan((b - a) * i / (n - 1) + a);
         }
         for (i = 0; i < n; i++) {
            y.xR[i] = randommid();
         }
         w.xR[0] = -1 / (x.xR[1] - x.xR[0]);
         s = 1.0;
         for (i = 1; i < n - 1; i++) {
            w.xR[i] = s * (1 / (x.xR[i] - x.xR[i - 1]) + 1 / (x.xR[i + 1] - x.xR[i]));
            s = -s;
         }
         w.xR[n - 1] = s / (x.xR[n - 1] - x.xR[n - 2]);
         for (i = 0; i < n; i++) {
            k = randominteger(n);
            if (k != i) {
               swapr(&x.xR[i], &x.xR[k]);
               swapr(&y.xR[i], &y.xR[k]);
               swapr(&w.xR[i], &w.xR[k]);
            }
         }
      // Build and test
         barycentricbuildfloaterhormann(&x, &y, n, 1, &b1);
         barycentricbuildxyw(&x, &y, &w, n, &b2);
         for (i = 1; i <= 2 * n; i++) {
            t = a + (b - a) * randomreal();
            maxerr = rmax2(maxerr, fabs(barycentriccalc(&b1, t) - barycentriccalc(&b2, t)));
         }
      }
   // D = 0, 1, 2. Equidistant nodes.
      for (d = 0; d <= 2; d++) {
         for (pass = 1; pass <= passcount; pass++) {
         // Skip incorrect (N,D) pairs
            if (n < 2 * d) {
               continue;
            }
         // Initialize X, Y, W
            a = -1.0 - randomreal();
            b = +1.0 + randomreal();
            for (i = 0; i < n; i++) {
               x.xR[i] = (b - a) * i / (n - 1) + a;
            }
            for (i = 0; i < n; i++) {
               y.xR[i] = randommid();
            }
            s = 1.0;
            if (d == 0) {
               for (i = 0; i < n; i++) {
                  w.xR[i] = s;
                  s = -s;
               }
            }
            if (d == 1) {
               w.xR[0] = -s;
               for (i = 1; i < n - 1; i++) {
                  w.xR[i] = 2 * s;
                  s = -s;
               }
               w.xR[n - 1] = s;
            }
            if (d == 2) {
               w.xR[0] = s;
               w.xR[1] = -3 * s;
               for (i = 2; i < n - 2; i++) {
                  w.xR[i] = 4 * s;
                  s = -s;
               }
               w.xR[n - 2] = 3 * s;
               w.xR[n - 1] = -s;
            }
         // Mix
            for (i = 0; i < n; i++) {
               k = randominteger(n);
               if (k != i) {
                  swapr(&x.xR[i], &x.xR[k]);
                  swapr(&y.xR[i], &y.xR[k]);
                  swapr(&w.xR[i], &w.xR[k]);
               }
            }
         // Build and test
            barycentricbuildfloaterhormann(&x, &y, n, d, &b1);
            barycentricbuildxyw(&x, &y, &w, n, &b2);
            for (i = 1; i <= 2 * n; i++) {
               t = a + (b - a) * randomreal();
               maxerr = rmax2(maxerr, fabs(barycentriccalc(&b1, t) - barycentriccalc(&b2, t)));
            }
         }
      }
   }
   if (maxerr > threshold) {
      npOk = false;
   }
// The final report.
   Ok = bcOk && npOk;
   if (!Ok || !silent) {
      printf("Rational Interpolation Tests\n");
      printf("Basic Barycentric Functions:              %s\n", bcOk? "Ok": "Failed");
      printf("Floater-Hormann:                          %s\n", npOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
// end
   ae_frame_leave();
   return Ok;
}

// === idw testing unit ===
// Testing continuity properties: C0 (D == 0) or C1 (D == 1) continuity.
static bool testidwunit_testcontinuity(idwmodel *model, ae_int_t nx, ae_int_t ny, RVector *x0, RVector *x1, ae_int_t nsteps, ae_int_t d) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t cidx;
   double t;
   double lc1;
   double lc2;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewMatrix(yy, 0, 0, DT_REAL);
   ae_assert(nsteps >= 10, "TestContinuity: NSteps is too small");
   ae_assert(d == 0 || d == 1, "TestContinuity: incorrect D");
// Compute sequence of function values
   ae_vector_set_length(&xc, nx);
   ae_matrix_set_length(&yy, nsteps, ny);
   for (i = 0; i < nsteps; i++) {
      t = (double)i / (nsteps - 1);
      for (j = 0; j < nx; j++) {
         xc.xR[j] = x0->xR[j] * t + x1->xR[j] * (1 - t);
      }
      idwcalcbuf(model, &xc, &yc);
      for (j = 0; j < ny; j++) {
         yy.xyR[i][j] = yc.xR[j];
      }
   }
// Evaluate all differentiability levels (C0, C1) requested by user
   for (cidx = 0; cidx <= d; cidx++) {
   // Compute Lipschitz constant for original and increased steps
      lc1 = 0.0;
      lc2 = 0.0;
      for (i = 0; i < nsteps - 2; i++) {
         for (j = 0; j < ny; j++) {
            lc1 = rmax2(lc1, fabs(yy.xyR[i][j] - yy.xyR[i + 1][j]));
            lc2 = rmax2(lc2, fabs(yy.xyR[i][j] - yy.xyR[i + 2][j]) / 2);
         }
      }
      Ok = Ok && (lc2 <= 1.0E-4 || lc1 <= 1.750 * lc2);
   // Differentiate function, repeat one more time
      for (i = 0; i < nsteps - 1; i++) {
         for (j = 0; j < ny; j++) {
            yy.xyR[i][j] = yy.xyR[i + 1][j] - yy.xyR[i][j];
         }
      }
      nsteps--;
   }
   ae_frame_leave();
   return Ok;
}

// Test MSTAB.
static bool testidwunit_testcommon() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t algotype;
   ae_int_t i;
   ae_int_t i0;
   ae_int_t i1;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   double v;
   double vv;
   bool initdone;
   double shepardp;
   double rbase;
   double tol;
   double mindistinf;
   double refrms;
   double refavg;
   double refmax;
   double refr2;
   double refrss;
   double reftss;
   ae_int_t nx;
   ae_int_t ny;
   double x0;
   double x1;
   double x2;
   ae_int_t continuitytesting;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(idwmodel, model);
   NewObj(idwmodel, model1);
   NewObj(idwbuilder, builder);
   NewObj(idwreport, rep);
   NewObj(idwcalcbuffer, buffer);
   NewObj(hqrndstate, rs);
   NewVector(x, 0, DT_REAL);
   NewVector(xx, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(meany, 0, DT_REAL);
   hqrndrandomize(&rs);
   tol = 1.0E-10;
   mindistinf = 0.05;
// Try all algorithms
   for (algotype = 0; algotype <= 2; algotype++) {
   // Test empty dataset
      for (nx = 1; nx <= 5; nx++) {
         for (ny = 1; ny <= 5; ny++) {
            initdone = false;
            idwbuildercreate(nx, ny, &builder);
            if (algotype == 0) {
               initdone = true;
               shepardp = 1.0 + (nx + 1) * hqrnduniformr(&rs);
               idwbuildersetalgotextbookshepard(&builder, shepardp);
            }
            if (algotype == 1) {
               initdone = true;
               rbase = pow(2.0, 2.0 * hqrndmiduniformr(&rs));
               idwbuildersetalgotextbookmodshepard(&builder, rbase);
            }
            if (algotype == 2) {
               initdone = true;
               rbase = pow(2.0, 2.0 * hqrndmiduniformr(&rs));
               idwbuildersetalgomstab(&builder, rbase);
            }
            ae_assert(initdone, "TestCommon: unexpected AlgoType");
            if (hqrndnormal(&rs) > 0.0) {
            // Fit and store result directly into the variable
               idwfit(&builder, &model, &rep);
            } else {
            // Fit, store result to temporary, pass through the serializer
               idwfit(&builder, &model1, &rep);
               {
               // This code passes data structure through serializers
               // (serializes it to string and loads back)
                  ae_frame _local_frame_block;
                  ae_frame_make(&_local_frame_block);
                  NewSerializer(_local_serializer);
                  ae_serializer_alloc_start(&_local_serializer);
                  idwalloc(&_local_serializer, &model1);
                  ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                  NewBlock(_local_dynamic_block, _local_ssize + 1);
                  ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  idwserialize(&_local_serializer, &model1);
                  ae_serializer_stop(&_local_serializer);
                  ae_serializer_init(&_local_serializer);
                  ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  idwunserialize(&_local_serializer, &model);
                  ae_serializer_stop(&_local_serializer);
                  ae_frame_leave();
               }
            }
            idwcreatecalcbuffer(&model, &buffer);
         // Test report
            Ok = Ok && rep.rmserror == 0.0;
            Ok = Ok && rep.avgerror == 0.0;
            Ok = Ok && rep.maxerror == 0.0;
            Ok = Ok && rep.r2 == 1.0;
         // Test simplified evaluation
            x0 = hqrndnormal(&rs);
            x1 = hqrndnormal(&rs);
            x2 = hqrndnormal(&rs);
            if (nx == 1 && ny == 1) {
               Ok = Ok && idwcalc1(&model, x0) == 0.0;
            }
            if (nx == 2 && ny == 1) {
               Ok = Ok && idwcalc2(&model, x0, x1) == 0.0;
            }
            if (nx == 3 && ny == 1) {
               Ok = Ok && idwcalc3(&model, x0, x1, x2) == 0.0;
            }
         // Test generic evaluation
            ae_vector_set_length(&x, nx);
            for (i = 0; i < nx; i++) {
               x.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&y, 0);
            idwcalc(&model, &x, &y);
            Ok = Ok && y.cnt == ny;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < ny; i++) {
               Ok = Ok && y.xR[i] == 0.0;
            }
            ae_vector_set_length(&y, 0);
            idwcalcbuf(&model, &x, &y);
            Ok = Ok && y.cnt == ny;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < ny; i++) {
               Ok = Ok && y.xR[i] == 0.0;
            }
            ae_vector_set_length(&y, 0);
            idwtscalcbuf(&model, &buffer, &x, &y);
            Ok = Ok && y.cnt == ny;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < ny; i++) {
               Ok = Ok && y.xR[i] == 0.0;
            }
         }
      }
   // Generate random dataset with distinct points, test interpolation
   // properties (target function is reproduced almost exactly, the model
   // is continuous)
      for (pass = 1; pass <= 20; pass++) {
         n = 1 + hqrnduniformi(&rs, 25);
         nx = 1 + hqrnduniformi(&rs, 4);
         ny = 1 + hqrnduniformi(&rs, 4);
         ae_vector_set_length(&x, nx);
         ae_vector_set_length(&xx, nx);
         ae_vector_set_length(&y, ny);
      // Generate dataset with distinct points
         ae_matrix_set_length(&xy, n, nx + ny);
         ae_vector_set_length(&meany, ny);
         for (j = 0; j < ny; j++) {
            meany.xR[j] = 0.0;
         }
         i = 0;
         while (i < n) {
         // Generate random point
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = hqrndnormal(&rs);
            }
         // Test distance between newly generated point and other ones.
         // Repeat point generation if it is too close to some other point.
            v = maxrealnumber;
            for (i0 = 0; i0 < i; i0++) {
               vv = 0.0;
               for (j = 0; j < nx; j++) {
                  vv = rmax2(vv, fabs(xy.xyR[i][j] - xy.xyR[i0][j]));
               }
               v = rmin2(v, vv);
            }
            if (v < mindistinf) {
               continue;
            }
         // Point is accepted
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = hqrndnormal(&rs);
               meany.xR[j] += xy.xyR[i][nx + j] / n;
            }
            i++;
         }
      // Build IDW model
         initdone = false;
         idwbuildercreate(nx, ny, &builder);
         if (algotype == 0) {
            initdone = true;
            shepardp = 1.0 + (nx + 1) * hqrnduniformr(&rs);
            idwbuildersetalgotextbookshepard(&builder, shepardp);
         }
         if (algotype == 1) {
            initdone = true;
            rbase = pow(2.0, 2.0 * hqrndmiduniformr(&rs));
            idwbuildersetalgotextbookmodshepard(&builder, rbase);
         }
         if (algotype == 2) {
            initdone = true;
            rbase = pow(2.0, 2.0 * hqrndmiduniformr(&rs));
            idwbuildersetalgomstab(&builder, rbase);
         }
         ae_assert(initdone, "TestCommon: unexpected AlgoType");
         idwbuildersetpoints(&builder, &xy, n);
         if (hqrndnormal(&rs) > 0.0) {
         // Fit and store result directly into the variable
            idwfit(&builder, &model, &rep);
         } else {
         // Fit, store result to temporary, pass through the serializer
            idwfit(&builder, &model1, &rep);
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               idwalloc(&_local_serializer, &model1);
               ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               idwserialize(&_local_serializer, &model1);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               idwunserialize(&_local_serializer, &model);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
         }
         idwcreatecalcbuffer(&model, &buffer);
      // Test error metrics
      //
      // NOTE: we expect that dataset is reproduced exactly
         Ok = Ok && SmallAtR(rep.rmserror, tol);
         Ok = Ok && SmallAtR(rep.avgerror, tol);
         Ok = Ok && SmallAtR(rep.maxerror, tol);
         Ok = Ok && !SmallR(rep.r2, 1 - tol);
      // Test that dataset is actually exactly reproduced
         for (i = 0; i < n; i++) {
         // Test generic evaluation
            for (j = 0; j < nx; j++) {
               x.xR[j] = xy.xyR[i][j];
            }
            ae_vector_set_length(&y, 0);
            idwcalc(&model, &x, &y);
            Ok = Ok && y.cnt == ny;
            for (j = 0; j < ny; j++) {
               Ok = Ok && NearAtR(y.xR[j], xy.xyR[i][nx + j], tol);
            }
            k = hqrnduniformi(&rs, 2 * ny + 1);
            ae_vector_set_length(&y, k);
            for (j = 0; j < y.cnt; j++) {
               y.xR[j] = 0.0;
            }
            idwcalcbuf(&model, &x, &y);
            Ok = Ok && y.cnt == imax2(ny, k);
            for (j = 0; j < ny; j++) {
               Ok = Ok && NearAtR(y.xR[j], xy.xyR[i][nx + j], tol);
            }
            k = hqrnduniformi(&rs, 2 * ny + 1);
            ae_vector_set_length(&y, k);
            for (j = 0; j < y.cnt; j++) {
               y.xR[j] = 0.0;
            }
            idwtscalcbuf(&model, &buffer, &x, &y);
            Ok = Ok && y.cnt == imax2(ny, k);
            for (j = 0; j < ny; j++) {
               Ok = Ok && NearAtR(y.xR[j], xy.xyR[i][nx + j], tol);
            }
         // Specialized 1, 2, 3-dimensional cases
            if (ny == 1) {
               if (nx == 1) {
                  Ok = Ok && NearAtR(idwcalc1(&model, x.xR[0]), xy.xyR[i][nx], tol);
               }
               if (nx == 2) {
                  Ok = Ok && NearAtR(idwcalc2(&model, x.xR[0], x.xR[1]), xy.xyR[i][nx], tol);
               }
               if (nx == 3) {
                  Ok = Ok && NearAtR(idwcalc3(&model, x.xR[0], x.xR[1], x.xR[2]), xy.xyR[i][nx], tol);
               }
            }
         }
      // Test continuity properties:
      // * continuity is guaranteed for original Shepard's method, MSTAB and MSMOOTH
      // * modified Shepard method does not guarantee continuity of the model, but
      //   we can be sure that model is continuous along line connecting two nearest
      //   points
         for (k = 0; k <= 1; k++) {
            i0 = hqrnduniformi(&rs, n);
            for (j = 0; j < nx; j++) {
               x.xR[j] = xy.xyR[i0][j];
            }
            i1 = -1;
            v = maxrealnumber;
            for (i = 0; i < n; i++) {
               vv = 0.0;
               for (j = 0; j < nx; j++) {
                  vv += sqr(x.xR[j] - xy.xyR[i][j]);
               }
               if (vv < v && vv > 0.0) {
                  i1 = i;
                  for (j = 0; j < nx; j++) {
                     xx.xR[j] = xy.xyR[i][j];
                  }
                  v = vv;
               }
            }
            if (i1 < 0) {
               i1 = hqrnduniformi(&rs, n);
               for (j = 0; j < nx; j++) {
                  xx.xR[j] = xy.xyR[i1][j];
               }
            }
            continuitytesting = 1;
            if (algotype == 0) {
               continuitytesting = 0;
            }
            if (algotype == 1) {
               continuitytesting = -1;
            }
            if (continuitytesting >= 0) {
               Ok = Ok && testidwunit_testcontinuity(&model, nx, ny, &x, &xx, 10000, continuitytesting);
            }
         }
      // Test evaluation at remote points
         ae_vector_set_length(&x, nx);
         for (j = 0; j < nx; j++) {
            x.xR[j] = 1.0E20 * (2 * hqrnduniformi(&rs, 2) - 1);
         }
         idwcalc(&model, &x, &y);
         for (j = 0; j < ny; j++) {
            Ok = Ok && NearAtR(y.xR[j], meany.xR[j], tol);
         }
      }
   // Generate random dataset with NONDISTINCT points, test approximation
   // properties and error reports.
      for (pass = 1; pass <= 20; pass++) {
         n = 2 * (1 + hqrnduniformi(&rs, 10));
         nx = 1 + hqrnduniformi(&rs, 4);
         ny = 1 + hqrnduniformi(&rs, 4);
         ae_vector_set_length(&x, nx);
         ae_vector_set_length(&xx, nx);
         ae_vector_set_length(&y, ny);
         ae_vector_set_length(&meany, ny);
      // Generate dataset with nondistinct points, each point is repeated;
      // compute reference values of the error metrics
         ae_matrix_set_length(&xy, n, nx + ny);
         refrms = 0.0;
         refavg = 0.0;
         refmax = 0.0;
         refrss = 0.0;
         reftss = 0.0;
         for (j = 0; j < ny; j++) {
            meany.xR[j] = 0.0;
         }
         i = 0;
         while (i < n / 2) {
         // Generate two copies of the same point
            for (j = 0; j < nx + ny; j++) {
               v = hqrndnormal(&rs);
               xy.xyR[2 * i][j] = v;
               xy.xyR[2 * i + 1][j] = v;
            }
         // Test distance between newly generated point and other ones.
         // Repeat point generation if it is too close to some other point.
            v = maxrealnumber;
            for (i0 = 0; i0 < 2 * i; i0++) {
               vv = 0.0;
               for (j = 0; j < nx; j++) {
                  vv = rmax2(vv, fabs(xy.xyR[2 * i][j] - xy.xyR[i0][j]));
               }
               v = rmin2(v, vv);
            }
            if (v < mindistinf) {
               continue;
            }
         // Update meanY
            for (j = 0; j < ny; j++) {
               meany.xR[j] += (xy.xyR[2 * i][nx + j] + xy.xyR[2 * i + 1][nx + j]) / n;
            }
         // Apply perturbation to the target value
            for (j = 0; j < ny; j++) {
               v = pow(2.0, hqrndnormal(&rs));
               xy.xyR[2 * i][nx + j] += v;
               xy.xyR[2 * i + 1][nx + j] -= v;
               v = fabs(v);
               refrms += 2 * v * v;
               refavg += 2 * v;
               refmax = rmax2(refmax, v);
               refrss += 2 * v * v;
            }
         // Next I
            i++;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < ny; j++) {
               reftss += sqr(xy.xyR[i][nx + j] - meany.xR[j]);
            }
         }
         refrms = sqrt(refrms / (n * ny));
         refavg /= n * ny;
         refr2 = 1.0 - refrss / coalesce(reftss, 1.0);
      // Build IDW model
         initdone = false;
         idwbuildercreate(nx, ny, &builder);
         if (algotype == 0) {
            initdone = true;
            shepardp = nx * (1.0 + hqrnduniformr(&rs));
            idwbuildersetalgotextbookshepard(&builder, shepardp);
         }
         if (algotype == 1) {
            initdone = true;
            rbase = pow(2.0, 2.0 * hqrndmiduniformr(&rs));
            idwbuildersetalgotextbookmodshepard(&builder, rbase);
         }
         if (algotype == 2) {
            initdone = true;
            rbase = pow(2.0, 2.0 * hqrndmiduniformr(&rs));
            idwbuildersetalgomstab(&builder, rbase);
         }
         ae_assert(initdone, "TestCommon: unexpected AlgoType");
         idwbuildersetpoints(&builder, &xy, n);
         if (hqrndnormal(&rs) > 0.0) {
         // Fit and store result directly into the variable
            idwfit(&builder, &model, &rep);
         } else {
         // Fit, store result to temporary, pass through the serializer
            idwfit(&builder, &model1, &rep);
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               idwalloc(&_local_serializer, &model1);
               ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               idwserialize(&_local_serializer, &model1);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               idwunserialize(&_local_serializer, &model);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
         }
         idwcreatecalcbuffer(&model, &buffer);
      // Test error metrics
         Ok = Ok && NearAtR(rep.rmserror, refrms, tol);
         Ok = Ok && NearAtR(rep.avgerror, refavg, tol);
         Ok = Ok && NearAtR(rep.maxerror, refmax, tol);
         Ok = Ok && NearAtR(rep.r2, refr2, tol);
      // Test ability to reproduce mean over non-distinct points
      //
      // NOTE: we do not test all evaluation functions, just IDWCalc()
         for (i = 0; i < n / 2; i++) {
            for (j = 0; j < nx; j++) {
               x.xR[j] = xy.xyR[2 * i][j];
            }
            idwcalc(&model, &x, &y);
            for (j = 0; j < ny; j++) {
               Ok = Ok && NearAtR(y.xR[j], 0.5 * (xy.xyR[2 * i][nx + j] + xy.xyR[2 * i + 1][nx + j]), tol);
            }
         }
      // Test continuity properties:
      // * continuity is guaranteed for original Shepard's method, MSTAB and MSMOOTH
      // * modified Shepard method does not guarantee continuity of the model, but
      //   we can be sure that model is continuous along line connecting two nearest
      //   points
         for (k = 0; k <= 1; k++) {
            i0 = hqrnduniformi(&rs, n);
            for (j = 0; j < nx; j++) {
               x.xR[j] = xy.xyR[i0][j];
            }
            i1 = -1;
            v = maxrealnumber;
            for (i = 0; i < n; i++) {
               vv = 0.0;
               for (j = 0; j < nx; j++) {
                  vv += sqr(x.xR[j] - xy.xyR[i][j]);
               }
               if (vv < v && vv > 0.0) {
                  i1 = i;
                  for (j = 0; j < nx; j++) {
                     xx.xR[j] = xy.xyR[i][j];
                  }
                  v = vv;
               }
            }
            if (i1 < 0) {
               i1 = hqrnduniformi(&rs, n);
               for (j = 0; j < nx; j++) {
                  xx.xR[j] = xy.xyR[i1][j];
               }
            }
            continuitytesting = 1;
            if (algotype == 0) {
               continuitytesting = 0;
            }
            if (algotype == 1) {
               continuitytesting = -1;
            }
            if (continuitytesting >= 0) {
               Ok = Ok && testidwunit_testcontinuity(&model, nx, ny, &x, &xx, 10000, continuitytesting);
            }
         }
      }
   // Test correct handling of the prior term
      n = 10;
      for (pass = 1; pass <= 20; pass++) {
         nx = 1 + hqrnduniformi(&rs, 4);
         ny = 1 + hqrnduniformi(&rs, 4);
         ae_vector_set_length(&x, nx);
         ae_vector_set_length(&y, ny);
         ae_matrix_set_length(&xy, n, nx + ny);
         ae_vector_set_length(&meany, ny);
         for (j = 0; j < ny; j++) {
            meany.xR[j] = 0.0;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = hqrndnormal(&rs);
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = hqrndnormal(&rs);
               meany.xR[j] += xy.xyR[i][nx + j] / n;
            }
         }
         initdone = false;
         idwbuildercreate(nx, ny, &builder);
         if (algotype == 0) {
            initdone = true;
            shepardp = 1.0 + (nx + 1) * hqrnduniformr(&rs);
            idwbuildersetalgotextbookshepard(&builder, shepardp);
         }
         if (algotype == 1) {
            initdone = true;
            rbase = pow(2.0, 2.0 * hqrndmiduniformr(&rs));
            idwbuildersetalgotextbookmodshepard(&builder, rbase);
         }
         if (algotype == 2) {
            initdone = true;
            rbase = pow(2.0, 2.0 * hqrndmiduniformr(&rs));
            idwbuildersetalgomstab(&builder, rbase);
         }
         ae_assert(initdone, "TestCommon: unexpected AlgoType (prior test)");
         idwbuildersetpoints(&builder, &xy, n);
      // Zero prior (not tested with textbook Shepard method)
         if (algotype != 0) {
            idwbuildersetzeroterm(&builder);
            idwfit(&builder, &model, &rep);
            for (j = 0; j < nx; j++) {
               x.xR[j] = 1.0E20 * (2 * hqrnduniformi(&rs, 2) - 1);
            }
            idwcalc(&model, &x, &y);
            for (j = 0; j < ny; j++) {
               Ok = Ok && SmallAtR(y.xR[j], tol);
            }
         }
      // Mean prior
         idwbuildersetconstterm(&builder);
         idwfit(&builder, &model, &rep);
         for (j = 0; j < nx; j++) {
            x.xR[j] = 1.0E20 * (2 * hqrnduniformi(&rs, 2) - 1);
         }
         idwcalc(&model, &x, &y);
         for (j = 0; j < ny; j++) {
            Ok = Ok && NearAtR(y.xR[j], meany.xR[j], tol);
         }
      // User-specified prior (not tested with textbook Shepard method)
         if (algotype != 0) {
            v = hqrndnormal(&rs);
            idwbuildersetuserterm(&builder, v);
            idwfit(&builder, &model, &rep);
            for (j = 0; j < nx; j++) {
               x.xR[j] = 1.0E20 * (2 * hqrnduniformi(&rs, 2) - 1);
            }
            idwcalc(&model, &x, &y);
            for (j = 0; j < ny; j++) {
               Ok = Ok && NearAtR(y.xR[j], v, tol);
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test MSTAB.
static bool testidwunit_testmstab() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t n;
   double v;
   double vv;
   double x0;
   double x1;
   double rbase;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(idwmodel, model);
   NewObj(idwbuilder, builder);
   NewObj(idwreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Basic test #1: nonzero derivative
// * XY = [[-1,-1],[0,0,],[1,1]]
// * RBase >= 2
// * derivative at x == 0 must be positive and bigger than 0.1
   ae_matrix_set_length(&xy, 3, 2);
   for (i = 0; i <= 2; i++) {
      xy.xyR[i][0] = (double)(i - 1);
      xy.xyR[i][1] = (double)(i - 1);
   }
   idwbuildercreate(1, 1, &builder);
   rbase = pow(2.0, 1.0 + hqrnduniformr(&rs));
   idwbuildersetalgomstab(&builder, rbase);
   idwbuildersetpoints(&builder, &xy, 3);
   idwfit(&builder, &model, &rep);
   v = 0.01;
   Ok = Ok && (idwcalc1(&model, v) - idwcalc1(&model, -v)) / (2 * v) >= 0.1;
// Basic test #2: good smoothness
// * 2D task, dataset is composed from 3 parallel lines
//   along y == -0.1, y == 0, y == +0.1, with outer lines having
//   constant zero target value, inner line having constant
//   target equal to 1
// * RBase == 1 is used
// * we test that function value does not change significantly
//   along the line
   n = 100;
   ae_matrix_set_length(&xy, 3 * n, 3);
   for (i = 0; i < n; i++) {
      xy.xyR[3 * i][0] = (double)i / (n - 1);
      xy.xyR[3 * i][1] = -0.1;
      xy.xyR[3 * i][2] = 0.0;
      xy.xyR[3 * i + 1][0] = (double)i / (n - 1);
      xy.xyR[3 * i + 1][1] = 0.0;
      xy.xyR[3 * i + 1][2] = 1.0;
      xy.xyR[3 * i + 2][0] = (double)i / (n - 1);
      xy.xyR[3 * i + 2][1] = 0.1;
      xy.xyR[3 * i + 2][2] = 0.0;
   }
   rbase = 1.0;
   idwbuildercreate(2, 1, &builder);
   idwbuildersetalgomstab(&builder, rbase);
   idwbuildersetpoints(&builder, &xy, 3 * n);
   idwfit(&builder, &model, &rep);
   v = 0.0;
   for (i = 0; i <= 1000; i++) {
      v = rmax2(v, fabs(idwcalc2(&model, hqrnduniformr(&rs), -0.1)));
      v = rmax2(v, fabs(idwcalc2(&model, hqrnduniformr(&rs), +0.1)));
      v = rmax2(v, fabs(idwcalc2(&model, hqrnduniformr(&rs), 0.0) - 1.0));
   }
   Ok = Ok && v <= 0.001;
// Continuity when moving away from the dataset
   ae_matrix_set_length(&xy, 1, 2);
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = 1.0;
   rbase = 1.0;
   idwbuildercreate(1, 1, &builder);
   idwbuildersetalgomstab(&builder, rbase);
   idwbuildersetpoints(&builder, &xy, 1);
   idwbuildersetzeroterm(&builder);
   idwfit(&builder, &model, &rep);
   Ok = Ok && idwcalc1(&model, 100000.0) == 0.0;
   v = 0.0;
   for (i = 0; i <= 500; i++) {
      x0 = 1.2 * rbase * ((double)i / 500.0);
      x1 = 1.2 * rbase * ((double)(i + 1) / 500.0);
      v = rmax2(v, fabs((idwcalc1(&model, x1) - idwcalc1(&model, x0)) / (x1 - x0)));
   }
   vv = 0.0;
   for (i = 0; i <= 1000; i++) {
      x0 = 1.2 * rbase * ((double)i / 1000.0);
      x1 = 1.2 * rbase * ((double)(i + 1) / 1000.0);
      vv = rmax2(vv, fabs((idwcalc1(&model, x1) - idwcalc1(&model, x0)) / (x1 - x0)));
   }
   Ok = Ok && vv / v <= 1.333;
   ae_frame_leave();
   return Ok;
}

// Testing IDW interpolation
bool testidw() {
   bool Ok;
   bool commonOk;
   bool mstabOk;
   commonOk = true;
   mstabOk = true;
   commonOk = commonOk && testidwunit_testcommon();
   mstabOk = mstabOk && testidwunit_testmstab();
// The final report.
   Ok = commonOk && mstabOk;
   if (!Ok || !silent) {
      printf("Inverse Distance Weighting Tests\n");
      printf("* Common Properties:                      %s\n", commonOk? "Ok": "Failed");
      printf("* MSTAB-Specific Tests:                   %s\n", mstabOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === polint testing unit ===
static double testpolintunit_internalpolint(RVector *x, RVector *f, ae_int_t n, double t) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double result;
   ae_frame_make(&_frame_block);
   DupVector(f);
   n--;
   for (j = 0; j < n; j++) {
      for (i = j + 1; i <= n; i++) {
         f->xR[i] = ((t - x->xR[j]) * f->xR[i] - (t - x->xR[i]) * f->xR[j]) / (x->xR[i] - x->xR[j]);
      }
   }
   result = f->xR[n];
   ae_frame_leave();
   return result;
}

static void testpolintunit_brcunset(barycentricinterpolant *b) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   ae_vector_set_length(&x, 1);
   ae_vector_set_length(&y, 1);
   ae_vector_set_length(&w, 1);
   x.xR[0] = 0.0;
   y.xR[0] = 0.0;
   w.xR[0] = 1.0;
   barycentricbuildxyw(&x, &y, &w, 1, b);
   ae_frame_leave();
}

// Unit test
bool testpolint() {
   ae_frame _frame_block;
   bool Ok;
   bool intOk;
   double threshold;
   double a;
   double b;
   double t;
   ae_int_t i;
   ae_int_t k;
   double v;
   double v0;
   double v1;
   double v2;
   double v3;
   double v4;
   double pscale;
   double poffset;
   double eps;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t pass;
   ae_int_t passcount;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(c, 0, DT_REAL);
   NewVector(c0, 0, DT_REAL);
   NewVector(c1, 0, DT_REAL);
   NewVector(c2, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(xfull, 0, DT_REAL);
   NewVector(yfull, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewVector(dc, 0, DT_INT);
   NewObj(barycentricinterpolant, p);
   NewObj(barycentricinterpolant, p1);
   NewObj(barycentricinterpolant, p2);
   Ok = true;
   intOk = true;
   maxn = 5;
   passcount = 20;
   threshold = 1.0E8 * machineepsilon;
// Test equidistant interpolation
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
      // prepare task:
      // * equidistant points
      // * random Y
      // * T in [A,B] or near (within 10% of its width)
         do {
            a = randommid();
            b = randommid();
         } while (NearAtR(a, b, 0.2));
         t = a + (1.2 * randomreal() - 0.1) * (b - a);
         taskgenint1dequidist(a, b, n, &x, &y);
      // test "fast" equidistant interpolation (no barycentric model)
         intOk = intOk && NearAtR(polynomialcalceqdist(a, b, &y, n, t), testpolintunit_internalpolint(&x, &y, n, t), threshold);
      // test "slow" equidistant interpolation (create barycentric model)
         testpolintunit_brcunset(&p);
         polynomialbuild(&x, &y, n, &p);
         intOk = intOk && NearAtR(barycentriccalc(&p, t), testpolintunit_internalpolint(&x, &y, n, t), threshold);
      // test "fast" interpolation (create "fast" barycentric model)
         testpolintunit_brcunset(&p);
         polynomialbuildeqdist(a, b, &y, n, &p);
         intOk = intOk && NearAtR(barycentriccalc(&p, t), testpolintunit_internalpolint(&x, &y, n, t), threshold);
      }
   }
// Test Chebyshev-1 interpolation
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
      // prepare task:
      // * equidistant points
      // * random Y
      // * T in [A,B] or near (within 10% of its width)
         do {
            a = randommid();
            b = randommid();
         } while (NearAtR(a, b, 0.2));
         t = a + (1.2 * randomreal() - 0.1) * (b - a);
         taskgenint1dcheb1(a, b, n, &x, &y);
      // test "fast" interpolation (no barycentric model)
         intOk = intOk && NearAtR(polynomialcalccheb1(a, b, &y, n, t), testpolintunit_internalpolint(&x, &y, n, t), threshold);
      // test "slow" interpolation (create barycentric model)
         testpolintunit_brcunset(&p);
         polynomialbuild(&x, &y, n, &p);
         intOk = intOk && NearAtR(barycentriccalc(&p, t), testpolintunit_internalpolint(&x, &y, n, t), threshold);
      // test "fast" interpolation (create "fast" barycentric model)
         testpolintunit_brcunset(&p);
         polynomialbuildcheb1(a, b, &y, n, &p);
         intOk = intOk && NearAtR(barycentriccalc(&p, t), testpolintunit_internalpolint(&x, &y, n, t), threshold);
      }
   }
// Test Chebyshev-2 interpolation
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
      // prepare task:
      // * equidistant points
      // * random Y
      // * T in [A,B] or near (within 10% of its width)
         do {
            a = randommid();
            b = randommid();
         } while (NearAtR(a, b, 0.2));
         t = a + (1.2 * randomreal() - 0.1) * (b - a);
         taskgenint1dcheb2(a, b, n, &x, &y);
      // test "fast" interpolation (no barycentric model)
         intOk = intOk && NearAtR(polynomialcalccheb2(a, b, &y, n, t), testpolintunit_internalpolint(&x, &y, n, t), threshold);
      // test "slow" interpolation (create barycentric model)
         testpolintunit_brcunset(&p);
         polynomialbuild(&x, &y, n, &p);
         intOk = intOk && NearAtR(barycentriccalc(&p, t), testpolintunit_internalpolint(&x, &y, n, t), threshold);
      // test "fast" interpolation (create "fast" barycentric model)
         testpolintunit_brcunset(&p);
         polynomialbuildcheb2(a, b, &y, n, &p);
         intOk = intOk && NearAtR(barycentriccalc(&p, t), testpolintunit_internalpolint(&x, &y, n, t), threshold);
      }
   }
// Testing conversion Barycentric<->Chebyshev
   for (pass = 1; pass <= passcount; pass++) {
      for (k = 1; k <= 3; k++) {
      // Allocate
         ae_vector_set_length(&x, k);
         ae_vector_set_length(&y, k);
      // Generate problem
         a = randommid();
         b = a + (0.1 + randomreal()) * (2 * randominteger(2) - 1);
         v0 = randommid();
         v1 = randommid();
         v2 = randommid();
         if (k == 1) {
            x.xR[0] = 0.5 * (a + b);
            y.xR[0] = v0;
         }
         if (k == 2) {
            x.xR[0] = a;
            y.xR[0] = v0 - v1;
            x.xR[1] = b;
            y.xR[1] = v0 + v1;
         }
         if (k == 3) {
            x.xR[0] = a;
            y.xR[0] = v0 - v1 + v2;
            x.xR[1] = 0.5 * (a + b);
            y.xR[1] = v0 - v2;
            x.xR[2] = b;
            y.xR[2] = v0 + v1 + v2;
         }
      // Test forward conversion
         polynomialbuild(&x, &y, k, &p);
         ae_vector_set_length(&c, 1);
         polynomialbar2cheb(&p, a, b, &c);
         intOk = intOk && c.cnt == k;
         if (k >= 1) {
            intOk = intOk && NearAtR(c.xR[0], v0, threshold);
         }
         if (k >= 2) {
            intOk = intOk && NearAtR(c.xR[1], v1, threshold);
         }
         if (k >= 3) {
            intOk = intOk && NearAtR(c.xR[2], v2, threshold);
         }
      // Test backward conversion
         polynomialcheb2bar(&c, k, a, b, &p2);
         v = a + randomreal() * (b - a);
         intOk = intOk && NearAtR(barycentriccalc(&p, v), barycentriccalc(&p2, v), threshold);
      }
   }
// Testing conversion Barycentric<->Power
   for (pass = 1; pass <= passcount; pass++) {
      for (k = 1; k <= 5; k++) {
      // Allocate
         ae_vector_set_length(&x, k);
         ae_vector_set_length(&y, k);
      // Generate problem
         poffset = randommid();
         pscale = (0.1 + randomreal()) * (2 * randominteger(2) - 1);
         v0 = randommid();
         v1 = randommid();
         v2 = randommid();
         v3 = randommid();
         v4 = randommid();
         if (k == 1) {
            x.xR[0] = poffset;
            y.xR[0] = v0;
         }
         if (k == 2) {
            x.xR[0] = poffset - pscale;
            y.xR[0] = v0 - v1;
            x.xR[1] = poffset + pscale;
            y.xR[1] = v0 + v1;
         }
         if (k == 3) {
            x.xR[0] = poffset - pscale;
            y.xR[0] = v0 - v1 + v2;
            x.xR[1] = poffset;
            y.xR[1] = v0;
            x.xR[2] = poffset + pscale;
            y.xR[2] = v0 + v1 + v2;
         }
         if (k == 4) {
            x.xR[0] = poffset - pscale;
            y.xR[0] = v0 - v1 + v2 - v3;
            x.xR[1] = poffset - 0.5 * pscale;
            y.xR[1] = v0 - 0.5 * v1 + 0.25 * v2 - 0.125 * v3;
            x.xR[2] = poffset + 0.5 * pscale;
            y.xR[2] = v0 + 0.5 * v1 + 0.25 * v2 + 0.125 * v3;
            x.xR[3] = poffset + pscale;
            y.xR[3] = v0 + v1 + v2 + v3;
         }
         if (k == 5) {
            x.xR[0] = poffset - pscale;
            y.xR[0] = v0 - v1 + v2 - v3 + v4;
            x.xR[1] = poffset - 0.5 * pscale;
            y.xR[1] = v0 - 0.5 * v1 + 0.25 * v2 - 0.125 * v3 + 0.0625 * v4;
            x.xR[2] = poffset;
            y.xR[2] = v0;
            x.xR[3] = poffset + 0.5 * pscale;
            y.xR[3] = v0 + 0.5 * v1 + 0.25 * v2 + 0.125 * v3 + 0.0625 * v4;
            x.xR[4] = poffset + pscale;
            y.xR[4] = v0 + v1 + v2 + v3 + v4;
         }
      // Test forward conversion
         polynomialbuild(&x, &y, k, &p);
         ae_vector_set_length(&c, 1);
         polynomialbar2pow(&p, poffset, pscale, &c);
         intOk = intOk && c.cnt == k;
         if (k >= 1) {
            intOk = intOk && NearAtR(c.xR[0], v0, threshold);
         }
         if (k >= 2) {
            intOk = intOk && NearAtR(c.xR[1], v1, threshold);
         }
         if (k >= 3) {
            intOk = intOk && NearAtR(c.xR[2], v2, threshold);
         }
         if (k >= 4) {
            intOk = intOk && NearAtR(c.xR[3], v3, threshold);
         }
         if (k >= 5) {
            intOk = intOk && NearAtR(c.xR[4], v4, threshold);
         }
      // Test backward conversion
         polynomialpow2bar(&c, k, poffset, pscale, &p2);
         v = poffset + randommid() * pscale;
         intOk = intOk && NearAtR(barycentriccalc(&p, v), barycentriccalc(&p2, v), threshold);
      }
   }
// crash-test: ability to solve tasks which will overflow/underflow
// weights with straightforward implementation
   for (n = 1; n <= 20; n++) {
      a = -0.1 * maxrealnumber;
      b = 0.1 * maxrealnumber;
      taskgenint1dequidist(a, b, n, &x, &y);
      polynomialbuild(&x, &y, n, &p);
      for (i = 0; i < n; i++) {
         intOk = intOk && p.w.xR[i] != 0.0;
      }
   }
// Test issue #634: instability in PolynomialBar2Pow().
//
// Function returns incorrect coefficients when called with
// approximately-unit scale for data which have significantly
// non-unit scale.
   n = 7;
   eps = 1.0E-8;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&x2, n);
   ae_vector_set_length(&y, n);
   x.xR[0] = randomreal() - 0.5;
   y.xR[0] = randomreal() - 0.5;
   for (i = 1; i < n; i++) {
      x.xR[i] = x.xR[i - 1] + randomreal() + 0.1;
      y.xR[i] = randomreal() - 0.5;
   }
   polynomialbuild(&x, &y, n, &p);
   polynomialbar2pow(&p, 0.0, 1.0, &c0);
   pscale = 1.0E-10;
   for (i = 0; i < n; i++) {
      x2.xR[i] = x.xR[i] * pscale;
   }
   polynomialbuild(&x2, &y, n, &p);
   polynomialbar2pow(&p, 0.0, 1.0, &c1);
   for (i = 0; i < n; i++) {
      intOk = intOk && NearAtR(c0.xR[i], c1.xR[i] * pow(pscale, (double)i), eps);
   }
   pscale = 1.0E10;
   for (i = 0; i < n; i++) {
      x2.xR[i] = x.xR[i] * pscale;
   }
   polynomialbuild(&x2, &y, n, &p);
   polynomialbar2pow(&p, 0.0, 1.0, &c2);
   for (i = 0; i < n; i++) {
      intOk = intOk && NearAtR(c0.xR[i], c2.xR[i] * pow(pscale, (double)i), eps);
   }
// The final report.
   Ok = intOk;
   if (!Ok || !silent) {
      printf("Polynomial Interpolation Test\n");
   // Normal tests
      printf("Interpolation Test:                       %s\n", intOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
// end
   ae_frame_leave();
   return Ok;
}

// === spline1d testing unit ===
// Lipschitz constants for spline itself, first and second derivatives.
static void testspline1dunit_lconst(double a, double b, spline1dinterpolant *c, double lstep, double *l0, double *l1, double *l2) {
   double t;
   double vl;
   double vm;
   double vr;
   double prevf;
   double prevd;
   double prevd2;
   double f;
   double d;
   double d2;
   *l0 = 0;
   *l1 = 0;
   *l2 = 0;
   *l0 = 0.0;
   *l1 = 0.0;
   *l2 = 0.0;
   t = a - 0.1;
   vl = spline1dcalc(c, t - 2 * lstep);
   vm = spline1dcalc(c, t - lstep);
   vr = spline1dcalc(c, t);
   f = vm;
   d = (vr - vl) / (2 * lstep);
   d2 = (vr - 2 * vm + vl) / sqr(lstep);
   while (t <= b + 0.1) {
      prevf = f;
      prevd = d;
      prevd2 = d2;
      vl = vm;
      vm = vr;
      vr = spline1dcalc(c, t + lstep);
      f = vm;
      d = (vr - vl) / (2 * lstep);
      d2 = (vr - 2 * vm + vl) / sqr(lstep);
      *l0 = rmax2(*l0, fabs((f - prevf) / lstep));
      *l1 = rmax2(*l1, fabs((d - prevd) / lstep));
      *l2 = rmax2(*l2, fabs((d2 - prevd2) / lstep));
      t += lstep;
   }
}

// This function is used to enumerate all spline types  which  can  be  built
// from given dataset. It should be used as follows:
//
// >
// > init X, Y, N
// > SplineIndex = 0;
// > while EnumerateAllSplines(X, Y, N, SplineIndex, S) do
// > begin
// >     do something with S
// > end;
// >
//
// On initial call EnumerateAllSplines accepts:
// * dataset X, Y, number of points N (N >= 2)
// * SplineIndex, equal to 0
//
// It returns:
// * True, in case there is a spline type which corresponds to SplineIndex.
//   In this case S contains spline which was built using X/Y and spline type,
//   as specified by input value of SplineIndex. SplineIndex is advanced to
//   the next value.
// * False, in case SplineIndex contains past-the-end value, spline is not built.
//
// This function tries different variants of linear/cubic, periodic/nonperiodic
// splines.
static bool testspline1dunit_enumerateallsplines(RVector *x, RVector *y, ae_int_t n, ae_int_t *splineindex, spline1dinterpolant *s) {
   ae_int_t idxoffs;
   bool Ok;
   SetObj(spline1dinterpolant, s);
   ae_assert(*splineindex >= 0, "Assertion failed");
   Ok = true;
   if (*splineindex == 0) {
   // Linear spline
      spline1dbuildlinear(x, y, n, s);
      ++*splineindex;
      Ok = false;
      return Ok;
   } else {
      if (*splineindex >= 1 && *splineindex < 11) {
      // Cubic spline, either periodic or non-periodic
         idxoffs = *splineindex - 1;
         if (idxoffs == 9) {
         // Periodic spline
            spline1dbuildcubic(x, y, n, -1, 0.0, -1, 0.0, s);
         } else {
         // Non-periodic spline
            spline1dbuildcubic(x, y, n, idxoffs / 3, randommid(), idxoffs % 3, randommid(), s);
         }
         ++*splineindex;
         Ok = false;
         return Ok;
      }
   }
   return Ok;
}

// Unpack testing
static bool testspline1dunit_testunpack(spline1dinterpolant *c, RVector *x) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t n;
   double err;
   double t;
   double v1;
   double v2;
   ae_int_t pass;
   ae_int_t passcount;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(tbl, 0, 0, DT_REAL);
   passcount = 20;
   err = 0.0;
   spline1dunpack(c, &n, &tbl);
   for (i = 0; i < n - 1; i++) {
      for (pass = 1; pass <= passcount; pass++) {
         t = randomreal() * (tbl.xyR[i][1] - tbl.xyR[i][0]);
         v1 = tbl.xyR[i][2] + t * tbl.xyR[i][3] + sqr(t) * tbl.xyR[i][4] + t * sqr(t) * tbl.xyR[i][5];
         v2 = spline1dcalc(c, tbl.xyR[i][0] + t);
         err = rmax2(err, fabs(v1 - v2));
      }
   }
   for (i = 0; i < n - 1; i++) {
      err = rmax2(err, fabs(x->xR[i] - tbl.xyR[i][0]));
   }
   for (i = 0; i < n - 1; i++) {
      err = rmax2(err, fabs(x->xR[i + 1] - tbl.xyR[i][1]));
   }
   Ok = err < 100.0 * machineepsilon;
   ae_frame_leave();
   return Ok;
}

// Unset spline, i.e. initialize it with random garbage
static void testspline1dunit_unsetspline1d(spline1dinterpolant *c) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   SetObj(spline1dinterpolant, c);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   ae_vector_set_length(&x, 2);
   ae_vector_set_length(&y, 2);
   ae_vector_set_length(&d, 2);
   x.xR[0] = -1.0;
   y.xR[0] = randomreal();
   d.xR[0] = randomreal();
   x.xR[1] = 1.0;
   y.xR[1] = randomreal();
   d.xR[1] = randomreal();
   spline1dbuildhermite(&x, &y, &d, 2, c);
   ae_frame_leave();
}

// Unset spline, i.e. initialize it with random garbage
static void testspline1dunit_unsetreport(spline1dfitreport *rep) {
   SetObj(spline1dfitreport, rep);
   rep->taskrcond = randomreal();
   rep->rmserror = randomreal();
   rep->avgerror = randomreal();
   rep->avgrelerror = randomreal();
   rep->maxerror = randomreal();
}

// Tests that built spline is monotone.
static bool testspline1dunit_testmonotonespline() {
   ae_frame _frame_block;
   double c0;
   double c1;
   ae_int_t m;
   ae_int_t alln;
   ae_int_t shift;
   double sign0;
   double sign1;
   double r;
   double st;
   double eps;
   double delta;
   double v;
   double dv;
   double d2v;
   ae_int_t nseg;
   ae_int_t npoints;
   ae_int_t tp;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t kmax;
   ae_int_t l;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(spline1dinterpolant, c);
   NewObj(spline1dinterpolant, s2);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(n, 0, DT_INT);
   eps = 100.0 * machineepsilon;
// Special test - N == 2.
//
// Following properties are tested:
// * monotone spline must be equal to the Hermite spline with
//   zero derivative at the ends
// * monotone spline is constant beyond left/right boundaries
   ae_vector_set_length(&x, 2);
   ae_vector_set_length(&y, 2);
   ae_vector_set_length(&d, 2);
   x.xR[0] = -0.1 - randomreal();
   y.xR[0] = randommid();
   d.xR[0] = 0.0;
   x.xR[1] = 0.1 + randomreal();
   y.xR[1] = y.xR[0];
   d.xR[1] = 0.0;
   spline1dbuildmonotone(&x, &y, 2, &c);
   spline1dbuildhermite(&x, &y, &d, 2, &s2);
   v = randommid();
   if (!NearAtR(spline1dcalc(&c, v), spline1dcalc(&s2, v), eps)) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   if (spline1dcalc(&c, -5.0) != y.xR[0]) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   if (spline1dcalc(&c, 5.0) != y.xR[0]) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
// Special test - N == 3, x == [0,1,2], y == [0,1,0].
// Monotone spline must be equal to the Hermite spline with
// zero derivative at all points.
   ae_vector_set_length(&x, 3);
   ae_vector_set_length(&y, 3);
   ae_vector_set_length(&d, 3);
   x.xR[0] = 0.0;
   y.xR[0] = 0.0;
   d.xR[0] = 0.0;
   x.xR[1] = 1.0;
   y.xR[1] = 1.0;
   d.xR[1] = 0.0;
   x.xR[2] = 2.0;
   y.xR[2] = 0.0;
   d.xR[2] = 0.0;
   spline1dbuildmonotone(&x, &y, 3, &c);
   spline1dbuildhermite(&x, &y, &d, 3, &s2);
   for (i = 0; i <= 10; i++) {
      v = x.xR[0] + (double)i / 10.0 *(x.xR[2] - x.xR[0]);
      if (!NearAtR(spline1dcalc(&c, v), spline1dcalc(&s2, v), eps)) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
// Special test - N == 5, x == [0,1,2,3,4], y == [0,1,1,2,3].
//
// 1) spline passes through all prescribed points
// 2) spline derivative at all points except x == 3 is exactly zero
// 3) spline derivative at x == 3 is 1.0 (within machine epsilon)
   ae_vector_set_length(&x, 5);
   ae_vector_set_length(&y, 5);
   x.xR[0] = 0.0;
   y.xR[0] = 0.0;
   x.xR[1] = 1.0;
   y.xR[1] = 1.0;
   x.xR[2] = 2.0;
   y.xR[2] = 1.0;
   x.xR[3] = 3.0;
   y.xR[3] = 2.0;
   x.xR[4] = 4.0;
   y.xR[4] = 3.0;
   spline1dbuildmonotone(&x, &y, 5, &c);
   for (i = 0; i <= 4; i++) {
      spline1ddiff(&c, x.xR[i], &v, &dv, &d2v);
      if (!NearAtR(v, y.xR[i], eps)) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      if (x.xR[i] == 3.0? !NearAtR(dv, 1.0, eps): dv != 0.0) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
// Special test:
// * N == 4
// * three fixed points - (0,0), (1,1), (2,0)
// * one special point (x,y) with x in [0.1,0.9], y in [0.1,0.9]
// * monotonicity of the interpolant at [0,1] is checked with very small step 1/KMax
   ae_vector_set_length(&x, 4);
   ae_vector_set_length(&y, 4);
   x.xR[0] = 0.0;
   y.xR[0] = 0.0;
   x.xR[2] = 1.0;
   y.xR[2] = 1.0;
   x.xR[3] = 2.0;
   y.xR[3] = 0.0;
   for (i = 1; i <= 9; i++) {
      for (j = 1; j <= 9; j++) {
         x.xR[1] = (double)i / 10.0;
         y.xR[1] = (double)j / 10.0;
         spline1dbuildmonotone(&x, &y, 4, &c);
         kmax = 1000;
         for (k = 0; k < kmax; k++) {
            if (spline1dcalc(&c, (double)k / kmax) > spline1dcalc(&c, (double)(k + 1) / kmax)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
// General case
   delta = 0.0;
   nseg = 10;
   npoints = 15;
   passcount = 30;
   for (pass = 1; pass <= passcount; pass++) {
      tp = randominteger(6) + 4;
      r = (double)(randominteger(76) + 25);
      m = randominteger(nseg) + 1;
      ae_vector_set_length(&n, m);
      alln = 0;
      for (i = 0; i < m; i++) {
         n.xZ[i] = randominteger(npoints) + 2;
         alln += n.xZ[i];
      }
      ae_vector_set_length(&x, alln);
      ae_vector_set_length(&y, alln);
      x.xR[0] = r * randommid();
      y.xR[0] = r * randommid();
   // Builds monotone function
      st = 0.1 + 0.7 * randomreal();
      shift = 0;
      sign0 = pow(-1.0, 0.0);
      for (i = 0; i < m; i++) {
         for (j = 1; j < n.xZ[i]; j++) {
            x.xR[shift + j] = x.xR[shift + j - 1] + st + randomreal();
            delta = rmax2(delta, x.xR[shift + j] - x.xR[shift + j - 1]);
            y.xR[shift + j] = y.xR[shift + j - 1] + sign0 * (st + randomreal());
         }
         shift += n.xZ[i];
         if (i != m - 1) {
            sign0 = pow(-1.0, (double)(i + 1));
            x.xR[shift] = x.xR[shift - 1] + st + randomreal();
            y.xR[shift] = y.xR[shift - 1] + sign0 * randomreal();
         }
      }
      delta *= 3;
      spline1dbuildmonotone(&x, &y, alln, &c);
   // Check that built function is monotone
      shift = 0;
      for (i = 0; i < m; i++) {
         for (j = 1; j < n.xZ[i]; j++) {
            st = (x.xR[shift + j] - x.xR[shift + j - 1]) / tp;
            sign0 = y.xR[shift + j] - y.xR[shift + j - 1];
            if (sign0 != 0.0) {
               sign0 /= fabs(sign0);
            }
            for (l = 0; l < tp; l++) {
               c0 = spline1dcalc(&c, x.xR[shift + j - 1] + l * st);
               c1 = spline1dcalc(&c, x.xR[shift + j - 1] + (l + 1) * st);
               sign1 = c1 - c0;
               if (sign1 != 0.0) {
                  sign1 /= fabs(sign1);
               }
               if (sign0 * sign1 < 0.0) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      }
      c0 = spline1dcalc(&c, x.xR[0] - delta);
      c1 = spline1dcalc(&c, x.xR[0]);
      if (!NearAtR(c0, c1, eps)) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      c0 = spline1dcalc(&c, x.xR[alln - 1]);
      c1 = spline1dcalc(&c, x.xR[alln - 1] + delta);
      if (!NearAtR(c0, c1, eps)) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   // Builds constant function
      y.xR[0] = r * randommid();
      for (i = 1; i < alln; i++) {
         y.xR[i] = y.xR[0];
      }
      spline1dbuildmonotone(&x, &y, alln, &c);
      shift = 0;
      for (i = 0; i < m; i++) {
         for (j = 1; j < n.xZ[i]; j++) {
            st = (x.xR[shift + j] - x.xR[shift + j - 1]) / tp;
            sign0 = y.xR[shift + j] - y.xR[shift + j - 1];
            for (l = 0; l < tp; l++) {
               c0 = spline1dcalc(&c, x.xR[shift + j - 1] + l * st);
               c1 = spline1dcalc(&c, x.xR[shift + j - 1] + (l + 1) * st);
               sign1 = c1 - c0;
               if (sign0 > eps || sign1 > eps) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

static bool testspline1dunit_testsplinefitting() {
   ae_frame _frame_block;
   double threshold;
   double nonstrictthreshold;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t k;
   ae_int_t pass;
   double s;
   double v;
   double v1;
   double v2;
   double u;
   double u1;
   double u2;
   double a;
   double b;
   double refrms;
   double refavg;
   double refavgrel;
   double refmax;
   double rho;
   double prevresiduals;
   double prevpenalty;
   double residuals;
   double penalty;
   double mxd2;
   ae_int_t testtype;
   double lipschitzeps;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(dc, 0, DT_INT);
   NewObj(spline1dinterpolant, c);
   NewObj(spline1dinterpolant, c2);
   NewObj(spline1dfitreport, rep);
   NewObj(spline1dfitreport, rep2);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Values:
// * pass count
// * threshold - for tests which must be satisfied exactly
// * nonstrictthreshold - for approximate tests
   passcount = 20;
   threshold = 10000.0 * machineepsilon;
   nonstrictthreshold = 1.0E-6;
   lipschitzeps = 1.0E-6;
   Ok = true;
// check basic properties of penalized splines which are
// preserved independently of Rho parameter.
   for (m = 4; m <= 10; m++) {
      for (k = -5; k <= 5; k++) {
         rho = (double)k;
      // when we have two points (even with different weights),
      // resulting spline must be equal to the straight line
         ae_vector_set_length(&x, 2);
         ae_vector_set_length(&y, 2);
         ae_vector_set_length(&w, 2);
         x.xR[0] = -0.5 - randomreal();
         y.xR[0] = 0.5 + randomreal();
         w.xR[0] = 1 + randomreal();
         x.xR[1] = 0.5 + randomreal();
         y.xR[1] = 0.5 + randomreal();
         w.xR[1] = 1 + randomreal();
         testspline1dunit_unsetspline1d(&c);
         testspline1dunit_unsetreport(&rep);
         spline1dfit(&x, &y, 2, m, pow(10.0, rho), &c, &rep);
         v = randommid();
         v1 = (v - x.xR[0]) / (x.xR[1] - x.xR[0]) * y.xR[1] + (v - x.xR[1]) / (x.xR[0] - x.xR[1]) * y.xR[0];
         Ok = Ok && NearAtR(v1, spline1dcalc(&c, v), threshold);
         Ok = Ok && rep.rmserror <= threshold;
         Ok = Ok && rep.avgerror <= threshold;
         Ok = Ok && rep.maxerror <= threshold;
      }
   }
// Test spline ability to reproduce target:
// * a penalized spline with M == N and nearly zero Rho must pass
//   through all points on equidistant grid
// * a penalized spline with M about 5*N and sufficiently small
//   Rho must pass through all points on equidistant grid
// In both cases spline must be C0, C1 and C2 continuous.
   for (n = 2; n <= 20; n++) {
   // Fit
      m = n;
      rho = -15.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = (double)i / (n - 1);
         y.xR[i] = randomreal() - 0.5;
      }
      testspline1dunit_unsetspline1d(&c);
      testspline1dunit_unsetreport(&rep);
      spline1dfit(&x, &y, n, m, pow(10.0, rho), &c, &rep);
   // Test that spline passes through all the points
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(y.xR[i], spline1dcalc(&c, x.xR[i]), nonstrictthreshold);
      }
      Ok = Ok && rep.rmserror <= nonstrictthreshold;
      Ok = Ok && rep.avgerror <= nonstrictthreshold;
      Ok = Ok && rep.maxerror <= nonstrictthreshold;
   // Test continuity properties
      s = 0.01 * (1.0 / m);
      testspline1dunit_lconst(0.0, 1.0, &c, s, &u, &u1, &u2);
      testspline1dunit_lconst(0.0, 1.0, &c, s / 2, &v, &v1, &v2);
      Ok = Ok && v / (u + lipschitzeps) <= 1.2;
      Ok = Ok && v1 / (u1 + lipschitzeps * m) <= 1.2;
      Ok = Ok && v2 / (u2 + lipschitzeps * sqr(m)) <= 1.2;
   }
   for (n = 2; n <= 20; n++) {
      m = 5 * n;
      rho = -10.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      ae_vector_set_length(&w, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = (double)i / (n - 1);
         y.xR[i] = randomreal();
         w.xR[i] = 0.1 + randomreal();
      }
      testspline1dunit_unsetspline1d(&c);
      testspline1dunit_unsetreport(&rep);
      spline1dfit(&x, &y, n, m, pow(10.0, rho), &c, &rep);
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(y.xR[i], spline1dcalc(&c, x.xR[i]), nonstrictthreshold);
      }
      Ok = Ok && rep.rmserror <= nonstrictthreshold;
      Ok = Ok && rep.avgerror <= nonstrictthreshold;
      Ok = Ok && rep.maxerror <= nonstrictthreshold;
   // Test continuity properties
      s = 0.01 * (1.0 / m);
      testspline1dunit_lconst(0.0, 1.0, &c, s, &u, &u1, &u2);
      testspline1dunit_lconst(0.0, 1.0, &c, s / 2, &v, &v1, &v2);
      Ok = Ok && v / (u + lipschitzeps) <= 1.2;
      Ok = Ok && v1 / (u1 + lipschitzeps * m) <= 1.2;
      Ok = Ok && v2 / (u2 + lipschitzeps * sqr(m)) <= 1.2;
   }
// Test smoothing properties: a sequence of problems with increasing Rho
// results in residuals monotonically increasing and nonlinearity penalty
// monotonically decreasing.
//
// This test is performed twice: first time for M << N, second time for M >> N
   for (testtype = 0; testtype <= 1; testtype++) {
      if (testtype == 0) {
         n = 100;
         m = 10;
      } else {
         n = 10;
         m = 100;
      }
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = hqrndnormal(&rs);
         y.xR[i] = hqrndnormal(&rs);
      }
      a = x.xR[0];
      b = x.xR[0];
      for (i = 1; i < n; i++) {
         a = rmin2(a, x.xR[i]);
         b = rmax2(b, x.xR[i]);
      }
      prevresiduals = 0.0;
      prevpenalty = maxrealnumber;
      rho = -4.0;
      while (rho <= 4.0) {
      // Fit spline
         testspline1dunit_unsetspline1d(&c);
         testspline1dunit_unsetreport(&rep);
         spline1dfit(&x, &y, n, m, pow(10.0, rho), &c, &rep);
      // Test continuity properties
         s = 0.01 * ((b - a) / m);
         testspline1dunit_lconst(a, b, &c, s, &u, &u1, &u2);
         testspline1dunit_lconst(a, b, &c, s / 2, &v, &v1, &v2);
         Ok = Ok && v / (u + lipschitzeps) <= 1.2;
         Ok = Ok && v1 / (u1 + lipschitzeps * m) <= 1.2;
         Ok = Ok && v2 / (u2 + lipschitzeps * sqr(m)) <= 1.2;
      // Compute residuals and penalty
         residuals = 0.0;
         for (i = 0; i < n; i++) {
            residuals += sqr(spline1dcalc(&c, x.xR[i]) - y.xR[i]);
         }
         residuals /= n;
         penalty = 0.0;
         mxd2 = 0.0;
         k = 100 * m;
         for (i = 0; i <= k; i++) {
            spline1ddiff(&c, a + (b - a) * i / k, &v, &v1, &v2);
            penalty += sqr(v2);
            mxd2 = rmax2(mxd2, fabs(v2));
         }
         penalty /= k + 1;
      // Compare with previous, update previous, update Rho
      //
      // Write('%.15e    %.15e    %.15e\n', Residuals, Penalty, MxD2);
         Ok = Ok && residuals > prevresiduals;
         Ok = Ok && penalty < prevpenalty;
         prevresiduals = residuals;
         prevpenalty = penalty;
         rho++;
      }
      Ok = Ok && penalty < 1.0E-6;
      Ok = Ok && mxd2 < 1.0E-3;
   }
// Special test which allows to distinguish "true smoothing" from
// basic regularization enforced upon spline coefficients.
   n = 4;
   m = 100;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&y, n);
   x.xR[0] = -2.0;
   x.xR[1] = -1.0;
   x.xR[2] = 1.0;
   x.xR[3] = 2.0;
   y.xR[0] = -1.0;
   y.xR[1] = 1.0;
   y.xR[2] = 1.0;
   y.xR[3] = -1.0;
   rho = -5.0;
   spline1dfit(&x, &y, n, m, pow(10.0, rho), &c, &rep);
   for (i = 0; i < n; i++) {
      Ok = Ok && NearAtR(spline1dcalc(&c, x.xR[i]), y.xR[i], 0.0001);
   }
   Ok = Ok && spline1dcalc(&c, 0.0) >= 1.000;
// Check correctness of error reports
   for (pass = 1; pass <= passcount; pass++) {
      ae_assert(passcount >= 2, "PassCount should be 2 or greater!");
   // solve simple task (all X[] are the same, Y[] are specially
   // calculated to ensure simple form of all types of errors)
   // and check correctness of the errors calculated by subroutines
   //
   // First pass is done with zero Y[], other passes - with random Y[].
   // It should test both ability to correctly calculate errors and
   // ability to not fail while working with zeros :)
      n = 4;
      if (pass == 1) {
         v1 = 0.0;
         v2 = 0.0;
         v = 0.0;
      } else {
         v1 = randomreal();
         v2 = randomreal();
         v = 1 + randomreal();
      }
      ae_vector_set_length(&x, 4);
      ae_vector_set_length(&y, 4);
      ae_vector_set_length(&w, 4);
      x.xR[0] = 0.0;
      y.xR[0] = v - v2;
      w.xR[0] = 1.0;
      x.xR[1] = 0.0;
      y.xR[1] = v - v1;
      w.xR[1] = 1.0;
      x.xR[2] = 0.0;
      y.xR[2] = v + v1;
      w.xR[2] = 1.0;
      x.xR[3] = 0.0;
      y.xR[3] = v + v2;
      w.xR[3] = 1.0;
      refrms = sqrt((sqr(v1) + sqr(v2)) / 2);
      refavg = (fabs(v1) + fabs(v2)) / 2;
      if (pass == 1) {
         refavgrel = 0.0;
      } else {
         refavgrel = 0.25 * (fabs(v2) / fabs(v - v2) + fabs(v1) / fabs(v - v1) + fabs(v1) / fabs(v + v1) + fabs(v2) / fabs(v + v2));
      }
      refmax = rmax2(v1, v2);
      spline1dfit(&x, &y, 4, 4, 0.0, &c, &rep);
      s = spline1dcalc(&c, 0.0);
      Ok = Ok && NearAtR(s, v, threshold);
      Ok = Ok && NearAtR(rep.rmserror, refrms, threshold);
      Ok = Ok && NearAtR(rep.avgerror, refavg, threshold);
      Ok = Ok && NearAtR(rep.avgrelerror, refavgrel, threshold);
      Ok = Ok && NearAtR(rep.maxerror, refmax, threshold);
   }
   ae_frame_leave();
   return Ok;
}

bool testspline1d() {
   ae_frame _frame_block;
   double threshold;
   ae_int_t passcount;
   double lstep;
   double h;
   ae_int_t maxn;
   ae_int_t bltype;
   ae_int_t brtype;
   bool periodiccond;
   ae_int_t n;
   ae_int_t i;
   ae_int_t k;
   ae_int_t pass;
   ae_int_t n2;
   double a;
   double b;
   double bl;
   double br;
   double t;
   double sa;
   double sb;
   double v;
   double l10;
   double l11;
   double l12;
   double l20;
   double l21;
   double l22;
   double p0;
   double p1;
   double p2;
   double s;
   double ds;
   double d2s;
   double s2;
   double ds2;
   double d2s2;
   double vl;
   double vm;
   double vr;
   double err;
   double tension;
   double intab;
   ae_int_t splineindex;
   double lipschitzeps;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(yp, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewVector(xtest, 0, DT_REAL);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(tmp1, 0, DT_REAL);
   NewVector(tmp2, 0, DT_REAL);
   NewVector(tmpx, 0, DT_REAL);
   NewVector(dc, 0, DT_INT);
   NewObj(spline1dinterpolant, c);
   NewObj(spline1dinterpolant, c2);
   passcount = 20;
   lstep = 0.005;
   h = 0.00001;
   maxn = 10;
   lipschitzeps = 1.0E-6;
   threshold = 10000.0 * machineepsilon;
   bool lsOk = true;
   bool csOk = true;
   bool crsOk = true;
   bool hsOk = true;
   bool asOk = true;
   bool dsOk = true;
   bool cpOk = true;
   bool upOk = true;
   bool ltOk = true;
   bool iOk = true;
// General test: linear, cubic, Hermite, Akima
   for (n = 2; n <= maxn; n++) {
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      ae_vector_set_length(&yp, n);
      ae_vector_set_length(&d, n);
      for (pass = 1; pass <= passcount; pass++) {
      // Prepare task:
      // * X contains abscissas from [A,B]
      // * Y contains function values
      // * YP contains periodic function values
         a = -1 - randomreal();
         b = 1 + randomreal();
         bl = randommid();
         br = randommid();
         for (i = 0; i < n; i++) {
            x.xR[i] = 0.5 * (b + a) + 0.5 * (b - a) * cos(pi * (2 * i + 1) / (2 * n));
            if (i == 0) {
               x.xR[i] = a;
            }
            if (i == n - 1) {
               x.xR[i] = b;
            }
            y.xR[i] = cos(1.3 * pi * x.xR[i] + 0.4);
            yp.xR[i] = y.xR[i];
            d.xR[i] = -1.3 * pi * sin(1.3 * pi * x.xR[i] + 0.4);
         }
         yp.xR[n - 1] = yp.xR[0];
         for (i = 0; i < n; i++) {
            k = randominteger(n);
            if (k != i) {
               swapr(&x.xR[i], &x.xR[k]);
               swapr(&y.xR[i], &y.xR[k]);
               swapr(&yp.xR[i], &yp.xR[k]);
               swapr(&d.xR[i], &d.xR[k]);
            }
         }
      // Build linear spline
      // Test for general interpolation scheme properties:
      // * values at nodes
      // * continuous function
      // Test for specific properties is implemented below.
         spline1dbuildlinear(&x, &y, n, &c);
         err = 0.0;
         for (i = 0; i < n; i++) {
            err = rmax2(err, fabs(y.xR[i] - spline1dcalc(&c, x.xR[i])));
         }
         lsOk = lsOk && err <= threshold;
         testspline1dunit_lconst(a, b, &c, lstep, &l10, &l11, &l12);
         testspline1dunit_lconst(a, b, &c, lstep / 3, &l20, &l21, &l22);
         lsOk = lsOk && l20 / l10 <= 1.2;
      // Build cubic spline.
      // Test for interpolation scheme properties:
      // * values at nodes
      // * boundary conditions
      // * continuous function
      // * continuous first derivative
      // * continuous second derivative
      // * periodicity properties
      // * Spline1DGridDiff(), Spline1DGridDiff2() and Spline1DDiff()
      //   calls must return same results
         for (bltype = -1; bltype <= 2; bltype++) {
            for (brtype = -1; brtype <= 2; brtype++) {
            // skip meaningless combination of boundary conditions
            // (one condition is periodic, another is not)
               periodiccond = bltype == -1 || brtype == -1;
               if (periodiccond && bltype != brtype) {
                  continue;
               }
            // build
               if (periodiccond) {
                  spline1dbuildcubic(&x, &yp, n, bltype, bl, brtype, br, &c);
               } else {
                  spline1dbuildcubic(&x, &y, n, bltype, bl, brtype, br, &c);
               }
            // interpolation properties
               err = 0.0;
               if (periodiccond) {
               // * check values at nodes; spline is periodic so
               //   we add random number of periods to nodes
               // * we also test for periodicity of derivatives
                  for (i = 0; i < n; i++) {
                     v = x.xR[i];
                     vm = v + (b - a) * (randominteger(5) - 2);
                     t = yp.xR[i] - spline1dcalc(&c, vm);
                     err = rmax2(err, fabs(t));
                     spline1ddiff(&c, v, &s, &ds, &d2s);
                     spline1ddiff(&c, vm, &s2, &ds2, &d2s2);
                     err = rmax2(err, fabs(s - s2));
                     err = rmax2(err, fabs(ds - ds2));
                     err = rmax2(err, fabs(d2s - d2s2));
                  }
               // periodicity between nodes
                  v = a + (b - a) * randomreal();
                  vm = v + (b - a) * (randominteger(5) - 2);
                  err = rmax2(err, fabs(spline1dcalc(&c, v) - spline1dcalc(&c, vm)));
                  spline1ddiff(&c, v, &s, &ds, &d2s);
                  spline1ddiff(&c, vm, &s2, &ds2, &d2s2);
                  err = rmax2(err, fabs(s - s2));
                  err = rmax2(err, fabs(ds - ds2));
                  err = rmax2(err, fabs(d2s - d2s2));
               } else {
               // * check values at nodes
                  for (i = 0; i < n; i++) {
                     err = rmax2(err, fabs(y.xR[i] - spline1dcalc(&c, x.xR[i])));
                  }
               }
               csOk = csOk && err <= threshold;
            // check boundary conditions
               err = 0.0;
               if (bltype == 0) {
                  spline1ddiff(&c, a - h, &s, &ds, &d2s);
                  spline1ddiff(&c, a + h, &s2, &ds2, &d2s2);
                  t = (d2s2 - d2s) / (2 * h);
                  err = rmax2(err, fabs(t));
               }
               if (bltype == 1) {
                  t = (spline1dcalc(&c, a + h) - spline1dcalc(&c, a - h)) / (2 * h);
                  err = rmax2(err, fabs(bl - t));
               }
               if (bltype == 2) {
                  t = (spline1dcalc(&c, a + h) - 2 * spline1dcalc(&c, a) + spline1dcalc(&c, a - h)) / sqr(h);
                  err = rmax2(err, fabs(bl - t));
               }
               if (brtype == 0) {
                  spline1ddiff(&c, b - h, &s, &ds, &d2s);
                  spline1ddiff(&c, b + h, &s2, &ds2, &d2s2);
                  t = (d2s2 - d2s) / (2 * h);
                  err = rmax2(err, fabs(t));
               }
               if (brtype == 1) {
                  t = (spline1dcalc(&c, b + h) - spline1dcalc(&c, b - h)) / (2 * h);
                  err = rmax2(err, fabs(br - t));
               }
               if (brtype == 2) {
                  t = (spline1dcalc(&c, b + h) - 2 * spline1dcalc(&c, b) + spline1dcalc(&c, b - h)) / sqr(h);
                  err = rmax2(err, fabs(br - t));
               }
               if (bltype == -1 || brtype == -1) {
                  spline1ddiff(&c, a + 100.0 * machineepsilon, &s, &ds, &d2s);
                  spline1ddiff(&c, b - 100.0 * machineepsilon, &s2, &ds2, &d2s2);
                  err = rmax2(err, fabs(s - s2));
                  err = rmax2(err, fabs(ds - ds2));
                  err = rmax2(err, fabs(d2s - d2s2));
               }
               csOk = csOk && err <= 1.0E-3;
            // Check Lipschitz continuity
               testspline1dunit_lconst(a, b, &c, lstep, &l10, &l11, &l12);
               testspline1dunit_lconst(a, b, &c, lstep / 3, &l20, &l21, &l22);
               if (l10 > lipschitzeps) {
                  csOk = csOk && l20 / (l10 + lipschitzeps) <= 1.2;
               }
               if (l11 > lipschitzeps) {
                  csOk = csOk && l21 / (l11 + lipschitzeps) <= 1.2;
               }
               if (l12 > lipschitzeps) {
                  csOk = csOk && l22 / (l12 + lipschitzeps) <= 1.2;
               }
            // compare spline1dgriddiff() and spline1ddiff() results
               err = 0.0;
               if (periodiccond) {
                  spline1dgriddiffcubic(&x, &yp, n, bltype, bl, brtype, br, &tmp1);
               } else {
                  spline1dgriddiffcubic(&x, &y, n, bltype, bl, brtype, br, &tmp1);
               }
               ae_assert(tmp1.cnt >= n, "Assertion failed");
               for (i = 0; i < n; i++) {
                  spline1ddiff(&c, x.xR[i], &s, &ds, &d2s);
                  err = rmax2(err, fabs(ds - tmp1.xR[i]));
               }
               if (periodiccond) {
                  spline1dgriddiff2cubic(&x, &yp, n, bltype, bl, brtype, br, &tmp1, &tmp2);
               } else {
                  spline1dgriddiff2cubic(&x, &y, n, bltype, bl, brtype, br, &tmp1, &tmp2);
               }
               for (i = 0; i < n; i++) {
                  spline1ddiff(&c, x.xR[i], &s, &ds, &d2s);
                  err = rmax2(err, fabs(ds - tmp1.xR[i]));
                  err = rmax2(err, fabs(d2s - tmp2.xR[i]));
               }
               csOk = csOk && err <= threshold;
            // compare spline1dconv()/convdiff()/convdiff2() and spline1ddiff() results
               n2 = 2 + randominteger(2 * n);
               ae_vector_set_length(&tmpx, n2);
               for (i = 0; i < n2; i++) {
                  tmpx.xR[i] = 0.5 * (a + b) + (a - b) * randommid();
               }
               err = 0.0;
               if (periodiccond) {
                  spline1dconvcubic(&x, &yp, n, bltype, bl, brtype, br, &tmpx, n2, &tmp0);
               } else {
                  spline1dconvcubic(&x, &y, n, bltype, bl, brtype, br, &tmpx, n2, &tmp0);
               }
               for (i = 0; i < n2; i++) {
                  spline1ddiff(&c, tmpx.xR[i], &s, &ds, &d2s);
                  err = rmax2(err, fabs(s - tmp0.xR[i]));
               }
               if (periodiccond) {
                  spline1dconvdiffcubic(&x, &yp, n, bltype, bl, brtype, br, &tmpx, n2, &tmp0, &tmp1);
               } else {
                  spline1dconvdiffcubic(&x, &y, n, bltype, bl, brtype, br, &tmpx, n2, &tmp0, &tmp1);
               }
               for (i = 0; i < n2; i++) {
                  spline1ddiff(&c, tmpx.xR[i], &s, &ds, &d2s);
                  err = rmax2(err, fabs(s - tmp0.xR[i]));
                  err = rmax2(err, fabs(ds - tmp1.xR[i]));
               }
               if (periodiccond) {
                  spline1dconvdiff2cubic(&x, &yp, n, bltype, bl, brtype, br, &tmpx, n2, &tmp0, &tmp1, &tmp2);
               } else {
                  spline1dconvdiff2cubic(&x, &y, n, bltype, bl, brtype, br, &tmpx, n2, &tmp0, &tmp1, &tmp2);
               }
               for (i = 0; i < n2; i++) {
                  spline1ddiff(&c, tmpx.xR[i], &s, &ds, &d2s);
                  err = rmax2(err, fabs(s - tmp0.xR[i]));
                  err = rmax2(err, fabs(ds - tmp1.xR[i]));
                  err = rmax2(err, fabs(d2s - tmp2.xR[i]));
               }
               csOk = csOk && err <= threshold;
            }
         }
      // Build Catmull-Rom spline.
      // Test for interpolation scheme properties:
      // * values at nodes
      // * boundary conditions
      // * continuous function
      // * continuous first derivative
      // * periodicity properties
         for (bltype = -1; bltype <= 0; bltype++) {
            periodiccond = bltype == -1;
         // select random tension value, then build
            if (randombool()) {
               if (randombool()) {
                  tension = 0.0;
               } else {
                  tension = 1.0;
               }
            } else {
               tension = randomreal();
            }
            if (periodiccond) {
               spline1dbuildcatmullrom(&x, &yp, n, bltype, tension, &c);
            } else {
               spline1dbuildcatmullrom(&x, &y, n, bltype, tension, &c);
            }
         // interpolation properties
            err = 0.0;
            if (periodiccond) {
            // * check values at nodes; spline is periodic so
            //   we add random number of periods to nodes
            // * we also test for periodicity of first derivative
               for (i = 0; i < n; i++) {
                  v = x.xR[i];
                  vm = v + (b - a) * (randominteger(5) - 2);
                  t = yp.xR[i] - spline1dcalc(&c, vm);
                  err = rmax2(err, fabs(t));
                  spline1ddiff(&c, v, &s, &ds, &d2s);
                  spline1ddiff(&c, vm, &s2, &ds2, &d2s2);
                  err = rmax2(err, fabs(s - s2));
                  err = rmax2(err, fabs(ds - ds2));
               }
            // periodicity between nodes
               v = a + (b - a) * randomreal();
               vm = v + (b - a) * (randominteger(5) - 2);
               err = rmax2(err, fabs(spline1dcalc(&c, v) - spline1dcalc(&c, vm)));
               spline1ddiff(&c, v, &s, &ds, &d2s);
               spline1ddiff(&c, vm, &s2, &ds2, &d2s2);
               err = rmax2(err, fabs(s - s2));
               err = rmax2(err, fabs(ds - ds2));
            } else {
            // * check values at nodes
               for (i = 0; i < n; i++) {
                  err = rmax2(err, fabs(y.xR[i] - spline1dcalc(&c, x.xR[i])));
               }
            }
            crsOk = crsOk && err <= threshold;
         // check boundary conditions
            err = 0.0;
            if (bltype == 0) {
               spline1ddiff(&c, a - h, &s, &ds, &d2s);
               spline1ddiff(&c, a + h, &s2, &ds2, &d2s2);
               t = (d2s2 - d2s) / (2 * h);
               err = rmax2(err, fabs(t));
               spline1ddiff(&c, b - h, &s, &ds, &d2s);
               spline1ddiff(&c, b + h, &s2, &ds2, &d2s2);
               t = (d2s2 - d2s) / (2 * h);
               err = rmax2(err, fabs(t));
            }
            if (bltype == -1) {
               spline1ddiff(&c, a + 100.0 * machineepsilon, &s, &ds, &d2s);
               spline1ddiff(&c, b - 100.0 * machineepsilon, &s2, &ds2, &d2s2);
               err = rmax2(err, fabs(s - s2));
               err = rmax2(err, fabs(ds - ds2));
            }
            crsOk = crsOk && err <= 1.0E-3;
         // Check Lipschitz continuity
            testspline1dunit_lconst(a, b, &c, lstep, &l10, &l11, &l12);
            testspline1dunit_lconst(a, b, &c, lstep / 3, &l20, &l21, &l22);
            if (l10 > 1.0E-6) {
               crsOk = crsOk && l20 / l10 <= 1.2;
            }
            if (l11 > 1.0E-6) {
               crsOk = crsOk && l21 / l11 <= 1.2;
            }
         }
      // Build Hermite spline.
      // Test for interpolation scheme properties:
      // * values and derivatives at nodes
      // * continuous function
      // * continuous first derivative
         spline1dbuildhermite(&x, &y, &d, n, &c);
         err = 0.0;
         for (i = 0; i < n; i++) {
            err = rmax2(err, fabs(y.xR[i] - spline1dcalc(&c, x.xR[i])));
         }
         hsOk = hsOk && err <= threshold;
         err = 0.0;
         for (i = 0; i < n; i++) {
            t = (spline1dcalc(&c, x.xR[i] + h) - spline1dcalc(&c, x.xR[i] - h)) / (2 * h);
            err = rmax2(err, fabs(d.xR[i] - t));
         }
         hsOk = hsOk && err <= 1.0E-3;
         testspline1dunit_lconst(a, b, &c, lstep, &l10, &l11, &l12);
         testspline1dunit_lconst(a, b, &c, lstep / 3, &l20, &l21, &l22);
         hsOk = hsOk && l20 / l10 <= 1.2;
         hsOk = hsOk && l21 / l11 <= 1.2;
      // Build Akima spline
      // Test for general interpolation scheme properties:
      // * values at nodes
      // * continuous function
      // * continuous first derivative
      // Test for Akima-specific properties is implemented below.
         spline1dbuildakima(&x, &y, n, &c);
         err = 0.0;
         for (i = 0; i < n; i++) {
            err = rmax2(err, fabs(y.xR[i] - spline1dcalc(&c, x.xR[i])));
         }
         asOk = asOk && err <= threshold;
         testspline1dunit_lconst(a, b, &c, lstep, &l10, &l11, &l12);
         testspline1dunit_lconst(a, b, &c, lstep / 3, &l20, &l21, &l22);
         hsOk = hsOk && (l10 <= 1.0E-10 || l20 / l10 <= 1.2);
         hsOk = hsOk && (l11 <= 1.0E-10 || l21 / l11 <= 1.2);
      }
   }
// Special linear spline test:
// test for linearity between x[i] and x[i+1]
   for (n = 2; n <= maxn; n++) {
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
   // Prepare task
      a = -1.0;
      b = 1.0;
      for (i = 0; i < n; i++) {
         x.xR[i] = a + (b - a) * i / (n - 1);
         y.xR[i] = randommid();
      }
      spline1dbuildlinear(&x, &y, n, &c);
   // Test
      err = 0.0;
      for (k = 0; k < n - 1; k++) {
         a = x.xR[k];
         b = x.xR[k + 1];
         for (pass = 1; pass <= passcount; pass++) {
            t = a + (b - a) * randomreal();
            v = y.xR[k] + (t - a) / (b - a) * (y.xR[k + 1] - y.xR[k]);
            err = rmax2(err, fabs(spline1dcalc(&c, t) - v));
         }
      }
      lsOk = lsOk && err <= threshold;
   }
// Special Akima test: test outlier sensitivity
// Spline value at (x[i], x[i+1]) should depend from
// f[i-2], f[i-1], f[i], f[i+1], f[i+2], f[i+3] only.
   for (n = 5; n <= maxn; n++) {
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      ae_vector_set_length(&y2, n);
   // Prepare unperturbed Akima spline
      a = -1.0;
      b = 1.0;
      for (i = 0; i < n; i++) {
         x.xR[i] = a + (b - a) * i / (n - 1);
         y.xR[i] = cos(1.3 * pi * x.xR[i] + 0.4);
      }
      spline1dbuildakima(&x, &y, n, &c);
   // Process perturbed tasks
      err = 0.0;
      for (k = 0; k < n; k++) {
         ae_v_move(y2.xR, 1, y.xR, 1, n);
         y2.xR[k] = 5.0;
         spline1dbuildakima(&x, &y2, n, &c2);
      // Test left part independence
         if (k - 3 >= 1) {
            a = -1.0;
            b = x.xR[k - 3];
            for (pass = 1; pass <= passcount; pass++) {
               t = a + (b - a) * randomreal();
               err = rmax2(err, fabs(spline1dcalc(&c, t) - spline1dcalc(&c2, t)));
            }
         }
      // Test right part independence
         if (k + 3 < n - 1) {
            a = x.xR[k + 3];
            b = 1.0;
            for (pass = 1; pass <= passcount; pass++) {
               t = a + (b - a) * randomreal();
               err = rmax2(err, fabs(spline1dcalc(&c, t) - spline1dcalc(&c2, t)));
            }
         }
      }
      asOk = asOk && err <= threshold;
   }
// Differentiation, copy/unpack test
   for (n = 2; n <= maxn; n++) {
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
   // Prepare cubic spline
      a = -1 - randomreal();
      b = 1 + randomreal();
      for (i = 0; i < n; i++) {
         x.xR[i] = a + (b - a) * i / (n - 1);
         y.xR[i] = cos(1.3 * pi * x.xR[i] + 0.4);
      }
      spline1dbuildcubic(&x, &y, n, 2, 0.0, 2, 0.0, &c);
   // Test diff
      err = 0.0;
      for (pass = 1; pass <= passcount; pass++) {
         t = a + (b - a) * randomreal();
         spline1ddiff(&c, t, &s, &ds, &d2s);
         vl = spline1dcalc(&c, t - h);
         vm = spline1dcalc(&c, t);
         vr = spline1dcalc(&c, t + h);
         err = rmax2(err, fabs(s - vm));
         err = rmax2(err, fabs(ds - (vr - vl) / (2 * h)));
         err = rmax2(err, fabs(d2s - (vr - 2 * vm + vl) / sqr(h)));
      }
      dsOk = dsOk && err <= 0.001;
   // Test copy
      testspline1dunit_unsetspline1d(&c2);
      spline1dcopy(&c, &c2);
      err = 0.0;
      for (pass = 1; pass <= passcount; pass++) {
         t = a + (b - a) * randomreal();
         err = rmax2(err, fabs(spline1dcalc(&c, t) - spline1dcalc(&c2, t)));
      }
      cpOk = cpOk && err <= threshold;
   // Test unpack
      upOk = upOk && testspline1dunit_testunpack(&c, &x);
   }
// Linear translation errors
   for (n = 2; n <= maxn; n++) {
   // Prepare:
   // * X, Y - grid points
   // * XTest - test points
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      a = -1 - randomreal();
      b = 1 + randomreal();
      for (i = 0; i < n; i++) {
         x.xR[i] = a + (b - a) * (i + 0.1 * randommid()) / (n - 1);
         y.xR[i] = randommid();
      }
      ae_vector_set_length(&xtest, 5 * n + 2);
      for (i = 0; i < xtest.cnt; i++) {
         xtest.xR[i] = a + (b - a) * (i - 1) / (xtest.cnt - 3);
      }
      splineindex = 0;
      while (!testspline1dunit_enumerateallsplines(&x, &y, n, &splineindex, &c)) {
      // LinTransX, general A
         sa = 2.0 * randommid();
         sb = randommid();
         spline1dcopy(&c, &c2);
         spline1dlintransx(&c2, sa, sb);
         for (i = 0; i < xtest.cnt; i++) {
            ltOk = ltOk && NearAtR(spline1dcalc(&c, xtest.xR[i]), spline1dcalc(&c2, (xtest.xR[i] - sb) / sa), threshold);
         }
      // LinTransX, special case: A == 0
         sb = randommid();
         spline1dcopy(&c, &c2);
         spline1dlintransx(&c2, 0.0, sb);
         for (i = 0; i < xtest.cnt; i++) {
            ltOk = ltOk && NearAtR(spline1dcalc(&c, sb), spline1dcalc(&c2, xtest.xR[i]), threshold);
         }
      // LinTransY
         sa = randommid();
         sb = randommid();
         spline1dcopy(&c, &c2);
         spline1dlintransy(&c2, sa, sb);
         for (i = 0; i < xtest.cnt; i++) {
            ltOk = ltOk && NearAtR(sa * spline1dcalc(&c, xtest.xR[i]) + sb, spline1dcalc(&c2, xtest.xR[i]), threshold);
         }
      }
   }
// Testing integration.
// Three tests are performed:
//
// * approximate test (well behaved smooth function, many points,
//   integration inside [a,b]), non-periodic spline
//
// * exact test (integration of parabola, outside of [a,b], non-periodic spline
//
// * approximate test for periodic splines. F(x) == cos(2*pi*x)+1.
//   Period length is equals to 1.0, so all operations with
//   multiples of period are done exactly. For each value of PERIOD
//   we calculate and test integral at four points:
//   -   0 < t0 < PERIOD
//   -   t1 = PERIOD-eps
//   -   t2 = PERIOD
//   -   t3 = PERIOD+eps
   err = 0.0;
   for (n = 20; n <= 35; n++) {
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      for (pass = 1; pass <= passcount; pass++) {
      // Prepare cubic spline
         a = -1 - 0.2 * randomreal();
         b = 1 + 0.2 * randomreal();
         for (i = 0; i < n; i++) {
            x.xR[i] = a + (b - a) * i / (n - 1);
            y.xR[i] = sin(pi * x.xR[i] + 0.4) + exp(x.xR[i]);
         }
         bl = pi * cos(pi * a + 0.4) + exp(a);
         br = pi * cos(pi * b + 0.4) + exp(b);
         spline1dbuildcubic(&x, &y, n, 1, bl, 1, br, &c);
      // Test
         t = a + (b - a) * randomreal();
         v = -cos(pi * a + 0.4) / pi + exp(a);
         v = -cos(pi * t + 0.4) / pi + exp(t) - v;
         v -= spline1dintegrate(&c, t);
         err = rmax2(err, fabs(v));
      }
   }
   iOk = iOk && err <= 0.001;
   p0 = randommid();
   p1 = randommid();
   p2 = randommid();
   a = -randomreal() - 0.5;
   b = randomreal() + 0.5;
   n = 2;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&y, n);
   ae_vector_set_length(&d, n);
   x.xR[0] = a;
   y.xR[0] = p0 + p1 * a + p2 * sqr(a);
   d.xR[0] = p1 + 2 * p2 * a;
   x.xR[1] = b;
   y.xR[1] = p0 + p1 * b + p2 * sqr(b);
   d.xR[1] = p1 + 2 * p2 * b;
   spline1dbuildhermite(&x, &y, &d, n, &c);
   bl = rmin2(a, b) - fabs(b - a);
   br = rmin2(a, b) + fabs(b - a);
   err = 0.0;
   for (pass = 1; pass <= 100; pass++) {
      t = bl + (br - bl) * randomreal();
      v = p0 * t + p1 * sqr(t) / 2 + p2 * sqr(t) * t / 3 - (p0 * a + p1 * sqr(a) / 2 + p2 * sqr(a) * a / 3);
      v -= spline1dintegrate(&c, t);
      err = rmax2(err, fabs(v));
   }
   iOk = iOk && err <= threshold;
   n = 100;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&y, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = (double)i / (n - 1);
      y.xR[i] = cos(2 * pi * x.xR[i]) + 1;
   }
   y.xR[0] = 2.0;
   y.xR[n - 1] = 2.0;
   spline1dbuildcubic(&x, &y, n, -1, 0.0, -1, 0.0, &c);
   intab = spline1dintegrate(&c, 1.0);
   v = randomreal();
   vr = spline1dintegrate(&c, v);
   iOk = iOk && NearAtR(intab, 1, 0.001);
   for (i = -10; i <= 10; i++) {
      iOk = iOk && NearAtR(spline1dintegrate(&c, i + v), i * intab + vr, 0.001);
      iOk = iOk && NearAtR(spline1dintegrate(&c, i - 1000.0 * machineepsilon), i * intab, 0.001);
      iOk = iOk && NearAtR(spline1dintegrate(&c, (double)i), i * intab, 0.001);
      iOk = iOk && NearAtR(spline1dintegrate(&c, i + 1000.0 * machineepsilon), i * intab, 0.001);
   }
// Test monotone cubic Hermit interpolation
   bool monotoneOk = testspline1dunit_testmonotonespline();
// Interpolation test summary.
   bool interpOk = lsOk && csOk && crsOk && hsOk && asOk && monotoneOk;
// Test fitting errors
   bool fitOk = testspline1dunit_testsplinefitting();
// The final report.
   bool Ok = interpOk && fitOk && dsOk && cpOk && upOk && ltOk && iOk;
   if (!Ok || !silent) {
      printf("Spline 1D Tests\n");
   // Normal tests.
      printf("* Interpolation Tests:                    %s\n", interpOk? "Ok": "Failed");
      if (!interpOk) {
         printf("* - Linear Spline:                        %s\n", lsOk? "Ok": "Failed");
         printf("* - Cubic Spline:                         %s\n", csOk? "Ok": "Failed");
         printf("* - Catmull-Rom Spline:                   %s\n", crsOk? "Ok": "Failed");
         printf("* - Hermite Spline:                       %s\n", hsOk? "Ok": "Failed");
         printf("* - Akima Spline:                         %s\n", asOk? "Ok": "Failed");
         printf("* - Monotone Spline:                      %s\n", monotoneOk? "Ok": "Failed");
      }
   // Other tests.
      printf("* Fitting:                                %s\n", fitOk? "Ok": "Failed");
      printf("* Differentiation Test:                   %s\n", dsOk? "Ok": "Failed");
      printf("* Copy/Serialization Test:                %s\n", cpOk? "Ok": "Failed");
      printf("* Unpack Test:                            %s\n", upOk? "Ok": "Failed");
      printf("* Linear Transform Test:                  %s\n", ltOk? "Ok": "Failed");
      printf("* Integration Test:                       %s\n", iOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
// end
   ae_frame_leave();
   return Ok;
}

// === lsfit testing unit ===
// Unit test
static bool testlsfitunit_testpolynomialfitting() {
   ae_frame _frame_block;
   double threshold;
   double t;
   ae_int_t i;
   ae_int_t k;
   ae_int_t info;
   ae_int_t info2;
   double v;
   double v0;
   double v1;
   double v2;
   double s;
   double xmin;
   double xmax;
   double refrms;
   double refavg;
   double refavgrel;
   double refmax;
   ae_int_t n;
   ae_int_t m;
   ae_int_t maxn;
   ae_int_t pass;
   ae_int_t passcount;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(xfull, 0, DT_REAL);
   NewVector(yfull, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewVector(dc, 0, DT_INT);
   NewObj(barycentricinterpolant, p);
   NewObj(barycentricinterpolant, p1);
   NewObj(barycentricinterpolant, p2);
   NewObj(polynomialfitreport, rep);
   NewObj(polynomialfitreport, rep2);
   Ok = true;
   maxn = 5;
   passcount = 20;
   threshold = 1.0E8 * machineepsilon;
// Test polynomial fitting
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
      // N == M+K fitting (i.e. interpolation)
         for (k = 0; k < n; k++) {
            taskgenint1d(-1.0, 1.0, n, &xfull, &yfull);
            ae_vector_set_length(&x, n - k);
            ae_vector_set_length(&y, n - k);
            ae_vector_set_length(&w, n - k);
            if (k > 0) {
               ae_vector_set_length(&xc, k);
               ae_vector_set_length(&yc, k);
               ae_vector_set_length(&dc, k);
            }
            for (i = 0; i < n - k; i++) {
               x.xR[i] = xfull.xR[i];
               y.xR[i] = yfull.xR[i];
               w.xR[i] = 1 + randomreal();
            }
            for (i = 0; i < k; i++) {
               xc.xR[i] = xfull.xR[n - k + i];
               yc.xR[i] = yfull.xR[n - k + i];
               dc.xZ[i] = 0;
            }
            polynomialfitwc(&x, &y, &w, n - k, &xc, &yc, &dc, k, n, &info, &p1, &rep);
            if (info <= 0) {
               Ok = false;
            } else {
               for (i = 0; i < n - k; i++) {
                  Ok = Ok && NearAtR(barycentriccalc(&p1, x.xR[i]), y.xR[i], threshold);
               }
               for (i = 0; i < k; i++) {
                  Ok = Ok && NearAtR(barycentriccalc(&p1, xc.xR[i]), yc.xR[i], threshold);
               }
            }
         }
      // Testing constraints on derivatives.
      // Special tasks which will always have solution:
      // 1. P(0) == YC[0]
      // 2. P(0) == YC[0], P'(0) == YC[1]
         if (n > 1) {
            for (m = 3; m <= 5; m++) {
               for (k = 1; k <= 2; k++) {
                  taskgenint1d(-1.0, 1.0, n, &x, &y);
                  ae_vector_set_length(&w, n);
                  ae_vector_set_length(&xc, 2);
                  ae_vector_set_length(&yc, 2);
                  ae_vector_set_length(&dc, 2);
                  for (i = 0; i < n; i++) {
                     w.xR[i] = 1 + randomreal();
                  }
                  xc.xR[0] = 0.0;
                  yc.xR[0] = randommid();
                  dc.xZ[0] = 0;
                  xc.xR[1] = 0.0;
                  yc.xR[1] = randommid();
                  dc.xZ[1] = 1;
                  polynomialfitwc(&x, &y, &w, n, &xc, &yc, &dc, k, m, &info, &p1, &rep);
                  if (info <= 0) {
                     Ok = false;
                  } else {
                     barycentricdiff1(&p1, 0.0, &v0, &v1);
                     Ok = Ok && NearAtR(v0, yc.xR[0], threshold);
                     if (k == 2) {
                        Ok = Ok && NearAtR(v1, yc.xR[1], threshold);
                     }
                  }
               }
            }
         }
      }
   }
   for (m = 2; m <= 8; m++) {
      for (pass = 1; pass <= passcount; pass++) {
      // General fitting
      //
      // interpolating function through M nodes should have
      // greater RMS error than fitting it through the same M nodes
         n = 100;
         ae_vector_set_length(&x2, n);
         ae_vector_set_length(&y2, n);
         ae_vector_set_length(&w2, n);
         xmin = 0.0;
         xmax = 2 * pi;
         for (i = 0; i < n; i++) {
            x2.xR[i] = 2 * pi * randomreal();
            y2.xR[i] = sin(x2.xR[i]);
            w2.xR[i] = 1.0;
         }
         ae_vector_set_length(&x, m);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            x.xR[i] = xmin + (xmax - xmin) * i / (m - 1);
            y.xR[i] = sin(x.xR[i]);
         }
         polynomialbuild(&x, &y, m, &p1);
         polynomialfitwc(&x2, &y2, &w2, n, &xc, &yc, &dc, 0, m, &info, &p2, &rep);
         if (info <= 0) {
            Ok = false;
         } else {
         // calculate P1 (interpolant) RMS error, compare with P2 error
            v1 = 0.0;
            v2 = 0.0;
            for (i = 0; i < n; i++) {
               v1 += sqr(barycentriccalc(&p1, x2.xR[i]) - y2.xR[i]);
               v2 += sqr(barycentriccalc(&p2, x2.xR[i]) - y2.xR[i]);
            }
            v1 = sqrt(v1 / n);
            v2 = sqrt(v2 / n);
            Ok = Ok && v2 <= v1;
            Ok = Ok && NearAtR(v2, rep.rmserror, threshold);
         }
      // compare weighted and non-weighted
         n = 20;
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
         ae_vector_set_length(&w, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = i + (randomreal() - 0.5);
            y.xR[i] = randommid();
            w.xR[i] = 1.0;
         }
         polynomialfitwc(&x, &y, &w, n, &xc, &yc, &dc, 0, m, &info, &p1, &rep);
         polynomialfit(&x, &y, n, m, &info2, &p2, &rep2);
         if (info <= 0 || info2 <= 0) {
            Ok = false;
         } else {
         // calculate P1 (interpolant), compare with P2 error
         // compare RMS errors
            t = randommid();
            v1 = barycentriccalc(&p1, t);
            v2 = barycentriccalc(&p2, t);
            Ok = Ok && NearAtR(v2, v1, 1.0E-12);
            Ok = Ok && NearAtR(rep.rmserror, rep2.rmserror, 1.0E-12 * rmax3(1.0, rep.rmserror, rep2.rmserror));
            Ok = Ok && NearAtR(rep.avgerror, rep2.avgerror, 1.0E-12 * rmax3(1.0, rep.avgerror, rep2.avgerror));
            Ok = Ok && NearAtR(rep.avgrelerror, rep2.avgrelerror, 1.0E-12 * rmax3(1.0, rep.avgrelerror, rep2.avgrelerror));
            Ok = Ok && NearAtR(rep.maxerror, rep2.maxerror, 1.0E-12 * rmax3(1.0, rep.maxerror, rep2.maxerror));
         }
      }
   }
   for (m = 1; m <= maxn; m++) {
      for (pass = 1; pass <= passcount; pass++) {
         ae_assert(passcount >= 2, "PassCount should be 2 or greater!");
      // solve simple task (all X[] are the same, Y[] are specially
      // calculated to ensure simple form of all types of errors)
      // and check correctness of the errors calculated by subroutines
      //
      // First pass is done with zero Y[], other passes - with random Y[].
      // It should test both ability to correctly calculate errors and
      // ability to not fail while working with zeros :)
         n = 4 * maxn;
         if (pass == 1) {
            v1 = 0.0;
            v2 = 0.0;
            v = 0.0;
         } else {
            v1 = randomreal();
            v2 = randomreal();
            v = 1 + randomreal();
         }
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
         ae_vector_set_length(&w, n);
         for (i = 0; i < maxn; i++) {
            x.xR[4 * i] = (double)i;
            y.xR[4 * i] = v - v2;
            w.xR[4 * i] = 1.0;
            x.xR[4 * i + 1] = (double)i;
            y.xR[4 * i + 1] = v - v1;
            w.xR[4 * i + 1] = 1.0;
            x.xR[4 * i + 2] = (double)i;
            y.xR[4 * i + 2] = v + v1;
            w.xR[4 * i + 2] = 1.0;
            x.xR[4 * i + 3] = (double)i;
            y.xR[4 * i + 3] = v + v2;
            w.xR[4 * i + 3] = 1.0;
         }
         refrms = sqrt((sqr(v1) + sqr(v2)) / 2);
         refavg = (fabs(v1) + fabs(v2)) / 2;
         if (pass == 1) {
            refavgrel = 0.0;
         } else {
            refavgrel = 0.25 * (fabs(v2) / fabs(v - v2) + fabs(v1) / fabs(v - v1) + fabs(v1) / fabs(v + v1) + fabs(v2) / fabs(v + v2));
         }
         refmax = rmax2(v1, v2);
      // Test errors correctness
         polynomialfit(&x, &y, n, m, &info, &p, &rep);
         if (info <= 0) {
            Ok = false;
         } else {
            s = barycentriccalc(&p, 0.0);
            Ok = Ok && NearAtR(s, v, threshold);
            Ok = Ok && NearAtR(rep.rmserror, refrms, threshold);
            Ok = Ok && NearAtR(rep.avgerror, refavg, threshold);
            Ok = Ok && NearAtR(rep.avgrelerror, refavgrel, threshold);
            Ok = Ok && NearAtR(rep.maxerror, refmax, threshold);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

static bool testlsfitunit_testrationalfitting() {
   ae_frame _frame_block;
   double threshold;
   ae_int_t maxn;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t k;
   ae_int_t pass;
   double t;
   double s;
   double v;
   double v0;
   double v1;
   double v2;
   ae_int_t info;
   ae_int_t info2;
   double xmin;
   double xmax;
   double refrms;
   double refavg;
   double refavgrel;
   double refmax;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(barycentricinterpolant, b1);
   NewObj(barycentricinterpolant, b2);
   NewVector(x, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewVector(dc, 0, DT_INT);
   NewObj(barycentricfitreport, rep);
   NewObj(barycentricfitreport, rep2);
   Ok = true;
// PassCount        number of repeated passes
// Threshold        error tolerance
// LipschitzTol     Lipschitz constant increase allowed
//                  when calculating constant on a twice denser grid
   passcount = 5;
   maxn = 15;
   threshold = 1000000.0 * machineepsilon;
// Test rational fitting:
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 2; n <= maxn; n++) {
      // N == M+K fitting (i.e. interpolation)
         for (k = 0; k < n; k++) {
            ae_vector_set_length(&x, n - k);
            ae_vector_set_length(&y, n - k);
            ae_vector_set_length(&w, n - k);
            if (k > 0) {
               ae_vector_set_length(&xc, k);
               ae_vector_set_length(&yc, k);
               ae_vector_set_length(&dc, k);
            }
            for (i = 0; i < n - k; i++) {
               x.xR[i] = (double)i / (n - 1);
               y.xR[i] = randommid();
               w.xR[i] = 1 + randomreal();
            }
            for (i = 0; i < k; i++) {
               xc.xR[i] = (double)(n - k + i) / (n - 1);
               yc.xR[i] = randommid();
               dc.xZ[i] = 0;
            }
            barycentricfitfloaterhormannwc(&x, &y, &w, n - k, &xc, &yc, &dc, k, n, &info, &b1, &rep);
            if (info <= 0) {
               Ok = false;
            } else {
               for (i = 0; i < n - k; i++) {
                  Ok = Ok && NearAtR(barycentriccalc(&b1, x.xR[i]), y.xR[i], threshold);
               }
               for (i = 0; i < k; i++) {
                  Ok = Ok && NearAtR(barycentriccalc(&b1, xc.xR[i]), yc.xR[i], threshold);
               }
            }
         }
      // Testing constraints on derivatives:
      // * several M's are tried
      // * several K's are tried - 1, 2.
      // * constraints at the ends of the interval
         for (m = 3; m <= 5; m++) {
            for (k = 1; k <= 2; k++) {
               ae_vector_set_length(&x, n);
               ae_vector_set_length(&y, n);
               ae_vector_set_length(&w, n);
               ae_vector_set_length(&xc, 2);
               ae_vector_set_length(&yc, 2);
               ae_vector_set_length(&dc, 2);
               for (i = 0; i < n; i++) {
                  x.xR[i] = randommid();
                  y.xR[i] = randommid();
                  w.xR[i] = 1 + randomreal();
               }
               xc.xR[0] = -1.0;
               yc.xR[0] = randommid();
               dc.xZ[0] = 0;
               xc.xR[1] = 1.0;
               yc.xR[1] = randommid();
               dc.xZ[1] = 0;
               barycentricfitfloaterhormannwc(&x, &y, &w, n, &xc, &yc, &dc, k, m, &info, &b1, &rep);
               if (info <= 0) {
                  Ok = false;
               } else {
                  for (i = 0; i < k; i++) {
                     barycentricdiff1(&b1, xc.xR[i], &v0, &v1);
                     Ok = Ok && NearAtR(v0, yc.xR[i], threshold);
                  }
               }
            }
         }
      }
   }
   for (m = 2; m <= 8; m++) {
      for (pass = 1; pass <= passcount; pass++) {
      // General fitting
      //
      // interpolating function through M nodes should have
      // greater RMS error than fitting it through the same M nodes
         n = 100;
         ae_vector_set_length(&x2, n);
         ae_vector_set_length(&y2, n);
         ae_vector_set_length(&w2, n);
         xmin = maxrealnumber;
         xmax = -maxrealnumber;
         for (i = 0; i < n; i++) {
            x2.xR[i] = 2 * pi * randomreal();
            y2.xR[i] = sin(x2.xR[i]);
            w2.xR[i] = 1.0;
            xmin = rmin2(xmin, x2.xR[i]);
            xmax = rmax2(xmax, x2.xR[i]);
         }
         ae_vector_set_length(&x, m);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            x.xR[i] = xmin + (xmax - xmin) * i / (m - 1);
            y.xR[i] = sin(x.xR[i]);
         }
         barycentricbuildfloaterhormann(&x, &y, m, 3, &b1);
         barycentricfitfloaterhormannwc(&x2, &y2, &w2, n, &xc, &yc, &dc, 0, m, &info, &b2, &rep);
         if (info <= 0) {
            Ok = false;
         } else {
         // calculate B1 (interpolant) RMS error, compare with B2 error
            v1 = 0.0;
            v2 = 0.0;
            for (i = 0; i < n; i++) {
               v1 += sqr(barycentriccalc(&b1, x2.xR[i]) - y2.xR[i]);
               v2 += sqr(barycentriccalc(&b2, x2.xR[i]) - y2.xR[i]);
            }
            v1 = sqrt(v1 / n);
            v2 = sqrt(v2 / n);
            Ok = Ok && v2 <= v1;
            Ok = Ok && NearAtR(v2, rep.rmserror, threshold);
         }
      // compare weighted and non-weighted
         n = 20;
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
         ae_vector_set_length(&w, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = i + (randomreal() - 0.5);
            y.xR[i] = randommid();
            w.xR[i] = 1.0;
         }
         barycentricfitfloaterhormannwc(&x, &y, &w, n, &xc, &yc, &dc, 0, m, &info, &b1, &rep);
         barycentricfitfloaterhormann(&x, &y, n, m, &info2, &b2, &rep2);
         if (info <= 0 || info2 <= 0) {
            Ok = false;
         } else {
         // calculate B1 (interpolant), compare with B2
         // compare RMS errors
            t = randommid();
            v1 = barycentriccalc(&b1, t);
            v2 = barycentriccalc(&b2, t);
            Ok = Ok && NearAtR(v2, v1, 1.0E-12);
            Ok = Ok && NearAtR(rep.rmserror, rep2.rmserror, 1.0E-12 * rmax3(1.0, rep.rmserror, rep2.rmserror));
            Ok = Ok && NearAtR(rep.avgerror, rep2.avgerror, 1.0E-12 * rmax3(1.0, rep.avgerror, rep2.avgerror));
            Ok = Ok && NearAtR(rep.avgrelerror, rep2.avgrelerror, 1.0E-12 * rmax3(1.0, rep.avgrelerror, rep2.avgrelerror));
            Ok = Ok && NearAtR(rep.maxerror, rep2.maxerror, 1.0E-12 * rmax3(1.0, rep.maxerror, rep2.maxerror));
         }
      }
   }
   for (pass = 1; pass <= passcount; pass++) {
      ae_assert(passcount >= 2, "PassCount should be 2 or greater!");
   // solve simple task (all X[] are the same, Y[] are specially
   // calculated to ensure simple form of all types of errors)
   // and check correctness of the errors calculated by subroutines
   //
   // First pass is done with zero Y[], other passes - with random Y[].
   // It should test both ability to correctly calculate errors and
   // ability to not fail while working with zeros :)
      n = 4;
      if (pass == 1) {
         v1 = 0.0;
         v2 = 0.0;
         v = 0.0;
      } else {
         v1 = randomreal();
         v2 = randomreal();
         v = 1 + randomreal();
      }
      ae_vector_set_length(&x, 4);
      ae_vector_set_length(&y, 4);
      ae_vector_set_length(&w, 4);
      x.xR[0] = 0.0;
      y.xR[0] = v - v2;
      w.xR[0] = 1.0;
      x.xR[1] = 0.0;
      y.xR[1] = v - v1;
      w.xR[1] = 1.0;
      x.xR[2] = 0.0;
      y.xR[2] = v + v1;
      w.xR[2] = 1.0;
      x.xR[3] = 0.0;
      y.xR[3] = v + v2;
      w.xR[3] = 1.0;
      refrms = sqrt((sqr(v1) + sqr(v2)) / 2);
      refavg = (fabs(v1) + fabs(v2)) / 2;
      if (pass == 1) {
         refavgrel = 0.0;
      } else {
         refavgrel = 0.25 * (fabs(v2) / fabs(v - v2) + fabs(v1) / fabs(v - v1) + fabs(v1) / fabs(v + v1) + fabs(v2) / fabs(v + v2));
      }
      refmax = rmax2(v1, v2);
   // Test errors correctness
      barycentricfitfloaterhormann(&x, &y, 4, 2, &info, &b1, &rep);
      if (info <= 0) {
         Ok = false;
      } else {
         s = barycentriccalc(&b1, 0.0);
         Ok = Ok && NearAtR(s, v, threshold);
         Ok = Ok && NearAtR(rep.rmserror, refrms, threshold);
         Ok = Ok && NearAtR(rep.avgerror, refavg, threshold);
         Ok = Ok && NearAtR(rep.avgrelerror, refavgrel, threshold);
         Ok = Ok && NearAtR(rep.maxerror, refmax, threshold);
      }
   }
   ae_frame_leave();
   return Ok;
}

static bool testlsfitunit_testsplinefitting() {
   ae_frame _frame_block;
   double threshold;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t k;
   ae_int_t pass;
   double sa;
   double sb;
   ae_int_t info;
   ae_int_t info1;
   ae_int_t info2;
   double s;
   double ds;
   double d2s;
   ae_int_t stype;
   double t;
   double v;
   double v1;
   double v2;
   double refrms;
   double refavg;
   double refavgrel;
   double refmax;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(dc, 0, DT_INT);
   NewObj(spline1dinterpolant, c);
   NewObj(spline1dinterpolant, c2);
   NewObj(spline1dfitreport, rep);
   NewObj(spline1dfitreport, rep2);
// Valyes:
// * pass count
// * threshold - for tests which must be satisfied exactly
   passcount = 20;
   threshold = 10000.0 * machineepsilon;
   Ok = true;
// Test fitting by Cubic and Hermite splines (obsolete, but still supported)
   for (pass = 1; pass <= passcount; pass++) {
   // Cubic splines
   // Ability to handle boundary constraints (1-4 constraints on F, dF/dx).
      for (m = 4; m <= 8; m++) {
         for (k = 1; k <= 4; k++) {
            if (k >= m) {
               continue;
            }
            n = 100;
            ae_vector_set_length(&x, n);
            ae_vector_set_length(&y, n);
            ae_vector_set_length(&w, n);
            ae_vector_set_length(&xc, 4);
            ae_vector_set_length(&yc, 4);
            ae_vector_set_length(&dc, 4);
            sa = 1 + randomreal();
            sb = randommid();
            for (i = 0; i < n; i++) {
               x.xR[i] = sa * randomreal() + sb;
               y.xR[i] = randommid();
               w.xR[i] = 1 + randomreal();
            }
            xc.xR[0] = sb;
            yc.xR[0] = randommid();
            dc.xZ[0] = 0;
            xc.xR[1] = sb;
            yc.xR[1] = randommid();
            dc.xZ[1] = 1;
            xc.xR[2] = sa + sb;
            yc.xR[2] = randommid();
            dc.xZ[2] = 0;
            xc.xR[3] = sa + sb;
            yc.xR[3] = randommid();
            dc.xZ[3] = 1;
            spline1dfitcubicwc(&x, &y, &w, n, &xc, &yc, &dc, k, m, &info, &c, &rep);
            if (info <= 0) {
               Ok = false;
            } else {
            // Check that constraints are satisfied
               for (i = 0; i < k; i++) {
                  spline1ddiff(&c, xc.xR[i], &s, &ds, &d2s);
                  if (dc.xZ[i] == 0) {
                     Ok = Ok && NearAtR(s, yc.xR[i], threshold);
                  }
                  if (dc.xZ[i] == 1) {
                     Ok = Ok && NearAtR(ds, yc.xR[i], threshold);
                  }
                  if (dc.xZ[i] == 2) {
                     Ok = Ok && NearAtR(d2s, yc.xR[i], threshold);
                  }
               }
            }
         }
      }
   // Cubic splines
   // Ability to handle one internal constraint
      for (m = 4; m <= 8; m++) {
         n = 100;
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
         ae_vector_set_length(&w, n);
         ae_vector_set_length(&xc, 1);
         ae_vector_set_length(&yc, 1);
         ae_vector_set_length(&dc, 1);
         sa = 1 + randomreal();
         sb = randommid();
         for (i = 0; i < n; i++) {
            x.xR[i] = sa * randomreal() + sb;
            y.xR[i] = randommid();
            w.xR[i] = 1 + randomreal();
         }
         xc.xR[0] = sa * randomreal() + sb;
         yc.xR[0] = randommid();
         dc.xZ[0] = randominteger(2);
         spline1dfitcubicwc(&x, &y, &w, n, &xc, &yc, &dc, 1, m, &info, &c, &rep);
         if (info <= 0) {
            Ok = false;
         } else {
         // Check that constraints are satisfied
            spline1ddiff(&c, xc.xR[0], &s, &ds, &d2s);
            if (dc.xZ[0] == 0) {
               Ok = Ok && NearAtR(s, yc.xR[0], threshold);
            }
            if (dc.xZ[0] == 1) {
               Ok = Ok && NearAtR(ds, yc.xR[0], threshold);
            }
            if (dc.xZ[0] == 2) {
               Ok = Ok && NearAtR(d2s, yc.xR[0], threshold);
            }
         }
      }
   // Hermite splines
   // Ability to handle boundary constraints (1-4 constraints on F, dF/dx).
      for (m = 4; m <= 8; m++) {
         for (k = 1; k <= 4; k++) {
            if (k >= m) {
               continue;
            }
            if (m % 2 != 0) {
               continue;
            }
            n = 100;
            ae_vector_set_length(&x, n);
            ae_vector_set_length(&y, n);
            ae_vector_set_length(&w, n);
            ae_vector_set_length(&xc, 4);
            ae_vector_set_length(&yc, 4);
            ae_vector_set_length(&dc, 4);
            sa = 1 + randomreal();
            sb = randommid();
            for (i = 0; i < n; i++) {
               x.xR[i] = sa * randomreal() + sb;
               y.xR[i] = randommid();
               w.xR[i] = 1 + randomreal();
            }
            xc.xR[0] = sb;
            yc.xR[0] = randommid();
            dc.xZ[0] = 0;
            xc.xR[1] = sb;
            yc.xR[1] = randommid();
            dc.xZ[1] = 1;
            xc.xR[2] = sa + sb;
            yc.xR[2] = randommid();
            dc.xZ[2] = 0;
            xc.xR[3] = sa + sb;
            yc.xR[3] = randommid();
            dc.xZ[3] = 1;
            spline1dfithermitewc(&x, &y, &w, n, &xc, &yc, &dc, k, m, &info, &c, &rep);
            if (info <= 0) {
               Ok = false;
            } else {
            // Check that constraints are satisfied
               for (i = 0; i < k; i++) {
                  spline1ddiff(&c, xc.xR[i], &s, &ds, &d2s);
                  if (dc.xZ[i] == 0) {
                     Ok = Ok && NearAtR(s, yc.xR[i], threshold);
                  }
                  if (dc.xZ[i] == 1) {
                     Ok = Ok && NearAtR(ds, yc.xR[i], threshold);
                  }
                  if (dc.xZ[i] == 2) {
                     Ok = Ok && NearAtR(d2s, yc.xR[i], threshold);
                  }
               }
            }
         }
      }
   // Hermite splines
   // Ability to handle one internal constraint
      for (m = 4; m <= 8; m++) {
         if (m % 2 != 0) {
            continue;
         }
         n = 100;
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
         ae_vector_set_length(&w, n);
         ae_vector_set_length(&xc, 1);
         ae_vector_set_length(&yc, 1);
         ae_vector_set_length(&dc, 1);
         sa = 1 + randomreal();
         sb = randommid();
         for (i = 0; i < n; i++) {
            x.xR[i] = sa * randomreal() + sb;
            y.xR[i] = randommid();
            w.xR[i] = 1 + randomreal();
         }
         xc.xR[0] = sa * randomreal() + sb;
         yc.xR[0] = randommid();
         dc.xZ[0] = randominteger(2);
         spline1dfithermitewc(&x, &y, &w, n, &xc, &yc, &dc, 1, m, &info, &c, &rep);
         if (info <= 0) {
            Ok = false;
         } else {
         // Check that constraints are satisfied
            spline1ddiff(&c, xc.xR[0], &s, &ds, &d2s);
            if (dc.xZ[0] == 0) {
               Ok = Ok && NearAtR(s, yc.xR[0], threshold);
            }
            if (dc.xZ[0] == 1) {
               Ok = Ok && NearAtR(ds, yc.xR[0], threshold);
            }
            if (dc.xZ[0] == 2) {
               Ok = Ok && NearAtR(d2s, yc.xR[0], threshold);
            }
         }
      }
   }
   for (m = 4; m <= 8; m++) {
      for (stype = 0; stype <= 1; stype++) {
         for (pass = 1; pass <= passcount; pass++) {
            if (stype == 1 && m % 2 != 0) {
               continue;
            }
         // cubic/Hermite spline fitting:
         // * generate "template spline" C2
         // * generate 2*N points from C2, such that result of
         //   ideal fit should be equal to C2
         // * fit, store in C
         // * compare C and C2
            sa = 1 + randomreal();
            sb = randommid();
            if (stype == 0) {
               ae_vector_set_length(&x, m - 2);
               ae_vector_set_length(&y, m - 2);
               for (i = 0; i < m - 2; i++) {
                  x.xR[i] = sa * i / (m - 2 - 1) + sb;
                  y.xR[i] = randommid();
               }
               spline1dbuildcubic(&x, &y, m - 2, 1, randommid(), 1, randommid(), &c2);
            }
            if (stype == 1) {
               ae_vector_set_length(&x, m / 2);
               ae_vector_set_length(&y, m / 2);
               ae_vector_set_length(&d, m / 2);
               for (i = 0; i < m / 2; i++) {
                  x.xR[i] = sa * i / (m / 2 - 1) + sb;
                  y.xR[i] = randommid();
                  d.xR[i] = randommid();
               }
               spline1dbuildhermite(&x, &y, &d, m / 2, &c2);
            }
            n = 50;
            ae_vector_set_length(&x, 2 * n);
            ae_vector_set_length(&y, 2 * n);
            ae_vector_set_length(&w, 2 * n);
            for (i = 0; i < n; i++) {
            // "if i == 0" and "if i == 1" are needed to
            // synchronize interval size for C2 and
            // spline being fitted (i.e. C).
               t = randomreal();
               x.xR[i] = sa * randomreal() + sb;
               if (i == 0) {
                  x.xR[i] = sb;
               }
               if (i == 1) {
                  x.xR[i] = sa + sb;
               }
               v = spline1dcalc(&c2, x.xR[i]);
               y.xR[i] = v + t;
               w.xR[i] = 1 + randomreal();
               x.xR[n + i] = x.xR[i];
               y.xR[n + i] = v - t;
               w.xR[n + i] = w.xR[i];
            }
            info = -1;
            if (stype == 0) {
               spline1dfitcubicwc(&x, &y, &w, 2 * n, &xc, &yc, &dc, 0, m, &info, &c, &rep);
            }
            if (stype == 1) {
               spline1dfithermitewc(&x, &y, &w, 2 * n, &xc, &yc, &dc, 0, m, &info, &c, &rep);
            }
            if (info <= 0) {
               Ok = false;
            } else {
               for (i = 0; i < n; i++) {
                  v = sa * randomreal() + sb;
                  Ok = Ok && NearAtR(spline1dcalc(&c, v), spline1dcalc(&c2, v), threshold);
               }
            }
         }
      }
   }
   for (m = 4; m <= 8; m++) {
      for (pass = 1; pass <= passcount; pass++) {
      // prepare points/weights
         n = 10 + randominteger(10);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
         ae_vector_set_length(&w, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = i + (randomreal() - 0.5);
            y.xR[i] = randommid();
            w.xR[i] = 1.0;
         }
      // Fit cubic with unity weights, without weights, then compare
         if (m >= 4) {
            spline1dfitcubicwc(&x, &y, &w, n, &xc, &yc, &dc, 0, m, &info1, &c, &rep);
            spline1dfitcubic(&x, &y, n, m, &info2, &c2, &rep2);
            if (info1 <= 0 || info2 <= 0) {
               Ok = false;
            } else {
               for (i = 0; i < n; i++) {
                  v = randomreal() * (n - 1);
                  Ok = Ok && NearAtR(spline1dcalc(&c, v), spline1dcalc(&c2, v), 1.0E-12);
                  Ok = Ok && NearAtR(rep.taskrcond, rep2.taskrcond, 1.0E-12 * rmax3(1.0, rep.taskrcond, rep2.taskrcond));
                  Ok = Ok && NearAtR(rep.rmserror, rep2.rmserror, 1.0E-12 * rmax3(1.0, rep.rmserror, rep2.rmserror));
                  Ok = Ok && NearAtR(rep.avgerror, rep2.avgerror, 1.0E-12 * rmax3(1.0, rep.avgerror, rep2.avgerror));
                  Ok = Ok && NearAtR(rep.avgrelerror, rep2.avgrelerror, 1.0E-12 * rmax3(1.0, rep.avgrelerror, rep2.avgrelerror));
                  Ok = Ok && NearAtR(rep.maxerror, rep2.maxerror, 1.0E-12 * rmax3(1.0, rep.maxerror, rep2.maxerror));
               }
            }
         }
      // Fit Hermite with unity weights, without weights, then compare
         if (m >= 4 && m % 2 == 0) {
            spline1dfithermitewc(&x, &y, &w, n, &xc, &yc, &dc, 0, m, &info1, &c, &rep);
            spline1dfithermite(&x, &y, n, m, &info2, &c2, &rep2);
            if (info1 <= 0 || info2 <= 0) {
               Ok = false;
            } else {
               for (i = 0; i < n; i++) {
                  v = randomreal() * (n - 1);
                  Ok = Ok && NearAtR(spline1dcalc(&c, v), spline1dcalc(&c2, v), 1.0E-12);
                  Ok = Ok && NearAtR(rep.taskrcond, rep2.taskrcond, 1.0E-12 * rmax3(1.0, rep.taskrcond, rep2.taskrcond));
                  Ok = Ok && NearAtR(rep.rmserror, rep2.rmserror, 1.0E-12 * rmax3(1.0, rep.rmserror, rep2.rmserror));
                  Ok = Ok && NearAtR(rep.avgerror, rep2.avgerror, 1.0E-12 * rmax3(1.0, rep.avgerror, rep2.avgerror));
                  Ok = Ok && NearAtR(rep.avgrelerror, rep2.avgrelerror, 1.0E-12 * rmax3(1.0, rep.avgrelerror, rep2.avgrelerror));
                  Ok = Ok && NearAtR(rep.maxerror, rep2.maxerror, 1.0E-12 * rmax3(1.0, rep.maxerror, rep2.maxerror));
               }
            }
         }
      }
   }
// Check correctness of error reports
   for (pass = 1; pass <= passcount; pass++) {
      ae_assert(passcount >= 2, "PassCount should be 2 or greater!");
   // solve simple task (all X[] are the same, Y[] are specially
   // calculated to ensure simple form of all types of errors)
   // and check correctness of the errors calculated by subroutines
   //
   // First pass is done with zero Y[], other passes - with random Y[].
   // It should test both ability to correctly calculate errors and
   // ability to not fail while working with zeros :)
      n = 4;
      if (pass == 1) {
         v1 = 0.0;
         v2 = 0.0;
         v = 0.0;
      } else {
         v1 = randomreal();
         v2 = randomreal();
         v = 1 + randomreal();
      }
      ae_vector_set_length(&x, 4);
      ae_vector_set_length(&y, 4);
      ae_vector_set_length(&w, 4);
      x.xR[0] = 0.0;
      y.xR[0] = v - v2;
      w.xR[0] = 1.0;
      x.xR[1] = 0.0;
      y.xR[1] = v - v1;
      w.xR[1] = 1.0;
      x.xR[2] = 0.0;
      y.xR[2] = v + v1;
      w.xR[2] = 1.0;
      x.xR[3] = 0.0;
      y.xR[3] = v + v2;
      w.xR[3] = 1.0;
      refrms = sqrt((sqr(v1) + sqr(v2)) / 2);
      refavg = (fabs(v1) + fabs(v2)) / 2;
      if (pass == 1) {
         refavgrel = 0.0;
      } else {
         refavgrel = 0.25 * (fabs(v2) / fabs(v - v2) + fabs(v1) / fabs(v - v1) + fabs(v1) / fabs(v + v1) + fabs(v2) / fabs(v + v2));
      }
      refmax = rmax2(v1, v2);
   // Test cubic fitting
      spline1dfitcubic(&x, &y, 4, 4, &info, &c, &rep);
      if (info <= 0) {
         Ok = false;
      } else {
         s = spline1dcalc(&c, 0.0);
         Ok = Ok && NearAtR(s, v, threshold);
         Ok = Ok && NearAtR(rep.rmserror, refrms, threshold);
         Ok = Ok && NearAtR(rep.avgerror, refavg, threshold);
         Ok = Ok && NearAtR(rep.avgrelerror, refavgrel, threshold);
         Ok = Ok && NearAtR(rep.maxerror, refmax, threshold);
      }
   // Test Hermite fitting
      spline1dfithermite(&x, &y, 4, 4, &info, &c, &rep);
      if (info <= 0) {
         Ok = false;
      } else {
         s = spline1dcalc(&c, 0.0);
         Ok = Ok && NearAtR(s, v, threshold);
         Ok = Ok && NearAtR(rep.rmserror, refrms, threshold);
         Ok = Ok && NearAtR(rep.avgerror, refavg, threshold);
         Ok = Ok && NearAtR(rep.avgrelerror, refavgrel, threshold);
         Ok = Ok && NearAtR(rep.maxerror, refmax, threshold);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test function 1:
//
//     F(K, X, Z) = SUM( (power(z_j,3)+alpha*z_j)*x_ij )
//
// here X is a space of points, Z is a space of parameters
static void testlsfitunit_testfunc1(ae_int_t k, RVector *x, RVector *z, double *f, bool needf, RVector *g, bool needg) {
   ae_int_t j;
   double v;
   double alpha;
   alpha = 0.01;
   v = 0.0;
   for (j = 0; j < k; j++) {
      v += (alpha * z->xR[j] + pow(z->xR[j], 3.0)) * x->xR[j];
      if (needg) {
         g->xR[j] = (alpha + 3 * pow(z->xR[j], 2.0)) * x->xR[j];
      }
   }
   if (needf) {
      *f = v;
   }
}

// Test function 2:
//
//     F(X|C) = c_0
//
// here X is a space of points, C is a space of parameters
static void testlsfitunit_testfunc2(RVector *x, ae_int_t nx, RVector *c, ae_int_t nc, double *f, bool needf, RVector *g, bool needg) {
   ae_assert(nc == 1, "TestFunc2: integrity check failure");
   if (needf) {
      *f = c->xR[0];
   }
   if (needg) {
      g->xR[0] = 1.0;
   }
}

// Test function 3:
//
//     F(X|C) = c_0 + c_1*x0 + c_2*x0^2 + ...
//
// here X is a space of points, C is a space of parameters
static void testlsfitunit_testfunc3(RVector *x, ae_int_t nx, RVector *c, ae_int_t nc, double *f, bool needf, RVector *g, bool needg) {
   double v;
   ae_int_t i;
   ae_assert(nx == 1, "TestFunc3: integrity check failure");
   v = 0.0;
   for (i = 0; i < nc; i++) {
      v += c->xR[i] * pow(x->xR[0], (double)i);
      if (needg) {
         g->xR[i] = pow(x->xR[0], (double)i);
      }
   }
   if (needf) {
      *f = v;
   }
}

// Test for box constrained problemsNLS.
static bool testlsfitunit_testbcnls() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t nc;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ii;
   double v;
   double h;
   double epsx;
   double f0;
   double f1;
   ae_int_t tmpkind;
   ae_int_t terminationtype;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(lsfitstate, state);
   NewObj(lsfitreport, rep);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(c0, 0, DT_REAL);
   NewVector(c1, 0, DT_REAL);
   NewVector(c2, 0, DT_REAL);
   NewMatrix(xx, 0, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Fit
//
//                  [                              ]
//    f(X|C) = SUM_j[ (alpha*c_j+power(c_j,3))*x_j ]
//                  [                              ]
//
// subject to non-negativity constraints on c_j
   epsx = 1.0E-9;
   for (tmpkind = 0; tmpkind <= 1; tmpkind++) {
      for (nc = 1; nc <= 20; nc++) {
         nx = nc;
         m = nc + hqrnduniformi(&rs, nc);
         ae_vector_set_length(&bl, nc);
         ae_vector_set_length(&bu, nc);
         ae_vector_set_length(&c0, nc);
         ae_vector_set_length(&x, nx);
         for (i = 0; i < nc; i++) {
            bl.xR[i] = 0.0;
            bu.xR[i] = +INFINITY;
            c0.xR[i] = 1.0 + hqrnduniformr(&rs);
         }
         ae_matrix_set_length(&xx, m, nx);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < nx; j++) {
               xx.xyR[i][j] = hqrndnormal(&rs);
            }
            y.xR[i] = hqrndnormal(&rs);
         }
         if (tmpkind == 0) {
            lsfitcreatef(&xx, &y, &c0, m, nx, nc, 10 * epsx, &state);
         }
         if (tmpkind == 1) {
            lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
         }
         lsfitsetcond(&state, epsx, 0);
         lsfitsetbc(&state, &bl, &bu);
         while (lsfititeration(&state)) {
            for (i = 0; i < nc; i++) {
               Ok = Ok && state.c.xR[i] >= bl.xR[i];
               Ok = Ok && state.c.xR[i] <= bu.xR[i];
            }
            if (state.needf) {
               testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, false);
            } else if (state.needfg) {
               testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, true);
            } else ae_assert(false, "minlm test: integrity check failed");
         }
         lsfitresults(&state, &terminationtype, &c1, &rep);
         Ok = Ok && terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         f0 = 0.0;
         for (ii = 0; ii < m; ii++) {
            ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
            testlsfitunit_testfunc1(nx, &x, &c1, &v, true, &state.g, false);
            f0 += sqr(v - y.xR[ii]);
         }
         h = 0.001;
         ae_vector_set_length(&c2, nc);
         for (i = 0; i < nc; i++) {
            Ok = Ok && c1.xR[i] >= bl.xR[i];
            Ok = Ok && c1.xR[i] <= bu.xR[i];
            if (c1.xR[i] + h >= bl.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] += h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc1(nx, &x, &c2, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               Ok = Ok && f1 >= f0;
            }
            if (c1.xR[i] - h >= bl.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] -= h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc1(nx, &x, &c2, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               Ok = Ok && f1 >= f0;
            }
         }
      }
   }
// Fit
//
//                  [                              ]
//    f(X|C) = SUM_j[ (alpha*c_j+power(c_j,3))*x_j ]
//                  [                              ]
//
// subject to random box constraints on c_j
   epsx = 1.0E-9;
   for (tmpkind = 0; tmpkind <= 1; tmpkind++) {
      for (nc = 1; nc <= 20; nc++) {
         nx = nc;
         m = nc + hqrnduniformi(&rs, nc);
         ae_vector_set_length(&bl, nc);
         ae_vector_set_length(&bu, nc);
         ae_vector_set_length(&c0, nc);
         ae_vector_set_length(&x, nx);
         for (i = 0; i < nc; i++) {
            bl.xR[i] = hqrndnormal(&rs);
            bu.xR[i] = bl.xR[i] + hqrnduniformr(&rs);
            c0.xR[i] = 1.0 + hqrnduniformr(&rs);
         }
         ae_matrix_set_length(&xx, m, nx);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < nx; j++) {
               xx.xyR[i][j] = hqrndnormal(&rs);
            }
            y.xR[i] = hqrndnormal(&rs);
         }
         if (tmpkind == 0) {
            lsfitcreatef(&xx, &y, &c0, m, nx, nc, 10 * epsx, &state);
         }
         if (tmpkind == 1) {
            lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
         }
         lsfitsetcond(&state, epsx, 0);
         lsfitsetbc(&state, &bl, &bu);
         while (lsfititeration(&state)) {
            for (i = 0; i < nc; i++) {
               Ok = Ok && state.c.xR[i] >= bl.xR[i];
               Ok = Ok && state.c.xR[i] <= bu.xR[i];
            }
            if (state.needf) {
               testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, false);
            } else if (state.needfg) {
               testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, true);
            } else ae_assert(false, "minlm test: integrity check failed");
         }
         lsfitresults(&state, &terminationtype, &c1, &rep);
         Ok = Ok && terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         f0 = 0.0;
         for (ii = 0; ii < m; ii++) {
            ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
            testlsfitunit_testfunc1(nx, &x, &c1, &v, true, &state.g, false);
            f0 += sqr(v - y.xR[ii]);
         }
         h = 0.001;
         ae_vector_set_length(&c2, nc);
         for (i = 0; i < nc; i++) {
            Ok = Ok && c1.xR[i] >= bl.xR[i];
            Ok = Ok && c1.xR[i] <= bu.xR[i];
            if (c1.xR[i] + h >= bl.xR[i] && c1.xR[i] + h <= bu.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] += h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc1(nx, &x, &c2, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               Ok = Ok && f1 >= f0;
            }
            if (c1.xR[i] - h >= bl.xR[i] && c1.xR[i] - h <= bu.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] -= h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc1(nx, &x, &c2, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               Ok = Ok && f1 >= f0;
            }
         }
      }
   }
// Fit
//
//    f(X|C) = c_0
//
// subject to random box constraints on c_0, where X is N-dimensional vector
// (f does not depend on X, and it is not an error! we just test that sizes
// of X and C are correctly handled).
   epsx = 1.0E-9;
   for (tmpkind = 0; tmpkind <= 1; tmpkind++) {
      for (nx = 1; nx <= 20; nx++) {
         nc = 1;
         m = nx + hqrnduniformi(&rs, nx);
         ae_vector_set_length(&bl, nc);
         ae_vector_set_length(&bu, nc);
         ae_vector_set_length(&c0, nc);
         ae_vector_set_length(&x, nx);
         for (i = 0; i < nc; i++) {
            bl.xR[i] = hqrndnormal(&rs);
            bu.xR[i] = bl.xR[i] + hqrnduniformr(&rs);
            c0.xR[i] = 1.0 + hqrnduniformr(&rs);
         }
         ae_matrix_set_length(&xx, m, nx);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < nx; j++) {
               xx.xyR[i][j] = hqrndnormal(&rs);
            }
            y.xR[i] = hqrndnormal(&rs);
         }
         if (tmpkind == 0) {
            lsfitcreatef(&xx, &y, &c0, m, nx, nc, 10 * epsx, &state);
         }
         if (tmpkind == 1) {
            lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
         }
         lsfitsetcond(&state, epsx, 0);
         lsfitsetbc(&state, &bl, &bu);
         while (lsfititeration(&state)) {
            for (i = 0; i < nc; i++) {
               Ok = Ok && state.c.xR[i] >= bl.xR[i];
               Ok = Ok && state.c.xR[i] <= bu.xR[i];
            }
            if (state.needf) {
               testlsfitunit_testfunc2(&state.x, nx, &state.c, nc, &state.f, true, &state.g, false);
            } else if (state.needfg) {
               testlsfitunit_testfunc2(&state.x, nx, &state.c, nc, &state.f, true, &state.g, true);
            } else ae_assert(false, "minlm test: integrity check failed");
         }
         lsfitresults(&state, &terminationtype, &c1, &rep);
         Ok = Ok && terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         f0 = 0.0;
         for (ii = 0; ii < m; ii++) {
            ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
            testlsfitunit_testfunc2(&x, nx, &c1, nc, &v, true, &state.g, false);
            f0 += sqr(v - y.xR[ii]);
         }
         h = 0.001;
         ae_vector_set_length(&c2, nc);
         for (i = 0; i < nc; i++) {
            Ok = Ok && c1.xR[i] >= bl.xR[i];
            Ok = Ok && c1.xR[i] <= bu.xR[i];
            if (c1.xR[i] + h >= bl.xR[i] && c1.xR[i] + h <= bu.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] += h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc2(&x, nx, &c2, nc, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               Ok = Ok && f1 >= f0;
            }
            if (c1.xR[i] - h >= bl.xR[i] && c1.xR[i] - h <= bu.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] -= h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc2(&x, nx, &c2, nc, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               Ok = Ok && f1 >= f0;
            }
         }
      }
   }
// Fit
//
//    f(X|C) = c_0 + c_1*x0 + c_2*x0^2 + ...
//
// subject to random box constraints on c.
   epsx = 1.0E-9;
   for (tmpkind = 0; tmpkind <= 1; tmpkind++) {
      for (nc = 1; nc <= 5; nc++) {
         nx = 1;
         m = 10 + nc + hqrnduniformi(&rs, nc);
         ae_vector_set_length(&bl, nc);
         ae_vector_set_length(&bu, nc);
         ae_vector_set_length(&c0, nc);
         ae_vector_set_length(&x, nx);
         for (i = 0; i < nc; i++) {
            bl.xR[i] = hqrndnormal(&rs);
            bu.xR[i] = bl.xR[i] + hqrnduniformr(&rs);
            c0.xR[i] = hqrndnormal(&rs);
         }
         ae_matrix_set_length(&xx, m, nx);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < nx; j++) {
               xx.xyR[i][j] = hqrndnormal(&rs);
            }
            y.xR[i] = hqrndnormal(&rs);
         }
         if (tmpkind == 0) {
            lsfitcreatef(&xx, &y, &c0, m, nx, nc, 10 * epsx, &state);
         }
         if (tmpkind == 1) {
            lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
         }
         lsfitsetcond(&state, epsx, 0);
         lsfitsetbc(&state, &bl, &bu);
         while (lsfititeration(&state)) {
            for (i = 0; i < nc; i++) {
               Ok = Ok && state.c.xR[i] >= bl.xR[i];
               Ok = Ok && state.c.xR[i] <= bu.xR[i];
            }
            if (state.needf) {
               testlsfitunit_testfunc3(&state.x, nx, &state.c, nc, &state.f, true, &state.g, false);
            } else if (state.needfg) {
               testlsfitunit_testfunc3(&state.x, nx, &state.c, nc, &state.f, true, &state.g, true);
            } else ae_assert(false, "minlm test: integrity check failed");
         }
         lsfitresults(&state, &terminationtype, &c1, &rep);
         Ok = Ok && terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         f0 = 0.0;
         for (ii = 0; ii < m; ii++) {
            ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
            testlsfitunit_testfunc3(&x, nx, &c1, nc, &v, true, &state.g, false);
            f0 += sqr(v - y.xR[ii]);
         }
         h = 0.001;
         ae_vector_set_length(&c2, nc);
         for (i = 0; i < nc; i++) {
            Ok = Ok && c1.xR[i] >= bl.xR[i];
            Ok = Ok && c1.xR[i] <= bu.xR[i];
            if (c1.xR[i] + h >= bl.xR[i] && c1.xR[i] + h <= bu.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] += h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc3(&x, nx, &c2, nc, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               Ok = Ok && f1 >= f0;
            }
            if (c1.xR[i] - h >= bl.xR[i] && c1.xR[i] - h <= bu.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] -= h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc3(&x, nx, &c2, nc, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               Ok = Ok && f1 >= f0;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test for linearly constrained NLS problems.
static bool testlsfitunit_testlcnls() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t nc;
   ae_int_t m;
   ae_int_t rawccnt;
   ae_int_t trialidx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ii;
   double v;
   double h;
   ae_int_t optkind;
   double epsx;
   double xtol;
   double f0;
   double f1;
   bool bflag;
   ae_int_t terminationtype;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(lsfitstate, state);
   NewObj(lsfitreport, rep);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(c0, 0, DT_REAL);
   NewVector(c1, 0, DT_REAL);
   NewVector(c2, 0, DT_REAL);
   NewMatrix(rawc, 0, 0, DT_REAL);
   NewVector(rawct, 0, DT_INT);
   NewMatrix(xx, 0, 0, DT_REAL);
   NewMatrix(xx12, 0, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Minimize
//
//          [      [                             ]2  ]
//     SUM_i[ SUM_j[ (0.1*x_j+power(x_j,3))*c_ij ]   ]
//          [      [                             ]   ]
//
// subject to mix of box and linear inequality constraints on x_j
//
// We check correctness of solution by sampling a few random points
// around one returned by optimizer, and comparing function value
// with target. Sampling is performed with respect to inequality
// constraints.
   epsx = 1.0E-12;
   xtol = 1.0E-8;
   optkind = 1;
   for (nc = 5; nc <= 20; nc++) {
   // Generate problem
      nx = nc;
      m = nc + hqrnduniformi(&rs, nc);
      ae_vector_set_length(&bl, nc);
      ae_vector_set_length(&bu, nc);
      ae_vector_set_length(&c0, nc);
      ae_vector_set_length(&x, nx);
      for (i = 0; i < nc; i++) {
         bl.xR[i] = hqrndnormal(&rs);
         bu.xR[i] = bl.xR[i] + 0.01 + hqrnduniformr(&rs);
         c0.xR[i] = bl.xR[i] + (bu.xR[i] - bl.xR[i]) * hqrnduniformr(&rs);
      }
      ae_matrix_set_length(&xx, m, nx);
      ae_vector_set_length(&y, m);
      for (i = 0; i < m; i++) {
         for (j = 0; j < nx; j++) {
            xx.xyR[i][j] = hqrndnormal(&rs);
         }
         y.xR[i] = hqrndnormal(&rs);
      }
      ae_assert(nc >= 5, "Assertion failed");
      rawccnt = 3;
      ae_matrix_set_length(&rawc, rawccnt, nc + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         v = 0.0;
         for (j = 0; j < nc; j++) {
            rawc.xyR[i][j] = hqrndnormal(&rs);
            v += c0.xR[j] * rawc.xyR[i][j];
         }
         rawc.xyR[i][nc] = v;
         rawct.xZ[i] = 2 * hqrnduniformi(&rs, 2) - 1;
      }
   // Solve
      if (optkind == 0) {
         lsfitcreatef(&xx, &y, &c0, m, nx, nc, 1.0E-6, &state);
      }
      if (optkind == 1) {
         lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
      }
      lsfitsetcond(&state, epsx, 0);
      lsfitsetbc(&state, &bl, &bu);
      lsfitsetlc(&state, &rawc, &rawct, rawccnt);
      while (lsfititeration(&state)) {
         for (i = 0; i < nc; i++) {
            Ok = Ok && state.c.xR[i] >= bl.xR[i];
            Ok = Ok && state.c.xR[i] <= bu.xR[i];
         }
         if (state.needf) {
            testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, false);
         } else if (state.needfg) {
            testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, true);
         } else ae_assert(false, "lsfit test: integrity check failed");
      }
      lsfitresults(&state, &terminationtype, &c1, &rep);
      Ok = Ok && terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Test feasibility w.r.t. box and linear inequality constraints
      for (i = 0; i < nc; i++) {
         Ok = Ok && c1.xR[i] >= bl.xR[i];
         Ok = Ok && c1.xR[i] <= bu.xR[i];
      }
      for (i = 0; i < rawccnt; i++) {
         v = ae_v_dotproduct(rawc.xyR[i], 1, c1.xR, 1, nc);
         v -= rawc.xyR[i][nc];
         if (rawct.xZ[i] > 0) {
            Ok = Ok && v >= -xtol;
         }
         if (rawct.xZ[i] < 0) {
            Ok = Ok && v <= xtol;
         }
      }
   // Make several random trial steps and:
   // 0) generate small random trial step
   // 1) if step is infeasible, skip to next trial
   // 2) compare function value in the trial point against one in other points
      f0 = 0.0;
      for (ii = 0; ii < m; ii++) {
         ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
         testlsfitunit_testfunc1(nx, &x, &c1, &v, true, &state.g, false);
         f0 += sqr(v - y.xR[ii]);
      }
      ae_vector_set_length(&c2, nc);
      for (trialidx = 0; trialidx <= 10 * nc; trialidx++) {
         h = 0.001;
         for (i = 0; i < nc; i++) {
            do {
               c2.xR[i] = c1.xR[i] + hqrndmiduniformr(&rs) * h;
            } while (c2.xR[i] < bl.xR[i] || c2.xR[i] > bu.xR[i]);
         }
         bflag = false;
         for (i = 0; i < rawccnt; i++) {
            ae_assert(rawct.xZ[i] != 0, "Assertion failed");
            v = ae_v_dotproduct(rawc.xyR[i], 1, c2.xR, 1, nc);
            v -= rawc.xyR[i][nc];
            bflag = bflag || rawct.xZ[i] > 0 && v < 0.0;
            bflag = bflag || rawct.xZ[i] < 0 && v > 0.0;
         }
         if (bflag) {
            continue;
         }
         f1 = 0.0;
         for (ii = 0; ii < m; ii++) {
            ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
            testlsfitunit_testfunc1(nx, &x, &c2, &v, true, &state.g, false);
            f1 += sqr(v - y.xR[ii]);
         }
         Ok = Ok && f1 >= f0;
      }
   }
// Minimize
//
//          [      [                             ]2  ]
//     SUM_i[ SUM_j[ (0.1*x_j+power(x_j,3))*c_ij ]   ]
//          [      [                             ]   ]
//
// subject to linear EQUALITY constraints on x_j.
//
// We check correctness of solution by sampling a few random points
// around one returned by optimizer, and comparing function value
// with target. Sampling is performed with respect to equality
// constraints. In order to simplify algorithm we use orthogonal
// equality constraints.
//
// NOTE: we solve problem using VJ mode (analytic Jacobian) because
//       roundoff errors from numerical differentiation sometimes
//       prevent us from converging with good precision.
   epsx = 1.0E-12;
   xtol = 1.0E-8;
   optkind = 1;
   for (nc = 10; nc <= 20; nc++) {
   // Generate problem
      nx = nc;
      m = nc + hqrnduniformi(&rs, nc);
      ae_vector_set_length(&c0, nc);
      for (i = 0; i < nc; i++) {
         c0.xR[i] = hqrndnormal(&rs);
      }
      ae_matrix_set_length(&xx, m, nx);
      ae_vector_set_length(&y, m);
      for (i = 0; i < m; i++) {
         for (j = 0; j < nx; j++) {
            xx.xyR[i][j] = hqrndnormal(&rs);
         }
         y.xR[i] = hqrndnormal(&rs);
      }
      ae_assert(nc >= 10, "Assertion failed");
      rawccnt = 1 + hqrnduniformi(&rs, 5);
      rmatrixrndorthogonal(nc, &z);
      ae_matrix_set_length(&rawc, rawccnt, nc + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         v = 0.0;
         for (j = 0; j < nc; j++) {
            rawc.xyR[i][j] = z.xyR[i][j];
            v += c0.xR[j] * rawc.xyR[i][j];
         }
         rawc.xyR[i][nc] = v;
         rawct.xZ[i] = 0;
      }
   // Solve
      if (optkind == 0) {
         lsfitcreatef(&xx, &y, &c0, m, nx, nc, 1.0E-6, &state);
      }
      if (optkind == 1) {
         lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
      }
      lsfitsetcond(&state, epsx, 0);
      lsfitsetlc(&state, &rawc, &rawct, rawccnt);
      while (lsfititeration(&state))
         if (state.needf) {
            testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, false);
         } else if (state.needfg) {
            testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, true);
         } else ae_assert(false, "lsfit test: integrity check failed");
      lsfitresults(&state, &terminationtype, &c1, &rep);
      Ok = Ok && terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Test feasibility w.r.t. linear equality constraints
      for (i = 0; i < rawccnt; i++) {
         v = ae_v_dotproduct(rawc.xyR[i], 1, c1.xR, 1, nc);
         v -= rawc.xyR[i][nc];
         Ok = Ok && SmallAtR(v, xtol);
      }
   // Make several random trial steps and:
   // 0) generate small random trial step
   // 1) project it onto equality constrained subspace
   // 2) compare function value in the trial point against one in other points
      f0 = 0.0;
      for (ii = 0; ii < m; ii++) {
         ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
         testlsfitunit_testfunc1(nx, &x, &c1, &v, true, &state.g, false);
         f0 += sqr(v - y.xR[ii]);
      }
      ae_vector_set_length(&c2, nc);
      for (trialidx = 0; trialidx <= nc; trialidx++) {
         h = 0.001;
         for (i = 0; i < nc; i++) {
            c2.xR[i] = hqrndnormal(&rs);
         }
         for (i = 0; i < rawccnt; i++) {
            v = ae_v_dotproduct(rawc.xyR[i], 1, c2.xR, 1, nc);
            ae_v_subd(c2.xR, 1, rawc.xyR[i], 1, nc, v);
         }
         v = ae_v_dotproduct(c2.xR, 1, c2.xR, 1, nc);
         ae_assert(v > 0.0, "Assertion failed");
         v = h / sqrt(v);
         ae_v_muld(c2.xR, 1, nc, v);
         ae_v_add(c2.xR, 1, c1.xR, 1, nc);
         f1 = 0.0;
         for (ii = 0; ii < m; ii++) {
            ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
            testlsfitunit_testfunc1(nx, &x, &c2, &v, true, &state.g, false);
            f1 += sqr(v - y.xR[ii]);
         }
         Ok = Ok && f1 >= f0;
      }
   }
// Fit
//
//    f(X|C) = c_0
//
// subject to single general linear equality constraint on c_0.
//
// Here X has dimensionality NX, and C has dimensionality 1.
//
// We do not test convergence to solution, only feasibility of constraint.
// The aim of this test is to assert that optimizer correctly handles
// situations when dimensions of X and C differ.
   epsx = 1.0E-9;
   for (optkind = 0; optkind <= 1; optkind++) {
      for (nx = 1; nx <= 20; nx++) {
         nc = 1;
         m = nx + hqrnduniformi(&rs, nx);
         ae_vector_set_length(&c0, nc);
         for (i = 0; i < nc; i++) {
            c0.xR[i] = hqrndnormal(&rs);
         }
         ae_matrix_set_length(&xx, m, nx);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < nx; j++) {
               xx.xyR[i][j] = hqrndnormal(&rs);
            }
            y.xR[i] = hqrndnormal(&rs);
         }
         ae_assert(nc == 1, "Assertion failed");
         rawccnt = 1;
         ae_matrix_set_length(&rawc, 1, 2);
         ae_vector_set_length(&rawct, 1);
         rawc.xyR[0][0] = 1.0;
         rawc.xyR[0][1] = hqrndnormal(&rs);
         rawct.xZ[0] = 0;
         if (optkind == 0) {
            lsfitcreatef(&xx, &y, &c0, m, nx, nc, 10 * epsx, &state);
         }
         if (optkind == 1) {
            lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
         }
         lsfitsetcond(&state, epsx, 0);
         lsfitsetlc(&state, &rawc, &rawct, rawccnt);
         while (lsfititeration(&state))
            if (state.needf) {
               testlsfitunit_testfunc2(&state.x, nx, &state.c, nc, &state.f, true, &state.g, false);
            } else if (state.needfg) {
               testlsfitunit_testfunc2(&state.x, nx, &state.c, nc, &state.f, true, &state.g, true);
            } else ae_assert(false, "minlm test: integrity check failed");
         lsfitresults(&state, &terminationtype, &c1, &rep);
         Ok = Ok && terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         Ok = Ok && NearAtR(c1.xR[0], rawc.xyR[0][1], 1.0E-6);
      }
   }
// Fit
//
//    f(X|C) = c_0 + c_1*x0 + c_2*x0^2 + ...
//
// subject to single general linear equality constraint on c.
//
// Here X has dimensionality 1, and C has dimensionality NC.
//
// We do not test convergence to solution, only feasibility of constraint.
// The aim of this test is to assert that optimizer correctly handles
// situations when dimensions of X and C differ.
   epsx = 1.0E-9;
   for (optkind = 0; optkind <= 1; optkind++) {
      for (nc = 1; nc <= 5; nc++) {
         nx = 1;
         m = 10 + nc + hqrnduniformi(&rs, nc);
         ae_vector_set_length(&c0, nc);
         for (i = 0; i < nc; i++) {
            c0.xR[i] = hqrndnormal(&rs);
         }
         ae_matrix_set_length(&xx, m, nx);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < nx; j++) {
               xx.xyR[i][j] = hqrndnormal(&rs);
            }
            y.xR[i] = hqrndnormal(&rs);
         }
         rawccnt = 1;
         ae_matrix_set_length(&rawc, 1, nc + 1);
         ae_vector_set_length(&rawct, 1);
         for (j = 0; j <= nc; j++) {
            rawc.xyR[0][j] = (2 * hqrnduniformi(&rs, 2) - 1) * (0.1 + hqrnduniformr(&rs));
         }
         rawct.xZ[0] = 0;
         if (optkind == 0) {
            lsfitcreatef(&xx, &y, &c0, m, nx, nc, 10 * epsx, &state);
         }
         if (optkind == 1) {
            lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
         }
         lsfitsetcond(&state, epsx, 0);
         lsfitsetlc(&state, &rawc, &rawct, rawccnt);
         while (lsfititeration(&state))
            if (state.needf) {
               testlsfitunit_testfunc3(&state.x, nx, &state.c, nc, &state.f, true, &state.g, false);
            } else if (state.needfg) {
               testlsfitunit_testfunc3(&state.x, nx, &state.c, nc, &state.f, true, &state.g, true);
            } else ae_assert(false, "minlm test: integrity check failed");
         lsfitresults(&state, &terminationtype, &c1, &rep);
         Ok = Ok && terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         v = -rawc.xyR[0][nc];
         for (j = 0; j < nc; j++) {
            v += rawc.xyR[0][j] * c1.xR[j];
         }
         Ok = Ok && SmallAtR(v, 1.0E-6);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Tests whether C is solution of LLS problem
static double testlsfitunit_getglserror(ae_int_t n, ae_int_t m, RVector *y, RVector *w, RMatrix *fmatrix, RVector *c) {
   ae_int_t i;
   double v;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      v = ae_v_dotproduct(fmatrix->xyR[i], 1, c->xR, 1, m);
      result += sqr(w->xR[i] * (v - y->xR[i]));
   }
   return result;
}

// Tests whether C is solution of (possibly) constrained LLS problem
static bool testlsfitunit_isglssolution(ae_int_t n, ae_int_t m, ae_int_t k, RVector *y, RVector *w, RMatrix *fmatrix, RMatrix *cmatrix, RVector *c) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   double s1;
   double s2;
   double s3;
   double delta;
   double threshold;
   bool Ok;
   ae_frame_make(&_frame_block);
   DupVector(c);
   NewVector(c2, 0, DT_REAL);
   NewVector(sv, 0, DT_REAL);
   NewVector(deltac, 0, DT_REAL);
   NewVector(deltaproj, 0, DT_REAL);
   NewMatrix(u, 0, 0, DT_REAL);
   NewMatrix(vt, 0, 0, DT_REAL);
// Setup.
// Threshold is small because CMatrix may be ill-conditioned
   delta = 0.001;
   threshold = sqrt(machineepsilon);
   ae_vector_set_length(&c2, m);
   ae_vector_set_length(&deltac, m);
   ae_vector_set_length(&deltaproj, m);
// test whether C is feasible point or not (projC must be close to C)
   for (i = 0; i < k; i++) {
      v = ae_v_dotproduct(cmatrix->xyR[i], 1, c->xR, 1, m);
      if (!NearAtR(v, cmatrix->xyR[i][m], threshold)) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
// find orthogonal basis of Null(CMatrix) (stored in rows from K to M-1)
   if (k > 0) {
      rmatrixsvd(cmatrix, k, m, 0, 2, 2, &sv, &u, &vt);
   }
// Test result
   Ok = true;
   s1 = testlsfitunit_getglserror(n, m, y, w, fmatrix, c);
   for (j = 0; j < m; j++) {
   // prepare modification of C which leave us in the feasible set.
   //
   // let deltaC be increment on Jth coordinate, then project
   // deltaC in the Null(CMatrix) and store result in DeltaProj
      ae_v_move(c2.xR, 1, c->xR, 1, m);
      for (i = 0; i < m; i++) {
         if (i == j) {
            deltac.xR[i] = delta;
         } else {
            deltac.xR[i] = 0.0;
         }
      }
      if (k == 0) {
         ae_v_move(deltaproj.xR, 1, deltac.xR, 1, m);
      } else {
         for (i = 0; i < m; i++) {
            deltaproj.xR[i] = 0.0;
         }
         for (i = k; i < m; i++) {
            v = ae_v_dotproduct(vt.xyR[i], 1, deltac.xR, 1, m);
            ae_v_addd(deltaproj.xR, 1, vt.xyR[i], 1, m, v);
         }
      }
   // now we have DeltaProj such that if C is feasible,
   // then C+DeltaProj is feasible too
      ae_v_move(c2.xR, 1, c->xR, 1, m);
      ae_v_add(c2.xR, 1, deltaproj.xR, 1, m);
      s2 = testlsfitunit_getglserror(n, m, y, w, fmatrix, &c2);
      ae_v_move(c2.xR, 1, c->xR, 1, m);
      ae_v_sub(c2.xR, 1, deltaproj.xR, 1, m);
      s3 = testlsfitunit_getglserror(n, m, y, w, fmatrix, &c2);
      Ok = Ok && s2 >= s1 / (1 + threshold) && s3 >= s1 / (1 + threshold);
   }
   ae_frame_leave();
   return Ok;
}

// Subroutine for nonlinear fitting of linear problem
//
// DerAvailable:
// * 0     when only function value should be used
// * 1     when we can provide gradient/function
// * 2     when we can provide Hessian/gradient/function
//
// Failure occurs when something which is not permitted by DerAvailable is requested.
static bool testlsfitunit_fitlinearnonlinear(ae_int_t m, ae_int_t deravailable, RMatrix *xy, lsfitstate *state) {
   ae_int_t i;
   ae_int_t j;
   double v;
   bool Ok = true;
   while (lsfititeration(state)) {
   // assume that one and only one of flags is set
   // test that we didn't request hessian in hessian-free setting
      if (deravailable < 1 && state->needfg) {
         Ok = false;
      } else if (deravailable < 2 && state->needfgh) {
         Ok = false;
      } else if (state->needf + state->needfg + state->needfgh != 1) {
         Ok = false;
      }
   // test that PointIndex is consistent with actual point passed
      for (i = 0; i < m; i++) {
         Ok = Ok && xy->xyR[state->pointindex][i] == state->x.xR[i];
      }
   // calculate
      if (state->needf) {
         v = ae_v_dotproduct(state->x.xR, 1, state->c.xR, 1, m);
         state->f = v;
      } else if (state->needfg) {
         v = ae_v_dotproduct(state->x.xR, 1, state->c.xR, 1, m);
         state->f = v;
         ae_v_move(state->g.xR, 1, state->x.xR, 1, m);
      } else if (state->needfgh) {
         v = ae_v_dotproduct(state->x.xR, 1, state->c.xR, 1, m);
         state->f = v;
         ae_v_move(state->g.xR, 1, state->x.xR, 1, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < m; j++) {
               state->h.xyR[i][j] = 0.0;
            }
         }
      }
   }
   return Ok;
}

static void testlsfitunit_testgeneralfitting(bool *LlsOkP, bool *NlsOkP) {
   ae_frame _frame_block;
   double threshold;
   double nlthreshold;
   ae_int_t maxn;
   ae_int_t maxm;
   ae_int_t skind;
   ae_int_t pkind;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t pass;
   double xscale;
   double cscale;
   double wscale;
   double noiselevel;
   double tol;
   double diffstep;
   double v;
   double v1;
   double v2;
   ae_int_t info;
   ae_int_t info2;
   double refrms;
   double refavg;
   double refavgrel;
   double refmax;
   double avgdeviationpar;
   double avgdeviationcurve;
   double avgdeviationnoise;
   double adccnt;
   double adpcnt;
   double adncnt;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(c, 0, DT_REAL);
   NewVector(cstart, 0, DT_REAL);
   NewVector(cend, 0, DT_REAL);
   NewVector(c2, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewMatrix(cm, 0, 0, DT_REAL);
   NewObj(lsfitreport, rep);
   NewObj(lsfitreport, rep2);
   NewObj(lsfitstate, state);
   *LlsOkP = true;
   *NlsOkP = true;
   threshold = 10000.0 * machineepsilon;
   nlthreshold = 0.00001;
   diffstep = 0.0001;
   maxn = 6;
   maxm = 6;
   passcount = 4;
// Test constrained NLS problems
   *NlsOkP = *NlsOkP && testlsfitunit_testbcnls();
   *NlsOkP = *NlsOkP && testlsfitunit_testlcnls();
// Testing unconstrained least squares (linear/nonlinear)
   for (n = 1; n <= maxn; n++) {
      for (m = 1; m <= maxm; m++) {
         for (pass = 1; pass <= passcount; pass++) {
         // Solve non-degenerate linear least squares task
         // Use Chebyshev basis. Its condition number is very good.
            ae_matrix_set_length(&a, n, m);
            ae_vector_set_length(&x, n);
            ae_vector_set_length(&y, n);
            ae_vector_set_length(&w, n);
            xscale = 0.9 + 0.1 * randomreal();
            for (i = 0; i < n; i++) {
               if (n == 1) {
                  x.xR[i] = randommid();
               } else {
                  x.xR[i] = xscale * ((double)(2 * i) / (n - 1) - 1);
               }
               y.xR[i] = 3 * x.xR[i] + exp(x.xR[i]);
               w.xR[i] = 1 + randomreal();
               a.xyR[i][0] = 1.0;
               if (m > 1) {
                  a.xyR[i][1] = x.xR[i];
               }
               for (j = 2; j < m; j++) {
                  a.xyR[i][j] = 2 * x.xR[i] * a.xyR[i][j - 1] - a.xyR[i][j - 2];
               }
            }
         // 1. test weighted fitting (optimality)
         // 2. Solve degenerate least squares task built on the basis
         //    of previous task
            lsfitlinearw(&y, &w, &a, n, m, &info, &c, &rep);
            if (info <= 0) {
               *LlsOkP = false;
            } else {
               *LlsOkP = *LlsOkP && testlsfitunit_isglssolution(n, m, 0, &y, &w, &a, &cm, &c);
            }
            ae_matrix_set_length(&a2, n, 2 * m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  a2.xyR[i][2 * j] = a.xyR[i][j];
                  a2.xyR[i][2 * j + 1] = a.xyR[i][j];
               }
            }
            lsfitlinearw(&y, &w, &a2, n, 2 * m, &info, &c2, &rep);
            if (info <= 0) {
               *LlsOkP = false;
            } else {
            // test answer correctness using design matrix properties
            // and previous task solution
               for (j = 0; j < m; j++) {
                  *LlsOkP = *LlsOkP && NearAtR(c2.xR[2 * j] + c2.xR[2 * j + 1], c.xR[j], threshold);
               }
            }
         // test non-weighted fitting
            ae_vector_set_length(&w2, n);
            for (i = 0; i < n; i++) {
               w2.xR[i] = 1.0;
            }
            lsfitlinearw(&y, &w2, &a, n, m, &info, &c, &rep);
            lsfitlinear(&y, &a, n, m, &info2, &c2, &rep2);
            if (info <= 0 || info2 <= 0) {
               *LlsOkP = false;
            } else {
            // test answer correctness
               for (j = 0; j < m; j++) {
                  *LlsOkP = *LlsOkP && NearAtR(c.xR[j], c2.xR[j], threshold);
               }
               *LlsOkP = *LlsOkP && NearAtR(rep.taskrcond, rep2.taskrcond, threshold);
            }
         // test nonlinear fitting on the linear task
         // (only non-degenerate tasks are tested)
         // and compare with answer from linear fitting subroutine
            if (n >= m) {
               ae_vector_set_length(&c2, m);
            // test function/gradient/Hessian-based weighted fitting
               lsfitlinearw(&y, &w, &a, n, m, &info, &c, &rep);
               for (i = 0; i < m; i++) {
                  c2.xR[i] = randommid();
               }
               lsfitcreatewf(&a, &y, &w, &c2, n, m, m, diffstep, &state);
               lsfitsetcond(&state, nlthreshold, 0);
               *NlsOkP = *NlsOkP && testlsfitunit_fitlinearnonlinear(m, 0, &a, &state);
               lsfitresults(&state, &info, &c2, &rep2);
               if (info <= 0) {
                  *NlsOkP = false;
               } else {
                  for (i = 0; i < m; i++) {
                     *NlsOkP = *NlsOkP && NearAtR(c.xR[i], c2.xR[i], 100 * nlthreshold);
                  }
               }
               for (i = 0; i < m; i++) {
                  c2.xR[i] = randommid();
               }
               lsfitcreatewfg(&a, &y, &w, &c2, n, m, m, randombool(), &state);
               lsfitsetcond(&state, nlthreshold, 0);
               *NlsOkP = *NlsOkP && testlsfitunit_fitlinearnonlinear(m, 1, &a, &state);
               lsfitresults(&state, &info, &c2, &rep2);
               if (info <= 0) {
                  *NlsOkP = false;
               } else {
                  for (i = 0; i < m; i++) {
                     *NlsOkP = *NlsOkP && NearAtR(c.xR[i], c2.xR[i], 100 * nlthreshold);
                  }
               }
               for (i = 0; i < m; i++) {
                  c2.xR[i] = randommid();
               }
               lsfitcreatewfgh(&a, &y, &w, &c2, n, m, m, &state);
               lsfitsetcond(&state, nlthreshold, 0);
               *NlsOkP = *NlsOkP && testlsfitunit_fitlinearnonlinear(m, 2, &a, &state);
               lsfitresults(&state, &info, &c2, &rep2);
               if (info <= 0) {
                  *NlsOkP = false;
               } else {
                  for (i = 0; i < m; i++) {
                     *NlsOkP = *NlsOkP && NearAtR(c.xR[i], c2.xR[i], 100 * nlthreshold);
                  }
               }
            // test gradient-only or Hessian-based fitting without weights
               lsfitlinear(&y, &a, n, m, &info, &c, &rep);
               for (i = 0; i < m; i++) {
                  c2.xR[i] = randommid();
               }
               lsfitcreatef(&a, &y, &c2, n, m, m, diffstep, &state);
               lsfitsetcond(&state, nlthreshold, 0);
               *NlsOkP = *NlsOkP && testlsfitunit_fitlinearnonlinear(m, 0, &a, &state);
               lsfitresults(&state, &info, &c2, &rep2);
               if (info <= 0) {
                  *NlsOkP = false;
               } else {
                  for (i = 0; i < m; i++) {
                     *NlsOkP = *NlsOkP && NearAtR(c.xR[i], c2.xR[i], 100 * nlthreshold);
                  }
               }
               for (i = 0; i < m; i++) {
                  c2.xR[i] = randommid();
               }
               lsfitcreatefg(&a, &y, &c2, n, m, m, randombool(), &state);
               lsfitsetcond(&state, nlthreshold, 0);
               *NlsOkP = *NlsOkP && testlsfitunit_fitlinearnonlinear(m, 1, &a, &state);
               lsfitresults(&state, &info, &c2, &rep2);
               if (info <= 0) {
                  *NlsOkP = false;
               } else {
                  for (i = 0; i < m; i++) {
                     *NlsOkP = *NlsOkP && NearAtR(c.xR[i], c2.xR[i], 100 * nlthreshold);
                  }
               }
               for (i = 0; i < m; i++) {
                  c2.xR[i] = randommid();
               }
               lsfitcreatefgh(&a, &y, &c2, n, m, m, &state);
               lsfitsetcond(&state, nlthreshold, 0);
               *NlsOkP = *NlsOkP && testlsfitunit_fitlinearnonlinear(m, 2, &a, &state);
               lsfitresults(&state, &info, &c2, &rep2);
               if (info <= 0) {
                  *NlsOkP = false;
               } else {
                  for (i = 0; i < m; i++) {
                     *NlsOkP = *NlsOkP && NearAtR(c.xR[i], c2.xR[i], 100 * nlthreshold);
                  }
               }
            }
         }
      }
   // test correctness of the RCond field
      ae_matrix_set_length(&a, n, n);
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      ae_vector_set_length(&w, n);
      v1 = maxrealnumber;
      v2 = minrealnumber;
      for (i = 0; i < n; i++) {
         x.xR[i] = 0.1 + 0.9 * randomreal();
         y.xR[i] = 0.1 + 0.9 * randomreal();
         w.xR[i] = 1.0;
         for (j = 0; j < n; j++) {
            if (i == j) {
               a.xyR[i][i] = 0.1 + 0.9 * randomreal();
               v1 = rmin2(v1, a.xyR[i][i]);
               v2 = rmax2(v2, a.xyR[i][i]);
            } else {
               a.xyR[i][j] = 0.0;
            }
         }
      }
      lsfitlinearw(&y, &w, &a, n, n, &info, &c, &rep);
      if (info <= 0) {
         *LlsOkP = false;
      } else {
         *LlsOkP = *LlsOkP && NearAtR(rep.taskrcond, v1 / v2, threshold);
      }
   }
// Test constrained least squares
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (m = 1; m <= maxm; m++) {
         // test for K != 0
            for (k = 1; k < m; k++) {
            // Prepare Chebyshev basis. Its condition number is very good.
            // Prepare constraints (random numbers)
               ae_matrix_set_length(&a, n, m);
               ae_vector_set_length(&x, n);
               ae_vector_set_length(&y, n);
               ae_vector_set_length(&w, n);
               xscale = 0.9 + 0.1 * randomreal();
               for (i = 0; i < n; i++) {
                  if (n == 1) {
                     x.xR[i] = randommid();
                  } else {
                     x.xR[i] = xscale * ((double)(2 * i) / (n - 1) - 1);
                  }
                  y.xR[i] = 3 * x.xR[i] + exp(x.xR[i]);
                  w.xR[i] = 1 + randomreal();
                  a.xyR[i][0] = 1.0;
                  if (m > 1) {
                     a.xyR[i][1] = x.xR[i];
                  }
                  for (j = 2; j < m; j++) {
                     a.xyR[i][j] = 2 * x.xR[i] * a.xyR[i][j - 1] - a.xyR[i][j - 2];
                  }
               }
               ae_matrix_set_length(&cm, k, m + 1);
               for (i = 0; i < k; i++) {
                  for (j = 0; j <= m; j++) {
                     cm.xyR[i][j] = randommid();
                  }
               }
            // Solve constrained task
               lsfitlinearwc(&y, &w, &a, &cm, n, m, k, &info, &c, &rep);
               if (info <= 0) {
                  *LlsOkP = false;
               } else {
                  *LlsOkP = *LlsOkP && testlsfitunit_isglssolution(n, m, k, &y, &w, &a, &cm, &c);
               }
            // test non-weighted fitting
               ae_vector_set_length(&w2, n);
               for (i = 0; i < n; i++) {
                  w2.xR[i] = 1.0;
               }
               lsfitlinearwc(&y, &w2, &a, &cm, n, m, k, &info, &c, &rep);
               lsfitlinearc(&y, &a, &cm, n, m, k, &info2, &c2, &rep2);
               if (info <= 0 || info2 <= 0) {
                  *LlsOkP = false;
               } else {
               // test answer correctness
                  for (j = 0; j < m; j++) {
                     *LlsOkP = *LlsOkP && NearAtR(c.xR[j], c2.xR[j], threshold);
                  }
                  *LlsOkP = *LlsOkP && NearAtR(rep.taskrcond, rep2.taskrcond, threshold);
               }
            }
         }
      }
   }
// nonlinear task for nonlinear fitting:
//
//     f(X,C) = 1/(1+C*X^2),
//     C(true) = 2.
   n = 100;
   ae_vector_set_length(&c, 1);
   c.xR[0] = 1.0 + 2.0 * randomreal();
   ae_matrix_set_length(&a, n, 1);
   ae_vector_set_length(&y, n);
   for (i = 0; i < n; i++) {
      a.xyR[i][0] = 2.0 * randommid();
      y.xR[i] = 1 / (1 + 2 * sqr(a.xyR[i][0]));
   }
   lsfitcreatefg(&a, &y, &c, n, 1, 1, true, &state);
   lsfitsetcond(&state, nlthreshold, 0);
   while (lsfititeration(&state))
      if (state.needf) {
         state.f = 1 / (1 + state.c.xR[0] * sqr(state.x.xR[0]));
      } else if (state.needfg) {
         state.f = 1 / (1 + state.c.xR[0] * sqr(state.x.xR[0]));
         state.g.xR[0] = -sqr(state.x.xR[0]) / sqr(1 + state.c.xR[0] * sqr(state.x.xR[0]));
      }
   lsfitresults(&state, &info, &c, &rep);
   if (info <= 0) {
      *NlsOkP = false;
   } else {
      *NlsOkP = *NlsOkP && NearAtR(c.xR[0], 2, 100 * nlthreshold);
   }
// solve simple task (fitting by constant function) and check
// correctness of the errors calculated by subroutines
   for (pass = 1; pass <= passcount; pass++) {
   // test on task with non-zero Yi
      n = 4;
      v1 = randomreal();
      v2 = randomreal();
      v = 1 + randomreal();
      ae_vector_set_length(&c, 1);
      c.xR[0] = 1.0 + 2.0 * randomreal();
      ae_matrix_set_length(&a, 4, 1);
      ae_vector_set_length(&y, 4);
      a.xyR[0][0] = 1.0;
      y.xR[0] = v - v2;
      a.xyR[1][0] = 1.0;
      y.xR[1] = v - v1;
      a.xyR[2][0] = 1.0;
      y.xR[2] = v + v1;
      a.xyR[3][0] = 1.0;
      y.xR[3] = v + v2;
      refrms = sqrt((sqr(v1) + sqr(v2)) / 2);
      refavg = (fabs(v1) + fabs(v2)) / 2;
      refavgrel = 0.25 * (fabs(v2) / fabs(v - v2) + fabs(v1) / fabs(v - v1) + fabs(v1) / fabs(v + v1) + fabs(v2) / fabs(v + v2));
      refmax = rmax2(v1, v2);
   // Test LLS
      lsfitlinear(&y, &a, 4, 1, &info, &c, &rep);
      if (info <= 0) {
         *LlsOkP = false;
      } else {
         *LlsOkP = *LlsOkP && NearAtR(c.xR[0], v, threshold);
         *LlsOkP = *LlsOkP && NearAtR(rep.rmserror, refrms, threshold);
         *LlsOkP = *LlsOkP && NearAtR(rep.avgerror, refavg, threshold);
         *LlsOkP = *LlsOkP && NearAtR(rep.avgrelerror, refavgrel, threshold);
         *LlsOkP = *LlsOkP && NearAtR(rep.maxerror, refmax, threshold);
      }
   // Test NLS
      lsfitcreatefg(&a, &y, &c, 4, 1, 1, true, &state);
      lsfitsetcond(&state, nlthreshold, 0);
      while (lsfititeration(&state))
         if (state.needf) {
            state.f = state.c.xR[0];
         } else if (state.needfg) {
            state.f = state.c.xR[0];
            state.g.xR[0] = 1.0;
         }
      lsfitresults(&state, &info, &c, &rep);
      if (info <= 0) {
         *NlsOkP = false;
      } else {
         *NlsOkP = *NlsOkP && NearAtR(c.xR[0], v, threshold);
         *NlsOkP = *NlsOkP && NearAtR(rep.rmserror, refrms, threshold);
         *NlsOkP = *NlsOkP && NearAtR(rep.avgerror, refavg, threshold);
         *NlsOkP = *NlsOkP && NearAtR(rep.avgrelerror, refavgrel, threshold);
         *NlsOkP = *NlsOkP && NearAtR(rep.maxerror, refmax, threshold);
      }
   }
// Check covariance matrix, errors-in-parameters.
//
// We test three different solvers:
// * nonlinear solver
// * unconstrained linear solver
// * constrained linear solver with empty set of constrains
// on two random problems:
// * problem with known prior, noise, unit weights
// * problem with known prior, noise, non-unit weights
//
// We test that:
// * rep.ErrPar == sqrt(diag(Rep.CovPar))
// * Rep.ErrPar is not too optimistic  - average value of ratio
//   between  |c_fit-c_prior| and ErrPar[] is less than TOL
// * Rep.ErrPar is not too pessimistic - average value of ratio
//   is larger than 1/TOL
// * similarly, Rep.ErrCurve gives good estimate of |A*c_fit - A*c_prior|
//   - not optimistic, not pessimistic.
// * similarly, per-point noise estimates are good enough (we use
//   slightly different tolerances, though)
// In order to have these estimates we perform many different tests
// and calculate average deviation divided by ErrPar/ErrCurve. Then
// we perform test.
//
// Due to stochastic nature of the test it is not good idea to
// consider each case individually - it is better to average over
// many runs.
//
   tol = 10.0;
   for (n = 1; n <= 10; n++) {
      for (skind = 0; skind <= 2; skind++) {
         for (pkind = 0; pkind <= 1; pkind++) {
         // Generate problem:
         // * PKind == 0 - unit weights
         // * PKind == 1 - non-unit weights, exact estimate of noise at I-th point
         //
         // We generate:
         // * C      -   prior values of parameters
         // * CStart -   random initial point
         // * A      -   function matrix
         // * Y      -   noisy version of A*C
         // * W      -   weights vector
         // * S      -   vector of per-point estimates of noise
            cscale = pow(10.0, 2 * randomnormal());
            xscale = pow(10.0, 2 * randomnormal());
            noiselevel = 0.01 * cscale * xscale;
            ae_vector_set_length(&c, n);
            ae_vector_set_length(&cstart, n);
            for (i = 0; i < n; i++) {
               c.xR[i] = cscale * randomnormal();
               cstart.xR[i] = cscale * randomnormal();
            }
            ae_matrix_set_length(&a, 1000, n);
            ae_vector_set_length(&y, a.rows);
            ae_vector_set_length(&w, a.rows);
            ae_vector_set_length(&s, a.rows);
            for (i = 0; i < a.rows; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = xscale * randomnormal();
               }
               v = ae_v_dotproduct(a.xyR[i], 1, c.xR, 1, n);
               if (pkind == 0) {
                  w.xR[i] = 1.0;
                  s.xR[i] = noiselevel;
                  y.xR[i] = v + s.xR[i] * randomnormal();
               }
               if (pkind == 1) {
                  w.xR[i] = 1 / noiselevel;
                  s.xR[i] = noiselevel;
                  y.xR[i] = v + s.xR[i] * randomnormal();
               }
            }
         // Test different solvers:
         // * SKind == 0 - nonlinear solver
         // * SKind == 1 - linear unconstrained
         // * SKind == 2 - linear constrained with empty set of constraints
            info = -1;
            if (skind == 0) {
               if (randombool()) {
                  lsfitcreatefg(&a, &y, &cstart, a.rows, n, n, true, &state);
               } else {
                  lsfitcreatef(&a, &y, &cstart, a.rows, n, n, 0.001 * cscale, &state);
               }
               lsfitsetcond(&state, 0.0, 10);
               while (lsfititeration(&state))
                  if (state.needf) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += state.c.xR[i] * state.x.xR[i];
                     }
                  } else if (state.needfg) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += state.c.xR[i] * state.x.xR[i];
                        state.g.xR[i] = state.x.xR[i];
                     }
                  }
               lsfitresults(&state, &info, &cend, &rep);
            }
            if (skind == 1) {
               if (pkind == 0) {
                  lsfitlinear(&y, &a, a.rows, n, &info, &cend, &rep);
               } else {
                  lsfitlinearw(&y, &w, &a, a.rows, n, &info, &cend, &rep);
               }
            }
            if (skind == 2) {
               if (pkind == 0) {
                  lsfitlinearc(&y, &a, &a2, a.rows, n, 0, &info, &cend, &rep);
               } else {
                  lsfitlinearwc(&y, &w, &a, &a2, a.rows, n, 0, &info, &cend, &rep);
               }
            }
         // Tests:
         // * check relation between CovPar and ErrPar
         // * accumulate average deviation in parameters
         // * accumulate average deviation in curve fit
         // * accumulate average deviation in noise estimate
            avgdeviationpar = 0.0;
            adpcnt = 0.0;
            avgdeviationcurve = 0.0;
            adccnt = 0.0;
            avgdeviationnoise = 0.0;
            adncnt = 0.0;
            for (i = 0; i < n; i++) {
               *LlsOkP = *LlsOkP && NearAtR(rep.covpar.xyR[i][i], sqr(rep.errpar.xR[i]), 100.0 * machineepsilon * rmax2(sqr(rep.errpar.xR[i]), rep.covpar.xyR[i][i]));
            }
            for (i = 0; i < n; i++) {
               avgdeviationpar = (avgdeviationpar * adpcnt + fabs(c.xR[i] - cend.xR[i]) / rep.errpar.xR[i]) / (adpcnt + 1);
               adpcnt++;
            }
            for (i = 0; i < a.rows; i++) {
               v1 = ae_v_dotproduct(c.xR, 1, a.xyR[i], 1, n);
               v2 = ae_v_dotproduct(cend.xR, 1, a.xyR[i], 1, n);
               avgdeviationcurve = (avgdeviationcurve * adccnt + fabs(v1 - v2) / rep.errcurve.xR[i]) / (adccnt + 1);
               adccnt++;
               avgdeviationnoise = (avgdeviationnoise * adncnt + rep.noise.xR[i] / s.xR[i]) / (adncnt + 1);
               adncnt++;
            }
         // Check that estimates are not too optimistic.
         // This test is performed always.
            *LlsOkP = *LlsOkP && avgdeviationpar <= tol;
            *LlsOkP = *LlsOkP && avgdeviationcurve <= tol;
            *LlsOkP = *LlsOkP && avgdeviationnoise <= 1.50;
            *LlsOkP = *LlsOkP && avgdeviationnoise >= 0.66;
         // Test for estimates being too pessimistic is performed only
         // when we have more than 4 parameters.
            *LlsOkP = *LlsOkP && (n < 5 || avgdeviationcurve >= 0.01 && avgdeviationpar >= 0.01);
         }
      }
   }
// Check special property of the LSFit solver: it does not include points with
// zero weight in the estimate of the noise level. Such property seems to be
// quite natural, but in fact it requires some additional code in order to
// ignore such points.
//
// In order to test it we solve two problems: one 300xN, with 150 non-zero
// weights and 150 zero weights - and another one with only 150 points with
// non-zero weights. Both problems should give us same covariance matrix.
   tol = 10.0;
   for (n = 1; n <= 10; n++) {
   // Generate N-dimensional linear problem with 300 points:
   // * y = c'*x + noise
   // * prior values of coefficients C has scale CScale
   // * coordinates X has scale XScale
   // * noise in I-th point has magnitude 0.1*CScale*XScale*WScale/W[i]
      cscale = pow(10.0, 2 * randomnormal());
      xscale = pow(10.0, 2 * randomnormal());
      wscale = pow(10.0, 2 * randomnormal());
      noiselevel = 0.1 * cscale * xscale;
      ae_vector_set_length(&c, n);
      ae_vector_set_length(&cstart, n);
      for (i = 0; i < n; i++) {
         c.xR[i] = cscale * randomnormal();
         cstart.xR[i] = cscale * randomnormal();
      }
      ae_matrix_set_length(&a, 300, n);
      ae_vector_set_length(&y, a.rows);
      ae_vector_set_length(&w, a.rows);
      for (i = 0; i < a.rows; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = xscale * randomnormal();
         }
         v = ae_v_dotproduct(a.xyR[i], 1, c.xR, 1, n);
         if (i < a.rows / 2) {
            w.xR[i] = pow(10.0, randomnormal()) * wscale;
            y.xR[i] = v + noiselevel / w.xR[i] * randomnormal();
         } else {
            w.xR[i] = 0.0;
            y.xR[i] = v + noiselevel * randomnormal();
         }
      }
   // Solve problem #1 (with zero weights).
   // We randomly choose between analytic gradient and numerical differentiation.
      if (randombool()) {
         lsfitcreatewfg(&a, &y, &w, &cstart, a.rows, n, n, true, &state);
      } else {
         lsfitcreatewf(&a, &y, &w, &cstart, a.rows, n, n, 0.001 * cscale, &state);
      }
      lsfitsetcond(&state, 0.0, 10);
      while (lsfititeration(&state))
         if (state.needf) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += state.c.xR[i] * state.x.xR[i];
            }
         } else if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += state.c.xR[i] * state.x.xR[i];
               state.g.xR[i] = state.x.xR[i];
            }
         }
      lsfitresults(&state, &info, &c2, &rep);
   // Solve problem #2 (only points with non-zero weights).
   // We randomly choose between analytic gradient and numerical differentiation.
      if (randombool()) {
         lsfitcreatewfg(&a, &y, &w, &cstart, a.rows / 2, n, n, true, &state);
      } else {
         lsfitcreatewf(&a, &y, &w, &cstart, a.rows / 2, n, n, 0.001 * cscale, &state);
      }
      lsfitsetcond(&state, 0.0, 10);
      while (lsfititeration(&state))
         if (state.needf) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += state.c.xR[i] * state.x.xR[i];
            }
         } else if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += state.c.xR[i] * state.x.xR[i];
               state.g.xR[i] = state.x.xR[i];
            }
         }
      lsfitresults(&state, &info, &c2, &rep2);
   // Compare covariance matrices, it should be enough to test algorithm
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            *NlsOkP = *NlsOkP && NearAtR(rep.covpar.xyR[i][j], rep2.covpar.xyR[i][j], 1.0E-4 * rmax2(rep.covpar.xyR[i][i], rep.covpar.xyR[j][j]));
         }
      }
   }
// Check correctness of Rep.R2
// Solve several problems with different values of R2.
//
// NOTE: we check only LSFitLinear() because other functions should use same algorithm
//       for calculation of Rep.R2
   n = 4;
   ae_matrix_set_length(&a, 4, 2);
   ae_vector_set_length(&y, 4);
   a.xyR[0][0] = 1.0;
   a.xyR[0][1] = -2.0;
   y.xR[0] = -2.0;
   a.xyR[1][0] = 1.0;
   a.xyR[1][1] = -1.0;
   y.xR[1] = -1.0;
   a.xyR[2][0] = 1.0;
   a.xyR[2][1] = 1.0;
   y.xR[2] = 1.0;
   a.xyR[3][0] = 1.0;
   a.xyR[3][1] = 2.0;
   y.xR[3] = 2.0;
   lsfitlinear(&y, &a, 4, 1, &info, &c, &rep);
   *LlsOkP = *LlsOkP && info > 0 && NearAtR(rep.r2, 0, threshold);
   lsfitlinear(&y, &a, 4, 2, &info, &c, &rep);
   *LlsOkP = *LlsOkP && info > 0 && NearAtR(rep.r2, 1, threshold);
   a.xyR[0][0] = 1.0;
   a.xyR[0][1] = -1.0;
   y.xR[0] = -1.0;
   a.xyR[1][0] = 1.0;
   a.xyR[1][1] = -1.0;
   y.xR[1] = 0.0;
   a.xyR[2][0] = 1.0;
   a.xyR[2][1] = 1.0;
   y.xR[2] = 1.0;
   a.xyR[3][0] = 1.0;
   a.xyR[3][1] = 1.0;
   y.xR[3] = 0.0;
   lsfitlinear(&y, &a, 4, 2, &info, &c, &rep);
   *LlsOkP = *LlsOkP && info > 0 && NearAtR(rep.r2, 0.5, threshold);
   n = 3;
   ae_matrix_set_length(&a, 3, 1);
   ae_vector_set_length(&y, 3);
   a.xyR[0][0] = 0.0;
   y.xR[0] = 0.0;
   a.xyR[1][0] = 0.0;
   y.xR[1] = 0.0;
   a.xyR[2][0] = 0.0;
   y.xR[2] = 0.0;
   lsfitlinear(&y, &a, 3, 1, &info, &c, &rep);
   *LlsOkP = *LlsOkP && info > 0 && isfinite(rep.r2) && rep.r2 == 1.0;
   ae_frame_leave();
}

// This function tests RDP functionality.
static bool testlsfitunit_testrdp() {
   ae_frame _frame_block;
   ae_int_t nsections;
   ae_int_t nsections3;
   double eps;
   ae_int_t i;
   ae_int_t k;
   ae_int_t n;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(e, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(x3, 0, DT_REAL);
   NewVector(y3, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewMatrix(xy3, 0, 0, DT_REAL);
   NewVector(idx2, 0, DT_INT);
   NewVector(idx3, 0, DT_INT);
   NewObj(spline1dinterpolant, s);
   hqrndrandomize(&rs);
// Non-parametric, single section basic test (fixed)
   ae_vector_set_length(&x, 2);
   ae_vector_set_length(&y, 2);
   x.xR[0] = 0.0;
   x.xR[1] = 1.5;
   y.xR[0] = 2.0;
   y.xR[1] = 3.0;
   lstfitpiecewiselinearrdpfixed(&x, &y, 2, 1, &x2, &y2, &nsections);
   Ok = Ok && nsections == 1;
   if (nsections == 1) {
      Ok = Ok && x2.xR[0] == 0.0;
      Ok = Ok && x2.xR[1] == 1.5;
      Ok = Ok && y2.xR[0] == 2.0;
      Ok = Ok && y2.xR[1] == 3.0;
   }
// Non-parametric, single section tied test (fixed)
   ae_vector_set_length(&x, 5);
   ae_vector_set_length(&y, 5);
   x.xR[0] = 0.0;
   x.xR[1] = 1.5;
   x.xR[2] = 0.0;
   x.xR[3] = 0.0;
   x.xR[4] = 1.5;
   y.xR[0] = 2.0;
   y.xR[1] = 1.0;
   y.xR[2] = 3.0;
   y.xR[3] = 1.0;
   y.xR[4] = 5.0;
   lstfitpiecewiselinearrdpfixed(&x, &y, 5, 1, &x2, &y2, &nsections);
   Ok = Ok && nsections == 1;
   if (nsections == 1) {
      Ok = Ok && x2.xR[0] == 0.0;
      Ok = Ok && x2.xR[1] == 1.5;
      Ok = Ok && y2.xR[0] == 2.0;
      Ok = Ok && y2.xR[1] == 3.0;
   }
// Non-parametric, two-section test (fixed)
   ae_vector_set_length(&x, 5);
   ae_vector_set_length(&y, 5);
   x.xR[0] = 0.0;
   x.xR[1] = 0.5;
   x.xR[2] = 1.0;
   x.xR[3] = 1.75;
   x.xR[4] = 2.0;
   y.xR[0] = 1.0;
   y.xR[1] = 2.1;
   y.xR[2] = 3.0;
   y.xR[3] = 5.21;
   y.xR[4] = 6.0;
   lstfitpiecewiselinearrdpfixed(&x, &y, 5, 2, &x2, &y2, &nsections);
   Ok = Ok && nsections == 2;
   if (nsections == 2) {
      Ok = Ok && x2.xR[0] == 0.0;
      Ok = Ok && x2.xR[1] == 1.0;
      Ok = Ok && x2.xR[2] == 2.0;
      Ok = Ok && y2.xR[0] == 1.0;
      Ok = Ok && y2.xR[1] == 3.0;
      Ok = Ok && y2.xR[2] == 6.0;
   }
// Non-parametric, variable precision test (non-fixed), results are compared against fixed-section test
   eps = 10.0;
   n = 100;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&y, n);
   while (eps >= 0.0001) {
   // Generate set of randomly rearranged points
      for (i = 0; i < n; i++) {
         x.xR[i] = pi * i / (n - 1);
         y.xR[i] = sin(x.xR[i]) + 0.005 * hqrndmiduniformr(&rs);
      }
      for (i = 0; i < n - 1; i++) {
         k = i + hqrnduniformi(&rs, n - i);
         swapr(&x.xR[i], &x.xR[k]);
         swapr(&y.xR[i], &y.xR[k]);
      }
   // Perform run of eps-based RDP algorithm
      lstfitpiecewiselinearrdp(&x, &y, n, eps, &x2, &y2, &nsections);
      Ok = Ok && nsections != 0;
      if (nsections == 0) {
         ae_frame_leave();
         return Ok;
      }
   // Check properties
      for (i = 0; i < nsections; i++) {
         Ok = Ok && x2.xR[i] <= x2.xR[i + 1];
      }
      spline1dbuildlinear(&x2, &y2, nsections + 1, &s);
      for (i = 0; i < n; i++) {
         Ok = Ok && NearAtR(spline1dcalc(&s, x.xR[i]), y.xR[i], eps);
      }
   // compare results with values returned by section-based algorithm
      lstfitpiecewiselinearrdpfixed(&x, &y, n, nsections, &x3, &y3, &nsections3);
      Ok = Ok && nsections3 == nsections;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < nsections; i++) {
         Ok = Ok && NearAtR(x2.xR[i], x3.xR[i], 1000.0 * machineepsilon);
         Ok = Ok && NearAtR(y2.xR[i], y3.xR[i], 1000.0 * machineepsilon);
      }
   // Next epsilon
      eps *= 0.5;
   }
// Test that non-parametric RDP correctly handles requests for more than N-1 section
   n = 100;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&y, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = pi * hqrnduniformr(&rs);
      y.xR[i] = sin(x.xR[i]) + 0.005 * hqrndmiduniformr(&rs);
   }
   lstfitpiecewiselinearrdpfixed(&x, &y, n, n, &x2, &y2, &nsections);
   Ok = Ok && nsections == n - 1;
   ae_frame_leave();
   return Ok;
}

// Appends 10 elements to the array
static void testlsfitunit_append10(RVector *x, double v0, double v1, double v2, double v3, double v4, double v5, double v6, double v7, double v8, double v9) {
   rvectorresize(x, x->cnt + 10);
   x->xR[x->cnt - 10] = v0;
   x->xR[x->cnt - 9] = v1;
   x->xR[x->cnt - 8] = v2;
   x->xR[x->cnt - 7] = v3;
   x->xR[x->cnt - 6] = v4;
   x->xR[x->cnt - 5] = v5;
   x->xR[x->cnt - 4] = v6;
   x->xR[x->cnt - 3] = v7;
   x->xR[x->cnt - 2] = v8;
   x->xR[x->cnt - 1] = v9;
}

// This function tests 4PL/5PL fitting.
static bool testlsfitunit_testlogisticfitting() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nz;
   ae_int_t ntotal;
   ae_int_t i;
   ae_int_t k;
   double v;
   double vv;
   ae_int_t k0;
   ae_int_t k1;
   double v0;
   double v1;
   ae_int_t pass;
   ae_int_t idxa;
   ae_int_t idxb;
   ae_int_t idxc;
   ae_int_t idxd;
   ae_int_t idxg;
   ae_int_t idxx;
   double a;
   double b;
   double c;
   double d;
   double g;
   double ae;
   double be;
   double ce;
   double de;
   double ge;
   double scalex;
   double scaley;
   double noise;
   double tol;
   double er2;
   double erms;
   double eavg;
   double eavgrel;
   double emax;
   double rss;
   double tss;
   double meany;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(lsfitreport, rep);
   NewObj(lsfitreport, rep2);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// 4PL/5PL calculation
   tol = 1.0E-6;
   for (idxa = -4; idxa <= 4; idxa++) {
      for (idxb = -3; idxb <= 3; idxb++) {
         for (idxc = -4; idxc <= 4; idxc++) {
            for (idxd = -4; idxd <= 4; idxd++) {
               for (idxg = -4; idxg <= 4; idxg++) {
                  for (idxx = -4; idxx <= 4; idxx++) {
                  // Convert Idx* to corresponding parameter value
                     a = (double)idxa;
                     b = (double)idxb;
                     c = pow(2.0, (double)idxc);
                     d = (double)idxd;
                     g = pow(2.0, (double)idxg);
                     if (idxx != 0) {
                        v = pow(2.0, (double)idxx);
                     } else {
                        v = 0.0;
                     }
                  // Test 4PL calculation
                     vv = 0.0;
                     if (v != 0.0) {
                        vv = d + (a - d) / (1 + pow(v / c, b));
                     } else {
                        if (b > 0.0) {
                           vv = a;
                        }
                        if (b < 0.0) {
                           vv = d;
                        }
                        if (b == 0.0) {
                           vv = 0.5 * (a + d);
                        }
                     }
                     v0 = logisticcalc4(v, a, b, c, d);
                     Ok = Ok && NearAtR(vv, v0, tol);
                  // Test 5PL calculation
                     if (v != 0.0) {
                        vv = d + (a - d) / pow(1 + pow(v / c, b), g);
                     } else {
                        if (b > 0.0) {
                           vv = a;
                        }
                        if (b < 0.0) {
                           vv = d;
                        }
                        if (b == 0.0) {
                           vv = d + (a - d) / pow(2.0, g);
                        }
                     }
                     v0 = logisticcalc5(v, a, b, c, d, g);
                     Ok = Ok && NearAtR(vv, v0, tol);
                  }
               }
            }
         }
      }
   }
// 4PL fitting
//
// Generate random AE/BE/CE/DE, generate random set of points and for
// each point generate two function values: F(x)+eps and F(x)-eps.
// Such problem has solution which is exactly AE/BE/CE/DE which were
// used to generate points.
//
// This test checks both unconstrained and constrained fitting (latter
// one is performed with A constrained to AE, B constrained to BE).
   tol = 1.0E-6;
   for (pass = 1; pass <= 30; pass++) {
   // Generate 2*N points with non-zero X and 2*NZ points with
   // zero X. In most cases we choose N != 0 and NZ != 0, but in
   // some cases either N or NZ (but not both) is zero.
   //
   // X-values have scale equal to ScaleX
      scalex = pow(10.0, 15.0 * hqrndmiduniformr(&rs));
      n = 40 + hqrnduniformi(&rs, 40);
      nz = 4 + hqrnduniformi(&rs, 4);
      if (hqrnduniformr(&rs) < 0.1) {
         if (hqrnduniformr(&rs) < 0.5) {
            n = 0;
         } else {
            nz = 0;
         }
      }
      ntotal = 2 * (n + nz);
      ae_vector_set_length(&x, ntotal);
      for (i = 0; i < n; i++) {
         v = scalex * exp(log(5.0) * hqrndmiduniformr(&rs));
         x.xR[2 * i] = v;
         x.xR[2 * i + 1] = v;
      }
      for (i = 0; i < nz; i++) {
         x.xR[2 * n + 2 * i] = 0.0;
         x.xR[2 * n + 2 * i + 1] = 0.0;
      }
   // Fenerate A/B/C/D:
   // * A/D are random with scale equal to ScaleY
   // * B is in +-[0.25,4.0]
   // * for C we choose one of X[], if N > 0;
   //   if N == 0, we set C == 1.
      scaley = pow(10.0, 15.0 * hqrndmiduniformr(&rs));
      ae = scaley * (hqrnduniformr(&rs) - 0.5);
      be = (2 * hqrnduniformi(&rs, 2) - 1) * exp(log(4.0) * hqrndmiduniformr(&rs));
      ce = scalex * exp(log(2.0) * hqrndmiduniformr(&rs));
      de = ae + scaley * (2 * hqrnduniformi(&rs, 2) - 1) * (hqrnduniformr(&rs) + 0.5);
   // Choose noise level and generate Y[].
      noise = 0.05 * scaley;
      ae_vector_set_length(&y, ntotal);
      for (i = 0; i < ntotal / 2; i++) {
         if (x.xR[2 * i] != 0.0) {
            v = de + (ae - de) / (1.0 + pow(x.xR[2 * i] / ce, be));
         } else {
            if (be >= 0.0) {
               v = ae;
            } else {
               v = de;
            }
         }
         y.xR[2 * i] = v + noise;
         y.xR[2 * i + 1] = v - noise;
      }
   // Unconstrained fit and test
   //
   // NOTE: we test that B >= 0 is returned. If BE < 0, we use
   //       symmetry property of 4PL model.
      logisticfit4(&x, &y, ntotal, &a, &b, &c, &d, &rep);
      Ok = Ok && isfinite(a);
      Ok = Ok && isfinite(b);
      Ok = Ok && isfinite(c);
      Ok = Ok && isfinite(d);
      Ok = Ok && b >= 0.0;
      v = 0.0;
      for (i = 0; i < ntotal; i++) {
         if (x.xR[i] != 0.0) {
            vv = d + (a - d) / (1.0 + pow(x.xR[i] / c, b));
         } else {
            vv = a;
         }
         v += sqr(y.xR[i] - vv);
      }
      v = sqrt(v / ntotal);
      Ok = Ok && v <= (1 + tol) * noise;
   // Constrained fit and test
   //
   // NOTE: we test that B >= 0 is returned. If BE < 0, we use
   //       symmetry property of 4PL model.
      for (k0 = 0; k0 <= 1; k0++) {
         for (k1 = 0; k1 <= 1; k1++) {
         // Choose constraints.
            if (k0 == 0) {
               v0 = NAN;
            } else {
               if (be >= 0.0) {
                  v0 = ae;
               } else {
                  v0 = de;
               }
            }
            if (k1 == 0) {
               v1 = NAN;
            } else {
               if (be >= 0.0) {
                  v1 = de;
               } else {
                  v1 = ae;
               }
            }
         // Fit
            logisticfit4ec(&x, &y, ntotal, v0, v1, &a, &b, &c, &d, &rep);
         // Check
            Ok = Ok && isfinite(a);
            Ok = Ok && isfinite(b);
            Ok = Ok && isfinite(c);
            Ok = Ok && isfinite(d);
            Ok = Ok && b >= 0.0;
            Ok = Ok && (k0 == 0 || a == v0);
            Ok = Ok && (k1 == 0 || d == v1);
            v = 0.0;
            for (i = 0; i < ntotal; i++) {
               if (x.xR[i] != 0.0) {
                  vv = d + (a - d) / (1.0 + pow(x.xR[i] / c, b));
               } else {
                  if (b >= 0.0) {
                     vv = a;
                  } else {
                     vv = d;
                  }
               }
               v += sqr(y.xR[i] - vv);
            }
            v = sqrt(v / ntotal);
            Ok = Ok && v <= (1 + tol) * noise;
         }
      }
   }
// 5PL fitting
//
// Generate random AE/BE/CE/DE/GE, generate random set of points and for
// each point generate two function values: F(x)+eps and F(x)-eps.
// Such problem has solution which is exactly AE/BE/CE/DE which were
// used to generate points.
//
// NOTE: because problem has higher condition number, we use lower
//       tolerance for power parameters B and G.
//
// This test checks both unconstrained and constrained fitting.
   tol = 1.0E-6;
   for (pass = 1; pass <= 10; pass++) {
   // Generate N points, N-1 of them with non-zero X and
   // last one with zero X.
   // X-values have scale equal to ScaleX
      scalex = pow(10.0, 15.0 * hqrndmiduniformr(&rs));
      k = 50;
      n = 2 * k + 1;
      ae_vector_set_length(&x, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = scalex * pow(2.0, (double)(2 * (i - k)) / k);
      }
      x.xR[n - 1] = 0.0;
   // Generate A/B/C/D/G:
   // * A/D are random with scale equal to ScaleY
   // * B is in +-[0.25,4.0]
   // * G is in   [0.25,4.0]
   // * C is in   [0.25,4.0]*ScaleX
   //   if N == 0, we set C == 1.
   // Generate Y[].
      scaley = pow(10.0, 15.0 * hqrndmiduniformr(&rs));
      ae = scaley * (hqrnduniformr(&rs) - 0.5);
      be = (2 * hqrnduniformi(&rs, 2) - 1) * exp(log(2.0) * hqrndmiduniformr(&rs));
      ce = scalex * exp(log(2.0) * hqrndmiduniformr(&rs));
      de = ae + scaley * (2 * hqrnduniformi(&rs, 2) - 1) * (hqrnduniformr(&rs) + 0.5);
      ge = exp(log(2.0) * hqrndmiduniformr(&rs));
      ae_vector_set_length(&y, n);
      for (i = 0; i < n; i++) {
         if (x.xR[i] != 0.0) {
            v = de + (ae - de) / pow(1.0 + pow(x.xR[i] / ce, be), ge);
         } else {
            if (be >= 0.0) {
               v = ae;
            } else {
               v = de;
            }
         }
         y.xR[i] = v;
      }
   // Unconstrained fit and test
   //
   // NOTE: we test that B >= 0 is returned. If BE < 0, we use
   //       symmetry property of 4PL model.
      logisticfit5(&x, &y, n, &a, &b, &c, &d, &g, &rep);
      v = 0.0;
      for (i = 0; i < n; i++) {
         if (x.xR[i] != 0.0) {
            vv = d + (a - d) / pow(1.0 + pow(x.xR[i] / c, b), g);
         } else {
            if (b >= 0.0) {
               vv = a;
            } else {
               vv = d;
            }
         }
         v += sqr(y.xR[i] - vv);
      }
      v = sqrt(v / n);
      Ok = Ok && v <= scaley * tol;
   // Constrained fit and test
      for (k0 = 0; k0 <= 1; k0++) {
         for (k1 = 0; k1 <= 1; k1++) {
         // Choose constraints.
            if (k0 == 0) {
               v0 = NAN;
            } else {
               if (be >= 0.0) {
                  v0 = ae;
               } else {
                  v0 = de;
               }
            }
            if (k1 == 0) {
               v1 = NAN;
            } else {
               if (be >= 0.0) {
                  v1 = de;
               } else {
                  v1 = ae;
               }
            }
         // Fit
            logisticfit5ec(&x, &y, n, v0, v1, &a, &b, &c, &d, &g, &rep);
            Ok = Ok && isfinite(a);
            Ok = Ok && isfinite(b);
            Ok = Ok && isfinite(c);
            Ok = Ok && isfinite(d);
            if (b > 0.0) {
               Ok = Ok && (k0 == 0 || a == v0);
               Ok = Ok && (k1 == 0 || d == v1);
            } else {
               Ok = Ok && (k0 == 0 || d == v0);
               Ok = Ok && (k1 == 0 || a == v1);
            }
            v = 0.0;
            for (i = 0; i < n; i++) {
               if (x.xR[i] != 0.0) {
                  vv = d + (a - d) / pow(1.0 + pow(x.xR[i] / c, b), g);
               } else {
                  if (b >= 0.0) {
                     vv = a;
                  } else {
                     vv = d;
                  }
               }
               v += sqr(y.xR[i] - vv);
            }
            v = sqrt(v / n);
            Ok = Ok && v <= scaley * tol;
         }
      }
   }
// Test correctness of errors
   tol = 1.0E-6;
   for (pass = 1; pass <= 20; pass++) {
      n = 10;
      meany = 0.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = (double)i;
         y.xR[i] = hqrnduniformr(&rs) - 0.5;
         meany += y.xR[i];
      }
      meany /= n;
      x.xR[1] = 0.0;
   // Choose model fitting function to test
      k = hqrnduniformi(&rs, 4);
      a = 0.0;
      d = 0.0;
      c = 1.0;
      b = 1.0;
      g = 1.0;
      if (k == 0) {
         logisticfit4(&x, &y, n, &a, &b, &c, &d, &rep);
         g = 1.0;
      }
      if (k == 1) {
         logisticfit4ec(&x, &y, n, hqrnduniformr(&rs) - 0.5, hqrnduniformr(&rs) - 0.5, &a, &b, &c, &d, &rep);
         g = 1.0;
      }
      if (k == 2) {
         logisticfit5(&x, &y, n, &a, &b, &c, &d, &g, &rep);
      }
      if (k == 3) {
         logisticfit5ec(&x, &y, n, hqrnduniformr(&rs) - 0.5, hqrnduniformr(&rs) - 0.5, &a, &b, &c, &d, &g, &rep);
      }
      k = 0;
      erms = 0.0;
      eavg = 0.0;
      eavgrel = 0.0;
      emax = 0.0;
      rss = 0.0;
      tss = 0.0;
      for (i = 0; i < n; i++) {
         if (x.xR[i] != 0.0) {
            v = d + (a - d) / pow(1.0 + pow(x.xR[i] / c, b), g);
         } else {
            if (b >= 0.0) {
               v = a;
            } else {
               v = d;
            }
         }
         v -= y.xR[i];
         rss += v * v;
         tss += sqr(y.xR[i] - meany);
         erms += sqr(v);
         eavg += fabs(v);
         if (y.xR[i] != 0.0) {
            eavgrel += fabs(v / y.xR[i]);
            k++;
         }
         emax = rmax2(emax, fabs(v));
      }
      er2 = 1.0 - rss / tss;
      erms = sqrt(erms / n);
      eavg /= n;
      if (k > 0) {
         eavgrel /= k;
      }
      Ok = Ok && NearAtR(erms, rep.rmserror, tol);
      Ok = Ok && NearAtR(eavg, rep.avgerror, tol);
      Ok = Ok && NearAtR(emax, rep.maxerror, tol);
      Ok = Ok && NearAtR(eavgrel, rep.avgrelerror, tol);
      Ok = Ok && NearAtR(er2, rep.r2, tol);
   }
// Test previously fixed bug #834
   ae_vector_set_length(&x, 0);
   testlsfitunit_append10(&x, 0.019556, 0.093533, 0.13780, 0.25210, 0.46373, 0.23997, 0.52861, 0.50526, 0.43401, 0.82270);
   testlsfitunit_append10(&x, 0.65746, 0.76479, 0.81512, 0.89031, 1.1959, 1.2032, 1.0671, 1.2350, 1.2954, 1.5422);
   testlsfitunit_append10(&x, 1.4306, 1.5628, 1.6774, 1.8053, 1.9866, 2.1446, 2.1740, 2.2574, 2.2662, 2.4035);
   testlsfitunit_append10(&x, 2.7225, 2.6500, 2.7752, 2.9126, 2.8962, 3.0439, 3.1260, 3.2458, 3.3613, 3.3728);
   testlsfitunit_append10(&x, 3.5641, 3.5168, 3.6975, 3.7848, 3.8421, 3.9058, 4.0292, 4.1111, 4.0835, 4.3436);
   testlsfitunit_append10(&x, 4.3982, 4.6098, 4.3606, 4.5595, 4.7099, 4.8806, 4.9779, 4.9909, 5.0121, 5.2571);
   testlsfitunit_append10(&x, 5.3663, 5.4739, 5.5818, 5.5224, 5.7895, 5.9141, 6.0897, 6.1476, 6.2491, 6.3541);
   testlsfitunit_append10(&x, 6.4007, 6.5969, 6.6530, 6.7837, 6.8692, 6.9383, 7.0344, 7.1702, 7.3118, 7.3728);
   testlsfitunit_append10(&x, 7.4589, 7.6068, 7.6290, 7.8139, 7.9891, 8.0425, 8.1817, 8.3442, 8.3772, 8.4691);
   testlsfitunit_append10(&x, 8.5864, 8.7201, 8.9721, 8.9208, 9.0603, 9.1961, 9.3344, 9.3738, 9.4808, 9.6527);
   testlsfitunit_append10(&x, 9.7197, 9.8180, 10.034, 10.155, 10.205, 10.323, 10.421, 10.571, 10.723, 10.795);
   testlsfitunit_append10(&x, 11.000, 10.977, 11.145, 11.249, 11.425, 11.495, 11.598, 11.723, 11.787, 12.001);
   testlsfitunit_append10(&x, 12.005, 12.136, 12.312, 12.381, 12.417, 12.645, 12.766, 12.864, 12.889, 13.017);
   testlsfitunit_append10(&x, 13.171, 13.323, 13.406, 13.451, 13.551, 13.732, 13.735, 13.909, 14.075, 14.150);
   testlsfitunit_append10(&x, 14.265, 14.365, 14.524, 14.541, 14.679, 14.836, 14.998, 15.071, 15.170, 15.238);
   testlsfitunit_append10(&x, 15.327, 15.388, 15.614, 15.729, 15.671, 15.858, 15.984, 16.008, 16.219, 16.231);
   testlsfitunit_append10(&x, 16.424, 16.642, 16.784, 16.837, 16.959, 17.000, 17.088, 17.162, 17.210, 17.460);
   testlsfitunit_append10(&x, 17.597, 17.698, 17.679, 17.962, 17.974, 17.966, 18.240, 18.240, 18.521, 18.645);
   testlsfitunit_append10(&x, 18.739, 18.830, 18.749, 19.062, 19.062, 19.160, 19.224, 19.334, 19.395, 19.567);
   ae_vector_set_length(&y, 0);
   testlsfitunit_append10(&y, 0.096932, 0.099305, 0.098981, 0.098981, 0.099898, 0.096879, 0.098334, 0.097525, 0.097418, 0.098065);
   testlsfitunit_append10(&y, 0.098334, 0.096016, 0.098172, 0.096339, 0.098550, 0.098927, 0.099898, 0.098927, 0.097472, 0.097418);
   testlsfitunit_append10(&y, 0.098604, 0.097849, 0.096932, 0.098765, 0.097957, 0.099143, 0.097795, 0.098819, 0.098550, 0.098658);
   testlsfitunit_append10(&y, 0.099143, 0.096609, 0.099358, 0.099358, 0.100110, 0.098819, 0.097148, 0.098604, 0.095692, 0.097849);
   testlsfitunit_append10(&y, 0.098172, 0.097957, 0.099898, 0.097687, 0.097364, 0.098226, 0.098280, 0.099844, 0.099143, 0.098765);
   testlsfitunit_append10(&y, 0.099412, 0.098442, 0.100110, 0.098172, 0.098334, 0.096932, 0.097687, 0.098981, 0.098873, 0.096501);
   testlsfitunit_append10(&y, 0.098550, 0.099682, 0.100170, 0.098927, 0.099628, 0.099628, 0.099197, 0.099089, 0.098550, 0.098819);
   testlsfitunit_append10(&y, 0.099035, 0.097202, 0.099736, 0.099628, 0.099035, 0.099035, 0.099305, 0.097795, 0.099143, 0.100060);
   testlsfitunit_append10(&y, 0.098442, 0.099951, 0.098065, 0.099628, 0.098388, 0.099898, 0.098873, 0.099520, 0.097795, 0.097687);
   testlsfitunit_append10(&y, 0.098658, 0.098765, 0.099628, 0.099736, 0.098388, 0.099628, 0.099251, 0.098334, 0.097903, 0.099682);
   testlsfitunit_append10(&y, 0.097094, 0.098765, 0.098765, 0.098981, 0.099574, 0.099736, 0.098280, 0.099520, 0.099466, 0.099790);
   testlsfitunit_append10(&y, 0.099358, 0.098873, 0.097579, 0.099143, 0.099951, 0.099035, 0.097256, 0.098765, 0.099520, 0.099790);
   testlsfitunit_append10(&y, 0.097094, 0.099520, 0.099305, 0.098765, 0.098604, 0.099790, 0.098226, 0.099251, 0.098819, 0.099574);
   testlsfitunit_append10(&y, 0.099682, 0.099951, 0.098119, 0.100220, 0.099197, 0.098334, 0.099035, 0.098927, 0.099628, 0.10076);
   testlsfitunit_append10(&y, 0.10081, 0.10351, 0.10367, 0.10405, 0.10502, 0.10815, 0.11208, 0.11451, 0.11467, 0.11639);
   testlsfitunit_append10(&y, 0.11839, 0.12195, 0.12378, 0.12577, 0.12755, 0.12842, 0.13262, 0.13747, 0.14486, 0.15483);
   testlsfitunit_append10(&y, 0.17554, 0.20422, 0.23796, 0.27581, 0.31495, 0.35576, 0.39857, 0.44374, 0.48946, 0.53475);
   testlsfitunit_append10(&y, 0.57766, 0.61960, 0.65400, 0.68936, 0.72268, 0.75573, 0.78446, 0.81169, 0.83185, 0.86247);
   testlsfitunit_append10(&y, 0.88797, 0.91083, 0.93142, 0.94916, 0.96463, 0.97881, 0.98809, 0.99774, 0.99844, 1.00000);
   logisticfit4(&x, &y, 190, &a, &b, &c, &d, &rep);
   Ok = Ok && b >= 31.90 && b <= 32.00;
   Ok = Ok && rep.rmserror <= 0.02;
   logisticfit5(&x, &y, 190, &a, &b, &c, &d, &g, &rep2);
   Ok = Ok && rep2.rmserror <= 0.95 * rep.rmserror;
   ae_frame_leave();
   return Ok;
}

// This function return function's value(F == F(X,C)) and it derivatives(DF == dF/dC).
// Function dimension is M. Length(C) is K.
//     Function's list:
//         * funcType == 1:
//             K > M:
//             F(X) == C0^2*(X0-CX0)^2+C1^2*(X1-CX1)^2+...+CM^2*(XM-CXM)^2
//                 +C(M+1)^2+...+CK^2;
//             K < M:
//             F(X) == C0^2*(X0-CX0)^2+C1^2*(X1-CX1)^2+...+CK^2*(XK-CXK)^2
//                 +(X(K+1)-CX(K+1))^2+...+(XM-CXM)^2;
//         * funcType == 2:
//             K > M:
//             F(X) == C0*sin(X0-CX0)^2+C1*sin(X1-CX1)^2+...+CM*sin(XM-CXM)^2
//                 +C(M+1)^3+...+CK^3;
//             K < M
//             F(X) == C0*sin(X0-CX0)^2+C1*sin(X1-CX1)^2+...+CK*sin(XK-CXK)^2
//                 +sin(X(K+1)-CX(K+1))^2+...+sin(XM-CXM)^2;
//         * funcType == 3:
//             F(X) == C0^2+C1^2+...+CK^2+(X0-CX0)^2+(X1-CX1)^2+...+(XM-CXM)^2.
static void testlsfitunit_funcderiv(RVector *c, RVector *x, RVector *x0, ae_int_t k, ae_int_t m, ae_int_t functype, double *f, RVector *g) {
   ae_int_t i;
   ae_assert(functype >= 1 && functype <= 3, "FuncDeriv: incorrect funcType(funcType < 1 or funcType > 3).");
   ae_assert(k > 0, "FuncDeriv: K <= 0");
   ae_assert(m > 0, "FuncDeriv: M <= 0");
   ae_assert(x->cnt >= m, "FuncDeriv: Length(X) < M");
   ae_assert(isfinitevector(x, m), "FuncDeriv: X contains NaN or Infinite.");
   ae_assert(x0->cnt >= m, "FuncDeriv: Length(X0) < M");
   ae_assert(isfinitevector(x0, m), "FuncDeriv: X0 contains NaN or Infinite.");
   ae_assert(c->cnt >= k, "FuncDeriv: Length(X) < K");
   ae_assert(isfinitevector(c, k), "FuncDeriv: C contains NaN or Infinite.");
   if (functype == 1) {
      *f = 0.0;
      for (i = 0; i < imin2(m, k); i++) {
         *f += sqr(c->xR[i] * (x->xR[i] - x0->xR[i]));
         g->xR[i] = 2 * c->xR[i] * sqr(x->xR[i] - x0->xR[i]);
      }
      if (k > m) {
         for (i = m; i < k; i++) {
            *f += sqr(c->xR[i]);
            g->xR[i] = 2 * c->xR[i];
         }
      }
      if (k < m) {
         for (i = k; i < m; i++) {
            *f += sqr(x->xR[i] - x0->xR[i]);
         }
      }
      return;
   }
   if (functype == 2) {
      *f = 0.0;
      for (i = 0; i < imin2(m, k); i++) {
         *f += c->xR[i] * sqr(sin(x->xR[i] - x0->xR[i]));
         g->xR[i] = sqr(sin(x->xR[i] - x0->xR[i]));
      }
      if (k > m) {
         for (i = m; i < k; i++) {
            *f += c->xR[i] * c->xR[i] * c->xR[i];
            g->xR[i] = 3 * sqr(c->xR[i]);
         }
      }
      if (k < m) {
         for (i = k; i < m; i++) {
            *f += sqr(sin(x->xR[i] - x0->xR[i]));
         }
      }
      return;
   }
   if (functype == 3) {
      *f = 0.0;
      for (i = 0; i < m; i++) {
         *f += sqr(x->xR[i] - x0->xR[i]);
      }
      for (i = 0; i < k; i++) {
         *f += c->xR[i] * c->xR[i];
      }
      for (i = 0; i < k; i++) {
         g->xR[i] = 2 * c->xR[i];
      }
      return;
   }
}

// This function tests, that gradient verified correctly.
static bool testlsfitunit_testgradientcheck() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t k;
   ae_int_t info;
   ae_int_t infcomp;
   double teststep;
   double noise;
   ae_int_t nbrcomp;
   double spp;
   ae_int_t func;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(lsfitstate, state);
   NewObj(lsfitreport, rep);
   NewVector(c, 0, DT_REAL);
   NewVector(cres, 0, DT_REAL);
   NewMatrix(x, 0, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   passcount = 35;
   spp = 1.0;
   teststep = 0.001;
   for (pass = 1; pass <= passcount; pass++) {
      m = randominteger(5) + 1;
      ae_vector_set_length(&x0, m);
      k = randominteger(5) + 1;
      ae_vector_set_length(&c, k);
      ae_vector_set_length(&bl, k);
      ae_vector_set_length(&bu, k);
   // Prepare test's parameters
      func = randominteger(3) + 1;
      n = randominteger(8) + 3;
      ae_matrix_set_length(&x, n, m);
      ae_vector_set_length(&y, n);
      nbrcomp = randominteger(k);
      noise = (double)(2 * randominteger(2) - 1);
   // Prepare function's parameters
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            x.xyR[i][j] = spp * randommid();
         }
         y.xR[i] = spp * randommid();
      }
      for (i = 0; i < k; i++) {
         c.xR[i] = spp * randommid();
      }
      for (i = 0; i < m; i++) {
         x0.xR[i] = 10.0 * randommid();
      }
   // Prepare boundary parameters
      for (i = 0; i < k; i++) {
         bl.xR[i] = -randomreal() - spp;
         bu.xR[i] = randomreal() + spp;
      }
      infcomp = randominteger(k + 1);
      if (infcomp < k) {
         bl.xR[infcomp] = -INFINITY;
      }
      infcomp = randominteger(k + 1);
      if (infcomp < k) {
         bu.xR[infcomp] = +INFINITY;
      }
      lsfitcreatefg(&x, &y, &c, n, m, k, true, &state);
      lsfitsetgradientcheck(&state, teststep);
      lsfitsetcond(&state, 0.0, 100);
      lsfitsetbc(&state, &bl, &bu);
   // Check that the criterion passes a derivative if it is correct
      while (lsfititeration(&state))
         if (state.needfg) {
            testlsfitunit_funcderiv(&state.c, &state.x, &x0, k, m, func, &state.f, &state.g);
         }
      lsfitresults(&state, &info, &cres, &rep);
   // Check that error code does not equal to -7 and parameter .VarIdx
   // equal to -1.
      if (info == -7 || rep.varidx != -1) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   // Create again and...
      lsfitcreatefg(&x, &y, &c, n, m, k, true, &state);
      lsfitsetgradientcheck(&state, teststep);
      lsfitsetcond(&state, 0.0, 100);
      lsfitsetbc(&state, &bl, &bu);
   // Check that the criterion does not miss a derivative if
   // it is incorrect
      while (lsfititeration(&state))
         if (state.needfg) {
            testlsfitunit_funcderiv(&state.c, &state.x, &x0, k, m, func, &state.f, &state.g);
            state.g.xR[nbrcomp] += noise;
         }
      lsfitresults(&state, &info, &cres, &rep);
   // Check that error code equal to -7 and parameter .VarIdx
   // equal to number of incorrect component.
      if (info != -7 || rep.varidx != nbrcomp) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   ae_frame_leave();
   return Ok;
}

bool testlsfit() {
   bool Ok;
   bool llsOk;
   bool nlsOk;
   bool polfitOk;
   bool ratfitOk;
   bool splfitOk;
   bool gradOk;
   bool logisticOk;
   bool rdpOk;
   Ok = true;
   polfitOk = true;
   ratfitOk = true;
   splfitOk = true;
   llsOk = true;
   nlsOk = true;
   gradOk = true;
   logisticOk = true;
   rdpOk = true;
   rdpOk = rdpOk && testlsfitunit_testrdp();
   logisticOk = logisticOk && testlsfitunit_testlogisticfitting();
   polfitOk = polfitOk && testlsfitunit_testpolynomialfitting();
   ratfitOk = ratfitOk && testlsfitunit_testrationalfitting();
   splfitOk = splfitOk && testlsfitunit_testsplinefitting();
   testlsfitunit_testgeneralfitting(&llsOk, &nlsOk);
   gradOk = gradOk && testlsfitunit_testgradientcheck();
// The final report.
   Ok = llsOk && nlsOk && polfitOk && ratfitOk && splfitOk && gradOk && logisticOk && rdpOk;
   if (!Ok || !silent) {
      printf("Least Squares Fit Tests\n");
      printf("Polynomial Least Squares:                 %s\n", polfitOk? "Ok": "Failed");
      printf("Rational Least Squares:                   %s\n", ratfitOk? "Ok": "Failed");
      printf("Spline Least Squares:                     %s\n", splfitOk? "Ok": "Failed");
      printf("Linear Least Squares:                     %s\n", llsOk? "Ok": "Failed");
      printf("Non-Linear Least Squares:                 %s\n", nlsOk? "Ok": "Failed");
      printf("Test For Verification Of The Gradient:    %s\n", gradOk? "Ok": "Failed");
      printf("Logistic Fitting (4PL/5PL):               %s\n", logisticOk? "Ok": "Failed");
      printf("RDP Algorithm:                            %s\n", rdpOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
// end
   return Ok;
}

// === fitsphere testing unit ===
// Used to calculate RLo/Rhi given XY and center position
static void testfitsphereunit_calcradii(RMatrix *xy, ae_int_t npoints, ae_int_t nx, RVector *cx, double *rlo, double *rhi) {
   ae_int_t i;
   ae_int_t j;
   double v;
   *rlo = 0;
   *rhi = 0;
   *rlo = maxrealnumber;
   *rhi = 0.0;
   for (i = 0; i < npoints; i++) {
      v = 0.0;
      for (j = 0; j < nx; j++) {
         v += sqr(xy->xyR[i][j] - cx->xR[j]);
      }
      v = sqrt(v);
      *rhi = rmax2(*rhi, v);
      *rlo = rmin2(*rlo, v);
   }
}

// Used to calculate least squares error given XY and center position
static void testfitsphereunit_calclserror(RMatrix *xy, ae_int_t npoints, ae_int_t nx, RVector *cx, double *err) {
   ae_int_t i;
   ae_int_t j;
   double v;
   double rad;
   *err = 0;
   rad = 0.0;
   for (i = 0; i < npoints; i++) {
      v = 0.0;
      for (j = 0; j < nx; j++) {
         v += sqr(cx->xR[j] - xy->xyR[i][j]);
      }
      rad += sqrt(v) / npoints;
   }
   *err = 0.0;
   for (i = 0; i < npoints; i++) {
      v = 0.0;
      for (j = 0; j < nx; j++) {
         v += sqr(cx->xR[j] - xy->xyR[i][j]);
      }
      *err += sqr(rad - sqrt(v));
   }
}

// This function tests least squares (LS) sphere fitting using generic
// synthetic datasets
static bool testfitsphereunit_testspherefittingls() {
   ae_frame _frame_block;
   double xtol;
   ae_int_t npoints;
   ae_int_t nx;
   double rlo;
   double rhi;
   double ftol;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double v0;
   double v1;
   ae_int_t problemtype;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(cx, 0, DT_REAL);
   NewVector(cy, 0, DT_REAL);
   hqrndrandomize(&rs);
   xtol = 1.0E-5;
// Generate random problem
   for (nx = 1; nx <= 4; nx++) {
   // Generate synthetic dataset, at least 5 points
      npoints = 5 + 2 * nx + hqrnduniformi(&rs, 50 + iround(pow(4.0, (double)nx)));
      ae_matrix_set_length(&xy, npoints, nx);
      for (i = 0; i < npoints; i++) {
         v = 0.0;
         for (j = 0; j < nx; j++) {
            vv = hqrndnormal(&rs);
            v += sqr(vv);
            xy.xyR[i][j] = vv;
         }
         ae_assert(v > 0.0, "Assertion failed");
         v = (1.0 + 0.1 * hqrnduniformr(&rs)) / sqrt(v);
         for (j = 0; j < nx; j++) {
            xy.xyR[i][j] *= v;
         }
      }
   // Solve with generic solver, check
      SetVector(&cx);
      rlo = 0.0;
      rhi = 0.0;
      problemtype = 0;
      fitspherex(&xy, npoints, nx, problemtype, 0.0, 0, 0.0, &cx, &rlo, &rhi);
      Ok = Ok && rlo == rhi;
      vv = 0.0;
      for (i = 0; i < npoints; i++) {
         v = 0.0;
         for (j = 0; j < nx; j++) {
            v += sqr(cx.xR[j] - xy.xyR[i][j]);
         }
         vv += sqrt(v) / npoints;
      }
      Ok = Ok && NearAtR(vv, rlo, xtol);
      testfitsphereunit_calclserror(&xy, npoints, nx, &cx, &v0);
   // Check that small perturbations to center position increase target function
   //
   // NOTE: in fact, we do allow small increase in target function - but no more
   //       than FTol == 1E-6*XTol. It helps to avoid spurious error reports in
   //       degenerate cases.
      ftol = 1.0E-6 * xtol;
      ae_vector_set_length(&cy, nx);
      for (j = 0; j < nx; j++) {
         for (k = 0; k < nx; k++) {
            cy.xR[k] = cx.xR[k];
         }
         cy.xR[j] = cx.xR[j] + xtol;
         testfitsphereunit_calclserror(&xy, npoints, nx, &cy, &v1);
         Ok = Ok && v1 >= v0 - ftol;
         for (k = 0; k < nx; k++) {
            cy.xR[k] = cx.xR[k];
         }
         cy.xR[j] = cx.xR[j] - xtol;
         testfitsphereunit_calclserror(&xy, npoints, nx, &cy, &v1);
         Ok = Ok && v1 >= v0 - ftol;
      }
   // Compare against results returned by specific solver
      fitspherels(&xy, npoints, nx, &cy, &v);
      Ok = Ok && v == rlo;
      for (j = 0; j < nx; j++) {
         Ok = Ok && cy.xR[j] == cx.xR[j];
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests sphere fitting using generic synthetic datasets and
// non-smooth target functions (MC, MI, MZ fitting)
static bool testfitsphereunit_testspherefittingns() {
   ae_frame _frame_block;
   ae_int_t npoints;
   ae_int_t nx;
   double rlo;
   double rhi;
   double rlo2;
   double rhi2;
   double xtol;
   double ftol;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   ae_int_t problemtype;
   double vlo;
   double vhi;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(cx, 0, DT_REAL);
   NewVector(cy, 0, DT_REAL);
   hqrndrandomize(&rs);
   xtol = 1.0E-5;
// Generate random problem
   for (nx = 1; nx <= 4; nx++) {
   // Generate synthetic dataset
      npoints = 50 + iround(pow(4.0, (double)nx));
      ae_matrix_set_length(&xy, npoints, nx);
      for (i = 0; i < npoints; i++) {
         v = 0.0;
         for (j = 0; j < nx; j++) {
            vv = hqrndnormal(&rs);
            v += sqr(vv);
            xy.xyR[i][j] = vv;
         }
         ae_assert(v > 0.0, "Assertion failed");
         v = (1.0 + 0.1 * hqrnduniformr(&rs)) / sqrt(v);
         for (j = 0; j < nx; j++) {
            xy.xyR[i][j] *= v;
         }
      }
   // Perform various kinds of fit, NLC solver is used
      for (problemtype = 1; problemtype <= 3; problemtype++) {
      // Solve with generic solver
         SetVector(&cx);
         rlo = 0.0;
         rhi = 0.0;
         fitspherex(&xy, npoints, nx, problemtype, 0.0, 0, 0.0, &cx, &rlo, &rhi);
      // Check that small perturbations to center position increase target function
      //
      // NOTE: in fact, we do allow small increase in target function - but no more
      //       than FTol == 1E-6*XTol. It helps to avoid spurious error reports in
      //       degenerate cases.
         ftol = 1.0E-6 * xtol;
         ae_vector_set_length(&cy, nx);
         if (problemtype == 2 || problemtype == 3) {
            vlo = 1.0;
         } else {
            vlo = 0.0;
         }
         if (problemtype == 1 || problemtype == 3) {
            vhi = 1.0;
         } else {
            vhi = 0.0;
         }
         for (j = 0; j < nx; j++) {
            for (k = 0; k < nx; k++) {
               cy.xR[k] = cx.xR[k];
            }
            cy.xR[j] = cx.xR[j] + xtol;
            testfitsphereunit_calcradii(&xy, npoints, nx, &cy, &rlo2, &rhi2);
            Ok = Ok && rhi2 * vhi - rlo2 * vlo >= rhi * vhi - rlo * vlo - ftol;
            for (k = 0; k < nx; k++) {
               cy.xR[k] = cx.xR[k];
            }
            cy.xR[j] = cx.xR[j] - xtol;
            testfitsphereunit_calcradii(&xy, npoints, nx, &cy, &rlo2, &rhi2);
            Ok = Ok && rhi2 * vhi - rlo2 * vlo >= rhi * vhi - rlo * vlo - ftol;
         }
      // Compare against results returned by specific solver
         if (problemtype == 1) {
            fitspheremc(&xy, npoints, nx, &cy, &rhi2);
            Ok = Ok && rhi2 == rhi;
            for (j = 0; j < nx; j++) {
               Ok = Ok && cy.xR[j] == cx.xR[j];
            }
         }
         if (problemtype == 2) {
            fitspheremi(&xy, npoints, nx, &cy, &rlo2);
            Ok = Ok && rlo2 == rlo;
            for (j = 0; j < nx; j++) {
               Ok = Ok && cy.xR[j] == cx.xR[j];
            }
         }
         if (problemtype == 3) {
            fitspheremz(&xy, npoints, nx, &cy, &rlo2, &rhi2);
            Ok = Ok && rlo2 == rlo;
            Ok = Ok && rhi2 == rhi;
            for (j = 0; j < nx; j++) {
               Ok = Ok && cy.xR[j] == cx.xR[j];
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Used to initialize dynamic array with constant values
static void testfitsphereunit_addvalue(RMatrix *xy, ae_int_t *cnt, double v) {
   xy->xyR[*cnt / xy->cols][*cnt % xy->cols] = v;
   ++*cnt;
}

// This function tests sphere fitting
static bool testfitsphereunit_testspherefittingvosswinkel2() {
   ae_frame _frame_block;
   ae_int_t cnt;
   double rlo;
   double rhi;
   double tol;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(cx, 0, DT_REAL);
   hqrndrandomize(&rs);
// Test problem #2 by Vosswinkel GmbH
   ae_matrix_set_length(&xy, 40, 2);
   cnt = 0;
   testfitsphereunit_addvalue(&xy, &cnt, 0.1026);
   testfitsphereunit_addvalue(&xy, &cnt, 0.000036);
   testfitsphereunit_addvalue(&xy, &cnt, 0.101119);
   testfitsphereunit_addvalue(&xy, &cnt, 0.016144);
   testfitsphereunit_addvalue(&xy, &cnt, 0.096754);
   testfitsphereunit_addvalue(&xy, &cnt, 0.031654);
   testfitsphereunit_addvalue(&xy, &cnt, 0.088981);
   testfitsphereunit_addvalue(&xy, &cnt, 0.045634);
   testfitsphereunit_addvalue(&xy, &cnt, 0.082056);
   testfitsphereunit_addvalue(&xy, &cnt, 0.06008);
   testfitsphereunit_addvalue(&xy, &cnt, 0.074966);
   testfitsphereunit_addvalue(&xy, &cnt, 0.075647);
   testfitsphereunit_addvalue(&xy, &cnt, 0.065);
   testfitsphereunit_addvalue(&xy, &cnt, 0.090471);
   testfitsphereunit_addvalue(&xy, &cnt, 0.052411);
   testfitsphereunit_addvalue(&xy, &cnt, 0.104381);
   testfitsphereunit_addvalue(&xy, &cnt, 0.036436);
   testfitsphereunit_addvalue(&xy, &cnt, 0.114859);
   testfitsphereunit_addvalue(&xy, &cnt, 0.019034);
   testfitsphereunit_addvalue(&xy, &cnt, 0.126577);
   testfitsphereunit_addvalue(&xy, &cnt, -0.001191);
   testfitsphereunit_addvalue(&xy, &cnt, 0.139295);
   testfitsphereunit_addvalue(&xy, &cnt, -0.024689);
   testfitsphereunit_addvalue(&xy, &cnt, 0.147143);
   testfitsphereunit_addvalue(&xy, &cnt, -0.049729);
   testfitsphereunit_addvalue(&xy, &cnt, 0.147861);
   testfitsphereunit_addvalue(&xy, &cnt, -0.076402);
   testfitsphereunit_addvalue(&xy, &cnt, 0.145907);
   testfitsphereunit_addvalue(&xy, &cnt, -0.103928);
   testfitsphereunit_addvalue(&xy, &cnt, 0.139553);
   testfitsphereunit_addvalue(&xy, &cnt, -0.133726);
   testfitsphereunit_addvalue(&xy, &cnt, 0.130429);
   testfitsphereunit_addvalue(&xy, &cnt, -0.159051);
   testfitsphereunit_addvalue(&xy, &cnt, 0.112298);
   testfitsphereunit_addvalue(&xy, &cnt, -0.179496);
   testfitsphereunit_addvalue(&xy, &cnt, 0.08821);
   testfitsphereunit_addvalue(&xy, &cnt, -0.194562);
   testfitsphereunit_addvalue(&xy, &cnt, 0.059989);
   testfitsphereunit_addvalue(&xy, &cnt, -0.204838);
   testfitsphereunit_addvalue(&xy, &cnt, 0.029135);
   testfitsphereunit_addvalue(&xy, &cnt, -0.206971);
   testfitsphereunit_addvalue(&xy, &cnt, -0.00349);
   testfitsphereunit_addvalue(&xy, &cnt, -0.206207);
   testfitsphereunit_addvalue(&xy, &cnt, -0.036427);
   testfitsphereunit_addvalue(&xy, &cnt, -0.197079);
   testfitsphereunit_addvalue(&xy, &cnt, -0.06806);
   testfitsphereunit_addvalue(&xy, &cnt, -0.180492);
   testfitsphereunit_addvalue(&xy, &cnt, -0.096353);
   testfitsphereunit_addvalue(&xy, &cnt, -0.158203);
   testfitsphereunit_addvalue(&xy, &cnt, -0.119891);
   testfitsphereunit_addvalue(&xy, &cnt, -0.132669);
   testfitsphereunit_addvalue(&xy, &cnt, -0.138375);
   testfitsphereunit_addvalue(&xy, &cnt, -0.105652);
   testfitsphereunit_addvalue(&xy, &cnt, -0.152229);
   testfitsphereunit_addvalue(&xy, &cnt, -0.078587);
   testfitsphereunit_addvalue(&xy, &cnt, -0.16316);
   testfitsphereunit_addvalue(&xy, &cnt, -0.049984);
   testfitsphereunit_addvalue(&xy, &cnt, -0.167084);
   testfitsphereunit_addvalue(&xy, &cnt, -0.022067);
   testfitsphereunit_addvalue(&xy, &cnt, -0.165233);
   testfitsphereunit_addvalue(&xy, &cnt, 0.004002);
   testfitsphereunit_addvalue(&xy, &cnt, -0.16075);
   testfitsphereunit_addvalue(&xy, &cnt, 0.028058);
   testfitsphereunit_addvalue(&xy, &cnt, -0.151829);
   testfitsphereunit_addvalue(&xy, &cnt, 0.050088);
   testfitsphereunit_addvalue(&xy, &cnt, -0.141178);
   testfitsphereunit_addvalue(&xy, &cnt, 0.067646);
   testfitsphereunit_addvalue(&xy, &cnt, -0.124169);
   testfitsphereunit_addvalue(&xy, &cnt, 0.081421);
   testfitsphereunit_addvalue(&xy, &cnt, -0.10567);
   testfitsphereunit_addvalue(&xy, &cnt, 0.087305);
   testfitsphereunit_addvalue(&xy, &cnt, -0.082618);
   testfitsphereunit_addvalue(&xy, &cnt, 0.094189);
   testfitsphereunit_addvalue(&xy, &cnt, -0.064399);
   testfitsphereunit_addvalue(&xy, &cnt, 0.099445);
   testfitsphereunit_addvalue(&xy, &cnt, -0.047018);
   testfitsphereunit_addvalue(&xy, &cnt, 0.09936);
   testfitsphereunit_addvalue(&xy, &cnt, -0.028981);
   testfitsphereunit_addvalue(&xy, &cnt, 0.101784);
   testfitsphereunit_addvalue(&xy, &cnt, -0.012918);
   tol = 1.0E-7;
// MZ problem, NLC solver
   SetVector(&cx);
   rlo = 0.0;
   rhi = 0.0;
   fitspheremz(&xy, xy.rows, xy.cols, &cx, &rlo, &rhi);
   Ok = Ok && cx.cnt == 2;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && NearAtR(cx.xR[0], -0.050884688, tol);
   Ok = Ok && NearAtR(cx.xR[1], -0.011472328, tol);
   Ok = Ok && NearAtR(rlo, 0.150973382, tol);
   Ok = Ok && NearAtR(rhi, 0.164374709, tol);
   SetVector(&cx);
   rlo = 0.0;
   rhi = 0.0;
   fitspherex(&xy, xy.rows, xy.cols, 3, 0.0, 0, 0.0, &cx, &rlo, &rhi);
   Ok = Ok && cx.cnt == 2;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && NearAtR(cx.xR[0], -0.050884688, tol);
   Ok = Ok && NearAtR(cx.xR[1], -0.011472328, tol);
   Ok = Ok && NearAtR(rlo, 0.150973382, tol);
   Ok = Ok && NearAtR(rhi, 0.164374709, tol);
// MC problem, NLC solver
   SetVector(&cx);
   rlo = 0.0;
   rhi = 0.0;
   fitspheremc(&xy, xy.rows, xy.cols, &cx, &rhi);
   Ok = Ok && cx.cnt == 2;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && NearAtR(cx.xR[0], -0.051137580, tol);
   Ok = Ok && NearAtR(cx.xR[1], -0.011680985, tol);
   Ok = Ok && rlo == 0.0;
   Ok = Ok && NearAtR(rhi, 0.164365735, tol);
   SetVector(&cx);
   rlo = 0.0;
   rhi = 0.0;
   fitspherex(&xy, xy.rows, xy.cols, 1, 0.0, 0, 0.0, &cx, &rlo, &rhi);
   Ok = Ok && cx.cnt == 2;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && NearAtR(cx.xR[0], -0.051137580, tol);
   Ok = Ok && NearAtR(cx.xR[1], -0.011680985, tol);
   Ok = Ok && rlo == 0.0;
   Ok = Ok && NearAtR(rhi, 0.164365735, tol);
// MI problem, NLC solver
   SetVector(&cx);
   rlo = 0.0;
   rhi = 0.0;
   fitspheremi(&xy, xy.rows, xy.cols, &cx, &rlo);
   Ok = Ok && cx.cnt == 2;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && NearAtR(cx.xR[0], -0.054593489, tol);
   Ok = Ok && NearAtR(cx.xR[1], -0.007459466, tol);
   Ok = Ok && NearAtR(rlo, 0.152429205, tol);
   Ok = Ok && rhi == 0.0;
   SetVector(&cx);
   rlo = 0.0;
   rhi = 0.0;
   fitspherex(&xy, xy.rows, xy.cols, 2, 0.0, 0, 0.0, &cx, &rlo, &rhi);
   Ok = Ok && cx.cnt == 2;
   if (!Ok) {
      ae_frame_leave();
      return Ok;
   }
   Ok = Ok && NearAtR(cx.xR[0], -0.054593489, tol);
   Ok = Ok && NearAtR(cx.xR[1], -0.007459466, tol);
   Ok = Ok && NearAtR(rlo, 0.152429205, tol);
   Ok = Ok && rhi == 0.0;
   ae_frame_leave();
   return Ok;
}

bool testfitsphere() {
   bool nsOk;
   bool lsOk;
   bool Ok;
   nsOk = true;
   lsOk = true;
// Sphere fitting, several different test suites
   lsOk = lsOk && testfitsphereunit_testspherefittingls();
   nsOk = nsOk && testfitsphereunit_testspherefittingns();
   nsOk = nsOk && testfitsphereunit_testspherefittingvosswinkel2();
// The final report.
   Ok = nsOk && lsOk;
   if (!Ok || !silent) {
      printf("Testing FitSphere\n");
      printf("* Least Squares Circle Fitting:           %s\n", lsOk? "Ok": "Failed");
      printf("* Non-Smooth Fitting (MC, MI, MZ):        %s\n", nsOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === parametric testing unit ===
// This function tests 4PL/5PL fitting.
static bool testparametricunit_testrdp() {
   ae_frame _frame_block;
   ae_int_t nsections;
   ae_int_t nsections3;
   double eps;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t d;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(e, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(x3, 0, DT_REAL);
   NewVector(y3, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewMatrix(xy3, 0, 0, DT_REAL);
   NewVector(idx2, 0, DT_INT);
   NewVector(idx3, 0, DT_INT);
   NewObj(spline1dinterpolant, s);
   hqrndrandomize(&rs);
// Parametric test 1: non-closed curve
   ae_matrix_set_length(&xy, 4, 2);
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = 0.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[1][1] = 2.0;
   xy.xyR[2][0] = 3.0;
   xy.xyR[2][1] = 1.0;
   xy.xyR[3][0] = 3.0;
   xy.xyR[3][1] = 3.0;
   parametricrdpfixed(&xy, 4, 2, 0, sqrt(2.0) + 0.001, &xy2, &idx2, &nsections);
   Ok = Ok && nsections == 1;
   if (nsections == 1) {
      Ok = Ok && xy2.xyR[0][0] == 0.0;
      Ok = Ok && xy2.xyR[0][1] == 0.0;
      Ok = Ok && idx2.xZ[0] == 0;
      Ok = Ok && xy2.xyR[1][0] == 3.0;
      Ok = Ok && xy2.xyR[1][1] == 3.0;
      Ok = Ok && idx2.xZ[1] == 3;
   }
   parametricrdpfixed(&xy, 4, 2, 0, sqrt(2.0) - 0.001, &xy2, &idx2, &nsections);
   Ok = Ok && nsections == 3;
   if (nsections == 3) {
      Ok = Ok && xy2.xyR[0][0] == 0.0;
      Ok = Ok && xy2.xyR[0][1] == 0.0;
      Ok = Ok && idx2.xZ[0] == 0;
      Ok = Ok && xy2.xyR[1][0] == 1.0;
      Ok = Ok && xy2.xyR[1][1] == 2.0;
      Ok = Ok && idx2.xZ[1] == 1;
      Ok = Ok && xy2.xyR[2][0] == 3.0;
      Ok = Ok && xy2.xyR[2][1] == 1.0;
      Ok = Ok && idx2.xZ[2] == 2;
      Ok = Ok && xy2.xyR[3][0] == 3.0;
      Ok = Ok && xy2.xyR[3][1] == 3.0;
      Ok = Ok && idx2.xZ[3] == 3;
   }
   parametricrdpfixed(&xy, 4, 2, 1, 0.0, &xy2, &idx2, &nsections);
   Ok = Ok && nsections == 1;
   if (nsections == 1) {
      Ok = Ok && xy2.xyR[0][0] == 0.0;
      Ok = Ok && xy2.xyR[0][1] == 0.0;
      Ok = Ok && idx2.xZ[0] == 0;
      Ok = Ok && xy2.xyR[1][0] == 3.0;
      Ok = Ok && xy2.xyR[1][1] == 3.0;
      Ok = Ok && idx2.xZ[1] == 3;
   }
   parametricrdpfixed(&xy, 4, 2, 2, 0.0, &xy2, &idx2, &nsections);
   Ok = Ok && nsections == 2;
   if (nsections == 2) {
      Ok = Ok && xy2.xyR[0][0] == 0.0;
      Ok = Ok && xy2.xyR[0][1] == 0.0;
      Ok = Ok && idx2.xZ[0] == 0;
      Ok = Ok && xy2.xyR[1][0] == 3.0;
      Ok = Ok && xy2.xyR[1][1] == 1.0;
      Ok = Ok && idx2.xZ[1] == 2;
      Ok = Ok && xy2.xyR[2][0] == 3.0;
      Ok = Ok && xy2.xyR[2][1] == 3.0;
      Ok = Ok && idx2.xZ[2] == 3;
   }
   parametricrdpfixed(&xy, 4, 2, 3, 0.0, &xy2, &idx2, &nsections);
   Ok = Ok && nsections == 3;
   if (nsections == 3) {
      Ok = Ok && xy2.xyR[0][0] == 0.0;
      Ok = Ok && xy2.xyR[0][1] == 0.0;
      Ok = Ok && idx2.xZ[0] == 0;
      Ok = Ok && xy2.xyR[1][0] == 1.0;
      Ok = Ok && xy2.xyR[1][1] == 2.0;
      Ok = Ok && idx2.xZ[1] == 1;
      Ok = Ok && xy2.xyR[2][0] == 3.0;
      Ok = Ok && xy2.xyR[2][1] == 1.0;
      Ok = Ok && idx2.xZ[2] == 2;
      Ok = Ok && xy2.xyR[3][0] == 3.0;
      Ok = Ok && xy2.xyR[3][1] == 3.0;
      Ok = Ok && idx2.xZ[3] == 3;
   }
   parametricrdpfixed(&xy, 4, 2, 4, 0.0, &xy2, &idx2, &nsections);
   Ok = Ok && nsections == 3;
   if (nsections == 3) {
      Ok = Ok && xy2.xyR[0][0] == 0.0;
      Ok = Ok && xy2.xyR[0][1] == 0.0;
      Ok = Ok && idx2.xZ[0] == 0;
      Ok = Ok && xy2.xyR[1][0] == 1.0;
      Ok = Ok && xy2.xyR[1][1] == 2.0;
      Ok = Ok && idx2.xZ[1] == 1;
      Ok = Ok && xy2.xyR[2][0] == 3.0;
      Ok = Ok && xy2.xyR[2][1] == 1.0;
      Ok = Ok && idx2.xZ[2] == 2;
      Ok = Ok && xy2.xyR[3][0] == 3.0;
      Ok = Ok && xy2.xyR[3][1] == 3.0;
      Ok = Ok && idx2.xZ[3] == 3;
   }
// Parametric test 2: closed curve
   ae_matrix_set_length(&xy, 5, 2);
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = 0.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[1][1] = 0.0;
   xy.xyR[2][0] = 1.0;
   xy.xyR[2][1] = 1.0;
   xy.xyR[3][0] = 0.0;
   xy.xyR[3][1] = 1.0;
   xy.xyR[4][0] = 0.0;
   xy.xyR[4][1] = 0.0;
   parametricrdpfixed(&xy, 5, 2, 0, sqrt(2.0) + 0.001, &xy2, &idx2, &nsections);
   Ok = Ok && nsections == 1;
   if (nsections == 1) {
      Ok = Ok && xy2.xyR[0][0] == 0.0;
      Ok = Ok && xy2.xyR[0][1] == 0.0;
      Ok = Ok && idx2.xZ[0] == 0;
      Ok = Ok && xy2.xyR[1][0] == 0.0;
      Ok = Ok && xy2.xyR[1][1] == 0.0;
      Ok = Ok && idx2.xZ[1] == 4;
   }
   parametricrdpfixed(&xy, 5, 2, 0, sqrt(2.0) - 0.001, &xy2, &idx2, &nsections);
   Ok = Ok && nsections == 2;
   if (nsections == 2) {
      Ok = Ok && xy2.xyR[0][0] == 0.0;
      Ok = Ok && xy2.xyR[0][1] == 0.0;
      Ok = Ok && idx2.xZ[0] == 0;
      Ok = Ok && xy2.xyR[1][0] == 1.0;
      Ok = Ok && xy2.xyR[1][1] == 1.0;
      Ok = Ok && idx2.xZ[1] == 2;
      Ok = Ok && xy2.xyR[2][0] == 0.0;
      Ok = Ok && xy2.xyR[2][1] == 0.0;
      Ok = Ok && idx2.xZ[2] == 4;
   }
   parametricrdpfixed(&xy, 5, 2, 0, sqrt(2.0) / 2 + 0.001, &xy2, &idx2, &nsections);
   Ok = Ok && nsections == 2;
   if (nsections == 2) {
      Ok = Ok && xy2.xyR[0][0] == 0.0;
      Ok = Ok && xy2.xyR[0][1] == 0.0;
      Ok = Ok && idx2.xZ[0] == 0;
      Ok = Ok && xy2.xyR[1][0] == 1.0;
      Ok = Ok && xy2.xyR[1][1] == 1.0;
      Ok = Ok && idx2.xZ[1] == 2;
      Ok = Ok && xy2.xyR[2][0] == 0.0;
      Ok = Ok && xy2.xyR[2][1] == 0.0;
      Ok = Ok && idx2.xZ[2] == 4;
   }
   parametricrdpfixed(&xy, 5, 2, 0, sqrt(2.0) / 2 - 0.001, &xy2, &idx2, &nsections);
   Ok = Ok && nsections == 4;
   if (nsections == 4) {
      Ok = Ok && xy2.xyR[0][0] == 0.0;
      Ok = Ok && xy2.xyR[0][1] == 0.0;
      Ok = Ok && idx2.xZ[0] == 0;
      Ok = Ok && xy2.xyR[1][0] == 1.0;
      Ok = Ok && xy2.xyR[1][1] == 0.0;
      Ok = Ok && idx2.xZ[1] == 1;
      Ok = Ok && xy2.xyR[2][0] == 1.0;
      Ok = Ok && xy2.xyR[2][1] == 1.0;
      Ok = Ok && idx2.xZ[2] == 2;
      Ok = Ok && xy2.xyR[3][0] == 0.0;
      Ok = Ok && xy2.xyR[3][1] == 1.0;
      Ok = Ok && idx2.xZ[3] == 3;
      Ok = Ok && xy2.xyR[4][0] == 0.0;
      Ok = Ok && xy2.xyR[4][1] == 0.0;
      Ok = Ok && idx2.xZ[4] == 4;
   }
// Parametric, variable precision test (non-fixed), results are compared against fixed-section test
   eps = 10.0;
   n = 100;
   while (eps >= 0.0001) {
   // Try different dimension counts
      for (d = 1; d <= 5; d++) {
      // Generate dataset
         ae_matrix_set_length(&xy, n, d);
         for (i = 0; i < n; i++) {
            v = pi * i / (n - 1);
            for (j = 0; j < d; j++) {
               xy.xyR[i][j] = pow(sin(v), (double)(j + 1)) + 0.005 * hqrndmiduniformr(&rs);
            }
         }
      // Perform run of eps-based RDP algorithm
         parametricrdpfixed(&xy, n, d, 0, eps, &xy2, &idx2, &nsections);
         Ok = Ok && nsections != 0;
         if (nsections == 0) {
            ae_frame_leave();
            return Ok;
         }
      // Check properties
         Ok = Ok && idx2.xZ[0] == 0;
         for (i = 0; i < nsections; i++) {
            Ok = Ok && idx2.xZ[i] < idx2.xZ[i + 1];
         }
         Ok = Ok && idx2.xZ[nsections] == n - 1;
         for (i = 0; i <= nsections; i++) {
            for (j = 0; j < d; j++) {
               Ok = Ok && xy2.xyR[i][j] == xy.xyR[idx2.xZ[i]][j];
            }
         }
         ae_vector_set_length(&x, nsections + 1);
         ae_vector_set_length(&y, nsections + 1);
         ae_vector_set_length(&e, n);
         for (i = 0; i < n; i++) {
            e.xR[i] = 0.0;
         }
         for (j = 0; j < d; j++) {
            for (i = 0; i <= nsections; i++) {
               x.xR[i] = (double)idx2.xZ[i];
               y.xR[i] = xy2.xyR[i][j];
            }
            spline1dbuildlinear(&x, &y, nsections + 1, &s);
            for (i = 0; i < n; i++) {
               e.xR[i] += sqr(spline1dcalc(&s, (double)i) - xy.xyR[i][j]);
            }
         }
         for (i = 0; i < n; i++) {
            Ok = Ok && sqrt(e.xR[i]) <= eps;
         }
      // compare results with values returned by section-based algorithm
         parametricrdpfixed(&xy, n, d, nsections, 0.0, &xy3, &idx3, &nsections3);
         Ok = Ok && nsections3 == nsections;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i <= nsections; i++) {
            Ok = Ok && idx2.xZ[i] == idx3.xZ[i];
            for (j = 0; j < d; j++) {
               Ok = Ok && NearAtR(xy2.xyR[i][j], xy3.xyR[i][j], 1000.0 * machineepsilon);
            }
         }
      }
   // Next epsilon
      eps *= 0.5;
   }
   ae_frame_leave();
   return Ok;
}

// Unset spline, i.e. initialize it with random garbage
static void testparametricunit_unsetp2(pspline2interpolant *p) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   SetObj(pspline2interpolant, p);
   NewMatrix(xy, 0, 0, DT_REAL);
   ae_matrix_set_length(&xy, 2, 2);
   xy.xyR[0][0] = -1.0;
   xy.xyR[0][1] = -1.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[1][1] = 1.0;
   pspline2build(&xy, 2, 1, 0, p);
   ae_frame_leave();
}

// Unset spline, i.e. initialize it with random garbage
static void testparametricunit_unsetp3(pspline3interpolant *p) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   SetObj(pspline3interpolant, p);
   NewMatrix(xy, 0, 0, DT_REAL);
   ae_matrix_set_length(&xy, 2, 3);
   xy.xyR[0][0] = -1.0;
   xy.xyR[0][1] = -1.0;
   xy.xyR[0][2] = -1.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[1][1] = 1.0;
   xy.xyR[1][2] = 1.0;
   pspline3build(&xy, 2, 1, 0, p);
   ae_frame_leave();
}

bool testparametric() {
   ae_frame _frame_block;
   bool Ok;
   bool p2Ok;
   bool p3Ok;
   bool rdpOk;
   double nonstrictthreshold;
   double threshold;
   ae_int_t maxn;
   ae_int_t periodicity;
   ae_int_t skind;
   ae_int_t pkind;
   bool periodic;
   double a;
   double b;
   ae_int_t n;
   ae_int_t tmpn;
   ae_int_t i;
   double vx;
   double vy;
   double vz;
   double vx2;
   double vy2;
   double vz2;
   double vdx;
   double vdy;
   double vdz;
   double vdx2;
   double vdy2;
   double vdz2;
   double vd2x;
   double vd2y;
   double vd2z;
   double vd2x2;
   double vd2y2;
   double vd2z2;
   double v0;
   double v1;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(z, 0, DT_REAL);
   NewVector(t, 0, DT_REAL);
   NewVector(t2, 0, DT_REAL);
   NewVector(t3, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xyz, 0, 0, DT_REAL);
   NewObj(pspline2interpolant, p2);
   NewObj(pspline3interpolant, p3);
   NewObj(spline1dinterpolant, s);
   Ok = true;
   maxn = 10;
   threshold = 10000.0 * machineepsilon;
   nonstrictthreshold = 0.00001;
   p2Ok = true;
   p3Ok = true;
   rdpOk = true;
   rdpOk = rdpOk && testparametricunit_testrdp();
// Test basic properties of 2- and 3-dimensional splines:
// * PSpline2ParameterValues() properties
// * values at nodes
// * for periodic splines - periodicity properties
//
// Variables used:
// * N              points count
// * SKind          spline
// * PKind          parameterization
// * Periodicity    whether we have periodic spline or not
   for (n = 2; n <= maxn; n++) {
      for (skind = 0; skind <= 2; skind++) {
         for (pkind = 0; pkind <= 2; pkind++) {
            for (periodicity = 0; periodicity <= 1; periodicity++) {
               periodic = periodicity == 1;
            // skip unsupported combinations of parameters
               if (periodic && n < 3) {
                  continue;
               }
               if (periodic && skind == 0) {
                  continue;
               }
               if (n < 5 && skind == 0) {
                  continue;
               }
            // init
               ae_matrix_set_length(&xy, n, 2);
               ae_matrix_set_length(&xyz, n, 3);
               taskgenint1dequidist(-1.0, 1.0, n, &t2, &x);
               ae_v_move(xy.xyR[0], xy.stride, x.xR, 1, n);
               ae_v_move(xyz.xyR[0], xyz.stride, x.xR, 1, n);
               taskgenint1dequidist(-1.0, 1.0, n, &t2, &y);
               ae_v_move(&xy.xyR[0][1], xy.stride, y.xR, 1, n);
               ae_v_move(&xyz.xyR[0][1], xyz.stride, y.xR, 1, n);
               taskgenint1dequidist(-1.0, 1.0, n, &t2, &z);
               ae_v_move(&xyz.xyR[0][2], xyz.stride, z.xR, 1, n);
               testparametricunit_unsetp2(&p2);
               testparametricunit_unsetp3(&p3);
               if (periodic) {
                  pspline2buildperiodic(&xy, n, skind, pkind, &p2);
                  pspline3buildperiodic(&xyz, n, skind, pkind, &p3);
               } else {
                  pspline2build(&xy, n, skind, pkind, &p2);
                  pspline3build(&xyz, n, skind, pkind, &p3);
               }
            // PSpline2ParameterValues() properties
               pspline2parametervalues(&p2, &tmpn, &t2);
               if (tmpn != n) {
                  p2Ok = false;
                  continue;
               }
               pspline3parametervalues(&p3, &tmpn, &t3);
               if (tmpn != n) {
                  p3Ok = false;
                  continue;
               }
               p2Ok = p2Ok && t2.xR[0] == 0.0;
               p3Ok = p3Ok && t3.xR[0] == 0.0;
               for (i = 1; i < n; i++) {
                  p2Ok = p2Ok && t2.xR[i] > t2.xR[i - 1];
                  p3Ok = p3Ok && t3.xR[i] > t3.xR[i - 1];
               }
               if (periodic) {
                  p2Ok = p2Ok && t2.xR[n - 1] < 1.0;
                  p3Ok = p3Ok && t3.xR[n - 1] < 1.0;
               } else {
                  p2Ok = p2Ok && t2.xR[n - 1] == 1.0;
                  p3Ok = p3Ok && t3.xR[n - 1] == 1.0;
               }
            // Now we have parameter values stored at T,
            // and want to test whether the actully correspond to
            // points
               for (i = 0; i < n; i++) {
               // 2-dimensional test
                  pspline2calc(&p2, t2.xR[i], &vx, &vy);
                  p2Ok = p2Ok && NearAtR(vx, x.xR[i], threshold);
                  p2Ok = p2Ok && NearAtR(vy, y.xR[i], threshold);
               // 3-dimensional test
                  pspline3calc(&p3, t3.xR[i], &vx, &vy, &vz);
                  p3Ok = p3Ok && NearAtR(vx, x.xR[i], threshold);
                  p3Ok = p3Ok && NearAtR(vy, y.xR[i], threshold);
                  p3Ok = p3Ok && NearAtR(vz, z.xR[i], threshold);
               }
            // Test periodicity (if needed)
               if (periodic) {
               // periodicity at nodes
                  for (i = 0; i < n; i++) {
                  // 2-dimensional test
                     pspline2calc(&p2, t2.xR[i] + randominteger(10) - 5, &vx, &vy);
                     p2Ok = p2Ok && NearAtR(vx, x.xR[i], threshold);
                     p2Ok = p2Ok && NearAtR(vy, y.xR[i], threshold);
                     pspline2diff(&p2, t2.xR[i] + randominteger(10) - 5, &vx, &vdx, &vy, &vdy);
                     p2Ok = p2Ok && NearAtR(vx, x.xR[i], threshold);
                     p2Ok = p2Ok && NearAtR(vy, y.xR[i], threshold);
                     pspline2diff2(&p2, t2.xR[i] + randominteger(10) - 5, &vx, &vdx, &vd2x, &vy, &vdy, &vd2y);
                     p2Ok = p2Ok && NearAtR(vx, x.xR[i], threshold);
                     p2Ok = p2Ok && NearAtR(vy, y.xR[i], threshold);
                  // 3-dimensional test
                     pspline3calc(&p3, t3.xR[i] + randominteger(10) - 5, &vx, &vy, &vz);
                     p3Ok = p3Ok && NearAtR(vx, x.xR[i], threshold);
                     p3Ok = p3Ok && NearAtR(vy, y.xR[i], threshold);
                     p3Ok = p3Ok && NearAtR(vz, z.xR[i], threshold);
                     pspline3diff(&p3, t3.xR[i] + randominteger(10) - 5, &vx, &vdx, &vy, &vdy, &vz, &vdz);
                     p3Ok = p3Ok && NearAtR(vx, x.xR[i], threshold);
                     p3Ok = p3Ok && NearAtR(vy, y.xR[i], threshold);
                     p3Ok = p3Ok && NearAtR(vz, z.xR[i], threshold);
                     pspline3diff2(&p3, t3.xR[i] + randominteger(10) - 5, &vx, &vdx, &vd2x, &vy, &vdy, &vd2y, &vz, &vdz, &vd2z);
                     p3Ok = p3Ok && NearAtR(vx, x.xR[i], threshold);
                     p3Ok = p3Ok && NearAtR(vy, y.xR[i], threshold);
                     p3Ok = p3Ok && NearAtR(vz, z.xR[i], threshold);
                  }
               // periodicity between nodes
                  v0 = randomreal();
                  pspline2calc(&p2, v0, &vx, &vy);
                  pspline2calc(&p2, v0 + randominteger(10) - 5, &vx2, &vy2);
                  p2Ok = p2Ok && NearAtR(vx, vx2, threshold);
                  p2Ok = p2Ok && NearAtR(vy, vy2, threshold);
                  pspline3calc(&p3, v0, &vx, &vy, &vz);
                  pspline3calc(&p3, v0 + randominteger(10) - 5, &vx2, &vy2, &vz2);
                  p3Ok = p3Ok && NearAtR(vx, vx2, threshold);
                  p3Ok = p3Ok && NearAtR(vy, vy2, threshold);
                  p3Ok = p3Ok && NearAtR(vz, vz2, threshold);
               // near-boundary test for continuity of function values and derivatives:
               // 2-dimensional curve
                  ae_assert(skind == 1 || skind == 2, "TEST: unexpected spline type!");
                  v0 = 100.0 * machineepsilon;
                  v1 = 1 - v0;
                  pspline2calc(&p2, v0, &vx, &vy);
                  pspline2calc(&p2, v1, &vx2, &vy2);
                  p2Ok = p2Ok && NearAtR(vx, vx2, threshold);
                  p2Ok = p2Ok && NearAtR(vy, vy2, threshold);
                  pspline2diff(&p2, v0, &vx, &vdx, &vy, &vdy);
                  pspline2diff(&p2, v1, &vx2, &vdx2, &vy2, &vdy2);
                  p2Ok = p2Ok && NearAtR(vx, vx2, threshold);
                  p2Ok = p2Ok && NearAtR(vy, vy2, threshold);
                  p2Ok = p2Ok && NearAtR(vdx, vdx2, nonstrictthreshold);
                  p2Ok = p2Ok && NearAtR(vdy, vdy2, nonstrictthreshold);
                  pspline2diff2(&p2, v0, &vx, &vdx, &vd2x, &vy, &vdy, &vd2y);
                  pspline2diff2(&p2, v1, &vx2, &vdx2, &vd2x2, &vy2, &vdy2, &vd2y2);
                  p2Ok = p2Ok && NearAtR(vx, vx2, threshold);
                  p2Ok = p2Ok && NearAtR(vy, vy2, threshold);
                  p2Ok = p2Ok && NearAtR(vdx, vdx2, nonstrictthreshold);
                  p2Ok = p2Ok && NearAtR(vdy, vdy2, nonstrictthreshold);
                  if (skind == 2) {
                  // second derivative test only for cubic splines
                     p2Ok = p2Ok && NearAtR(vd2x, vd2x2, nonstrictthreshold);
                     p2Ok = p2Ok && NearAtR(vd2y, vd2y2, nonstrictthreshold);
                  }
               // near-boundary test for continuity of function values and derivatives:
               // 3-dimensional curve
                  ae_assert(skind == 1 || skind == 2, "TEST: unexpected spline type!");
                  v0 = 100.0 * machineepsilon;
                  v1 = 1 - v0;
                  pspline3calc(&p3, v0, &vx, &vy, &vz);
                  pspline3calc(&p3, v1, &vx2, &vy2, &vz2);
                  p3Ok = p3Ok && NearAtR(vx, vx2, threshold);
                  p3Ok = p3Ok && NearAtR(vy, vy2, threshold);
                  p3Ok = p3Ok && NearAtR(vz, vz2, threshold);
                  pspline3diff(&p3, v0, &vx, &vdx, &vy, &vdy, &vz, &vdz);
                  pspline3diff(&p3, v1, &vx2, &vdx2, &vy2, &vdy2, &vz2, &vdz2);
                  p3Ok = p3Ok && NearAtR(vx, vx2, threshold);
                  p3Ok = p3Ok && NearAtR(vy, vy2, threshold);
                  p3Ok = p3Ok && NearAtR(vz, vz2, threshold);
                  p3Ok = p3Ok && NearAtR(vdx, vdx2, nonstrictthreshold);
                  p3Ok = p3Ok && NearAtR(vdy, vdy2, nonstrictthreshold);
                  p3Ok = p3Ok && NearAtR(vdz, vdz2, nonstrictthreshold);
                  pspline3diff2(&p3, v0, &vx, &vdx, &vd2x, &vy, &vdy, &vd2y, &vz, &vdz, &vd2z);
                  pspline3diff2(&p3, v1, &vx2, &vdx2, &vd2x2, &vy2, &vdy2, &vd2y2, &vz2, &vdz2, &vd2z2);
                  p3Ok = p3Ok && NearAtR(vx, vx2, threshold);
                  p3Ok = p3Ok && NearAtR(vy, vy2, threshold);
                  p3Ok = p3Ok && NearAtR(vz, vz2, threshold);
                  p3Ok = p3Ok && NearAtR(vdx, vdx2, nonstrictthreshold);
                  p3Ok = p3Ok && NearAtR(vdy, vdy2, nonstrictthreshold);
                  p3Ok = p3Ok && NearAtR(vdz, vdz2, nonstrictthreshold);
                  if (skind == 2) {
                  // second derivative test only for cubic splines
                     p3Ok = p3Ok && NearAtR(vd2x, vd2x2, nonstrictthreshold);
                     p3Ok = p3Ok && NearAtR(vd2y, vd2y2, nonstrictthreshold);
                     p3Ok = p3Ok && NearAtR(vd2z, vd2z2, nonstrictthreshold);
                  }
               }
            }
         }
      }
   }
// Test differentiation, tangents, calculation between nodes.
//
// Because differentiation is done in parameterization/spline/periodicity
// oblivious manner, we don't have to test all possible combinations
// of spline types and parameterizations.
//
// Actually we test special combination with properties which allow us
// to easily solve this problem:
// * 2 (3) variables
// * first variable is sampled from equidistant grid on [0,1]
// * other variables are random
// * uniform parameterization is used
// * periodicity - none
// * spline type - any (we use cubic splines)
// Same problem allows us to test calculation BETWEEN nodes.
   for (n = 2; n <= maxn; n++) {
   // init
      ae_matrix_set_length(&xy, n, 2);
      ae_matrix_set_length(&xyz, n, 3);
      taskgenint1dequidist(0.0, 1.0, n, &t, &x);
      ae_v_move(xy.xyR[0], xy.stride, x.xR, 1, n);
      ae_v_move(xyz.xyR[0], xyz.stride, x.xR, 1, n);
      taskgenint1dequidist(0.0, 1.0, n, &t, &y);
      ae_v_move(&xy.xyR[0][1], xy.stride, y.xR, 1, n);
      ae_v_move(&xyz.xyR[0][1], xyz.stride, y.xR, 1, n);
      taskgenint1dequidist(0.0, 1.0, n, &t, &z);
      ae_v_move(&xyz.xyR[0][2], xyz.stride, z.xR, 1, n);
      testparametricunit_unsetp2(&p2);
      testparametricunit_unsetp3(&p3);
      pspline2build(&xy, n, 2, 0, &p2);
      pspline3build(&xyz, n, 2, 0, &p3);
   // Test 2D/3D spline:
   // * build non-parametric cubic spline from T and X/Y
   // * calculate its value and derivatives at V0
   // * compare with Spline2Calc/Spline2Diff/Spline2Diff2
   // Because of task properties both variants should
   // return same answer.
      v0 = randomreal();
      spline1dbuildcubic(&t, &x, n, 0, 0.0, 0, 0.0, &s);
      spline1ddiff(&s, v0, &vx2, &vdx2, &vd2x2);
      spline1dbuildcubic(&t, &y, n, 0, 0.0, 0, 0.0, &s);
      spline1ddiff(&s, v0, &vy2, &vdy2, &vd2y2);
      spline1dbuildcubic(&t, &z, n, 0, 0.0, 0, 0.0, &s);
      spline1ddiff(&s, v0, &vz2, &vdz2, &vd2z2);
   // 2D test
      pspline2calc(&p2, v0, &vx, &vy);
      p2Ok = p2Ok && NearAtR(vx, vx2, threshold);
      p2Ok = p2Ok && NearAtR(vy, vy2, threshold);
      pspline2diff(&p2, v0, &vx, &vdx, &vy, &vdy);
      p2Ok = p2Ok && NearAtR(vx, vx2, threshold);
      p2Ok = p2Ok && NearAtR(vy, vy2, threshold);
      p2Ok = p2Ok && NearAtR(vdx, vdx2, threshold);
      p2Ok = p2Ok && NearAtR(vdy, vdy2, threshold);
      pspline2diff2(&p2, v0, &vx, &vdx, &vd2x, &vy, &vdy, &vd2y);
      p2Ok = p2Ok && NearAtR(vx, vx2, threshold);
      p2Ok = p2Ok && NearAtR(vy, vy2, threshold);
      p2Ok = p2Ok && NearAtR(vdx, vdx2, threshold);
      p2Ok = p2Ok && NearAtR(vdy, vdy2, threshold);
      p2Ok = p2Ok && NearAtR(vd2x, vd2x2, threshold);
      p2Ok = p2Ok && NearAtR(vd2y, vd2y2, threshold);
   // 3D test
      pspline3calc(&p3, v0, &vx, &vy, &vz);
      p3Ok = p3Ok && NearAtR(vx, vx2, threshold);
      p3Ok = p3Ok && NearAtR(vy, vy2, threshold);
      p3Ok = p3Ok && NearAtR(vz, vz2, threshold);
      pspline3diff(&p3, v0, &vx, &vdx, &vy, &vdy, &vz, &vdz);
      p3Ok = p3Ok && NearAtR(vx, vx2, threshold);
      p3Ok = p3Ok && NearAtR(vy, vy2, threshold);
      p3Ok = p3Ok && NearAtR(vz, vz2, threshold);
      p3Ok = p3Ok && NearAtR(vdx, vdx2, threshold);
      p3Ok = p3Ok && NearAtR(vdy, vdy2, threshold);
      p3Ok = p3Ok && NearAtR(vdz, vdz2, threshold);
      pspline3diff2(&p3, v0, &vx, &vdx, &vd2x, &vy, &vdy, &vd2y, &vz, &vdz, &vd2z);
      p3Ok = p3Ok && NearAtR(vx, vx2, threshold);
      p3Ok = p3Ok && NearAtR(vy, vy2, threshold);
      p3Ok = p3Ok && NearAtR(vz, vz2, threshold);
      p3Ok = p3Ok && NearAtR(vdx, vdx2, threshold);
      p3Ok = p3Ok && NearAtR(vdy, vdy2, threshold);
      p3Ok = p3Ok && NearAtR(vdz, vdz2, threshold);
      p3Ok = p3Ok && NearAtR(vd2x, vd2x2, threshold);
      p3Ok = p3Ok && NearAtR(vd2y, vd2y2, threshold);
      p3Ok = p3Ok && NearAtR(vd2z, vd2z2, threshold);
   // Test tangents for 2D/3D
      pspline2tangent(&p2, v0, &vx, &vy);
      p2Ok = p2Ok && NearAtR(vx, vdx2 / safepythag2(vdx2, vdy2), threshold);
      p2Ok = p2Ok && NearAtR(vy, vdy2 / safepythag2(vdx2, vdy2), threshold);
      pspline3tangent(&p3, v0, &vx, &vy, &vz);
      p3Ok = p3Ok && NearAtR(vx, vdx2 / safepythag3(vdx2, vdy2, vdz2), threshold);
      p3Ok = p3Ok && NearAtR(vy, vdy2 / safepythag3(vdx2, vdy2, vdz2), threshold);
      p3Ok = p3Ok && NearAtR(vz, vdz2 / safepythag3(vdx2, vdy2, vdz2), threshold);
   }
// Arc length test.
//
// Simple problem with easy solution (points on a straight line with
// uniform parameterization).
   for (n = 2; n <= maxn; n++) {
      ae_matrix_set_length(&xy, n, 2);
      ae_matrix_set_length(&xyz, n, 3);
      for (i = 0; i < n; i++) {
         xy.xyR[i][0] = (double)i;
         xy.xyR[i][1] = (double)i;
         xyz.xyR[i][0] = (double)i;
         xyz.xyR[i][1] = (double)i;
         xyz.xyR[i][2] = (double)i;
      }
      pspline2build(&xy, n, 1, 0, &p2);
      pspline3build(&xyz, n, 1, 0, &p3);
      a = randomreal();
      b = randomreal();
      p2Ok = p2Ok && NearAtR(pspline2arclength(&p2, a, b), (b - a) * sqrt(2.0) * (n - 1), nonstrictthreshold);
      p3Ok = p3Ok && NearAtR(pspline3arclength(&p3, a, b), (b - a) * sqrt(3.0) * (n - 1), nonstrictthreshold);
   }
// The final report.
   Ok = p2Ok && p3Ok && rdpOk;
   if (!Ok || !silent) {
      printf("Parametric Spline Interpolation Tests\n");
   // Normal tests
      printf("2D Splines:                               %s\n", p2Ok? "Ok": "Failed");
      printf("3D Splines:                               %s\n", p3Ok? "Ok": "Failed");
      printf("RDP:                                      %s\n", rdpOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
// end
   ae_frame_leave();
   return Ok;
}

// === spline2d testing unit ===
// Numerical differentiation.
static void testspline2dunit_twodnumder(spline2dinterpolant *c, double x, double y, double h, double *f, double *fx, double *fy, double *fxy) {
   *f = 0;
   *fx = 0;
   *fy = 0;
   *fxy = 0;
   *f = spline2dcalc(c, x, y);
   *fx = (spline2dcalc(c, x + h, y) - spline2dcalc(c, x - h, y)) / (2 * h);
   *fy = (spline2dcalc(c, x, y + h) - spline2dcalc(c, x, y - h)) / (2 * h);
   *fxy = (spline2dcalc(c, x + h, y + h) - spline2dcalc(c, x - h, y + h) - spline2dcalc(c, x + h, y - h) + spline2dcalc(c, x - h, y - h)) / sqr(2 * h);
}

// Lipschitz constants for spline itself, first and second derivatives.
static void testspline2dunit_lconst(spline2dinterpolant *c, RVector *lx, RVector *ly, ae_int_t m, ae_int_t n, double lstep, double *lc, double *lcx, double *lcy, double *lcxy) {
   ae_int_t i;
   ae_int_t j;
   double f1;
   double f2;
   double f3;
   double f4;
   double fx1;
   double fx2;
   double fx3;
   double fx4;
   double fy1;
   double fy2;
   double fy3;
   double fy4;
   double fxy1;
   double fxy2;
   double fxy3;
   double fxy4;
   double s2lstep;
   *lc = 0;
   *lcx = 0;
   *lcy = 0;
   *lcxy = 0;
   *lc = 0.0;
   *lcx = 0.0;
   *lcy = 0.0;
   *lcxy = 0.0;
   s2lstep = sqrt(2.0) * lstep;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
      // Calculate
         testspline2dunit_twodnumder(c, lx->xR[j] - lstep / 2, ly->xR[i] - lstep / 2, lstep / 4, &f1, &fx1, &fy1, &fxy1);
         testspline2dunit_twodnumder(c, lx->xR[j] + lstep / 2, ly->xR[i] - lstep / 2, lstep / 4, &f2, &fx2, &fy2, &fxy2);
         testspline2dunit_twodnumder(c, lx->xR[j] + lstep / 2, ly->xR[i] + lstep / 2, lstep / 4, &f3, &fx3, &fy3, &fxy3);
         testspline2dunit_twodnumder(c, lx->xR[j] - lstep / 2, ly->xR[i] + lstep / 2, lstep / 4, &f4, &fx4, &fy4, &fxy4);
      // Lipschitz constant for the function itself
         *lc = rmax2(*lc, fabs((f1 - f2) / lstep));
         *lc = rmax2(*lc, fabs((f2 - f3) / lstep));
         *lc = rmax2(*lc, fabs((f3 - f4) / lstep));
         *lc = rmax2(*lc, fabs((f4 - f1) / lstep));
         *lc = rmax2(*lc, fabs((f1 - f3) / s2lstep));
         *lc = rmax2(*lc, fabs((f2 - f4) / s2lstep));
      // Lipschitz constant for the first derivative
         *lcx = rmax2(*lcx, fabs((fx1 - fx2) / lstep));
         *lcx = rmax2(*lcx, fabs((fx2 - fx3) / lstep));
         *lcx = rmax2(*lcx, fabs((fx3 - fx4) / lstep));
         *lcx = rmax2(*lcx, fabs((fx4 - fx1) / lstep));
         *lcx = rmax2(*lcx, fabs((fx1 - fx3) / s2lstep));
         *lcx = rmax2(*lcx, fabs((fx2 - fx4) / s2lstep));
      // Lipschitz constant for the first derivative
         *lcy = rmax2(*lcy, fabs((fy1 - fy2) / lstep));
         *lcy = rmax2(*lcy, fabs((fy2 - fy3) / lstep));
         *lcy = rmax2(*lcy, fabs((fy3 - fy4) / lstep));
         *lcy = rmax2(*lcy, fabs((fy4 - fy1) / lstep));
         *lcy = rmax2(*lcy, fabs((fy1 - fy3) / s2lstep));
         *lcy = rmax2(*lcy, fabs((fy2 - fy4) / s2lstep));
      // Lipschitz constant for the cross-derivative
         *lcxy = rmax2(*lcxy, fabs((fxy1 - fxy2) / lstep));
         *lcxy = rmax2(*lcxy, fabs((fxy2 - fxy3) / lstep));
         *lcxy = rmax2(*lcxy, fabs((fxy3 - fxy4) / lstep));
         *lcxy = rmax2(*lcxy, fabs((fxy4 - fxy1) / lstep));
         *lcxy = rmax2(*lcxy, fabs((fxy1 - fxy3) / s2lstep));
         *lcxy = rmax2(*lcxy, fabs((fxy2 - fxy4) / s2lstep));
      }
   }
}

// Unpack test
static bool testspline2dunit_testunpack(spline2dinterpolant *c, RVector *lx, RVector *ly) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t m;
   ae_int_t ci;
   ae_int_t cj;
   ae_int_t p;
   double err;
   double tx;
   double ty;
   double v1;
   double v2;
   ae_int_t pass;
   ae_int_t passcount;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(tbl, 0, 0, DT_REAL);
   passcount = 20;
   err = 0.0;
   spline2dunpack(c, &m, &n, &tbl);
   for (i = 0; i < m - 1; i++) {
      for (j = 0; j < n - 1; j++) {
         for (pass = 1; pass <= passcount; pass++) {
            p = (n - 1) * i + j;
            tx = (0.001 + 0.999 * randomreal()) * (tbl.xyR[p][1] - tbl.xyR[p][0]);
            ty = (0.001 + 0.999 * randomreal()) * (tbl.xyR[p][3] - tbl.xyR[p][2]);
         // Interpolation properties
            v1 = 0.0;
            for (ci = 0; ci <= 3; ci++) {
               for (cj = 0; cj <= 3; cj++) {
                  v1 += tbl.xyR[p][4 + ci * 4 + cj] * pow(tx, (double)ci) * pow(ty, (double)cj);
               }
            }
            v2 = spline2dcalc(c, tbl.xyR[p][0] + tx, tbl.xyR[p][2] + ty);
            err = rmax2(err, fabs(v1 - v2));
         // Grid correctness
            err = rmax2(err, fabs(lx->xR[2 * j] - tbl.xyR[p][0]));
            err = rmax2(err, fabs(lx->xR[2 * (j + 1)] - tbl.xyR[p][1]));
            err = rmax2(err, fabs(ly->xR[2 * i] - tbl.xyR[p][2]));
            err = rmax2(err, fabs(ly->xR[2 * (i + 1)] - tbl.xyR[p][3]));
         }
      }
   }
   Ok = err < 10000.0 * machineepsilon;
   ae_frame_leave();
   return Ok;
}

// LinTrans test for scalar
static bool testspline2dunit_testlintrans(spline2dinterpolant *c, ae_int_t d, double ax, double bx, double ay, double by) {
   ae_frame _frame_block;
   double err;
   double a1;
   double a2;
   double b1;
   double b2;
   double tx;
   double ty;
   double vx;
   double vy;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t xjob;
   ae_int_t yjob;
   ae_int_t di;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(v1, 0, DT_REAL);
   NewVector(v2, 0, DT_REAL);
   NewObj(spline2dinterpolant, c2);
   passcount = 5;
   err = 0.0;
   for (xjob = 0; xjob <= 1; xjob++) {
      for (yjob = 0; yjob <= 1; yjob++) {
         for (pass = 1; pass <= passcount; pass++) {
         // Prepare
            do {
               a1 = randommid();
            } while (a1 == 0.0);
            a1 *= xjob;
            b1 = randommid();
            do {
               a2 = randommid();
            } while (a2 == 0.0);
            a2 *= yjob;
            b2 = randommid();
         // Test XY
            spline2dcopy(c, &c2);
            spline2dlintransxy(&c2, a1, b1, a2, b2);
            tx = ax + randomreal() * (bx - ax);
            ty = ay + randomreal() * (by - ay);
            if (xjob == 0) {
               tx = b1;
               vx = ax + randomreal() * (bx - ax);
            } else {
               vx = (tx - b1) / a1;
            }
            if (yjob == 0) {
               ty = b2;
               vy = ay + randomreal() * (by - ay);
            } else {
               vy = (ty - b2) / a2;
            }
            spline2dcalcv(c, tx, ty, &v1);
            spline2dcalcv(&c2, vx, vy, &v2);
            for (di = 0; di < d; di++) {
               err = rmax2(err, fabs(v1.xR[di] - v2.xR[di]));
            }
         // Test F
            spline2dcopy(c, &c2);
            spline2dlintransf(&c2, a1, b1);
            tx = ax + randomreal() * (bx - ax);
            ty = ay + randomreal() * (by - ay);
            spline2dcalcv(c, tx, ty, &v1);
            spline2dcalcv(&c2, tx, ty, &v2);
            for (di = 0; di < d; di++) {
               err = rmax2(err, fabs(a1 * v1.xR[di] + b1 - v2.xR[di]));
            }
         }
      }
   }
   Ok = err < 10000.0 * machineepsilon;
   ae_frame_leave();
   return Ok;
}

// Unset spline, i.e. initialize it with random garbage
static void testspline2dunit_unsetspline2d(spline2dinterpolant *c) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   SetObj(spline2dinterpolant, c);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(f, 0, 0, DT_REAL);
   ae_vector_set_length(&x, 2);
   ae_vector_set_length(&y, 2);
   ae_matrix_set_length(&f, 2, 2);
   x.xR[0] = -1.0;
   x.xR[1] = 1.0;
   y.xR[0] = -1.0;
   y.xR[1] = 1.0;
   f.xyR[0][0] = 0.0;
   f.xyR[0][1] = 0.0;
   f.xyR[1][0] = 0.0;
   f.xyR[1][1] = 0.0;
   spline2dbuildbilinear(&x, &y, &f, 2, 2, c);
   ae_frame_leave();
}

// The function check, that follow functions works correctly:
//     Spline2DBilinearV, Spline2DBicubicV, Spline2DCalcV, Spline2DCalcVI,
//     Spline2DDiffVI and Spline2DUnpackV.
static bool testspline2dunit_testspline2dvf() {
   ae_frame _frame_block;
   double range;
   double rndx;
   double rndy;
   double resef;
   ae_int_t m;
   ae_int_t n;
   ae_int_t d;
   ae_int_t tstn;
   ae_int_t tstm;
   ae_int_t tstd;
   double eps;
   double st;
   ae_int_t p0;
   ae_int_t p1;
   ae_int_t variant;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t i0;
   ae_int_t j0;
   double xmin;
   double xmax;
   double ymin;
   double ymax;
   double vi;
   double vxi;
   double vyi;
   double vxyi;
   double si;
   double sxi;
   double syi;
   double sxyi;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(spline2dinterpolant, vc);
   NewObj(spline2dinterpolant, sc);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(f, 0, DT_REAL);
   NewVector(resf, 0, DT_REAL);
   NewMatrix(ef, 0, 0, DT_REAL);
   NewMatrix(tsttbl0, 0, 0, DT_REAL);
   NewMatrix(tsttbl1, 0, 0, DT_REAL);
   eps = 10000.0 * machineepsilon;
   st = 0.1;
   passcount = 5;
   Ok = true;
   for (pass = 1; pass <= passcount; pass++) {
      for (variant = 1; variant <= 2; variant++) {
         range = (double)(randominteger(71) + 30);
         m = randominteger(4) + 2;
         n = randominteger(4) + 2;
         d = randominteger(3) + 1;
         vectorsetlengthatleast(&x, n);
         vectorsetlengthatleast(&y, m);
         vectorsetlengthatleast(&f, n * m * d);
         matrixsetlengthatleast(&ef, m, n);
      // Build a grid for spline
         x.xR[0] = range * randommid();
         y.xR[0] = range * randommid();
         for (i = 1; i < n; i++) {
            x.xR[i] = x.xR[i - 1] + st + randomreal();
         }
         for (i = 1; i < m; i++) {
            y.xR[i] = y.xR[i - 1] + st + randomreal();
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
               for (k = 0; k < d; k++) {
                  f.xR[d * (n * j + i) + k] = range * randommid();
               }
            }
         }
         xmin = x.xR[0];
         xmax = x.xR[n - 1];
         ymin = y.xR[0];
         ymax = y.xR[m - 1];
      // Build a spline
         if (variant == 1) {
            spline2dbuildbilinearv(&x, n, &y, m, &f, d, &vc);
         }
         if (variant == 2) {
            spline2dbuildbicubicv(&x, n, &y, m, &f, d, &vc);
         }
      // Part of test, which shows that Spline2DBuildBilinearV function
      // works correctly.
      // And there is test for Spline2DUnpackV.
         spline2dunpackv(&vc, &tstm, &tstn, &tstd, &tsttbl1);
         if (tstm != m || tstn != n || tstd != d) {
            if (!silent) {
               printf("TestSpline2DVF: Failed\n");
               printf("* Spline2DUnpack: TstM = %0d, M = %0d, TstN = %0d, N = %0d, TstD = %0d, D = %0d\n", (int)tstm, (int)m, (int)tstn, (int)n, (int)tstd, (int)d);
            }
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (k = 0; k < d; k++) {
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  ef.xyR[i][j] = f.xR[d * (i * n + j) + k];
               }
            }
            if (variant == 1) {
               spline2dbuildbilinear(&x, &y, &ef, m, n, &sc);
            }
            if (variant == 2) {
               spline2dbuildbicubic(&x, &y, &ef, m, n, &sc);
            }
            spline2dunpack(&sc, &tstm, &tstn, &tsttbl0);
            if (tstm != m || tstn != n) {
               if (!silent) {
                  printf("TestSpline2DVF: Failed\n");
                  printf("* Spline2DUnpack: TstM = %0d, M = %0d, TstN = %0d, N = %0d\n", (int)tstm, (int)m, (int)tstn, (int)n);
               }
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < m - 1; i++) {
               for (j = 0; j < n - 1; j++) {
                  p0 = i * (n - 1) + j;
                  p1 = d * p0;
                  for (i0 = 0; i0 <= 19; i0++) {
                     if (tsttbl1.xyR[p1 + k][i0] != tsttbl0.xyR[p0][i0]) {
                        if (!silent) {
                           printf("TestSpline2DVF: Failed\n");
                           printf("* Tbl error\n");
                        }
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  }
               }
            }
         }
      // Part of test, which shows that functions Spline2DCalcVBuf, Spline2DDiffVI,
      // Spline2DCalcVI and Spline2DCalcV work correctly
         for (k = 0; k < d; k++) {
         // Build 1D spline corresponding to selected dimension (already tested)
            for (i0 = 0; i0 < m; i0++) {
               for (j0 = 0; j0 < n; j0++) {
                  ef.xyR[i0][j0] = f.xR[d * (i0 * n + j0) + k];
               }
            }
            if (variant == 1) {
               spline2dbuildbilinear(&x, &y, &ef, m, n, &sc);
            }
            if (variant == 2) {
               spline2dbuildbicubic(&x, &y, &ef, m, n, &sc);
            }
         // test at grid points
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
               // Test calculation at grid points
                  spline2dcalcv(&vc, x.xR[i], y.xR[j], &resf);
                  resef = spline2dcalc(&sc, x.xR[i], y.xR[j]);
                  Ok = Ok && NearAtR(resf.xR[k], resef, eps);
                  Ok = Ok && NearAtR(spline2dcalcvi(&vc, x.xR[i], y.xR[j], k), resef, eps);
               // Test differentiation at grid points
                  spline2ddiffvi(&vc, x.xR[i], y.xR[j], k, &vi, &vxi, &vyi, &vxyi);
                  spline2ddiff(&sc, x.xR[i], y.xR[j], &si, &sxi, &syi, &sxyi);
                  Ok = Ok && NearAtR(vi, si, eps * (fabs(si) + 1));
                  Ok = Ok && NearAtR(vxi, sxi, eps * (fabs(sxi) + 1));
                  Ok = Ok && NearAtR(vyi, syi, eps * (fabs(syi) + 1));
                  Ok = Ok && NearAtR(vxyi, sxyi, eps * (fabs(sxyi) + 1));
               }
            }
         // Test at random points
            for (i = 0; i < n * m; i++) {
               rndx = xmin + (xmax - xmin) * randomreal();
               rndy = ymin + (ymax - ymin) * randomreal();
            // Test calculation at random points
               spline2dcalcv(&vc, rndx, rndy, &resf);
               resef = spline2dcalc(&sc, rndx, rndy);
               Ok = Ok && NearAtR(resf.xR[k], resef, eps);
               Ok = Ok && NearAtR(spline2dcalcvi(&vc, rndx, rndy, k), resef, eps);
            // Test differentiation at random points
               spline2ddiffvi(&vc, rndx, rndy, k, &vi, &vxi, &vyi, &vxyi);
               spline2ddiff(&sc, rndx, rndy, &si, &sxi, &syi, &sxyi);
               Ok = Ok && NearAtR(vi, si, eps * (fabs(si) + 1));
               Ok = Ok && NearAtR(vxi, sxi, eps * (fabs(sxi) + 1));
               Ok = Ok && NearAtR(vyi, syi, eps * (fabs(syi) + 1));
               Ok = Ok && NearAtR(vxyi, sxyi, eps * (fabs(sxyi) + 1));
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Fitting, properties of linear prior term
static bool testspline2dunit_testfittingprior() {
   ae_frame _frame_block;
   ae_int_t d;
   ae_int_t kidx;
   ae_int_t areatype;
   ae_int_t solvertype;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double tol;
   ae_int_t kx;
   ae_int_t ky;
   ae_int_t npoints;
   double vprior;
   double v;
   bool bad;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(kv, 0, DT_INT);
   NewObj(hqrndstate, rs);
   NewObj(spline2dbuilder, state);
   NewObj(spline2dinterpolant, s);
   NewObj(spline2dinterpolant, s2);
   NewObj(spline2dinterpolant, s3);
   NewObj(spline2dfitreport, rep);
   NewObj(spline2dfitreport, rep2);
   NewObj(spline2dfitreport, rep3);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewMatrix(xy3, 0, 0, DT_REAL);
   NewMatrix(vterm, 0, 0, DT_REAL);
   NewVector(meany, 0, DT_REAL);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(tmp1, 0, DT_REAL);
   hqrndrandomize(&rs);
   tol = 1.0E-5;
// Check properties of underlying linear prior.
   ae_vector_set_length(&kv, 3);
   kv.xZ[0] = 5;
   kv.xZ[1] = 10;
   kv.xZ[2] = 16;
   for (kidx = 0; kidx < kv.cnt; kidx++) {
      for (d = 1; d <= 3; d++) {
         for (areatype = 0; areatype <= 0; areatype++) {
            for (solvertype = 1; solvertype <= 2; solvertype++) {
            // Select grid size and create builder
               kx = 1 + hqrnduniformi(&rs, kv.xZ[kidx]);
               ky = 1 + hqrnduniformi(&rs, kv.xZ[kidx]);
               if (hqrndnormal(&rs) > 0.0) {
                  kx = kv.xZ[kidx];
               } else {
                  ky = kv.xZ[kidx];
               }
               spline2dbuildercreate(d, &state);
               spline2dbuildersetgrid(&state, kx, ky);
               if (solvertype == 1) {
                  spline2dbuildersetalgoblocklls(&state, 0.0);
               } else {
                  if (solvertype == 2) {
                     spline2dbuildersetalgonaivells(&state, 0.0);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            // Generate perfectly linear dataset, check against linear prior.
            // At least 8 points is required to get stable results.
            //
            // NOTE: we also check that constant term does NOT work.
               ae_matrix_set_length(&vterm, d, 3);
               for (i = 0; i < d; i++) {
                  for (j = 0; j <= 2; j++) {
                     vterm.xyR[i][j] = hqrndnormal(&rs);
                  }
               }
               npoints = 8 + iround(10.0 * hqrnduniformr(&rs));
               ae_vector_set_length(&meany, d);
               for (j = 0; j < d; j++) {
                  meany.xR[j] = 0.0;
               }
               ae_matrix_set_length(&xy, npoints, 2 + d);
               for (i = 0; i < npoints; i++) {
                  xy.xyR[i][0] = hqrnduniformr(&rs);
                  xy.xyR[i][1] = hqrnduniformr(&rs);
                  for (j = 0; j < d; j++) {
                     xy.xyR[i][2 + j] = vterm.xyR[j][0] * xy.xyR[i][0] + vterm.xyR[j][1] * xy.xyR[i][1] + vterm.xyR[j][2];
                     meany.xR[j] += xy.xyR[i][2 + j] / npoints;
                  }
               }
               spline2dbuildersetpoints(&state, &xy, npoints);
               spline2dbuildersetlinterm(&state);
               spline2dfit(&state, &s, &rep);
               ae_vector_set_length(&tmp0, 3);
               for (k = 0; k <= 10; k++) {
                  tmp0.xR[0] = 3.0 * hqrnduniformr(&rs) - 1.0;
                  tmp0.xR[1] = 3.0 * hqrnduniformr(&rs) - 1.0;
                  tmp0.xR[2] = 1.0;
                  spline2dcalcv(&s, tmp0.xR[0], tmp0.xR[1], &tmp1);
                  for (j = 0; j < d; j++) {
                     v = vterm.xyR[j][0] * tmp0.xR[0] + vterm.xyR[j][1] * tmp0.xR[1] + vterm.xyR[j][2];
                     Ok = Ok && NearAtR(tmp1.xR[j], v, rmax2(fabs(v), 1.0) * tol);
                  }
               }
               Ok = Ok && rep.rmserror <= tol;
               Ok = Ok && rep.avgerror <= tol;
               Ok = Ok && rep.maxerror <= tol;
               spline2dbuildersetconstterm(&state);
               spline2dfit(&state, &s, &rep);
               ae_vector_set_length(&tmp0, 3);
               bad = false;
               for (k = 0; k <= 10; k++) {
                  tmp0.xR[0] = 2.0 + hqrnduniformr(&rs);
                  tmp0.xR[1] = 2.0 + hqrnduniformr(&rs);
                  tmp0.xR[2] = 1.0;
                  spline2dcalcv(&s, tmp0.xR[0], tmp0.xR[1], &tmp1);
                  for (j = 0; j < d; j++) {
                     v = vterm.xyR[j][0] * tmp0.xR[0] + vterm.xyR[j][1] * tmp0.xR[1] + vterm.xyR[j][2];
                     bad = bad || !NearAtR(tmp1.xR[j], v, tol);
                  }
               }
               Ok = Ok && bad;
            // Generate perfectly constant dataset, check against constant prior.
            // At least 8 points is required to get stable results.
               ae_matrix_set_length(&vterm, d, 3);
               for (i = 0; i < d; i++) {
                  for (j = 0; j <= 1; j++) {
                     vterm.xyR[i][j] = 0.0;
                  }
                  vterm.xyR[i][2] = hqrndnormal(&rs);
               }
               npoints = 8 + iround(10.0 * hqrnduniformr(&rs));
               ae_vector_set_length(&meany, d);
               for (j = 0; j < d; j++) {
                  meany.xR[j] = 0.0;
               }
               ae_matrix_set_length(&xy, npoints, 2 + d);
               for (i = 0; i < npoints; i++) {
                  xy.xyR[i][0] = hqrnduniformr(&rs);
                  xy.xyR[i][1] = hqrnduniformr(&rs);
                  for (j = 0; j < d; j++) {
                     xy.xyR[i][2 + j] = vterm.xyR[j][0] * xy.xyR[i][0] + vterm.xyR[j][1] * xy.xyR[i][1] + vterm.xyR[j][2];
                     meany.xR[j] += xy.xyR[i][2 + j] / npoints;
                  }
               }
               spline2dbuildersetpoints(&state, &xy, npoints);
               spline2dbuildersetconstterm(&state);
               spline2dfit(&state, &s, &rep);
               ae_vector_set_length(&tmp0, 3);
               for (k = 0; k <= 10; k++) {
                  tmp0.xR[0] = 3.0 * hqrnduniformr(&rs) - 1.0;
                  tmp0.xR[1] = 3.0 * hqrnduniformr(&rs) - 1.0;
                  tmp0.xR[2] = 1.0;
                  spline2dcalcv(&s, tmp0.xR[0], tmp0.xR[1], &tmp1);
                  for (j = 0; j < d; j++) {
                     v = vterm.xyR[j][0] * tmp0.xR[0] + vterm.xyR[j][1] * tmp0.xR[1] + vterm.xyR[j][2];
                     Ok = Ok && NearAtR(tmp1.xR[j], v, rmax2(fabs(v), 1.0) * tol);
                  }
               }
               Ok = Ok && rep.rmserror <= tol;
               Ok = Ok && rep.avgerror <= tol;
               Ok = Ok && rep.maxerror <= tol;
            // Generate perfectly constant dataset, check against user-defined constant prior.
            // At least 8 points is required to get stable results.
               vprior = hqrndnormal(&rs);
               npoints = 8 + iround(10.0 * hqrnduniformr(&rs));
               ae_vector_set_length(&meany, d);
               for (j = 0; j < d; j++) {
                  meany.xR[j] = 0.0;
               }
               ae_matrix_set_length(&xy, npoints, 2 + d);
               for (i = 0; i < npoints; i++) {
                  xy.xyR[i][0] = hqrnduniformr(&rs);
                  xy.xyR[i][1] = hqrnduniformr(&rs);
                  for (j = 0; j < d; j++) {
                     xy.xyR[i][2 + j] = vprior;
                     meany.xR[j] += xy.xyR[i][2 + j] / npoints;
                  }
               }
               spline2dbuildersetpoints(&state, &xy, npoints);
               spline2dbuildersetuserterm(&state, vprior);
               spline2dfit(&state, &s, &rep);
               ae_vector_set_length(&tmp0, 3);
               for (k = 0; k <= 10; k++) {
                  tmp0.xR[0] = 3.0 * hqrnduniformr(&rs) - 1.0;
                  tmp0.xR[1] = 3.0 * hqrnduniformr(&rs) - 1.0;
                  tmp0.xR[2] = 1.0;
                  spline2dcalcv(&s, tmp0.xR[0], tmp0.xR[1], &tmp1);
                  for (j = 0; j < d; j++) {
                     Ok = Ok && NearAtR(tmp1.xR[j], vprior, tol);
                  }
               }
               Ok = Ok && rep.rmserror <= tol;
               Ok = Ok && rep.avgerror <= tol;
               Ok = Ok && rep.maxerror <= tol;
               spline2dbuildersetuserterm(&state, vprior + (2 * hqrnduniformi(&rs, 2) - 1));
               spline2dfit(&state, &s, &rep);
               ae_vector_set_length(&tmp0, 3);
               for (k = 0; k <= 10; k++) {
                  tmp0.xR[0] = 2.0 + hqrnduniformr(&rs);
                  tmp0.xR[1] = 2.0 + hqrnduniformr(&rs);
                  tmp0.xR[2] = 1.0;
                  spline2dcalcv(&s, tmp0.xR[0], tmp0.xR[1], &tmp1);
                  for (j = 0; j < d; j++) {
                     Ok = Ok && !NearAtR(tmp1.xR[j], vprior, tol);
                  }
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Nonlinearity penalty test
static bool testspline2dunit_testfittingpenalty() {
   ae_frame _frame_block;
   ae_int_t kidx;
   ae_int_t pidx;
   ae_int_t solvertype;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t d;
   ae_int_t kx;
   ae_int_t ky;
   ae_int_t npoints;
   double rmserror;
   double v;
   double v0;
   double v1;
   double f0;
   double f1;
   double f2;
   double f3;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(spline2dinterpolant, s);
   NewObj(spline2dinterpolant, s2);
   NewObj(spline2dfitreport, rep);
   NewObj(spline2dfitreport, rep2);
   NewObj(hqrndstate, rs);
   NewObj(spline2dbuilder, state);
   NewVector(penalty, 0, DT_REAL);
   NewVector(penalty2, 0, DT_REAL);
   hqrndrandomize(&rs);
// Penalized fitting problem:
// * square KxK grid, K >= 8 (points do not "touch" each other by their far fields)
// * four points in the corners, perfectly linear value
// * zero prior term
//
// Check that:
// * with significant nonlinearity penalty we have nearly-linear fit,
//   central value is an average of corner values
// * without nonlinearity penalty, central value is zero
   for (kidx = 3; kidx <= 4; kidx++) {
      for (solvertype = 1; solvertype <= 2; solvertype++) {
      // Generate dataset
         kx = iround(pow(2.0, (double)kidx));
         ky = kx;
         npoints = 4;
         ae_matrix_set_length(&xy, npoints, 3);
         xy.xyR[0][0] = -1.0;
         xy.xyR[0][1] = -1.0;
         xy.xyR[0][2] = hqrndnormal(&rs);
         xy.xyR[1][0] = 1.0;
         xy.xyR[1][1] = -1.0;
         xy.xyR[1][2] = hqrndnormal(&rs);
         xy.xyR[2][0] = -1.0;
         xy.xyR[2][1] = 1.0;
         xy.xyR[2][2] = hqrndnormal(&rs);
         xy.xyR[3][0] = 1.0;
         xy.xyR[3][1] = 1.0;
         xy.xyR[3][2] = xy.xyR[0][2] + (xy.xyR[1][2] - xy.xyR[0][2]) + (xy.xyR[2][2] - xy.xyR[0][2]);
      // Create solver, set grid, area and other properties
      // according to chosen test mode.
         spline2dbuildercreate(1, &state);
         spline2dbuildersetgrid(&state, kx, ky);
         spline2dbuildersetarea(&state, -1.0, 1.0, -1.0, 1.0);
         spline2dbuildersetpoints(&state, &xy, npoints);
         spline2dbuildersetzeroterm(&state);
      // Check fitting with penalty
         if (solvertype == 1) {
            spline2dbuildersetalgoblocklls(&state, 1.0);
         } else {
            if (solvertype == 2) {
               spline2dbuildersetalgonaivells(&state, 1.0);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
         spline2dfit(&state, &s, &rep);
         Ok = Ok && NearAtR(spline2dcalc(&s, 0.0, 0.0), 0.25 * (xy.xyR[0][2] + xy.xyR[1][2] + xy.xyR[2][2] + xy.xyR[3][2]), 1.0E-4);
      // Check fitting without penalty
         if (solvertype == 1) {
            spline2dbuildersetalgoblocklls(&state, 0.0);
         } else {
            if (solvertype == 2) {
               spline2dbuildersetalgonaivells(&state, 0.0);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
         spline2dfit(&state, &s2, &rep2);
         Ok = Ok && SmallAtR(spline2dcalc(&s2, 0.0, 0.0), 1.0E-4);
      }
   }
// Solve a sequence of problems with increasing value of penalty coefficient;
// test that increasing penalty coefficient results in:
// * increased residuals
// * decreased value of penalty function
   for (solvertype = 1; solvertype <= 2; solvertype++) {
      for (d = 1; d <= 3; d++) {
      // Prepare solver and dataset
         kx = 6 + hqrnduniformi(&rs, 5);
         ky = 6 + hqrnduniformi(&rs, 5);
         npoints = 3 * (kx + 2) * (ky + 2) + 30;
         ae_matrix_set_length(&xy, npoints, 2 + d);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = hqrnduniformr(&rs);
            xy.xyR[i][1] = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
            }
         }
         spline2dbuildercreate(d, &state);
         spline2dbuildersetgrid(&state, kx, ky);
         if (solvertype == 1) {
            spline2dbuildersetalgoblocklls(&state, 0.0);
         } else {
            if (solvertype == 2) {
               spline2dbuildersetalgonaivells(&state, 0.0);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
         spline2dbuildersetarea(&state, 0.0, 1.0, 0.0, 1.0);
         spline2dbuildersetpoints(&state, &xy, npoints);
         spline2dbuildersetzeroterm(&state);
      // Solve with zero penalty
         spline2dfit(&state, &s, &rep);
         rmserror = rep.rmserror;
         ae_vector_set_length(&penalty, d);
         for (k = 0; k < d; k++) {
            penalty.xR[k] = 0.0;
         }
         v = 1.0E-3;
         for (i = 0; i < kx; i++) {
            for (j = 0; j < ky; j++) {
               v0 = (double)i / (kx - 1);
               v1 = (double)j / (ky - 1);
               for (k = 0; k < d; k++) {
                  f0 = spline2dcalcvi(&s, v0 - v, v1, k);
                  f1 = spline2dcalcvi(&s, v0, v1, k);
                  f2 = spline2dcalcvi(&s, v0 + v, v1, k);
                  penalty.xR[k] += sqr((f0 + f2 - 2 * f1) / sqr(v));
               }
               for (k = 0; k < d; k++) {
                  f0 = spline2dcalcvi(&s, v0, v1 - v, k);
                  f1 = spline2dcalcvi(&s, v0, v1, k);
                  f2 = spline2dcalcvi(&s, v0, v1 + v, k);
                  penalty.xR[k] += sqr((f0 + f2 - 2 * f1) / sqr(v));
               }
               for (k = 0; k < d; k++) {
                  f0 = spline2dcalcvi(&s, v0 - v, v1 - v, k);
                  f1 = spline2dcalcvi(&s, v0 + v, v1 - v, k);
                  f2 = spline2dcalcvi(&s, v0 - v, v1 + v, k);
                  f3 = spline2dcalcvi(&s, v0 + v, v1 + v, k);
                  penalty.xR[k] += 2 * sqr((f3 - f2 - f1 + f0) / sqr(v));
               }
            }
         }
      // Solve with non-zero penalty
         for (pidx = -6; pidx <= 3; pidx++) {
            if (solvertype == 1) {
               spline2dbuildersetalgoblocklls(&state, pow(10.0, (double)pidx / 2.0));
            } else {
               if (solvertype == 2) {
                  spline2dbuildersetalgonaivells(&state, pow(10.0, (double)pidx / 2.0));
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
            spline2dfit(&state, &s, &rep);
            ae_vector_set_length(&penalty2, d);
            for (k = 0; k < d; k++) {
               penalty2.xR[k] = 0.0;
            }
            v = 1.0E-3;
            for (i = 0; i < kx; i++) {
               for (j = 0; j < ky; j++) {
                  v0 = (double)i / (kx - 1);
                  v1 = (double)j / (ky - 1);
                  for (k = 0; k < d; k++) {
                     f0 = spline2dcalcvi(&s, v0 - v, v1, k);
                     f1 = spline2dcalcvi(&s, v0, v1, k);
                     f2 = spline2dcalcvi(&s, v0 + v, v1, k);
                     penalty2.xR[k] += sqr((f0 + f2 - 2 * f1) / sqr(v));
                  }
                  for (k = 0; k < d; k++) {
                     f0 = spline2dcalcvi(&s, v0, v1 - v, k);
                     f1 = spline2dcalcvi(&s, v0, v1, k);
                     f2 = spline2dcalcvi(&s, v0, v1 + v, k);
                     penalty2.xR[k] += sqr((f0 + f2 - 2 * f1) / sqr(v));
                  }
                  for (k = 0; k < d; k++) {
                     f0 = spline2dcalcvi(&s, v0 - v, v1 - v, k);
                     f1 = spline2dcalcvi(&s, v0 + v, v1 - v, k);
                     f2 = spline2dcalcvi(&s, v0 - v, v1 + v, k);
                     f3 = spline2dcalcvi(&s, v0 + v, v1 + v, k);
                     penalty2.xR[k] += 2 * sqr((f3 - f2 - f1 + f0) / sqr(v));
                  }
               }
            }
            Ok = Ok && rep.rmserror > rmserror;
            for (k = 0; k < d; k++) {
               Ok = Ok && penalty2.xR[k] < penalty.xR[k];
            }
            rmserror = rep.rmserror;
            for (k = 0; k < d; k++) {
               penalty.xR[k] = penalty2.xR[k];
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Block solver test for fitting functionality
static bool testspline2dunit_testfittingblocksolver() {
   ae_frame _frame_block;
   ae_int_t d;
   ae_int_t kidx;
   ae_int_t areatype;
   ae_int_t gridtype;
   ae_int_t solvertype;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double errtol;
   ae_int_t kx;
   ae_int_t ky;
   double w1;
   double xc;
   double yc;
   ae_int_t npoints;
   ae_int_t priortype;
   double mx;
   double rmserror;
   double avgerror;
   double maxerror;
   double rss;
   double tss;
   double r2;
   double v;
   double v0;
   double v1;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewVector(kv, 0, DT_INT);
   NewObj(hqrndstate, rs);
   NewObj(spline2dbuilder, state);
   NewObj(spline2dinterpolant, s);
   NewObj(spline2dinterpolant, s2);
   NewObj(spline2dinterpolant, s3);
   NewObj(spline2dfitreport, rep);
   NewObj(spline2dfitreport, rep2);
   NewObj(spline2dfitreport, rep3);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewMatrix(xy3, 0, 0, DT_REAL);
   NewMatrix(vterm, 0, 0, DT_REAL);
   NewVector(meany, 0, DT_REAL);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(tmp1, 0, DT_REAL);
   hqrndrandomize(&rs);
   errtol = 1.0E-6;
// Check that default state (no dataset) results in zero model being returned.
   for (priortype = 0; priortype <= 2; priortype++) {
      for (d = 1; d <= 3; d++) {
         for (areatype = 0; areatype <= 1; areatype++) {
            for (gridtype = 0; gridtype <= 1; gridtype++) {
               for (solvertype = 1; solvertype <= 2; solvertype++) {
               // Create solver, set grid, area and other properties
               // according to chosen test mode.
                  kx = imax2(4, 1 + hqrnduniformi(&rs, 10));
                  ky = imax2(4, 1 + hqrnduniformi(&rs, 10));
                  spline2dbuildercreate(d, &state);
                  if (gridtype == 1) {
                     spline2dbuildersetgrid(&state, kx, ky);
                  }
                  if (solvertype == 1) {
                     spline2dbuildersetalgoblocklls(&state, 0.0);
                  } else {
                     if (solvertype == 2) {
                        spline2dbuildersetalgonaivells(&state, 0.0);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
                  if (areatype == 0) {
                     spline2dbuildersetareaauto(&state);
                  } else {
                     if (areatype == 1) {
                        spline2dbuildersetarea(&state, 0.0, 1.0, 0.0, 1.0);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
                  if (priortype == 0) {
                     spline2dbuildersetlinterm(&state);
                  } else {
                     if (priortype == 1) {
                        spline2dbuildersetconstterm(&state);
                     } else {
                        if (priortype == 2) {
                           spline2dbuildersetzeroterm(&state);
                        } else {
                           ae_assert(false, "Assertion failed");
                        }
                     }
                  }
                  spline2dfit(&state, &s, &rep);
               // Test
                  for (j = 0; j < d; j++) {
                     Ok = Ok && spline2dcalcvi(&s, hqrndnormal(&rs), hqrndnormal(&rs), j) == 0.0;
                  }
                  Ok = Ok && rep.rmserror == 0.0;
                  Ok = Ok && rep.avgerror == 0.0;
                  Ok = Ok && rep.maxerror == 0.0;
                  Ok = Ok && rep.r2 == 1.0;
               }
            }
         }
      }
   }
// Check properties of regression spline fitting WITHOUT nonlinearity
// penalty. Absence of penalty term allows us to perform several indirect
// tests which are impossible when working under penalty.
//
// Section below performs following tests on completely random dataset:
// * correctness of report fields
// * indirect tests for fitting solver (fitting on residuals from previous fit)
   ae_vector_set_length(&kv, 5);
   kv.xZ[0] = 4;
   kv.xZ[1] = 5;
   kv.xZ[2] = 10;
   kv.xZ[3] = 12;
   kv.xZ[4] = 15;
   for (kidx = 0; kidx < kv.cnt; kidx++) {
      for (d = 1; d <= 3; d++) {
         for (areatype = 0; areatype <= 1; areatype++) {
            for (gridtype = 1; gridtype <= 1; gridtype++) {
               for (solvertype = 1; solvertype <= 2; solvertype++) {
               // Generate dataset
                  kx = imax2(4, 1 + hqrnduniformi(&rs, kv.xZ[kidx]));
                  ky = imax2(4, 1 + hqrnduniformi(&rs, kv.xZ[kidx]));
                  if (hqrndnormal(&rs) > 0.0) {
                     kx = kv.xZ[kidx];
                  } else {
                     ky = kv.xZ[kidx];
                  }
                  w1 = pow(10.0, hqrndnormal(&rs));
                  xc = w1 * hqrndmiduniformr(&rs);
                  yc = w1 * hqrndmiduniformr(&rs);
                  ae_vector_set_length(&meany, d);
                  for (j = 0; j < d; j++) {
                     meany.xR[j] = 0.0;
                  }
                  npoints = iround((kx + 2) * (ky + 2) * (3.0 + hqrnduniformr(&rs)));
                  ae_matrix_set_length(&xy, npoints, 2 + d);
                  for (i = 0; i < npoints; i++) {
                     xy.xyR[i][0] = xc + w1 * hqrndmiduniformr(&rs) * kx;
                     xy.xyR[i][1] = yc + w1 * hqrndmiduniformr(&rs) * ky;
                     for (j = 0; j < d; j++) {
                        xy.xyR[i][2 + j] = hqrndnormal(&rs);
                        meany.xR[j] += xy.xyR[i][2 + j] / npoints;
                     }
                  }
               // Create solver, set grid, area and other properties
               // according to chosen test mode.
                  spline2dbuildercreate(d, &state);
                  if (gridtype == 1) {
                     spline2dbuildersetgrid(&state, kx, ky);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
                  if (solvertype == 1) {
                     spline2dbuildersetalgoblocklls(&state, 0.0);
                  } else {
                     if (solvertype == 2) {
                        spline2dbuildersetalgonaivells(&state, 0.0);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
                  if (areatype == 0) {
                     spline2dbuildersetareaauto(&state);
                  } else {
                     if (areatype == 1) {
                        spline2dbuildersetarea(&state, xc - w1 * kx, xc + w1 * kx, yc - w1 * ky, yc + w1 * ky);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
                  spline2dbuildersetpoints(&state, &xy, npoints);
                  spline2dfit(&state, &s, &rep);
               // Test report fields
                  rmserror = 0.0;
                  avgerror = 0.0;
                  maxerror = 0.0;
                  rss = 0.0;
                  tss = 0.0;
                  for (i = 0; i < npoints; i++) {
                     spline2dcalcv(&s, xy.xyR[i][0], xy.xyR[i][1], &tmp0);
                     for (j = 0; j < d; j++) {
                        v = xy.xyR[i][2 + j] - tmp0.xR[j];
                        rss += v * v;
                        tss += sqr(xy.xyR[i][2 + j] - meany.xR[j]);
                        rmserror += sqr(v);
                        avgerror += fabs(v) / (npoints * d);
                        maxerror = rmax2(maxerror, fabs(v));
                     }
                  }
                  rmserror = sqrt(rmserror / (npoints * d));
                  r2 = 1.0 - rss / coalesce(tss, 1.0);
                  Ok = Ok && NearAtR(rmserror, rep.rmserror, errtol);
                  Ok = Ok && NearAtR(avgerror, rep.avgerror, errtol);
                  Ok = Ok && NearAtR(maxerror, rep.maxerror, errtol);
                  if (tss > 1.0E-3) {
                     Ok = Ok && NearAtR(r2, rep.r2, errtol);
                  }
               // Minimalistic test for fitting quality: R2 is better than zero
               // (zero value = fitting by median value).
                  Ok = Ok && rep.r2 >= 0.0;
               // Indirect test for solver: test that fitting on residuals from
               // previous fitting does not significantly decrease residuals.
               //
               // In our test we require that residuals from residuals are
               // greater than 0.8 times original residuals.
               //
               // In the ideal world, fitting on residuals will return same
               // residuals, but during spline construction we made several
               // compromises (regularization, pre-model phase). So, we just
               // check that residuals are weakly decreased.
               //
               // NOTE: this test is performed only for significantly non-zero residuals
                  if (rep.rmserror > 0.05) {
                     ae_matrix_set_length(&xy2, npoints, 2 + d);
                     for (i = 0; i < npoints; i++) {
                        xy2.xyR[i][0] = xy.xyR[i][0];
                        xy2.xyR[i][1] = xy.xyR[i][1];
                        spline2dcalcv(&s, xy.xyR[i][0], xy.xyR[i][1], &tmp1);
                        for (j = 0; j < d; j++) {
                           xy2.xyR[i][2 + j] = xy.xyR[i][2 + j] - tmp1.xR[j];
                        }
                     }
                     spline2dbuildersetpoints(&state, &xy2, npoints);
                     spline2dfit(&state, &s2, &rep2);
                     Ok = Ok && rep2.rmserror >= 0.8 * rep.rmserror;
                  }
               }
            }
         }
      }
   }
// Direct test:
// * points on regular grid which is exactly the same as one used
//   for regression, but with some noise added to point locations
// * we test that without penalty we get nearly-zero RMS error
   ae_vector_set_length(&kv, 5);
   kv.xZ[0] = 4;
   kv.xZ[1] = 5;
   kv.xZ[2] = 6;
   kv.xZ[3] = 8;
   kv.xZ[4] = 12;
   for (kidx = 0; kidx < kv.cnt; kidx++) {
      for (d = 1; d <= 2; d++) {
         for (solvertype = 1; solvertype <= 2; solvertype++) {
         // Generate dataset
            kx = imax2(4, 1 + hqrnduniformi(&rs, kv.xZ[kidx]));
            ky = imax2(4, 1 + hqrnduniformi(&rs, kv.xZ[kidx]));
            if (hqrndnormal(&rs) > 0.0) {
               kx = kv.xZ[kidx];
            } else {
               ky = kv.xZ[kidx];
            }
            npoints = kx * ky;
            ae_matrix_set_length(&xy, npoints, 2 + d);
            for (i = 0; i < npoints; i++) {
               xy.xyR[i][0] = rboundval(i % kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(kx - 1));
               xy.xyR[i][1] = rboundval(i / kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(ky - 1));
               for (j = 0; j < d; j++) {
                  xy.xyR[i][2 + j] = hqrndnormal(&rs);
               }
            }
         // Create solver, set grid, area and other properties
         // according to chosen test mode.
            spline2dbuildercreate(d, &state);
            spline2dbuildersetgrid(&state, kx, ky);
            if (solvertype == 1) {
               spline2dbuildersetalgoblocklls(&state, 0.0);
            } else {
               if (solvertype == 2) {
                  spline2dbuildersetalgonaivells(&state, 0.0);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
            spline2dbuildersetareaauto(&state);
            spline2dbuildersetpoints(&state, &xy, npoints);
            spline2dfit(&state, &s, &rep);
         // Test
            for (i = 0; i < npoints; i++) {
               for (k = 0; k < d; k++) {
                  Ok = Ok && NearAtR(spline2dcalcvi(&s, xy.xyR[i][0], xy.xyR[i][1], k), xy.xyR[i][2 + k], 1.0E-6);
               }
            }
         }
      }
   }
// Compare results obtained with block solver vs naive one
   mx = 0.0;
   for (kx = 4; kx <= 8; kx++) {
      for (ky = 4; ky <= 8; ky++) {
         for (d = 1; d <= 2; d++) {
         // Generate dataset
            npoints = 300;
            ae_matrix_set_length(&xy, npoints, 2 + d);
            for (i = 0; i < npoints; i++) {
               xy.xyR[i][0] = (kx - 1) * hqrnduniformr(&rs);
               xy.xyR[i][1] = (ky - 1) * hqrnduniformr(&rs);
               for (j = 0; j < d; j++) {
                  xy.xyR[i][2 + j] = hqrndnormal(&rs);
               }
            }
         // Create solver, set grid, area and other properties
         // according to chosen test mode.
         //
         // NOTE: we perform just one iteration of LSQR in order
         //       to test subtle differences of two implementations -
         //       reference one (NaiveLLS) and high-performance one.
            spline2dbuildercreate(d, &state);
            spline2dbuildersetgrid(&state, kx, ky);
            spline2dbuildersetarea(&state, 0.0, (double)(kx - 1), 0.0, (double)(ky - 1));
            spline2dbuildersetpoints(&state, &xy, npoints);
            state.lsqrcnt = 1;
            spline2dbuildersetalgonaivells(&state, 0.0);
            spline2dfit(&state, &s, &rep);
            spline2dbuildersetalgoblocklls(&state, 0.0);
            spline2dfit(&state, &s2, &rep2);
            for (i = 0; i < npoints; i++) {
               spline2dcalcv(&s, xy.xyR[i][0], xy.xyR[i][1], &tmp0);
               spline2dcalcv(&s2, xy.xyR[i][0], xy.xyR[i][1], &tmp1);
               for (j = 0; j < d; j++) {
                  Ok = Ok && NearAtR(tmp0.xR[j], tmp1.xR[j], 1.0E-6);
                  mx = rmax2(mx, fabs(tmp0.xR[j] - tmp1.xR[j]));
               }
            }
         }
      }
   }
// Investigate stability against minor perturbations
   d = 1;
   kx = 20;
   ky = 20;
   npoints = 5 * kx * ky;
   ae_matrix_set_length(&xy, npoints, 2 + d);
   for (i = 0; i < npoints; i++) {
      xy.xyR[i][0] = (kx - 1) * hqrnduniformr(&rs);
      xy.xyR[i][1] = (ky - 1) * hqrnduniformr(&rs);
      xy.xyR[i][2] = hqrndnormal(&rs);
   }
   spline2dbuildercreate(d, &state);
   spline2dbuildersetgrid(&state, kx, ky);
   spline2dbuildersetarea(&state, 0.0, (double)(kx - 1), 0.0, (double)(ky - 1));
   spline2dbuildersetalgoblocklls(&state, 0.001);
   spline2dbuildersetpoints(&state, &xy, npoints);
   spline2dfit(&state, &s, &rep);
   for (i = 0; i < npoints; i++) {
      j = i + hqrnduniformi(&rs, npoints - i);
      swaprows(&xy, i, j, -1);
      xy.xyR[i][2] += machineepsilon * hqrndnormal(&rs);
   }
   spline2dbuildersetpoints(&state, &xy, npoints);
   spline2dfit(&state, &s2, &rep2);
   mx = 0.0;
   maxerror = 0.0;
   for (i = 0; i < npoints; i++) {
      v0 = (kx - 1) * hqrnduniformr(&rs);
      v1 = (ky - 1) * hqrnduniformr(&rs);
      maxerror = rmax2(maxerror, fabs(spline2dcalc(&s, v0, v1) - spline2dcalc(&s2, v0, v1)));
      mx = rmax2(mx, fabs(spline2dcalc(&s, v0, v1)));
   }
   Ok = Ok && maxerror / mx <= 1.0E-12;
   ae_frame_leave();
   return Ok;
}

// Block solver test for fitting functionality
static bool testspline2dunit_testfittingfastddmsolver() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t tilesize;
   ae_int_t interfacesize;
   ae_int_t npoints;
   ae_int_t d;
   ae_int_t kx;
   ae_int_t ky;
   ae_int_t kxcur;
   ae_int_t kycur;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v0;
   double v1;
   double vx;
   double vy;
   double f0;
   double f1;
   double f2;
   double f3;
   double h;
   double smax;
   double ernd;
   double ept;
   double emax;
   double eavg;
   double vmax;
   ae_int_t padding;
   ae_int_t nlayers;
   double rmserror;
   double avgerror;
   double maxerror;
   double rss;
   double tss;
   double r2;
   double v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy1, 0, 0, DT_REAL);
   NewObj(spline2dbuilder, state);
   NewObj(spline2dinterpolant, sa0);
   NewObj(spline2dinterpolant, sa1);
   NewObj(spline2dinterpolant, s1);
   NewObj(spline2dinterpolant, s2);
   NewObj(spline2dfitreport, rep0);
   NewObj(spline2dfitreport, rep1);
   NewObj(spline2dfitreport, rep2);
   NewVector(meany, 0, DT_REAL);
   NewVector(lambdaa, 0, DT_REAL);
   NewVector(penaltya, 0, DT_REAL);
   NewVector(rmsa, 0, DT_REAL);
   hqrndrandomize(&rs);
// Basic test:
// * small grid whose size is TileSize+1 or less
// * random dataset
// * compared with single run of naiveLLS
// * we also test correctness of report fields
   for (pass = 1; pass <= 3; pass++) {
      for (d = 1; d <= 3; d++) {
         tilesize = 8 + hqrnduniformi(&rs, 8);
         kx = imax2(1 + hqrnduniformi(&rs, tilesize + 1), 4);
         ky = imax2(1 + hqrnduniformi(&rs, tilesize + 1), 4);
         npoints = 10 * kx * ky;
         ae_matrix_set_length(&xy, npoints, 2 + d);
         ae_vector_set_length(&meany, d);
         for (j = 0; j < d; j++) {
            meany.xR[j] = 0.0;
         }
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = hqrnduniformr(&rs);
            xy.xyR[i][1] = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
               meany.xR[j] += xy.xyR[i][2 + j] / npoints;
            }
         }
      // Create solver, set grid, area and other properties.
      // Fit with NaiveLLS first.
         spline2dbuildercreate(d, &state);
         spline2dbuildersetarea(&state, 0.0, 1.0, 0.0, 1.0);
         state.maxcoresize = tilesize;
         state.adddegreeoffreedom = false;
         spline2dbuildersetalgonaivells(&state, 0.0);
         spline2dbuildersetpoints(&state, &xy, npoints);
         spline2dbuildersetgrid(&state, kx, ky);
         spline2dfit(&state, &sa0, &rep0);
      // Fit with FastDDM solver with NLayers in [-2,+2]
         spline2dbuildersetpoints(&state, &xy, npoints);
         spline2dbuildersetgrid(&state, kx, ky);
         spline2dbuildersetalgofastddm(&state, hqrnduniformi(&rs, 5) - 2, 0.0);
         spline2dfit(&state, &s1, &rep1);
      // Compare at random locations
         smax = 0.0;
         ernd = 0.0;
         for (k = 0; k < 20 * kx * ky; k++) {
            vx = hqrnduniformr(&rs);
            vy = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               v0 = spline2dcalcvi(&sa0, vx, vy, j);
               v1 = spline2dcalcvi(&s1, vx, vy, j);
               smax = rmax2(smax, fabs(v0));
               ernd = rmax2(ernd, fabs(v0 - v1));
            }
         }
         Ok = Ok && ernd / smax <= 0.001;
      // Test report fields
         rmserror = 0.0;
         avgerror = 0.0;
         maxerror = 0.0;
         rss = 0.0;
         tss = 0.0;
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < d; j++) {
               v = xy.xyR[i][2 + j] - spline2dcalcvi(&s1, xy.xyR[i][0], xy.xyR[i][1], j);
               rss += v * v;
               tss += sqr(xy.xyR[i][2 + j] - meany.xR[j]);
               rmserror += sqr(v);
               avgerror += fabs(v) / (npoints * d);
               maxerror = rmax2(maxerror, fabs(v));
            }
         }
         rmserror = sqrt(rmserror / (npoints * d));
         r2 = 1.0 - rss / coalesce(tss, 1.0);
         Ok = Ok && NearAtR(rmserror, rep1.rmserror, 1.0E-6);
         Ok = Ok && NearAtR(avgerror, rep1.avgerror, 1.0E-6);
         Ok = Ok && NearAtR(maxerror, rep1.maxerror, 1.0E-6);
         if (tss > 1.0E-3) {
            Ok = Ok && NearAtR(r2, rep1.r2, 1.0E-6);
         }
      }
   }
// Basic test: two-layer task; "reference" model is built by
// subsequent fitting of two "traditional" splines; test model
// is built by FastDDM algorithm.
   tilesize = 15;
   for (d = 1; d <= 2; d++) {
   // Generate dataset
      kx = 2 * tilesize + 1;
      ky = 2 * tilesize + 1;
      npoints = kx * ky;
      ae_matrix_set_length(&xy, npoints, 2 + d);
      for (i = 0; i < npoints; i++) {
         xy.xyR[i][0] = rboundval(i % kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(kx - 1));
         xy.xyR[i][1] = rboundval(i / kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(ky - 1));
         for (j = 0; j < d; j++) {
            xy.xyR[i][2 + j] = hqrndnormal(&rs);
         }
      }
   // Create solver, set grid, area and other properties
      spline2dbuildercreate(d, &state);
      spline2dbuildersetarea(&state, 0.0, (double)(kx - 1), 0.0, (double)(ky - 1));
      state.maxcoresize = tilesize;
   // Fit with BlockLLS solver
      state.adddegreeoffreedom = false;
      spline2dbuildersetalgoblocklls(&state, 0.0);
      spline2dbuildersetpoints(&state, &xy, npoints);
      spline2dbuildersetgrid(&state, (kx - 1) / 2 + 1, (ky - 1) / 2 + 1);
      spline2dfit(&state, &sa0, &rep0);
      ae_matrix_set_length(&xy1, npoints, 2 + d);
      for (i = 0; i < npoints; i++) {
         xy1.xyR[i][0] = xy.xyR[i][0];
         xy1.xyR[i][1] = xy.xyR[i][1];
         for (j = 0; j < d; j++) {
            xy1.xyR[i][2 + j] = xy.xyR[i][2 + j] - spline2dcalcvi(&sa0, xy.xyR[i][0], xy.xyR[i][1], j);
         }
      }
      spline2dbuildersetpoints(&state, &xy1, npoints);
      spline2dbuildersetgrid(&state, kx, ky);
      spline2dfit(&state, &sa1, &rep0);
   // Fit with another solver
      spline2dbuildersetpoints(&state, &xy, npoints);
      spline2dbuildersetgrid(&state, kx, ky);
      spline2dbuildersetalgofastddm(&state, 0, 0.0);
      spline2dfit(&state, &s1, &rep1);
   // Compare
      padding = 0;
      smax = 0.0;
      ernd = 0.0;
      for (k = 0; k < 20 * kx * ky; k++) {
         vx = (kx - 1 - 2 * padding) * hqrnduniformr(&rs) + padding;
         vy = (ky - 1 - 2 * padding) * hqrnduniformr(&rs) + padding;
         for (j = 0; j < d; j++) {
            v0 = spline2dcalcvi(&sa0, vx, vy, j) + spline2dcalcvi(&sa1, vx, vy, j);
            v1 = spline2dcalcvi(&s1, vx, vy, j);
            smax = rmax2(smax, fabs(v0));
            ernd = rmax2(ernd, fabs(v0 - v1));
         }
      }
      Ok = Ok && ernd / smax <= 0.010;
      ept = 0.0;
      for (i = 0; i < npoints; i++) {
         vx = xy.xyR[i][0];
         vy = xy.xyR[i][1];
         for (j = 0; j < d; j++) {
            v0 = spline2dcalcvi(&sa0, vx, vy, j) + spline2dcalcvi(&sa1, vx, vy, j);
            v1 = spline2dcalcvi(&s1, vx, vy, j);
            smax = rmax2(smax, fabs(v0));
            ept = rmax2(ept, fabs(v0 - v1));
         }
      }
      Ok = Ok && ept / smax <= 0.001;
   }
// Test correctness of error reporting in multilevel setting:
// * grid whose size is larger than TileSize+1
// * random dataset
// * we just test correctness of report fields
   for (pass = 1; pass <= 2; pass++) {
      for (d = 1; d <= 2; d++) {
         tilesize = 5 + hqrnduniformi(&rs, 3);
         kx = imax2(1 + hqrnduniformi(&rs, 5 * tilesize + 1), 4);
         ky = imax2(1 + hqrnduniformi(&rs, 5 * tilesize + 1), 4);
         npoints = 10 * kx * ky;
         ae_matrix_set_length(&xy, npoints, 2 + d);
         ae_vector_set_length(&meany, d);
         for (j = 0; j < d; j++) {
            meany.xR[j] = 0.0;
         }
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = hqrnduniformr(&rs);
            xy.xyR[i][1] = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
               meany.xR[j] += xy.xyR[i][2 + j] / npoints;
            }
         }
      // Create solver, set grid, area and other properties.
      // Fit with FastDDM solver
         spline2dbuildercreate(d, &state);
         spline2dbuildersetarea(&state, 0.0, 1.0, 0.0, 1.0);
         state.maxcoresize = tilesize;
         spline2dbuildersetpoints(&state, &xy, npoints);
         spline2dbuildersetgrid(&state, kx, ky);
         spline2dbuildersetalgofastddm(&state, hqrnduniformi(&rs, 5) - 2, 0.0);
         spline2dfit(&state, &s1, &rep1);
      // Test report fields
         rmserror = 0.0;
         avgerror = 0.0;
         maxerror = 0.0;
         rss = 0.0;
         tss = 0.0;
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < d; j++) {
               v = xy.xyR[i][2 + j] - spline2dcalcvi(&s1, xy.xyR[i][0], xy.xyR[i][1], j);
               rss += v * v;
               tss += sqr(xy.xyR[i][2 + j] - meany.xR[j]);
               rmserror += sqr(v);
               avgerror += fabs(v) / (npoints * d);
               maxerror = rmax2(maxerror, fabs(v));
            }
         }
         rmserror = sqrt(rmserror / (npoints * d));
         r2 = 1.0 - rss / coalesce(tss, 1.0);
         Ok = Ok && NearAtR(rmserror, rep1.rmserror, 1.0E-6);
         Ok = Ok && NearAtR(avgerror, rep1.avgerror, 1.0E-6);
         Ok = Ok && NearAtR(maxerror, rep1.maxerror, 1.0E-6);
         if (tss > 1.0E-3) {
            Ok = Ok && NearAtR(r2, rep1.r2, 1.0E-6);
         }
      }
   }
// Test correctness of handling NLayers > 0, NLayers == 0 and NLayers < 0.
//
// NOTE: we use reduced tile size and interface size, because we do
//       not test model quality, just identity with NLayers <= 0
   d = 1;
   tilesize = 5;
   interfacesize = 2;
   kx = 1 + 4 * (tilesize - hqrnduniformi(&rs, 2));
   ky = 1 + 4 * (tilesize - hqrnduniformi(&rs, 2));
   nlayers = 3;
   npoints = kx * ky;
   ae_matrix_set_length(&xy, npoints, 2 + d);
   for (i = 0; i < npoints; i++) {
      xy.xyR[i][0] = hqrnduniformr(&rs);
      xy.xyR[i][1] = hqrnduniformr(&rs);
      for (j = 0; j < d; j++) {
         xy.xyR[i][2 + j] = hqrndnormal(&rs);
      }
   }
// Create solver, set grid, area and other properties.
   spline2dbuildercreate(d, &state);
   spline2dbuildersetarea(&state, 0.0, 1.0, 0.0, 1.0);
   state.maxcoresize = tilesize;
   state.interfacesize = interfacesize;
   spline2dbuildersetpoints(&state, &xy, npoints);
   spline2dbuildersetgrid(&state, kx, ky);
// Try different NLayers > 0, compare with corresponding non-positive values
   for (k = 1; k <= nlayers + 1; k++) {
      spline2dbuildersetalgofastddm(&state, k, 0.0);
      spline2dfit(&state, &s1, &rep1);
      spline2dbuildersetalgofastddm(&state, imin2(k - nlayers, 0), 0.0);
      spline2dfit(&state, &s2, &rep2);
   // Test report fields
      vmax = 0.0;
      for (i = 0; i <= 10; i++) {
         vx = hqrnduniformr(&rs);
         vy = hqrnduniformr(&rs);
         vmax = rmax2(vmax, fabs(spline2dcalc(&s1, vx, vy) - spline2dcalc(&s2, vx, vy)));
      }
      Ok = Ok && vmax <= 1.0E-12;
   }
// Ability to reproduce target function in multilayer setup:
// * small tile size
// * nearly regular KX*KY dataset, for random KX > TileSize, KY > TileSize
// * (2*KX)x(2*KY) grid, flexible enough
//
// We check that maximum and average errors at nodes are small
   vmax = 0.0;
   for (pass = 1; pass <= 10; pass++) {
      d = 1;
      tilesize = 5 + hqrnduniformi(&rs, 4);
      kx = 4 + hqrnduniformi(&rs, 4 * tilesize + 1);
      ky = 4 + hqrnduniformi(&rs, 4 * tilesize + 1);
      npoints = kx * ky;
      ae_matrix_set_length(&xy, npoints, 2 + d);
      for (i = 0; i < npoints; i++) {
         xy.xyR[i][0] = rboundval(i % kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(kx - 1));
         xy.xyR[i][1] = rboundval(i / kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(ky - 1));
         for (j = 0; j < d; j++) {
            xy.xyR[i][2 + j] = hqrndnormal(&rs);
         }
      }
   // Create solver, set grid, area and other properties.
      spline2dbuildercreate(d, &state);
      state.maxcoresize = tilesize;
      spline2dbuildersetpoints(&state, &xy, npoints);
      spline2dbuildersetgrid(&state, iround(2.0 * kx), iround(2.0 * ky));
      spline2dbuildersetarea(&state, 0.0, (double)(kx - 1), 0.0, (double)(ky - 1));
      spline2dbuildersetalgofastddm(&state, 0, 0.0);
      spline2dfit(&state, &s1, &rep1);
   // Compare
      emax = 0.0;
      eavg = 0.0;
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < d; j++) {
            v = fabs(spline2dcalcvi(&s1, xy.xyR[i][0], xy.xyR[i][1], j) - xy.xyR[i][2 + j]);
            emax = rmax2(emax, v);
            eavg += v / (npoints * d);
         }
      }
      Ok = Ok && emax <= 0.00100;
      Ok = Ok && eavg <= 0.00010;
      vmax = rmax2(vmax, fabs(emax));
   }
// Test that increasing LambdaV results in decrease of S'' integral;
// although (unlike BlockLLS) FastDDM does NOT minimize S'' explicitly,
// it shows similar behavior with respect to regularization, so we can
// expect that penalty decreases.
//
// NOTE: we use ultra-small values of tile size and interface size because
//       precision is not important here.
   for (pass = 0; pass <= 2; pass++) {
      d = 1;
      tilesize = 5;
      kx = 1 + 4 * (tilesize - hqrnduniformi(&rs, 2));
      ky = 1 + 4 * (tilesize - hqrnduniformi(&rs, 2));
      npoints = -1;
      vx = 0.0;
      vy = 0.0;
      if (pass == 0) {
         npoints = 1 + iround(0.5 * kx * ky);
         ae_matrix_set_length(&xy, npoints, 2 + d);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = hqrnduniformr(&rs);
            xy.xyR[i][1] = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
            }
         }
         vx = 1.0 / (kx - 1);
         vy = 1.0 / (ky - 1);
      }
      if (pass == 1) {
         npoints = kx * ky;
         ae_matrix_set_length(&xy, npoints, 2 + d);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = rboundval(i % kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(kx - 1));
            xy.xyR[i][1] = rboundval(i / kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(ky - 1));
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
            }
         }
         vx = 1.0;
         vy = 1.0;
      }
      if (pass == 2) {
         npoints = 1 + iround(3.0 * kx * ky);
         ae_matrix_set_length(&xy, npoints, 2 + d);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = hqrnduniformr(&rs);
            xy.xyR[i][1] = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
            }
         }
         vx = 1.0 / (kx - 1);
         vy = 1.0 / (ky - 1);
      }
      ae_assert(vx > 0.0, "Spline2D: unit test failed integrity check");
      ae_assert(vy > 0.0, "Spline2D: unit test failed integrity check");
   // Create solver, set grid, area and other properties.
      spline2dbuildercreate(d, &state);
      spline2dbuildersetarea(&state, 0.0, (double)(kx - 1), 0.0, (double)(ky - 1));
      state.maxcoresize = tilesize;
      spline2dbuildersetpoints(&state, &xy, npoints);
      spline2dbuildersetgrid(&state, kx, ky);
   // Try different values of LambdaV, calculate penalty
      ae_vector_set_length(&lambdaa, 4);
      lambdaa.xR[0] = 0.0;
      lambdaa.xR[1] = 1.0E-1;
      lambdaa.xR[2] = 1.0E+1;
      lambdaa.xR[3] = 1.0E+2;
      ae_vector_set_length(&penaltya, lambdaa.cnt);
      ae_vector_set_length(&rmsa, lambdaa.cnt);
      for (k = 0; k < lambdaa.cnt; k++) {
         spline2dbuildersetalgofastddm(&state, 0, lambdaa.xR[k]);
         spline2dfit(&state, &s1, &rep1);
         h = 1.0E-4;
         v = 0.0;
         for (i = 0; i < kx; i++) {
            for (j = 0; j < ky; j++) {
               v0 = i * vx;
               v1 = j * vy;
               f0 = spline2dcalc(&s1, v0 - h, v1);
               f1 = spline2dcalc(&s1, v0, v1);
               f2 = spline2dcalc(&s1, v0 + h, v1);
               v += sqr((f0 + f2 - 2 * f1) / sqr(h));
               f0 = spline2dcalc(&s1, v0, v1 - h);
               f1 = spline2dcalc(&s1, v0, v1);
               f2 = spline2dcalc(&s1, v0, v1 + h);
               v += sqr((f0 + f2 - 2 * f1) / sqr(h));
               f0 = spline2dcalc(&s1, v0 - h, v1 - h);
               f1 = spline2dcalc(&s1, v0 + h, v1 - h);
               f2 = spline2dcalc(&s1, v0 - h, v1 + h);
               f3 = spline2dcalc(&s1, v0 + h, v1 + h);
               v += 2 * sqr((f3 - f2 - f1 + f0) / sqr(h));
            }
         }
         penaltya.xR[k] = v;
         rmsa.xR[k] = rep1.rmserror;
      }
      for (k = 0; k < lambdaa.cnt - 1; k++) {
         Ok = Ok && penaltya.xR[k] >= penaltya.xR[k + 1];
      }
   }
// Test that refining grid in "K = 2*K-1" fashion results in
// decrease of RMS error; although it seems quite silly test,
// in fact it checks various failures in the algorithm.
//
// NOTE: we set high penalty coefficient in order to avoid nearly
//       precise fits (such fits are hard to test reliably)
//
// NOTE: we use ultra-small values of tile size and interface size because
//       precision is not important here.
   for (pass = 0; pass <= 2; pass++) {
      d = 1;
      tilesize = 5;
      kx = 1 + 4 * tilesize;
      ky = 1 + 4 * tilesize;
      nlayers = 3;
      npoints = -1;
      if (pass == 0) {
         npoints = 1 + iround(0.1 * kx * ky);
         ae_matrix_set_length(&xy, npoints, 2 + d);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = hqrnduniformr(&rs);
            xy.xyR[i][1] = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
            }
         }
         vx = 1.0 / (kx - 1);
         vy = 1.0 / (ky - 1);
      }
      if (pass == 1) {
         npoints = kx * ky;
         ae_matrix_set_length(&xy, npoints, 2 + d);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = rboundval(i % kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(kx - 1));
            xy.xyR[i][1] = rboundval(i / kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(ky - 1));
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
            }
         }
         vx = 1.0;
         vy = 1.0;
      }
      if (pass == 2) {
         npoints = 1 + iround(2.0 * kx * ky);
         ae_matrix_set_length(&xy, npoints, 2 + d);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = hqrnduniformr(&rs);
            xy.xyR[i][1] = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
            }
         }
         vx = 1.0 / (kx - 1);
         vy = 1.0 / (ky - 1);
      }
   // Create solver, set grid, area and other properties.
      spline2dbuildercreate(d, &state);
      spline2dbuildersetarea(&state, 0.0, (double)(kx - 1), 0.0, (double)(ky - 1));
      state.maxcoresize = tilesize;
      spline2dbuildersetpoints(&state, &xy, npoints);
   // Try different values of LambdaV, calculate penalty
      ae_vector_set_length(&rmsa, nlayers);
      kxcur = tilesize + 1;
      kycur = tilesize + 1;
      for (k = 0; k < rmsa.cnt; k++) {
         spline2dbuildersetgrid(&state, kxcur, kycur);
         spline2dbuildersetalgofastddm(&state, 0, 0.0);
         spline2dfit(&state, &s1, &rep1);
         rmsa.xR[k] = rep1.rmserror;
         kxcur = 2 * kxcur - 1;
         kycur = 2 * kycur - 1;
      }
      for (k = 0; k < rmsa.cnt - 1; k++) {
         Ok = Ok && rmsa.xR[k] > rmsa.xR[k + 1];
      }
   }
   ae_frame_leave();
   return Ok;
}

bool testspline2d() {
   ae_frame _frame_block;
   bool Ok;
   bool blOk;
   bool bcOk;
   bool dsOk;
   bool cpOk;
   bool serOk;
   bool upOk;
   bool ltOk;
   bool syOk;
   bool rlOk;
   bool rcOk;
   bool vfOk;
   bool fitfastddmsolverOk;
   bool fitblocksolverOk;
   bool fitpenaltyOk;
   bool fitpriorOk;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t jobtype;
   double lstep;
   double h;
   double ax;
   double ay;
   double bx;
   double by;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t m;
   ae_int_t d;
   ae_int_t n2;
   ae_int_t m2;
   double err;
   double t1;
   double t2;
   double l1;
   double l1x;
   double l1y;
   double l1xy;
   double l2;
   double l2x;
   double l2y;
   double l2xy;
   double fm;
   double f1;
   double f2;
   double f3;
   double f4;
   double v1;
   double v1x;
   double v1y;
   double v1xy;
   double v2;
   double v2x;
   double v2y;
   double v2xy;
   double mf;
   ae_frame_make(&_frame_block);
   if (!silent) printf("2D Spline Test Breakdown\n");
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(spline2dinterpolant, c);
   NewObj(spline2dinterpolant, c2);
   NewVector(lx, 0, DT_REAL);
   NewVector(ly, 0, DT_REAL);
   NewVector(fv1, 0, DT_REAL);
   NewVector(fvd, 0, DT_REAL);
   NewMatrix(f, 0, 0, DT_REAL);
   NewMatrix(fr, 0, 0, DT_REAL);
   NewMatrix(ft, 0, 0, DT_REAL);
   Ok = true;
   passcount = 10;
   h = 0.00001;
   lstep = 0.001;
   blOk = true;
   bcOk = true;
   dsOk = true;
   cpOk = true;
   serOk = true;
   upOk = true;
   ltOk = true;
   syOk = true;
   rlOk = true;
   rcOk = true;
   vfOk = true;
   fitfastddmsolverOk = true;
   fitblocksolverOk = true;
   fitpriorOk = true;
   fitpenaltyOk = true;
// Fitting functions
   fitfastddmsolverOk = fitfastddmsolverOk && testspline2dunit_testfittingfastddmsolver();
   fitpriorOk = fitpriorOk && testspline2dunit_testfittingprior();
   fitblocksolverOk = fitblocksolverOk && testspline2dunit_testfittingblocksolver();
   fitpenaltyOk = fitpenaltyOk && testspline2dunit_testfittingpenalty();
// Test: bilinear, bicubic
   for (n = 2; n <= 7; n++) {
      for (m = 2; m <= 7; m++) {
         d = randominteger(2) + 2;
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, m);
         ae_vector_set_length(&lx, 2 * n - 1);
         ae_vector_set_length(&ly, 2 * m - 1);
         ae_matrix_set_length(&f, m, n);
         ae_vector_set_length(&fv1, m * n);
         ae_vector_set_length(&fvd, m * n * d);
         ae_matrix_set_length(&ft, n, m);
         for (pass = 1; pass <= passcount; pass++) {
         // Prepare task:
         // * X and Y stores grid
         // * F stores function values
         // * LX and LY stores twice dense grid (for Lipschitz testing)
            ax = -1 - randomreal();
            bx = 1 + randomreal();
            ay = -1 - randomreal();
            by = 1 + randomreal();
            for (j = 0; j < n; j++) {
               x.xR[j] = 0.5 * (bx + ax) - 0.5 * (bx - ax) * cos(pi * (2 * j + 1) / (2 * n));
               if (j == 0) {
                  x.xR[j] = ax;
               }
               if (j == n - 1) {
                  x.xR[j] = bx;
               }
               lx.xR[2 * j] = x.xR[j];
               if (j > 0) {
                  lx.xR[2 * j - 1] = 0.5 * (x.xR[j] + x.xR[j - 1]);
               }
            }
            for (j = 0; j < n; j++) {
               k = randominteger(n);
               if (k != j) {
                  swapr(&x.xR[j], &x.xR[k]);
               }
            }
            for (i = 0; i < m; i++) {
               y.xR[i] = 0.5 * (by + ay) - 0.5 * (by - ay) * cos(pi * (2 * i + 1) / (2 * m));
               if (i == 0) {
                  y.xR[i] = ay;
               }
               if (i == m - 1) {
                  y.xR[i] = by;
               }
               ly.xR[2 * i] = y.xR[i];
               if (i > 0) {
                  ly.xR[2 * i - 1] = 0.5 * (y.xR[i] + y.xR[i - 1]);
               }
            }
            for (i = 0; i < m; i++) {
               k = randominteger(m);
               if (k != i) {
                  swapr(&y.xR[i], &y.xR[k]);
               }
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  f.xyR[i][j] = exp(0.6 * x.xR[j]) - exp(-0.3 * y.xR[i] + 0.08 * x.xR[j]) + 2 * cos(pi * (x.xR[j] + 1.2 * y.xR[i])) + 0.1 * cos(20 * x.xR[j] + 15 * y.xR[i]);
                  fv1.xR[i * n + j] = f.xyR[i][j];
               }
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  for (k = 0; k < d; k++) {
                     fvd.xR[d * (n * j + i) + k] = exp(0.6 * x.xR[i]) - exp(-0.3 * y.xR[j] + 0.08 * x.xR[i]) + 2 * cos(pi * (x.xR[i] + 1.2 * y.xR[j] + k)) + 0.1 * cos(20 * x.xR[i] + 15 * y.xR[j] + k);
                  }
               }
            }
         // Test scalar bilinear interpolation:
         // * interpolation at the nodes
         // * linearity
         // * continuity
         // * differentiation in the inner points
            spline2dbuildbilinearv(&x, n, &y, m, &fv1, 1, &c);
            err = 0.0;
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  err = rmax2(err, fabs(f.xyR[i][j] - spline2dcalc(&c, x.xR[j], y.xR[i])));
               }
            }
            blOk = blOk && err <= 10000.0 * machineepsilon;
            err = 0.0;
            for (i = 0; i < m - 1; i++) {
               for (j = 0; j < n - 1; j++) {
               // Test for linearity between grid points
               // (test point - geometric center of the cell)
                  fm = spline2dcalc(&c, lx.xR[2 * j + 1], ly.xR[2 * i + 1]);
                  f1 = spline2dcalc(&c, lx.xR[2 * j], ly.xR[2 * i]);
                  f2 = spline2dcalc(&c, lx.xR[2 * j + 2], ly.xR[2 * i]);
                  f3 = spline2dcalc(&c, lx.xR[2 * j + 2], ly.xR[2 * i + 2]);
                  f4 = spline2dcalc(&c, lx.xR[2 * j], ly.xR[2 * i + 2]);
                  err = rmax2(err, fabs(0.25 * (f1 + f2 + f3 + f4) - fm));
               }
            }
            blOk = blOk && err <= 10000.0 * machineepsilon;
            testspline2dunit_lconst(&c, &lx, &ly, m, n, lstep, &l1, &l1x, &l1y, &l1xy);
            testspline2dunit_lconst(&c, &lx, &ly, m, n, lstep / 3, &l2, &l2x, &l2y, &l2xy);
            blOk = blOk && l2 / l1 <= 1.2;
            err = 0.0;
            for (i = 0; i < m - 1; i++) {
               for (j = 0; j < n - 1; j++) {
                  spline2ddiff(&c, lx.xR[2 * j + 1], ly.xR[2 * i + 1], &v1, &v1x, &v1y, &v1xy);
                  testspline2dunit_twodnumder(&c, lx.xR[2 * j + 1], ly.xR[2 * i + 1], h, &v2, &v2x, &v2y, &v2xy);
                  err = rmax2(err, fabs(v1 - v2));
                  err = rmax2(err, fabs(v1x - v2x));
                  err = rmax2(err, fabs(v1y - v2y));
                  err = rmax2(err, fabs(v1xy - v2xy));
               }
            }
            dsOk = dsOk && err <= 1.0E-3;
            upOk = upOk && testspline2dunit_testunpack(&c, &lx, &ly);
            ltOk = ltOk && testspline2dunit_testlintrans(&c, 1, ax, bx, ay, by);
         // Lin.Trans. test for multicomponent vector function
            spline2dbuildbilinearv(&x, n, &y, m, &fvd, d, &c);
            ltOk = ltOk && testspline2dunit_testlintrans(&c, d, ax, bx, ay, by);
         // Test bicubic interpolation.
         // * interpolation at the nodes
         // * smoothness
         // * differentiation
            spline2dbuildbicubicv(&x, n, &y, m, &fv1, 1, &c);
            err = 0.0;
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  err = rmax2(err, fabs(f.xyR[i][j] - spline2dcalc(&c, x.xR[j], y.xR[i])));
               }
            }
            bcOk = bcOk && err <= 10000.0 * machineepsilon;
            testspline2dunit_lconst(&c, &lx, &ly, m, n, lstep, &l1, &l1x, &l1y, &l1xy);
            testspline2dunit_lconst(&c, &lx, &ly, m, n, lstep / 3, &l2, &l2x, &l2y, &l2xy);
            bcOk = bcOk && l2 / l1 <= 1.2;
            bcOk = bcOk && l2x / l1x <= 1.2;
            bcOk = bcOk && l2y / l1y <= 1.2;
            if (l2xy > 0.01 && l1xy > 0.01) {
            // Cross-derivative continuity is tested only when
            // bigger than 0.01. When the task size is too
            // small, the d2F/dXdY is nearly zero and Lipschitz
            // constant ratio is ill-conditioned.
               bcOk = bcOk && l2xy / l1xy <= 1.2;
            }
            err = 0.0;
            for (i = 0; i < 2 * m - 1; i++) {
               for (j = 0; j < 2 * n - 1; j++) {
                  spline2ddiff(&c, lx.xR[j], ly.xR[i], &v1, &v1x, &v1y, &v1xy);
                  testspline2dunit_twodnumder(&c, lx.xR[j], ly.xR[i], h, &v2, &v2x, &v2y, &v2xy);
                  err = rmax2(err, fabs(v1 - v2));
                  err = rmax2(err, fabs(v1x - v2x));
                  err = rmax2(err, fabs(v1y - v2y));
                  err = rmax2(err, fabs(v1xy - v2xy));
               }
            }
            dsOk = dsOk && err <= 1.0E-3;
            upOk = upOk && testspline2dunit_testunpack(&c, &lx, &ly);
            ltOk = ltOk && testspline2dunit_testlintrans(&c, 1, ax, bx, ay, by);
         // Lin.Trans. test for vector-function
            spline2dbuildbicubicv(&x, n, &y, m, &fvd, d, &c);
            ltOk = ltOk && testspline2dunit_testlintrans(&c, d, ax, bx, ay, by);
         // Copy test
            if (randombool()) {
               spline2dbuildbicubic(&x, &y, &f, m, n, &c);
            } else {
               spline2dbuildbilinear(&x, &y, &f, m, n, &c);
            }
            testspline2dunit_unsetspline2d(&c2);
            spline2dcopy(&c, &c2);
            err = 0.0;
            for (i = 1; i <= 5; i++) {
               t1 = ax + (bx - ax) * randomreal();
               t2 = ay + (by - ay) * randomreal();
               err = rmax2(err, fabs(spline2dcalc(&c, t1, t2) - spline2dcalc(&c2, t1, t2)));
            }
            cpOk = cpOk && err <= 10000.0 * machineepsilon;
         // Serialization test
            if (randombool()) {
               spline2dbuildbicubic(&x, &y, &f, m, n, &c);
            } else {
               spline2dbuildbilinear(&x, &y, &f, m, n, &c);
            }
            testspline2dunit_unsetspline2d(&c2);
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               spline2dalloc(&_local_serializer, &c);
               ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               spline2dserialize(&_local_serializer, &c);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               spline2dunserialize(&_local_serializer, &c2);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
            err = 0.0;
            for (i = 1; i <= 5; i++) {
               t1 = ax + (bx - ax) * randomreal();
               t2 = ay + (by - ay) * randomreal();
               err = rmax2(err, fabs(spline2dcalc(&c, t1, t2) - spline2dcalc(&c2, t1, t2)));
            }
            serOk = serOk && err <= 10000.0 * machineepsilon;
         // Special symmetry test
            err = 0.0;
            for (jobtype = 0; jobtype <= 1; jobtype++) {
            // Prepare
               for (i = 0; i < m; i++) {
                  for (j = 0; j < n; j++) {
                     ft.xyR[j][i] = f.xyR[i][j];
                  }
               }
               if (jobtype == 0) {
                  spline2dbuildbilinear(&x, &y, &f, m, n, &c);
                  spline2dbuildbilinear(&y, &x, &ft, n, m, &c2);
               } else {
                  spline2dbuildbicubic(&x, &y, &f, m, n, &c);
                  spline2dbuildbicubic(&y, &x, &ft, n, m, &c2);
               }
            // Test
               for (i = 1; i <= 10; i++) {
                  t1 = ax + (bx - ax) * randomreal();
                  t2 = ay + (by - ay) * randomreal();
                  err = rmax2(err, fabs(spline2dcalc(&c, t1, t2) - spline2dcalc(&c2, t2, t1)));
               }
            }
            syOk = syOk && err <= 10000.0 * machineepsilon;
         }
      }
   }
// Test resample
   for (m = 2; m <= 6; m++) {
      for (n = 2; n <= 6; n++) {
         ae_matrix_set_length(&f, m, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, m);
         for (j = 0; j < n; j++) {
            x.xR[j] = (double)j / (n - 1);
         }
         for (i = 0; i < m; i++) {
            y.xR[i] = (double)i / (m - 1);
         }
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               f.xyR[i][j] = exp(0.6 * x.xR[j]) - exp(-0.3 * y.xR[i] + 0.08 * x.xR[j]) + 2 * cos(pi * (x.xR[j] + 1.2 * y.xR[i])) + 0.1 * cos(20 * x.xR[j] + 15 * y.xR[i]);
            }
         }
         for (m2 = 2; m2 <= 6; m2++) {
            for (n2 = 2; n2 <= 6; n2++) {
               for (pass = 1; pass <= passcount; pass++) {
                  for (jobtype = 0; jobtype <= 1; jobtype++) {
                     if (jobtype == 0) {
                        spline2dresamplebilinear(&f, m, n, &fr, m2, n2);
                        spline2dbuildbilinear(&x, &y, &f, m, n, &c);
                     }
                     if (jobtype == 1) {
                        spline2dresamplebicubic(&f, m, n, &fr, m2, n2);
                        spline2dbuildbicubic(&x, &y, &f, m, n, &c);
                     }
                     err = 0.0;
                     mf = 0.0;
                     for (i = 0; i < m2; i++) {
                        for (j = 0; j < n2; j++) {
                           v1 = spline2dcalc(&c, (double)j / (n2 - 1), (double)i / (m2 - 1));
                           v2 = fr.xyR[i][j];
                           err = rmax2(err, fabs(v1 - v2));
                           mf = rmax2(mf, fabs(v1));
                        }
                     }
                     if (jobtype == 0) {
                        rlOk = rlOk && err / mf <= 10000.0 * machineepsilon;
                     }
                     if (jobtype == 1) {
                        rcOk = rcOk && err / mf <= 10000.0 * machineepsilon;
                     }
                  }
               }
            }
         }
      }
   }
// Test for vector-function
   vfOk = testspline2dunit_testspline2dvf();
// The final report.
   Ok = blOk && bcOk && dsOk && cpOk && serOk && upOk && ltOk && syOk && rlOk && rcOk && vfOk && fitpriorOk && fitpenaltyOk && fitblocksolverOk && fitfastddmsolverOk;
   if (!Ok || !silent) {
      printf("2D Spline Tests\n");
   // Normal tests
      printf("Interpolation:\n");
      printf("* Bi-Linear:                              %s\n", blOk? "Ok": "Failed");
      printf("* Bi-Cubic:                               %s\n", bcOk? "Ok": "Failed");
      printf("* Differentiation:                        %s\n", dsOk? "Ok": "Failed");
      printf("* Copying:                                %s\n", cpOk? "Ok": "Failed");
      printf("* Serialization:                          %s\n", serOk? "Ok": "Failed");
      printf("* Unpacking:                              %s\n", upOk? "Ok": "Failed");
      printf("* Linear Transform:                       %s\n", ltOk? "Ok": "Failed");
      printf("* Special Symmetry Props:                 %s\n", syOk? "Ok": "Failed");
      printf("* Vector Spline:                          %s\n", vfOk? "Ok": "Failed");
      printf("Fitting Tests:\n");
      printf("* Linear Prior Term:                      %s\n", fitpriorOk? "Ok": "Failed");
      printf("* Non-Linearity Penalty Term:             %s\n", fitpenaltyOk? "Ok": "Failed");
      printf("* Block Solver:                           %s\n", fitblocksolverOk? "Ok": "Failed");
      printf("* Fast DDM Solver:                        %s\n", fitfastddmsolverOk? "Ok": "Failed");
      printf("Resampling Tests:\n");
      printf("* Bi-Linear:                              %s\n", rlOk? "Ok": "Failed");
      printf("* Bi-Cubic:                               %s\n", rcOk? "Ok": "Failed");
   // Summary
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
// end
   ae_frame_leave();
   return Ok;
}

// === spline3d testing unit ===
// The function does build random function on random grid with random number
// of points:
// * N, M, K   -   random from 2 to 5
// * D         -   1 in case IsVect == False, 1..3 in case IsVect == True
// * X, Y, Z   -   each variable spans from MinV to MaxV, with MinV is random
//                 number from [-1.5,0.5] and MaxV is random number from
//                 [0.5,1.5]. All nodes are well separated. All nodes are
//                 randomly reordered in case Reorder == False. When Reorder == True,
//                 nodes are returned in ascending order.
// * F         -   random values from [-1,+1]
static void testspline3dunit_buildrndgrid(bool isvect, bool reorder, ae_int_t *n, ae_int_t *m, ae_int_t *l, ae_int_t *d, RVector *x, RVector *y, RVector *z, RVector *f) {
   double st;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t di;
   double mx;
   double maxv;
   double minv;
   *n = 0;
   *m = 0;
   *l = 0;
   *d = 0;
   SetVector(x);
   SetVector(y);
   SetVector(z);
   SetVector(f);
   st = 0.3;
   *m = randominteger(4) + 2;
   *n = randominteger(4) + 2;
   *l = randominteger(4) + 2;
   if (isvect) {
      *d = randominteger(3) + 1;
   } else {
      *d = 1;
   }
   vectorsetlengthatleast(x, *n);
   vectorsetlengthatleast(y, *m);
   vectorsetlengthatleast(z, *l);
   vectorsetlengthatleast(f, *n * (*m) * (*l) * (*d));
// Fill X
   x->xR[0] = 0.0;
   for (i = 1; i < *n; i++) {
      x->xR[i] = x->xR[i - 1] + st + randomreal();
   }
   minv = -0.5 - randomreal();
   maxv = 0.5 + randomreal();
   mx = x->xR[*n - 1];
   for (i = 0; i < *n; i++) {
      x->xR[i] = x->xR[i] / mx * (maxv - minv) + minv;
   }
   if (reorder) {
      for (i = 0; i < *n; i++) {
         swapr(&x->xR[i], &x->xR[randominteger(*n)]);
      }
   }
// Fill Y
   y->xR[0] = 0.0;
   for (i = 1; i < *m; i++) {
      y->xR[i] = y->xR[i - 1] + st + randomreal();
   }
   minv = -0.5 - randomreal();
   maxv = 0.5 + randomreal();
   mx = y->xR[*m - 1];
   for (i = 0; i < *m; i++) {
      y->xR[i] = y->xR[i] / mx * (maxv - minv) + minv;
   }
   if (reorder) {
      for (i = 0; i < *m; i++) {
         swapr(&y->xR[i], &y->xR[randominteger(*m)]);
      }
   }
// Fill Z
   z->xR[0] = 0.0;
   for (i = 1; i < *l; i++) {
      z->xR[i] = z->xR[i - 1] + st + randomreal();
   }
   minv = -0.5 - randomreal();
   maxv = 0.5 + randomreal();
   mx = z->xR[*l - 1];
   for (i = 0; i < *l; i++) {
      z->xR[i] = z->xR[i] / mx * (maxv - minv) + minv;
   }
   if (reorder) {
      for (i = 0; i < *l; i++) {
         swapr(&z->xR[i], &z->xR[randominteger(*l)]);
      }
   }
// Fill F
   for (i = 0; i < *n; i++) {
      for (j = 0; j < *m; j++) {
         for (k = 0; k < *l; k++) {
            for (di = 0; di < *d; di++) {
               f->xR[*d * (*n * (*m * k + j) + i) + di] = randommid();
            }
         }
      }
   }
}

// The function does test basic functionality.
static bool testspline3dunit_basictest() {
   ae_frame _frame_block;
   double vsf;
   ae_int_t d;
   ae_int_t m;
   ae_int_t n;
   ae_int_t l;
   double eps;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t offs;
   ae_int_t di;
   double ax;
   double ay;
   double az;
   double axy;
   double ayz;
   double vx;
   double vy;
   double vz;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(spline3dinterpolant, c);
   NewObj(spline3dinterpolant, cc);
   NewVector(vvf, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(z, 0, DT_REAL);
   NewVector(sf, 0, DT_REAL);
   NewVector(vf, 0, DT_REAL);
   eps = 1000.0 * machineepsilon;
// Test spline ability to reproduce D-dimensional vector function
//     f[idx](x,y,z) = idx+AX*x + AY*y + AZ*z + AXY*x*y + AYZ*y*z
// with random AX/AY/...
//
// We generate random test function, build spline, then evaluate
// it in the random test point.
   for (d = 1; d <= 3; d++) {
      n = 2 + randominteger(4);
      m = 2 + randominteger(4);
      l = 2 + randominteger(4);
      ae_vector_set_length(&x, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = (double)i;
      }
      ae_vector_set_length(&y, m);
      for (i = 0; i < m; i++) {
         y.xR[i] = (double)i;
      }
      ae_vector_set_length(&z, l);
      for (i = 0; i < l; i++) {
         z.xR[i] = (double)i;
      }
      ae_vector_set_length(&vf, l * m * n * d);
      offs = 0;
      ax = randommid();
      ay = randommid();
      az = randommid();
      axy = randommid();
      ayz = randommid();
      for (k = 0; k < l; k++) {
         for (j = 0; j < m; j++) {
            for (i = 0; i < n; i++) {
               for (di = 0; di < d; di++) {
                  vf.xR[offs] = di + ax * i + ay * j + az * k + axy * i * j + ayz * j * k;
                  offs++;
               }
            }
         }
      }
      spline3dbuildtrilinearv(&x, n, &y, m, &z, l, &vf, d, &c);
      vx = randomreal() * n;
      vy = randomreal() * m;
      vz = randomreal() * l;
      spline3dcalcv(&c, vx, vy, vz, &vf);
      for (di = 0; di < d; di++) {
         if (!NearAtR(di + ax * vx + ay * vy + az * vz + axy * vx * vy + ayz * vy * vz, vf.xR[di], eps)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
      if (d == 1) {
         vsf = spline3dcalc(&c, vx, vy, vz);
         if (!NearAtR(ax * vx + ay * vy + az * vz + axy * vx * vy + ayz * vy * vz, vsf, eps)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   }
// Generate random grid and test function.
// Test spline ability to reproduce function values at grid nodes.
   passcount = 20;
   for (pass = 1; pass <= passcount; pass++) {
   // Prepare a model and check that functions (Spline3DBuildTrilinear,
   // Spline3DCalc,Spline3DCalcV) work correctly and
      testspline3dunit_buildrndgrid(true, true, &n, &m, &l, &d, &x, &y, &z, &vf);
      vectorsetlengthatleast(&sf, n * m * l);
   // Check that the model's values are equal to the function's values
   // in grid points
      spline3dbuildtrilinearv(&x, n, &y, m, &z, l, &vf, d, &c);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            for (k = 0; k < l; k++) {
               spline3dcalcv(&c, x.xR[i], y.xR[j], z.xR[k], &vvf);
               for (di = 0; di < d; di++) {
                  if (!NearAtR(vf.xR[d * (n * (m * k + j) + i) + di], vvf.xR[di], eps)) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
               }
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Unpack/UnpackV test
static bool testspline3dunit_testunpack() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t l;
   ae_int_t d;
   ae_int_t sz;
   ae_int_t un;
   ae_int_t um;
   ae_int_t ul;
   ae_int_t ud;
   ae_int_t ust;
   ae_int_t uvn;
   ae_int_t uvm;
   ae_int_t uvl;
   ae_int_t uvd;
   ae_int_t uvst;
   ae_int_t ci;
   ae_int_t cj;
   ae_int_t ck;
   ae_int_t p0;
   ae_int_t p1;
   double tx;
   double ty;
   double tz;
   double v1;
   double v2;
   double err;
   ae_int_t pass;
   ae_int_t passcount;
   bool bperr;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t di;
   ae_int_t i0;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(spline3dinterpolant, c);
   NewMatrix(tbl0, 0, 0, DT_REAL);
   NewMatrix(tbl1, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(z, 0, DT_REAL);
   NewVector(sf, 0, DT_REAL);
   NewVector(vf, 0, DT_REAL);
   passcount = 20;
   err = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
   // generate random grid.
   // NOTE: for this test we need ordered grid, i.e. grid
   //       with nodes in ascending order
      testspline3dunit_buildrndgrid(true, false, &n, &m, &l, &d, &x, &y, &z, &vf);
      sz = n * m * l;
      vectorsetlengthatleast(&sf, sz);
      spline3dbuildtrilinearv(&x, n, &y, m, &z, l, &vf, d, &c);
      spline3dunpackv(&c, &uvn, &uvm, &uvl, &uvd, &uvst, &tbl0);
      for (di = 0; di < d; di++) {
      // DI-th component copy of a vector-function to
      // a scalar function
         for (i = 0; i < sz; i++) {
            sf.xR[i] = vf.xR[d * i + di];
         }
         spline3dbuildtrilinearv(&x, n, &y, m, &z, l, &sf, 1, &c);
         spline3dunpackv(&c, &un, &um, &ul, &ud, &ust, &tbl1);
         for (i = 0; i < n - 1; i++) {
            for (j = 0; j < m - 1; j++) {
               for (k = 0; k < l - 1; k++) {
                  p1 = (n - 1) * ((m - 1) * k + j) + i;
                  p0 = d * p1 + di;
               // Check that all components are correct:
               // * first check, that unpacked componets are equal
               //   to packed components;
                  bperr = un != n || um != m || ul != l || tbl1.xyR[p1][0] != x.xR[i] || tbl1.xyR[p1][1] != x.xR[i + 1] || tbl1.xyR[p1][2] != y.xR[j] || tbl1.xyR[p1][3] != y.xR[j + 1] || tbl1.xyR[p1][4] != z.xR[k] || tbl1.xyR[p1][5] != z.xR[k + 1] || uvn != n || uvm != m || uvl != l || uvd != d || tbl0.xyR[p0][0] != x.xR[i] || tbl0.xyR[p0][1] != x.xR[i + 1] || tbl0.xyR[p0][2] != y.xR[j] || tbl0.xyR[p0][3] != y.xR[j + 1] || tbl0.xyR[p0][4] != z.xR[k] || tbl0.xyR[p0][5] != z.xR[k + 1];
               // * check, that all components unpacked by Unpack
               //   function are equal to all components unpacked
               //   by UnpackV function.
                  for (i0 = 0; i0 <= 13; i0++) {
                     bperr = bperr || tbl0.xyR[p0][i0] != tbl1.xyR[p1][i0];
                  }
                  if (bperr) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
                  tx = (0.001 + 0.999 * randomreal()) * (tbl1.xyR[p1][1] - tbl1.xyR[p1][0]);
                  ty = (0.001 + 0.999 * randomreal()) * (tbl1.xyR[p1][3] - tbl1.xyR[p1][2]);
                  tz = (0.001 + 0.999 * randomreal()) * (tbl1.xyR[p1][5] - tbl1.xyR[p1][4]);
               // Interpolation properties for:
               // * scalar function;
                  v1 = 0.0;
                  for (ci = 0; ci <= 1; ci++) {
                     for (cj = 0; cj <= 1; cj++) {
                        for (ck = 0; ck <= 1; ck++) {
                           v1 += tbl1.xyR[p1][6 + 2 * (2 * ck + cj) + ci] * pow(tx, (double)ci) * pow(ty, (double)cj) * pow(tz, (double)ck);
                        }
                     }
                  }
                  v2 = spline3dcalc(&c, tbl1.xyR[p1][0] + tx, tbl1.xyR[p1][2] + ty, tbl1.xyR[p1][4] + tz);
                  err = rmax2(err, fabs(v1 - v2));
               // * component of vector function.
                  v1 = 0.0;
                  for (ci = 0; ci <= 1; ci++) {
                     for (cj = 0; cj <= 1; cj++) {
                        for (ck = 0; ck <= 1; ck++) {
                           v1 += tbl0.xyR[p0][6 + 2 * (2 * ck + cj) + ci] * pow(tx, (double)ci) * pow(ty, (double)cj) * pow(tz, (double)ck);
                        }
                     }
                  }
                  v2 = spline3dcalc(&c, tbl0.xyR[p0][0] + tx, tbl0.xyR[p0][2] + ty, tbl0.xyR[p0][4] + tz);
                  err = rmax2(err, fabs(v1 - v2));
               }
            }
         }
      }
   }
   Ok = err <= 1.0E+5 * machineepsilon;
   ae_frame_leave();
   return Ok;
}

// LinTrans test
static bool testspline3dunit_testlintrans() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t l;
   ae_int_t d;
   double a1;
   double a2;
   double a3;
   double b1;
   double b2;
   double b3;
   double tx;
   double ty;
   double tz;
   double vx;
   double vy;
   double vz;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t xjob;
   ae_int_t yjob;
   ae_int_t zjob;
   double err;
   ae_int_t i;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(spline3dinterpolant, c);
   NewObj(spline3dinterpolant, c2);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(z, 0, DT_REAL);
   NewVector(f, 0, DT_REAL);
   NewVector(v1, 0, DT_REAL);
   NewVector(v2, 0, DT_REAL);
   err = 0.0;
   passcount = 15;
   for (pass = 1; pass <= passcount; pass++) {
      testspline3dunit_buildrndgrid(true, false, &n, &m, &l, &d, &x, &y, &z, &f);
      spline3dbuildtrilinearv(&x, n, &y, m, &z, l, &f, d, &c);
      for (xjob = 0; xjob <= 1; xjob++) {
         for (yjob = 0; yjob <= 1; yjob++) {
            for (zjob = 0; zjob <= 1; zjob++) {
            // Prepare
               do {
                  a1 = randommid();
               } while (a1 == 0.0);
               a1 *= xjob;
               b1 = x.xR[0] + randomreal() * (x.xR[n - 1] - x.xR[0] + 2.0) - 1.0;
               do {
                  a2 = randommid();
               } while (a2 == 0.0);
               a2 *= yjob;
               b2 = y.xR[0] + randomreal() * (y.xR[m - 1] - y.xR[0] + 2.0) - 1.0;
               do {
                  a3 = randommid();
               } while (a3 == 0.0);
               a3 *= zjob;
               b3 = z.xR[0] + randomreal() * (z.xR[l - 1] - z.xR[0] + 2.0) - 1.0;
            // Test XYZ
               spline3dcopy(&c, &c2);
               spline3dlintransxyz(&c2, a1, b1, a2, b2, a3, b3);
               tx = x.xR[0] + randomreal() * (x.xR[n - 1] - x.xR[0]);
               ty = y.xR[0] + randomreal() * (y.xR[m - 1] - y.xR[0]);
               tz = z.xR[0] + randomreal() * (z.xR[l - 1] - z.xR[0]);
               if (xjob == 0) {
                  tx = b1;
                  vx = x.xR[0] + randomreal() * (x.xR[n - 1] - x.xR[0]);
               } else {
                  vx = (tx - b1) / a1;
               }
               if (yjob == 0) {
                  ty = b2;
                  vy = y.xR[0] + randomreal() * (y.xR[m - 1] - y.xR[0]);
               } else {
                  vy = (ty - b2) / a2;
               }
               if (zjob == 0) {
                  tz = b3;
                  vz = z.xR[0] + randomreal() * (z.xR[l - 1] - z.xR[0]);
               } else {
                  vz = (tz - b3) / a3;
               }
               spline3dcalcv(&c, tx, ty, tz, &v1);
               spline3dcalcv(&c2, vx, vy, vz, &v2);
               for (i = 0; i < d; i++) {
                  err = rmax2(err, fabs(v1.xR[i] - v2.xR[i]));
               }
               if (err > 1.0E+4 * machineepsilon) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            // Test F
               spline3dcopy(&c, &c2);
               spline3dlintransf(&c2, a1, b1);
               tx = x.xR[0] + randomreal() * (x.xR[n - 1] - x.xR[0]);
               ty = y.xR[0] + randomreal() * (y.xR[m - 1] - y.xR[0]);
               tz = z.xR[0] + randomreal() * (z.xR[l - 1] - z.xR[0]);
               spline3dcalcv(&c, tx, ty, tz, &v1);
               spline3dcalcv(&c2, tx, ty, tz, &v2);
               for (i = 0; i < d; i++) {
                  err = rmax2(err, fabs(a1 * v1.xR[i] + b1 - v2.xR[i]));
               }
            }
         }
      }
   }
   Ok = err <= 1.0E+4 * machineepsilon;
   ae_frame_leave();
   return Ok;
}

// Resample test
static bool testspline3dunit_testtrilinearresample() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t l;
   ae_int_t n2;
   ae_int_t m2;
   ae_int_t l2;
   double v1;
   double v2;
   double err;
   double mf;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(spline3dinterpolant, c);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(z, 0, DT_REAL);
   NewVector(f, 0, DT_REAL);
   NewVector(fr, 0, DT_REAL);
   Ok = true;
   passcount = 20;
   for (pass = 1; pass <= passcount; pass++) {
      n = randominteger(4) + 2;
      m = randominteger(4) + 2;
      l = randominteger(4) + 2;
      n2 = randominteger(4) + 2;
      m2 = randominteger(4) + 2;
      l2 = randominteger(4) + 2;
      vectorsetlengthatleast(&x, n);
      vectorsetlengthatleast(&y, m);
      vectorsetlengthatleast(&z, l);
      vectorsetlengthatleast(&f, n * m * l);
      for (i = 0; i < n; i++) {
         x.xR[i] = (double)i / (n - 1);
      }
      for (i = 0; i < m; i++) {
         y.xR[i] = (double)i / (m - 1);
      }
      for (i = 0; i < l; i++) {
         z.xR[i] = (double)i / (l - 1);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            for (k = 0; k < l; k++) {
               f.xR[n * (m * k + j) + i] = randommid();
            }
         }
      }
      spline3dresampletrilinear(&f, l, m, n, l2, m2, n2, &fr);
      spline3dbuildtrilinearv(&x, n, &y, m, &z, l, &f, 1, &c);
      err = 0.0;
      mf = 0.0;
      for (i = 0; i < n2; i++) {
         for (j = 0; j < m2; j++) {
            for (k = 0; k < l2; k++) {
               v1 = spline3dcalc(&c, (double)i / (n2 - 1), (double)j / (m2 - 1), (double)k / (l2 - 1));
               v2 = fr.xR[n2 * (m2 * k + j) + i];
               err = rmax2(err, fabs(v1 - v2));
               mf = rmax2(mf, fabs(v1));
            }
         }
      }
      Ok = Ok && err / mf <= 1.0E+4 * machineepsilon;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   }
   ae_frame_leave();
   return Ok;
}

bool testspline3d() {
   bool Ok;
   bool basicOk;
   bool unpackOk;
   bool lintransfOk;
   bool trilinresOk;
   basicOk = testspline3dunit_basictest();
   unpackOk = testspline3dunit_testunpack();
   lintransfOk = testspline3dunit_testlintrans();
   trilinresOk = testspline3dunit_testtrilinearresample();
// The final report.
   Ok = basicOk && unpackOk && lintransfOk && trilinresOk;
   if (!Ok || !silent) {
      printf("3D Spline Tests\n");
      printf("Basic Test:                               %s\n", basicOk? "Ok": "Failed");
      printf("Unpack Test:                              %s\n", unpackOk? "Ok": "Failed");
      printf("Linear Transform Test:                    %s\n", lintransfOk? "Ok": "Failed");
      printf("Tri-Linear Resampling Test:               %s\n", trilinresOk? "Ok": "Failed");
   // Summary
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === rbf testing unit ===
static const double testrbfunit_tol = 1.0E-10;
static const ae_int_t testrbfunit_mxits = 0;
static const double testrbfunit_heps = 1.0E-12;

// The test  has  to  check, that  algorithm can solve problems of matrix are
// degenerate.
//     * used model with linear term;
//     * points locate in a subspace of dimension less than an original space.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
static bool sqrdegmatrixrbftest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t np;
   double sx;
   double sy;
   double zx;
   double px;
   double zy;
   double py;
   double q;
   double z;
   ae_int_t gen;
   double pvdnorm;
   double vnorm;
   double dd0;
   double dd1;
   ae_int_t unx;
   ae_int_t uny;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double eps;
   ae_int_t modelversion;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewVector(point, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(d0, 0, DT_REAL);
   NewVector(d1, 0, DT_REAL);
   NewVector(pvd0, 0, DT_REAL);
   NewVector(pvd1, 0, DT_REAL);
   NewMatrix(gp, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(xwr, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   zx = 10.0;
   px = 15.0;
   zy = 10.0;
   py = 15.0;
   eps = 1.0E-6;
   ny = 1;
   for (nx = 2; nx <= 3; nx++) {
   // prepare test problem
      sx = pow(zx, px * (randominteger(3) - 1));
      sy = pow(zy, py * (randominteger(3) - 1));
      ae_vector_set_length(&x, nx);
      ae_vector_set_length(&y, ny);
      ae_vector_set_length(&point, nx);
      rbfcreate(nx, ny, &s);
      rbfsetcond(&s, testrbfunit_heps, testrbfunit_heps, testrbfunit_mxits);
      q = 0.25 + randomreal();
      z = 4.5 + randomreal();
      rbfsetalgoqnn(&s, q, z);
   // start points for grid
      for (i = 0; i < nx; i++) {
         point.xR[i] = sx * randommid();
      }
      if (nx == 2) {
         for (k0 = 2; k0 <= 4; k0++) {
            rmatrixrndorthogonal(nx, &a);
            ae_vector_set_length(&d0, nx);
            ae_v_move(d0.xR, 1, a.xyR[0], a.stride, nx);
            np = k0;
            ae_matrix_set_length(&gp, np, nx + ny);
         // create grid
            for (i = 0; i < k0; i++) {
               gp.xyR[i][0] = point.xR[0] + sx * i * d0.xR[0];
               gp.xyR[i][1] = point.xR[1] + sx * i * d0.xR[1];
               for (k = 0; k < ny; k++) {
                  gp.xyR[i][nx + k] = sy * randommid();
               }
            }
            rbfsetpoints(&s, &gp, np);
            rbfbuildmodel(&s, &rep);
            for (i = 0; i < np; i++) {
               x.xR[0] = gp.xyR[i][0];
               x.xR[1] = gp.xyR[i][1];
               rbfcalc(&s, &x, &y);
               for (j = 0; j < ny; j++) {
                  if (!NearAtR(gp.xyR[i][nx + j], y.xR[j], sy * eps)) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
               }
            }
         }
      }
      if (nx == 3) {
         for (k0 = 2; k0 <= 4; k0++) {
            for (k1 = 2; k1 <= 4; k1++) {
               for (gen = 1; gen <= 2; gen++) {
                  rmatrixrndorthogonal(nx, &a);
                  ae_vector_set_length(&d0, nx);
                  ae_v_move(d0.xR, 1, a.xyR[0], a.stride, nx);
               // create grid
                  np = -1;
                  if (gen == 1) {
                     np = k0;
                     ae_matrix_set_length(&gp, np, nx + ny);
                     for (i = 0; i < k0; i++) {
                        gp.xyR[i][0] = point.xR[0] + sx * i * d0.xR[0];
                        gp.xyR[i][1] = point.xR[1] + sx * i * d0.xR[1];
                        gp.xyR[i][2] = point.xR[2] + sx * i * d0.xR[2];
                        for (k = 0; k < ny; k++) {
                           gp.xyR[i][nx + k] = sy * randommid();
                        }
                     }
                  }
                  if (gen == 2) {
                     ae_vector_set_length(&d1, nx);
                     ae_v_move(d1.xR, 1, &a.xyR[0][1], a.stride, nx);
                     np = k0 * k1;
                     ae_matrix_set_length(&gp, np, nx + ny);
                     for (i = 0; i < k0; i++) {
                        for (j = 0; j < k1; j++) {
                           gp.xyR[i * k1 + j][0] = sx * i * d0.xR[0] + sx * j * d1.xR[0];
                           gp.xyR[i * k1 + j][1] = sx * i * d0.xR[1] + sx * j * d1.xR[1];
                           gp.xyR[i * k1 + j][2] = sx * i * d0.xR[2] + sx * j * d1.xR[2];
                           for (k = 0; k < ny; k++) {
                              gp.xyR[i * k1 + j][nx + k] = sy * randommid();
                           }
                        }
                     }
                  }
                  ae_assert(np >= 0, "rbf test: integrity error");
                  rbfsetpoints(&s, &gp, np);
                  rbfbuildmodel(&s, &rep);
                  for (i = 0; i < np; i++) {
                     x.xR[0] = gp.xyR[i][0];
                     x.xR[1] = gp.xyR[i][1];
                     x.xR[2] = gp.xyR[i][2];
                     rbfcalc(&s, &x, &y);
                     for (j = 0; j < ny; j++) {
                        if (!NearAtR(gp.xyR[i][nx + j], y.xR[j], sy * eps)) {
                           Ok = false;
                           ae_frame_leave();
                           return Ok;
                        }
                     }
                  }
                  if (gen == 2) {
                     rbfunpack(&s, &unx, &uny, &xwr, &np, &v, &modelversion);
                     dd0 = (d0.xR[0] * v.xyR[0][0] + d0.xR[1] * v.xyR[0][1] + d0.xR[2] * v.xyR[0][2]) / (d0.xR[0] * d0.xR[0] + d0.xR[1] * d0.xR[1] + d0.xR[2] * d0.xR[2]);
                     dd1 = (d1.xR[0] * v.xyR[0][0] + d1.xR[1] * v.xyR[0][1] + d1.xR[2] * v.xyR[0][2]) / (d1.xR[0] * d1.xR[0] + d1.xR[1] * d1.xR[1] + d1.xR[2] * d1.xR[2]);
                     ae_vector_set_length(&pvd0, nx);
                     ae_vector_set_length(&pvd1, nx);
                     for (i = 0; i < nx; i++) {
                        pvd0.xR[i] = dd0 * d0.xR[i];
                        pvd1.xR[i] = dd1 * d1.xR[i];
                     }
                     pvdnorm = sqrt(sqr(v.xyR[0][0] - pvd0.xR[0] - pvd1.xR[0]) + sqr(v.xyR[0][1] - pvd0.xR[1] - pvd1.xR[1]) + sqr(v.xyR[0][2] - pvd0.xR[2] - pvd1.xR[2]));
                     vnorm = sqrt(sqr(v.xyR[0][0]) + sqr(v.xyR[0][1]) + sqr(v.xyR[0][2]));
                     if (pvdnorm > vnorm * testrbfunit_tol) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  }
               }
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

static bool testrbfunit_searcherr(RMatrix *y0, RMatrix *y1, ae_int_t n, ae_int_t ny, ae_int_t errtype, RVector *b1, RVector *delta) {
   ae_frame _frame_block;
   double oralerr;
   double iralerr;
   ae_int_t lb;
   ae_int_t rb;
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   ae_frame_make(&_frame_block);
   DupMatrix(y0);
   DupMatrix(y1);
   DupVector(b1);
   DupVector(delta);
   NewVector(irerr, 0, DT_REAL);
   NewVector(orerr, 0, DT_REAL);
   ae_assert(n > 0, "testrbfunit_searcherr: invalid parameter N(N <= 0).");
   ae_assert(ny > 0, "testrbfunit_searcherr: invalid parameter NY(NY <= 0).");
   oralerr = 1.0E-1;
   iralerr = 1.0E-2;
   lb = 25;
   rb = 75;
   ae_vector_set_length(&orerr, ny);
   ae_vector_set_length(&irerr, ny);
   for (j = 0; j < ny; j++) {
      orerr.xR[j] = 0.0;
      irerr.xR[j] = 0.0;
   }
   if (errtype == 1) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < ny; j++) {
            if (orerr.xR[j] < fabs(y0->xyR[i][j] - y1->xyR[i][j])) {
               orerr.xR[j] = fabs(y0->xyR[i][j] - y1->xyR[i][j]);
            }
         }
      }
      for (i = 0; i < ny; i++) {
         if (orerr.xR[i] > b1->xR[i] + delta->xR[i] || orerr.xR[i] < b1->xR[i] - delta->xR[i]) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   } else {
      if (errtype == 2) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < ny; j++) {
               if (i > lb && i < rb) {
                  if (irerr.xR[j] < fabs(y0->xyR[i][j] - y1->xyR[i][j])) {
                     irerr.xR[j] = fabs(y0->xyR[i][j] - y1->xyR[i][j]);
                  }
               } else {
                  if (orerr.xR[j] < fabs(y0->xyR[i][j] - y1->xyR[i][j])) {
                     orerr.xR[j] = fabs(y0->xyR[i][j] - y1->xyR[i][j]);
                  }
               }
            }
         }
         for (i = 0; i < ny; i++) {
            if (orerr.xR[i] > oralerr || irerr.xR[i] > iralerr) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      } else {
         ae_assert(false, "testrbfunit_searcherr: invalid argument ErrType(ErrType neither 1 nor 2)");
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Function for testing basic functionality of RBF module on regular grids with
// multi-layer algorithm in 1D.
// ALGLIB: Copyright 02.03.2012 by Sergey Bochkanov
static bool basicmultilayerrbf1dtest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t linterm;
   ae_int_t n;
   double q;
   double r;
   ae_int_t errtype;
   ae_int_t nlayers;
   double a;
   double b;
   double f1;
   double f2;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   double deltapct; //(@) Added to the original.
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewVector(delta, 0, DT_REAL);
   NewVector(a1, 0, DT_REAL);
   NewVector(b1, 0, DT_REAL);
   NewMatrix(gp, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(mody0, 0, 0, DT_REAL);
   NewMatrix(mody1, 0, 0, DT_REAL);
   NewMatrix(gy, 0, 0, DT_REAL);
   NewVector(gpgx0, 0, DT_REAL);
   NewVector(gpgx1, 0, DT_REAL);
   a = 1.0;
   b = 1.0 / 9.0;
   f1 = 1.0;
   f2 = 10.0;
   passcount = 5;
   n = 100;
   ae_vector_set_length(&gpgx0, n);
   ae_vector_set_length(&gpgx1, n);
   for (i = 0; i < n; i++) {
      gpgx0.xR[i] = (double)i / n;
      gpgx1.xR[i] = 0.0;
   }
   r = 1.0;
   deltapct = 0.45; //(@) The original used 0.35 below, but errors as high as 0.40-0.45 may occur.
   for (pass = 0; pass < passcount; pass++) {
      nx = randominteger(2) + 2;
      ny = randominteger(3) + 1;
      linterm = randominteger(3) + 1;
      ae_vector_set_length(&x, nx);
      ae_vector_set_length(&y, ny);
      ae_vector_set_length(&a1, ny);
      ae_vector_set_length(&b1, ny);
      ae_vector_set_length(&delta, ny);
      ae_matrix_set_length(&mody0, n, ny);
      ae_matrix_set_length(&mody1, n, ny);
      for (i = 0; i < ny; i++) {
         a1.xR[i] = a + 0.01 * a * randommid();
         b1.xR[i] = b + 0.01 * b * randommid();
         delta.xR[i] = deltapct * b1.xR[i]; //(@) Originally had 0.35 in place of deltapct.
      }
      ae_matrix_set_length(&gp, n, nx + ny);
   // create grid
      for (i = 0; i < n; i++) {
         for (j = 0; j < nx; j++) {
            gp.xyR[i][j] = 0.0;
         }
         gp.xyR[i][0] = (double)i / n;
         for (j = 0; j < ny; j++) {
            gp.xyR[i][nx + j] = a1.xR[j] * cos(f1 * 2 * pi * gp.xyR[i][0]) + b1.xR[j] * cos(f2 * 2 * pi * gp.xyR[i][0]);
            mody0.xyR[i][j] = gp.xyR[i][nx + j];
         }
      }
      q = 1.0;
      nlayers = 1;
      errtype = 1;
   // test multilayer algorithm with different parameters
      while (q * f2 >= 0.5) {
         rbfcreate(nx, ny, &s);
         rbfsetalgomultilayer(&s, r, nlayers, 0.0);
         if (linterm == 1) {
            rbfsetlinterm(&s);
         }
         if (linterm == 2) {
            rbfsetconstterm(&s);
         }
         if (linterm == 3) {
            rbfsetzeroterm(&s);
         }
         rbfsetpoints(&s, &gp, n);
         rbfbuildmodel(&s, &rep);
         if (ny == 1) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < nx; j++) {
                  x.xR[j] = gp.xyR[i][j];
               }
               if (nx == 2) {
                  mody1.xyR[i][0] = rbfcalc2(&s, x.xR[0], x.xR[1]);
               } else {
                  if (nx == 3) {
                     mody1.xyR[i][0] = rbfcalc3(&s, x.xR[0], x.xR[1], x.xR[2]);
                  } else {
                     ae_assert(false, "BasicMultiLayerRBFTest1D: Invalid variable NX(NX neither 2 nor 3)");
                  }
               }
            }
            if (!testrbfunit_searcherr(&mody0, &mody1, n, ny, errtype, &b1, &delta)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            if (nx == 2) {
               rbfgridcalc2(&s, &gpgx0, n, &gpgx1, n, &gy);
               for (i = 0; i < n; i++) {
                  mody1.xyR[i][0] = gy.xyR[i][0];
               }
            }
            if (!testrbfunit_searcherr(&mody0, &mody1, n, ny, errtype, &b1, &delta)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               x.xR[j] = gp.xyR[i][j];
            }
            rbfcalc(&s, &x, &y);
            for (j = 0; j < ny; j++) {
               mody1.xyR[i][j] = y.xR[j];
            }
         }
         if (!testrbfunit_searcherr(&mody0, &mody1, n, ny, errtype, &b1, &delta)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               x.xR[j] = gp.xyR[i][j];
            }
            rbfcalcbuf(&s, &x, &y);
            for (j = 0; j < ny; j++) {
               mody1.xyR[i][j] = y.xR[j];
            }
         }
         if (!testrbfunit_searcherr(&mody0, &mody1, n, ny, errtype, &b1, &delta)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         q /= 2;
         nlayers++;
         if (errtype == 1 && q * f2 <= 1.0) {
            errtype = 2;
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This function tests special cases:
// * uninitialized RBF model will correctly return zero values
// * RBF correctly handles 1 or 2 distinct points
// * when  we have many uniformly spaced points and one outlier, filter which
//   is applied to radii, makes all radii equal (RBF-QNN).
// * RBF-ML with NLayers == 0 gives linear model
// * Hierarchical RBF with NLayers == 0 gives linear model
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
static bool testrbfunit_specialtest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t t;
   ae_int_t termtype;
   double errtol;
   ae_int_t tmpnx;
   ae_int_t tmpny;
   ae_int_t tmpnc;
   double sx;
   double z;
   double va;
   double vb;
   double vc;
   double vd;
   ae_int_t modelversion;
   double vv;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(vf, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(xwr, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   errtol = 1.0E-9;
   Ok = true;
// Create model in the default state (no parameters/points specified).
// With probability 0.5 we do one of the following:
// * test that default state of the model is a zero model (all Calc()
//   functions return zero)
// * call RBFBuildModel() (without specifying anything) and test  that
//   all Calc() functions return zero.
//
// NOTE: because NX varies between 1 and 4, both V1 (old) and V2 RBFs
//       are tested.
   for (nx = 1; nx <= 4; nx++) {
      for (ny = 1; ny <= 3; ny++) {
         rbfcreate(nx, ny, &s);
         if (randombool()) {
            rbfbuildmodel(&s, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
         ae_vector_set_length(&x, nx);
         ae_vector_set_length(&y, 1);
         for (i = 0; i < nx; i++) {
            x.xR[i] = randommid();
         }
         rbfcalc(&s, &x, &y);
         if (y.cnt != ny) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < ny; i++) {
            if (y.xR[i] != 0.0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
// Create default model with 1 point and different types of linear term.
// Test algorithm on such dataset.
//
// NOTE: because NX varies between 1 and 4, both V1 (old) and V2 RBFs
//       are tested.
   for (nx = 1; nx <= 4; nx++) {
      for (ny = 1; ny <= 3; ny++) {
         rbfcreate(nx, ny, &s);
         for (termtype = 0; termtype <= 1; termtype++) {
            if (termtype == 0) {
               rbfsetlinterm(&s);
            }
            if (termtype == 1) {
               rbfsetconstterm(&s);
            }
            ae_matrix_set_length(&xy, 1, nx + ny);
            for (i = 0; i < nx + ny; i++) {
               xy.xyR[0][i] = randommid();
            }
            rbfsetpoints(&s, &xy, 1);
            rbfbuildmodel(&s, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         // First, test that model exactly reproduces our dataset in the specified point
            ae_vector_set_length(&x, nx);
            for (i = 0; i < nx; i++) {
               x.xR[i] = xy.xyR[0][i];
            }
            rbfcalc(&s, &x, &y);
            if (y.cnt != ny) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < ny; i++) {
               if (!NearAtR(y.xR[i], xy.xyR[0][nx + i], errtol)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         // Second, test that model is constant
            for (i = 0; i < nx; i++) {
               x.xR[i] = randommid();
            }
            rbfcalc(&s, &x, &y);
            if (y.cnt != ny) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < ny; i++) {
               if (!NearAtR(y.xR[i], xy.xyR[0][nx + i], errtol)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      }
   }
// Create model with 2 points and different types of linear term.
// Test algorithm on such dataset.
   for (nx = 2; nx <= 3; nx++) {
      for (ny = 1; ny <= 3; ny++) {
         rbfcreate(nx, ny, &s);
         for (termtype = 0; termtype <= 1; termtype++) {
            if (termtype == 0) {
               rbfsetlinterm(&s);
            }
            if (termtype == 1) {
               rbfsetconstterm(&s);
            }
            if (termtype == 2) {
               rbfsetzeroterm(&s);
            }
            ae_matrix_set_length(&xy, 2, nx + ny);
            for (i = 0; i < nx + ny; i++) {
               xy.xyR[0][i] = randommid();
            }
            for (i = 0; i < nx + ny; i++) {
               xy.xyR[1][i] = xy.xyR[0][i] + 1.0;
            }
            rbfsetpoints(&s, &xy, 2);
            rbfbuildmodel(&s, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            for (j = 0; j <= 1; j++) {
               ae_vector_set_length(&x, nx);
               for (i = 0; i < nx; i++) {
                  x.xR[i] = xy.xyR[j][i];
               }
               rbfcalc(&s, &x, &y);
               if (y.cnt != ny) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
               for (i = 0; i < ny; i++) {
                  if (!NearAtR(y.xR[i], xy.xyR[j][nx + i], errtol)) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
               }
            }
         }
      }
   }
// Generate a set of points (xi,yi) = (SX*i,0), and one
// outlier (x_far,y_far) == (-1000*SX,0).
//
// Radii filtering should place a bound on the radius of outlier.
   for (nx = 2; nx <= 3; nx++) {
      for (ny = 1; ny <= 3; ny++) {
         sx = exp(-5.0 + 10.0 * randomreal());
         rbfcreate(nx, ny, &s);
         ae_matrix_set_length(&xy, 20, nx + ny);
         for (i = 0; i < xy.rows; i++) {
            xy.xyR[i][0] = sx * i;
            for (j = 1; j < nx; j++) {
               xy.xyR[i][j] = 0.0;
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = randomreal();
            }
         }
         xy.xyR[xy.rows - 1][0] = -1000 * sx;
         rbfsetpoints(&s, &xy, xy.rows);
      // Try random Z from [1,5]
         z = 1.0 + randomreal() * 4.0;
         rbfsetalgoqnn(&s, 1.0, z);
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         rbfunpack(&s, &tmpnx, &tmpny, &xwr, &tmpnc, &v, &modelversion);
         if (tmpnx != nx || tmpny != ny || tmpnc != xy.rows || xwr.cols != nx + ny + 1 || xwr.rows != tmpnc || modelversion != 1) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < tmpnc - 1; i++) {
            if (!NearAtR(xwr.xyR[i][nx + ny], sx, errtol)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
         if (!NearAtR(xwr.xyR[tmpnc - 1][nx + ny], z * sx, errtol)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   }
// RBF-ML with NLayers == 0 gives us linear model.
//
// In order to perform this test, we use test function which
// is perfectly linear and see whether RBF model is able to
// reproduce such function.
   n = 5;
   for (ny = 1; ny <= 3; ny++) {
      va = randommid();
      vb = randommid();
      vc = randommid();
      vd = randommid();
   // Test NX == 2.
   // Generate linear function using random coefficients VA/VB/VC.
   // Function is K-dimensional vector-valued, each component has slightly
   // different coefficients.
      ae_matrix_set_length(&xy, n * n, 2 + ny);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            xy.xyR[n * i + j][0] = (double)i;
            xy.xyR[n * i + j][1] = (double)j;
            for (k = 0; k < ny; k++) {
               xy.xyR[n * i + j][2 + k] = (va + 0.1 * k) * i + (vb + 0.2 * k) * j + (vc + 0.3 * k);
            }
         }
      }
      rbfcreate(2, ny, &s);
      rbfsetpoints(&s, &xy, n * n);
      rbfsetalgomultilayer(&s, 1.0, 0, 0.01);
      rbfbuildmodel(&s, &rep);
      if (rep.terminationtype <= 0) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      ae_vector_set_length(&x, 2);
      x.xR[0] = (n - 1) * randomreal();
      x.xR[1] = (n - 1) * randomreal();
      if (ny == 1 && !NearAtR(rbfcalc2(&s, x.xR[0], x.xR[1]), va * x.xR[0] + vb * x.xR[1] + vc, errtol)) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      rbfcalc(&s, &x, &y);
      for (k = 0; k < ny; k++) {
         if (!NearAtR(y.xR[k], (va + 0.1 * k) * x.xR[0] + (vb + 0.2 * k) * x.xR[1] + (vc + 0.3 * k), errtol)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   // Test NX == 3.
   // Generate linear function using random coefficients VA/VB/VC/VC.
   // Function is K-dimensional vector-valued, each component has slightly
   // different coefficients.
      ae_matrix_set_length(&xy, n * n * n, 3 + ny);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            for (t = 0; t < n; t++) {
               xy.xyR[n * n * i + n * j + t][0] = (double)i;
               xy.xyR[n * n * i + n * j + t][1] = (double)j;
               xy.xyR[n * n * i + n * j + t][2] = (double)t;
               for (k = 0; k < ny; k++) {
                  xy.xyR[n * n * i + n * j + t][3 + k] = (va + 0.1 * k) * i + (vb + 0.2 * k) * j + (vc + 0.3 * k) * t + (vd + 0.4 * k);
               }
            }
         }
      }
      rbfcreate(3, ny, &s);
      rbfsetpoints(&s, &xy, n * n * n);
      rbfsetalgomultilayer(&s, 1.0, 0, 0.01);
      rbfbuildmodel(&s, &rep);
      if (rep.terminationtype <= 0) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      ae_vector_set_length(&x, 3);
      x.xR[0] = (n - 1) * randomreal();
      x.xR[1] = (n - 1) * randomreal();
      x.xR[2] = (n - 1) * randomreal();
      if (ny == 1 && !NearAtR(rbfcalc3(&s, x.xR[0], x.xR[1], x.xR[2]), va * x.xR[0] + vb * x.xR[1] + vc * x.xR[2] + vd, errtol)) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      rbfcalc(&s, &x, &y);
      for (k = 0; k < ny; k++) {
         if (!NearAtR(y.xR[k], (va + 0.1 * k) * x.xR[0] + (vb + 0.2 * k) * x.xR[1] + (vc + 0.3 * k) * x.xR[2] + (vd + 0.4 * k), errtol)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   }
// HierarchicalRBF with NLayers == 0 gives us linear model.
//
// In order to perform this test, we use test function which
// is perfectly linear and see whether RBF model is able to
// reproduce such function.
   n = 15;
   for (nx = 1; nx <= 5; nx++) {
      for (ny = 1; ny <= 3; ny++) {
         ae_matrix_set_length(&vf, ny, nx + 1);
         for (i = 0; i < ny; i++) {
            for (j = 0; j <= nx; j++) {
               vf.xyR[i][j] = randommid();
            }
         }
         ae_matrix_set_length(&xy, n, nx + ny);
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = randomreal();
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = vf.xyR[j][nx];
               for (k = 0; k < nx; k++) {
                  xy.xyR[i][nx + j] += vf.xyR[j][k] * xy.xyR[i][k];
               }
            }
         }
         rbfcreate(nx, ny, &s);
         rbfsetpoints(&s, &xy, n);
         rbfsetalgohierarchical(&s, 1.0, 0, 0.0);
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         ae_vector_set_length(&x, nx);
         for (i = 0; i < nx; i++) {
            x.xR[i] = randomreal();
         }
         rbfcalc(&s, &x, &y);
         for (k = 0; k < ny; k++) {
            vv = vf.xyR[k][nx];
            for (j = 0; j < nx; j++) {
               vv += vf.xyR[k][j] * x.xR[j];
            }
            Ok = Ok && NearAtR(vv, y.xR[k], errtol);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing basic functionality of RBF module on regular grids.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
static bool testrbfunit_basicrbftest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t k2;
   ae_int_t linterm;
   ae_int_t np;
   double sx;
   double sy;
   double zx;
   double px;
   double zy;
   double py;
   double q;
   double z;
   ae_int_t unx;
   ae_int_t uny;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   ae_int_t fidx;
   double eps;
   ae_int_t modelversion;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewObj(rbfcalcbuffer, calcbuf);
   NewVector(point, 0, DT_REAL);
   NewMatrix(gp, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(gy, 0, 0, DT_REAL);
   NewMatrix(xwr, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewVector(gpgx0, 0, DT_REAL);
   NewVector(gpgx1, 0, DT_REAL);
   zx = 10.0;
   px = 15.0;
   zy = 10.0;
   py = 15.0;
   eps = 1.0E-6;
// Problem types:
// * 2 and 3-dimensional problems
// * problems with zero, constant, linear terms
// * different scalings of X and Y values (1.0, 1E-15, 1E+15)
// * regular grids different grid sizes (from 2 to 4 points for each dimension)
//
// We check that:
// * RBF model correctly reproduces function value (testes with different Calc() functions)
// * unpacked model containt correct radii
// * linear term has correct form
   for (nx = 2; nx <= 3; nx++) {
      for (ny = 1; ny <= 3; ny++) {
         for (linterm = 1; linterm <= 3; linterm++) {
         // prepare test problem
            sx = pow(zx, px * (randominteger(3) - 1));
            sy = pow(zy, py * (randominteger(3) - 1));
            ae_vector_set_length(&x, nx);
            ae_vector_set_length(&y, ny);
            ae_vector_set_length(&point, nx);
            rbfcreate(nx, ny, &s);
            rbfsetcond(&s, testrbfunit_heps, testrbfunit_heps, testrbfunit_mxits);
            q = 0.25 + randomreal();
            z = 4.5 + randomreal();
            rbfsetalgoqnn(&s, q, z);
            if (linterm == 1) {
               rbfsetlinterm(&s);
            }
            if (linterm == 2) {
               rbfsetconstterm(&s);
            }
            if (linterm == 3) {
               rbfsetzeroterm(&s);
            }
         // start points for grid
            for (i = 0; i < nx; i++) {
               point.xR[i] = sx * randommid();
            }
         // 2-dimensional test problem
            if (nx == 2) {
               for (k0 = 2; k0 <= 4; k0++) {
                  for (k1 = 2; k1 <= 4; k1++) {
                     np = k0 * k1;
                     ae_matrix_set_length(&gp, np, nx + ny);
                  // create grid
                     for (i = 0; i < k0; i++) {
                        for (j = 0; j < k1; j++) {
                           gp.xyR[i * k1 + j][0] = point.xR[0] + sx * i;
                           gp.xyR[i * k1 + j][1] = point.xR[1] + sx * j;
                           for (k = 0; k < ny; k++) {
                              gp.xyR[i * k1 + j][nx + k] = sy * randommid();
                           }
                        }
                     }
                     rbfsetpoints(&s, &gp, np);
                     rbfbuildmodel(&s, &rep);
                     rbfcreatecalcbuffer(&s, &calcbuf);
                     if (ny == 1) {
                        ae_vector_set_length(&gpgx0, k0);
                        ae_vector_set_length(&gpgx1, k1);
                        for (i = 0; i < k0; i++) {
                           gpgx0.xR[i] = point.xR[0] + sx * i;
                        }
                        for (i = 0; i < k1; i++) {
                           gpgx1.xR[i] = point.xR[1] + sx * i;
                        }
                        rbfgridcalc2(&s, &gpgx0, k0, &gpgx1, k1, &gy);
                        for (i = 0; i < k0; i++) {
                           for (j = 0; j < k1; j++) {
                              if (!NearAtR(gy.xyR[i][j], gp.xyR[i * k1 + j][nx], sy * eps)) {
                                 Ok = false;
                                 ae_frame_leave();
                                 return Ok;
                              }
                           }
                        }
                     }
                     for (i = 0; i < np; i++) {
                     // For each row we randomly choose a function to test
                     // and call it. We do not call multiple functions per
                     // row because carry-over effects may mask errors in
                     // some function (say, it is possible that function
                     // simply returns results from previous call of some
                     // other function which were stored in the RBF model;
                     // in this case, previous call with same parameters
                     // may hide deficiencies in the function).
                        x.xR[0] = gp.xyR[i][0];
                        x.xR[1] = gp.xyR[i][1];
                        fidx = randominteger(4);
                        if (fidx == 0 && ny == 1) {
                           y.xR[0] = rbfcalc2(&s, x.xR[0], x.xR[1]);
                           if (!NearAtR(gp.xyR[i][nx], y.xR[0], sy * eps)) {
                              Ok = false;
                              ae_frame_leave();
                              return Ok;
                           }
                        }
                        if (fidx == 1) {
                           rbfcalc(&s, &x, &y);
                           for (j = 0; j < ny; j++) {
                              if (!NearAtR(gp.xyR[i][nx + j], y.xR[j], sy * eps)) {
                                 Ok = false;
                                 ae_frame_leave();
                                 return Ok;
                              }
                           }
                        }
                        if (fidx == 2) {
                           rbfcalcbuf(&s, &x, &y);
                           for (j = 0; j < ny; j++) {
                              if (!NearAtR(gp.xyR[i][nx + j], y.xR[j], sy * eps)) {
                                 Ok = false;
                                 ae_frame_leave();
                                 return Ok;
                              }
                           }
                        }
                        if (fidx == 3) {
                           rbftscalcbuf(&s, &calcbuf, &x, &y);
                           for (j = 0; j < ny; j++) {
                              if (!NearAtR(gp.xyR[i][nx + j], y.xR[j], sy * eps)) {
                                 Ok = false;
                                 ae_frame_leave();
                                 return Ok;
                              }
                           }
                        }
                     }
                  // test for RBFUnpack
                     rbfunpack(&s, &unx, &uny, &xwr, &np, &v, &modelversion);
                     if (nx != unx || ny != uny || xwr.rows != np || xwr.cols != nx + ny + 1 || v.rows != ny || v.cols != nx + 1 || modelversion != 1) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                     for (i = 0; i < np; i++) {
                        if (!NearAtR(xwr.xyR[i][unx + uny], q * sx, sx * eps)) {
                           Ok = false;
                           ae_frame_leave();
                           return Ok;
                        }
                     }
                     if (linterm == 2) {
                        for (i = 0; i < unx; i++) {
                           for (j = 0; j < uny; j++) {
                              if (v.xyR[j][i] != 0.0) {
                                 Ok = false;
                                 ae_frame_leave();
                                 return Ok;
                              }
                           }
                        }
                     }
                     if (linterm == 3) {
                        for (i = 0; i <= unx; i++) {
                           for (j = 0; j < uny; j++) {
                              if (v.xyR[j][i] != 0.0) {
                                 Ok = false;
                                 ae_frame_leave();
                                 return Ok;
                              }
                           }
                        }
                     }
                  }
               }
            }
         // 3-dimensional test problems
            if (nx == 3) {
               for (k0 = 2; k0 <= 4; k0++) {
                  for (k1 = 2; k1 <= 4; k1++) {
                     for (k2 = 2; k2 <= 4; k2++) {
                        np = k0 * k1 * k2;
                        ae_matrix_set_length(&gp, np, nx + ny);
                     // create grid
                        for (i = 0; i < k0; i++) {
                           for (j = 0; j < k1; j++) {
                              for (k = 0; k < k2; k++) {
                                 gp.xyR[(i * k1 + j) * k2 + k][0] = point.xR[0] + sx * i;
                                 gp.xyR[(i * k1 + j) * k2 + k][1] = point.xR[1] + sx * j;
                                 gp.xyR[(i * k1 + j) * k2 + k][2] = point.xR[2] + sx * k;
                                 for (l = 0; l < ny; l++) {
                                    gp.xyR[(i * k1 + j) * k2 + k][nx + l] = sy * randommid();
                                 }
                              }
                           }
                        }
                        rbfsetpoints(&s, &gp, np);
                        rbfbuildmodel(&s, &rep);
                        rbfcreatecalcbuffer(&s, &calcbuf);
                        for (i = 0; i < np; i++) {
                        // For each row we randomly choose a function to test
                        // and call it. We do not call multiple functions per
                        // row because carry-over effects may mask errors in
                        // some function (say, it is possible that function
                        // simply returns results from previous call of some
                        // other function which were stored in the RBF model;
                        // in this case, previous call with same parameters
                        // may hide deficiencies in the function).
                           x.xR[0] = gp.xyR[i][0];
                           x.xR[1] = gp.xyR[i][1];
                           x.xR[2] = gp.xyR[i][2];
                           fidx = randominteger(4);
                           if (fidx == 0 && ny == 1) {
                              y.xR[0] = rbfcalc3(&s, x.xR[0], x.xR[1], x.xR[2]);
                              if (!NearAtR(gp.xyR[i][nx], y.xR[0], sy * eps)) {
                                 Ok = false;
                                 ae_frame_leave();
                                 return Ok;
                              }
                           }
                           if (fidx == 1) {
                              rbfcalc(&s, &x, &y);
                              for (j = 0; j < ny; j++) {
                                 if (!NearAtR(gp.xyR[i][nx + j], y.xR[j], sy * eps)) {
                                    Ok = false;
                                    ae_frame_leave();
                                    return Ok;
                                 }
                              }
                           }
                           if (fidx == 2) {
                              rbfcalcbuf(&s, &x, &y);
                              for (j = 0; j < ny; j++) {
                                 if (!NearAtR(gp.xyR[i][nx + j], y.xR[j], sy * eps)) {
                                    Ok = false;
                                    ae_frame_leave();
                                    return Ok;
                                 }
                              }
                           }
                           if (fidx == 3) {
                              rbftscalcbuf(&s, &calcbuf, &x, &y);
                              for (j = 0; j < ny; j++) {
                                 if (!NearAtR(gp.xyR[i][nx + j], y.xR[j], sy * eps)) {
                                    Ok = false;
                                    ae_frame_leave();
                                    return Ok;
                                 }
                              }
                           }
                        }
                     // test for RBFUnpack
                        rbfunpack(&s, &unx, &uny, &xwr, &np, &v, &modelversion);
                        if (nx != unx || ny != uny || xwr.rows != np || xwr.cols != nx + ny + 1 || v.rows != ny || v.cols != nx + 1 || modelversion != 1) {
                           Ok = false;
                           ae_frame_leave();
                           return Ok;
                        }
                        for (i = 0; i < np; i++) {
                           if (!NearAtR(xwr.xyR[i][unx + uny], q * sx, sx * eps)) {
                              Ok = false;
                              ae_frame_leave();
                              return Ok;
                           }
                        }
                        if (linterm == 2) {
                           for (i = 0; i < unx; i++) {
                              for (j = 0; j < uny; j++) {
                                 if (v.xyR[j][i] != 0.0) {
                                    Ok = false;
                                    ae_frame_leave();
                                    return Ok;
                                 }
                              }
                           }
                        }
                        if (linterm == 3) {
                           for (i = 0; i <= unx; i++) {
                              for (j = 0; j < uny; j++) {
                                 if (v.xyR[j][i] != 0.0) {
                                    Ok = false;
                                    ae_frame_leave();
                                    return Ok;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Function for testing RBF module on irregular grids.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
static bool testrbfunit_irregularrbftest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t k2;
   ae_int_t linterm;
   ae_int_t np;
   double sx;
   double sy;
   double zx;
   double px;
   double zy;
   double py;
   double q;
   double z;
   double noiselevel;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   double eps;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewVector(point, 0, DT_REAL);
   NewMatrix(gp, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(gy, 0, 0, DT_REAL);
   zx = 10.0;
   px = 15.0;
   zy = 10.0;
   py = 15.0;
   noiselevel = 0.1;
   eps = 1.0E-6;
// Problem types:
// * 2 and 3-dimensional problems
// * problems with zero, constant, linear terms
// * different scalings of X and Y values (1.0, 1E-15, 1E+15)
// * noisy grids, which are just regular grids with different grid sizes
//   (from 2 to 4 points for each dimension) and moderate amount of random
//   noise added to all node positions.
//
// We check that:
// * RBF model correctly reproduces function value (testes with different Calc() functions)
   for (nx = 2; nx <= 3; nx++) {
      for (ny = 1; ny <= 3; ny++) {
         for (linterm = 1; linterm <= 3; linterm++) {
         // prepare test problem
            sx = pow(zx, px * (randominteger(3) - 1));
            sy = pow(zy, py * (randominteger(3) - 1));
            ae_vector_set_length(&x, nx);
            ae_vector_set_length(&y, ny);
            ae_vector_set_length(&point, nx);
            rbfcreate(nx, ny, &s);
            rbfsetcond(&s, testrbfunit_heps, testrbfunit_heps, testrbfunit_mxits);
            q = 0.25 + randomreal();
            z = 4.5 + randomreal();
            rbfsetalgoqnn(&s, q, z);
            if (linterm == 1) {
               rbfsetlinterm(&s);
            }
            if (linterm == 2) {
               rbfsetconstterm(&s);
            }
            if (linterm == 3) {
               rbfsetzeroterm(&s);
            }
         // start points for grid
            for (i = 0; i < nx; i++) {
               point.xR[i] = sx * randommid();
            }
         // 2-dimensional test problems
            if (nx == 2) {
               for (k0 = 2; k0 <= 4; k0++) {
                  for (k1 = 2; k1 <= 4; k1++) {
                     np = k0 * k1;
                     ae_matrix_set_length(&gp, np, nx + ny);
                  // create grid
                     for (i = 0; i < k0; i++) {
                        for (j = 0; j < k1; j++) {
                           gp.xyR[i * k1 + j][0] = point.xR[0] + sx * i + noiselevel * sx * randommid();
                           gp.xyR[i * k1 + j][1] = point.xR[1] + sx * j + noiselevel * sx * randommid();
                           for (k = 0; k < ny; k++) {
                              gp.xyR[i * k1 + j][nx + k] = sy * randommid();
                           }
                        }
                     }
                     rbfsetpoints(&s, &gp, np);
                     rbfbuildmodel(&s, &rep);
                     for (i = 0; i < np; i++) {
                        x.xR[0] = gp.xyR[i][0];
                        x.xR[1] = gp.xyR[i][1];
                        if (ny == 1) {
                           y.xR[0] = rbfcalc2(&s, x.xR[0], x.xR[1]);
                           if (!NearAtR(gp.xyR[i][nx], y.xR[0], sy * eps)) {
                              Ok = false;
                              ae_frame_leave();
                              return Ok;
                           }
                        }
                        rbfcalc(&s, &x, &y);
                        for (j = 0; j < ny; j++) {
                           if (!NearAtR(gp.xyR[i][nx + j], y.xR[j], sy * eps)) {
                              Ok = false;
                              ae_frame_leave();
                              return Ok;
                           }
                        }
                        rbfcalcbuf(&s, &x, &y);
                        for (j = 0; j < ny; j++) {
                           if (!NearAtR(gp.xyR[i][nx + j], y.xR[j], sy * eps)) {
                              Ok = false;
                              ae_frame_leave();
                              return Ok;
                           }
                        }
                     }
                  }
               }
            }
         // 2-dimensional test problems
            if (nx == 3) {
               for (k0 = 2; k0 <= 4; k0++) {
                  for (k1 = 2; k1 <= 4; k1++) {
                     for (k2 = 2; k2 <= 4; k2++) {
                        np = k0 * k1 * k2;
                        ae_matrix_set_length(&gp, np, nx + ny);
                     // create grid
                        for (i = 0; i < k0; i++) {
                           for (j = 0; j < k1; j++) {
                              for (k = 0; k < k2; k++) {
                                 gp.xyR[(i * k1 + j) * k2 + k][0] = point.xR[0] + sx * i + noiselevel * sx * randommid();
                                 gp.xyR[(i * k1 + j) * k2 + k][1] = point.xR[1] + sx * j + noiselevel * sx * randommid();
                                 gp.xyR[(i * k1 + j) * k2 + k][2] = point.xR[2] + sx * k + noiselevel * sx * randommid();
                                 for (l = 0; l < ny; l++) {
                                    gp.xyR[(i * k1 + j) * k2 + k][nx + l] = sy * randommid();
                                 }
                              }
                           }
                        }
                        rbfsetpoints(&s, &gp, np);
                        rbfbuildmodel(&s, &rep);
                        for (i = 0; i < np; i++) {
                           x.xR[0] = gp.xyR[i][0];
                           x.xR[1] = gp.xyR[i][1];
                           x.xR[2] = gp.xyR[i][2];
                           if (ny == 1) {
                              y.xR[0] = rbfcalc3(&s, x.xR[0], x.xR[1], x.xR[2]);
                              if (!NearAtR(gp.xyR[i][nx], y.xR[0], sy * eps)) {
                                 Ok = false;
                                 ae_frame_leave();
                                 return Ok;
                              }
                           }
                           rbfcalc(&s, &x, &y);
                           for (j = 0; j < ny; j++) {
                              if (!NearAtR(gp.xyR[i][nx + j], y.xR[j], sy * eps)) {
                                 Ok = false;
                                 ae_frame_leave();
                                 return Ok;
                              }
                           }
                           rbfcalcbuf(&s, &x, &y);
                           for (j = 0; j < ny; j++) {
                              if (!NearAtR(gp.xyR[i][nx + j], y.xR[j], sy * eps)) {
                                 Ok = false;
                                 ae_frame_leave();
                                 return Ok;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// The test does  check, that  algorithm  can build linear model for the data
// sets, when Y depends on X linearly.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
static bool testrbfunit_linearitymodelrbftest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t k2;
   ae_int_t linterm;
   ae_int_t np;
   double sx;
   double sy;
   double zx;
   double px;
   double zy;
   double py;
   double q;
   double z;
   ae_int_t unx;
   ae_int_t uny;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   ae_int_t modelversion;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewVector(point, 0, DT_REAL);
   NewVector(a, 0, DT_REAL);
   NewMatrix(gp, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(xwr, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   zx = 10.0;
   px = 15.0;
   zy = 10.0;
   py = 15.0;
   ny = 1;
   for (nx = 2; nx <= 3; nx++) {
      for (linterm = 1; linterm <= 3; linterm++) {
      // prepare test problem
         sx = pow(zx, px * (randominteger(3) - 1));
         sy = pow(zy, py * (randominteger(3) - 1));
         ae_vector_set_length(&x, nx);
         ae_vector_set_length(&y, ny);
         ae_vector_set_length(&point, nx);
         rbfcreate(nx, ny, &s);
         q = 0.25 + randomreal();
         z = 4.5 + randomreal();
         rbfsetalgoqnn(&s, q, z);
         ae_vector_set_length(&a, nx + 1);
         if (linterm == 1) {
            rbfsetlinterm(&s);
            for (i = 0; i < nx; i++) {
               a.xR[i] = sy * randommid() / sx;
            }
            a.xR[nx] = sy * randommid();
         }
         if (linterm == 2) {
            rbfsetconstterm(&s);
            for (i = 0; i < nx; i++) {
               a.xR[i] = 0.0;
            }
            a.xR[nx] = sy * randommid();
         }
         if (linterm == 3) {
            rbfsetzeroterm(&s);
            for (i = 0; i <= nx; i++) {
               a.xR[i] = 0.0;
            }
         }
      // start points for grid
         for (i = 0; i < nx; i++) {
            point.xR[i] = sx * randommid();
         }
         if (nx == 2) {
            for (k0 = 2; k0 <= 4; k0++) {
               for (k1 = 2; k1 <= 4; k1++) {
                  np = k0 * k1;
                  ae_matrix_set_length(&gp, np, nx + ny);
               // create grid
                  for (i = 0; i < k0; i++) {
                     for (j = 0; j < k1; j++) {
                        gp.xyR[i * k1 + j][0] = point.xR[0] + sx * i;
                        gp.xyR[i * k1 + j][1] = point.xR[1] + sx * j;
                        gp.xyR[i * k1 + j][nx] = a.xR[nx];
                        for (k = 0; k < nx; k++) {
                           gp.xyR[i * k1 + j][nx] += gp.xyR[i * k1 + j][k] * a.xR[k];
                        }
                     }
                  }
                  rbfsetpoints(&s, &gp, np);
                  rbfbuildmodel(&s, &rep);
               // test for RBFUnpack
                  rbfunpack(&s, &unx, &uny, &xwr, &np, &v, &modelversion);
                  if (nx != unx || ny != uny || xwr.rows != np || xwr.cols != nx + ny + 1 || v.rows != ny || v.cols != nx + 1 || modelversion != 1) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
                  for (i = 0; i < nx; i++) {
                     if (!NearAtR(v.xyR[0][i], a.xR[i], sy / sx * testrbfunit_tol)) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  }
                  if (!NearAtR(v.xyR[0][nx], a.xR[nx], sy * testrbfunit_tol)) {
                     Ok = false;
                     ae_frame_leave();
                     return Ok;
                  }
                  for (i = 0; i < np; i++) {
                     if (!SmallAtR(xwr.xyR[i][unx], sy * testrbfunit_tol)) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                  }
               }
            }
         }
         if (nx == 3) {
            for (k0 = 2; k0 <= 4; k0++) {
               for (k1 = 2; k1 <= 4; k1++) {
                  for (k2 = 2; k2 <= 4; k2++) {
                     np = k0 * k1 * k2;
                     ae_matrix_set_length(&gp, np, nx + ny);
                  // create grid
                     for (i = 0; i < k0; i++) {
                        for (j = 0; j < k1; j++) {
                           for (k = 0; k < k2; k++) {
                              gp.xyR[(i * k1 + j) * k2 + k][0] = point.xR[0] + sx * i;
                              gp.xyR[(i * k1 + j) * k2 + k][1] = point.xR[1] + sx * j;
                              gp.xyR[(i * k1 + j) * k2 + k][2] = point.xR[2] + sx * k;
                              gp.xyR[(i * k1 + j) * k2 + k][nx] = a.xR[nx];
                              for (l = 0; l < nx; l++) {
                                 gp.xyR[(i * k1 + j) * k2 + k][nx] += gp.xyR[(i * k1 + j) * k2 + k][l] * a.xR[l];
                              }
                           }
                        }
                     }
                     rbfsetpoints(&s, &gp, np);
                     rbfbuildmodel(&s, &rep);
                  // test for RBFUnpack
                     rbfunpack(&s, &unx, &uny, &xwr, &np, &v, &modelversion);
                     if (nx != unx || ny != uny || xwr.rows != np || xwr.cols != nx + ny + 1 || v.rows != ny || v.cols != nx + 1 || modelversion != 1) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                     for (i = 0; i < nx; i++) {
                        if (!NearAtR(v.xyR[0][i], a.xR[i], sy / sx * testrbfunit_tol)) {
                           Ok = false;
                           ae_frame_leave();
                           return Ok;
                        }
                     }
                     if (!NearAtR(v.xyR[0][nx], a.xR[nx], sy * testrbfunit_tol)) {
                        Ok = false;
                        ae_frame_leave();
                        return Ok;
                     }
                     for (i = 0; i < np; i++) {
                        if (!SmallAtR(xwr.xyR[i][unx], sy * testrbfunit_tol)) {
                           Ok = false;
                           ae_frame_leave();
                           return Ok;
                        }
                     }
                  }
               }
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This function tests serialization
// ALGLIB: Copyright 02.02.2012 by Sergey Bochkanov
static bool testrbfunit_serializationtest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t k2;
   ae_int_t i;
   ae_int_t i0;
   ae_int_t i1;
   ae_int_t i2;
   ae_int_t j;
   ae_int_t k;
   double rbase;
   ae_int_t nlayers;
   ae_int_t bf;
   ae_int_t gridsize;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfmodel, s2);
   NewObj(rbfreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(testpoint, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(scalevec, 0, DT_REAL);
   Ok = true;
// This function generates random 2 or 3 dimensional problem,
// builds RBF model (QNN is used), serializes/unserializes it, then compares
// models by calculating model value at some random point.
//
// Additionally we test that new model (one which was restored
// after serialization) has lost all model construction settings,
// i.e. if we call RBFBuildModel() on a NEW model, we will get
// empty (zero) model.
   for (nx = 2; nx <= 3; nx++) {
      for (ny = 1; ny <= 2; ny++) {
      // prepare test problem
         rbfcreate(nx, ny, &s);
         rbfsetalgoqnn(&s, 1.0, 5.0);
         rbfsetlinterm(&s);
         if (nx == 2) {
         // 2-dimensional problem
            k0 = 2 + randominteger(4);
            k1 = 2 + randominteger(4);
            ae_matrix_set_length(&xy, k0 * k1, nx + ny);
            for (i0 = 0; i0 < k0; i0++) {
               for (i1 = 0; i1 < k1; i1++) {
                  xy.xyR[i0 * k1 + i1][0] = i0 + 0.1 * randommid();
                  xy.xyR[i0 * k1 + i1][1] = i1 + 0.1 * randommid();
                  for (j = 0; j < ny; j++) {
                     xy.xyR[i0 * k1 + i1][nx + j] = randommid();
                  }
               }
            }
            ae_vector_set_length(&testpoint, nx);
            testpoint.xR[0] = randomreal() * (k0 - 1);
            testpoint.xR[1] = randomreal() * (k1 - 1);
         } else {
         // 3-dimensional problem
            k0 = 2 + randominteger(4);
            k1 = 2 + randominteger(4);
            k2 = 2 + randominteger(4);
            ae_matrix_set_length(&xy, k0 * k1 * k2, nx + ny);
            for (i0 = 0; i0 < k0; i0++) {
               for (i1 = 0; i1 < k1; i1++) {
                  for (i2 = 0; i2 < k2; i2++) {
                     xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][0] = i0 + 0.1 * randommid();
                     xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][1] = i1 + 0.1 * randommid();
                     xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][2] = i2 + 0.1 * randommid();
                     for (j = 0; j < ny; j++) {
                        xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][nx + j] = randommid();
                     }
                  }
               }
            }
            ae_vector_set_length(&testpoint, nx);
            testpoint.xR[0] = randomreal() * (k0 - 1);
            testpoint.xR[1] = randomreal() * (k1 - 1);
            testpoint.xR[2] = randomreal() * (k2 - 1);
         }
         rbfsetpoints(&s, &xy, xy.rows);
      // Build model, serialize, compare
         rbfbuildmodel(&s, &rep);
         {
         // This code passes data structure through serializers
         // (serializes it to string and loads back)
            ae_frame _local_frame_block;
            ae_frame_make(&_local_frame_block);
            NewSerializer(_local_serializer);
            ae_serializer_alloc_start(&_local_serializer);
            rbfalloc(&_local_serializer, &s);
            ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
            NewBlock(_local_dynamic_block, _local_ssize + 1);
            ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            rbfserialize(&_local_serializer, &s);
            ae_serializer_stop(&_local_serializer);
            ae_serializer_init(&_local_serializer);
            ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            rbfunserialize(&_local_serializer, &s2);
            ae_serializer_stop(&_local_serializer);
            ae_frame_leave();
         }
         rbfcalc(&s, &testpoint, &y0);
         rbfcalc(&s2, &testpoint, &y1);
         if (y0.cnt != ny || y1.cnt != ny) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (j = 0; j < ny; j++) {
            if (y0.xR[j] != y1.xR[j]) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      // Check that calling RBFBuildModel() on S2 (new model)
      // will result in construction of zero model, i.e. test
      // that serialization restores model, but not dataset
      // which was used to build model.
         rbfbuildmodel(&s2, &rep);
         rbfcalc(&s2, &testpoint, &y1);
         if (y1.cnt != ny) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (j = 0; j < ny; j++) {
            if (y1.xR[j] != 0.0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
// This function generates random 2 or 3 dimensional problem,
// builds model using RBF-ML algo, serializes/unserializes it,
// then compares models by calculating model value at some
// random point.
//
// Additionally we test that new model (one which was restored
// after serialization) has lost all model construction settings,
// i.e. if we call RBFBuildModel() on a NEW model, we will get
// empty (zero) model.
   for (nx = 2; nx <= 3; nx++) {
      for (ny = 1; ny <= 2; ny++) {
      // prepare test problem
         rbfcreate(nx, ny, &s);
         rbfsetalgomultilayer(&s, 5.0, 5, 1.0E-3);
         rbfsetlinterm(&s);
         if (nx == 2) {
         // 2-dimensional problem
            k0 = 2 + randominteger(4);
            k1 = 2 + randominteger(4);
            ae_matrix_set_length(&xy, k0 * k1, nx + ny);
            for (i0 = 0; i0 < k0; i0++) {
               for (i1 = 0; i1 < k1; i1++) {
                  xy.xyR[i0 * k1 + i1][0] = i0 + 0.1 * randommid();
                  xy.xyR[i0 * k1 + i1][1] = i1 + 0.1 * randommid();
                  for (j = 0; j < ny; j++) {
                     xy.xyR[i0 * k1 + i1][nx + j] = randommid();
                  }
               }
            }
            ae_vector_set_length(&testpoint, nx);
            testpoint.xR[0] = randomreal() * (k0 - 1);
            testpoint.xR[1] = randomreal() * (k1 - 1);
         } else {
         // 3-dimensional problem
            k0 = 2 + randominteger(4);
            k1 = 2 + randominteger(4);
            k2 = 2 + randominteger(4);
            ae_matrix_set_length(&xy, k0 * k1 * k2, nx + ny);
            for (i0 = 0; i0 < k0; i0++) {
               for (i1 = 0; i1 < k1; i1++) {
                  for (i2 = 0; i2 < k2; i2++) {
                     xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][0] = i0 + 0.1 * randommid();
                     xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][1] = i1 + 0.1 * randommid();
                     xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][2] = i2 + 0.1 * randommid();
                     for (j = 0; j < ny; j++) {
                        xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][nx + j] = randommid();
                     }
                  }
               }
            }
            ae_vector_set_length(&testpoint, nx);
            testpoint.xR[0] = randomreal() * (k0 - 1);
            testpoint.xR[1] = randomreal() * (k1 - 1);
            testpoint.xR[2] = randomreal() * (k2 - 1);
         }
         rbfsetpoints(&s, &xy, xy.rows);
      // Build model, serialize, compare
         rbfbuildmodel(&s, &rep);
         {
         // This code passes data structure through serializers
         // (serializes it to string and loads back)
            ae_frame _local_frame_block;
            ae_frame_make(&_local_frame_block);
            NewSerializer(_local_serializer);
            ae_serializer_alloc_start(&_local_serializer);
            rbfalloc(&_local_serializer, &s);
            ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
            NewBlock(_local_dynamic_block, _local_ssize + 1);
            ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            rbfserialize(&_local_serializer, &s);
            ae_serializer_stop(&_local_serializer);
            ae_serializer_init(&_local_serializer);
            ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            rbfunserialize(&_local_serializer, &s2);
            ae_serializer_stop(&_local_serializer);
            ae_frame_leave();
         }
         rbfcalc(&s, &testpoint, &y0);
         rbfcalc(&s2, &testpoint, &y1);
         if (y0.cnt != ny || y1.cnt != ny) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (j = 0; j < ny; j++) {
            if (y0.xR[j] != y1.xR[j]) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      // Check that calling RBFBuildModel() on S2 (new model)
      // will result in construction of zero model, i.e. test
      // that serialization restores model, but not dataset
      // which was used to build model.
         rbfbuildmodel(&s2, &rep);
         rbfcalc(&s2, &testpoint, &y1);
         if (y1.cnt != ny) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (j = 0; j < ny; j++) {
            if (y1.xR[j] != 0.0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
// This function generates random 1...4-dimensional problem,
// builds model using RBF-H algo, serializes/unserializes it,
// then compares models by calculating model value at some
// random point.
//
// NOTE: we choose at random whether to use default scaling -
//       or user-supplied one.
//
// Additionally we test that new model (one which was restored
// after serialization) has lost all model construction settings,
// i.e. if we call RBFBuildModel() on a NEW model, we will get
// empty (zero) model.
   for (nx = 1; nx <= 4; nx++) {
      for (ny = 1; ny <= 2; ny++) {
      // problem setup
         n = 150;
         rbase = 0.33;
         nlayers = 5;
         gridsize = iround(pow((double)n, 1.0 / nx)) + 1;
         bf = randominteger(2);
         n = iround(pow((double)gridsize, (double)nx));
         ae_matrix_set_length(&xy, n, nx + ny);
         ae_assert(gridsize > 1, "Assertion failed");
         ae_assert(n == pow((double)gridsize, (double)nx), "Assertion failed");
         for (i = 0; i < n; i++) {
            k = i;
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = (double)(k % gridsize) / (gridsize - 1);
               k /= gridsize;
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = randomreal() - 0.5;
            }
         }
         ae_vector_set_length(&testpoint, nx);
         for (j = 0; j < nx; j++) {
            testpoint.xR[j] = randomreal();
         }
         ae_vector_set_length(&scalevec, nx);
         for (j = 0; j < nx; j++) {
            scalevec.xR[j] = pow(2.0, randommid());
         }
      // prepare test problem
         rbfcreate(nx, ny, &s);
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase, nlayers, 0.0);
         rbfsetlinterm(&s);
         if (randombool()) {
            rbfsetpoints(&s, &xy, xy.rows);
         } else {
            rbfsetpointsandscales(&s, &xy, xy.rows, &scalevec);
         }
      // Build model, serialize, compare
         rbfbuildmodel(&s, &rep);
         {
         // This code passes data structure through serializers
         // (serializes it to string and loads back)
            ae_frame _local_frame_block;
            ae_frame_make(&_local_frame_block);
            NewSerializer(_local_serializer);
            ae_serializer_alloc_start(&_local_serializer);
            rbfalloc(&_local_serializer, &s);
            ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
            NewBlock(_local_dynamic_block, _local_ssize + 1);
            ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            rbfserialize(&_local_serializer, &s);
            ae_serializer_stop(&_local_serializer);
            ae_serializer_init(&_local_serializer);
            ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            rbfunserialize(&_local_serializer, &s2);
            ae_serializer_stop(&_local_serializer);
            ae_frame_leave();
         }
         rbfcalc(&s, &testpoint, &y0);
         rbfcalc(&s2, &testpoint, &y1);
         if (y0.cnt != ny || y1.cnt != ny) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (j = 0; j < ny; j++) {
            if (y0.xR[j] != y1.xR[j]) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      // Check that calling RBFBuildModel() on S2 (new model)
      // will result in construction of zero model, i.e. test
      // that serialization restores model, but not dataset
      // which was used to build model.
         rbfbuildmodel(&s2, &rep);
         rbfcalc(&s2, &testpoint, &y1);
         if (y1.cnt != ny) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (j = 0; j < ny; j++) {
            if (y1.xR[j] != 0.0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing basic functionality of RBF module on regular grids with
// multi-layer algorithm in 2-3D.
// ALGLIB: Copyright 02.03.2012 by Sergey Bochkanov
static bool testrbfunit_basicmultilayerrbftest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t k2;
   ae_int_t linterm;
   ae_int_t np;
   double q;
   ae_int_t layers;
   double eps;
   ae_int_t range;
   double s1;
   double s2;
   double gstep;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   ae_int_t fidx;
   double r0;
   ae_int_t margin;
   ae_int_t gridsize;
   double threshold;
   double v;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewObj(rbfcalcbuffer, calcbuf);
   NewVector(point, 0, DT_REAL);
   NewMatrix(gp, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(gy, 0, 0, DT_REAL);
   NewVector(gpgx0, 0, DT_REAL);
   NewVector(gpgx1, 0, DT_REAL);
   NewVector(gpgx2, 0, DT_REAL);
   NewVector(gcy, 0, DT_REAL);
   Ok = true;
   range = 10;
   passcount = 10;
   eps = 1.0E-6;
// Test that RBF model with sufficient layers will exactly reproduce
// target function.
   for (pass = 0; pass < passcount; pass++) {
   // prepare test problem
      k0 = 6 + randominteger(3);
      k1 = 6 + randominteger(3);
      k2 = 6 + randominteger(3);
      s1 = pow((double)range, (double)(randominteger(3) - 1));
      s2 = pow((double)range, (double)(randominteger(3) - 1));
      nx = randominteger(2) + 2;
      ny = randominteger(2) + 1;
      linterm = randominteger(3) + 1;
      layers = 5;
      gstep = s1 / 6;
      q = s1;
   // Create RBF structure and auxiliary structures
      ae_vector_set_length(&x, nx);
      ae_vector_set_length(&y, ny);
      ae_vector_set_length(&point, nx);
      rbfcreate(nx, ny, &s);
      rbfsetalgomultilayer(&s, q, layers, 0.0);
      if (linterm == 1) {
         rbfsetlinterm(&s);
      }
      if (linterm == 2) {
         rbfsetconstterm(&s);
      }
      if (linterm == 3) {
         rbfsetzeroterm(&s);
      }
      for (i = 0; i < nx; i++) {
         point.xR[i] = s1 * randommid();
      }
   // 2-dimensional test problem
      if (nx == 2) {
         np = k0 * k1;
         ae_matrix_set_length(&gp, np, nx + ny);
      // create grid
         for (i = 0; i < k0; i++) {
            for (j = 0; j < k1; j++) {
               gp.xyR[i * k1 + j][0] = point.xR[0] + gstep * i;
               gp.xyR[i * k1 + j][1] = point.xR[1] + gstep * j;
               for (k = 0; k < ny; k++) {
                  gp.xyR[i * k1 + j][nx + k] = s2 * randommid();
               }
            }
         }
         rbfsetpoints(&s, &gp, np);
         rbfbuildmodel(&s, &rep);
         rbfcreatecalcbuffer(&s, &calcbuf);
         if (ny == 1) {
            ae_vector_set_length(&gpgx0, k0);
            ae_vector_set_length(&gpgx1, k1);
            for (i = 0; i < k0; i++) {
               gpgx0.xR[i] = point.xR[0] + gstep * i;
            }
            for (i = 0; i < k1; i++) {
               gpgx1.xR[i] = point.xR[1] + gstep * i;
            }
            rbfgridcalc2(&s, &gpgx0, k0, &gpgx1, k1, &gy);
            for (i = 0; i < k0; i++) {
               for (j = 0; j < k1; j++) {
                  Ok = Ok && NearAtR(gy.xyR[i][j], gp.xyR[i * k1 + j][nx], s2 * eps);
               }
            }
         }
         for (i = 0; i < np; i++) {
         // For each row we randomly choose a function to test
         // and call it. We do not call multiple functions per
         // row because carry-over effects may mask errors in
         // some function (say, it is possible that function
         // simply returns results from previous call of some
         // other function which were stored in the RBF model;
         // in this case, previous call with same parameters
         // may hide deficiencies in the function).
            x.xR[0] = gp.xyR[i][0];
            x.xR[1] = gp.xyR[i][1];
            fidx = randominteger(4);
            if (fidx == 0 && ny != 1) {
               continue;
            }
            if (fidx == 0) {
               y.xR[0] = rbfcalc2(&s, x.xR[0], x.xR[1]);
            }
            if (fidx == 1) {
               rbfcalc(&s, &x, &y);
            }
            if (fidx == 2) {
               rbfcalcbuf(&s, &x, &y);
            }
            if (fidx == 3) {
               rbftscalcbuf(&s, &calcbuf, &x, &y);
            }
            for (j = 0; j < ny; j++) {
               Ok = Ok && NearAtR(gp.xyR[i][nx + j], y.xR[j], s2 * eps);
            }
         }
      }
   // 3-dimensional test problems
      if (nx == 3) {
         np = k0 * k1 * k2;
         ae_matrix_set_length(&gp, np, nx + ny);
      // create grid, build model
         ae_vector_set_length(&gpgx0, k0);
         ae_vector_set_length(&gpgx1, k1);
         ae_vector_set_length(&gpgx2, k2);
         for (i = 0; i < k0; i++) {
            gpgx0.xR[i] = point.xR[0] + gstep * i;
         }
         for (i = 0; i < k1; i++) {
            gpgx1.xR[i] = point.xR[1] + gstep * i;
         }
         for (i = 0; i < k2; i++) {
            gpgx2.xR[i] = point.xR[2] + gstep * i;
         }
         for (i = 0; i < k0; i++) {
            for (j = 0; j < k1; j++) {
               for (k = 0; k < k2; k++) {
                  gp.xyR[(i * k1 + j) * k2 + k][0] = gpgx0.xR[i];
                  gp.xyR[(i * k1 + j) * k2 + k][1] = gpgx1.xR[j];
                  gp.xyR[(i * k1 + j) * k2 + k][2] = gpgx2.xR[k];
                  for (l = 0; l < ny; l++) {
                     gp.xyR[(i * k1 + j) * k2 + k][nx + l] = s2 * randommid();
                  }
               }
            }
         }
         rbfsetpoints(&s, &gp, np);
         rbfbuildmodel(&s, &rep);
         rbfcreatecalcbuffer(&s, &calcbuf);
      // Test RBFCalc3(), RBFCalc() and RBFCalcBuf() vs expected values on the grid (we expect good fit).
         for (i = 0; i < np; i++) {
         // For each row we randomly choose a function to test
         // and call it. We do not call multiple functions per
         // row because carry-over effects may mask errors in
         // some function (say, it is possible that function
         // simply returns results from previous call of some
         // other function which were stored in the RBF model;
         // in this case, previous call with same parameters
         // may hide deficiencies in the function).
            x.xR[0] = gp.xyR[i][0];
            x.xR[1] = gp.xyR[i][1];
            x.xR[2] = gp.xyR[i][2];
            fidx = randominteger(4);
            if (fidx == 0 && ny != 1) {
               continue;
            }
            if (fidx == 0) {
               y.xR[0] = rbfcalc3(&s, x.xR[0], x.xR[1], x.xR[2]);
            }
            if (fidx == 1) {
               rbfcalc(&s, &x, &y);
            }
            if (fidx == 2) {
               rbfcalcbuf(&s, &x, &y);
            }
            if (fidx == 3) {
               rbftscalcbuf(&s, &calcbuf, &x, &y);
            }
            for (j = 0; j < ny; j++) {
               Ok = Ok && NearAtR(gp.xyR[i][nx + j], y.xR[j], s2 * eps);
            }
         }
      // Test RBFGridCalc3V vs RBFCalc()
         rbfgridcalc3v(&s, &gpgx0, k0, &gpgx1, k1, &gpgx2, k2, &gcy);
         for (i = 0; i < k0; i++) {
            for (j = 0; j < k1; j++) {
               for (k = 0; k < k2; k++) {
                  x.xR[0] = gpgx0.xR[i];
                  x.xR[1] = gpgx1.xR[j];
                  x.xR[2] = gpgx2.xR[k];
                  rbfcalcbuf(&s, &x, &y);
                  for (l = 0; l < ny; l++) {
                     Ok = Ok && NearAtR(y.xR[l], gcy.xR[l + ny * (i + j * k0 + k * k0 * k1)], 1.0E-9 * s2);
                  }
               }
            }
         }
      }
   }
// Test smoothing properties of RBF model: model with just one layer
// and large initial radius will produce "average" value of neighbors.
//
// In order to test it we create regular grid, fill it with regular
// +1/-1 pattern, and test model values in the inner points. Model
// values should be around zero (we use handcrafted threshold to test
// it). Radius is chosen to be several times larger than grid step.
//
// We perform test for 2D model, because same behavior is expected
// regardless of dimensionality.
   r0 = 3.0;
   margin = 5;
   gridsize = 2 * margin + 20;
   threshold = 0.1;
   nx = 2;
   ny = 1;
   rbfcreate(nx, ny, &s);
   rbfsetalgomultilayer(&s, r0, 1, 0.0);
   rbfsetzeroterm(&s);
   ae_matrix_set_length(&gp, gridsize * gridsize, nx + ny);
   for (i = 0; i < gridsize; i++) {
      for (j = 0; j < gridsize; j++) {
         gp.xyR[i * gridsize + j][0] = (double)i;
         gp.xyR[i * gridsize + j][1] = (double)j;
         gp.xyR[i * gridsize + j][2] = 0.05 * randommid() + (2 * ((i + j) % 2) - 1);
      }
   }
   rbfsetpoints(&s, &gp, gridsize * gridsize);
   rbfbuildmodel(&s, &rep);
   v = 0.0;
   for (i = margin; i < gridsize - margin; i++) {
      for (j = margin; j < gridsize - margin; j++) {
         v = rmax2(v, fabs(rbfcalc2(&s, (double)i, (double)j)));
      }
   }
   Ok = Ok && v <= threshold;
   ae_frame_leave();
   return Ok;
}

// Function for testing basic functionality of RBF module on regular grids with
// multi-layer algorithm in 2-3D.
// ALGLIB: Copyright 02.03.2012 by Sergey Bochkanov
static bool testrbfunit_gridcalc23test() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   double perturbation;
   double sx;
   double sy;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t linterm;
   ae_int_t layers;
   ae_int_t npoints;
   double sparsity;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewObj(hqrndstate, rs);
   NewVector(kx, 0, DT_INT);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(gf, 0, DT_BOOL);
   NewVector(rf, 0, DT_BOOL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(gy, 0, DT_REAL);
   NewVector(gy2, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   hqrndrandomize(&rs);
   for (pass = 0; pass <= 24; pass++) {
   // prepare test problem
      ae_vector_set_length(&kx, 3);
      for (i = 0; i <= 2; i++) {
      // 66% of cases - large grid
         if (hqrnduniformi(&rs, 3) == 0) {
            kx.xZ[i] = iround(10 * pow(10.0, hqrnduniformr(&rs)));
            continue;
         }
      // 33% of cases - small grid
         k = hqrnduniformi(&rs, 3);
         if (k == 0) {
            kx.xZ[i] = 1;
         }
         if (k == 1) {
            kx.xZ[i] = 2;
         }
         if (k == 2) {
            kx.xZ[i] = 10;
         }
      }
      sx = pow(10.0, (double)(hqrnduniformi(&rs, 3) - 1));
      sy = pow(10.0, (double)(hqrnduniformi(&rs, 3) - 1));
      nx = 3;
      ny = 1 + hqrnduniformi(&rs, 5);
      linterm = hqrnduniformi(&rs, 3) + 1;
      layers = hqrnduniformi(&rs, 3) + 1;
      npoints = 100;
      ae_matrix_set_length(&xy, npoints, nx + ny);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nx; j++) {
            xy.xyR[i][j] = hqrnduniformr(&rs) * sx;
         }
         for (j = 0; j < ny; j++) {
            xy.xyR[i][nx + j] = hqrnduniformr(&rs) * sy;
         }
      }
   // Create RBF model
      rbfcreate(nx, ny, &s);
      rbfsetalgomultilayer(&s, 0.1 * sx, layers, 0.0);
      if (linterm == 1) {
         rbfsetlinterm(&s);
      }
      if (linterm == 2) {
         rbfsetconstterm(&s);
      }
      if (linterm == 3) {
         rbfsetzeroterm(&s);
      }
      rbfsetpoints(&s, &xy, npoints);
      rbfbuildmodel(&s, &rep);
      Ok = Ok && rep.terminationtype > 0;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Prepare test grid
      ae_vector_set_length(&x0, kx.xZ[0]);
      for (i = 0; i < kx.xZ[0]; i++) {
         perturbation = 0.25 * hqrndmiduniformr(&rs);
         x0.xR[i] = sx * (i + perturbation) / kx.xZ[0];
      }
      ae_vector_set_length(&x1, kx.xZ[1]);
      for (i = 0; i < kx.xZ[1]; i++) {
         perturbation = 0.25 * hqrndmiduniformr(&rs);
         x1.xR[i] = sx * (i + perturbation) / kx.xZ[1];
      }
      ae_vector_set_length(&x2, kx.xZ[2]);
      for (i = 0; i < kx.xZ[2]; i++) {
         perturbation = 0.25 * hqrndmiduniformr(&rs);
         x2.xR[i] = sx * (i + perturbation) / kx.xZ[2];
      }
   // Test calculation on grid
      ae_vector_set_length(&x, nx);
      ae_vector_set_length(&y, ny);
      SetVector(&gy);
      rbfgridcalc3v(&s, &x0, kx.xZ[0], &x1, kx.xZ[1], &x2, kx.xZ[2], &gy);
      for (i = 0; i < kx.xZ[0]; i++) {
         for (j = 0; j < kx.xZ[1]; j++) {
            for (k = 0; k < kx.xZ[2]; k++) {
               x.xR[0] = x0.xR[i];
               x.xR[1] = x1.xR[j];
               x.xR[2] = x2.xR[k];
               rbfcalcbuf(&s, &x, &y);
               for (l = 0; l < ny; l++) {
                  Ok = Ok && NearAtR(y.xR[l], gy.xR[l + ny * (i + j * kx.xZ[0] + k * kx.xZ[0] * kx.xZ[1])], 1.0E-9 * sy);
               }
            }
         }
      }
   // Test calculation on subset of regular grid:
   // * select sparsity coefficient (from 1.0 to 0.001)
   // * fill bitmap array
   // * Test 1: compare full and subset versions
   // * Test 2: check sparsity. Subset function may perform additional
   //   evaluations because it processes data micro-row by micro-row.
   //   So, we can't check that all elements which were not flagged
   //   are zero - some of them may become non-zero. However, if entire
   //   row is empty, we can reasonably expect (informal guarantee)
   //   that it is not processed. So, we check empty (completely
   //   unflagged) rows
   //
      sparsity = pow(10.0, (double)-hqrnduniformi(&rs, 4));
      ae_vector_set_length(&gf, kx.xZ[0] * kx.xZ[1] * kx.xZ[2]);
      ae_vector_set_length(&rf, kx.xZ[1] * kx.xZ[2]);
      for (i = 0; i < kx.xZ[1] * kx.xZ[2]; i++) {
         rf.xB[i] = false;
      }
      for (i = 0; i < kx.xZ[0] * kx.xZ[1] * kx.xZ[2]; i++) {
         gf.xB[i] = hqrnduniformr(&rs) < sparsity;
         if (gf.xB[i]) {
            rf.xB[i / kx.xZ[0]] = true;
         }
      }
      ae_vector_set_length(&x, nx);
      ae_vector_set_length(&y, ny);
      SetVector(&gy);
      SetVector(&gy2);
      rbfgridcalc3vsubset(&s, &x0, kx.xZ[0], &x1, kx.xZ[1], &x2, kx.xZ[2], &gf, &gy);
      rbfgridcalc3v(&s, &x0, kx.xZ[0], &x1, kx.xZ[1], &x2, kx.xZ[2], &gy2);
      for (i = 0; i < ny * kx.xZ[0] * kx.xZ[1] * kx.xZ[2]; i++) {
         Ok = Ok && (!gf.xB[i / ny] || NearAtR(gy.xR[i], gy2.xR[i], 1.0E-9 * sy));
         Ok = Ok && (rf.xB[i / (ny * kx.xZ[0])] || gy.xR[i] == 0.0);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing basic functionality of RBF module with hierarchical
// algorithm.
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static bool testrbfunit_basichrbftest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t linterm;
   ae_int_t bf;
   double rbase;
   ae_int_t nlayers;
   double errtol;
   double scalefactor;
   ae_int_t n;
   ae_int_t ntest;
   ae_int_t gridsize;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double r0;
   ae_int_t margin;
   double threshold;
   double v;
   ae_int_t functype;
   ae_int_t densitytype;
   double width;
   double lowprec;
   double highprec;
   ae_int_t modeltype;
   ae_int_t shaketype;
   double maxerr;
   bool fractionalerror;
   ae_int_t unx;
   ae_int_t uny;
   ae_int_t unc;
   ae_int_t modelversion;
   bool hasscale;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfmodel, s2);
   NewObj(rbfreport, rep);
   NewObj(rbfcalcbuffer, tsbuf);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xytest, 0, 0, DT_REAL);
   NewMatrix(uxwr, 0, 0, DT_REAL);
   NewMatrix(uv, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(xzero, 0, DT_REAL);
   NewVector(yref, 0, DT_REAL);
   NewVector(scalevec, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   Ok = true;
// First test - random problem, ability to build model
// which reproduces function value in all points with
// good precision.
//
// We also test properties of the linear term - that
// model value in far away points is either constant
// or exactly zero (for corresponding kinds of linear
// term).
//
// All dataset points are located in unit cube on
// regular grid. We do not use smoothing for this test.
//
// We use/test following functions:
// * RBFCalc()
// * RBFCalc2()
// * RBFCalc3()
// * RBFCalcBuf()
// * RBFTsCalcBuf()
   errtol = 1.0E-6;
   for (nx = 1; nx <= 4; nx++) {
      for (ny = 1; ny <= 3; ny++) {
      // problem setup
         n = 150;
         rbase = 0.33;
         nlayers = 10;
         gridsize = iround(pow((double)n, 1.0 / nx)) + 1;
         linterm = 1 + randominteger(3);
         bf = randominteger(2);
         n = iround(pow((double)gridsize, (double)nx));
         ae_matrix_set_length(&xy, n, nx + ny);
         ae_assert(gridsize > 1, "Assertion failed");
         ae_assert(n == pow((double)gridsize, (double)nx), "Assertion failed");
         for (i = 0; i < n; i++) {
            k = i;
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = (double)(k % gridsize) / (gridsize - 1);
               k /= gridsize;
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = randomreal() - 0.5;
            }
         }
      // Build model
         rbfcreate(nx, ny, &s);
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase, nlayers, 0.0);
         if (linterm == 1) {
            rbfsetlinterm(&s);
         }
         if (linterm == 2) {
            rbfsetconstterm(&s);
         }
         if (linterm == 3) {
            rbfsetzeroterm(&s);
         }
         rbfsetpoints(&s, &xy, n);
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         rbfcreatecalcbuffer(&s, &tsbuf);
      // Test ability to reproduce function value
      //
      // NOTE: we use RBFCalc(XZero) to guarantee that internal state of
      //       RBF model is "reset" between subsequent calls of different
      //       functions. It allows us to make sure that we have no bug
      //       like function simply returning latest result
         ae_vector_set_length(&x, nx);
         ae_vector_set_length(&xzero, nx);
         ae_vector_set_length(&y, ny);
         for (j = 0; j < nx; j++) {
            xzero.xR[j] = 0.0;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               x.xR[j] = xy.xyR[i][j];
            }
            rbfcalc(&s, &xzero, &y);
            if (randombool()) {
               ae_vector_set_length(&yref, ny + 1);
            }
            rbfcalc(&s, &x, &yref);
            for (j = 0; j < ny; j++) {
               Ok = Ok && NearAtR(yref.xR[j], xy.xyR[i][nx + j], errtol);
            }
            Ok = Ok && yref.cnt == ny;
            if (nx == 1 && ny == 1) {
               rbfcalc(&s, &xzero, &y);
               Ok = Ok && rbfcalc1(&s, x.xR[0]) == yref.xR[0];
            }
            if (nx == 2 && ny == 1) {
               rbfcalc(&s, &xzero, &y);
               Ok = Ok && rbfcalc2(&s, x.xR[0], x.xR[1]) == yref.xR[0];
            }
            if (nx == 3 && ny == 1) {
               rbfcalc(&s, &xzero, &y);
               Ok = Ok && rbfcalc3(&s, x.xR[0], x.xR[1], x.xR[2]) == yref.xR[0];
            }
            rbfcalc(&s, &xzero, &y);
            if (randombool()) {
               ae_vector_set_length(&y, ny + 1);
               rbfcalcbuf(&s, &x, &y);
               Ok = Ok && y.cnt == ny + 1;
            } else {
               ae_vector_set_length(&y, ny - 1);
               rbfcalcbuf(&s, &x, &y);
               Ok = Ok && y.cnt == ny;
            }
            for (j = 0; j < ny; j++) {
               Ok = Ok && y.xR[j] == yref.xR[j];
            }
            rbfcalc(&s, &xzero, &y);
            if (randombool()) {
               ae_vector_set_length(&y, ny + 1);
               rbftscalcbuf(&s, &tsbuf, &x, &y);
               Ok = Ok && y.cnt == ny + 1;
            } else {
               ae_vector_set_length(&y, ny - 1);
               rbftscalcbuf(&s, &tsbuf, &x, &y);
               Ok = Ok && y.cnt == ny;
            }
            for (j = 0; j < ny; j++) {
               Ok = Ok && y.xR[j] == yref.xR[j];
            }
         }
      // Test that:
      // a) model with zero linear term is zero far away from dataset
      // b) model with constant linear term is constant far away from dataset
         ae_vector_set_length(&x, nx);
         if (linterm == 2) {
            for (j = 0; j < nx; j++) {
               if (randombool()) {
                  x.xR[j] = 1 + 1000 * rbase;
               } else {
                  x.xR[j] = 0 - 1000 * rbase;
               }
            }
            rbfcalc(&s, &x, &y);
            for (j = 0; j < nx; j++) {
               if (randombool()) {
                  x.xR[j] = 1 + 1000 * rbase;
               } else {
                  x.xR[j] = 0 - 1000 * rbase;
               }
            }
            rbfcalc(&s, &x, &y2);
            for (j = 0; j < ny; j++) {
               Ok = Ok && y.xR[j] == y2.xR[j];
            }
         }
         if (linterm == 3) {
            for (j = 0; j < nx; j++) {
               if (randombool()) {
                  x.xR[j] = 1 + 1000 * rbase;
               } else {
                  x.xR[j] = 0 - 1000 * rbase;
               }
            }
            rbfcalc(&s, &x, &y);
            for (j = 0; j < ny; j++) {
               Ok = Ok && y.xR[j] == 0.0;
            }
         }
      }
   }
// Test rbfunpack()
   for (nx = 1; nx <= 2; nx++) {
      for (ny = 1; ny <= 2; ny++) {
      // problem setup
         n = 150;
         rbase = 0.33;
         nlayers = 5;
         gridsize = iround(pow((double)n, 1.0 / nx)) + 1;
         linterm = 1 + randominteger(3);
         bf = randominteger(2);
         n = iround(pow((double)gridsize, (double)nx));
         ae_matrix_set_length(&xy, n, nx + ny);
         ae_assert(gridsize > 1, "Assertion failed");
         ae_assert(n == pow((double)gridsize, (double)nx), "Assertion failed");
         for (i = 0; i < n; i++) {
            k = i;
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = (double)(k % gridsize) / (gridsize - 1);
               k /= gridsize;
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = randomreal() - 0.5;
            }
         }
         hasscale = randominteger(2) == 0;
         ae_vector_set_length(&scalevec, nx);
         if (hasscale) {
            for (j = 0; j < nx; j++) {
               scalevec.xR[j] = pow(2.0, randommid());
            }
         }
      // Build model
         rbfcreate(nx, ny, &s);
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase, nlayers, 0.0);
         if (linterm == 1) {
            rbfsetlinterm(&s);
         }
         if (linterm == 2) {
            rbfsetconstterm(&s);
         }
         if (linterm == 3) {
            rbfsetzeroterm(&s);
         }
         if (hasscale) {
            rbfsetpointsandscales(&s, &xy, n, &scalevec);
         } else {
            rbfsetpoints(&s, &xy, n);
         }
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      // Test RBFUnpack()
         rbfunpack(&s, &unx, &uny, &uxwr, &unc, &uv, &modelversion);
         if (modelversion != 2) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         if (unx != nx || uny != ny) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         if (uv.cols != nx + 1 || uv.rows != ny) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         if (linterm == 2) {
            for (i = 0; i < ny; i++) {
               for (j = 0; j < nx; j++) {
                  Ok = Ok && uv.xyR[i][j] == 0.0;
               }
            }
         }
         if (linterm == 3) {
            for (i = 0; i < ny; i++) {
               for (j = 0; j <= nx; j++) {
                  Ok = Ok && uv.xyR[i][j] == 0.0;
               }
            }
         }
         ae_vector_set_length(&x, nx);
         ae_vector_set_length(&y, ny);
         for (i = 0; i <= 9; i++) {
            for (j = 0; j < nx; j++) {
               x.xR[j] = randomreal();
            }
            rbfcalc(&s, &x, &yref);
            for (j = 0; j < ny; j++) {
               y.xR[j] = uv.xyR[j][nx];
               for (k = 0; k < nx; k++) {
                  y.xR[j] += x.xR[k] * uv.xyR[j][k];
               }
            }
            for (k = 0; k < unc; k++) {
               v = 0.0;
               for (j = 0; j < nx; j++) {
                  v += sqr(uxwr.xyR[k][j] - x.xR[j]) / sqr(uxwr.xyR[k][nx + ny + j]);
               }
               if (v < rbfv2farradius(bf) * rbfv2farradius(bf)) {
                  v = rbfv2basisfunc(bf, v);
               } else {
                  v = 0.0;
               }
               for (j = 0; j < ny; j++) {
                  y.xR[j] += v * uxwr.xyR[k][nx + j];
               }
            }
            for (j = 0; j < ny; j++) {
               Ok = Ok && NearAtR(y.xR[j], yref.xR[j], 1.0E-9);
            }
         }
      }
   }
// Test that smooth 1D function is reproduced (between nodes)
// with good precision. We test two model types: model with
// three layers and moderate initial radius, and model with
// large initial radius and large number of layers.
//
// This test:
// * generates test function on [-Width,+Width]. Two sets of
//   nodes are generated - "model" ones and "test" ones.
// * builds RBF model using "model" dataset
// * test model using "test" dataset. Test points are more
//   dense and are spread in [-0.9*Width, +0.9*Width] (reduced
//   interval is used because RBF models are too bad near the
//   boundaries).
//
// NOTE: we calculate maximum error for given function type
//       and grid density over all modifications of the task,
//       and only after that we perform comparison with tolerance
//       level. It allows easier debugging.
   for (functype = 0; functype <= 2; functype++) {
      for (densitytype = 0; densitytype <= 1; densitytype++) {
      // Select tolerance
         lowprec = -999999.0;
         highprec = -999999.0;
         if (functype == 0) {
            lowprec = 1.0E-2;
            highprec = 1.0E-3;
         } else {
            if (functype == 1) {
               lowprec = 1.0E-1;
               highprec = 1.0E-2;
            } else {
               if (functype == 2) {
                  lowprec = 1.0E-3;
                  highprec = 1.0E-4;
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         if (densitytype == 0) {
            errtol = lowprec;
         } else {
            errtol = highprec;
         }
      // Test
         maxerr = 0.0;
         for (modeltype = 0; modeltype <= 1; modeltype++) {
            for (shaketype = 0; shaketype <= 1; shaketype++) {
            // Generate grid
               width = 1.0;
               fractionalerror = false;
               if (functype == 0) {
               // sin(x) on [-2*pi,+2*pi]
                  n = 17 * iround(pow(4.0, (double)densitytype));
                  width = pi;
                  fractionalerror = false;
               } else {
                  if (functype == 1) {
                  // exp(x) on [-3,+3]
                     n = 50 * iround(pow(4.0, (double)densitytype));
                     width = 3.0;
                     fractionalerror = true;
                  } else {
                     if (functype == 2) {
                     // 1/(1+x^2) on [-3,+3]
                        n = 20 * iround(pow(4.0, (double)densitytype));
                        width = 3.0;
                        fractionalerror = false;
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
               }
               ae_matrix_set_length(&xy, n, 2);
               for (i = 0; i < n; i++) {
                  v = shaketype * 0.125 * randommid();
                  v = (i + v) / (n - 1);
                  v = 2 * v - 1;
                  xy.xyR[i][0] = width * v;
               }
               ntest = n * 10;
               ae_matrix_set_length(&xytest, ntest, 2);
               for (i = 0; i < ntest; i++) {
                  xytest.xyR[i][0] = 0.9 * width * ((double)(2 * i) / (ntest - 1) - 1);
               }
            // Evaluate function
               if (functype == 0) {
               // sin(x)
                  for (i = 0; i < n; i++) {
                     xy.xyR[i][1] = sin(xy.xyR[i][0]);
                  }
                  for (i = 0; i < ntest; i++) {
                     xytest.xyR[i][1] = sin(xytest.xyR[i][0]);
                  }
               } else {
                  if (functype == 1) {
                  // exp(x)
                     for (i = 0; i < n; i++) {
                        xy.xyR[i][1] = exp(xy.xyR[i][0]);
                     }
                     for (i = 0; i < ntest; i++) {
                        xytest.xyR[i][1] = exp(xytest.xyR[i][0]);
                     }
                  } else {
                     if (functype == 2) {
                     // 1/(1+x^2)
                        for (i = 0; i < n; i++) {
                           xy.xyR[i][1] = 1 / (1 + sqr(xy.xyR[i][0]));
                        }
                        for (i = 0; i < ntest; i++) {
                           xytest.xyR[i][1] = 1 / (1 + sqr(xytest.xyR[i][0]));
                        }
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
               }
            // Select model properties and precision
               if (modeltype == 0) {
                  rbase = 4.0 * (2 * width / n);
                  nlayers = 3;
               } else {
                  if (modeltype == 1) {
                     rbase = 16.0 * (2 * width / n);
                     nlayers = 6;
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            // Build model
               bf = randominteger(2);
               rbfcreate(1, 1, &s);
               rbfsetv2bf(&s, bf);
               rbfsetalgohierarchical(&s, rbase, nlayers, 0.0);
               rbfsetpoints(&s, &xy, n);
               rbfbuildmodel(&s, &rep);
               if (rep.terminationtype <= 0) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            // Check
               ae_vector_set_length(&x, 1);
               for (i = 0; i < ntest; i++) {
                  x.xR[0] = xytest.xyR[i][0];
                  rbfcalc(&s, &x, &y);
                  if (fractionalerror) {
                     maxerr = rmax2(maxerr, fabs(y.xR[0] - xytest.xyR[i][1]) / fabs(xytest.xyR[i][1]));
                  } else {
                     maxerr = rmax2(maxerr, fabs(y.xR[0] - xytest.xyR[i][1]));
                  }
               }
            }
         }
      // Check error
         Ok = Ok && maxerr <= errtol;
      }
   }
// Scaling test - random problem, we test that after
// scaling of all variables and radius by 2^K (for some K)
// we will get exactly same results (up to the last bit of
// mantissa).
//
// It is very strong requirement for algorithm stability,
// but it is satisfiable in most implementations of RBFs,
// because all operations involving spatial values are usually
// followed by division by radius, and using multiplier which
// is exactly power of 2 results in no changes in numbers
// being returned.
//
// It allows to test different scale-related bugs
// (say, situation when deep in kd-tree search code we compare
// against R instead of R^2).
//
// All dataset points are located in unit cube on
// regular grid.
//
// We do not use smoothing for this test.
   for (nx = 1; nx <= 4; nx++) {
   // problem setup
      n = 150;
      rbase = 0.33;
      nlayers = randominteger(4);
      scalefactor = pow(1024.0, (double)(2 * randominteger(2) - 1));
      gridsize = iround(pow((double)n, 1.0 / nx)) + 1;
      ny = 1 + randominteger(3);
      linterm = 1 + randominteger(3);
      bf = randominteger(2);
      n = iround(pow((double)gridsize, (double)nx));
      ae_matrix_set_length(&xy, n, nx + ny);
      ae_matrix_set_length(&xy2, n, nx + ny);
      ae_assert(gridsize > 1, "Assertion failed");
      ae_assert(n == pow((double)gridsize, (double)nx), "Assertion failed");
      for (i = 0; i < n; i++) {
         k = i;
         for (j = 0; j < nx; j++) {
            xy.xyR[i][j] = (double)(k % gridsize) / (gridsize - 1);
            xy2.xyR[i][j] = xy.xyR[i][j] * scalefactor;
            k /= gridsize;
         }
         for (j = 0; j < ny; j++) {
            xy.xyR[i][nx + j] = randomreal() - 0.5;
            xy2.xyR[i][nx + j] = xy.xyR[i][nx + j];
         }
      }
   // Build model 1
      rbfcreate(nx, ny, &s);
      rbfsetv2bf(&s, bf);
      rbfsetalgohierarchical(&s, rbase, nlayers, 0.0);
      if (linterm == 1) {
         rbfsetlinterm(&s);
      }
      if (linterm == 2) {
         rbfsetconstterm(&s);
      }
      if (linterm == 3) {
         rbfsetzeroterm(&s);
      }
      rbfsetpoints(&s, &xy, n);
      rbfbuildmodel(&s, &rep);
      if (rep.terminationtype <= 0) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   // Build model 2
      rbfcreate(nx, ny, &s2);
      rbfsetv2bf(&s2, bf);
      rbfsetalgohierarchical(&s2, rbase * scalefactor, nlayers, 0.0);
      if (linterm == 1) {
         rbfsetlinterm(&s2);
      }
      if (linterm == 2) {
         rbfsetconstterm(&s2);
      }
      if (linterm == 3) {
         rbfsetzeroterm(&s2);
      }
      rbfsetpoints(&s2, &xy2, n);
      rbfbuildmodel(&s2, &rep);
      if (rep.terminationtype <= 0) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   // Compare models
      ae_vector_set_length(&x, nx);
      ae_vector_set_length(&y, ny);
      ae_vector_set_length(&y2, ny);
      for (i = 0; i < n; i++) {
         for (j = 0; j < nx; j++) {
            x.xR[j] = xy.xyR[i][j];
         }
         rbfcalc(&s, &x, &y);
         for (j = 0; j < nx; j++) {
            x.xR[j] = xy2.xyR[i][j];
         }
         rbfcalc(&s2, &x, &y2);
         for (j = 0; j < ny; j++) {
            Ok = Ok && y.xR[j] == y2.xR[j];
         }
      }
   }
// Test that passing scaled dataset automatically results in V2 model
// being built (even when algorithm type is not set explicitly).
   for (nx = 1; nx <= 4; nx++) {
      for (ny = 1; ny <= 3; ny++) {
      // problem setup
         n = 10;
         ae_matrix_set_length(&xy, n, nx + ny);
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx + ny; j++) {
               xy.xyR[i][j] = randomreal() - 0.5;
            }
         }
         ae_vector_set_length(&scalevec, nx);
         for (j = 0; j < nx; j++) {
            scalevec.xR[j] = pow(2.0, randommid());
         }
      // prepare test problem
         rbfcreate(nx, ny, &s);
         rbfsetpointsandscales(&s, &xy, xy.rows, &scalevec);
      // Build model, check model version
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         Ok = Ok && rbfgetmodelversion(&s) == 2;
      }
   }
// Test smoothing properties of RBF model: model with just one layer
// and large initial radius will produce "average" value of neighbors.
//
// In order to test it we create regular grid, fill it with regular
// +1/-1 pattern, and test model values in the inner points. Model
// values should be around zero (we use handcrafted threshold to test
// it). Radius is chosen to be several times larger than grid step.
//
// We perform test for 2D model, because same behavior is expected
// regardless of dimensionality.
   r0 = 6.0;
   margin = 10;
   threshold = 0.005;
   gridsize = 2 * margin + 10;
   nx = 2;
   ny = 1;
   for (bf = 0; bf <= 1; bf++) {
      rbfcreate(nx, ny, &s);
      rbfsetv2bf(&s, bf);
      rbfsetalgohierarchical(&s, r0, 1, 1.0E-1);
      rbfsetzeroterm(&s);
      ae_matrix_set_length(&xy, gridsize * gridsize, nx + ny);
      for (i = 0; i < gridsize; i++) {
         for (j = 0; j < gridsize; j++) {
            xy.xyR[i * gridsize + j][0] = (double)i;
            xy.xyR[i * gridsize + j][1] = (double)j;
            xy.xyR[i * gridsize + j][2] = 0.005 * randommid() + (2 * ((i + j) % 2) - 1);
         }
      }
      rbfsetpoints(&s, &xy, gridsize * gridsize);
      rbfbuildmodel(&s, &rep);
      if (rep.terminationtype <= 0) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      v = 0.0;
      for (i = margin; i < gridsize - margin; i++) {
         for (j = margin; j < gridsize - margin; j++) {
            v = rmax2(v, fabs(rbfcalc2(&s, (double)i, (double)j)));
         }
      }
      Ok = Ok && v <= threshold;
   }
   ae_frame_leave();
   return Ok;
}

// Function for testing scaling-related functionality of RBF module with
// hierarchical algorithm.
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static bool testrbfunit_scaledhrbftest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t linterm;
   ae_int_t bf;
   double rbase;
   ae_int_t nlayers;
   double errtol;
   ae_int_t n;
   ae_int_t gridsize;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t strictness;
   double lambdav;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfmodel, s2);
   NewObj(rbfreport, rep);
   NewObj(rbfcalcbuffer, tsbuf);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(xzero, 0, DT_REAL);
   NewVector(yref, 0, DT_REAL);
   NewVector(scalex, 0, DT_REAL);
   NewVector(scaley, 0, DT_REAL);
   NewVector(c0, 0, DT_REAL);
   NewVector(c1, 0, DT_REAL);
   Ok = true;
// First test - random problem, test that using scaling
// does not change model significantly (except for
// rounding-related errors).
//
// We test two kinds of scaling:
// * "strict", which is scaling by some power of 2, and
//   which should result in bit-to-bit equivalence of results
// * "non-strict", which is scaling by random number, and
//   which should result in approximate equivalence
//
// We also apply scaling to Y, in order to test that it
// is correctly handled too.
   for (strictness = 0; strictness <= 1; strictness++) {
      for (nx = 1; nx <= 2; nx++) {
         for (ny = 1; ny <= 2; ny++) {
         // problem setup
            if (strictness == 1) {
               errtol = 0.0;
               ae_vector_set_length(&scalex, nx);
               for (i = 0; i < nx; i++) {
                  scalex.xR[i] = pow(16.0, (double)(randominteger(3) - 1));
               }
               ae_vector_set_length(&scaley, ny);
               for (i = 0; i < ny; i++) {
                  scaley.xR[i] = pow(16.0, (double)(randominteger(3) - 1));
               }
            } else {
               errtol = 1.0E-3;
               ae_vector_set_length(&scalex, nx);
               for (i = 0; i < nx; i++) {
                  scalex.xR[i] = pow(4.0, randommid());
               }
               ae_vector_set_length(&scaley, ny);
               for (i = 0; i < ny; i++) {
                  scaley.xR[i] = pow(4.0, randommid());
               }
            }
            n = 150;
            rbase = 0.33;
            nlayers = 2;
            gridsize = iround(pow((double)n, 1.0 / nx)) + 1;
            linterm = 1 + randominteger(3);
            bf = randominteger(2);
            lambdav = 1.0E-3 * randominteger(2);
            n = iround(pow((double)gridsize, (double)nx));
            ae_matrix_set_length(&xy, n, nx + ny);
            ae_assert(gridsize > 1, "Assertion failed");
            ae_assert(n == pow((double)gridsize, (double)nx), "Assertion failed");
            ae_vector_set_length(&c0, nx);
            for (j = 0; j < nx; j++) {
               c0.xR[j] = randomreal() - 0.5;
            }
            ae_vector_set_length(&c1, ny);
            for (j = 0; j < ny; j++) {
               c1.xR[j] = randomreal() - 0.5;
            }
            for (i = 0; i < n; i++) {
               k = i;
               for (j = 0; j < nx; j++) {
                  xy.xyR[i][j] = (double)(k % gridsize) / (gridsize - 1);
                  k /= gridsize;
               }
               for (j = 0; j < ny; j++) {
                  xy.xyR[i][nx + j] = 0.0;
                  for (k = 0; k < nx; k++) {
                     xy.xyR[i][nx + j] += c0.xR[k] * cos(pi * (1 + k) * xy.xyR[i][k]);
                  }
                  xy.xyR[i][nx + j] *= c1.xR[j];
               }
            }
            ae_matrix_set_length(&xy2, n, nx + ny);
            for (i = 0; i < n; i++) {
               for (j = 0; j < nx; j++) {
                  xy2.xyR[i][j] = xy.xyR[i][j] * scalex.xR[j];
               }
               for (j = 0; j < ny; j++) {
                  xy2.xyR[i][nx + j] = xy.xyR[i][nx + j] * scaley.xR[j];
               }
            }
         // Build models
            rbfcreate(nx, ny, &s);
            rbfsetv2bf(&s, bf);
            rbfsetalgohierarchical(&s, rbase, nlayers, lambdav);
            if (linterm == 1) {
               rbfsetlinterm(&s);
            }
            if (linterm == 2) {
               rbfsetconstterm(&s);
            }
            if (linterm == 3) {
               rbfsetzeroterm(&s);
            }
            rbfsetpoints(&s, &xy, n);
            rbfbuildmodel(&s, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
            rbfcreate(nx, ny, &s2);
            rbfsetv2bf(&s2, bf);
            rbfsetalgohierarchical(&s2, rbase, nlayers, lambdav);
            if (linterm == 1) {
               rbfsetlinterm(&s2);
            }
            if (linterm == 2) {
               rbfsetconstterm(&s2);
            }
            if (linterm == 3) {
               rbfsetzeroterm(&s2);
            }
            rbfsetpointsandscales(&s2, &xy2, n, &scalex);
            rbfbuildmodel(&s2, &rep);
            if (rep.terminationtype <= 0) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         // Compare model values in grid points
            ae_vector_set_length(&x, nx);
            for (i = 0; i < n; i++) {
               for (j = 0; j < nx; j++) {
                  x.xR[j] = xy.xyR[i][j];
               }
               rbfcalc(&s, &x, &y);
               for (j = 0; j < nx; j++) {
                  x.xR[j] = xy2.xyR[i][j];
               }
               rbfcalc(&s2, &x, &y2);
               for (j = 0; j < ny; j++) {
                  Ok = Ok && NearAtR(y.xR[j], y2.xR[j] / scaley.xR[j], errtol);
               }
            }
         // Compare model values in random points
            ae_vector_set_length(&x, nx);
            for (i = 0; i < n; i++) {
               for (j = 0; j < nx; j++) {
                  x.xR[j] = randomreal();
               }
               rbfcalc(&s, &x, &y);
               for (j = 0; j < nx; j++) {
                  x.xR[j] *= scalex.xR[j];
               }
               rbfcalc(&s2, &x, &y2);
               for (j = 0; j < ny; j++) {
                  Ok = Ok && NearAtR(y.xR[j], y2.xR[j] / scaley.xR[j], errtol);
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test special properties of hierarchical RBFs.
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static bool testrbfunit_spechrbftest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nx;
   ae_int_t ny;
   double rbase;
   ae_int_t nlayers;
   ae_int_t i;
   ae_int_t j;
   double vdiff;
   double d2;
   ae_int_t v2its;
   double vref;
   double vfunc;
   double maxerr;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s0);
   NewObj(rbfmodel, s1);
   NewObj(rbfreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   Ok = true;
// Test properties of RBF basis functions - we compare values
// returned by RBFV2BasisFunc() against analytic expressions
// which are approximately modeled by RBFV2BasisFunc().
   d2 = 0.0;
   while (d2 < 100.0) {
      vref = exp(-d2);
      vfunc = rbfv2basisfunc(0, d2);
      Ok = Ok && NearAtR(vref, vfunc, 1.0E-9 * vref);
      d2 += 1.0 / 64.0;
   }
   d2 = 0.0;
   maxerr = 0.0;
   while (d2 < 16.0) {
      vref = rmax2(1 - d2 / 9, 0.0) * exp(-d2);
      vfunc = rbfv2basisfunc(1, d2);
      maxerr = rmax2(maxerr, fabs(vref - vfunc));
      Ok = Ok && NearAtR(vref, vfunc, 0.005);
      d2 += 1.0 / 64.0;
   }
// Test that tiny changes in dataset points introduce tiny
// numerical noise. The noise magnitude depends on the
// properties of the linear solver being used. We compare
// noise magnitude against hard-coded values.
//
// Test sequence:
// * create model #1
// * create model #2 using slightly modified dataset
   nx = 2;
   ny = 1;
   n = 20;
   rbase = 2.0;
   nlayers = 1;
   v2its = 50;
   ae_matrix_set_length(&xy, n * n, nx + ny);
   for (i = 0; i < n * n; i++) {
      xy.xyR[i][0] = (double)(i % n);
      xy.xyR[i][1] = (double)(i / n);
      xy.xyR[i][2] = sin((double)i);
   }
   rbfcreate(nx, ny, &s0);
   rbfsetalgohierarchical(&s0, rbase, nlayers, 0.0);
   rbfsetv2its(&s0, v2its);
   rbfsetpoints(&s0, &xy, n * n);
   rbfbuildmodel(&s0, &rep);
   if (rep.terminationtype <= 0) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   for (i = 0; i < n * n; i++) {
      xy.xyR[i][0] += 1.0E-14 * sin((double)(3 * i));
      xy.xyR[i][1] += 1.0E-14 * sin((double)(7 * i * i));
   }
   rbfcreate(nx, ny, &s1);
   rbfsetalgohierarchical(&s1, rbase, nlayers, 0.0);
   rbfsetv2its(&s1, v2its);
   rbfsetpoints(&s1, &xy, n * n);
   rbfbuildmodel(&s1, &rep);
   if (rep.terminationtype <= 0) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   vdiff = 0.0;
   for (i = 0; i < n - 1; i++) {
      for (j = 0; j < n - 1; j++) {
         vdiff += fabs(rbfcalc2(&s0, 0.5 + i, 0.5 + j) - rbfcalc2(&s1, 0.5 + i, 0.5 + j)) / sqr(n - 1);
      }
   }
   Ok = Ok && vdiff <= 0.00200 && vdiff >= 0.00001;
// Test progress reports: progress before model construction is
// zero, progress after model is built is 1. More detailed tests
// are performed in the multithreaded TestHRBFProgress().
   nx = 2;
   ny = 1;
   n = 20;
   rbase = 1.0;
   nlayers = 3;
   ae_matrix_set_length(&xy, n, nx + ny);
   for (i = 0; i < n; i++) {
      for (j = 0; j <= nx; j++) {
         xy.xyR[i][j] = hqrndnormal(&rs);
      }
   }
   rbfcreate(nx, ny, &s0);
   rbfsetalgohierarchical(&s0, rbase, nlayers, 0.0);
   Ok = Ok && rbfpeekprogress(&s0) == 0.0;
   rbfbuildmodel(&s0, &rep);
   Ok = Ok && rep.terminationtype > 0;
   Ok = Ok && rbfpeekprogress(&s0) == 1.0;
   rbfcreate(nx, ny, &s0);
   rbfsetpoints(&s0, &xy, n);
   rbfsetalgohierarchical(&s0, rbase, 0, 0.0);
   Ok = Ok && rbfpeekprogress(&s0) == 0.0;
   rbfbuildmodel(&s0, &rep);
   Ok = Ok && rep.terminationtype > 0;
   Ok = Ok && rbfpeekprogress(&s0) == 1.0;
   rbfcreate(nx, ny, &s0);
   rbfsetpoints(&s0, &xy, n);
   rbfsetalgohierarchical(&s0, rbase, nlayers, 0.0);
   Ok = Ok && rbfpeekprogress(&s0) == 0.0;
   rbfbuildmodel(&s0, &rep);
   Ok = Ok && rep.terminationtype > 0;
   Ok = Ok && rbfpeekprogress(&s0) == 1.0;
   ae_frame_leave();
   return Ok;
}

// Test gridded evaluation of hierarchical RBFs.
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static bool testrbfunit_gridhrbftest() {
   ae_frame _frame_block;
   ae_int_t linterm;
   ae_int_t bf;
   double rbase;
   ae_int_t nlayers;
   ae_int_t nx;
   ae_int_t ny;
   bool hasscale;
   double errtol;
   ae_int_t n;
   ae_int_t n0;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t nkind;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t i0;
   ae_int_t i1;
   ae_int_t i2;
   double scalefactor;
   double lambdav;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewMatrix(y2, 0, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(x02, 0, DT_REAL);
   NewVector(x12, 0, DT_REAL);
   NewVector(x22, 0, DT_REAL);
   NewVector(scalevec, 0, DT_REAL);
   NewVector(scalevec2, 0, DT_REAL);
   NewVector(needy, 0, DT_BOOL);
   NewVector(rowflags, 0, DT_BOOL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(yv, 0, DT_REAL);
   NewVector(yv2, 0, DT_REAL);
   Ok = true;
// Test 2-dimensional grid calculation
   errtol = 1.0E-12;
   nx = 2;
   for (ny = 1; ny <= 4; ny++) {
      for (nkind = 0; nkind <= 2; nkind++) {
      // problem setup
         n = 150;
         rbase = 0.10;
         nlayers = randominteger(3);
         linterm = 1 + randominteger(3);
         lambdav = 1.0E-3 * randominteger(2);
         bf = randominteger(2);
         ae_matrix_set_length(&xy, n, nx + ny);
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = randomreal();
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = randomreal() - 0.5;
            }
         }
         hasscale = randominteger(2) == 0;
         if (hasscale) {
            ae_vector_set_length(&scalevec, nx);
            for (j = 0; j < nx; j++) {
               scalevec.xR[j] = pow(2.0, randommid());
            }
         }
      // Build model
         rbfcreate(nx, ny, &s);
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase, nlayers, lambdav);
         if (linterm == 1) {
            rbfsetlinterm(&s);
         }
         if (linterm == 2) {
            rbfsetconstterm(&s);
         }
         if (linterm == 3) {
            rbfsetzeroterm(&s);
         }
         if (hasscale) {
            rbfsetpointsandscales(&s, &xy, n, &scalevec);
         } else {
            rbfsetpoints(&s, &xy, n);
         }
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      // Prepare grid to test
         n0 = 1 + randominteger(50);
         n1 = 1 + randominteger(50);
         if (nkind == 1) {
            k = randominteger(2);
            if (k == 0) {
               n0 = 1;
            }
            if (k == 1) {
               n1 = 1;
            }
         } else {
            if (nkind == 2) {
               n0 = 1;
               n1 = 1;
            } else {
               ae_assert(nkind == 0, "Assertion failed");
            }
         }
         ae_vector_set_length(&x0, n0);
         x0.xR[0] = randomreal();
         for (i = 1; i < n0; i++) {
            x0.xR[i] = x0.xR[i - 1] + randomreal() / n0;
         }
         ae_vector_set_length(&x1, n1);
         x1.xR[0] = randomreal();
         for (i = 1; i < n1; i++) {
            x1.xR[i] = x1.xR[i - 1] + randomreal() / n1;
         }
         ae_vector_set_length(&needy, n0 * n1);
         v = pow(10.0, -3 * randomreal());
         for (i = 0; i < n0 * n1; i++) {
            needy.xB[i] = randombool(v);
         }
      // Test at grid
         ae_vector_set_length(&x, nx);
         rbfgridcalc2v(&s, &x0, n0, &x1, n1, &yv);
         for (i0 = 0; i0 < n0; i0++) {
            for (i1 = 0; i1 < n1; i1++) {
               x.xR[0] = x0.xR[i0];
               x.xR[1] = x1.xR[i1];
               rbfcalc(&s, &x, &y);
               for (i = 0; i < ny; i++) {
                  Ok = Ok && NearAtR(y.xR[i], yv.xR[i + ny * (i0 + i1 * n0)], errtol);
               }
            }
         }
      // Test calculation on subset of regular grid:
      // * Test 1: compare full and subset versions
      // * Test 2: check sparsity. Subset function may perform additional
      //   evaluations because it processes data micro-row by micro-row.
      //   So, we can't check that all elements which were not flagged
      //   are zero - some of them may become non-zero. However, if entire
      //   row is empty, we can reasonably expect (informal guarantee)
      //   that it is not processed. So, we check empty (completely
      //   unflagged) rows
      //
         SetVector(&yv2);
         rbfgridcalc2vsubset(&s, &x0, n0, &x1, n1, &needy, &yv2);
         for (i = 0; i < ny * n0 * n1; i++) {
            Ok = Ok && (!needy.xB[i / ny] || NearAtR(yv.xR[i], yv2.xR[i], errtol));
         }
      // Test legacy function
         rbfgridcalc2(&s, &x0, n0, &x1, n1, &y2);
         for (i = 0; i < n0 * n1; i++) {
            if (ny == 1) {
               Ok = Ok && NearAtR(yv.xR[i], y2.xyR[i % n0][i / n0], errtol);
            } else {
               Ok = Ok && y2.xyR[i % n0][i / n0] == 0.0;
            }
         }
      // Test that scaling RBase, XY, X0, X1 by some power of 2
      // does not change values at grid (quite a strict requirement, but
      // ALGLIB implementation of RBF may deal with it).
         scalefactor = pow(1024.0, (double)(2 * randominteger(2) - 1));
         ae_matrix_set_length(&xy2, n, nx + ny);
         ae_vector_set_length(&x02, n0);
         ae_vector_set_length(&x12, n1);
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               xy2.xyR[i][j] = xy.xyR[i][j] * scalefactor;
            }
            for (j = 0; j < ny; j++) {
               xy2.xyR[i][nx + j] = xy.xyR[i][nx + j];
            }
         }
         for (i = 0; i < n0; i++) {
            x02.xR[i] = x0.xR[i] * scalefactor;
         }
         for (i = 0; i < n1; i++) {
            x12.xR[i] = x1.xR[i] * scalefactor;
         }
         if (hasscale) {
            rbfsetpointsandscales(&s, &xy2, n, &scalevec);
         } else {
            rbfsetpoints(&s, &xy2, n);
         }
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase * scalefactor, nlayers, lambdav);
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         SetVector(&yv2);
         rbfgridcalc2v(&s, &x02, n0, &x12, n1, &yv2);
         for (i = 0; i < ny * n0 * n1; i++) {
            Ok = Ok && yv.xR[i] == yv2.xR[i];
         }
      // Test that scaling RBase and scale vector by some power of 2
      // (increase RBase and decreasing scale, or vice versa) does not
      // change values at grid (quite a strict requirement, but
      // ALGLIB implementation of RBF may deal with it).
         scalefactor = pow(1024.0, (double)(2 * randominteger(2) - 1));
         ae_vector_set_length(&scalevec2, nx);
         for (i = 0; i < nx; i++) {
            if (hasscale) {
               scalevec2.xR[i] = scalevec.xR[i];
            } else {
               scalevec2.xR[i] = 1.0;
            }
            scalevec2.xR[i] /= scalefactor;
         }
         rbfsetpointsandscales(&s, &xy, n, &scalevec2);
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase * scalefactor, nlayers, lambdav);
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         SetVector(&yv2);
         rbfgridcalc2v(&s, &x0, n0, &x1, n1, &yv2);
         for (i = 0; i < ny * n0 * n1; i++) {
            Ok = Ok && NearAtR(yv.xR[i], yv2.xR[i], 100.0 * machineepsilon * rmax3(fabs(yv.xR[i]), fabs(yv2.xR[i]), 1.0));
         }
      }
   }
// Test 3-dimensional grid calculation
   errtol = 1.0E-12;
   nx = 3;
   for (ny = 1; ny <= 4; ny++) {
      for (nkind = 0; nkind <= 2; nkind++) {
      // problem setup
         n = 150;
         rbase = 0.10;
         lambdav = 1.0E-3 * randominteger(2);
         nlayers = randominteger(3);
         linterm = 1 + randominteger(3);
         bf = randominteger(2);
         ae_matrix_set_length(&xy, n, nx + ny);
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = randomreal();
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = randomreal() - 0.5;
            }
         }
         hasscale = randominteger(2) == 0;
         if (hasscale) {
            ae_vector_set_length(&scalevec, nx);
            for (j = 0; j < nx; j++) {
               scalevec.xR[j] = pow(2.0, randommid());
            }
         }
      // Build model
         rbfcreate(nx, ny, &s);
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase, nlayers, lambdav);
         if (linterm == 1) {
            rbfsetlinterm(&s);
         }
         if (linterm == 2) {
            rbfsetconstterm(&s);
         }
         if (linterm == 3) {
            rbfsetzeroterm(&s);
         }
         if (hasscale) {
            rbfsetpointsandscales(&s, &xy, n, &scalevec);
         } else {
            rbfsetpoints(&s, &xy, n);
         }
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      // Prepare grid to test
         n0 = 1 + randominteger(50);
         n1 = 1 + randominteger(50);
         n2 = 1 + randominteger(50);
         if (nkind == 1) {
            k = randominteger(3);
            if (k == 0) {
               n0 = 1;
            }
            if (k == 1) {
               n1 = 1;
            }
            if (k == 2) {
               n2 = 1;
            }
         } else {
            if (nkind == 2) {
               n0 = 1;
               n1 = 1;
               n2 = 1;
            } else {
               ae_assert(nkind == 0, "Assertion failed");
            }
         }
         ae_vector_set_length(&x0, n0);
         x0.xR[0] = randomreal();
         for (i = 1; i < n0; i++) {
            x0.xR[i] = x0.xR[i - 1] + randomreal() / n0;
         }
         ae_vector_set_length(&x1, n1);
         x1.xR[0] = randomreal();
         for (i = 1; i < n1; i++) {
            x1.xR[i] = x1.xR[i - 1] + randomreal() / n1;
         }
         ae_vector_set_length(&x2, n2);
         x2.xR[0] = randomreal();
         for (i = 1; i < n2; i++) {
            x2.xR[i] = x2.xR[i - 1] + randomreal() / n2;
         }
         ae_vector_set_length(&needy, n0 * n1 * n2);
         v = pow(10.0, -3 * randomreal());
         for (i = 0; i < n0 * n1 * n2; i++) {
            needy.xB[i] = randombool(v);
         }
      // Test at grid
         ae_vector_set_length(&x, nx);
         rbfgridcalc3v(&s, &x0, n0, &x1, n1, &x2, n2, &yv);
         for (i0 = 0; i0 < n0; i0++) {
            for (i1 = 0; i1 < n1; i1++) {
               for (i2 = 0; i2 < n2; i2++) {
                  x.xR[0] = x0.xR[i0];
                  x.xR[1] = x1.xR[i1];
                  x.xR[2] = x2.xR[i2];
                  rbfcalc(&s, &x, &y);
                  for (i = 0; i < ny; i++) {
                     Ok = Ok && NearAtR(y.xR[i], yv.xR[i + ny * (i0 + i1 * n0 + i2 * n0 * n1)], errtol);
                  }
               }
            }
         }
      // Test calculation on subset of regular grid:
      // * Test 1: compare full and subset versions
      // * Test 2: check sparsity. Subset function may perform additional
      //   evaluations because it processes data micro-row by micro-row.
      //   So, we can't check that all elements which were not flagged
      //   are zero - some of them may become non-zero. However, if entire
      //   row is empty, we can reasonably expect (informal guarantee)
      //   that it is not processed. So, we check empty (completely
      //   unflagged) rows
      //
         ae_vector_set_length(&rowflags, n1 * n2);
         for (i = 0; i < n1 * n2; i++) {
            rowflags.xB[i] = false;
         }
         for (i = 0; i < n0 * n1 * n2; i++) {
            if (needy.xB[i]) {
               rowflags.xB[i / n0] = true;
            }
         }
         SetVector(&yv2);
         rbfgridcalc3vsubset(&s, &x0, n0, &x1, n1, &x2, n2, &needy, &yv2);
         for (i = 0; i < ny * n0 * n1 * n2; i++) {
            Ok = Ok && (!needy.xB[i / ny] || NearAtR(yv.xR[i], yv2.xR[i], errtol));
            Ok = Ok && (rowflags.xB[i / (ny * n0)] || yv2.xR[i] == 0.0);
         }
      // Test that scaling RBase, XY, X0, X1 and X2 by some power of 2
      // does not change values at grid (quite a strict requirement, but
      // ALGLIB implementation of RBF may deal with it).
         scalefactor = pow(1024.0, (double)(2 * randominteger(2) - 1));
         ae_matrix_set_length(&xy2, n, nx + ny);
         ae_vector_set_length(&x02, n0);
         ae_vector_set_length(&x12, n1);
         ae_vector_set_length(&x22, n2);
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               xy2.xyR[i][j] = xy.xyR[i][j] * scalefactor;
            }
            for (j = 0; j < ny; j++) {
               xy2.xyR[i][nx + j] = xy.xyR[i][nx + j];
            }
         }
         for (i = 0; i < n0; i++) {
            x02.xR[i] = x0.xR[i] * scalefactor;
         }
         for (i = 0; i < n1; i++) {
            x12.xR[i] = x1.xR[i] * scalefactor;
         }
         for (i = 0; i < n2; i++) {
            x22.xR[i] = x2.xR[i] * scalefactor;
         }
         if (hasscale) {
            rbfsetpointsandscales(&s, &xy2, n, &scalevec);
         } else {
            rbfsetpoints(&s, &xy2, n);
         }
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase * scalefactor, nlayers, lambdav);
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         SetVector(&yv2);
         rbfgridcalc3v(&s, &x02, n0, &x12, n1, &x22, n2, &yv2);
         for (i = 0; i < ny * n0 * n1 * n2; i++) {
            Ok = Ok && yv.xR[i] == yv2.xR[i];
         }
      // Test that scaling RBase and scale vector by some power of 2
      // (increase RBase and decreasing scale, or vice versa) does not
      // change values at grid (quite a strict requirement, but
      // ALGLIB implementation of RBF may deal with it).
         scalefactor = pow(1024.0, (double)(2 * randominteger(2) - 1));
         ae_vector_set_length(&scalevec2, nx);
         for (i = 0; i < nx; i++) {
            if (hasscale) {
               scalevec2.xR[i] = scalevec.xR[i];
            } else {
               scalevec2.xR[i] = 1.0;
            }
            scalevec2.xR[i] /= scalefactor;
         }
         rbfsetpointsandscales(&s, &xy, n, &scalevec2);
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase * scalefactor, nlayers, lambdav);
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         SetVector(&yv2);
         rbfgridcalc3v(&s, &x0, n0, &x1, n1, &x2, n2, &yv2);
         for (i = 0; i < ny * n0 * n1 * n2; i++) {
            Ok = Ok && NearAtR(yv.xR[i], yv2.xR[i], 100.0 * machineepsilon * rmax3(fabs(yv.xR[i]), fabs(yv2.xR[i]), 1.0));
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

bool testrbf() {
   bool specialOk;
   bool basicrbfOk;
   bool irregularrbfOk;
   bool linearitymodelrbfOk;
   bool sqrdegmatrixrbfOk;
   bool serOk;
   bool multilayerrbf1dOk;
   bool multilayerrbfOk;
   bool gridcalc23Ok;
   bool hrbfbasicOk;
   bool hrbfscaleOk;
   bool hrbfspecOk;
   bool hrbfgridOk;
   bool hrbfOk;
   bool Ok;
// HRBF tests
   hrbfbasicOk = testrbfunit_basichrbftest();
   hrbfspecOk = testrbfunit_spechrbftest();
   hrbfscaleOk = testrbfunit_scaledhrbftest();
   hrbfgridOk = testrbfunit_gridhrbftest();
   hrbfOk = hrbfbasicOk && hrbfspecOk && hrbfscaleOk && hrbfgridOk;
// Other tests
   specialOk = testrbfunit_specialtest();
   basicrbfOk = testrbfunit_basicrbftest();
   irregularrbfOk = testrbfunit_irregularrbftest();
   linearitymodelrbfOk = testrbfunit_linearitymodelrbftest();
   sqrdegmatrixrbfOk = sqrdegmatrixrbftest();
   multilayerrbf1dOk = basicmultilayerrbf1dtest(); //(@) This test was disabled in the distribution version.
   multilayerrbfOk = testrbfunit_basicmultilayerrbftest();
   serOk = testrbfunit_serializationtest();
   gridcalc23Ok = true;
   gridcalc23Ok = gridcalc23Ok && testrbfunit_gridcalc23test();
// The final report.
   Ok = specialOk && basicrbfOk && irregularrbfOk && linearitymodelrbfOk && sqrdegmatrixrbfOk && serOk && multilayerrbf1dOk && multilayerrbfOk && gridcalc23Ok && hrbfOk;
   if (!Ok || !silent) {
      printf("RBF Tests\n");
      printf("General Tests:\n");
      printf("* Serialization Test:                     %s\n", serOk? "Ok": "Failed");
      printf("* Special Properties:                     %s\n", specialOk? "Ok": "Failed");
      printf("RBF-V2:\n");
      printf("* Basic HRBF Test:                        %s\n", hrbfbasicOk? "Ok": "Failed");
      printf("* Scale-Related Tests:                    %s\n", hrbfscaleOk? "Ok": "Failed");
      printf("* Grid Calculation Tests:                 %s\n", hrbfgridOk? "Ok": "Failed");
      printf("* Special Properties:                     %s\n", hrbfspecOk? "Ok": "Failed");
      printf("RBF-V1:\n");
      printf("* Basic RBF Test:                         %s\n", basicrbfOk? "Ok": "Failed");
      printf("* Irregular RBF Test:                     %s\n", irregularrbfOk? "Ok": "Failed");
      printf("* Linearity Test:                         %s\n", linearitymodelrbfOk? "Ok": "Failed");
      printf("* Sqr Deg Matrix RBF Test:                %s\n", sqrdegmatrixrbfOk? "Ok": "Failed");
      printf("* Multi-Layer RBF Errors In 1D Test:      %s\n", multilayerrbf1dOk? "Ok": "Failed");
      printf("* Multi-Layer RBF Errors In 2-3D Test:    %s\n", multilayerrbfOk? "Ok": "Failed");
      printf("* Grid Calc 2/3 V:                        %s\n", gridcalc23Ok? "Ok": "Failed");
   // was errors?
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === fft testing unit ===
// Internal complex FFT stub.
// Uses straightforward formula with O(N^2) complexity.
static void testfftunit_refinternalcfft(RVector *a, ae_int_t nn, bool inversefft) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t k;
   double hre;
   double him;
   double c;
   double s;
   double re;
   double im;
   ae_frame_make(&_frame_block);
   NewVector(tmp, 0, DT_REAL);
   ae_vector_set_length(&tmp, 2 * nn);
   if (!inversefft) {
      for (i = 0; i < nn; i++) {
         hre = 0.0;
         him = 0.0;
         for (k = 0; k < nn; k++) {
            re = a->xR[2 * k];
            im = a->xR[2 * k + 1];
            c = cos(-2 * pi * k * i / nn);
            s = sin(-2 * pi * k * i / nn);
            hre += c * re - s * im;
            him += c * im + s * re;
         }
         tmp.xR[2 * i] = hre;
         tmp.xR[2 * i + 1] = him;
      }
      for (i = 0; i < 2 * nn; i++) {
         a->xR[i] = tmp.xR[i];
      }
   } else {
      for (k = 0; k < nn; k++) {
         hre = 0.0;
         him = 0.0;
         for (i = 0; i < nn; i++) {
            re = a->xR[2 * i];
            im = a->xR[2 * i + 1];
            c = cos(2 * pi * k * i / nn);
            s = sin(2 * pi * k * i / nn);
            hre += c * re - s * im;
            him += c * im + s * re;
         }
         tmp.xR[2 * k] = hre / nn;
         tmp.xR[2 * k + 1] = him / nn;
      }
      for (i = 0; i < 2 * nn; i++) {
         a->xR[i] = tmp.xR[i];
      }
   }
   ae_frame_leave();
}

// Internal real FFT stub.
// Uses straightforward formula with O(N^2) complexity.
static void testfftunit_refinternalrfft(RVector *a, ae_int_t nn, CVector *f) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   SetVector(f);
   NewVector(tmp, 0, DT_REAL);
   ae_vector_set_length(&tmp, 2 * nn);
   for (i = 0; i < nn; i++) {
      tmp.xR[2 * i] = a->xR[i];
      tmp.xR[2 * i + 1] = 0.0;
   }
   testfftunit_refinternalcfft(&tmp, nn, false);
   ae_vector_set_length(f, nn);
   for (i = 0; i < nn; i++) {
      f->xC[i] = complex_from_d(tmp.xR[2 * i], tmp.xR[2 * i + 1]);
   }
   ae_frame_leave();
}

// Reference FFT
static void testfftunit_reffftc1d(CVector *a, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewVector(buf, 0, DT_REAL);
   ae_assert(n > 0, "FFTC1D: incorrect N!");
   ae_vector_set_length(&buf, 2 * n);
   for (i = 0; i < n; i++) {
      buf.xR[2 * i] = a->xC[i].x;
      buf.xR[2 * i + 1] = a->xC[i].y;
   }
   testfftunit_refinternalcfft(&buf, n, false);
   for (i = 0; i < n; i++) {
      a->xC[i] = complex_from_d(buf.xR[2 * i], buf.xR[2 * i + 1]);
   }
   ae_frame_leave();
}

// Reference inverse FFT
static void testfftunit_reffftc1dinv(CVector *a, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewVector(buf, 0, DT_REAL);
   ae_assert(n > 0, "FFTC1DInv: incorrect N!");
   ae_vector_set_length(&buf, 2 * n);
   for (i = 0; i < n; i++) {
      buf.xR[2 * i] = a->xC[i].x;
      buf.xR[2 * i + 1] = a->xC[i].y;
   }
   testfftunit_refinternalcfft(&buf, n, true);
   for (i = 0; i < n; i++) {
      a->xC[i] = complex_from_d(buf.xR[2 * i], buf.xR[2 * i + 1]);
   }
   ae_frame_leave();
}

// This function performs real/complex FFT of given length on random data,
// selects K random components and compares them with values calculated by
// DFT definition.
//
// It updates RefErr and RefRErr as follows:
//     RefErr =  max(RefErr, error_of_complex_FFT)
//     RefRErr = max(RefRErr,error_of_real_FFT)
static void testfftunit_quicktest(ae_int_t n, double *referr, double *refrerr) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t idx;
   complex v;
   double c;
   double s;
   double re;
   double im;
   ae_frame_make(&_frame_block);
   NewVector(a0, 0, DT_COMPLEX);
   NewVector(a1, 0, DT_COMPLEX);
   k = 10;
// Complex FFT - forward and inverse
   ae_vector_set_length(&a0, n);
   ae_vector_set_length(&a1, n);
   for (i = 0; i < n; i++) {
      a0.xC[i] = complex_from_d(randommid(), randommid());
      a1.xC[i] = a0.xC[i];
   }
   fftc1d(&a0, n);
   for (i = 0; i < k; i++) {
      idx = randominteger(n);
      v = complex_from_i(0);
      for (j = 0; j < n; j++) {
         re = a1.xC[j].x;
         im = a1.xC[j].y;
         c = cos(-2 * pi * j * idx / n);
         s = sin(-2 * pi * j * idx / n);
         v.x += c * re - s * im;
         v.y += c * im + s * re;
      }
      *referr = rmax2(*referr, abscomplex(ae_c_sub(v, a0.xC[idx])));
   }
   fftc1dinv(&a0, n);
   for (i = 0; i < n; i++) {
      *referr = rmax2(*referr, abscomplex(ae_c_sub(a0.xC[i], a1.xC[i])));
   }
   ae_frame_leave();
}

// Test
bool testfft() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t k;
   ae_int_t maxsmalln;
   double bidierr;
   double bidirerr;
   double referr;
   double refrerr;
   double reinterr;
   double errtol;
   bool refOk;
   bool bidiOk;
   bool refrOk;
   bool bidirOk;
   bool reintOk;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(a1, 0, DT_COMPLEX);
   NewVector(a2, 0, DT_COMPLEX);
   NewVector(a3, 0, DT_COMPLEX);
   NewVector(r1, 0, DT_REAL);
   NewVector(r2, 0, DT_REAL);
   NewVector(buf, 0, DT_REAL);
   NewObj(fasttransformplan, plan);
   maxsmalln = 128;
   errtol = 100000 * pow((double)maxsmalln, 3.0 / 2.0) * machineepsilon;
   bidiOk = true;
   refOk = true;
   bidirOk = true;
   refrOk = true;
   reintOk = true;
   Ok = true;
// Test bi-directional error: norm(x-invFFT(FFT(x)))
   bidierr = 0.0;
   bidirerr = 0.0;
   for (n = 1; n <= maxsmalln; n++) {
   // Complex FFT/invFFT
      ae_vector_set_length(&a1, n);
      ae_vector_set_length(&a2, n);
      ae_vector_set_length(&a3, n);
      for (i = 0; i < n; i++) {
         a1.xC[i] = complex_from_d(randommid(), randommid());
         a2.xC[i] = a1.xC[i];
         a3.xC[i] = a1.xC[i];
      }
      fftc1d(&a2, n);
      fftc1dinv(&a2, n);
      fftc1dinv(&a3, n);
      fftc1d(&a3, n);
      for (i = 0; i < n; i++) {
         bidierr = rmax2(bidierr, abscomplex(ae_c_sub(a1.xC[i], a2.xC[i])));
         bidierr = rmax2(bidierr, abscomplex(ae_c_sub(a1.xC[i], a3.xC[i])));
      }
   // Real
      ae_vector_set_length(&r1, n);
      ae_vector_set_length(&r2, n);
      for (i = 0; i < n; i++) {
         r1.xR[i] = randommid();
         r2.xR[i] = r1.xR[i];
      }
      fftr1d(&r2, n, &a1);
      ae_v_muld(r2.xR, 1, n, 0);
      fftr1dinv(&a1, n, &r2);
      for (i = 0; i < n; i++) {
         bidirerr = rmax2(bidirerr, abscomplex(complex_from_d(r1.xR[i] - r2.xR[i])));
      }
   }
   bidiOk = bidiOk && bidierr <= errtol;
   bidirOk = bidirOk && bidirerr <= errtol;
// Test against reference O(N^2) implementation for small N's
// (we do not test large N's because reference implementation will be too slow).
   referr = 0.0;
   refrerr = 0.0;
   for (n = 1; n <= maxsmalln; n++) {
   // Complex FFT
      ae_vector_set_length(&a1, n);
      ae_vector_set_length(&a2, n);
      for (i = 0; i < n; i++) {
         a1.xC[i] = complex_from_d(randommid(), randommid());
         a2.xC[i] = a1.xC[i];
      }
      fftc1d(&a1, n);
      testfftunit_reffftc1d(&a2, n);
      for (i = 0; i < n; i++) {
         referr = rmax2(referr, abscomplex(ae_c_sub(a1.xC[i], a2.xC[i])));
      }
   // Complex inverse FFT
      ae_vector_set_length(&a1, n);
      ae_vector_set_length(&a2, n);
      for (i = 0; i < n; i++) {
         a1.xC[i] = complex_from_d(randommid(), randommid());
         a2.xC[i] = a1.xC[i];
      }
      fftc1dinv(&a1, n);
      testfftunit_reffftc1dinv(&a2, n);
      for (i = 0; i < n; i++) {
         referr = rmax2(referr, abscomplex(ae_c_sub(a1.xC[i], a2.xC[i])));
      }
   // Real forward/inverse FFT:
   // * calculate and check forward FFT
   // * use precalculated FFT to check backward FFT
   //   fill unused parts of frequencies array with random numbers
   //   to ensure that they are not really used
      ae_vector_set_length(&r1, n);
      ae_vector_set_length(&r2, n);
      for (i = 0; i < n; i++) {
         r1.xR[i] = randommid();
         r2.xR[i] = r1.xR[i];
      }
      fftr1d(&r1, n, &a1);
      testfftunit_refinternalrfft(&r2, n, &a2);
      for (i = 0; i < n; i++) {
         refrerr = rmax2(refrerr, abscomplex(ae_c_sub(a1.xC[i], a2.xC[i])));
      }
      ae_vector_set_length(&a3, ifloor((double)n / 2.0) + 1);
      for (i = 0; i <= ifloor((double)n / 2.0); i++) {
         a3.xC[i] = a2.xC[i];
      }
      a3.xC[0].y = randommid();
      if (n % 2 == 0) {
         a3.xC[ifloor((double)n / 2.0)].y = randommid();
      }
      for (i = 0; i < n; i++) {
         r1.xR[i] = 0.0;
      }
      fftr1dinv(&a3, n, &r1);
      for (i = 0; i < n; i++) {
         refrerr = rmax2(refrerr, fabs(r2.xR[i] - r1.xR[i]));
      }
   }
   refOk = refOk && referr <= errtol;
   refrOk = refrOk && refrerr <= errtol;
// Test for large N's:
// * we perform FFT
// * we selectively calculate K (small number) of DFT components (using reference formula)
//   and compare them with ones calculated by fast implementation
// * K components to test are chosen at random (random sampling with possible repetitions)
// * overall complexity of the test is O(N*logN+K*N)
// Several N's are tested, with different kinds of factorizations
   referr = 0.0;
   refrerr = 0.0;
   testfftunit_quicktest(1000, &referr, &refrerr);
   testfftunit_quicktest(1024, &referr, &refrerr);
   testfftunit_quicktest(1025, &referr, &refrerr);
   testfftunit_quicktest(2000, &referr, &refrerr);
   testfftunit_quicktest(2048, &referr, &refrerr);
   testfftunit_quicktest(6535, &referr, &refrerr);
   testfftunit_quicktest(65536, &referr, &refrerr);
   testfftunit_quicktest(104729, &referr, &refrerr);
   testfftunit_quicktest(139129, &referr, &refrerr);
   testfftunit_quicktest(141740, &referr, &refrerr);
   refOk = refOk && referr <= errtol;
   refrOk = refrOk && refrerr <= errtol;
// test internal real even FFT
   reinterr = 0.0;
   for (k = 1; k <= maxsmalln / 2; k++) {
      n = 2 * k;
   // Real forward FFT
      ae_vector_set_length(&r1, n);
      ae_vector_set_length(&r2, n);
      for (i = 0; i < n; i++) {
         r1.xR[i] = randommid();
         r2.xR[i] = r1.xR[i];
      }
      ftcomplexfftplan(n / 2, 1, &plan);
      ae_vector_set_length(&buf, n);
      fftr1dinternaleven(&r1, n, &buf, &plan);
      testfftunit_refinternalrfft(&r2, n, &a2);
      reinterr = rmax2(reinterr, fabs(r1.xR[0] - a2.xC[0].x));
      reinterr = rmax2(reinterr, fabs(r1.xR[1] - a2.xC[n / 2].x));
      for (i = 1; i < n / 2; i++) {
         reinterr = rmax2(reinterr, fabs(r1.xR[2 * i] - a2.xC[i].x));
         reinterr = rmax2(reinterr, fabs(r1.xR[2 * i + 1] - a2.xC[i].y));
      }
   // Real backward FFT
      ae_vector_set_length(&r1, n);
      for (i = 0; i < n; i++) {
         r1.xR[i] = randommid();
      }
      ae_vector_set_length(&a2, ifloor((double)n / 2.0) + 1);
      a2.xC[0] = complex_from_d(r1.xR[0]);
      for (i = 1; i < ifloor((double)n / 2.0); i++) {
         a2.xC[i] = complex_from_d(r1.xR[2 * i], r1.xR[2 * i + 1]);
      }
      a2.xC[ifloor((double)n / 2.0)] = complex_from_d(r1.xR[1]);
      ftcomplexfftplan(n / 2, 1, &plan);
      ae_vector_set_length(&buf, n);
      fftr1dinvinternaleven(&r1, n, &buf, &plan);
      fftr1dinv(&a2, n, &r2);
      for (i = 0; i < n; i++) {
         reinterr = rmax2(reinterr, fabs(r1.xR[i] - r2.xR[i]));
      }
   }
   reintOk = reintOk && reinterr <= errtol;
// The final report.
   Ok = bidiOk && bidirOk && refOk && refrOk && reintOk;
   if (!Ok || !silent) {
      printf("FFT Tests\n");
      printf("* Bi-Directional Complex Test:            %s\n", bidiOk? "Ok": "Failed");
      printf("* Against Reference Complex FFT:          %s\n", refOk? "Ok": "Failed");
      printf("* Bi-Directional Real Test:               %s\n", bidirOk? "Ok": "Failed");
      printf("* Against Reference Real FFT:             %s\n", refrOk? "Ok": "Failed");
      printf("* Internal Even FFT:                      %s\n", reintOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === fht testing unit ===
// Reference FHT
static void testfhtunit_reffhtr1d(RVector *a, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_frame_make(&_frame_block);
   NewVector(buf, 0, DT_REAL);
   ae_assert(n > 0, "RefFHTR1D: incorrect N!");
   ae_vector_set_length(&buf, n);
   for (i = 0; i < n; i++) {
      v = 0.0;
      for (j = 0; j < n; j++) {
         v += a->xR[j] * (cos(2 * pi * i * j / n) + sin(2 * pi * i * j / n));
      }
      buf.xR[i] = v;
   }
   for (i = 0; i < n; i++) {
      a->xR[i] = buf.xR[i];
   }
   ae_frame_leave();
}

// Reference inverse FHT
static void testfhtunit_reffhtr1dinv(RVector *a, ae_int_t n) {
   ae_int_t i;
   ae_assert(n > 0, "RefFHTR1DInv: incorrect N!");
   testfhtunit_reffhtr1d(a, n);
   for (i = 0; i < n; i++) {
      a->xR[i] /= n;
   }
}

// Test
bool testfht() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t maxn;
   double bidierr;
   double referr;
   double errtol;
   bool refOk;
   bool bidiOk;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(r1, 0, DT_REAL);
   NewVector(r2, 0, DT_REAL);
   NewVector(r3, 0, DT_REAL);
   maxn = 128;
   errtol = 100000 * pow((double)maxn, 3.0 / 2.0) * machineepsilon;
   bidiOk = true;
   refOk = true;
   Ok = true;
// Test bi-directional error: norm(x-invFHT(FHT(x)))
   bidierr = 0.0;
   for (n = 1; n <= maxn; n++) {
   // FHT/invFHT
      ae_vector_set_length(&r1, n);
      ae_vector_set_length(&r2, n);
      ae_vector_set_length(&r3, n);
      for (i = 0; i < n; i++) {
         r1.xR[i] = randommid();
         r2.xR[i] = r1.xR[i];
         r3.xR[i] = r1.xR[i];
      }
      fhtr1d(&r2, n);
      fhtr1dinv(&r2, n);
      fhtr1dinv(&r3, n);
      fhtr1d(&r3, n);
      for (i = 0; i < n; i++) {
         bidierr = rmax2(bidierr, fabs(r1.xR[i] - r2.xR[i]));
         bidierr = rmax2(bidierr, fabs(r1.xR[i] - r3.xR[i]));
      }
   }
   bidiOk = bidiOk && bidierr <= errtol;
// Test against reference O(N^2) implementation
   referr = 0.0;
   for (n = 1; n <= maxn; n++) {
   // FHT
      ae_vector_set_length(&r1, n);
      ae_vector_set_length(&r2, n);
      for (i = 0; i < n; i++) {
         r1.xR[i] = randommid();
         r2.xR[i] = r1.xR[i];
      }
      fhtr1d(&r1, n);
      testfhtunit_reffhtr1d(&r2, n);
      for (i = 0; i < n; i++) {
         referr = rmax2(referr, fabs(r1.xR[i] - r2.xR[i]));
      }
   // inverse FHT
      ae_vector_set_length(&r1, n);
      ae_vector_set_length(&r2, n);
      for (i = 0; i < n; i++) {
         r1.xR[i] = randommid();
         r2.xR[i] = r1.xR[i];
      }
      fhtr1dinv(&r1, n);
      testfhtunit_reffhtr1dinv(&r2, n);
      for (i = 0; i < n; i++) {
         referr = rmax2(referr, fabs(r1.xR[i] - r2.xR[i]));
      }
   }
   refOk = refOk && referr <= errtol;
// The final report.
   Ok = bidiOk && refOk;
   if (!Ok || !silent) {
      printf("FHT Tests\n");
      printf("* Bi-Directional Test:                    %s\n", bidiOk? "Ok": "Failed");
      printf("* Against Reference FHT:                  %s\n", refOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === conv testing unit ===
// Reference FFT
static void testconvunit_refconvr1d(RVector *a, ae_int_t m, RVector *b, ae_int_t n, RVector *r) {
   ae_int_t i;
   double v;
   SetVector(r);
   ae_vector_set_length(r, m + n - 1);
   for (i = 0; i < m + n - 1; i++) {
      r->xR[i] = 0.0;
   }
   for (i = 0; i < m; i++) {
      v = a->xR[i];
      ae_v_addd(&r->xR[i], 1, b->xR, 1, n, v);
   }
}

// Reference implementation
static void testconvunit_refconvc1d(CVector *a, ae_int_t m, CVector *b, ae_int_t n, CVector *r) {
   ae_int_t i;
   complex v;
   SetVector(r);
   ae_vector_set_length(r, m + n - 1);
   for (i = 0; i < m + n - 1; i++) {
      r->xC[i] = complex_from_i(0);
   }
   for (i = 0; i < m; i++) {
      v = a->xC[i];
      ae_v_caddc(&r->xC[i], 1, b->xC, 1, "N", n, v);
   }
}

// Reference implementation
static void testconvunit_refconvr1dcircular(RVector *a, ae_int_t m, RVector *b, ae_int_t n, RVector *r) {
   ae_frame _frame_block;
   ae_int_t i1;
   ae_int_t i2;
   ae_int_t j2;
   ae_frame_make(&_frame_block);
   SetVector(r);
   NewVector(buf, 0, DT_REAL);
   testconvunit_refconvr1d(a, m, b, n, &buf);
   ae_vector_set_length(r, m);
   ae_v_move(r->xR, 1, buf.xR, 1, m);
   i1 = m;
   while (i1 < m + n - 1) {
      i2 = imin2(i1 + m - 1, m + n - 2);
      j2 = i2 - i1;
      ae_v_add(r->xR, 1, &buf.xR[i1], 1, j2 + 1);
      i1 += m;
   }
   ae_frame_leave();
}

// Reference implementation
static void testconvunit_refconvc1dcircular(CVector *a, ae_int_t m, CVector *b, ae_int_t n, CVector *r) {
   ae_frame _frame_block;
   ae_int_t i1;
   ae_int_t i2;
   ae_int_t j2;
   ae_frame_make(&_frame_block);
   SetVector(r);
   NewVector(buf, 0, DT_COMPLEX);
   testconvunit_refconvc1d(a, m, b, n, &buf);
   ae_vector_set_length(r, m);
   ae_v_cmove(r->xC, 1, buf.xC, 1, "N", m);
   i1 = m;
   while (i1 < m + n - 1) {
      i2 = imin2(i1 + m - 1, m + n - 2);
      j2 = i2 - i1;
      ae_v_cadd(r->xC, 1, &buf.xC[i1], 1, "N", j2 + 1);
      i1 += m;
   }
   ae_frame_leave();
}

// Test
bool testconv() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t i;
   ae_int_t rkind;
   ae_int_t circkind;
   ae_int_t maxn;
   double referr;
   double refrerr;
   double inverr;
   double invrerr;
   double errtol;
   bool refOk;
   bool refrOk;
   bool invOk;
   bool invrOk;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(ra, 0, DT_REAL);
   NewVector(rb, 0, DT_REAL);
   NewVector(rr1, 0, DT_REAL);
   NewVector(rr2, 0, DT_REAL);
   NewVector(ca, 0, DT_COMPLEX);
   NewVector(cb, 0, DT_COMPLEX);
   NewVector(cr1, 0, DT_COMPLEX);
   NewVector(cr2, 0, DT_COMPLEX);
   maxn = 32;
   errtol = 100000 * pow((double)maxn, 3.0 / 2.0) * machineepsilon;
   refOk = true;
   refrOk = true;
   invOk = true;
   invrOk = true;
   Ok = true;
// Test against reference O(N^2) implementation.
//
// Automatic ConvC1D() and different algorithms of ConvC1DX() are tested.
   referr = 0.0;
   refrerr = 0.0;
   for (m = 1; m <= maxn; m++) {
      for (n = 1; n <= maxn; n++) {
         for (circkind = 0; circkind <= 1; circkind++) {
            for (rkind = -3; rkind <= 1; rkind++) {
            // skip impossible combinations of parameters:
            // * circular convolution, M < N, RKind != -3 - internal subroutine does not support M < N.
               if (circkind != 0 && m < n && rkind != -3) {
                  continue;
               }
            // Complex convolution
               ae_vector_set_length(&ca, m);
               for (i = 0; i < m; i++) {
                  ca.xC[i] = complex_from_d(randommid(), randommid());
               }
               ae_vector_set_length(&cb, n);
               for (i = 0; i < n; i++) {
                  cb.xC[i] = complex_from_d(randommid(), randommid());
               }
               ae_vector_set_length(&cr1, 1);
               if (rkind == -3) {
               // test wrapper subroutine:
               // * circular/non-circular
                  if (circkind == 0) {
                     convc1d(&ca, m, &cb, n, &cr1);
                  } else {
                     convc1dcircular(&ca, m, &cb, n, &cr1);
                  }
               } else {
               // test internal subroutine
                  if (m >= n) {
                  // test internal subroutine:
                  // * circular/non-circular mode
                     convc1dx(&ca, m, &cb, n, circkind != 0, rkind, 0, &cr1);
                  } else {
                  // test internal subroutine - circular mode only
                     ae_assert(circkind == 0, "Convolution test: internal error!");
                     convc1dx(&cb, n, &ca, m, false, rkind, 0, &cr1);
                  }
               }
               if (circkind == 0) {
                  testconvunit_refconvc1d(&ca, m, &cb, n, &cr2);
               } else {
                  testconvunit_refconvc1dcircular(&ca, m, &cb, n, &cr2);
               }
               if (circkind == 0) {
                  for (i = 0; i < m + n - 1; i++) {
                     referr = rmax2(referr, abscomplex(ae_c_sub(cr1.xC[i], cr2.xC[i])));
                  }
               } else {
                  for (i = 0; i < m; i++) {
                     referr = rmax2(referr, abscomplex(ae_c_sub(cr1.xC[i], cr2.xC[i])));
                  }
               }
            // Real convolution
               ae_vector_set_length(&ra, m);
               for (i = 0; i < m; i++) {
                  ra.xR[i] = randommid();
               }
               ae_vector_set_length(&rb, n);
               for (i = 0; i < n; i++) {
                  rb.xR[i] = randommid();
               }
               ae_vector_set_length(&rr1, 1);
               if (rkind == -3) {
               // test wrapper subroutine:
               // * circular/non-circular
                  if (circkind == 0) {
                     convr1d(&ra, m, &rb, n, &rr1);
                  } else {
                     convr1dcircular(&ra, m, &rb, n, &rr1);
                  }
               } else {
                  if (m >= n) {
                  // test internal subroutine:
                  // * circular/non-circular mode
                     convr1dx(&ra, m, &rb, n, circkind != 0, rkind, 0, &rr1);
                  } else {
                  // test internal subroutine - non-circular mode only
                     convr1dx(&rb, n, &ra, m, circkind != 0, rkind, 0, &rr1);
                  }
               }
               if (circkind == 0) {
                  testconvunit_refconvr1d(&ra, m, &rb, n, &rr2);
               } else {
                  testconvunit_refconvr1dcircular(&ra, m, &rb, n, &rr2);
               }
               if (circkind == 0) {
                  for (i = 0; i < m + n - 1; i++) {
                     refrerr = rmax2(refrerr, fabs(rr1.xR[i] - rr2.xR[i]));
                  }
               } else {
                  for (i = 0; i < m; i++) {
                     refrerr = rmax2(refrerr, fabs(rr1.xR[i] - rr2.xR[i]));
                  }
               }
            }
         }
      }
   }
   refOk = refOk && referr <= errtol;
   refrOk = refrOk && refrerr <= errtol;
// Test inverse convolution
   inverr = 0.0;
   invrerr = 0.0;
   for (m = 1; m <= maxn; m++) {
      for (n = 1; n <= maxn; n++) {
      // Complex circilar and non-circular
         ae_vector_set_length(&ca, m);
         for (i = 0; i < m; i++) {
            ca.xC[i] = complex_from_d(randommid(), randommid());
         }
         ae_vector_set_length(&cb, n);
         for (i = 0; i < n; i++) {
            cb.xC[i] = complex_from_d(randommid(), randommid());
         }
         ae_vector_set_length(&cr1, 1);
         ae_vector_set_length(&cr2, 1);
         convc1d(&ca, m, &cb, n, &cr2);
         convc1dinv(&cr2, m + n - 1, &cb, n, &cr1);
         for (i = 0; i < m; i++) {
            inverr = rmax2(inverr, abscomplex(ae_c_sub(cr1.xC[i], ca.xC[i])));
         }
         ae_vector_set_length(&cr1, 1);
         ae_vector_set_length(&cr2, 1);
         convc1dcircular(&ca, m, &cb, n, &cr2);
         convc1dcircularinv(&cr2, m, &cb, n, &cr1);
         for (i = 0; i < m; i++) {
            inverr = rmax2(inverr, abscomplex(ae_c_sub(cr1.xC[i], ca.xC[i])));
         }
      // Real circilar and non-circular
         ae_vector_set_length(&ra, m);
         for (i = 0; i < m; i++) {
            ra.xR[i] = randommid();
         }
         ae_vector_set_length(&rb, n);
         for (i = 0; i < n; i++) {
            rb.xR[i] = randommid();
         }
         ae_vector_set_length(&rr1, 1);
         ae_vector_set_length(&rr2, 1);
         convr1d(&ra, m, &rb, n, &rr2);
         convr1dinv(&rr2, m + n - 1, &rb, n, &rr1);
         for (i = 0; i < m; i++) {
            invrerr = rmax2(invrerr, fabs(rr1.xR[i] - ra.xR[i]));
         }
         ae_vector_set_length(&rr1, 1);
         ae_vector_set_length(&rr2, 1);
         convr1dcircular(&ra, m, &rb, n, &rr2);
         convr1dcircularinv(&rr2, m, &rb, n, &rr1);
         for (i = 0; i < m; i++) {
            invrerr = rmax2(invrerr, fabs(rr1.xR[i] - ra.xR[i]));
         }
      }
   }
   invOk = invOk && inverr <= errtol;
   invrOk = invrOk && invrerr <= errtol;
// The final report.
   Ok = refOk && refrOk && invOk && invrOk;
   if (!Ok || !silent) {
      printf("Convolution Tests\n");
      printf("* Against Reference Complex Conv:         %s\n", refOk? "Ok": "Failed");
      printf("* Against Reference Real Conv:            %s\n", refrOk? "Ok": "Failed");
      printf("* Complex Inverse:                        %s\n", invOk? "Ok": "Failed");
      printf("* Real Inverse:                           %s\n", invrOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === corr testing unit ===
// Reference implementation
static void testcorrunit_refcorrr1d(RVector *signal, ae_int_t n, RVector *pattern, ae_int_t m, RVector *r) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_frame_make(&_frame_block);
   SetVector(r);
   NewVector(s, 0, DT_REAL);
   ae_vector_set_length(&s, m + n - 1);
   ae_v_move(s.xR, 1, signal->xR, 1, n);
   for (i = n; i < m + n - 1; i++) {
      s.xR[i] = 0.0;
   }
   ae_vector_set_length(r, m + n - 1);
   for (i = 0; i < n; i++) {
      v = 0.0;
      for (j = 0; j < m; j++) {
         if (i + j >= n) {
            break;
         }
         v += pattern->xR[j] * s.xR[i + j];
      }
      r->xR[i] = v;
   }
   for (i = 1; i < m; i++) {
      v = 0.0;
      for (j = i; j < m; j++) {
         v += pattern->xR[j] * s.xR[-i + j];
      }
      r->xR[m + n - 1 - i] = v;
   }
   ae_frame_leave();
}

// Reference implementation
static void testcorrunit_refcorrc1d(CVector *signal, ae_int_t n, CVector *pattern, ae_int_t m, CVector *r) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   complex v;
   ae_frame_make(&_frame_block);
   SetVector(r);
   NewVector(s, 0, DT_COMPLEX);
   ae_vector_set_length(&s, m + n - 1);
   ae_v_cmove(s.xC, 1, signal->xC, 1, "N", n);
   for (i = n; i < m + n - 1; i++) {
      s.xC[i] = complex_from_i(0);
   }
   ae_vector_set_length(r, m + n - 1);
   for (i = 0; i < n; i++) {
      v = complex_from_i(0);
      for (j = 0; j < m; j++) {
         if (i + j >= n) {
            break;
         }
         v = ae_c_add(v, ae_c_mul(conj(pattern->xC[j]), s.xC[i + j]));
      }
      r->xC[i] = v;
   }
   for (i = 1; i < m; i++) {
      v = complex_from_i(0);
      for (j = i; j < m; j++) {
         v = ae_c_add(v, ae_c_mul(conj(pattern->xC[j]), s.xC[j - i]));
      }
      r->xC[m + n - 1 - i] = v;
   }
   ae_frame_leave();
}

// Reference implementation
static void testcorrunit_refcorrr1dcircular(RVector *signal, ae_int_t n, RVector *pattern, ae_int_t m, RVector *r) {
   ae_int_t i;
   ae_int_t j;
   double v;
   SetVector(r);
   ae_vector_set_length(r, n);
   for (i = 0; i < n; i++) {
      v = 0.0;
      for (j = 0; j < m; j++) {
         v += pattern->xR[j] * signal->xR[(i + j) % n];
      }
      r->xR[i] = v;
   }
}

// Reference implementation
static void testcorrunit_refcorrc1dcircular(CVector *signal, ae_int_t n, CVector *pattern, ae_int_t m, CVector *r) {
   ae_int_t i;
   ae_int_t j;
   complex v;
   SetVector(r);
   ae_vector_set_length(r, n);
   for (i = 0; i < n; i++) {
      v = complex_from_i(0);
      for (j = 0; j < m; j++) {
         v = ae_c_add(v, ae_c_mul(conj(pattern->xC[j]), signal->xC[(i + j) % n]));
      }
      r->xC[i] = v;
   }
}

// Test
bool testcorr() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t i;
   ae_int_t maxn;
   double referr;
   double refrerr;
   double errtol;
   bool refOk;
   bool refrOk;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(ra, 0, DT_REAL);
   NewVector(rb, 0, DT_REAL);
   NewVector(rr1, 0, DT_REAL);
   NewVector(rr2, 0, DT_REAL);
   NewVector(ca, 0, DT_COMPLEX);
   NewVector(cb, 0, DT_COMPLEX);
   NewVector(cr1, 0, DT_COMPLEX);
   NewVector(cr2, 0, DT_COMPLEX);
   maxn = 32;
   errtol = 100000 * pow((double)maxn, 3.0 / 2.0) * machineepsilon;
   refOk = true;
   refrOk = true;
   Ok = true;
// Test against reference O(N^2) implementation.
   referr = 0.0;
   refrerr = 0.0;
   for (m = 1; m <= maxn; m++) {
      for (n = 1; n <= maxn; n++) {
      // Complex correlation
         ae_vector_set_length(&ca, m);
         for (i = 0; i < m; i++) {
            ca.xC[i] = complex_from_d(randommid(), randommid());
         }
         ae_vector_set_length(&cb, n);
         for (i = 0; i < n; i++) {
            cb.xC[i] = complex_from_d(randommid(), randommid());
         }
         ae_vector_set_length(&cr1, 1);
         corrc1d(&ca, m, &cb, n, &cr1);
         testcorrunit_refcorrc1d(&ca, m, &cb, n, &cr2);
         for (i = 0; i < m + n - 1; i++) {
            referr = rmax2(referr, abscomplex(ae_c_sub(cr1.xC[i], cr2.xC[i])));
         }
         ae_vector_set_length(&cr1, 1);
         corrc1dcircular(&ca, m, &cb, n, &cr1);
         testcorrunit_refcorrc1dcircular(&ca, m, &cb, n, &cr2);
         for (i = 0; i < m; i++) {
            referr = rmax2(referr, abscomplex(ae_c_sub(cr1.xC[i], cr2.xC[i])));
         }
      // Real correlation
         ae_vector_set_length(&ra, m);
         for (i = 0; i < m; i++) {
            ra.xR[i] = randommid();
         }
         ae_vector_set_length(&rb, n);
         for (i = 0; i < n; i++) {
            rb.xR[i] = randommid();
         }
         ae_vector_set_length(&rr1, 1);
         corrr1d(&ra, m, &rb, n, &rr1);
         testcorrunit_refcorrr1d(&ra, m, &rb, n, &rr2);
         for (i = 0; i < m + n - 1; i++) {
            refrerr = rmax2(refrerr, fabs(rr1.xR[i] - rr2.xR[i]));
         }
         ae_vector_set_length(&rr1, 1);
         corrr1dcircular(&ra, m, &rb, n, &rr1);
         testcorrunit_refcorrr1dcircular(&ra, m, &rb, n, &rr2);
         for (i = 0; i < m; i++) {
            refrerr = rmax2(refrerr, fabs(rr1.xR[i] - rr2.xR[i]));
         }
      }
   }
   refOk = refOk && referr <= errtol;
   refrOk = refrOk && refrerr <= errtol;
// The final report.
   Ok = refOk && refrOk;
   if (!Ok || !silent) {
      printf("Correlation Tests\n");
      printf("* Against Reference Complex Corr:         %s\n", refOk? "Ok": "Failed");
      printf("* Against Reference Real Corr:            %s\n", refrOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === chebyshev testing unit ===
bool testchebyshev() {
   ae_frame _frame_block;
   double err;
   double sumerr;
   double cerr;
   double ferr;
   double threshold;
   double x;
   double v;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t maxn;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(c, 0, DT_REAL);
   NewVector(p1, 0, DT_REAL);
   NewVector(p2, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   err = 0.0;
   sumerr = 0.0;
   cerr = 0.0;
   ferr = 0.0;
   threshold = 1.0E-9;
   Ok = true;
// Testing Chebyshev polynomials of the first kind
   err = rmax2(err, fabs(chebyshevcalculate(1, 0, 0.00) - 1));
   err = rmax2(err, fabs(chebyshevcalculate(1, 0, 0.33) - 1));
   err = rmax2(err, fabs(chebyshevcalculate(1, 0, -0.42) - 1));
   x = 0.2;
   err = rmax2(err, fabs(chebyshevcalculate(1, 1, x) - 0.2));
   x = 0.4;
   err = rmax2(err, fabs(chebyshevcalculate(1, 1, x) - 0.4));
   x = 0.6;
   err = rmax2(err, fabs(chebyshevcalculate(1, 1, x) - 0.6));
   x = 0.8;
   err = rmax2(err, fabs(chebyshevcalculate(1, 1, x) - 0.8));
   x = 1.0;
   err = rmax2(err, fabs(chebyshevcalculate(1, 1, x) - 1.0));
   x = 0.2;
   err = rmax2(err, fabs(chebyshevcalculate(1, 2, x) + 0.92));
   x = 0.4;
   err = rmax2(err, fabs(chebyshevcalculate(1, 2, x) + 0.68));
   x = 0.6;
   err = rmax2(err, fabs(chebyshevcalculate(1, 2, x) + 0.28));
   x = 0.8;
   err = rmax2(err, fabs(chebyshevcalculate(1, 2, x) - 0.28));
   x = 1.0;
   err = rmax2(err, fabs(chebyshevcalculate(1, 2, x) - 1.00));
   n = 10;
   err = rmax2(err, fabs(chebyshevcalculate(1, n, 0.2) - 0.4284556288));
   n = 11;
   err = rmax2(err, fabs(chebyshevcalculate(1, n, 0.2) + 0.7996160205));
   n = 12;
   err = rmax2(err, fabs(chebyshevcalculate(1, n, 0.2) + 0.7483020370));
// Testing Chebyshev polynomials of the second kind
   n = 0;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) - 1.0000000000));
   n = 1;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) - 0.4000000000));
   n = 2;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) + 0.8400000000));
   n = 3;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) + 0.7360000000));
   n = 4;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) - 0.5456000000));
   n = 10;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) - 0.6128946176));
   n = 11;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) + 0.6770370970));
   n = 12;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) + 0.8837094564));
// Testing Clenshaw summation
   maxn = 20;
   ae_vector_set_length(&c, maxn + 1);
   for (k = 1; k <= 2; k++) {
      for (pass = 1; pass <= 10; pass++) {
         x = randommid();
         v = 0.0;
         for (n = 0; n <= maxn; n++) {
            c.xR[n] = randommid();
            v += chebyshevcalculate(k, n, x) * c.xR[n];
            sumerr = rmax2(sumerr, fabs(v - chebyshevsum(&c, k, n, x)));
         }
      }
   }
// Testing coefficients
   chebyshevcoefficients(0, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 1));
   chebyshevcoefficients(1, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 1));
   chebyshevcoefficients(2, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] + 1));
   cerr = rmax2(cerr, fabs(c.xR[1] - 0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 2));
   chebyshevcoefficients(3, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 3));
   cerr = rmax2(cerr, fabs(c.xR[2] - 0));
   cerr = rmax2(cerr, fabs(c.xR[3] - 4));
   chebyshevcoefficients(4, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 1));
   cerr = rmax2(cerr, fabs(c.xR[1] - 0));
   cerr = rmax2(cerr, fabs(c.xR[2] + 8));
   cerr = rmax2(cerr, fabs(c.xR[3] - 0));
   cerr = rmax2(cerr, fabs(c.xR[4] - 8));
   chebyshevcoefficients(9, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 9));
   cerr = rmax2(cerr, fabs(c.xR[2] - 0));
   cerr = rmax2(cerr, fabs(c.xR[3] + 120));
   cerr = rmax2(cerr, fabs(c.xR[4] - 0));
   cerr = rmax2(cerr, fabs(c.xR[5] - 432));
   cerr = rmax2(cerr, fabs(c.xR[6] - 0));
   cerr = rmax2(cerr, fabs(c.xR[7] + 576));
   cerr = rmax2(cerr, fabs(c.xR[8] - 0));
   cerr = rmax2(cerr, fabs(c.xR[9] - 256));
// Testing FromChebyshev
   maxn = 10;
   ae_matrix_set_length(&a, maxn + 1, maxn + 1);
   for (i = 0; i <= maxn; i++) {
      for (j = 0; j <= maxn; j++) {
         a.xyR[i][j] = 0.0;
      }
      chebyshevcoefficients(i, &c);
      ae_v_move(a.xyR[i], 1, c.xR, 1, i + 1);
   }
   ae_vector_set_length(&c, maxn + 1);
   ae_vector_set_length(&p1, maxn + 1);
   for (n = 0; n <= maxn; n++) {
      for (pass = 1; pass <= 10; pass++) {
         for (i = 0; i <= n; i++) {
            p1.xR[i] = 0.0;
         }
         for (i = 0; i <= n; i++) {
            c.xR[i] = randommid();
            v = c.xR[i];
            ae_v_addd(p1.xR, 1, a.xyR[i], 1, i + 1, v);
         }
         fromchebyshev(&c, n, &p2);
         for (i = 0; i <= n; i++) {
            ferr = rmax2(ferr, fabs(p1.xR[i] - p2.xR[i]));
         }
      }
   }
// The final report.
   Ok = err <= threshold && sumerr <= threshold && cerr <= threshold && ferr <= threshold;
   if (!Ok || !silent) {
      printf("Calculation of the Chebyshev Polynomials Tests\n");
      printf("Max Error Against Table:                  %5.2e\n", err);
      printf("Summation Error:                          %5.2e\n", sumerr);
      printf("Coefficients Error:                       %5.2e\n", cerr);
      printf("Frobenius-Chebyshev Error:                %5.2e\n", ferr);
      printf("Threshold:                                %5.2e\n", threshold);
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === hermite testing unit ===
bool testhermite() {
   ae_frame _frame_block;
   double err;
   double sumerr;
   double cerr;
   double threshold;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t pass;
   double x;
   double v;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(c, 0, DT_REAL);
   err = 0.0;
   sumerr = 0.0;
   cerr = 0.0;
   threshold = 1.0E-9;
   Ok = true;
// Testing Hermite polynomials
   n = 0;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) - 1));
   n = 1;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) - 2));
   n = 2;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) - 2));
   n = 3;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) + 4));
   n = 4;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) + 20));
   n = 5;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) + 8));
   n = 6;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) - 184));
   n = 7;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) - 464));
   n = 11;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) - 230848));
   n = 12;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) - 280768));
// Testing Clenshaw summation
   maxn = 10;
   ae_vector_set_length(&c, maxn + 1);
   for (pass = 1; pass <= 10; pass++) {
      x = randommid();
      v = 0.0;
      for (n = 0; n <= maxn; n++) {
         c.xR[n] = randommid();
         v += hermitecalculate(n, x) * c.xR[n];
         sumerr = rmax2(sumerr, fabs(v - hermitesum(&c, n, x)));
      }
   }
// Testing coefficients
   hermitecoefficients(0, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 1));
   hermitecoefficients(1, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 2));
   hermitecoefficients(2, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] + 2));
   cerr = rmax2(cerr, fabs(c.xR[1] - 0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 4));
   hermitecoefficients(3, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 12));
   cerr = rmax2(cerr, fabs(c.xR[2] - 0));
   cerr = rmax2(cerr, fabs(c.xR[3] - 8));
   hermitecoefficients(4, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 12));
   cerr = rmax2(cerr, fabs(c.xR[1] - 0));
   cerr = rmax2(cerr, fabs(c.xR[2] + 48));
   cerr = rmax2(cerr, fabs(c.xR[3] - 0));
   cerr = rmax2(cerr, fabs(c.xR[4] - 16));
   hermitecoefficients(5, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 120));
   cerr = rmax2(cerr, fabs(c.xR[2] - 0));
   cerr = rmax2(cerr, fabs(c.xR[3] + 160));
   cerr = rmax2(cerr, fabs(c.xR[4] - 0));
   cerr = rmax2(cerr, fabs(c.xR[5] - 32));
   hermitecoefficients(6, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] + 120));
   cerr = rmax2(cerr, fabs(c.xR[1] - 0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 720));
   cerr = rmax2(cerr, fabs(c.xR[3] - 0));
   cerr = rmax2(cerr, fabs(c.xR[4] + 480));
   cerr = rmax2(cerr, fabs(c.xR[5] - 0));
   cerr = rmax2(cerr, fabs(c.xR[6] - 64));
// The final report.
   Ok = err <= threshold && sumerr <= threshold && cerr <= threshold;
   if (!Ok || !silent) {
      printf("Calculation of the Hermite Polynomials Tests\n");
      printf("Max Error:                                %5.2e\n", err);
      printf("Summation Error:                          %5.2e\n", sumerr);
      printf("Coefficients Error:                       %5.2e\n", cerr);
      printf("Threshold:                                %5.2e\n", threshold);
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === legendre testing unit ===
bool testlegendre() {
   ae_frame _frame_block;
   double err;
   double sumerr;
   double cerr;
   double threshold;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t i;
   ae_int_t pass;
   double x;
   double v;
   double t;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(c, 0, DT_REAL);
   err = 0.0;
   sumerr = 0.0;
   cerr = 0.0;
   threshold = 1.0E-9;
   Ok = true;
// Testing Legendre polynomials values
   for (n = 0; n <= 10; n++) {
      legendrecoefficients(n, &c);
      for (pass = 1; pass <= 10; pass++) {
         x = randommid();
         v = legendrecalculate(n, x);
         t = 1.0;
         for (i = 0; i <= n; i++) {
            v -= c.xR[i] * t;
            t *= x;
         }
         err = rmax2(err, fabs(v));
      }
   }
// Testing Clenshaw summation
   maxn = 20;
   ae_vector_set_length(&c, maxn + 1);
   for (pass = 1; pass <= 10; pass++) {
      x = randommid();
      v = 0.0;
      for (n = 0; n <= maxn; n++) {
         c.xR[n] = randommid();
         v += legendrecalculate(n, x) * c.xR[n];
         sumerr = rmax2(sumerr, fabs(v - legendresum(&c, n, x)));
      }
   }
// Testing coefficients
   legendrecoefficients(0, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 1));
   legendrecoefficients(1, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 1));
   legendrecoefficients(2, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] + 1.0 / 2.0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 3.0 / 2.0));
   legendrecoefficients(3, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 3.0 / 2.0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 0));
   cerr = rmax2(cerr, fabs(c.xR[3] - 5.0 / 2.0));
   legendrecoefficients(4, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 3.0 / 8.0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 0));
   cerr = rmax2(cerr, fabs(c.xR[2] + 30.0 / 8.0));
   cerr = rmax2(cerr, fabs(c.xR[3] - 0));
   cerr = rmax2(cerr, fabs(c.xR[4] - 35.0 / 8.0));
   legendrecoefficients(9, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 315.0 / 128.0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 0));
   cerr = rmax2(cerr, fabs(c.xR[3] + 4620.0 / 128.0));
   cerr = rmax2(cerr, fabs(c.xR[4] - 0));
   cerr = rmax2(cerr, fabs(c.xR[5] - 18018.0 / 128.0));
   cerr = rmax2(cerr, fabs(c.xR[6] - 0));
   cerr = rmax2(cerr, fabs(c.xR[7] + 25740.0 / 128.0));
   cerr = rmax2(cerr, fabs(c.xR[8] - 0));
   cerr = rmax2(cerr, fabs(c.xR[9] - 12155.0 / 128.0));
// The final report.
   Ok = err <= threshold && sumerr <= threshold && cerr <= threshold;
   if (!Ok || !silent) {
      printf("Calculation of the Legendre Polynomials Tests\n");
      printf("Max Error:                                %5.2e\n", err);
      printf("Summation Error:                          %5.2e\n", sumerr);
      printf("Coefficients Error:                       %5.2e\n", cerr);
      printf("Threshold:                                %5.2e\n", threshold);
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === laguerre testing unit ===
bool testlaguerre() {
   ae_frame _frame_block;
   double err;
   double sumerr;
   double cerr;
   double threshold;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t pass;
   double x;
   double v;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(c, 0, DT_REAL);
   err = 0.0;
   sumerr = 0.0;
   cerr = 0.0;
   threshold = 1.0E-9;
   Ok = true;
// Testing Laguerre polynomials
   n = 0;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) - 1.0000000000));
   n = 1;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) - 0.5000000000));
   n = 2;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) - 0.1250000000));
   n = 3;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.1458333333));
   n = 4;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.3307291667));
   n = 5;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.4455729167));
   n = 6;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.5041449653));
   n = 7;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.5183392237));
   n = 8;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.4983629984));
   n = 9;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.4529195204));
   n = 10;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.3893744141));
   n = 11;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.3139072988));
   n = 12;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.2316496389));
// Testing Clenshaw summation
   maxn = 20;
   ae_vector_set_length(&c, maxn + 1);
   for (pass = 1; pass <= 10; pass++) {
      x = randommid();
      v = 0.0;
      for (n = 0; n <= maxn; n++) {
         c.xR[n] = randommid();
         v += laguerrecalculate(n, x) * c.xR[n];
         sumerr = rmax2(sumerr, fabs(v - laguerresum(&c, n, x)));
      }
   }
// Testing coefficients
   laguerrecoefficients(0, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 1));
   laguerrecoefficients(1, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 1));
   cerr = rmax2(cerr, fabs(c.xR[1] + 1));
   laguerrecoefficients(2, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 2.0 / 2.0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 4.0 / 2.0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 1.0 / 2.0));
   laguerrecoefficients(3, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 6.0 / 6.0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 18.0 / 6.0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 9.0 / 6.0));
   cerr = rmax2(cerr, fabs(c.xR[3] + 1.0 / 6.0));
   laguerrecoefficients(4, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 24.0 / 24.0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 96.0 / 24.0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 72.0 / 24.0));
   cerr = rmax2(cerr, fabs(c.xR[3] + 16.0 / 24.0));
   cerr = rmax2(cerr, fabs(c.xR[4] - 1.0 / 24.0));
   laguerrecoefficients(5, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 120.0 / 120.0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 600.0 / 120.0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 600.0 / 120.0));
   cerr = rmax2(cerr, fabs(c.xR[3] + 200.0 / 120.0));
   cerr = rmax2(cerr, fabs(c.xR[4] - 25.0 / 120.0));
   cerr = rmax2(cerr, fabs(c.xR[5] + 1.0 / 120.0));
   laguerrecoefficients(6, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 720.0 / 720.0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 4320.0 / 720.0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 5400.0 / 720.0));
   cerr = rmax2(cerr, fabs(c.xR[3] + 2400.0 / 720.0));
   cerr = rmax2(cerr, fabs(c.xR[4] - 450.0 / 720.0));
   cerr = rmax2(cerr, fabs(c.xR[5] + 36.0 / 720.0));
   cerr = rmax2(cerr, fabs(c.xR[6] - 1.0 / 720.0));
// The final report.
   Ok = err <= threshold && sumerr <= threshold && cerr <= threshold;
   if (!Ok || !silent) {
      printf("Calculation of the LaGuerre Polynomials Tests\n");
      printf("Max Error:                                %5.2e\n", err);
      printf("Summation Error:                          %5.2e\n", sumerr);
      printf("Coefficients Error:                       %5.2e\n", cerr);
      printf("Threshold:                                %5.2e\n", threshold);
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === pca testing unit ===
// Moments estimates and their errors
static void testpcaunit_calculatemv(RVector *x, ae_int_t n, double *mean, double *means, double *stddev, double *stddevs) {
   ae_int_t i;
   double v1;
   double v2;
   double variance;
   *mean = 0;
   *means = 0;
   *stddev = 0;
   *stddevs = 0;
   *mean = 0.0;
   *means = 1.0;
   *stddev = 0.0;
   *stddevs = 1.0;
   variance = 0.0;
   if (n <= 1) {
      return;
   }
// Mean
   for (i = 0; i < n; i++) {
      *mean += x->xR[i];
   }
   *mean /= n;
// Variance (using corrected two-pass algorithm)
   if (n != 1) {
      v1 = 0.0;
      for (i = 0; i < n; i++) {
         v1 += sqr(x->xR[i] - (*mean));
      }
      v2 = 0.0;
      for (i = 0; i < n; i++) {
         v2 += x->xR[i] - (*mean);
      }
      v2 = sqr(v2) / n;
      variance = (v1 - v2) / n;
      if (variance < 0.0) {
         variance = 0.0;
      }
      *stddev = sqrt(variance);
   }
// Errors
   *means = *stddev / sqrt(n);
   *stddevs = *stddev * sqrt(2.0) / sqrt(n - 1);
}

bool testpca() {
   ae_frame _frame_block;
   ae_int_t maxn;
   ae_int_t maxm;
   double threshold;
   ae_int_t m;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t info;
   double t;
   double h;
   double tmean;
   double tmeans;
   double tstddev;
   double tstddevs;
   double tmean2;
   double tmeans2;
   double tstddev2;
   double tstddevs2;
   ae_int_t requested;
   double tolreduced;
   double varcomplete;
   double varreduced;
   ae_int_t pass;
   bool pcaconvOk;
   bool pcaortOk;
   bool pcavarOk;
   bool pcaoptOk;
   bool pcadensesubspaceOk;
   bool pcasparsesubspaceOk;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(means, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(s2, 0, DT_REAL);
   NewVector(t2, 0, DT_REAL);
   NewVector(t3, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewMatrix(v2, 0, 0, DT_REAL);
   NewMatrix(x, 0, 0, DT_REAL);
   NewObj(sparsematrix, xsparse);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Primary settings
   maxm = 10;
   maxn = 100;
   threshold = 1.0E5 * machineepsilon;
   Ok = true;
   pcaconvOk = true;
   pcaortOk = true;
   pcavarOk = true;
   pcaoptOk = true;
   pcadensesubspaceOk = true;
   pcasparsesubspaceOk = true;
// Test 1: N random points in M-dimensional space, full PCA.
   for (m = 1; m <= maxm; m++) {
      for (n = 1; n <= maxn; n++) {
      // Generate task
         ae_matrix_set_length(&x, n, m);
         ae_vector_set_length(&means, m);
         for (j = 0; j < m; j++) {
            means.xR[j] = 0.75 * randommid();
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
               x.xyR[i][j] = means.xR[j] + randommid();
            }
         }
      // Solve
         pcabuildbasis(&x, n, m, &info, &s, &v);
         if (info != 1) {
            pcaconvOk = false;
            continue;
         }
      // Orthogonality test
         for (i = 0; i < m; i++) {
            for (j = 0; j < m; j++) {
               t = ae_v_dotproduct(&v.xyR[0][i], v.stride, &v.xyR[0][j], v.stride, m);
               if (i == j) {
                  t--;
               }
               pcaortOk = pcaortOk && SmallAtR(t, threshold);
            }
         }
      // Variance test
         ae_vector_set_length(&t2, n);
         for (k = 0; k < m; k++) {
            for (i = 0; i < n; i++) {
               t = ae_v_dotproduct(x.xyR[i], 1, &v.xyR[0][k], v.stride, m);
               t2.xR[i] = t;
            }
            testpcaunit_calculatemv(&t2, n, &tmean, &tmeans, &tstddev, &tstddevs);
            if (n != 1) {
               t = sqr(tstddev) * n / (n - 1);
            } else {
               t = 0.0;
            }
            pcavarOk = pcavarOk && NearAtR(t, s.xR[k], threshold);
         }
         for (k = 0; k < m - 1; k++) {
            pcavarOk = pcavarOk && s.xR[k] >= s.xR[k + 1];
         }
      // Optimality: different perturbations in V[..,0] can't
      // increase variance of projection - can only decrease.
         ae_vector_set_length(&t2, n);
         ae_vector_set_length(&t3, n);
         for (i = 0; i < n; i++) {
            t = ae_v_dotproduct(x.xyR[i], 1, v.xyR[0], v.stride, m);
            t2.xR[i] = t;
         }
         testpcaunit_calculatemv(&t2, n, &tmean, &tmeans, &tstddev, &tstddevs);
         for (k = 0; k < 2 * m; k++) {
            h = 0.001;
            if (k % 2 != 0) {
               h = -h;
            }
            ae_v_move(t3.xR, 1, t2.xR, 1, n);
            ae_v_addd(t3.xR, 1, &x.xyR[0][k / 2], x.stride, n, h);
            t = 0.0;
            for (j = 0; j < m; j++) {
               if (j != k / 2) {
                  t += sqr(v.xyR[j][0]);
               } else {
                  t += sqr(v.xyR[j][0] + h);
               }
            }
            t = 1 / sqrt(t);
            ae_v_muld(t3.xR, 1, n, t);
            testpcaunit_calculatemv(&t3, n, &tmean2, &tmeans2, &tstddev2, &tstddevs2);
            pcaoptOk = pcaoptOk && tstddev2 <= tstddev + threshold;
         }
      }
   }
// Special test for N == 0
   for (m = 1; m <= maxm; m++) {
   // Solve
      pcabuildbasis(&x, 0, m, &info, &s, &v);
      if (info != 1) {
         pcaconvOk = false;
         continue;
      }
   // Orthogonality test
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            t = ae_v_dotproduct(&v.xyR[0][i], v.stride, &v.xyR[0][j], v.stride, m);
            if (i == j) {
               t--;
            }
            pcaortOk = pcaortOk && SmallAtR(t, threshold);
         }
      }
   }
// Test dense reduced subspace PCA on randomly generated matrix. Because
// matrix is random, it may have bad spectral properties, so large
// number of iterations is performed.
//
// Following properties are tested:
// * principal vectors are orthogonal
// * variance values are computed correctly
// * variance values are decreasing
// * variance by inexact reduced PCA deviates from variance explained
//   by top REQUESTED vectors of complete PCA by at most TolReduced.
   tolreduced = 1.0E-3;
   for (m = 1; m <= maxm; m++) {
      for (n = 1; n <= maxn; n++) {
      // Generate task
         requested = 1 + hqrnduniformi(&rs, m);
         ae_vector_set_length(&means, m);
         for (j = 0; j < m; j++) {
            means.xR[j] = 100 * hqrndnormal(&rs);
         }
         ae_matrix_set_length(&x, n, m);
         for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
               x.xyR[i][j] = hqrndnormal(&rs) + means.xR[j];
            }
         }
      // Solve
         pcatruncatedsubspace(&x, n, m, requested, 1.0E-9, 0, &s, &v);
      // Orthogonality test
         for (i = 0; i < requested; i++) {
            for (j = 0; j < requested; j++) {
               t = ae_v_dotproduct(&v.xyR[0][i], v.stride, &v.xyR[0][j], v.stride, m);
               if (i == j) {
                  t--;
               }
               pcadensesubspaceOk = pcadensesubspaceOk && SmallAtR(t, threshold);
            }
         }
      // Variance test
         ae_vector_set_length(&t2, n);
         for (k = 0; k < requested; k++) {
            for (i = 0; i < n; i++) {
               t = ae_v_dotproduct(x.xyR[i], 1, &v.xyR[0][k], v.stride, m);
               t2.xR[i] = t;
            }
            testpcaunit_calculatemv(&t2, n, &tmean, &tmeans, &tstddev, &tstddevs);
            if (n != 1) {
               t = sqr(tstddev) * n / (n - 1);
            } else {
               t = 0.0;
            }
            pcadensesubspaceOk = pcadensesubspaceOk && NearAtR(t, s.xR[k], threshold);
         }
         for (k = 0; k < requested - 1; k++) {
            pcadensesubspaceOk = pcadensesubspaceOk && fabs(s.xR[k]) >= fabs(s.xR[k + 1]);
         }
         for (k = 0; k < requested; k++) {
            pcadensesubspaceOk = pcadensesubspaceOk && (s.xR[k] > 0.0 || SmallAtR(s.xR[k], 1000.0 * machineepsilon * fabs(s.xR[0])));
         }
      // Compare variance explained by top REQUESTED vectors from
      // full PCA and variance explained by reduced PCA.
         pcabuildbasis(&x, n, m, &info, &s2, &v2);
         ae_assert(info > 0, "PCA error: solver nonconvergence");
         varcomplete = 0.0;
         varreduced = 0.0;
         for (k = 0; k < requested; k++) {
            varreduced += s.xR[k];
            varcomplete += s2.xR[k];
         }
         pcadensesubspaceOk = pcadensesubspaceOk && varreduced - varcomplete >= -tolreduced * varcomplete;
         pcadensesubspaceOk = pcadensesubspaceOk && varreduced - varcomplete <= 1.0E5 * machineepsilon * varcomplete;
      }
   }
// Test dense subspace reduced PCA on specially designed problem with good
// spectral properties. Only limited number of iterations is performed,
// and we expect fast convergence.
   for (pass = 0; pass <= 3; pass++) {
   // Generate task
      m = -1;
      requested = -1;
      if (pass == 0) {
         m = 50 + hqrnduniformi(&rs, 50);
         requested = 1 + hqrnduniformi(&rs, 10);
      }
      if (pass == 1) {
         m = 100 + hqrnduniformi(&rs, 50);
         requested = 1 + hqrnduniformi(&rs, 10);
      }
      if (pass == 2) {
         m = 100 + hqrnduniformi(&rs, 50);
         requested = 25 + hqrnduniformi(&rs, 10);
      }
      if (pass == 3) {
         m = 200 + hqrnduniformi(&rs, 200);
         requested = 1 + hqrnduniformi(&rs, 10);
      }
      ae_assert(m > 0 && requested > 0, "PCA test: integrity failure");
      n = 2 * m;
      tolreduced = 1.0E-3;
      ae_matrix_set_length(&x, n, m);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            x.xyR[i][j] = 0.0;
         }
      }
      x.xyR[0][0] = 1.0;
      for (i = 1; i < m; i++) {
         x.xyR[i][i] = x.xyR[i - 1][i - 1] * (1 / 1.05);
      }
      rmatrixrndorthogonalfromtheleft(&x, n, m);
      rmatrixrndorthogonalfromtheright(&x, n, m);
   // Solve
      if (hqrnduniformr(&rs) > 0.5) {
         pcatruncatedsubspace(&x, n, m, requested, 0.0, 20, &s, &v);
      } else {
         pcatruncatedsubspace(&x, n, m, requested, 0.0, 0, &s, &v);
      }
   // Orthogonality test
      for (i = 0; i < requested; i++) {
         for (j = 0; j < requested; j++) {
            t = ae_v_dotproduct(&v.xyR[0][i], v.stride, &v.xyR[0][j], v.stride, m);
            if (i == j) {
               t--;
            }
            pcadensesubspaceOk = pcadensesubspaceOk && SmallAtR(t, threshold);
         }
      }
   // Variance test
      ae_vector_set_length(&t2, n);
      for (k = 0; k < requested; k++) {
         for (i = 0; i < n; i++) {
            t = ae_v_dotproduct(x.xyR[i], 1, &v.xyR[0][k], v.stride, m);
            t2.xR[i] = t;
         }
         testpcaunit_calculatemv(&t2, n, &tmean, &tmeans, &tstddev, &tstddevs);
         if (n != 1) {
            t = sqr(tstddev) * n / (n - 1);
         } else {
            t = 0.0;
         }
         pcadensesubspaceOk = pcadensesubspaceOk && NearAtR(t, s.xR[k], threshold);
      }
      for (k = 0; k < requested - 1; k++) {
         pcadensesubspaceOk = pcadensesubspaceOk && s.xR[k] >= s.xR[k + 1];
      }
   // Compare variance explained by top REQUESTED vectors from
   // full PCA and variance explained by reduced PCA.
      pcabuildbasis(&x, n, m, &info, &s2, &v2);
      ae_assert(info > 0, "PCA error: solver nonconvergence");
      varcomplete = 0.0;
      varreduced = 0.0;
      for (k = 0; k < requested; k++) {
         varreduced += s.xR[k];
         varcomplete += s2.xR[k];
      }
      pcadensesubspaceOk = pcadensesubspaceOk && varreduced - varcomplete >= -tolreduced * varcomplete;
      pcadensesubspaceOk = pcadensesubspaceOk && varreduced - varcomplete <= 1.0E5 * machineepsilon * varcomplete;
   }
// Test sparse reduced subspace PCA on randomly generated matrix with
// two non-zero elements at each row. Because matrix is random, it may
// have bad spectral properties, so large number of iterations is performed.
//
// Following properties are tested:
// * principal vectors are orthogonal
// * variance values are computed correctly
// * variance values are decreasing
// * variance by inexact reduced PCA deviates from variance explained
//   by top REQUESTED vectors of complete PCA by at most TolReduced.
   tolreduced = 1.0E-3;
   for (m = 1; m <= maxm; m++) {
      for (n = 1; n <= maxn; n++) {
      // Generate task
         requested = 1 + hqrnduniformi(&rs, m);
         ae_vector_set_length(&means, m);
         for (j = 0; j < m; j++) {
            means.xR[j] = 100 * hqrndnormal(&rs);
         }
         sparsecreate(n, m, 0, &xsparse);
         for (i = 0; i < n; i++) {
            j = hqrnduniformi(&rs, m);
            sparseset(&xsparse, i, j, hqrndnormal(&rs) + means.xR[j]);
            j = hqrnduniformi(&rs, m);
            sparseset(&xsparse, i, j, hqrndnormal(&rs) + means.xR[j]);
         }
         if (hqrndnormal(&rs) > 0.0) {
            sparseconverttocrs(&xsparse);
         }
         ae_matrix_set_length(&x, n, m);
         for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
               x.xyR[i][j] = sparseget(&xsparse, i, j);
            }
         }
      // Solve
         pcatruncatedsubspacesparse(&xsparse, n, m, requested, 1.0E-9, 0, &s, &v);
      // Orthogonality test
         for (i = 0; i < requested; i++) {
            for (j = 0; j < requested; j++) {
               t = ae_v_dotproduct(&v.xyR[0][i], v.stride, &v.xyR[0][j], v.stride, m);
               if (i == j) {
                  t--;
               }
               pcasparsesubspaceOk = pcasparsesubspaceOk && SmallAtR(t, threshold);
            }
         }
      // Variance test
         ae_vector_set_length(&t2, n);
         for (k = 0; k < requested; k++) {
            for (i = 0; i < n; i++) {
               t = ae_v_dotproduct(x.xyR[i], 1, &v.xyR[0][k], v.stride, m);
               t2.xR[i] = t;
            }
            testpcaunit_calculatemv(&t2, n, &tmean, &tmeans, &tstddev, &tstddevs);
            if (n != 1) {
               t = sqr(tstddev) * n / (n - 1);
            } else {
               t = 0.0;
            }
            pcasparsesubspaceOk = pcasparsesubspaceOk && NearAtR(t, s.xR[k], threshold * rmaxabs3(t, s.xR[k], 1.0));
         }
         for (k = 0; k < requested - 1; k++) {
            pcasparsesubspaceOk = pcasparsesubspaceOk && fabs(s.xR[k]) >= fabs(s.xR[k + 1]);
         }
         for (k = 0; k < requested; k++) {
            pcasparsesubspaceOk = pcasparsesubspaceOk && (s.xR[k] > 0.0 || SmallAtR(s.xR[k], 1000.0 * machineepsilon * rmax2(fabs(s.xR[0]), 1.0)));
         }
      // Compare variance explained by top REQUESTED vectors from
      // full PCA and variance explained by reduced PCA.
         pcabuildbasis(&x, n, m, &info, &s2, &v2);
         ae_assert(info > 0, "PCA error: solver nonconvergence");
         varcomplete = 0.0;
         varreduced = 0.0;
         for (k = 0; k < requested; k++) {
            varreduced += s.xR[k];
            varcomplete += s2.xR[k];
         }
         pcasparsesubspaceOk = pcasparsesubspaceOk && varreduced - varcomplete >= -tolreduced * rmax2(varcomplete, 1.0);
         pcasparsesubspaceOk = pcasparsesubspaceOk && varreduced - varcomplete <= 1.0E5 * machineepsilon * rmax2(varcomplete, 1.0);
      }
   }
// The final report.
   Ok = pcaconvOk && pcaortOk && pcavarOk && pcaoptOk && pcadensesubspaceOk && pcasparsesubspaceOk;
   if (!Ok || !silent) {
      printf("PCA Tests\n");
      printf("Complete PCA:\n");
      printf("* Convergence:                            %s\n", pcaconvOk? "Ok": "Failed");
      printf("* Ortogonality:                           %s\n", pcaortOk? "Ok": "Failed");
      printf("* Variance Report:                        %s\n", pcavarOk? "Ok": "Failed");
      printf("* Optimality:                             %s\n", pcaoptOk? "Ok": "Failed");
      printf("Subspace PCA:\n");
      printf("* Dense Subspace PCA:                     %s\n", pcadensesubspaceOk? "Ok": "Failed");
      printf("* Sparse Subspace PCA:                    %s\n", pcasparsesubspaceOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === bdss testing unit ===
// Unsets 1D array.
static void testbdssunit_unset1di(ZVector *a) {
   ae_vector_set_length(a, 0 + 1);
   a->xZ[0] = randominteger(3) - 1;
}

// Testing BDSS operations
bool testbdss() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t maxn;
   ae_int_t maxnq;
   ae_int_t ni;
   ae_int_t tiecount;
   ae_int_t c1;
   ae_int_t c0;
   ae_int_t nc;
   double pal;
   double pbl;
   double par;
   double pbr;
   double cve;
   double cvr;
   ae_int_t info;
   double threshold;
   double rms;
   double cvrms;
   bool Ok;
   bool tiesOk;
   bool split2Ok;
   bool optimalsplitkOk;
   bool splitkOk;
   ae_frame_make(&_frame_block);
   NewVector(a, 0, DT_REAL);
   NewVector(a0, 0, DT_REAL);
   NewVector(at, 0, DT_REAL);
   NewMatrix(p, 0, 0, DT_REAL);
   NewVector(thresholds, 0, DT_REAL);
   NewVector(c, 0, DT_INT);
   NewVector(p1, 0, DT_INT);
   NewVector(p2, 0, DT_INT);
   NewVector(ties, 0, DT_INT);
   NewVector(pt1, 0, DT_INT);
   NewVector(pt2, 0, DT_INT);
   NewVector(tmp, 0, DT_REAL);
   NewVector(sortrbuf, 0, DT_REAL);
   NewVector(sortrbuf2, 0, DT_REAL);
   NewVector(sortibuf, 0, DT_INT);
   NewVector(tiebuf, 0, DT_INT);
   NewVector(cntbuf, 0, DT_INT);
   Ok = true;
   tiesOk = true;
   split2Ok = true;
   splitkOk = true;
   optimalsplitkOk = true;
   maxn = 100;
   maxnq = 49;
   passcount = 10;
// Test ties
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
      // untied data, test DSTie
         testbdssunit_unset1di(&p1);
         testbdssunit_unset1di(&p2);
         testbdssunit_unset1di(&pt1);
         testbdssunit_unset1di(&pt2);
         ae_vector_set_length(&a, n);
         ae_vector_set_length(&a0, n);
         ae_vector_set_length(&at, n);
         ae_vector_set_length(&tmp, n);
         a.xR[0] = randommid();
         tmp.xR[0] = randomreal();
         for (i = 1; i < n; i++) {
         // A is randomly permuted
            a.xR[i] = a.xR[i - 1] + 0.1 * randomreal() + 0.1;
            tmp.xR[i] = randomreal();
         }
         tagsortfastr(&tmp, &a, &sortrbuf, &sortrbuf2, n);
         for (i = 0; i < n; i++) {
            a0.xR[i] = a.xR[i];
            at.xR[i] = a.xR[i];
         }
         dstie(&a0, n, &ties, &tiecount, &p1, &p2);
         tagsort(&at, n, &pt1, &pt2);
         for (i = 0; i < n; i++) {
            tiesOk = tiesOk && p1.xZ[i] == pt1.xZ[i];
            tiesOk = tiesOk && p2.xZ[i] == pt2.xZ[i];
         }
         tiesOk = tiesOk && tiecount == n;
         if (tiecount == n) {
            for (i = 0; i <= n; i++) {
               tiesOk = tiesOk && ties.xZ[i] == i;
            }
         }
      // tied data, test DSTie
         testbdssunit_unset1di(&p1);
         testbdssunit_unset1di(&p2);
         testbdssunit_unset1di(&pt1);
         testbdssunit_unset1di(&pt2);
         ae_vector_set_length(&a, n);
         ae_vector_set_length(&a0, n);
         ae_vector_set_length(&at, n);
         c1 = 0;
         c0 = 0;
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)randominteger(2);
            if (a.xR[i] == 0.0) {
               c0++;
            } else {
               c1++;
            }
            a0.xR[i] = a.xR[i];
            at.xR[i] = a.xR[i];
         }
         dstie(&a0, n, &ties, &tiecount, &p1, &p2);
         tagsort(&at, n, &pt1, &pt2);
         for (i = 0; i < n; i++) {
            tiesOk = tiesOk && p1.xZ[i] == pt1.xZ[i];
            tiesOk = tiesOk && p2.xZ[i] == pt2.xZ[i];
         }
         if (c0 == 0 || c1 == 0) {
            tiesOk = tiesOk && tiecount == 1;
            if (tiecount == 1) {
               tiesOk = tiesOk && ties.xZ[0] == 0;
               tiesOk = tiesOk && ties.xZ[1] == n;
            }
         } else {
            tiesOk = tiesOk && tiecount == 2;
            if (tiecount == 2) {
               tiesOk = tiesOk && ties.xZ[0] == 0;
               tiesOk = tiesOk && ties.xZ[1] == c0;
               tiesOk = tiesOk && ties.xZ[2] == n;
            }
         }
      }
   }
// split-2
// General tests for different N's
   for (n = 1; n <= maxn; n++) {
      ae_vector_set_length(&a, n);
      ae_vector_set_length(&c, n);
   // one-tie test
      if (n % 2 == 0) {
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)n;
            c.xZ[i] = i % 2;
         }
         dsoptimalsplit2(&a, &c, n, &info, &threshold, &pal, &pbl, &par, &pbr, &cve);
         if (info != -3) {
            split2Ok = false;
            continue;
         }
      }
   // two-tie test
   // test #1
      if (n > 1) {
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)(i / ((n + 1) / 2));
            c.xZ[i] = i / ((n + 1) / 2);
         }
         dsoptimalsplit2(&a, &c, n, &info, &threshold, &pal, &pbl, &par, &pbr, &cve);
         if (info != 1) {
            split2Ok = false;
            continue;
         }
         split2Ok = split2Ok && NearAtR(threshold, 0.5, 100.0 * machineepsilon);
         split2Ok = split2Ok && NearAtR(pal, 1.0, 100.0 * machineepsilon);
         split2Ok = split2Ok && NearAtR(pbl, 0.0, 100.0 * machineepsilon);
         split2Ok = split2Ok && NearAtR(par, 0.0, 100.0 * machineepsilon);
         split2Ok = split2Ok && NearAtR(pbr, 1.0, 100.0 * machineepsilon);
      }
   }
// Special "CREDIT"-test (transparency coefficient)
   n = 110;
   ae_vector_set_length(&a, n);
   ae_vector_set_length(&c, n);
   a.xR[0] = 0.000;
   c.xZ[0] = 0;
   a.xR[1] = 0.000;
   c.xZ[1] = 0;
   a.xR[2] = 0.000;
   c.xZ[2] = 0;
   a.xR[3] = 0.000;
   c.xZ[3] = 0;
   a.xR[4] = 0.000;
   c.xZ[4] = 0;
   a.xR[5] = 0.000;
   c.xZ[5] = 0;
   a.xR[6] = 0.000;
   c.xZ[6] = 0;
   a.xR[7] = 0.000;
   c.xZ[7] = 1;
   a.xR[8] = 0.000;
   c.xZ[8] = 0;
   a.xR[9] = 0.000;
   c.xZ[9] = 1;
   a.xR[10] = 0.000;
   c.xZ[10] = 0;
   a.xR[11] = 0.000;
   c.xZ[11] = 0;
   a.xR[12] = 0.000;
   c.xZ[12] = 0;
   a.xR[13] = 0.000;
   c.xZ[13] = 0;
   a.xR[14] = 0.000;
   c.xZ[14] = 0;
   a.xR[15] = 0.000;
   c.xZ[15] = 0;
   a.xR[16] = 0.000;
   c.xZ[16] = 0;
   a.xR[17] = 0.000;
   c.xZ[17] = 0;
   a.xR[18] = 0.000;
   c.xZ[18] = 0;
   a.xR[19] = 0.000;
   c.xZ[19] = 0;
   a.xR[20] = 0.000;
   c.xZ[20] = 0;
   a.xR[21] = 0.000;
   c.xZ[21] = 0;
   a.xR[22] = 0.000;
   c.xZ[22] = 1;
   a.xR[23] = 0.000;
   c.xZ[23] = 0;
   a.xR[24] = 0.000;
   c.xZ[24] = 0;
   a.xR[25] = 0.000;
   c.xZ[25] = 0;
   a.xR[26] = 0.000;
   c.xZ[26] = 0;
   a.xR[27] = 0.000;
   c.xZ[27] = 1;
   a.xR[28] = 0.000;
   c.xZ[28] = 0;
   a.xR[29] = 0.000;
   c.xZ[29] = 1;
   a.xR[30] = 0.000;
   c.xZ[30] = 0;
   a.xR[31] = 0.000;
   c.xZ[31] = 1;
   a.xR[32] = 0.000;
   c.xZ[32] = 0;
   a.xR[33] = 0.000;
   c.xZ[33] = 1;
   a.xR[34] = 0.000;
   c.xZ[34] = 0;
   a.xR[35] = 0.030;
   c.xZ[35] = 0;
   a.xR[36] = 0.030;
   c.xZ[36] = 0;
   a.xR[37] = 0.050;
   c.xZ[37] = 0;
   a.xR[38] = 0.070;
   c.xZ[38] = 1;
   a.xR[39] = 0.110;
   c.xZ[39] = 0;
   a.xR[40] = 0.110;
   c.xZ[40] = 1;
   a.xR[41] = 0.120;
   c.xZ[41] = 0;
   a.xR[42] = 0.130;
   c.xZ[42] = 0;
   a.xR[43] = 0.140;
   c.xZ[43] = 0;
   a.xR[44] = 0.140;
   c.xZ[44] = 0;
   a.xR[45] = 0.140;
   c.xZ[45] = 0;
   a.xR[46] = 0.150;
   c.xZ[46] = 0;
   a.xR[47] = 0.150;
   c.xZ[47] = 0;
   a.xR[48] = 0.170;
   c.xZ[48] = 0;
   a.xR[49] = 0.190;
   c.xZ[49] = 1;
   a.xR[50] = 0.200;
   c.xZ[50] = 0;
   a.xR[51] = 0.200;
   c.xZ[51] = 0;
   a.xR[52] = 0.250;
   c.xZ[52] = 0;
   a.xR[53] = 0.250;
   c.xZ[53] = 0;
   a.xR[54] = 0.260;
   c.xZ[54] = 0;
   a.xR[55] = 0.270;
   c.xZ[55] = 0;
   a.xR[56] = 0.280;
   c.xZ[56] = 0;
   a.xR[57] = 0.310;
   c.xZ[57] = 0;
   a.xR[58] = 0.310;
   c.xZ[58] = 0;
   a.xR[59] = 0.330;
   c.xZ[59] = 0;
   a.xR[60] = 0.330;
   c.xZ[60] = 0;
   a.xR[61] = 0.340;
   c.xZ[61] = 0;
   a.xR[62] = 0.340;
   c.xZ[62] = 0;
   a.xR[63] = 0.370;
   c.xZ[63] = 0;
   a.xR[64] = 0.380;
   c.xZ[64] = 1;
   a.xR[65] = 0.380;
   c.xZ[65] = 0;
   a.xR[66] = 0.410;
   c.xZ[66] = 0;
   a.xR[67] = 0.460;
   c.xZ[67] = 0;
   a.xR[68] = 0.520;
   c.xZ[68] = 0;
   a.xR[69] = 0.530;
   c.xZ[69] = 0;
   a.xR[70] = 0.540;
   c.xZ[70] = 0;
   a.xR[71] = 0.560;
   c.xZ[71] = 0;
   a.xR[72] = 0.560;
   c.xZ[72] = 0;
   a.xR[73] = 0.570;
   c.xZ[73] = 0;
   a.xR[74] = 0.600;
   c.xZ[74] = 0;
   a.xR[75] = 0.600;
   c.xZ[75] = 0;
   a.xR[76] = 0.620;
   c.xZ[76] = 0;
   a.xR[77] = 0.650;
   c.xZ[77] = 0;
   a.xR[78] = 0.660;
   c.xZ[78] = 0;
   a.xR[79] = 0.680;
   c.xZ[79] = 0;
   a.xR[80] = 0.700;
   c.xZ[80] = 0;
   a.xR[81] = 0.750;
   c.xZ[81] = 0;
   a.xR[82] = 0.770;
   c.xZ[82] = 0;
   a.xR[83] = 0.770;
   c.xZ[83] = 0;
   a.xR[84] = 0.770;
   c.xZ[84] = 0;
   a.xR[85] = 0.790;
   c.xZ[85] = 0;
   a.xR[86] = 0.810;
   c.xZ[86] = 0;
   a.xR[87] = 0.840;
   c.xZ[87] = 0;
   a.xR[88] = 0.860;
   c.xZ[88] = 0;
   a.xR[89] = 0.870;
   c.xZ[89] = 0;
   a.xR[90] = 0.890;
   c.xZ[90] = 0;
   a.xR[91] = 0.900;
   c.xZ[91] = 1;
   a.xR[92] = 0.900;
   c.xZ[92] = 0;
   a.xR[93] = 0.910;
   c.xZ[93] = 0;
   a.xR[94] = 0.940;
   c.xZ[94] = 0;
   a.xR[95] = 0.950;
   c.xZ[95] = 0;
   a.xR[96] = 0.952;
   c.xZ[96] = 0;
   a.xR[97] = 0.970;
   c.xZ[97] = 0;
   a.xR[98] = 0.970;
   c.xZ[98] = 0;
   a.xR[99] = 0.980;
   c.xZ[99] = 0;
   a.xR[100] = 1.000;
   c.xZ[100] = 0;
   a.xR[101] = 1.000;
   c.xZ[101] = 0;
   a.xR[102] = 1.000;
   c.xZ[102] = 0;
   a.xR[103] = 1.000;
   c.xZ[103] = 0;
   a.xR[104] = 1.000;
   c.xZ[104] = 0;
   a.xR[105] = 1.020;
   c.xZ[105] = 0;
   a.xR[106] = 1.090;
   c.xZ[106] = 0;
   a.xR[107] = 1.130;
   c.xZ[107] = 0;
   a.xR[108] = 1.840;
   c.xZ[108] = 0;
   a.xR[109] = 2.470;
   c.xZ[109] = 0;
   dsoptimalsplit2(&a, &c, n, &info, &threshold, &pal, &pbl, &par, &pbr, &cve);
   if (info != 1) {
      split2Ok = false;
   } else {
      split2Ok = split2Ok && NearAtR(threshold, 0.195, 100.0 * machineepsilon);
      split2Ok = split2Ok && NearAtR(pal, 0.80, 0.02);
      split2Ok = split2Ok && NearAtR(pbl, 0.20, 0.02);
      split2Ok = split2Ok && NearAtR(par, 0.97, 0.02);
      split2Ok = split2Ok && NearAtR(pbr, 0.03, 0.02);
   }
// split-2 fast
// General tests for different N's
   for (n = 1; n <= maxn; n++) {
      ae_vector_set_length(&a, n);
      ae_vector_set_length(&c, n);
      ae_vector_set_length(&tiebuf, n + 1);
      ae_vector_set_length(&cntbuf, 3 + 1);
   // one-tie test
      if (n % 2 == 0) {
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)n;
            c.xZ[i] = i % 2;
         }
         dsoptimalsplit2fast(&a, &c, &tiebuf, &cntbuf, &sortrbuf, &sortibuf, n, 2, 0.00, &info, &threshold, &rms, &cvrms);
         if (info != -3) {
            split2Ok = false;
            continue;
         }
      }
   // two-tie test
   // test #1
      if (n > 1) {
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)(i / ((n + 1) / 2));
            c.xZ[i] = i / ((n + 1) / 2);
         }
         dsoptimalsplit2fast(&a, &c, &tiebuf, &cntbuf, &sortrbuf, &sortibuf, n, 2, 0.00, &info, &threshold, &rms, &cvrms);
         if (info != 1) {
            split2Ok = false;
            continue;
         }
         split2Ok = split2Ok && NearAtR(threshold, 0.5, 100.0 * machineepsilon);
         split2Ok = split2Ok && NearAtR(rms, 0.0, 100.0 * machineepsilon);
         if (n == 2) {
            split2Ok = split2Ok && NearAtR(cvrms, 0.5, 100.0 * machineepsilon);
         } else {
            if (n == 3) {
               split2Ok = split2Ok && NearAtR(cvrms, sqrt((2 * 0 + 2 * 0 + 2 * 0.25) / 6), 100.0 * machineepsilon);
            } else {
               split2Ok = split2Ok && SmallAtR(cvrms, 100.0 * machineepsilon);
            }
         }
      }
   }
// special tests
   n = 10;
   ae_vector_set_length(&a, n);
   ae_vector_set_length(&c, n);
   ae_vector_set_length(&tiebuf, n + 1);
   ae_vector_set_length(&cntbuf, 2 * 3);
   for (i = 0; i < n; i++) {
      a.xR[i] = (double)i;
      if (i < n - 2) {
         c.xZ[i] = 0;
      } else {
         c.xZ[i] = i - (n - 3);
      }
   }
   dsoptimalsplit2fast(&a, &c, &tiebuf, &cntbuf, &sortrbuf, &sortibuf, n, 3, 0.00, &info, &threshold, &rms, &cvrms);
   if (info != 1) {
      split2Ok = false;
   } else {
      split2Ok = split2Ok && NearAtR(threshold, n - 2.5, 100.0 * machineepsilon);
      split2Ok = split2Ok && NearAtR(rms, sqrt((0.25 + 0.25 + 0.25 + 0.25) / (3 * n)), 100.0 * machineepsilon);
      split2Ok = split2Ok && NearAtR(cvrms, sqrt((double)(1 + 1 + 1 + 1) / (3 * n)), 100.0 * machineepsilon);
   }
// Optimal split-K
// General tests for different N's
   for (n = 1; n <= maxnq; n++) {
      ae_vector_set_length(&a, n);
      ae_vector_set_length(&c, n);
   // one-tie test
      if (n % 2 == 0) {
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)n;
            c.xZ[i] = i % 2;
         }
         dsoptimalsplitk(&a, &c, n, 2, 2 + randominteger(5), &info, &thresholds, &ni, &cve);
         if (info != -3) {
            optimalsplitkOk = false;
            continue;
         }
      }
   // two-tie test
   // test #1
      if (n > 1) {
         c0 = 0;
         c1 = 0;
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)(i / ((n + 1) / 2));
            c.xZ[i] = i / ((n + 1) / 2);
            if (c.xZ[i] == 0) {
               c0++;
            }
            if (c.xZ[i] == 1) {
               c1++;
            }
         }
         dsoptimalsplitk(&a, &c, n, 2, 2 + randominteger(5), &info, &thresholds, &ni, &cve);
         if (info != 1) {
            optimalsplitkOk = false;
            continue;
         }
         optimalsplitkOk = optimalsplitkOk && ni == 2;
         optimalsplitkOk = optimalsplitkOk && NearAtR(thresholds.xR[0], 0.5, 100.0 * machineepsilon);
         optimalsplitkOk = optimalsplitkOk && NearAtR(cve, -c0 * log((double)c0 / (c0 + 1)) - c1 * log((double)c1 / (c1 + 1)), 100.0 * machineepsilon);
      }
   // test #2
      if (n > 2) {
         c0 = 1 + randominteger(n - 1);
         c1 = n - c0;
         for (i = 0; i < n; i++) {
            if (i < c0) {
               a.xR[i] = 0.0;
               c.xZ[i] = 0;
            } else {
               a.xR[i] = 1.0;
               c.xZ[i] = 1;
            }
         }
         dsoptimalsplitk(&a, &c, n, 2, 2 + randominteger(5), &info, &thresholds, &ni, &cve);
         if (info != 1) {
            optimalsplitkOk = false;
            continue;
         }
         optimalsplitkOk = optimalsplitkOk && ni == 2;
         optimalsplitkOk = optimalsplitkOk && NearAtR(thresholds.xR[0], 0.5, 100.0 * machineepsilon);
         optimalsplitkOk = optimalsplitkOk && NearAtR(cve, -c0 * log((double)c0 / (c0 + 1)) - c1 * log((double)c1 / (c1 + 1)), 100.0 * machineepsilon);
      }
   // multi-tie test
      if (n >= 16) {
      // Multi-tie test.
      //
      // First NC-1 ties have C0 entries, remaining NC-th tie
      // have C1 entries.
         nc = iround(sqrt(n));
         c0 = n / nc;
         c1 = n - c0 * (nc - 1);
         for (i = 0; i < nc - 1; i++) {
            for (j = c0 * i; j < c0 * (i + 1); j++) {
               a.xR[j] = (double)j;
               c.xZ[j] = i;
            }
         }
         for (j = c0 * (nc - 1); j < n; j++) {
            a.xR[j] = (double)j;
            c.xZ[j] = nc - 1;
         }
         dsoptimalsplitk(&a, &c, n, nc, nc + randominteger(nc), &info, &thresholds, &ni, &cve);
         if (info != 1) {
            optimalsplitkOk = false;
            continue;
         }
         optimalsplitkOk = optimalsplitkOk && ni == nc;
         if (ni == nc) {
            for (i = 0; i < nc - 1; i++) {
               optimalsplitkOk = optimalsplitkOk && NearAtR(thresholds.xR[i], c0 * (i + 1) - 1.0 + 0.5, 100.0 * machineepsilon);
            }
            cvr = -((nc - 1) * c0 * log((double)c0 / (c0 + nc - 1)) + c1 * log((double)c1 / (c1 + nc - 1)));
            optimalsplitkOk = optimalsplitkOk && NearAtR(cve, cvr, 100.0 * machineepsilon);
         }
      }
   }
// Non-optimal split-K
// General tests for different N's
   for (n = 1; n <= maxnq; n++) {
      ae_vector_set_length(&a, n);
      ae_vector_set_length(&c, n);
   // one-tie test
      if (n % 2 == 0) {
         for (i = 0; i < n; i++) {
            a.xR[i] = 99.0;
            c.xZ[i] = i % 2;
         }
         dssplitk(&a, &c, n, 2, 2 + randominteger(5), &info, &thresholds, &ni, &cve);
         if (info != -3) {
            splitkOk = false;
            continue;
         }
      }
   // two-tie test
   // test #1
      if (n > 1) {
         c0 = 0;
         c1 = 0;
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)(i / ((n + 1) / 2));
            c.xZ[i] = i / ((n + 1) / 2);
            if (c.xZ[i] == 0) {
               c0++;
            }
            if (c.xZ[i] == 1) {
               c1++;
            }
         }
         dssplitk(&a, &c, n, 2, 2 + randominteger(5), &info, &thresholds, &ni, &cve);
         if (info != 1) {
            splitkOk = false;
            continue;
         }
         splitkOk = splitkOk && ni == 2;
         if (ni == 2) {
            splitkOk = splitkOk && NearAtR(thresholds.xR[0], 0.5, 100.0 * machineepsilon);
            splitkOk = splitkOk && NearAtR(cve, -c0 * log((double)c0 / (c0 + 1)) - c1 * log((double)c1 / (c1 + 1)), 100.0 * machineepsilon);
         }
      }
   // test #2
      if (n > 2) {
         c0 = 1 + randominteger(n - 1);
         c1 = n - c0;
         for (i = 0; i < n; i++) {
            if (i < c0) {
               a.xR[i] = 0.0;
               c.xZ[i] = 0;
            } else {
               a.xR[i] = 1.0;
               c.xZ[i] = 1;
            }
         }
         dssplitk(&a, &c, n, 2, 2 + randominteger(5), &info, &thresholds, &ni, &cve);
         if (info != 1) {
            splitkOk = false;
            continue;
         }
         splitkOk = splitkOk && ni == 2;
         if (ni == 2) {
            splitkOk = splitkOk && NearAtR(thresholds.xR[0], 0.5, 100.0 * machineepsilon);
            splitkOk = splitkOk && NearAtR(cve, -c0 * log((double)c0 / (c0 + 1)) - c1 * log((double)c1 / (c1 + 1)), 100.0 * machineepsilon);
         }
      }
   // multi-tie test
      for (c0 = 4; c0 <= n; c0++) {
         if (n % c0 == 0 && n / c0 <= c0 && n / c0 > 1) {
            nc = n / c0;
            for (i = 0; i < nc; i++) {
               for (j = c0 * i; j < c0 * (i + 1); j++) {
                  a.xR[j] = (double)j;
                  c.xZ[j] = i;
               }
            }
            dssplitk(&a, &c, n, nc, nc + randominteger(nc), &info, &thresholds, &ni, &cve);
            if (info != 1) {
               splitkOk = false;
               continue;
            }
            splitkOk = splitkOk && ni == nc;
            if (ni == nc) {
               for (i = 0; i < nc - 1; i++) {
                  splitkOk = splitkOk && NearAtR(thresholds.xR[i], c0 * (i + 1) - 1.0 + 0.5, 100.0 * machineepsilon);
               }
               cvr = -nc * c0 * log((double)c0 / (c0 + nc - 1));
               splitkOk = splitkOk && NearAtR(cve, cvr, 100.0 * machineepsilon);
            }
         }
      }
   }
// The final report.
   Ok = tiesOk && split2Ok && optimalsplitkOk && splitkOk;
   if (!Ok || !silent) {
      printf("Basic Dataset Subroutines Tests\n");
      printf("Ties:                                     %s\n", tiesOk? "Ok": "Failed");
      printf("Split-2:                                  %s\n", split2Ok? "Ok": "Failed");
      printf("Optimal Split-K:                          %s\n", optimalsplitkOk? "Ok": "Failed");
      printf("Split-K:                                  %s\n", splitkOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === mlpbase testing unit ===
// This function compares vectors G0 and G1 and returns
//     ||G0-G1||/max(||G0||,||G1||,S)
//
// For zero G0, G1 and S (all three quantities are zero) it returns zero.
static double testmlpbaseunit_vectordiff(RVector *g0, RVector *g1, ae_int_t n, double s) {
   ae_int_t i;
   double norm0;
   double norm1;
   double diff;
   double result;
   norm0 = 0.0;
   norm1 = 0.0;
   diff = 0.0;
   for (i = 0; i < n; i++) {
      norm0 += sqr(g0->xR[i]);
      norm1 += sqr(g1->xR[i]);
      diff += sqr(g0->xR[i] - g1->xR[i]);
   }
   norm0 = sqrt(norm0);
   norm1 = sqrt(norm1);
   diff = sqrt(diff);
   if (norm0 != 0.0 || norm1 != 0.0 || s != 0.0) {
      diff /= rmax2(rmax2(norm0, norm1), s);
   } else {
      diff = 0.0;
   }
   result = diff;
   return result;
}

// Network creation
//
// This function creates network with desired structure.
//
// Network is created using one of the three methods:
// a) straightforward creation using MLPCreate???()
// b) MLPCreate???() for proxy object, which is copied with PassThroughSerializer()
// c) MLPCreate???() for proxy object, which is copied with MLPCopy()
//
// One of these methods is chosen at random.
static void testmlpbaseunit_createnetwork(multilayerperceptron *network, ae_int_t nkind, double a1, double a2, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout) {
   ae_frame _frame_block;
   ae_int_t mkind;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, tmp);
   ae_assert(nin > 0 && nhid1 >= 0 && nhid2 >= 0 && nout > 0, "CreateNetwork error");
   ae_assert(nhid1 != 0 || nhid2 == 0, "CreateNetwork error");
   ae_assert(nkind != 1 || nout >= 2, "CreateNetwork error");
   mkind = randominteger(3);
   if (nhid1 == 0) {
   // No hidden layers
      if (nkind == 0) {
         if (mkind == 0) {
            mlpcreate0(nin, nout, network);
         }
         if (mkind == 1) {
            mlpcreate0(nin, nout, &tmp);
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               mlpalloc(&_local_serializer, &tmp);
               ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpserialize(&_local_serializer, &tmp);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpunserialize(&_local_serializer, network);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
         }
         if (mkind == 2) {
            mlpcreate0(nin, nout, &tmp);
            mlpcopy(&tmp, network);
         }
      } else {
         if (nkind == 1) {
            if (mkind == 0) {
               mlpcreatec0(nin, nout, network);
            }
            if (mkind == 1) {
               mlpcreatec0(nin, nout, &tmp);
               {
               // This code passes data structure through serializers
               // (serializes it to string and loads back)
                  ae_frame _local_frame_block;
                  ae_frame_make(&_local_frame_block);
                  NewSerializer(_local_serializer);
                  ae_serializer_alloc_start(&_local_serializer);
                  mlpalloc(&_local_serializer, &tmp);
                  ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                  NewBlock(_local_dynamic_block, _local_ssize + 1);
                  ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  mlpserialize(&_local_serializer, &tmp);
                  ae_serializer_stop(&_local_serializer);
                  ae_serializer_init(&_local_serializer);
                  ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  mlpunserialize(&_local_serializer, network);
                  ae_serializer_stop(&_local_serializer);
                  ae_frame_leave();
               }
            }
            if (mkind == 2) {
               mlpcreatec0(nin, nout, &tmp);
               mlpcopy(&tmp, network);
            }
         } else {
            if (nkind == 2) {
               if (mkind == 0) {
                  mlpcreateb0(nin, nout, a1, a2, network);
               }
               if (mkind == 1) {
                  mlpcreateb0(nin, nout, a1, a2, &tmp);
                  {
                  // This code passes data structure through serializers
                  // (serializes it to string and loads back)
                     ae_frame _local_frame_block;
                     ae_frame_make(&_local_frame_block);
                     NewSerializer(_local_serializer);
                     ae_serializer_alloc_start(&_local_serializer);
                     mlpalloc(&_local_serializer, &tmp);
                     ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                     NewBlock(_local_dynamic_block, _local_ssize + 1);
                     ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                     mlpserialize(&_local_serializer, &tmp);
                     ae_serializer_stop(&_local_serializer);
                     ae_serializer_init(&_local_serializer);
                     ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                     mlpunserialize(&_local_serializer, network);
                     ae_serializer_stop(&_local_serializer);
                     ae_frame_leave();
                  }
               }
               if (mkind == 2) {
                  mlpcreateb0(nin, nout, a1, a2, &tmp);
                  mlpcopy(&tmp, network);
               }
            } else {
               if (nkind == 3) {
                  if (mkind == 0) {
                     mlpcreater0(nin, nout, a1, a2, network);
                  }
                  if (mkind == 1) {
                     mlpcreater0(nin, nout, a1, a2, &tmp);
                     {
                     // This code passes data structure through serializers
                     // (serializes it to string and loads back)
                        ae_frame _local_frame_block;
                        ae_frame_make(&_local_frame_block);
                        NewSerializer(_local_serializer);
                        ae_serializer_alloc_start(&_local_serializer);
                        mlpalloc(&_local_serializer, &tmp);
                        ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                        NewBlock(_local_dynamic_block, _local_ssize + 1);
                        ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                        mlpserialize(&_local_serializer, &tmp);
                        ae_serializer_stop(&_local_serializer);
                        ae_serializer_init(&_local_serializer);
                        ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                        mlpunserialize(&_local_serializer, network);
                        ae_serializer_stop(&_local_serializer);
                        ae_frame_leave();
                     }
                  }
                  if (mkind == 2) {
                     mlpcreater0(nin, nout, a1, a2, &tmp);
                     mlpcopy(&tmp, network);
                  }
               }
            }
         }
      }
      mlprandomizefull(network);
      ae_frame_leave();
      return;
   }
   if (nhid2 == 0) {
   // One hidden layer
      if (nkind == 0) {
         if (mkind == 0) {
            mlpcreate1(nin, nhid1, nout, network);
         }
         if (mkind == 1) {
            mlpcreate1(nin, nhid1, nout, &tmp);
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               mlpalloc(&_local_serializer, &tmp);
               ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpserialize(&_local_serializer, &tmp);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpunserialize(&_local_serializer, network);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
         }
         if (mkind == 2) {
            mlpcreate1(nin, nhid1, nout, &tmp);
            mlpcopy(&tmp, network);
         }
      } else {
         if (nkind == 1) {
            if (mkind == 0) {
               mlpcreatec1(nin, nhid1, nout, network);
            }
            if (mkind == 1) {
               mlpcreatec1(nin, nhid1, nout, &tmp);
               {
               // This code passes data structure through serializers
               // (serializes it to string and loads back)
                  ae_frame _local_frame_block;
                  ae_frame_make(&_local_frame_block);
                  NewSerializer(_local_serializer);
                  ae_serializer_alloc_start(&_local_serializer);
                  mlpalloc(&_local_serializer, &tmp);
                  ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                  NewBlock(_local_dynamic_block, _local_ssize + 1);
                  ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  mlpserialize(&_local_serializer, &tmp);
                  ae_serializer_stop(&_local_serializer);
                  ae_serializer_init(&_local_serializer);
                  ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  mlpunserialize(&_local_serializer, network);
                  ae_serializer_stop(&_local_serializer);
                  ae_frame_leave();
               }
            }
            if (mkind == 2) {
               mlpcreatec1(nin, nhid1, nout, &tmp);
               mlpcopy(&tmp, network);
            }
         } else {
            if (nkind == 2) {
               if (mkind == 0) {
                  mlpcreateb1(nin, nhid1, nout, a1, a2, network);
               }
               if (mkind == 1) {
                  mlpcreateb1(nin, nhid1, nout, a1, a2, &tmp);
                  {
                  // This code passes data structure through serializers
                  // (serializes it to string and loads back)
                     ae_frame _local_frame_block;
                     ae_frame_make(&_local_frame_block);
                     NewSerializer(_local_serializer);
                     ae_serializer_alloc_start(&_local_serializer);
                     mlpalloc(&_local_serializer, &tmp);
                     ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                     NewBlock(_local_dynamic_block, _local_ssize + 1);
                     ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                     mlpserialize(&_local_serializer, &tmp);
                     ae_serializer_stop(&_local_serializer);
                     ae_serializer_init(&_local_serializer);
                     ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                     mlpunserialize(&_local_serializer, network);
                     ae_serializer_stop(&_local_serializer);
                     ae_frame_leave();
                  }
               }
               if (mkind == 2) {
                  mlpcreateb1(nin, nhid1, nout, a1, a2, &tmp);
                  mlpcopy(&tmp, network);
               }
            } else {
               if (nkind == 3) {
                  if (mkind == 0) {
                     mlpcreater1(nin, nhid1, nout, a1, a2, network);
                  }
                  if (mkind == 1) {
                     mlpcreater1(nin, nhid1, nout, a1, a2, &tmp);
                     {
                     // This code passes data structure through serializers
                     // (serializes it to string and loads back)
                        ae_frame _local_frame_block;
                        ae_frame_make(&_local_frame_block);
                        NewSerializer(_local_serializer);
                        ae_serializer_alloc_start(&_local_serializer);
                        mlpalloc(&_local_serializer, &tmp);
                        ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                        NewBlock(_local_dynamic_block, _local_ssize + 1);
                        ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                        mlpserialize(&_local_serializer, &tmp);
                        ae_serializer_stop(&_local_serializer);
                        ae_serializer_init(&_local_serializer);
                        ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                        mlpunserialize(&_local_serializer, network);
                        ae_serializer_stop(&_local_serializer);
                        ae_frame_leave();
                     }
                  }
                  if (mkind == 2) {
                     mlpcreater1(nin, nhid1, nout, a1, a2, &tmp);
                     mlpcopy(&tmp, network);
                  }
               }
            }
         }
      }
      mlprandomizefull(network);
      ae_frame_leave();
      return;
   }
// Two hidden layers
   if (nkind == 0) {
      if (mkind == 0) {
         mlpcreate2(nin, nhid1, nhid2, nout, network);
      }
      if (mkind == 1) {
         mlpcreate2(nin, nhid1, nhid2, nout, &tmp);
         {
         // This code passes data structure through serializers
         // (serializes it to string and loads back)
            ae_frame _local_frame_block;
            ae_frame_make(&_local_frame_block);
            NewSerializer(_local_serializer);
            ae_serializer_alloc_start(&_local_serializer);
            mlpalloc(&_local_serializer, &tmp);
            ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
            NewBlock(_local_dynamic_block, _local_ssize + 1);
            ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            mlpserialize(&_local_serializer, &tmp);
            ae_serializer_stop(&_local_serializer);
            ae_serializer_init(&_local_serializer);
            ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            mlpunserialize(&_local_serializer, network);
            ae_serializer_stop(&_local_serializer);
            ae_frame_leave();
         }
      }
      if (mkind == 2) {
         mlpcreate2(nin, nhid1, nhid2, nout, &tmp);
         mlpcopy(&tmp, network);
      }
   } else {
      if (nkind == 1) {
         if (mkind == 0) {
            mlpcreatec2(nin, nhid1, nhid2, nout, network);
         }
         if (mkind == 1) {
            mlpcreatec2(nin, nhid1, nhid2, nout, &tmp);
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               mlpalloc(&_local_serializer, &tmp);
               ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpserialize(&_local_serializer, &tmp);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpunserialize(&_local_serializer, network);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
         }
         if (mkind == 2) {
            mlpcreatec2(nin, nhid1, nhid2, nout, &tmp);
            mlpcopy(&tmp, network);
         }
      } else {
         if (nkind == 2) {
            if (mkind == 0) {
               mlpcreateb2(nin, nhid1, nhid2, nout, a1, a2, network);
            }
            if (mkind == 1) {
               mlpcreateb2(nin, nhid1, nhid2, nout, a1, a2, &tmp);
               {
               // This code passes data structure through serializers
               // (serializes it to string and loads back)
                  ae_frame _local_frame_block;
                  ae_frame_make(&_local_frame_block);
                  NewSerializer(_local_serializer);
                  ae_serializer_alloc_start(&_local_serializer);
                  mlpalloc(&_local_serializer, &tmp);
                  ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                  NewBlock(_local_dynamic_block, _local_ssize + 1);
                  ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  mlpserialize(&_local_serializer, &tmp);
                  ae_serializer_stop(&_local_serializer);
                  ae_serializer_init(&_local_serializer);
                  ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  mlpunserialize(&_local_serializer, network);
                  ae_serializer_stop(&_local_serializer);
                  ae_frame_leave();
               }
            }
            if (mkind == 2) {
               mlpcreateb2(nin, nhid1, nhid2, nout, a1, a2, &tmp);
               mlpcopy(&tmp, network);
            }
         } else {
            if (nkind == 3) {
               if (mkind == 0) {
                  mlpcreater2(nin, nhid1, nhid2, nout, a1, a2, network);
               }
               if (mkind == 1) {
                  mlpcreater2(nin, nhid1, nhid2, nout, a1, a2, &tmp);
                  {
                  // This code passes data structure through serializers
                  // (serializes it to string and loads back)
                     ae_frame _local_frame_block;
                     ae_frame_make(&_local_frame_block);
                     NewSerializer(_local_serializer);
                     ae_serializer_alloc_start(&_local_serializer);
                     mlpalloc(&_local_serializer, &tmp);
                     ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                     NewBlock(_local_dynamic_block, _local_ssize + 1);
                     ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                     mlpserialize(&_local_serializer, &tmp);
                     ae_serializer_stop(&_local_serializer);
                     ae_serializer_init(&_local_serializer);
                     ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                     mlpunserialize(&_local_serializer, network);
                     ae_serializer_stop(&_local_serializer);
                     ae_frame_leave();
                  }
               }
               if (mkind == 2) {
                  mlpcreater2(nin, nhid1, nhid2, nout, a1, a2, &tmp);
                  mlpcopy(&tmp, network);
               }
            }
         }
      }
   }
   mlprandomizefull(network);
   ae_frame_leave();
}

// Unsets network (initialize it to smallest network possible
static void testmlpbaseunit_unsetnetwork(multilayerperceptron *network) {
   mlpcreate0(1, 1, network);
}

// Informational functions test
static bool testmlpbaseunit_testinformational(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t wcount;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double threshold;
   ae_int_t nlayers;
   ae_int_t nmax;
   double mean;
   double sigma;
   ae_int_t fkind;
   double c;
   double f;
   double df;
   double d2f;
   double s;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewMatrix(neurons, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   threshold = 100000.0 * machineepsilon;
   testmlpbaseunit_createnetwork(&network, nkind, 0.0, 0.0, nin, nhid1, nhid2, nout);
// test MLPProperties()
   mlpproperties(&network, &n1, &n2, &wcount);
   Ok = Ok && n1 == nin && n2 == nout && wcount > 0;
   Ok = Ok && mlpgetinputscount(&network) == nin && mlpgetoutputscount(&network) == nout && mlpgetweightscount(&network) == wcount;
// Test network geometry functions
//
// In order to do this we calculate neural network output using
// informational functions only, and compare results with ones
// obtained with MLPProcess():
// 1. we allocate 2-dimensional array of neurons and fill it by zeros
// 2. we full first layer of neurons by input values
// 3. we move through array, calculating values of subsequent layers
// 4. if we have classification network, we SOFTMAX-normalize output layer
// 5. we apply scaling to the outputs
// 6. we compare results with ones obtained by MLPProcess()
//
// NOTE: it is important to do (4) before (5), because on SOFTMAX network
//       MLPGetOutputScaling() must return Mean == 0 and Sigma == 1. In order
//       to test it implicitly, we apply it to the classifier results
//       (already normalized). If one of the coefficients deviates from
//       expected values, we will get error during (6).
   nlayers = 2;
   nmax = imax2(nin, nout);
   if (nhid1 != 0) {
      nlayers = 3;
      nmax = imax2(nmax, nhid1);
   }
   if (nhid2 != 0) {
      nlayers = 4;
      nmax = imax2(nmax, nhid2);
   }
   ae_matrix_set_length(&neurons, nlayers, nmax);
   for (i = 0; i < nlayers; i++) {
      for (j = 0; j < nmax; j++) {
         neurons.xyR[i][j] = 0.0;
      }
   }
   ae_vector_set_length(&x, nin);
   for (i = 0; i < nin; i++) {
      x.xR[i] = randommid();
   }
   ae_vector_set_length(&y, nout);
   for (i = 0; i < nout; i++) {
      y.xR[i] = randommid();
   }
   for (j = 0; j < nin; j++) {
      mlpgetinputscaling(&network, j, &mean, &sigma);
      neurons.xyR[0][j] = (x.xR[j] - mean) / sigma;
   }
   for (i = 1; i < nlayers; i++) {
      for (j = 0; j < mlpgetlayersize(&network, i); j++) {
         for (k = 0; k < mlpgetlayersize(&network, i - 1); k++) {
            neurons.xyR[i][j] += mlpgetweight(&network, i - 1, k, i, j) * neurons.xyR[i - 1][k];
         }
         mlpgetneuroninfo(&network, i, j, &fkind, &c);
         mlpactivationfunction(neurons.xyR[i][j] - c, fkind, &f, &df, &d2f);
         neurons.xyR[i][j] = f;
      }
   }
   if (nkind == 1) {
      s = 0.0;
      for (j = 0; j < nout; j++) {
         s += exp(neurons.xyR[nlayers - 1][j]);
      }
      for (j = 0; j < nout; j++) {
         neurons.xyR[nlayers - 1][j] = exp(neurons.xyR[nlayers - 1][j]) / s;
      }
   }
   for (j = 0; j < nout; j++) {
      mlpgetoutputscaling(&network, j, &mean, &sigma);
      neurons.xyR[nlayers - 1][j] = neurons.xyR[nlayers - 1][j] * sigma + mean;
   }
   mlpprocess(&network, &x, &y);
   for (j = 0; j < nout; j++) {
      Ok = Ok && NearAtR(neurons.xyR[nlayers - 1][j], y.xR[j], threshold);
   }
   ae_frame_leave();
   return Ok;
}

// Processing functions test
static bool testmlpbaseunit_testprocessing(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t npoints;
   ae_int_t subnp;
   bool iscls;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t wcount;
   bool zeronet;
   double a1;
   double a2;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   bool allsame;
   ae_int_t pcount;
   double v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewObj(multilayerperceptron, network2);
   NewObj(sparsematrix, sparsexy);
   NewMatrix(densexy, 0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(p0, 0, DT_REAL);
   NewVector(p1, 0, DT_REAL);
   ae_assert(passcount >= 2, "PassCount < 2!");
// Prepare network
   a1 = 0.0;
   a2 = 0.0;
   if (nkind == 2) {
      a1 = 500.0 * randommid();
      a2 = randommid();
   }
   if (nkind == 3) {
      a1 = 500.0 * randommid();
      a2 = a1 + (2 * randominteger(2) - 1) * (0.1 + 0.9 * randomreal());
   }
   testmlpbaseunit_createnetwork(&network, nkind, a1, a2, nin, nhid1, nhid2, nout);
   mlpproperties(&network, &n1, &n2, &wcount);
   iscls = mlpissoftmax(&network);
// Initialize arrays
   ae_vector_set_length(&x1, nin);
   ae_vector_set_length(&x2, nin);
   ae_vector_set_length(&y1, nout);
   ae_vector_set_length(&y2, nout);
// Initialize sets
   npoints = randominteger(11) + 10;
   if (iscls) {
      ae_matrix_set_length(&densexy, npoints, nin + 1);
      sparsecreate(npoints, nin + 1, npoints, &sparsexy);
   } else {
      ae_matrix_set_length(&densexy, npoints, nin + nout);
      sparsecreate(npoints, nin + nout, npoints, &sparsexy);
   }
   sparseconverttocrs(&sparsexy);
// Main cycle
   for (pass = 1; pass <= passcount; pass++) {
   // Last run is made on zero network
      mlprandomizefull(&network);
      zeronet = false;
      if (pass == passcount) {
         ae_v_muld(network.weights.xR, 1, wcount, 0);
         zeronet = true;
      }
   // Same inputs leads to same outputs
      for (i = 0; i < nin; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nout; i++) {
         y1.xR[i] = randommid();
         y2.xR[i] = randommid();
      }
      mlpprocess(&network, &x1, &y1);
      mlpprocess(&network, &x2, &y2);
      Ok = Ok && testmlpbaseunit_vectordiff(&y1, &y2, nout, 1.0) == 0.0;
   // Same inputs on original network leads to same outputs
   // on copy created:
   // * using MLPCopy
   // * using MLPCopyShared
      for (i = 0; i < nin; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nout; i++) {
         y1.xR[i] = randommid();
      }
      for (i = 0; i < nout; i++) {
         y2.xR[i] = randommid();
      }
      testmlpbaseunit_unsetnetwork(&network2);
      mlpcopy(&network, &network2);
      mlpprocess(&network, &x1, &y1);
      mlpprocess(&network2, &x2, &y2);
      Ok = Ok && testmlpbaseunit_vectordiff(&y1, &y2, nout, 1.0) == 0.0;
      for (i = 0; i < nout; i++) {
         y2.xR[i] = randommid();
      }
      testmlpbaseunit_unsetnetwork(&network2);
      mlpcopyshared(&network, &network2);
      mlpprocess(&network, &x1, &y1);
      mlpprocess(&network2, &x2, &y2);
      Ok = Ok && testmlpbaseunit_vectordiff(&y1, &y2, nout, 1.0) == 0.0;
   // Additionally we tests functions for copying of tunable
   // parameters by:
   // * copying network using MLPCopy
   // * randomizing tunable parameters with MLPRandomizeFull()
   // * copying tunable parameters with:
   //   a) MLPCopyTunableParameters
   //   b) combination of MLPExportTunableParameters and
   //      MLPImportTunableParameters - we export parameters
   //      to P1, copy PCount elements to P2, then test import.
      for (i = 0; i < nin; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nout; i++) {
         y1.xR[i] = randommid();
      }
      for (i = 0; i < nout; i++) {
         y2.xR[i] = randommid();
      }
      testmlpbaseunit_unsetnetwork(&network2);
      mlpcopy(&network, &network2);
      mlprandomizefull(&network2);
      mlpcopytunableparameters(&network, &network2);
      mlpprocess(&network, &x1, &y1);
      mlpprocess(&network2, &x2, &y2);
      Ok = Ok && testmlpbaseunit_vectordiff(&y1, &y2, nout, 1.0) == 0.0;
      for (i = 0; i < nout; i++) {
         y2.xR[i] = randommid();
      }
      testmlpbaseunit_unsetnetwork(&network2);
      mlpcopy(&network, &network2);
      mlprandomizefull(&network2);
      mlpexporttunableparameters(&network, &p0, &pcount);
      ae_vector_set_length(&p1, pcount);
      for (i = 0; i < pcount; i++) {
         p1.xR[i] = p0.xR[i];
      }
      mlpimporttunableparameters(&network2, &p1);
      mlpprocess(&network, &x1, &y1);
      mlpprocess(&network2, &x2, &y2);
      Ok = Ok && testmlpbaseunit_vectordiff(&y1, &y2, nout, 1.0) == 0.0;
   // Same inputs on original network leads to same outputs
   // on copy created using MLPSerialize
      testmlpbaseunit_unsetnetwork(&network2);
      {
      // This code passes data structure through serializers
      // (serializes it to string and loads back)
         ae_frame _local_frame_block;
         ae_frame_make(&_local_frame_block);
         NewSerializer(_local_serializer);
         ae_serializer_alloc_start(&_local_serializer);
         mlpalloc(&_local_serializer, &network);
         ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
         NewBlock(_local_dynamic_block, _local_ssize + 1);
         ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
         mlpserialize(&_local_serializer, &network);
         ae_serializer_stop(&_local_serializer);
         ae_serializer_init(&_local_serializer);
         ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
         mlpunserialize(&_local_serializer, &network2);
         ae_serializer_stop(&_local_serializer);
         ae_frame_leave();
      }
      for (i = 0; i < nin; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nout; i++) {
         y1.xR[i] = randommid();
         y2.xR[i] = randommid();
      }
      mlpprocess(&network, &x1, &y1);
      mlpprocess(&network2, &x2, &y2);
      allsame = true;
      for (i = 0; i < nout; i++) {
         allsame = allsame && y1.xR[i] == y2.xR[i];
      }
      Ok = Ok && allsame;
   // Different inputs leads to different outputs (non-zero network)
      if (!zeronet) {
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = randommid();
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = y1.xR[i];
         }
         mlpprocess(&network, &x1, &y1);
         mlpprocess(&network, &x2, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         Ok = Ok && !allsame;
      }
   // Randomization changes outputs (when inputs are unchanged, non-zero network)
      if (!zeronet) {
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = randommid();
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = y1.xR[i];
         }
         mlpcopy(&network, &network2);
         mlprandomize(&network2);
         mlpprocess(&network, &x1, &y1);
         mlpprocess(&network2, &x1, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         Ok = Ok && !allsame;
      }
   // Full randomization changes outputs (when inputs are unchanged, non-zero network)
      if (!zeronet) {
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = randommid();
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = y1.xR[i];
         }
         mlpcopy(&network, &network2);
         mlprandomizefull(&network2);
         mlpprocess(&network, &x1, &y1);
         mlpprocess(&network2, &x1, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         Ok = Ok && !allsame;
      }
   // Normalization properties
      if (nkind == 1) {
      // Classifier network outputs are normalized
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
         }
         mlpprocess(&network, &x1, &y1);
         v = 0.0;
         for (i = 0; i < nout; i++) {
            v += y1.xR[i];
            Ok = Ok && y1.xR[i] >= 0.0;
         }
         Ok = Ok && NearAtR(v, 1, 1000.0 * machineepsilon);
      }
      if (nkind == 2) {
      // B-type network outputs are bounded from above/below
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
         }
         mlpprocess(&network, &x1, &y1);
         for (i = 0; i < nout; i++) {
            if (a2 >= 0.0) {
               Ok = Ok && y1.xR[i] >= a1;
            } else {
               Ok = Ok && y1.xR[i] <= a1;
            }
         }
      }
      if (nkind == 3) {
      // R-type network outputs are within [A1,A2] (or [A2,A1])
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
         }
         mlpprocess(&network, &x1, &y1);
         for (i = 0; i < nout; i++) {
            Ok = Ok && y1.xR[i] >= rmin2(a1, a2) && y1.xR[i] <= rmax2(a1, a2);
         }
      }
   // Comperison MLPInitPreprocessor results with
   // MLPInitPreprocessorSparse results
      sparseconverttohash(&sparsexy);
      if (iscls) {
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nin; j++) {
               densexy.xyR[i][j] = randommid();
               sparseset(&sparsexy, i, j, densexy.xyR[i][j]);
            }
            densexy.xyR[i][nin] = (double)randominteger(nout);
            sparseset(&sparsexy, i, j, densexy.xyR[i][nin]);
         }
      } else {
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nin + nout; j++) {
               densexy.xyR[i][j] = randommid();
               sparseset(&sparsexy, i, j, densexy.xyR[i][j]);
            }
         }
      }
      sparseconverttocrs(&sparsexy);
      mlpcopy(&network, &network2);
      mlpinitpreprocessor(&network, &densexy, npoints);
      mlpinitpreprocessorsparse(&network2, &sparsexy, npoints);
      subnp = randominteger(npoints);
      for (i = 0; i < subnp; i++) {
         for (j = 0; j < nin; j++) {
            x1.xR[j] = randommid();
         }
         mlpprocess(&network, &x1, &y1);
         mlpprocess(&network2, &x1, &y2);
         for (j = 0; j < nout; j++) {
            Ok = Ok && NearAtR(y1.xR[j], y2.xR[j], 1.0E-6);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Gradient functions test
static bool testmlpbaseunit_testgradient(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t passcount, ae_int_t sizemin, ae_int_t sizemax) {
   ae_frame _frame_block;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t wcount;
   double h;
   double etol;
   double escale;
   double gscale;
   double nonstricttolerance;
   double a1;
   double a2;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t ssize;
   ae_int_t subsetsize;
   ae_int_t rowsize;
   double v;
   double e;
   double e1;
   double e2;
   double esp;
   double v1;
   double v2;
   double v3;
   double v4;
   double wprev;
   double referencee;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewObj(sparsematrix, sparsexy);
   NewObj(sparsematrix, sparsexy2);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewVector(grad1, 0, DT_REAL);
   NewVector(grad2, 0, DT_REAL);
   NewVector(gradsp, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(idx, 0, DT_INT);
   NewVector(referenceg, 0, DT_REAL);
   a1 = 0.0;
   a2 = 0.0;
   if (nkind == 2) {
      a1 = 500.0 * randommid();
      a2 = randommid();
   }
   if (nkind == 3) {
      a1 = 500.0 * randommid();
      a2 = a1 + (2 * randominteger(2) - 1) * (0.1 + 0.9 * randomreal());
   }
   testmlpbaseunit_createnetwork(&network, nkind, a1, a2, nin, nhid1, nhid2, nout);
   mlpproperties(&network, &n1, &n2, &wcount);
   h = 0.0001;
   etol = 1.0E-2;
   escale = 1.0E-2;
   gscale = 1.0E-2;
   nonstricttolerance = 0.01;
// Initialize
   ae_vector_set_length(&x, nin);
   ae_vector_set_length(&x1, nin);
   ae_vector_set_length(&x2, nin);
   ae_vector_set_length(&y, nout);
   ae_vector_set_length(&y1, nout);
   ae_vector_set_length(&y2, nout);
   ae_vector_set_length(&referenceg, wcount);
   ae_vector_set_length(&grad1, wcount);
   ae_vector_set_length(&grad2, wcount);
// Process
   for (pass = 1; pass <= passcount; pass++) {
   // Randomize network, then re-randomaze weights manually.
   //
   // NOTE: weights magnitude is chosen to be small, about 0.1,
   //       which allows us to avoid oversaturated network.
   //       In 10% of cases we use zero weights.
      mlprandomizefull(&network);
      if (randombool(0.1)) {
         for (i = 0; i < wcount; i++) {
            network.weights.xR[i] = 0.0;
         }
      } else {
         for (i = 0; i < wcount; i++) {
            network.weights.xR[i] = 0.1 * randommid();
         }
      }
   // Test MLPError(), MLPErrorSparse(), MLPGrad() for single-element dataset:
   // * generate input X, output Y, combine them in dataset XY
   // * calculate "reference" error on dataset manually (call MLPProcess and evaluate sum-of-squared errors)
   // * calculate "reference" gradient by performing numerical differentiation of "reference" error
   //   using 4-point differentiation formula
   // * test error/gradient returned by MLPGrad(), MLPError(), MLPErrorSparse()
      ae_matrix_set_length(&xy, 1, nin + nout);
      sparsecreate(1, nin + nout, nin + nout, &sparsexy);
      for (i = 0; i < nin; i++) {
         x.xR[i] = 2.0 * randommid();
      }
      ae_v_move(xy.xyR[0], 1, x.xR, 1, nin);
      for (i = 0; i < nin; i++) {
         sparseset(&sparsexy, 0, i, x.xR[i]);
      }
      if (mlpissoftmax(&network)) {
         for (i = 0; i < nout; i++) {
            y.xR[i] = 0.0;
         }
         xy.xyR[0][nin] = (double)randominteger(nout);
         sparseset(&sparsexy, 0, nin, xy.xyR[0][nin]);
         y.xR[iround(xy.xyR[0][nin])] = 1.0;
      } else {
         for (i = 0; i < nout; i++) {
            y.xR[i] = 2.0 * randommid();
            sparseset(&sparsexy, 0, nin + i, y.xR[i]);
         }
         ae_v_move(&xy.xyR[0][nin], 1, y.xR, 1, nout);
      }
      sparseconverttocrs(&sparsexy);
      mlpprocess(&network, &x, &y2);
      ae_v_sub(y2.xR, 1, y.xR, 1, nout);
      referencee = ae_v_dotproduct(y2.xR, 1, y2.xR, 1, nout);
      referencee /= 2;
      for (i = 0; i < wcount; i++) {
         wprev = network.weights.xR[i];
         network.weights.xR[i] = wprev - 2 * h;
         mlpprocess(&network, &x, &y1);
         ae_v_sub(y1.xR, 1, y.xR, 1, nout);
         v1 = ae_v_dotproduct(y1.xR, 1, y1.xR, 1, nout);
         v1 /= 2;
         network.weights.xR[i] = wprev - h;
         mlpprocess(&network, &x, &y1);
         ae_v_sub(y1.xR, 1, y.xR, 1, nout);
         v2 = ae_v_dotproduct(y1.xR, 1, y1.xR, 1, nout);
         v2 /= 2;
         network.weights.xR[i] = wprev + h;
         mlpprocess(&network, &x, &y1);
         ae_v_sub(y1.xR, 1, y.xR, 1, nout);
         v3 = ae_v_dotproduct(y1.xR, 1, y1.xR, 1, nout);
         v3 /= 2;
         network.weights.xR[i] = wprev + 2 * h;
         mlpprocess(&network, &x, &y1);
         ae_v_sub(y1.xR, 1, y.xR, 1, nout);
         v4 = ae_v_dotproduct(y1.xR, 1, y1.xR, 1, nout);
         v4 /= 2;
         network.weights.xR[i] = wprev;
         referenceg.xR[i] = (v1 - 8 * v2 + 8 * v3 - v4) / (12 * h);
      }
      mlpgrad(&network, &x, &y, &e, &grad2);
      Ok = Ok && RelNear(e, referencee, etol, escale);
      Ok = Ok && RelNear(mlperror(&network, &xy, 1), referencee, etol, escale);
      Ok = Ok && RelNear(mlperrorsparse(&network, &sparsexy, 1), referencee, etol, escale);
      Ok = Ok && testmlpbaseunit_vectordiff(&referenceg, &grad2, wcount, gscale) <= etol;
   // Test MLPErrorN(), MLPGradN() for single-element dataset:
   // * generate input X, output Y, combine them in dataset XY
   // * calculate "reference" error on dataset manually (call MLPProcess and evaluate sum-of-squared errors)
   // * calculate "reference" gradient by performing numerical differentiation of "reference" error
   // * test error/gradient returned by MLPGradN(), MLPErrorN()
   //
   // NOTE: because we use inexact 2-point formula, we perform gradient test with NonStrictTolerance
      ae_matrix_set_length(&xy, 1, nin + nout);
      for (i = 0; i < nin; i++) {
         x.xR[i] = 2.0 * randommid();
      }
      ae_v_move(xy.xyR[0], 1, x.xR, 1, nin);
      if (mlpissoftmax(&network)) {
         for (i = 0; i < nout; i++) {
            y.xR[i] = 0.0;
         }
         xy.xyR[0][nin] = (double)randominteger(nout);
         y.xR[iround(xy.xyR[0][nin])] = 1.0;
      } else {
         for (i = 0; i < nout; i++) {
            y.xR[i] = 2.0 * randommid();
         }
         ae_v_move(&xy.xyR[0][nin], 1, y.xR, 1, nout);
      }
      mlpprocess(&network, &x, &y2);
      referencee = 0.0;
      if (nkind != 1) {
         for (i = 0; i < nout; i++) {
            referencee += 0.5 * sqr(y2.xR[i] - y.xR[i]);
         }
      } else {
         for (i = 0; i < nout; i++) {
            if (y.xR[i] != 0.0) {
               if (y2.xR[i] == 0.0) {
                  referencee += y.xR[i] * log(maxrealnumber);
               } else {
                  referencee += y.xR[i] * log(y.xR[i] / y2.xR[i]);
               }
            }
         }
      }
      for (i = 0; i < wcount; i++) {
         wprev = network.weights.xR[i];
         network.weights.xR[i] = wprev + h;
         mlpprocess(&network, &x, &y2);
         network.weights.xR[i] = wprev - h;
         mlpprocess(&network, &x, &y1);
         network.weights.xR[i] = wprev;
         v = 0.0;
         if (nkind != 1) {
            for (j = 0; j < nout; j++) {
               v += 0.5 * (sqr(y2.xR[j] - y.xR[j]) - sqr(y1.xR[j] - y.xR[j])) / (2 * h);
            }
         } else {
            for (j = 0; j < nout; j++) {
               if (y.xR[j] != 0.0) {
                  if (y2.xR[j] == 0.0) {
                     v += y.xR[j] * log(maxrealnumber);
                  } else {
                     v += y.xR[j] * log(y.xR[j] / y2.xR[j]);
                  }
                  if (y1.xR[j] == 0.0) {
                     v -= y.xR[j] * log(maxrealnumber);
                  } else {
                     v -= y.xR[j] * log(y.xR[j] / y1.xR[j]);
                  }
               }
            }
            v /= 2 * h;
         }
         referenceg.xR[i] = v;
      }
      mlpgradn(&network, &x, &y, &e, &grad2);
      Ok = Ok && RelNear(e, referencee, etol, escale);
      Ok = Ok && RelNear(mlperrorn(&network, &xy, 1), referencee, etol, escale);
      Ok = Ok && testmlpbaseunit_vectordiff(&referenceg, &grad2, wcount, gscale) <= nonstricttolerance;
   // Test that gradient calculation functions automatically allocate
   // space for gradient, if needed.
   //
   // NOTE: we perform test with empty dataset.
      sparsecreate(1, nin + nout, 0, &sparsexy);
      sparseconverttocrs(&sparsexy);
      ae_vector_set_length(&grad1, 1);
      mlpgradbatch(&network, &xy, 0, &e1, &grad1);
      Ok = Ok && grad1.cnt == wcount;
      ae_vector_set_length(&grad1, 1);
      mlpgradbatchsparse(&network, &sparsexy, 0, &e1, &grad1);
      Ok = Ok && grad1.cnt == wcount;
      ae_vector_set_length(&grad1, 1);
      mlpgradbatchsubset(&network, &xy, 0, &idx, 0, &e1, &grad1);
      Ok = Ok && grad1.cnt == wcount;
      ae_vector_set_length(&grad1, 1);
      mlpgradbatchsparsesubset(&network, &sparsexy, 0, &idx, 0, &e1, &grad1);
      Ok = Ok && grad1.cnt == wcount;
   // Test MLPError(), MLPErrorSparse(), MLPGradBatch(), MLPGradBatchSparse() for many-element dataset:
   // * generate random dataset XY
   // * calculate "reference" error/gradient using MLPGrad(), which was tested in previous
   //   section and is assumed to work correctly
   // * test results returned by MLPGradBatch/MLPGradBatchSparse against reference ones
   //
   // NOTE: about 10% of tests are performed with zero SSize
      ssize = sizemin + randominteger(sizemax - sizemin + 1);
      ae_matrix_set_length(&xy, imax2(ssize, 1), nin + nout);
      sparsecreate(imax2(ssize, 1), nin + nout, ssize * (nin + nout), &sparsexy);
      for (i = 0; i < wcount; i++) {
         referenceg.xR[i] = 0.0;
      }
      referencee = 0.0;
      for (i = 0; i < ssize; i++) {
         for (j = 0; j < nin; j++) {
            x1.xR[j] = 2.0 * randommid();
            sparseset(&sparsexy, i, j, x1.xR[j]);
         }
         ae_v_move(xy.xyR[i], 1, x1.xR, 1, nin);
         if (mlpissoftmax(&network)) {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 0.0;
            }
            xy.xyR[i][nin] = (double)randominteger(nout);
            sparseset(&sparsexy, i, nin, xy.xyR[i][nin]);
            y1.xR[iround(xy.xyR[i][nin])] = 1.0;
         } else {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 2.0 * randommid();
               sparseset(&sparsexy, i, nin + j, y1.xR[j]);
            }
            ae_v_move(&xy.xyR[i][nin], 1, y1.xR, 1, nout);
         }
         mlpgrad(&network, &x1, &y1, &v, &grad2);
         referencee += v;
         ae_v_add(referenceg.xR, 1, grad2.xR, 1, wcount);
      }
      sparseconverttocrs(&sparsexy);
      e2 = mlperror(&network, &xy, ssize);
      Ok = Ok && RelNear(e2, referencee, etol, escale);
      e2 = mlperrorsparse(&network, &sparsexy, ssize);
      Ok = Ok && RelNear(e2, referencee, etol, escale);
      mlpgradbatch(&network, &xy, ssize, &e2, &grad2);
      Ok = Ok && RelNear(e2, referencee, etol, escale);
      Ok = Ok && testmlpbaseunit_vectordiff(&referenceg, &grad2, wcount, gscale) <= etol;
      mlpgradbatchsparse(&network, &sparsexy, ssize, &esp, &gradsp);
      Ok = Ok && RelNear(esp, referencee, etol, escale);
      Ok = Ok && testmlpbaseunit_vectordiff(&referenceg, &gradsp, wcount, gscale) <= etol;
   // Test MLPErrorSubset(), MLPGradBatchSubset(), MLPErrorSparseSubset(), MLPGradBatchSparseSubset()
   // for many-element dataset with different types of subsets:
   // * generate random dataset XY
   // * "reference" error/gradient are calculated with MLPGradBatch(),
   //   which was tested in previous section and is assumed to work correctly
   // * we perform tests for different subsets:
   //   * SubsetSize < 0 - subset is a full dataset
   //   * SubsetSize == 0 - subset is empty
   //   * SubsetSize > 0 - random subset
      ssize = sizemin + randominteger(sizemax - sizemin + 1);
      ae_matrix_set_length(&xy, imax2(ssize, 1), nin + nout);
      sparsecreate(imax2(ssize, 1), nin + nout, ssize * (nin + nout), &sparsexy);
      for (i = 0; i < ssize; i++) {
         for (j = 0; j < nin; j++) {
            x1.xR[j] = 2.0 * randommid();
            sparseset(&sparsexy, i, j, x1.xR[j]);
         }
         ae_v_move(xy.xyR[i], 1, x1.xR, 1, nin);
         if (mlpissoftmax(&network)) {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 0.0;
            }
            xy.xyR[i][nin] = (double)randominteger(nout);
            sparseset(&sparsexy, i, nin, xy.xyR[i][nin]);
            y1.xR[iround(xy.xyR[i][nin])] = 1.0;
         } else {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 2.0 * randommid();
               sparseset(&sparsexy, i, nin + j, y1.xR[j]);
            }
            ae_v_move(&xy.xyR[i][nin], 1, y1.xR, 1, nout);
         }
      }
      sparseconverttocrs(&sparsexy);
      if (ssize > 0) {
         subsetsize = 1 + randominteger(10);
         ae_matrix_set_length(&xy2, subsetsize, nin + nout);
         ae_vector_set_length(&idx, subsetsize);
         sparsecreate(subsetsize, nin + nout, subsetsize * (nin + nout), &sparsexy2);
         if (mlpissoftmax(&network)) {
            rowsize = nin + 1;
         } else {
            rowsize = nin + nout;
         }
         for (i = 0; i < subsetsize; i++) {
            k = randominteger(ssize);
            idx.xZ[i] = k;
            for (j = 0; j < rowsize; j++) {
               xy2.xyR[i][j] = xy.xyR[k][j];
               sparseset(&sparsexy2, i, j, sparseget(&sparsexy, k, j));
            }
         }
         sparseconverttocrs(&sparsexy2);
      } else {
         subsetsize = 0;
         ae_matrix_set_length(&xy2, 0, 0);
         ae_vector_set_length(&idx, 0);
         sparsecreate(1, nin + nout, 0, &sparsexy2);
         sparseconverttocrs(&sparsexy2);
      }
      mlpgradbatch(&network, &xy, ssize, &referencee, &referenceg);
      e2 = mlperrorsubset(&network, &xy, ssize, &idx, -1);
      esp = mlperrorsparsesubset(&network, &sparsexy, ssize, &idx, -1);
      Ok = Ok && RelNear(e2, referencee, etol, escale);
      Ok = Ok && RelNear(esp, referencee, etol, escale);
      mlpgradbatchsubset(&network, &xy, ssize, &idx, -1, &e2, &grad2);
      mlpgradbatchsparsesubset(&network, &sparsexy, ssize, &idx, -1, &esp, &gradsp);
      Ok = Ok && RelNear(e2, referencee, etol, escale);
      Ok = Ok && RelNear(esp, referencee, etol, escale);
      Ok = Ok && testmlpbaseunit_vectordiff(&referenceg, &grad2, wcount, gscale) <= etol;
      Ok = Ok && testmlpbaseunit_vectordiff(&referenceg, &gradsp, wcount, gscale) <= etol;
      mlpgradbatch(&network, &xy, 0, &referencee, &referenceg);
      e2 = mlperrorsubset(&network, &xy, ssize, &idx, 0);
      esp = mlperrorsparsesubset(&network, &sparsexy, ssize, &idx, 0);
      Ok = Ok && RelNear(e2, referencee, etol, escale);
      Ok = Ok && RelNear(esp, referencee, etol, escale);
      mlpgradbatchsubset(&network, &xy, ssize, &idx, 0, &e2, &grad2);
      mlpgradbatchsparsesubset(&network, &sparsexy, ssize, &idx, 0, &esp, &gradsp);
      Ok = Ok && RelNear(e2, referencee, etol, escale);
      Ok = Ok && RelNear(esp, referencee, etol, escale);
      Ok = Ok && testmlpbaseunit_vectordiff(&referenceg, &grad2, wcount, gscale) <= etol;
      Ok = Ok && testmlpbaseunit_vectordiff(&referenceg, &gradsp, wcount, gscale) <= etol;
      mlpgradbatch(&network, &xy2, subsetsize, &referencee, &referenceg);
      e2 = mlperrorsubset(&network, &xy, ssize, &idx, subsetsize);
      esp = mlperrorsparsesubset(&network, &sparsexy, ssize, &idx, subsetsize);
      Ok = Ok && RelNear(e2, referencee, etol, escale);
      Ok = Ok && RelNear(esp, referencee, etol, escale);
      mlpgradbatchsubset(&network, &xy, ssize, &idx, subsetsize, &e2, &grad2);
      mlpgradbatchsparsesubset(&network, &sparsexy, ssize, &idx, subsetsize, &esp, &gradsp);
      Ok = Ok && RelNear(e2, referencee, etol, escale);
      Ok = Ok && RelNear(esp, referencee, etol, escale);
      Ok = Ok && testmlpbaseunit_vectordiff(&referenceg, &grad2, wcount, gscale) <= etol;
      Ok = Ok && testmlpbaseunit_vectordiff(&referenceg, &gradsp, wcount, gscale) <= etol;
   // Test MLPGradNBatch() for many-element dataset:
   // * generate random dataset XY
   // * calculate "reference" error/gradient using MLPGrad(), which was tested in previous
   //   section and is assumed to work correctly
   // * test results returned by MLPGradNBatch against reference ones
      ssize = sizemin + randominteger(sizemax - sizemin + 1);
      ae_matrix_set_length(&xy, ssize, nin + nout);
      for (i = 0; i < wcount; i++) {
         referenceg.xR[i] = 0.0;
      }
      referencee = 0.0;
      for (i = 0; i < ssize; i++) {
         for (j = 0; j < nin; j++) {
            x1.xR[j] = 2.0 * randommid();
         }
         ae_v_move(xy.xyR[i], 1, x1.xR, 1, nin);
         if (mlpissoftmax(&network)) {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 0.0;
            }
            xy.xyR[i][nin] = (double)randominteger(nout);
            y1.xR[iround(xy.xyR[i][nin])] = 1.0;
         } else {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 2.0 * randommid();
            }
            ae_v_move(&xy.xyR[i][nin], 1, y1.xR, 1, nout);
         }
         mlpgradn(&network, &x1, &y1, &v, &grad2);
         referencee += v;
         ae_v_add(referenceg.xR, 1, grad2.xR, 1, wcount);
      }
      mlpgradnbatch(&network, &xy, ssize, &e2, &grad2);
      Ok = Ok && RelNear(e2, referencee, etol, escale);
      Ok = Ok && testmlpbaseunit_vectordiff(&referenceg, &grad2, wcount, gscale) <= etol;
   }
   ae_frame_leave();
   return Ok;
}

// Hessian functions test
static bool testmlpbaseunit_testhessian(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t hkind;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t wcount;
   double h;
   double etol;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ssize;
   double a1;
   double a2;
   double v;
   double e1;
   double e2;
   double wprev;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(h1, 0, 0, DT_REAL);
   NewMatrix(h2, 0, 0, DT_REAL);
   NewVector(grad1, 0, DT_REAL);
   NewVector(grad2, 0, DT_REAL);
   NewVector(grad3, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   ae_assert(passcount >= 2, "PassCount < 2!");
   a1 = 0.0;
   a2 = 0.0;
   if (nkind == 2) {
      a1 = 500.0 * randommid();
      a2 = randommid();
   }
   if (nkind == 3) {
      a1 = 500.0 * randommid();
      a2 = a1 + (2 * randominteger(2) - 1) * (0.1 + 0.9 * randomreal());
   }
   testmlpbaseunit_createnetwork(&network, nkind, a1, a2, nin, nhid1, nhid2, nout);
   mlpproperties(&network, &n1, &n2, &wcount);
   h = 0.0001;
   etol = 0.05;
// Initialize
   ae_vector_set_length(&x, nin);
   ae_vector_set_length(&x1, nin);
   ae_vector_set_length(&x2, nin);
   ae_vector_set_length(&y, nout);
   ae_vector_set_length(&y1, nout);
   ae_vector_set_length(&y2, nout);
   ae_vector_set_length(&grad1, wcount);
   ae_vector_set_length(&grad2, wcount);
   ae_vector_set_length(&grad3, wcount);
   ae_matrix_set_length(&h1, wcount, wcount);
   ae_matrix_set_length(&h2, wcount, wcount);
// Process
   for (pass = 1; pass <= passcount; pass++) {
      mlprandomizefull(&network);
   // Test hessian calculation .
   // E1 contains total error (calculated using MLPGrad/MLPGradN)
   // Grad1 contains total gradient (calculated using MLPGrad/MLPGradN)
   // H1 contains Hessian calculated using differences of gradients
   //
   // E2, Grad2 and H2 contains corresponing values calculated using MLPHessianBatch/MLPHessianNBatch
      for (hkind = 0; hkind <= 1; hkind++) {
         ssize = 1 + randominteger(10);
         ae_matrix_set_length(&xy, ssize, nin + nout);
         for (i = 0; i < wcount; i++) {
            grad1.xR[i] = 0.0;
         }
         for (i = 0; i < wcount; i++) {
            for (j = 0; j < wcount; j++) {
               h1.xyR[i][j] = 0.0;
            }
         }
         e1 = 0.0;
         for (i = 0; i < ssize; i++) {
         // X, Y
            for (j = 0; j < nin; j++) {
               x1.xR[j] = 2.0 * randommid();
            }
            ae_v_move(xy.xyR[i], 1, x1.xR, 1, nin);
            if (mlpissoftmax(&network)) {
               for (j = 0; j < nout; j++) {
                  y1.xR[j] = 0.0;
               }
               xy.xyR[i][nin] = (double)randominteger(nout);
               y1.xR[iround(xy.xyR[i][nin])] = 1.0;
            } else {
               for (j = 0; j < nout; j++) {
                  y1.xR[j] = 2.0 * randommid();
               }
               ae_v_move(&xy.xyR[i][nin], 1, y1.xR, 1, nout);
            }
         // E1, Grad1
            if (hkind == 0) {
               mlpgrad(&network, &x1, &y1, &v, &grad2);
            } else {
               mlpgradn(&network, &x1, &y1, &v, &grad2);
            }
            e1 += v;
            ae_v_add(grad1.xR, 1, grad2.xR, 1, wcount);
         // H1
            for (j = 0; j < wcount; j++) {
               wprev = network.weights.xR[j];
               network.weights.xR[j] = wprev - 2 * h;
               if (hkind == 0) {
                  mlpgrad(&network, &x1, &y1, &v, &grad2);
               } else {
                  mlpgradn(&network, &x1, &y1, &v, &grad2);
               }
               network.weights.xR[j] = wprev - h;
               if (hkind == 0) {
                  mlpgrad(&network, &x1, &y1, &v, &grad3);
               } else {
                  mlpgradn(&network, &x1, &y1, &v, &grad3);
               }
               ae_v_subd(grad2.xR, 1, grad3.xR, 1, wcount, 8);
               network.weights.xR[j] = wprev + h;
               if (hkind == 0) {
                  mlpgrad(&network, &x1, &y1, &v, &grad3);
               } else {
                  mlpgradn(&network, &x1, &y1, &v, &grad3);
               }
               ae_v_addd(grad2.xR, 1, grad3.xR, 1, wcount, 8);
               network.weights.xR[j] = wprev + 2 * h;
               if (hkind == 0) {
                  mlpgrad(&network, &x1, &y1, &v, &grad3);
               } else {
                  mlpgradn(&network, &x1, &y1, &v, &grad3);
               }
               ae_v_sub(grad2.xR, 1, grad3.xR, 1, wcount);
               v = 1 / (12 * h);
               ae_v_addd(h1.xyR[j], 1, grad2.xR, 1, wcount, v);
               network.weights.xR[j] = wprev;
            }
         }
         if (hkind == 0) {
            mlphessianbatch(&network, &xy, ssize, &e2, &grad2, &h2);
         } else {
            mlphessiannbatch(&network, &xy, ssize, &e2, &grad2, &h2);
         }
         Ok = Ok && NearAtR(e1, e2, e1 * etol);
         for (i = 0; i < wcount; i++) {
            if (!SmallAtR(grad1.xR[i], 1.0E-2)) {
               Ok = Ok && NearAtR(grad2.xR[i], grad1.xR[i], fabs(grad1.xR[i]) * etol);
            } else {
               Ok = Ok && NearAtR(grad2.xR[i], grad1.xR[i], etol);
            }
         }
         for (i = 0; i < wcount; i++) {
            for (j = 0; j < wcount; j++) {
               if (!SmallAtR(h1.xyR[i][j], 5.0E-2)) {
                  Ok = Ok && NearAtR(h1.xyR[i][j], h2.xyR[i][j], fabs(h1.xyR[i][j]) * etol);
               } else {
                  Ok = Ok && NearAtR(h2.xyR[i][j], h1.xyR[i][j], etol);
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Error functions (other than MLPError and MLPErrorN) test.
//
// Network of type NKind is created, with  NIn  inputs,  NHid1*NHid2   hidden
// layers (one layer if NHid2 == 0), NOut outputs. PassCount  random  passes  is
// performed. Dataset has random size in [SizeMin,SizeMax].
static bool testmlpbaseunit_testerr(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t passcount, ae_int_t sizemin, ae_int_t sizemax) {
   ae_frame _frame_block;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t wcount;
   double etol;
   double escale;
   double a1;
   double a2;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t ssize;
   ae_int_t subsetsize;
   double refrmserror;
   double refclserror;
   double refrelclserror;
   double refavgce;
   double refavgerror;
   double refavgrelerror;
   ae_int_t avgrelcnt;
   ae_int_t nnmax;
   ae_int_t dsmax;
   double relclstolerance;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewObj(sparsematrix, sparsexy);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(idx, 0, DT_INT);
   NewVector(dummy, 0, DT_INT);
   NewObj(modelerrors, allerrors);
   a1 = 0.0;
   a2 = 0.0;
   if (nkind == 2) {
      a1 = 500.0 * randommid();
      a2 = randommid();
   }
   if (nkind == 3) {
      a1 = 500.0 * randommid();
      a2 = a1 + (2 * randominteger(2) - 1) * (0.1 + 0.9 * randomreal());
   }
   testmlpbaseunit_createnetwork(&network, nkind, a1, a2, nin, nhid1, nhid2, nout);
   mlpproperties(&network, &n1, &n2, &wcount);
   etol = 1.0E-4;
   escale = 1.0E-2;
// Initialize
   ae_vector_set_length(&x1, nin);
   ae_vector_set_length(&y, nout);
   ae_vector_set_length(&y1, nout);
// Process
   for (pass = 1; pass <= passcount; pass++) {
   // Randomize network, then re-randomaze weights manually.
   //
   // NOTE: weights magnitude is chosen to be small, about 0.1,
   //       which allows us to avoid oversaturated network.
   //       In 10% of cases we use zero weights.
      mlprandomizefull(&network);
      if (randombool(0.1)) {
         for (i = 0; i < wcount; i++) {
            network.weights.xR[i] = 0.0;
         }
      } else {
         for (i = 0; i < wcount; i++) {
            network.weights.xR[i] = 0.1 * randommid();
         }
      }
   // Generate random dataset.
   // Calculate reference errors.
   //
   // NOTE: about 10% of tests are performed with zero SSize
      ssize = sizemin + randominteger(sizemax - sizemin + 1);
      if (mlpissoftmax(&network)) {
         ae_matrix_set_length(&xy, imax2(ssize, 1), nin + 1);
         sparsecreate(imax2(ssize, 1), nin + 1, 0, &sparsexy);
      } else {
         ae_matrix_set_length(&xy, imax2(ssize, 1), nin + nout);
         sparsecreate(imax2(ssize, 1), nin + nout, 0, &sparsexy);
      }
      refrmserror = 0.0;
      refclserror = 0.0;
      refavgce = 0.0;
      refavgerror = 0.0;
      refavgrelerror = 0.0;
      avgrelcnt = 0;
      for (i = 0; i < ssize; i++) {
      // Fill I-th row
         for (j = 0; j < nin; j++) {
            x1.xR[j] = 2.0 * randommid();
            sparseset(&sparsexy, i, j, x1.xR[j]);
         }
         ae_v_move(xy.xyR[i], 1, x1.xR, 1, nin);
         if (mlpissoftmax(&network)) {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 0.0;
            }
            xy.xyR[i][nin] = (double)randominteger(nout);
            sparseset(&sparsexy, i, nin, xy.xyR[i][nin]);
            y1.xR[iround(xy.xyR[i][nin])] = 1.0;
         } else {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 2.0 * randommid();
               sparseset(&sparsexy, i, nin + j, y1.xR[j]);
            }
            ae_v_move(&xy.xyR[i][nin], 1, y1.xR, 1, nout);
         }
      // Process
         mlpprocess(&network, &x1, &y);
      // Update reference errors
         nnmax = 0;
         if (mlpissoftmax(&network)) {
            if (y.xR[iround(xy.xyR[i][nin])] > 0.0) {
               refavgce += log(1 / y.xR[iround(xy.xyR[i][nin])]);
            } else {
               refavgce += log(maxrealnumber);
            }
         }
         if (mlpissoftmax(&network)) {
            dsmax = iround(xy.xyR[i][nin]);
         } else {
            dsmax = 0;
         }
         for (j = 0; j < nout; j++) {
            refrmserror += sqr(y.xR[j] - y1.xR[j]);
            refavgerror += fabs(y.xR[j] - y1.xR[j]);
            if (y1.xR[j] != 0.0) {
               refavgrelerror += fabs(y.xR[j] - y1.xR[j]) / fabs(y1.xR[j]);
               avgrelcnt++;
            }
            if (y.xR[j] > y.xR[nnmax]) {
               nnmax = j;
            }
            if (!mlpissoftmax(&network) && y1.xR[j] > y1.xR[dsmax]) {
               dsmax = j;
            }
         }
         if (nnmax != dsmax) {
            refclserror++;
         }
      }
      sparseconverttocrs(&sparsexy);
      if (ssize > 0) {
         refrmserror = sqrt(refrmserror / (ssize * nout));
         refavgerror /= ssize * nout;
         refrelclserror = refclserror / ssize;
         refavgce /= ssize * log(2.0);
      } else {
         refrelclserror = 0.0;
      }
      if (avgrelcnt > 0) {
         refavgrelerror /= avgrelcnt;
      }
   // Test "continuous" errors on full dataset
      Ok = Ok && RelNear(mlprmserror(&network, &xy, ssize), refrmserror, etol, escale);
      Ok = Ok && RelNear(mlpavgce(&network, &xy, ssize), refavgce, etol, escale);
      Ok = Ok && RelNear(mlpavgerror(&network, &xy, ssize), refavgerror, etol, escale);
      Ok = Ok && RelNear(mlpavgrelerror(&network, &xy, ssize), refavgrelerror, etol, escale);
      Ok = Ok && RelNear(mlprmserrorsparse(&network, &sparsexy, ssize), refrmserror, etol, escale);
      Ok = Ok && RelNear(mlpavgcesparse(&network, &sparsexy, ssize), refavgce, etol, escale);
      Ok = Ok && RelNear(mlpavgerrorsparse(&network, &sparsexy, ssize), refavgerror, etol, escale);
      Ok = Ok && RelNear(mlpavgrelerrorsparse(&network, &sparsexy, ssize), refavgrelerror, etol, escale);
      mlpallerrorssubset(&network, &xy, ssize, &dummy, -1, &allerrors);
      Ok = Ok && RelNear(allerrors.avgce, refavgce, etol, escale);
      Ok = Ok && RelNear(allerrors.rmserror, refrmserror, etol, escale);
      Ok = Ok && RelNear(allerrors.avgerror, refavgerror, etol, escale);
      Ok = Ok && RelNear(allerrors.avgrelerror, refavgrelerror, etol, escale);
      mlpallerrorssparsesubset(&network, &sparsexy, ssize, &dummy, -1, &allerrors);
      Ok = Ok && RelNear(allerrors.avgce, refavgce, etol, escale);
      Ok = Ok && RelNear(allerrors.rmserror, refrmserror, etol, escale);
      Ok = Ok && RelNear(allerrors.avgerror, refavgerror, etol, escale);
      Ok = Ok && RelNear(allerrors.avgrelerror, refavgrelerror, etol, escale);
   // Test errors on dataset given by subset.
   // We perform only limited test for RMS error, assuming that either all errors
   // are calculated correctly (subject to subset given by Idx) - or none of them.
      if (ssize > 0) {
         subsetsize = randominteger(10);
      } else {
         subsetsize = 0;
      }
      ae_vector_set_length(&idx, subsetsize);
      refrmserror = 0.0;
      for (i = 0; i < subsetsize; i++) {
         k = randominteger(ssize);
         idx.xZ[i] = k;
         ae_v_move(x1.xR, 1, xy.xyR[k], 1, nin);
         if (mlpissoftmax(&network)) {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 0.0;
            }
            y1.xR[iround(xy.xyR[k][nin])] = 1.0;
         } else {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = xy.xyR[k][nin + j];
            }
         }
         mlpprocess(&network, &x1, &y);
         for (j = 0; j < nout; j++) {
            refrmserror += sqr(y.xR[j] - y1.xR[j]);
         }
      }
      if (subsetsize > 0) {
         refrmserror = sqrt(refrmserror / (subsetsize * nout));
      }
      mlpallerrorssubset(&network, &xy, ssize, &idx, subsetsize, &allerrors);
      Ok = Ok && RelNear(allerrors.rmserror, refrmserror, etol, escale);
      mlpallerrorssparsesubset(&network, &sparsexy, ssize, &idx, subsetsize, &allerrors);
      Ok = Ok && RelNear(allerrors.rmserror, refrmserror, etol, escale);
   // Test "discontinuous" error function.
   // Even slight changes in the network output may force these functions
   // to change by 1. So, we test them with relaxed criteria, corresponding to
   // difference in classification of two samples.
      if (ssize > 0) {
         relclstolerance = 2.5 / ssize;
         Ok = Ok && NearAtR(mlpclserror(&network, &xy, ssize), refclserror, ssize * relclstolerance);
         Ok = Ok && NearAtR(mlprelclserror(&network, &xy, ssize), refrelclserror, relclstolerance);
         Ok = Ok && NearAtR(mlprelclserrorsparse(&network, &sparsexy, ssize), refrelclserror, relclstolerance);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Special tests
static bool testmlpbaseunit_spectests() {
   ae_frame _frame_block;
   double f;
   ae_int_t i;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
// Special test for overflow in tanh():
// * create 1x1x1 linear network
// * create dataset with 1 item: [x, y] = [0, 1]
// * set network weights to [10000000, 10000000, 10000000, 10000000]
// * check that error function is finite
// * check that gradient is finite
   mlpcreate1(1, 1, 1, &net);
   ae_matrix_set_length(&xy, 1, 2);
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = 1.0;
   for (i = 0; i < mlpgetweightscount(&net); i++) {
      net.weights.xR[i] = 10000000.0;
   }
   mlpgradbatch(&net, &xy, 1, &f, &g);
   Ok = Ok && isfinite(f);
   Ok = Ok && isfinite(mlperror(&net, &xy, 1));
   for (i = 0; i < mlpgetweightscount(&net); i++) {
      Ok = Ok && isfinite(g.xR[i]);
   }
// Special test for overflow in SOFTMAX layer:
// * create 1x1x2 classifier network
// * create dataset with 1 item: [x, y] = [0, 1]
// * set network weights to [10000000, 10000000, 10000000, 10000000]
// * check that error function is finite
// * check that gradient is finite
   mlpcreatec1(1, 1, 2, &net);
   ae_matrix_set_length(&xy, 1, 2);
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = 1.0;
   for (i = 0; i < mlpgetweightscount(&net); i++) {
      net.weights.xR[i] = 10000000.0;
   }
   mlpgradbatch(&net, &xy, 1, &f, &g);
   Ok = Ok && isfinite(f);
   Ok = Ok && isfinite(mlperror(&net, &xy, 1));
   for (i = 0; i < mlpgetweightscount(&net); i++) {
      Ok = Ok && isfinite(g.xR[i]);
   }
   ae_frame_leave();
   return Ok;
}

// The function test functions MLPGradBatchMasked and MLPGradBatchSparseMasked.
static bool testmlpbaseunit_testmlpgbsubset() {
   ae_frame _frame_block;
   double e1;
   double e2;
   ae_int_t nin;
   ae_int_t nout;
   ae_int_t w;
   ae_int_t wcount;
   ae_int_t nhid1;
   ae_int_t nhid2;
   ae_int_t nkind;
   double a1;
   double a2;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t ssize;
   ae_int_t maxssize;
   ae_int_t sbsize;
   ae_int_t nvar;
   ae_int_t variant;
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(parta, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewObj(sparsematrix, partsa);
   NewVector(idx, 0, DT_INT);
   NewVector(grad1, 0, DT_REAL);
   NewVector(grad2, 0, DT_REAL);
// Variant:
// * 1 - there are all rows;
// * 2 - there are no one rows;
// * 3 - there are some random rows.
   nvar = 3;
   maxssize = 96;
   for (ssize = 0; ssize <= maxssize; ssize++) {
      ae_vector_set_length(&idx, ssize);
      nkind = randominteger(4);
      a1 = 0.0;
      a2 = 0.0;
      if (nkind == 2) {
         a1 = 500.0 * randommid();
         a2 = randommid();
      }
      if (nkind == 3) {
         a1 = 500.0 * randommid();
         a2 = a1 + (2 * randominteger(2) - 1) * (0.1 + 0.9 * randomreal());
      }
      nin = randominteger(20) + 1;
      nhid1 = randominteger(5);
      if (nhid1 == 0) {
         nhid2 = 0;
      } else {
         nhid2 = randominteger(5);
      }
      nout = randominteger(20) + 2;
      testmlpbaseunit_createnetwork(&net, nkind, a1, a2, nin, nhid1, nhid2, nout);
      mlpproperties(&net, &n1, &n2, &wcount);
      if (mlpissoftmax(&net)) {
         w = nin + 1;
         if (ssize > 0) {
            ae_matrix_set_length(&a, ssize, w);
            sparsecreate(ssize, w, ssize * w, &sa);
         } else {
            ae_matrix_set_length(&a, 0, 0);
            sparsecreate(1, 1, 0, &sa);
         }
         for (i = 0; i < ssize; i++) {
            for (j = 0; j < w; j++) {
               a.xyR[i][j] = randommid();
               sparseset(&sa, i, j, a.xyR[i][j]);
            }
         }
         for (i = 0; i < ssize; i++) {
            a.xyR[i][nin] = (double)randominteger(nout);
            sparseset(&sa, i, nin, a.xyR[i][nin]);
         }
      } else {
         w = nin + nout;
         if (ssize > 0) {
            ae_matrix_set_length(&a, ssize, w);
            sparsecreate(ssize, w, ssize * w, &sa);
         } else {
            ae_matrix_set_length(&a, 0, 0);
            sparsecreate(1, 1, 0, &sa);
         }
         for (i = 0; i < ssize; i++) {
            for (j = 0; j < w; j++) {
               a.xyR[i][j] = randommid();
               sparseset(&sa, i, j, a.xyR[i][j]);
            }
         }
      }
      sparseconverttocrs(&sa);
      for (variant = 1; variant <= nvar; variant++) {
         sbsize = -1;
         if (variant == 1) {
            sbsize = ssize;
            for (i = 0; i < sbsize; i++) {
               idx.xZ[i] = i;
            }
         }
         if (variant == 2) {
            sbsize = 0;
         }
         if (variant == 3) {
            if (ssize == 0) {
               sbsize = 0;
            } else {
               sbsize = randominteger(ssize);
            }
            for (i = 0; i < sbsize; i++) {
               idx.xZ[i] = randominteger(ssize);
            }
         }
         ae_assert(sbsize >= 0, "mlpbase test: integrity check failed");
         if (sbsize != 0) {
            ae_matrix_set_length(&parta, sbsize, w);
            sparsecreate(sbsize, w, sbsize * w, &partsa);
         } else {
            ae_matrix_set_length(&parta, 0, 0);
            sparsecreate(1, 1, 0, &partsa);
         }
         for (i = 0; i < sbsize; i++) {
            ae_v_move(parta.xyR[i], 1, a.xyR[idx.xZ[i]], 1, w);
            for (j = 0; j < w; j++) {
               sparseset(&partsa, i, j, parta.xyR[i][j]);
            }
         }
         sparseconverttocrs(&partsa);
         mlpgradbatch(&net, &parta, sbsize, &e1, &grad1);
         mlpgradbatchsubset(&net, &a, ssize, &idx, sbsize, &e2, &grad2);
      // Test for dense matrix
         if (!NearAtR(e1, e2, 1.0E-6)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < wcount; i++) {
            if (!NearAtR(grad1.xR[i], grad2.xR[i], 1.0E-6)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      // Test for sparse matrix
         mlpgradbatchsparse(&net, &partsa, sbsize, &e1, &grad1);
         mlpgradbatchsparsesubset(&net, &sa, ssize, &idx, sbsize, &e2, &grad2);
         if (!NearAtR(e1, e2, 1.0E-6)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < wcount; i++) {
            if (!NearAtR(grad1.xR[i], grad2.xR[i], 1.0E-6)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

bool testmlpbase() {
   ae_frame _frame_block;
   bool Ok;
   ae_int_t passcount;
   ae_int_t maxn;
   ae_int_t maxhid;
   ae_int_t sizemin;
   ae_int_t sizemax;
   ae_int_t nf;
   ae_int_t nl;
   ae_int_t nhid1;
   ae_int_t nhid2;
   ae_int_t nkind;
   bool infOk;
   bool procOk;
   bool gradOk;
   bool hessOk;
   bool errOk;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewObj(multilayerperceptron, network2);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(valxy, 0, 0, DT_REAL);
   Ok = true;
   infOk = true;
   procOk = true;
   gradOk = true;
   hessOk = true;
   errOk = true;
   passcount = 5;
   maxn = 3;
   maxhid = 3;
// Special tests
   gradOk = gradOk && testmlpbaseunit_spectests();
// General multilayer network tests.
// These tests are performed with small dataset, whose size is in [0,10].
// We test correctness of functions on small sets, but do not test code
// which splits large dataset into smaller chunks.
   sizemin = 0;
   sizemax = 10;
   for (nf = 1; nf <= maxn; nf++) {
      for (nl = 1; nl <= maxn; nl++) {
         for (nhid1 = 0; nhid1 <= maxhid; nhid1++) {
            for (nhid2 = 0; nhid2 <= maxhid; nhid2++) {
               for (nkind = 0; nkind <= 3; nkind++) {
               // Skip meaningless parameters combinations
                  if (nkind == 1 && nl < 2) {
                     continue;
                  }
                  if (nhid1 == 0 && nhid2 != 0) {
                     continue;
                  }
               // Tests
                  infOk = infOk && testmlpbaseunit_testinformational(nkind, nf, nhid1, nhid2, nl, passcount);
                  procOk = procOk && testmlpbaseunit_testprocessing(nkind, nf, nhid1, nhid2, nl, passcount);
                  gradOk = gradOk && testmlpbaseunit_testgradient(nkind, nf, nhid1, nhid2, nl, passcount, sizemin, sizemax);
                  hessOk = hessOk && testmlpbaseunit_testhessian(nkind, nf, nhid1, nhid2, nl, passcount);
                  errOk = errOk && testmlpbaseunit_testerr(nkind, nf, nhid1, nhid2, nl, passcount, sizemin, sizemax);
               }
            }
         }
      }
   }
// Special tests on large datasets: test ability to correctly split
// work into smaller chunks.
   nf = 2;
   nhid1 = 20;
   nhid2 = 20;
   nl = 2;
   sizemin = 50000;
   sizemax = 50000;
   errOk = errOk && testmlpbaseunit_testerr(0, nf, nhid1, nhid2, nl, 1, sizemin, sizemax);
   gradOk = gradOk && testmlpbaseunit_testgradient(0, nf, nhid1, nhid2, nl, 1, sizemin, sizemax);
// Test for MLPGradBatch____Subset()
   gradOk = gradOk && testmlpbaseunit_testmlpgbsubset();
// The final report.
   Ok = infOk && procOk && gradOk && hessOk && errOk;
   if (!Ok || !silent) {
      printf("MLP Tests\n");
      printf("Informational Functions:                  %s\n", infOk? "Ok": "Failed");
      printf("Basic Processing:                         %s\n", procOk? "Ok": "Failed");
      printf("Gradient Calculation:                     %s\n", gradOk? "Ok": "Failed");
      printf("Hessian Calculation:                      %s\n", hessOk? "Ok": "Failed");
      printf("Error Functions:                          %s\n", errOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === mlpe testing unit ===
// Network creation
static void testmlpeunit_createensemble(mlpensemble *ensemble, ae_int_t nkind, double a1, double a2, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t ec) {
   ae_assert(nin > 0 && nhid1 >= 0 && nhid2 >= 0 && nout > 0, "CreateNetwork error");
   ae_assert(nhid1 != 0 || nhid2 == 0, "CreateNetwork error");
   ae_assert(nkind != 1 || nout >= 2, "CreateNetwork error");
   if (nhid1 == 0) {
   // No hidden layers
      if (nkind == 0) {
         mlpecreate0(nin, nout, ec, ensemble);
      } else {
         if (nkind == 1) {
            mlpecreatec0(nin, nout, ec, ensemble);
         } else {
            if (nkind == 2) {
               mlpecreateb0(nin, nout, a1, a2, ec, ensemble);
            } else {
               if (nkind == 3) {
                  mlpecreater0(nin, nout, a1, a2, ec, ensemble);
               }
            }
         }
      }
      return;
   }
   if (nhid2 == 0) {
   // One hidden layer
      if (nkind == 0) {
         mlpecreate1(nin, nhid1, nout, ec, ensemble);
      } else {
         if (nkind == 1) {
            mlpecreatec1(nin, nhid1, nout, ec, ensemble);
         } else {
            if (nkind == 2) {
               mlpecreateb1(nin, nhid1, nout, a1, a2, ec, ensemble);
            } else {
               if (nkind == 3) {
                  mlpecreater1(nin, nhid1, nout, a1, a2, ec, ensemble);
               }
            }
         }
      }
      return;
   }
// Two hidden layers
   if (nkind == 0) {
      mlpecreate2(nin, nhid1, nhid2, nout, ec, ensemble);
   } else {
      if (nkind == 1) {
         mlpecreatec2(nin, nhid1, nhid2, nout, ec, ensemble);
      } else {
         if (nkind == 2) {
            mlpecreateb2(nin, nhid1, nhid2, nout, a1, a2, ec, ensemble);
         } else {
            if (nkind == 3) {
               mlpecreater2(nin, nhid1, nhid2, nout, a1, a2, ec, ensemble);
            }
         }
      }
   }
}

// Unsets network (initialize it to smallest network possible
static void testmlpeunit_unsetensemble(mlpensemble *ensemble) {
   mlpecreate0(1, 1, 1, ensemble);
}

// Iformational functions test
static bool testmlpeunit_testinformational(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t ec, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t n1;
   ae_int_t n2;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(mlpensemble, ensemble);
   testmlpeunit_createensemble(&ensemble, nkind, -1.0, 1.0, nin, nhid1, nhid2, nout, ec);
   mlpeproperties(&ensemble, &n1, &n2);
   Ok = Ok && n1 == nin && n2 == nout;
   ae_frame_leave();
   return Ok;
}

// Processing functions test
static bool testmlpeunit_testprocessing(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t ec, ae_int_t passcount) {
   ae_frame _frame_block;
   double a1;
   double a2;
   ae_int_t pass;
   ae_int_t rkind;
   ae_int_t i;
   bool allsame;
   double v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(mlpensemble, ensemble);
   NewObj(mlpensemble, ensemble2);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(ra, 0, DT_REAL);
   NewVector(ra2, 0, DT_REAL);
// Prepare network
   a1 = 0.0;
   a2 = 0.0;
   if (nkind == 2) {
      a1 = 500.0 * randommid();
      a2 = randommid();
   }
   if (nkind == 3) {
      a1 = 500.0 * randommid();
      a2 = a1 + (2 * randominteger(2) - 1) * (0.1 + 0.9 * randomreal());
   }
// Initialize arrays
   ae_vector_set_length(&x1, nin);
   ae_vector_set_length(&x2, nin);
   ae_vector_set_length(&y1, nout);
   ae_vector_set_length(&y2, nout);
// Main cycle:
// * Pass is a number of repeated test
// * RKind is a "replication kind":
//   * RKind == 0 means that we work with original ensemble
//   * RKind == 1 means that we work with replica created with MLPECopy()
//   * RKind == 2 means that we work with replica created with serialization/unserialization
   for (pass = 1; pass <= passcount; pass++) {
      for (rkind = 0; rkind <= 2; rkind++) {
      // Create network, pass through replication in order to test that replicated network works correctly.
         testmlpeunit_createensemble(&ensemble, nkind, a1, a2, nin, nhid1, nhid2, nout, ec);
         if (rkind == 1) {
            mlpecopy(&ensemble, &ensemble2);
            testmlpeunit_unsetensemble(&ensemble);
            mlpecopy(&ensemble2, &ensemble);
            testmlpeunit_unsetensemble(&ensemble2);
         }
         if (rkind == 2) {
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               mlpealloc(&_local_serializer, &ensemble);
               ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpeserialize(&_local_serializer, &ensemble);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpeunserialize(&_local_serializer, &ensemble2);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
            testmlpeunit_unsetensemble(&ensemble);
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               mlpealloc(&_local_serializer, &ensemble2);
               ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpeserialize(&_local_serializer, &ensemble2);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpeunserialize(&_local_serializer, &ensemble);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
            testmlpeunit_unsetensemble(&ensemble2);
         }
      // Same inputs leads to same outputs
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = x1.xR[i];
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = randommid();
         }
         mlpeprocess(&ensemble, &x1, &y1);
         mlpeprocess(&ensemble, &x2, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         Ok = Ok && allsame;
      // Same inputs on original network leads to same outputs
      // on copy created using MLPCopy
         testmlpeunit_unsetensemble(&ensemble2);
         mlpecopy(&ensemble, &ensemble2);
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = x1.xR[i];
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = randommid();
         }
         mlpeprocess(&ensemble, &x1, &y1);
         mlpeprocess(&ensemble2, &x2, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         Ok = Ok && allsame;
      // Same inputs on original network leads to same outputs
      // on copy created using MLPSerialize
         {
         // This code passes data structure through serializers
         // (serializes it to string and loads back)
            ae_frame _local_frame_block;
            ae_frame_make(&_local_frame_block);
            NewSerializer(_local_serializer);
            ae_serializer_alloc_start(&_local_serializer);
            mlpealloc(&_local_serializer, &ensemble);
            ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
            NewBlock(_local_dynamic_block, _local_ssize + 1);
            ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            mlpeserialize(&_local_serializer, &ensemble);
            ae_serializer_stop(&_local_serializer);
            ae_serializer_init(&_local_serializer);
            ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            mlpeunserialize(&_local_serializer, &ensemble2);
            ae_serializer_stop(&_local_serializer);
            ae_frame_leave();
         }
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = x1.xR[i];
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = randommid();
         }
         mlpeprocess(&ensemble, &x1, &y1);
         mlpeprocess(&ensemble2, &x2, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         Ok = Ok && allsame;
      // Different inputs leads to different outputs (non-zero network)
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = randommid();
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = y1.xR[i];
         }
         mlpeprocess(&ensemble, &x1, &y1);
         mlpeprocess(&ensemble, &x2, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         Ok = Ok && !allsame;
      // Randomization changes outputs (when inputs are unchanged, non-zero network)
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = randommid();
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = y1.xR[i];
         }
         mlpecopy(&ensemble, &ensemble2);
         mlperandomize(&ensemble2);
         mlpeprocess(&ensemble, &x1, &y1);
         mlpeprocess(&ensemble2, &x1, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         Ok = Ok && !allsame;
      // Normalization properties
         if (nkind == 1) {
         // Classifier network outputs are normalized
            for (i = 0; i < nin; i++) {
               x1.xR[i] = randommid();
            }
            mlpeprocess(&ensemble, &x1, &y1);
            v = 0.0;
            for (i = 0; i < nout; i++) {
               v += y1.xR[i];
               Ok = Ok && y1.xR[i] >= 0.0;
            }
            Ok = Ok && NearAtR(v, 1, 1000.0 * machineepsilon);
         }
         if (nkind == 2) {
         // B-type network outputs are bounded from above/below
            for (i = 0; i < nin; i++) {
               x1.xR[i] = randommid();
            }
            mlpeprocess(&ensemble, &x1, &y1);
            for (i = 0; i < nout; i++) {
               if (a2 >= 0.0) {
                  Ok = Ok && y1.xR[i] >= a1;
               } else {
                  Ok = Ok && y1.xR[i] <= a1;
               }
            }
         }
         if (nkind == 3) {
         // R-type network outputs are within [A1,A2] (or [A2,A1])
            for (i = 0; i < nin; i++) {
               x1.xR[i] = randommid();
            }
            mlpeprocess(&ensemble, &x1, &y1);
            for (i = 0; i < nout; i++) {
               Ok = Ok && y1.xR[i] >= rmin2(a1, a2) && y1.xR[i] <= rmax2(a1, a2);
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Error functions
//
// Ensemble of type NKind is created, with  NIn  inputs,  NHid1*NHid2  hidden
// layers (one layer if NHid2 == 0), NOut outputs. PassCount  random  passes  is
// performed. Dataset has random size in [SizeMin,SizeMax].
static bool testmlpeunit_testerr(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t ec, ae_int_t passcount, ae_int_t sizemin, ae_int_t sizemax) {
   ae_frame _frame_block;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t wcount;
   double etol;
   double escale;
   double a1;
   double a2;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ssize;
   double refrmserror;
   double refclserror;
   double refavgce;
   double refavgerror;
   double refavgrelerror;
   ae_int_t avgrelcnt;
   ae_int_t nnmax;
   ae_int_t dsmax;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(mlpensemble, ensemble);
   NewObj(sparsematrix, sparsexy);
   NewObj(sparsematrix, sparsexy2);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(idx, 0, DT_INT);
   NewVector(dummy, 0, DT_INT);
   NewObj(modelerrors, allerrors);
   a1 = 0.0;
   a2 = 0.0;
   if (nkind == 2) {
      a1 = 500.0 * randommid();
      a2 = randommid();
   }
   if (nkind == 3) {
      a1 = 500.0 * randommid();
      a2 = a1 + (2 * randominteger(2) - 1) * (0.1 + 0.9 * randomreal());
   }
   testmlpeunit_createensemble(&ensemble, nkind, a1, a2, nin, nhid1, nhid2, nout, ec);
   mlpproperties(&ensemble.network, &n1, &n2, &wcount);
   etol = 1.0E-4;
   escale = 1.0E-2;
// Initialize
   ae_vector_set_length(&x1, nin);
   ae_vector_set_length(&y, nout);
   ae_vector_set_length(&y1, nout);
// Process
   for (pass = 1; pass <= passcount; pass++) {
   // Randomize Ensemble, then re-randomaze weights manually.
   //
   // NOTE: weights magnitude is chosen to be small, about 0.1,
   //       which allows us to avoid oversaturated Ensemble.
   //       In 10% of cases we use zero weights.
      mlperandomize(&ensemble);
      if (randombool(0.1)) {
         for (i = 0; i < wcount * ec; i++) {
            ensemble.weights.xR[i] = 0.0;
         }
      } else {
         for (i = 0; i < wcount * ec; i++) {
            ensemble.weights.xR[i] = 0.1 * randommid();
         }
      }
   // Generate random dataset.
   // Calculate reference errors.
   //
   // NOTE: about 10% of tests are performed with zero SSize
      ssize = sizemin + randominteger(sizemax - sizemin + 1);
      if (mlpeissoftmax(&ensemble)) {
         ae_matrix_set_length(&xy, imax2(ssize, 1), nin + 1);
         sparsecreate(imax2(ssize, 1), nin + 1, 0, &sparsexy);
      } else {
         ae_matrix_set_length(&xy, imax2(ssize, 1), nin + nout);
         sparsecreate(imax2(ssize, 1), nin + nout, 0, &sparsexy);
      }
      refrmserror = 0.0;
      refclserror = 0.0;
      refavgce = 0.0;
      refavgerror = 0.0;
      refavgrelerror = 0.0;
      avgrelcnt = 0;
      for (i = 0; i < ssize; i++) {
      // Fill I-th row
         for (j = 0; j < nin; j++) {
            x1.xR[j] = 2.0 * randommid();
            sparseset(&sparsexy, i, j, x1.xR[j]);
         }
         ae_v_move(xy.xyR[i], 1, x1.xR, 1, nin);
         if (mlpeissoftmax(&ensemble)) {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 0.0;
            }
            xy.xyR[i][nin] = (double)randominteger(nout);
            sparseset(&sparsexy, i, nin, xy.xyR[i][nin]);
            y1.xR[iround(xy.xyR[i][nin])] = 1.0;
         } else {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 2.0 * randommid();
               sparseset(&sparsexy, i, nin + j, y1.xR[j]);
            }
            ae_v_move(&xy.xyR[i][nin], 1, y1.xR, 1, nout);
         }
      // Process
         mlpeprocess(&ensemble, &x1, &y);
      // Update reference errors
         nnmax = 0;
         if (mlpeissoftmax(&ensemble)) {
            if (y.xR[iround(xy.xyR[i][nin])] > 0.0) {
               refavgce += log(1 / y.xR[iround(xy.xyR[i][nin])]);
            } else {
               refavgce += log(maxrealnumber);
            }
         }
         if (mlpeissoftmax(&ensemble)) {
            dsmax = iround(xy.xyR[i][nin]);
         } else {
            dsmax = 0;
         }
         for (j = 0; j < nout; j++) {
            refrmserror += sqr(y.xR[j] - y1.xR[j]);
            refavgerror += fabs(y.xR[j] - y1.xR[j]);
            if (y1.xR[j] != 0.0) {
               refavgrelerror += fabs(y.xR[j] - y1.xR[j]) / fabs(y1.xR[j]);
               avgrelcnt++;
            }
            if (y.xR[j] > y.xR[nnmax]) {
               nnmax = j;
            }
            if (!mlpeissoftmax(&ensemble) && y1.xR[j] > y1.xR[dsmax]) {
               dsmax = j;
            }
         }
         if (nnmax != dsmax) {
            refclserror++;
         }
      }
      sparseconverttocrs(&sparsexy);
      if (ssize > 0) {
         refrmserror = sqrt(refrmserror / (ssize * nout));
         refavgerror /= ssize * nout;
         refavgce /= ssize * log(2.0);
      }
      if (avgrelcnt > 0) {
         refavgrelerror /= avgrelcnt;
      }
   // Test "continuous" errors on full dataset
      Ok = Ok && RelNear(mlpermserror(&ensemble, &xy, ssize), refrmserror, etol, escale);
      Ok = Ok && RelNear(mlpeavgce(&ensemble, &xy, ssize), refavgce, etol, escale);
      Ok = Ok && RelNear(mlpeavgerror(&ensemble, &xy, ssize), refavgerror, etol, escale);
      Ok = Ok && RelNear(mlpeavgrelerror(&ensemble, &xy, ssize), refavgrelerror, etol, escale);
   }
   ae_frame_leave();
   return Ok;
}

bool testmlpe() {
   bool Ok;
   bool infOk;
   bool procOk;
   bool errOk;
   ae_int_t passcount;
   ae_int_t maxn;
   ae_int_t maxhid;
   ae_int_t nf;
   ae_int_t nl;
   ae_int_t nhid1;
   ae_int_t nhid2;
   ae_int_t ec;
   ae_int_t nkind;
   ae_int_t sizemin;
   ae_int_t sizemax;
   Ok = true;
   infOk = true;
   procOk = true;
   errOk = true;
   passcount = 5;
   maxn = 3;
   maxhid = 3;
// General MLP ensembles tests
// These tests are performed with small dataset, whose size is in [0,10].
// We test correctness of functions on small sets, but do not test code
// which splits large dataset into smaller chunks.
   sizemin = 0;
   sizemax = 10;
   for (nf = 1; nf <= maxn; nf++) {
      for (nl = 1; nl <= maxn; nl++) {
         for (nhid1 = 0; nhid1 <= maxhid; nhid1++) {
            for (nhid2 = 0; nhid2 <= maxhid; nhid2++) {
               for (nkind = 0; nkind <= 3; nkind++) {
                  for (ec = 1; ec <= 3; ec++) {
                  // Skip meaningless parameters combinations
                     if (nkind == 1 && nl < 2) {
                        continue;
                     }
                     if (nhid1 == 0 && nhid2 != 0) {
                        continue;
                     }
                  // Tests
                     infOk = infOk && testmlpeunit_testinformational(nkind, nf, nhid1, nhid2, nl, ec, passcount);
                     procOk = procOk && testmlpeunit_testprocessing(nkind, nf, nhid1, nhid2, nl, ec, passcount);
                     errOk = errOk && testmlpeunit_testerr(nkind, nf, nhid1, nhid2, nl, ec, passcount, sizemin, sizemax);
                  }
               }
            }
         }
      }
   }
// Special tests on large datasets: test ability to correctly split
// work into smaller chunks.
   nf = 2;
   nhid1 = 10;
   nhid2 = 10;
   nl = 2;
   ec = 10;
   sizemin = 1000;
   sizemax = 1000;
   errOk = errOk && testmlpeunit_testerr(0, nf, nhid1, nhid2, nl, ec, 1, sizemin, sizemax);
// The final report.
   Ok = infOk && procOk && errOk;
   if (!Ok || !silent) {
      printf("MLP Ensemble Tests\n");
      printf("Informational Functions:                  %s\n", infOk? "Ok": "Failed");
      printf("Basic Processing:                         %s\n", procOk? "Ok": "Failed");
      printf("Error Functions:                          %s\n", errOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === clustering testing unit ===
// This function replays merges and checks that:
// * Rep.NPoints, Rep.Z, Rep.PZ and Rep.PM are consistent and correct
// * Rep.MergeDist is consistent with distance between clusters being merged
// * clusters with minimal distance are merged at each step
// * GetKClusters() correctly unpacks clusters for each K
//
// NOTE: this algorithm correctly handle ties, i.e. situations where several
//       pairs  of  clusters  have  same intercluster distance, and we can't
//       unambiguously choose clusters to merge.
//
// Inputs:
//     D           -   distance matrix, array[NPoints,NPoints], full matrix
//                     is given (including both triangles and zeros on the
//                     main diagonal)
//     XY          -   dataset matrix, array[NPoints,NF]
//     NPoints     -   dataset size
//     NF          -   number of features
//     Rep         -   clusterizer report
//     AHCAlgo     -   AHC algorithm:
//                     * 0 - complete linkage
//                     * 1 - single linkage
//                     * 2 - unweighted average linkage
static bool testclusteringunit_errorsinmerges(RMatrix *d, RMatrix *xy, ae_int_t npoints, ae_int_t nf, ahcreport *rep, ae_int_t ahcalgo) {
   ae_frame _frame_block;
   bool bflag;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t i0;
   ae_int_t i1;
   ae_int_t c0;
   ae_int_t c1;
   ae_int_t s0;
   ae_int_t s1;
   double v;
   ae_int_t t;
   ae_int_t mergeidx;
   ae_int_t currentelement;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(dm, 0, 0, DT_REAL);
   NewMatrix(cm, 0, 0, DT_INT);
   NewVector(clustersizes, 0, DT_INT);
   NewVector(clusterheights, 0, DT_INT);
   NewVector(b, 0, DT_BOOL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(kidx, 0, DT_INT);
   NewVector(kidxz, 0, DT_INT);
   ae_assert(ahcalgo != 3, "integrity error");
   Ok = true;
   ae_vector_set_length(&x0, nf);
   ae_vector_set_length(&x1, nf);
// Basic checks:
// * positive completion code
// * sizes of arrays
// * Rep.P is correct permutation
// * Rep.Z contains correct cluster indexes
// * Rep.PZ is consistent with Rep.P/Rep.Z
// * Rep.PM contains consistent indexes
// * GetKClusters() for K == NPoints
   bflag = false;
   bflag = bflag || rep->terminationtype <= 0;
   if (bflag) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   bflag = bflag || rep->npoints != npoints;
   bflag = bflag || rep->z.rows != npoints - 1 || npoints > 1 && rep->z.cols != 2;
   bflag = bflag || rep->pz.rows != npoints - 1 || npoints > 1 && rep->pz.cols != 2;
   bflag = bflag || rep->pm.rows != npoints - 1 || npoints > 1 && rep->pm.cols != 6;
   bflag = bflag || rep->mergedist.cnt != npoints - 1;
   bflag = bflag || rep->p.cnt != npoints;
   if (bflag) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   ae_vector_set_length(&b, npoints);
   for (i = 0; i < npoints; i++) {
      b.xB[i] = false;
   }
   for (i = 0; i < npoints; i++) {
      if (rep->p.xZ[i] < 0 || rep->p.xZ[i] >= npoints || b.xB[rep->p.xZ[i]]) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      b.xB[rep->p.xZ[i]] = true;
   }
   for (i = 0; i < npoints - 1; i++) {
      if (rep->z.xyZ[i][0] < 0 || rep->z.xyZ[i][0] >= rep->z.xyZ[i][1] || rep->z.xyZ[i][1] >= npoints + i) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      if (rep->pz.xyZ[i][0] < 0 || rep->pz.xyZ[i][0] >= rep->pz.xyZ[i][1] || rep->pz.xyZ[i][1] >= npoints + i) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   for (i = 0; i < npoints - 1; i++) {
      c0 = rep->z.xyZ[i][0];
      c1 = rep->z.xyZ[i][1];
      s0 = rep->pz.xyZ[i][0];
      s1 = rep->pz.xyZ[i][1];
      if (c0 < npoints) {
         c0 = rep->p.xZ[c0];
      }
      if (c1 < npoints) {
         c1 = rep->p.xZ[c1];
      }
      if (c0 != s0 || c1 != s1) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   clusterizergetkclusters(rep, npoints, &kidx, &kidxz);
   if (kidx.cnt != npoints || kidxz.cnt != npoints) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
   for (i = 0; i < npoints; i++) {
      if (kidxz.xZ[i] != i || kidx.xZ[i] != i) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
// Test description:
// * we generate (2*NPoints-1)x(2*NPoints-1) matrix of distances DM and
//   (2*NPoints-1)xNPoints matrix of clusters CM (I-th row contains indexes
//   of elements which belong to I-th cluster, negative indexes denote
//   empty cells). Leading N*N square of DM is just a distance matrix,
//   other elements are filled by some large number M (used to mark empty
//   elements).
// * we replay all merges
// * every time we merge clusters I and J into K, we:
//   * check that distance between I and J is equal to the smallest
//     element of DM (note: we account for rounding errors when we
//     decide on that)
//   * check that distance is consistent with Rep.MergeDist
//   * then, we enumerate all elements in clusters being merged,
//     and check that after permutation their indexes fall into range
//     prescribed by Rep.PM
//   * fill K-th column/row of D by distances to cluster K
//   * merge I-th and J-th rows of CM and store result into K-th row
//   * clear DM and CM: fill I-th and J-th column/row of DM by large
//     number M, fill I-th and J-th row of CM by -1.
//
// NOTE: DM is initialized by distance metric specific to AHC algorithm
//       being used. CLINK, SLINK and average linkage use user-provided
//       distance measure, say Euclidean one, without any modifications.
//       Ward's method uses (and reports) squared and scaled Euclidean
//       distances.
   ae_matrix_set_length(&dm, 2 * npoints - 1, 2 * npoints - 1);
   ae_matrix_set_length(&cm, 2 * npoints - 1, npoints);
   ae_vector_set_length(&clustersizes, 2 * npoints - 1);
   for (i = 0; i < 2 * npoints - 1; i++) {
      for (j = 0; j < 2 * npoints - 1; j++) {
         if (i < npoints && j < npoints) {
            dm.xyR[i][j] = d->xyR[i][j];
            if (ahcalgo == 4) {
               dm.xyR[i][j] = 0.5 * sqr(dm.xyR[i][j]);
            }
         } else {
            dm.xyR[i][j] = maxrealnumber;
         }
      }
   }
   for (i = 0; i < 2 * npoints - 1; i++) {
      for (j = 0; j < npoints; j++) {
         cm.xyZ[i][j] = -1;
      }
   }
   for (i = 0; i < npoints; i++) {
      cm.xyZ[i][0] = i;
      clustersizes.xZ[i] = 1;
   }
   for (i = npoints; i < 2 * npoints - 1; i++) {
      clustersizes.xZ[i] = 0;
   }
   ae_vector_set_length(&clusterheights, 2 * npoints - 1);
   for (i = 0; i < npoints; i++) {
      clusterheights.xZ[i] = 0;
   }
   for (mergeidx = 0; mergeidx < npoints - 1; mergeidx++) {
   // Check that clusters with minimum distance are merged,
   // and that MergeDist is consistent with results.
   //
   // NOTE: we do not check for specific cluster indexes,
   //       because it is possible to have a tie. We just
   //       check that distance between clusters is a true
   //       minimum over all possible clusters.
      v = maxrealnumber;
      for (i = 0; i < 2 * npoints - 1; i++) {
         for (j = 0; j < 2 * npoints - 1; j++) {
            if (i != j) {
               v = rmin2(v, dm.xyR[i][j]);
            }
         }
      }
      c0 = rep->z.xyZ[mergeidx][0];
      c1 = rep->z.xyZ[mergeidx][1];
      if (dm.xyR[c0][c1] > v + 10000.0 * machineepsilon) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      if (rep->mergedist.xR[mergeidx] > v + 10000.0 * machineepsilon) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   // Check that indexes of elements fall into range prescribed by Rep.PM,
   // and Rep.PM correctly described merge operation
      s0 = clustersizes.xZ[c0];
      s1 = clustersizes.xZ[c1];
      for (j = 0; j < clustersizes.xZ[c0]; j++) {
         if (rep->p.xZ[cm.xyZ[c0][j]] < rep->pm.xyZ[mergeidx][0] || rep->p.xZ[cm.xyZ[c0][j]] > rep->pm.xyZ[mergeidx][1]) {
         // Element falls outside of range described by PM
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
      for (j = 0; j < clustersizes.xZ[c1]; j++) {
         if (rep->p.xZ[cm.xyZ[c1][j]] < rep->pm.xyZ[mergeidx][2] || rep->p.xZ[cm.xyZ[c1][j]] > rep->pm.xyZ[mergeidx][3]) {
         // Element falls outside of range described by PM
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
      if (rep->pm.xyZ[mergeidx][1] - rep->pm.xyZ[mergeidx][0] != s0 - 1 || rep->pm.xyZ[mergeidx][3] - rep->pm.xyZ[mergeidx][2] != s1 - 1 || rep->pm.xyZ[mergeidx][2] != rep->pm.xyZ[mergeidx][1] + 1) {
      // Cluster size (as given by PM) is inconsistent with its actual size.
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      if (rep->pm.xyZ[mergeidx][4] != clusterheights.xZ[rep->z.xyZ[mergeidx][0]] || rep->pm.xyZ[mergeidx][5] != clusterheights.xZ[rep->z.xyZ[mergeidx][1]]) {
      // Heights of subdendrograms as returned by PM are inconsistent with heights
      // calculated by us.
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   // Update cluster heights
      clusterheights.xZ[mergeidx + npoints] = imax2(clusterheights.xZ[rep->z.xyZ[mergeidx][0]], clusterheights.xZ[rep->z.xyZ[mergeidx][1]]) + 1;
   // Update CM
      t = 0;
      for (j = 0; j < clustersizes.xZ[rep->z.xyZ[mergeidx][0]]; j++) {
         cm.xyZ[npoints + mergeidx][t] = cm.xyZ[rep->z.xyZ[mergeidx][0]][j];
         t++;
      }
      for (j = 0; j < clustersizes.xZ[rep->z.xyZ[mergeidx][1]]; j++) {
         cm.xyZ[npoints + mergeidx][t] = cm.xyZ[rep->z.xyZ[mergeidx][1]][j];
         t++;
      }
      clustersizes.xZ[npoints + mergeidx] = t;
      clustersizes.xZ[rep->z.xyZ[mergeidx][0]] = 0;
      clustersizes.xZ[rep->z.xyZ[mergeidx][1]] = 0;
   // Update distance matrix D
      for (i = 0; i < 2 * npoints - 1; i++) {
      // "Remove" columns/rows corresponding to clusters being merged
         dm.xyR[i][rep->z.xyZ[mergeidx][0]] = maxrealnumber;
         dm.xyR[i][rep->z.xyZ[mergeidx][1]] = maxrealnumber;
         dm.xyR[rep->z.xyZ[mergeidx][0]][i] = maxrealnumber;
         dm.xyR[rep->z.xyZ[mergeidx][1]][i] = maxrealnumber;
      }
      for (i = 0; i < npoints + mergeidx; i++) {
         if (clustersizes.xZ[i] > 0) {
         // Calculate column/row corresponding to new cluster
            if (ahcalgo == 0) {
            // Calculate distance between clusters I and NPoints+MergeIdx for CLINK
               v = 0.0;
               for (i0 = 0; i0 < clustersizes.xZ[i]; i0++) {
                  for (i1 = 0; i1 < clustersizes.xZ[npoints + mergeidx]; i1++) {
                     v = rmax2(v, d->xyR[cm.xyZ[i][i0]][cm.xyZ[npoints + mergeidx][i1]]);
                  }
               }
            }
            if (ahcalgo == 1) {
            // Calculate distance between clusters I and NPoints+MergeIdx for SLINK
               v = maxrealnumber;
               for (i0 = 0; i0 < clustersizes.xZ[i]; i0++) {
                  for (i1 = 0; i1 < clustersizes.xZ[npoints + mergeidx]; i1++) {
                     v = rmin2(v, d->xyR[cm.xyZ[i][i0]][cm.xyZ[npoints + mergeidx][i1]]);
                  }
               }
            }
            if (ahcalgo == 2) {
            // Calculate distance between clusters I and NPoints+MergeIdx for unweighted average
               v = 0.0;
               t = 0;
               for (i0 = 0; i0 < clustersizes.xZ[i]; i0++) {
                  for (i1 = 0; i1 < clustersizes.xZ[npoints + mergeidx]; i1++) {
                     v += d->xyR[cm.xyZ[i][i0]][cm.xyZ[npoints + mergeidx][i1]];
                     t++;
                  }
               }
               v /= t;
            }
            if (ahcalgo == 3) {
               ae_assert(false, "Assertion failed");
            }
            if (ahcalgo == 4) {
            // Calculate distance between clusters I and NPoints+MergeIdx for Ward's method:
            // * X0 = center of mass for cluster I
            // * X1 = center of mass for cluster NPoints+MergeIdx
            // * S0 = size of cluster I
            // * S1 = size of cluster NPoints+MergeIdx
            // * distance between clusters is S0*S1/(S0+S1)*|X0-X1|^2
            //
               for (j = 0; j < nf; j++) {
                  x0.xR[j] = 0.0;
                  x1.xR[j] = 0.0;
               }
               for (i0 = 0; i0 < clustersizes.xZ[i]; i0++) {
                  for (j = 0; j < nf; j++) {
                     x0.xR[j] += xy->xyR[cm.xyZ[i][i0]][j] / clustersizes.xZ[i];
                  }
               }
               for (i1 = 0; i1 < clustersizes.xZ[npoints + mergeidx]; i1++) {
                  for (j = 0; j < nf; j++) {
                     x1.xR[j] += xy->xyR[cm.xyZ[npoints + mergeidx][i1]][j] / clustersizes.xZ[npoints + mergeidx];
                  }
               }
               v = 0.0;
               for (j = 0; j < nf; j++) {
                  v += sqr(x0.xR[j] - x1.xR[j]);
               }
               v = v * clustersizes.xZ[i] * clustersizes.xZ[npoints + mergeidx] / (clustersizes.xZ[i] + clustersizes.xZ[npoints + mergeidx]);
            }
            dm.xyR[i][npoints + mergeidx] = v;
            dm.xyR[npoints + mergeidx][i] = v;
         }
      }
   // Check that GetKClusters() correctly unpacks clusters for K == NPoints-(MergeIdx+1):
   // * check lengths of arays
   // * check consistency of CIdx/CZ parameters
   // * scan clusters (CZ parameter), for each cluster scan CM matrix which stores
   //   cluster elements (according to our replay of merges), for each element of
   //   the current cluster check that CIdx array correctly reflects its status.
      k = npoints - (mergeidx + 1);
      clusterizergetkclusters(rep, k, &kidx, &kidxz);
      if (kidx.cnt != npoints || kidxz.cnt != k) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      for (i = 0; i < k - 1; i++) {
         if (kidxz.xZ[i] < 0 || kidxz.xZ[i] >= kidxz.xZ[i + 1] || kidxz.xZ[i + 1] > 2 * npoints - 2) {
         // CZ is inconsistent
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
      for (i = 0; i < npoints; i++) {
         if (kidx.xZ[i] < 0 || kidx.xZ[i] >= k) {
         // CIdx is inconsistent
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
      for (i = 0; i < k; i++) {
         for (j = 0; j < clustersizes.xZ[kidxz.xZ[i]]; j++) {
            currentelement = cm.xyZ[kidxz.xZ[i]][j];
            if (kidx.xZ[currentelement] != i) {
            // We've found element which belongs to I-th cluster (according to CM
            // matrix, which reflects current status of agglomerative clustering),
            // but this element does not belongs to I-th cluster according to
            // results of ClusterizerGetKClusters()
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Basic agglomerative hierarchical clustering tests.
// Basic tests study algorithm behavior on simple,  hand-made  datasets  with
// small number of points (1..10).
static bool testclusteringunit_basicahctests() {
   ae_frame _frame_block;
   bool berr;
   ae_int_t ahcalgo;
   ae_int_t i;
   ae_int_t j;
   ae_int_t npoints;
   ae_int_t k;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(clusterizerstate, s);
   NewObj(ahcreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(d, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(cidx, 0, DT_INT);
   NewVector(cz, 0, DT_INT);
   NewVector(cidx2, 0, DT_INT);
   NewVector(cz2, 0, DT_INT);
   Ok = false;
// Test on empty problem
   clusterizercreate(&s);
   clusterizerrunahc(&s, &rep);
   if (rep.npoints != 0) {
      ae_frame_leave();
      return Ok;
   }
// Test on problem with one point
   ae_matrix_set_length(&xy, 1, 2);
   xy.xyR[0][0] = randomreal();
   xy.xyR[0][1] = randomreal();
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 1, 2, 0);
   clusterizerrunahc(&s, &rep);
   if (rep.npoints != 1) {
      ae_frame_leave();
      return Ok;
   }
// Test on problem with two points
   ae_matrix_set_length(&xy, 2, 2);
   xy.xyR[0][0] = randomreal();
   xy.xyR[0][1] = randomreal();
   xy.xyR[1][0] = randomreal();
   xy.xyR[1][1] = randomreal();
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 2, 2, 0);
   clusterizerrunahc(&s, &rep);
   if (rep.npoints != 2 || rep.z.rows != 1 || rep.z.cols != 2) {
      ae_frame_leave();
      return Ok;
   }
   if (rep.z.xyZ[0][0] != 0 || rep.z.xyZ[0][1] != 1) {
      ae_frame_leave();
      return Ok;
   }
// Test on specially designed problem which should have
// following dendrogram:
//
//   ------
//   |    |
// ----  ----
// |  |  |  |
// 0  1  2  3
//
// ...with first merge performed on 0 and 1, second merge
// performed on 2 and 3. Complete linkage is used.
//
// Additionally we test ClusterizerSeparatedByDist() on this
// problem for different distances. Test is performed by
// comparing function result with ClusterizerGetKClusters()
// for known K.
   ae_matrix_set_length(&xy, 4, 1);
   xy.xyR[0][0] = 0.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[2][0] = 3.0;
   xy.xyR[3][0] = 4.1;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 4, 1, 0);
   clusterizersetahcalgo(&s, 0);
   clusterizerrunahc(&s, &rep);
   if (rep.npoints != 4 || rep.z.rows != 3 || rep.z.cols != 2 || rep.pz.rows != 3 || rep.pz.cols != 2) {
      ae_frame_leave();
      return Ok;
   }
   berr = false;
   berr = berr || rep.z.xyZ[0][0] != 0 || rep.z.xyZ[0][1] != 1;
   berr = berr || rep.z.xyZ[1][0] != 2 || rep.z.xyZ[1][1] != 3;
   berr = berr || rep.z.xyZ[2][0] != 4 || rep.z.xyZ[2][1] != 5;
   berr = berr || rep.p.xZ[0] != 0 || rep.p.xZ[1] != 1 || rep.p.xZ[2] != 2 || rep.p.xZ[3] != 3;
   berr = berr || rep.pz.xyZ[0][0] != 0 || rep.pz.xyZ[0][1] != 1;
   berr = berr || rep.pz.xyZ[1][0] != 2 || rep.pz.xyZ[1][1] != 3;
   berr = berr || rep.pz.xyZ[2][0] != 4 || rep.pz.xyZ[2][1] != 5;
   berr = berr || rep.pm.xyZ[0][0] != 0 || rep.pm.xyZ[0][1] != 0 || rep.pm.xyZ[0][2] != 1 || rep.pm.xyZ[0][3] != 1;
   berr = berr || rep.pm.xyZ[1][0] != 2 || rep.pm.xyZ[1][1] != 2 || rep.pm.xyZ[1][2] != 3 || rep.pm.xyZ[1][3] != 3;
   berr = berr || rep.pm.xyZ[2][0] != 0 || rep.pm.xyZ[2][1] != 1 || rep.pm.xyZ[2][2] != 2 || rep.pm.xyZ[2][3] != 3;
   if (berr) {
      ae_frame_leave();
      return Ok;
   }
   clusterizerseparatedbydist(&rep, 0.5, &k, &cidx, &cz);
   clusterizergetkclusters(&rep, 4, &cidx2, &cz2);
   if (k != 4) {
      ae_frame_leave();
      return Ok;
   }
   if (cidx.xZ[0] != cidx2.xZ[0] || cidx.xZ[1] != cidx2.xZ[1] || cidx.xZ[2] != cidx2.xZ[2] || cidx.xZ[3] != cidx2.xZ[3]) {
      ae_frame_leave();
      return Ok;
   }
   if (cz.xZ[0] != cz2.xZ[0] || cz.xZ[1] != cz2.xZ[1] || cz.xZ[2] != cz2.xZ[2] || cz.xZ[3] != cz2.xZ[3]) {
      ae_frame_leave();
      return Ok;
   }
   clusterizerseparatedbydist(&rep, 1.05, &k, &cidx, &cz);
   clusterizergetkclusters(&rep, 3, &cidx2, &cz2);
   if (k != 3) {
      ae_frame_leave();
      return Ok;
   }
   if (cidx.xZ[0] != cidx2.xZ[0] || cidx.xZ[1] != cidx2.xZ[1] || cidx.xZ[2] != cidx2.xZ[2] || cidx.xZ[3] != cidx2.xZ[3]) {
      ae_frame_leave();
      return Ok;
   }
   if (cz.xZ[0] != cz2.xZ[0] || cz.xZ[1] != cz2.xZ[1] || cz.xZ[2] != cz2.xZ[2]) {
      ae_frame_leave();
      return Ok;
   }
   clusterizerseparatedbydist(&rep, 1.15, &k, &cidx, &cz);
   clusterizergetkclusters(&rep, 2, &cidx2, &cz2);
   if (k != 2) {
      ae_frame_leave();
      return Ok;
   }
   if (cidx.xZ[0] != cidx2.xZ[0] || cidx.xZ[1] != cidx2.xZ[1] || cidx.xZ[2] != cidx2.xZ[2] || cidx.xZ[3] != cidx2.xZ[3]) {
      ae_frame_leave();
      return Ok;
   }
   if (cz.xZ[0] != cz2.xZ[0] || cz.xZ[1] != cz2.xZ[1]) {
      ae_frame_leave();
      return Ok;
   }
// Test on specially designed problem with Pearson distance
// which should have following dendrogram:
//
//   ------
//   |    |
// ----  ----
// |  |  |  |
// 0  1  2  3
//
// This problem is used to test ClusterizerSeparatedByDist().
// The test is performed by comparing function result with
// ClusterizerGetKClusters() for known K.
//
// NOTE:
// * corr(a0,a1) = 0.866
// * corr(a2,a3) = 0.990
// * corr(a0/a1, a2/a3) <= 0.5
   ae_matrix_set_length(&xy, 4, 3);
   xy.xyR[0][0] = 0.3;
   xy.xyR[0][1] = 0.5;
   xy.xyR[0][2] = 0.3;
   xy.xyR[1][0] = 0.3;
   xy.xyR[1][1] = 0.5;
   xy.xyR[1][2] = 0.4;
   xy.xyR[2][0] = 0.1;
   xy.xyR[2][1] = 0.5;
   xy.xyR[2][2] = 0.9;
   xy.xyR[3][0] = 0.1;
   xy.xyR[3][1] = 0.4;
   xy.xyR[3][2] = 0.9;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 4, 3, 10);
   clusterizersetahcalgo(&s, 1);
   clusterizerrunahc(&s, &rep);
   clusterizerseparatedbycorr(&rep, 0.999, &k, &cidx, &cz);
   clusterizergetkclusters(&rep, 4, &cidx2, &cz2);
   if (k != 4) {
      ae_frame_leave();
      return Ok;
   }
   if (cidx.xZ[0] != cidx2.xZ[0] || cidx.xZ[1] != cidx2.xZ[1] || cidx.xZ[2] != cidx2.xZ[2] || cidx.xZ[3] != cidx2.xZ[3]) {
      ae_frame_leave();
      return Ok;
   }
   if (cz.xZ[0] != cz2.xZ[0] || cz.xZ[1] != cz2.xZ[1] || cz.xZ[2] != cz2.xZ[2] || cz.xZ[3] != cz2.xZ[3]) {
      ae_frame_leave();
      return Ok;
   }
   clusterizerseparatedbycorr(&rep, 0.900, &k, &cidx, &cz);
   clusterizergetkclusters(&rep, 3, &cidx2, &cz2);
   if (k != 3) {
      ae_frame_leave();
      return Ok;
   }
   if (cidx.xZ[0] != cidx2.xZ[0] || cidx.xZ[1] != cidx2.xZ[1] || cidx.xZ[2] != cidx2.xZ[2] || cidx.xZ[3] != cidx2.xZ[3]) {
      ae_frame_leave();
      return Ok;
   }
   if (cz.xZ[0] != cz2.xZ[0] || cz.xZ[1] != cz2.xZ[1] || cz.xZ[2] != cz2.xZ[2]) {
      ae_frame_leave();
      return Ok;
   }
   clusterizerseparatedbycorr(&rep, 0.600, &k, &cidx, &cz);
   clusterizergetkclusters(&rep, 2, &cidx2, &cz2);
   if (k != 2) {
      ae_frame_leave();
      return Ok;
   }
   if (cidx.xZ[0] != cidx2.xZ[0] || cidx.xZ[1] != cidx2.xZ[1] || cidx.xZ[2] != cidx2.xZ[2] || cidx.xZ[3] != cidx2.xZ[3]) {
      ae_frame_leave();
      return Ok;
   }
   if (cz.xZ[0] != cz2.xZ[0] || cz.xZ[1] != cz2.xZ[1]) {
      ae_frame_leave();
      return Ok;
   }
// Single linkage vs. complete linkage
   ae_matrix_set_length(&xy, 6, 1);
   xy.xyR[0][0] = 0.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[2][0] = 2.1;
   xy.xyR[3][0] = 3.3;
   xy.xyR[4][0] = 6.0;
   xy.xyR[5][0] = 4.6;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 6, 1, 0);
   clusterizersetahcalgo(&s, 0);
   clusterizerrunahc(&s, &rep);
   if (rep.npoints != 6 || rep.p.cnt != 6) {
      ae_frame_leave();
      return Ok;
   }
   if (rep.z.rows != 5 || rep.z.cols != 2 || rep.pz.rows != 5 || rep.pz.cols != 2) {
      ae_frame_leave();
      return Ok;
   }
   berr = false;
   berr = berr || rep.p.xZ[0] != 2;
   berr = berr || rep.p.xZ[1] != 3;
   berr = berr || rep.p.xZ[2] != 4;
   berr = berr || rep.p.xZ[3] != 5;
   berr = berr || rep.p.xZ[4] != 0;
   berr = berr || rep.p.xZ[5] != 1;
   berr = berr || rep.z.xyZ[0][0] != 0 || rep.z.xyZ[0][1] != 1;
   berr = berr || rep.z.xyZ[1][0] != 2 || rep.z.xyZ[1][1] != 3;
   berr = berr || rep.z.xyZ[2][0] != 4 || rep.z.xyZ[2][1] != 5;
   berr = berr || rep.z.xyZ[3][0] != 6 || rep.z.xyZ[3][1] != 7;
   berr = berr || rep.z.xyZ[4][0] != 8 || rep.z.xyZ[4][1] != 9;
   berr = berr || rep.pz.xyZ[0][0] != 2 || rep.pz.xyZ[0][1] != 3;
   berr = berr || rep.pz.xyZ[1][0] != 4 || rep.pz.xyZ[1][1] != 5;
   berr = berr || rep.pz.xyZ[2][0] != 0 || rep.pz.xyZ[2][1] != 1;
   berr = berr || rep.pz.xyZ[3][0] != 6 || rep.pz.xyZ[3][1] != 7;
   berr = berr || rep.pz.xyZ[4][0] != 8 || rep.pz.xyZ[4][1] != 9;
   if (berr) {
      ae_frame_leave();
      return Ok;
   }
   clusterizersetahcalgo(&s, 1);
   clusterizerrunahc(&s, &rep);
   if (rep.npoints != 6 || rep.z.rows != 5 || rep.z.cols != 2) {
      ae_frame_leave();
      return Ok;
   }
   berr = false;
   berr = berr || rep.z.xyZ[0][0] != 0 || rep.z.xyZ[0][1] != 1;
   berr = berr || rep.z.xyZ[1][0] != 2 || rep.z.xyZ[1][1] != 6;
   berr = berr || rep.z.xyZ[2][0] != 3 || rep.z.xyZ[2][1] != 7;
   berr = berr || rep.z.xyZ[3][0] != 5 || rep.z.xyZ[3][1] != 8;
   berr = berr || rep.z.xyZ[4][0] != 4 || rep.z.xyZ[4][1] != 9;
   if (berr) {
      ae_frame_leave();
      return Ok;
   }
// Test which differentiates complete linkage and average linkage from
// single linkage:
// * we have cluster C0 == {(-0.5), (0)},
//   cluster C1 == {(19.0), (20.0), (21.0), (22.0), (23.0)},
//   and point P between them - (10.0)
// * we try three different strategies - single linkage, complete
//   linkage, average linkage.
// * any strategy will merge C0 first, then merge points of C1,
//   and then merge P with C0 or C1 (depending on linkage type)
// * we test that:
//   a) C0 is merged first
//   b) after 5 merges (including merge of C0), P is merged with C0 or C1
//   c) P is merged with C1 when we have single linkage, with C0 otherwise
   ae_matrix_set_length(&xy, 8, 1);
   xy.xyR[0][0] = -0.5;
   xy.xyR[1][0] = 0.0;
   xy.xyR[2][0] = 10.0;
   xy.xyR[3][0] = 19.0;
   xy.xyR[4][0] = 20.0;
   xy.xyR[5][0] = 21.0;
   xy.xyR[6][0] = 22.0;
   xy.xyR[7][0] = 23.0;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 8, 1, 0);
   for (ahcalgo = 0; ahcalgo <= 2; ahcalgo++) {
      clusterizersetahcalgo(&s, ahcalgo);
      clusterizerrunahc(&s, &rep);
      if (rep.npoints != 8 || rep.z.rows != 7 || rep.z.cols != 2) {
         ae_frame_leave();
         return Ok;
      }
      if (rep.z.xyZ[0][0] != 0 || rep.z.xyZ[0][1] != 1) {
         ae_frame_leave();
         return Ok;
      }
      if (rep.z.xyZ[5][0] != 2 && rep.z.xyZ[5][1] != 2) {
         ae_frame_leave();
         return Ok;
      }
      if (rep.z.xyZ[5][0] != 2 && rep.z.xyZ[5][1] != 2) {
         ae_frame_leave();
         return Ok;
      }
      if ((ahcalgo == 0 || ahcalgo == 2) && rep.z.xyZ[5][0] != 8 && rep.z.xyZ[5][1] != 8) {
         ae_frame_leave();
         return Ok;
      }
      if (ahcalgo == 1 && (rep.z.xyZ[5][0] == 8 || rep.z.xyZ[5][1] == 8)) {
         ae_frame_leave();
         return Ok;
      }
   }
// Test which differentiates single linkage and average linkage from
// complete linkage:
// * we have cluster C0 == {(-2.5), (-2.0)},
//   cluster C1 == {(19.0), (20.0), (21.0), (22.0), (23.0)},
//   and point P between them - (10.0)
// * we try three different strategies - single linkage, complete
//   linkage, average linkage.
// * any strategy will merge C0 first, then merge points of C1,
//   and then merge P with C0 or C1 (depending on linkage type)
// * we test that:
//   a) C0 is merged first
//   b) after 5 merges (including merge of C0), P is merged with C0 or C1
//   c) P is merged with C0 when we have complete linkage, with C1 otherwise
   ae_matrix_set_length(&xy, 8, 1);
   xy.xyR[0][0] = -2.5;
   xy.xyR[1][0] = -2.0;
   xy.xyR[2][0] = 10.0;
   xy.xyR[3][0] = 19.0;
   xy.xyR[4][0] = 20.0;
   xy.xyR[5][0] = 21.0;
   xy.xyR[6][0] = 22.0;
   xy.xyR[7][0] = 23.0;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 8, 1, 0);
   for (ahcalgo = 0; ahcalgo <= 2; ahcalgo++) {
      clusterizersetahcalgo(&s, ahcalgo);
      clusterizerrunahc(&s, &rep);
      if (rep.npoints != 8 || rep.z.rows != 7 || rep.z.cols != 2) {
         ae_frame_leave();
         return Ok;
      }
      if (rep.z.xyZ[0][0] != 0 || rep.z.xyZ[0][1] != 1) {
         ae_frame_leave();
         return Ok;
      }
      if (rep.z.xyZ[5][0] != 2 && rep.z.xyZ[5][1] != 2) {
         ae_frame_leave();
         return Ok;
      }
      if (rep.z.xyZ[5][0] != 2 && rep.z.xyZ[5][1] != 2) {
         ae_frame_leave();
         return Ok;
      }
      if (ahcalgo == 0 && rep.z.xyZ[5][0] != 8 && rep.z.xyZ[5][1] != 8) {
         ae_frame_leave();
         return Ok;
      }
      if ((ahcalgo == 1 || ahcalgo == 2) && (rep.z.xyZ[5][0] == 8 || rep.z.xyZ[5][1] == 8)) {
         ae_frame_leave();
         return Ok;
      }
   }
// Test which differentiates weighred average linkage from unweighted average linkage:
// * we have cluster C0 == {(0.0), (1.5), (2.5)},
//   cluster C1 == {(7.5), (7.99)},
//   and point P between them - (4.5)
// * we try two different strategies - weighted average linkage and unweighted average linkage
// * any strategy will merge C1 first, then merge points of C0,
//   and then merge P with C0 or C1 (depending on linkage type)
// * we test that:
//   a) C1 is merged first, C0 is merged after that
//   b) after first 3 merges P is merged with C0 or C1
//   c) P is merged with C1 when we have weighted average linkage, with C0 otherwise
   ae_matrix_set_length(&xy, 6, 1);
   xy.xyR[0][0] = 0.0;
   xy.xyR[1][0] = 1.5;
   xy.xyR[2][0] = 2.5;
   xy.xyR[3][0] = 4.5;
   xy.xyR[4][0] = 7.5;
   xy.xyR[5][0] = 7.99;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 6, 1, 0);
   for (ahcalgo = 2; ahcalgo <= 3; ahcalgo++) {
      clusterizersetahcalgo(&s, ahcalgo);
      clusterizerrunahc(&s, &rep);
      if (rep.npoints != 6 || rep.z.rows != 5 || rep.z.cols != 2) {
         ae_frame_leave();
         return Ok;
      }
      if (rep.z.xyZ[0][0] != 4 || rep.z.xyZ[0][1] != 5) {
         ae_frame_leave();
         return Ok;
      }
      if (rep.z.xyZ[1][0] != 1 || rep.z.xyZ[1][1] != 2) {
         ae_frame_leave();
         return Ok;
      }
      if (rep.z.xyZ[2][0] != 0 || rep.z.xyZ[2][1] != 7) {
         ae_frame_leave();
         return Ok;
      }
      if (rep.z.xyZ[3][0] != 3) {
         ae_frame_leave();
         return Ok;
      }
      if (ahcalgo == 2 && rep.z.xyZ[3][1] != 8) {
         ae_frame_leave();
         return Ok;
      }
      if (ahcalgo == 3 && rep.z.xyZ[3][1] != 6) {
         ae_frame_leave();
         return Ok;
      }
   }
// Test which checks correctness of Ward's method on very basic problem
   ae_matrix_set_length(&xy, 4, 1);
   xy.xyR[0][0] = 0.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[2][0] = 3.1;
   xy.xyR[3][0] = 4.0;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, xy.rows, xy.cols, 2);
   clusterizergetdistances(&xy, xy.rows, xy.cols, 2, &d);
   clusterizersetahcalgo(&s, 4);
   clusterizerrunahc(&s, &rep);
   if (!testclusteringunit_errorsinmerges(&d, &xy, xy.rows, xy.cols, &rep, 4)) {
      ae_frame_leave();
      return Ok;
   }
// One more Ward's test
   ae_matrix_set_length(&xy, 8, 2);
   xy.xyR[0][0] = 0.4700566262;
   xy.xyR[0][1] = 0.4565938448;
   xy.xyR[1][0] = 0.2394499506;
   xy.xyR[1][1] = 0.1750209592;
   xy.xyR[2][0] = 0.6518417019;
   xy.xyR[2][1] = 0.6151370746;
   xy.xyR[3][0] = 0.9863942841;
   xy.xyR[3][1] = 0.7855012189;
   xy.xyR[4][0] = 0.1517812919;
   xy.xyR[4][1] = 0.2600174758;
   xy.xyR[5][0] = 0.7840203638;
   xy.xyR[5][1] = 0.9023597604;
   xy.xyR[6][0] = 0.2604194835;
   xy.xyR[6][1] = 0.9792704661;
   xy.xyR[7][0] = 0.6353096042;
   xy.xyR[7][1] = 0.8252606906;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, xy.rows, xy.cols, 2);
   clusterizergetdistances(&xy, xy.rows, xy.cols, 2, &d);
   clusterizersetahcalgo(&s, 4);
   clusterizerrunahc(&s, &rep);
   if (rep.z.xyZ[0][0] != 1 || rep.z.xyZ[0][1] != 4) {
      ae_frame_leave();
      return Ok;
   }
   if (rep.z.xyZ[1][0] != 5 || rep.z.xyZ[1][1] != 7) {
      ae_frame_leave();
      return Ok;
   }
   if (rep.z.xyZ[2][0] != 0 || rep.z.xyZ[2][1] != 2) {
      ae_frame_leave();
      return Ok;
   }
   if (rep.z.xyZ[3][0] != 3 || rep.z.xyZ[3][1] != 9) {
      ae_frame_leave();
      return Ok;
   }
   if (rep.z.xyZ[4][0] != 10 || rep.z.xyZ[4][1] != 11) {
      ae_frame_leave();
      return Ok;
   }
   if (rep.z.xyZ[5][0] != 6 || rep.z.xyZ[5][1] != 12) {
      ae_frame_leave();
      return Ok;
   }
   if (rep.z.xyZ[6][0] != 8 || rep.z.xyZ[6][1] != 13) {
      ae_frame_leave();
      return Ok;
   }
   if (!testclusteringunit_errorsinmerges(&d, &xy, xy.rows, xy.cols, &rep, 4)) {
      ae_frame_leave();
      return Ok;
   }
// Ability to solve problems with zero distance matrix
   npoints = 20;
   ae_matrix_set_length(&d, npoints, npoints);
   for (i = 0; i < npoints; i++) {
      for (j = 0; j < npoints; j++) {
         d.xyR[i][j] = 0.0;
      }
   }
   for (ahcalgo = 0; ahcalgo <= 4; ahcalgo++) {
      clusterizercreate(&s);
      clusterizersetdistances(&s, &d, npoints, true);
      clusterizersetahcalgo(&s, ahcalgo);
      clusterizerrunahc(&s, &rep);
      if (rep.npoints != npoints || rep.z.rows != npoints - 1 || rep.z.cols != 2) {
         ae_frame_leave();
         return Ok;
      }
   }
// Test GetKClusters()
   ae_matrix_set_length(&xy, 8, 1);
   xy.xyR[0][0] = -2.5;
   xy.xyR[1][0] = -2.0;
   xy.xyR[2][0] = 10.0;
   xy.xyR[3][0] = 19.0;
   xy.xyR[4][0] = 20.0;
   xy.xyR[5][0] = 21.0;
   xy.xyR[6][0] = 22.0;
   xy.xyR[7][0] = 23.0;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 8, 1, 0);
   clusterizersetahcalgo(&s, 0);
   clusterizerrunahc(&s, &rep);
   clusterizergetkclusters(&rep, 3, &cidx, &cz);
   if (cidx.xZ[0] != 1 || cidx.xZ[1] != 1 || cidx.xZ[2] != 0 || cidx.xZ[3] != 2 || cidx.xZ[4] != 2 || cidx.xZ[5] != 2 || cidx.xZ[6] != 2 || cidx.xZ[7] != 2) {
      ae_frame_leave();
      return Ok;
   }
   if (cz.xZ[0] != 2 || cz.xZ[1] != 8 || cz.xZ[2] != 12) {
      ae_frame_leave();
      return Ok;
   }
// Test is done
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// Distance function: distance between X0 and X1
//
// X0, X1 - array[D], points
// DistType - distance type
static double testclusteringunit_distfunc(RVector *x0, RVector *x1, ae_int_t d, ae_int_t disttype) {
   ae_int_t i;
   double s0;
   double s1;
   double result;
   ae_assert(disttype == 0 || disttype == 1 || disttype == 2 || disttype == 10 || disttype == 11 || disttype == 12 || disttype == 13 || disttype == 20 || disttype == 21, "Assertion failed");
   if (disttype == 0) {
      result = 0.0;
      for (i = 0; i < d; i++) {
         result = rmax2(result, fabs(x0->xR[i] - x1->xR[i]));
      }
      return result;
   }
   if (disttype == 1) {
      result = 0.0;
      for (i = 0; i < d; i++) {
         result += fabs(x0->xR[i] - x1->xR[i]);
      }
      return result;
   }
   if (disttype == 2) {
      result = 0.0;
      for (i = 0; i < d; i++) {
         result += sqr(x0->xR[i] - x1->xR[i]);
      }
      result = sqrt(result);
      return result;
   }
   if (disttype == 10) {
      result = rmax2(1 - pearsoncorr2(x0, x1, d), 0.0);
      return result;
   }
   if (disttype == 11) {
      result = rmax2(1 - fabs(pearsoncorr2(x0, x1, d)), 0.0);
      return result;
   }
   if (disttype == 12 || disttype == 13) {
      s0 = 0.0;
      s1 = 0.0;
      for (i = 0; i < d; i++) {
         s0 += sqr(x0->xR[i]) / d;
         s1 += sqr(x1->xR[i]) / d;
      }
      s0 = sqrt(s0);
      s1 = sqrt(s1);
      result = 0.0;
      for (i = 0; i < d; i++) {
         result += x0->xR[i] / s0 * (x1->xR[i] / s1) / d;
      }
      if (disttype == 12) {
         result = rmax2(1 - result, 0.0);
      } else {
         result = rmax2(1 - fabs(result), 0.0);
      }
      return result;
   }
   if (disttype == 20) {
      result = rmax2(1 - spearmancorr2(x0, x1, d), 0.0);
      return result;
   }
   if (disttype == 21) {
      result = rmax2(1 - fabs(spearmancorr2(x0, x1, d)), 0.0);
      return result;
   }
   result = 0.0;
   return result;
}

// Advanced  agglomerative  hierarchical  clustering  tests.
//
// Advanced testing subroutine perform several automatically generated tests.
static bool testclusteringunit_advancedahctests() {
   ae_frame _frame_block;
   ae_int_t d;
   ae_int_t n;
   ae_int_t npoints;
   ae_int_t ahcalgo;
   ae_int_t disttype;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t euclidean;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(clusterizerstate, s);
   NewObj(ahcreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(dm, 0, 0, DT_REAL);
   NewMatrix(dm2, 0, 0, DT_REAL);
   NewVector(idx, 0, DT_INT);
   NewVector(disttypes, 0, DT_INT);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   Ok = true;
   euclidean = 2;
// Test on D-dimensional problem:
// * D = 2...5
// * D clusters, each has N points;
//   centers are located at x == (0 ... 1 ... 0);
//   cluster radii are approximately 0.1
// * single/complete/unweighted_average/weighted_average linkage/Ward's method are tested
// * Euclidean distance is used, either:
//   a) one given by distance matrix (ClusterizerSetDistances)
//   b) one calculated from dataset (ClusterizerSetPoints)
// * we have N*D points, and N*D-1 merges in total
// * points are randomly rearranged after generation
//
// For all kinds of linkage we perform following test:
// * for each point we remember index of its cluster
//   (one which is determined during dataset generation)
// * we clusterize points with ALGLIB capabilities
// * we scan Rep.Z and perform first D*(N-1) merges
// * for each merge we check that it merges points
//   from same cluster;
//
// Additionally, we call ErrorsInMerges(). See function comments
// for more information about specific tests performed. This function
// allows us to check that clusters are built exactly as specified by
// definition of the clustering algorithm.
   for (d = 2; d <= 5; d++) {
      for (ahcalgo = 0; ahcalgo <= 4; ahcalgo++) {
         n = iround(pow(3.0, (double)randominteger(3)));
         npoints = d * n;
      // 1. generate dataset.
      // 2. fill Idx (array of cluster indexes):
      //    * first N*D elements store cluster indexes
      //    * next D*(N-1) elements are filled during merges
      // 3. build distance matrix DM
         ae_matrix_set_length(&xy, n * d, d);
         ae_vector_set_length(&idx, n * d + d * (n - 1));
         for (i = 0; i < n * d; i++) {
            for (j = 0; j < d; j++) {
               xy.xyR[i][j] = 0.1 * randommid();
            }
            xy.xyR[i][i % d]++;
            idx.xZ[i] = i % d;
         }
         for (i = 0; i < n * d; i++) {
            k = randominteger(n * d);
            if (k != i) {
               for (j = 0; j < d; j++) {
                  swapr(&xy.xyR[i][j], &xy.xyR[k][j]);
               }
               swapi(&idx.xZ[k], &idx.xZ[i]);
            }
         }
         ae_matrix_set_length(&dm, npoints, npoints);
         ae_vector_set_length(&x0, d);
         ae_vector_set_length(&x1, d);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < npoints; j++) {
               ae_v_move(x0.xR, 1, xy.xyR[i], 1, d);
               ae_v_move(x1.xR, 1, xy.xyR[j], 1, d);
               dm.xyR[i][j] = testclusteringunit_distfunc(&x0, &x1, d, euclidean);
            }
         }
      // Clusterize with SetPoints()
         clusterizercreate(&s);
         clusterizersetpoints(&s, &xy, n * d, d, euclidean);
         clusterizersetahcalgo(&s, ahcalgo);
         clusterizerrunahc(&s, &rep);
      // Tests:
      // * replay first D*(N-1) merges; these merges should take place
      //   within clusters, intercluster merges will be performed at the
      //   last stages of the processing.
      // * test with ErrorsInMerges()
         if (rep.npoints != npoints) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < d * (n - 1); i++) {
         // Check correctness of I-th row of Z
            if (rep.z.xyZ[i][0] < 0 || rep.z.xyZ[i][0] >= rep.z.xyZ[i][1] || rep.z.xyZ[i][1] >= d * n + i) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         // Check that merge is performed within cluster
            if (idx.xZ[rep.z.xyZ[i][0]] != idx.xZ[rep.z.xyZ[i][1]]) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         // Write new entry of Idx.
         // Both points from the same cluster, so result of the merge
         // belongs to the same cluster
            idx.xZ[n * d + i] = idx.xZ[rep.z.xyZ[i][1]];
         }
         if (ahcalgo == 0 || ahcalgo == 1 || ahcalgo == 2 || ahcalgo == 4) {
            if (!testclusteringunit_errorsinmerges(&dm, &xy, d * n, d, &rep, ahcalgo)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      // Clusterize one more time, now with distance matrix
         clusterizercreate(&s);
         clusterizersetdistances(&s, &dm, n * d, randombool());
         clusterizersetahcalgo(&s, ahcalgo);
         clusterizerrunahc(&s, &rep);
      // Tests:
      // * replay first D*(N-1) merges; these merges should take place
      //   within clusters, intercluster merges will be performed at the
      //   last stages of the processing.
      // * test with ErrorsInMerges()
         if (rep.npoints != npoints) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < d * (n - 1); i++) {
         // Check correctness of I-th row of Z
            if (rep.z.xyZ[i][0] < 0 || rep.z.xyZ[i][0] >= rep.z.xyZ[i][1] || rep.z.xyZ[i][1] >= d * n + i) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         // Check that merge is performed within cluster
            if (idx.xZ[rep.z.xyZ[i][0]] != idx.xZ[rep.z.xyZ[i][1]]) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         // Write new entry of Idx.
         // Both points from the same cluster, so result of the merge
         // belongs to the same cluster
            idx.xZ[n * d + i] = idx.xZ[rep.z.xyZ[i][1]];
         }
         if (ahcalgo == 0 || ahcalgo == 1 || ahcalgo == 2 || ahcalgo == 4) {
            if (!testclusteringunit_errorsinmerges(&dm, &xy, d * n, d, &rep, ahcalgo)) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
// Test on random D-dimensional problem:
// * D = 2...5
// * N = 1..16 random points from unit hypercube
// * single/complete/unweighted_average linkage/Ward's method are tested
// * different distance functions are tested
// * we call ErrorsInMerges() and we check distance matrix
//   calculated by unit test against one returned by GetDistances()
   ae_vector_set_length(&disttypes, 9);
   disttypes.xZ[0] = 0;
   disttypes.xZ[1] = 1;
   disttypes.xZ[2] = 2;
   disttypes.xZ[3] = 10;
   disttypes.xZ[4] = 11;
   disttypes.xZ[5] = 12;
   disttypes.xZ[6] = 13;
   disttypes.xZ[7] = 20;
   disttypes.xZ[8] = 21;
   for (disttype = 0; disttype < disttypes.cnt; disttype++) {
      for (ahcalgo = 0; ahcalgo <= 4; ahcalgo++) {
         if (ahcalgo == 3) {
            continue;
         }
         if (ahcalgo == 4 && disttype != 2) {
            continue;
         }
         npoints = iround(pow(2.0, (double)randominteger(5)));
         d = 2 + randominteger(4);
      // Generate dataset and distance matrix
         ae_matrix_set_length(&xy, npoints, d);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < d; j++) {
               xy.xyR[i][j] = randomreal();
            }
         }
         ae_matrix_set_length(&dm, npoints, npoints);
         ae_vector_set_length(&x0, d);
         ae_vector_set_length(&x1, d);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < npoints; j++) {
               ae_v_move(x0.xR, 1, xy.xyR[i], 1, d);
               ae_v_move(x1.xR, 1, xy.xyR[j], 1, d);
               dm.xyR[i][j] = testclusteringunit_distfunc(&x0, &x1, d, disttypes.xZ[disttype]);
            }
         }
      // Clusterize
         clusterizercreate(&s);
         clusterizersetpoints(&s, &xy, npoints, d, disttypes.xZ[disttype]);
         clusterizersetahcalgo(&s, ahcalgo);
         clusterizerrunahc(&s, &rep);
      // Test with ErrorsInMerges()
         if (!testclusteringunit_errorsinmerges(&dm, &xy, npoints, d, &rep, ahcalgo)) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      // Test distance matrix
         clusterizergetdistances(&xy, npoints, d, disttypes.xZ[disttype], &dm2);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < npoints; j++) {
               if (!isfinite(dm2.xyR[i][j]) || !NearAtR(dm.xyR[i][j], dm2.xyR[i][j], 1.0E5 * machineepsilon)) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Random normal number
static double testclusteringunit_rnormal() {
   double u;
   double v;
   double s;
   double x1;
   double result;
   while (true) {
      u = randommid();
      v = randommid();
      s = sqr(u) + sqr(v);
      if (s > 0.0 && s < 1.0) {
         s = sqrt(-2 * log(s) / s);
         x1 = u * s;
         break;
      }
   }
   result = x1;
   return result;
}

// Random point from sphere
static void testclusteringunit_rsphere(RMatrix *xy, ae_int_t n, ae_int_t i) {
   ae_int_t j;
   double v;
   for (j = 0; j < n; j++) {
      xy->xyR[i][j] = testclusteringunit_rnormal();
   }
   v = ae_v_dotproduct(xy->xyR[i], 1, xy->xyR[i], 1, n);
   v = randomreal() / sqrt(v);
   ae_v_muld(xy->xyR[i], 1, n, v);
}

// Simple test 1: ellipsoid in NF-dimensional space.
// compare k-means centers with random centers
static bool testclusteringunit_kmeanssimpletest1(ae_int_t nvars, ae_int_t nc, ae_int_t passcount, bool *ConvOkP, bool *OtherOkP) {
   ae_frame _frame_block;
   ae_int_t npoints;
   ae_int_t majoraxis;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   ae_int_t restarts;
   double ekmeans;
   double erandom;
   double dclosest;
   ae_int_t cclosest;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewObj(clusterizerstate, s);
   NewObj(kmeansreport, rep);
   npoints = nc * 100;
   restarts = 5;
   passcount = 10;
   ae_vector_set_length(&tmp, nvars);
   for (pass = 1; pass <= passcount; pass++) {
   // Fill
      ae_matrix_set_length(&xy, npoints, nvars);
      majoraxis = randominteger(nvars);
      for (i = 0; i < npoints; i++) {
         testclusteringunit_rsphere(&xy, nvars, i);
         xy.xyR[i][majoraxis] *= nc;
      }
   // Test
      clusterizercreate(&s);
      clusterizersetpoints(&s, &xy, npoints, nvars, 2);
      clusterizersetkmeanslimits(&s, restarts, 0);
      clusterizerrunkmeans(&s, nc, &rep);
      if (rep.terminationtype <= 0) {
         *ConvOkP = false;
         ae_frame_leave();
         return Ok;
      }
   // Test that XYC is correct mapping to cluster centers
      for (i = 0; i < npoints; i++) {
         cclosest = -1;
         dclosest = maxrealnumber;
         for (j = 0; j < nc; j++) {
            ae_v_move(tmp.xR, 1, xy.xyR[i], 1, nvars);
            ae_v_sub(tmp.xR, 1, rep.c.xyR[j], 1, nvars);
            v = ae_v_dotproduct(tmp.xR, 1, tmp.xR, 1, nvars);
            if (v < dclosest) {
               cclosest = j;
               dclosest = v;
            }
         }
         if (cclosest != rep.cidx.xZ[i]) {
            *OtherOkP = false;
            ae_frame_leave();
            return Ok;
         }
      }
   // Use first NC rows of XY as random centers
   // (XY is totally random, so it is as good as any other choice).
   //
   // Compare potential functions.
      ekmeans = 0.0;
      for (i = 0; i < npoints; i++) {
         ae_v_move(tmp.xR, 1, xy.xyR[i], 1, nvars);
         ae_v_sub(tmp.xR, 1, rep.c.xyR[rep.cidx.xZ[i]], 1, nvars);
         v = ae_v_dotproduct(tmp.xR, 1, tmp.xR, 1, nvars);
         ekmeans += v;
      }
      erandom = 0.0;
      for (i = 0; i < npoints; i++) {
         dclosest = maxrealnumber;
         v = 0.0;
         for (j = 0; j < nc; j++) {
            ae_v_move(tmp.xR, 1, xy.xyR[i], 1, nvars);
            ae_v_sub(tmp.xR, 1, xy.xyR[j], 1, nvars);
            v = ae_v_dotproduct(tmp.xR, 1, tmp.xR, 1, nvars);
            if (v < dclosest) {
               dclosest = v;
            }
         }
         erandom += v;
      }
      if (erandom < ekmeans) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   ae_frame_leave();
   return Ok;
}

// This procedure is a reference version of KMeansUpdateDistances().
//
// Inputs:
//     XY          -   dataset, array [0..NPoints-1,0..NVars-1].
//     NPoints     -   dataset size, NPoints >= K
//     NVars       -   number of variables, NVars >= 1
//     CT          -   matrix of centers, centers are stored in rows
//     K           -   number of centers, K >= 1
//     XYC         -   preallocated output buffer
//     XYDist2     -   preallocated output buffer
//
// Outputs:
//     XYC         -   new assignment of points to centers
//     XYDist2     -   squared distances
// ALGLIB: Copyright 21.01.2015 by Sergey Bochkanov
static void testclusteringunit_kmeansreferenceupdatedistances(RMatrix *xy, ae_int_t npoints, ae_int_t nvars, RMatrix *ct, ae_int_t k, ZVector *xyc, RVector *xydist2) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t cclosest;
   double dclosest;
   double v;
   ae_frame_make(&_frame_block);
   NewVector(tmp, 0, DT_REAL);
   ae_vector_set_length(&tmp, nvars);
   for (i = 0; i < npoints; i++) {
      cclosest = -1;
      dclosest = maxrealnumber;
      for (j = 0; j < k; j++) {
         ae_v_move(tmp.xR, 1, xy->xyR[i], 1, nvars);
         ae_v_sub(tmp.xR, 1, ct->xyR[j], 1, nvars);
         v = ae_v_dotproduct(tmp.xR, 1, tmp.xR, 1, nvars);
         if (v < dclosest) {
            cclosest = j;
            dclosest = v;
         }
      }
      ae_assert(cclosest >= 0, "KMeansUpdateDistances: internal error");
      xyc->xZ[i] = cclosest;
      xydist2->xR[i] = dclosest;
   }
   ae_frame_leave();
}

// This test perform several checks for special properties
static bool testclusteringunit_kmeansspecialtests() {
   ae_frame _frame_block;
   ae_int_t npoints;
   ae_int_t nfeatures;
   ae_int_t nclusters;
   ae_int_t initalgo;
   ae_int_t idx0;
   ae_int_t idx1;
   ae_int_t idx2;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t separation;
   bool allsame;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(xyc, 0, DT_INT);
   NewVector(xycref, 0, DT_INT);
   NewVector(xydist2, 0, DT_REAL);
   NewVector(xydist2ref, 0, DT_REAL);
   NewVector(energies, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   NewObj(clusterizerstate, s);
   NewObj(kmeansreport, rep);
   NewObj(ae_shared_pool, bufferpool);
   NewObj(apbuffers, bufferseed);
   NewVector(pointslist, 0, DT_INT);
   NewVector(featureslist, 0, DT_INT);
   NewVector(clusterslist, 0, DT_INT);
   hqrndrandomize(&rs);
// Compare different initialization algorithms:
// * dataset is K balls, chosen at random gaussian points, with
//   radius equal to 2^(-Separation).
// * we generate random sample, run k-means initialization algorithm
//   and calculate mean energy for each initialization algorithm.
//   In order to suppress Lloyd's iteration we use KmeansDbgNoIts
//   debug flag.
// * then, we compare mean energies; kmeans++ must be best one,
//   random initialization must be worst one.
   ae_vector_set_length(&energies, 4);
   passcount = 1000;
   npoints = 100;
   nfeatures = 3;
   nclusters = 6;
   ae_matrix_set_length(&xy, npoints, nfeatures);
   ae_matrix_set_length(&c, nclusters, nfeatures);
   clusterizercreate(&s);
   s.kmeansdbgnoits = true;
   for (separation = 2; separation <= 5; separation++) {
   // Try different init algorithms
      for (initalgo = 1; initalgo <= 3; initalgo++) {
         energies.xR[initalgo] = 0.0;
         clusterizersetkmeansinit(&s, initalgo);
         for (pass = 1; pass <= passcount; pass++) {
         // Generate centers of balls
            for (i = 0; i < nclusters; i++) {
               for (j = 0; j < nfeatures; j++) {
                  c.xyR[i][j] = hqrndnormal(&rs);
               }
            }
         // Generate points
            for (i = 0; i < npoints; i++) {
               for (j = 0; j < nfeatures; j++) {
                  xy.xyR[i][j] = hqrndnormal(&rs) * pow(2.0, (double)-separation) + c.xyR[i % nclusters][j];
               }
            }
         // Run clusterization
            clusterizersetpoints(&s, &xy, npoints, nfeatures, 2);
            clusterizerrunkmeans(&s, nclusters, &rep);
            Ok = Ok && rep.terminationtype > 0;
            energies.xR[initalgo] += rep.energy / passcount;
         }
      }
   // Compare
      Ok = Ok && energies.xR[2] < energies.xR[1];
      Ok = Ok && energies.xR[3] < energies.xR[1];
   }
// Test distance calculation algorithm
   ae_vector_set_length(&pointslist, 6);
   pointslist.xZ[0] = 1;
   pointslist.xZ[1] = 10;
   pointslist.xZ[2] = 32;
   pointslist.xZ[3] = 100;
   pointslist.xZ[4] = 512;
   pointslist.xZ[5] = 8000;
   ae_vector_set_length(&featureslist, 5);
   featureslist.xZ[0] = 1;
   featureslist.xZ[1] = 5;
   featureslist.xZ[2] = 32;
   featureslist.xZ[3] = 50;
   featureslist.xZ[4] = 96;
   ae_vector_set_length(&clusterslist, 5);
   clusterslist.xZ[0] = 1;
   clusterslist.xZ[1] = 5;
   clusterslist.xZ[2] = 32;
   clusterslist.xZ[3] = 50;
   clusterslist.xZ[4] = 96;
   ae_shared_pool_set_seed(&bufferpool, &bufferseed, sizeof(bufferseed), apbuffers_init, apbuffers_copy, apbuffers_free);
   for (idx0 = 0; idx0 < pointslist.cnt; idx0++) {
      for (idx1 = 0; idx1 < featureslist.cnt; idx1++) {
         for (idx2 = 0; idx2 < clusterslist.cnt; idx2++) {
            npoints = pointslist.xZ[idx0];
            nfeatures = featureslist.xZ[idx1];
            nclusters = clusterslist.xZ[idx2];
            ae_matrix_set_length(&xy, npoints, nfeatures);
            for (i = 0; i < npoints; i++) {
               for (j = 0; j < nfeatures; j++) {
                  xy.xyR[i][j] = hqrndnormal(&rs);
               }
            }
            ae_matrix_set_length(&c, nclusters, nfeatures);
            for (i = 0; i < nclusters; i++) {
               for (j = 0; j < nfeatures; j++) {
                  c.xyR[i][j] = hqrndnormal(&rs);
               }
            }
            ae_vector_set_length(&xyc, npoints);
            ae_vector_set_length(&xycref, npoints);
            ae_vector_set_length(&xydist2, npoints);
            ae_vector_set_length(&xydist2ref, npoints);
         // Test
            kmeansupdatedistances(&xy, 0, npoints, nfeatures, &c, 0, nclusters, &xyc, &xydist2, &bufferpool);
            testclusteringunit_kmeansreferenceupdatedistances(&xy, npoints, nfeatures, &c, nclusters, &xycref, &xydist2ref);
            for (i = 0; i < npoints; i++) {
               Ok = Ok && xyc.xZ[i] == xycref.xZ[i];
               Ok = Ok && NearAtR(xydist2.xR[i], xydist2ref.xR[i], 1.0E-6);
            }
         }
      }
   }
// Test degenerate dataset (less than NClusters distinct points)
   for (nclusters = 2; nclusters <= 10; nclusters++) {
      for (initalgo = 0; initalgo <= 3; initalgo++) {
         for (pass = 1; pass <= 10; pass++) {
         // Initialize points. Two algorithms are used:
         // * initialization by small integers (no rounding problems)
         // * initialization by "long" fraction
            npoints = 100;
            nfeatures = 10;
            ae_matrix_set_length(&xy, npoints, nfeatures);
            if (hqrndnormal(&rs) > 0.0) {
               for (i = 0; i < nclusters - 1; i++) {
                  for (j = 0; j < nfeatures; j++) {
                     xy.xyR[i][j] = sin(hqrndnormal(&rs));
                  }
               }
            } else {
               for (i = 0; i < nclusters - 1; i++) {
                  for (j = 0; j < nfeatures; j++) {
                     xy.xyR[i][j] = (double)hqrnduniformi(&rs, 50);
                  }
               }
            }
            for (i = nclusters - 1; i < npoints; i++) {
               idx0 = hqrnduniformi(&rs, nclusters - 1);
               for (j = 0; j < nfeatures; j++) {
                  xy.xyR[i][j] = xy.xyR[idx0][j];
               }
            }
         // Clusterize with unlimited number of iterations.
         // Correct error code must be returned.
            clusterizercreate(&s);
            clusterizersetpoints(&s, &xy, npoints, nfeatures, 2);
            clusterizersetkmeanslimits(&s, 1, 0);
            clusterizersetkmeansinit(&s, initalgo);
            clusterizerrunkmeans(&s, nclusters, &rep);
            Ok = Ok && rep.terminationtype == -3;
         }
      }
   }
// Test deterministic seed:
// * specyfying zero seed, or not specyfind seed at all = nondeterministic algo
// * nonzero zeed = deterministic algo
   for (initalgo = 0; initalgo <= 3; initalgo++) {
   // Initialize points.
      npoints = 100;
      nfeatures = 3;
      ae_matrix_set_length(&xy, npoints, nfeatures);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nfeatures; j++) {
            xy.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Clusterize with negative seed.
   //
   // Perform multiple runs, compare results with
   // first one returned - at least one result must
   // be different.
      clusterizercreate(&s);
      clusterizersetpoints(&s, &xy, npoints, nfeatures, 2);
      clusterizersetkmeanslimits(&s, 1, 1);
      clusterizersetkmeansinit(&s, initalgo);
      clusterizersetseed(&s, -randominteger(3));
      allsame = true;
      for (pass = 0; pass <= 10; pass++) {
         clusterizerrunkmeans(&s, nclusters, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         if (pass == 0) {
         // Save clusters
            ae_matrix_set_length(&c, rep.c.rows, rep.c.cols);
            for (i = 0; i < rep.c.rows; i++) {
               for (j = 0; j < rep.c.cols; j++) {
                  c.xyR[i][j] = rep.c.xyR[i][j];
               }
            }
         } else {
         // Compare clusters with ones returned from first run.
            for (i = 0; i < rep.c.rows; i++) {
               for (j = 0; j < rep.c.cols; j++) {
                  allsame = allsame && c.xyR[i][j] == rep.c.xyR[i][j];
               }
            }
         }
      }
      Ok = Ok && !allsame;
   // Clusterize with positive seed.
   //
   // Perform multiple runs, compare results with
   // first one returned - all results must be same.
      clusterizercreate(&s);
      clusterizersetpoints(&s, &xy, npoints, nfeatures, 2);
      clusterizersetkmeanslimits(&s, 1, 1);
      clusterizersetkmeansinit(&s, initalgo);
      clusterizersetseed(&s, 1 + randominteger(3));
      allsame = true;
      for (pass = 0; pass <= 10; pass++) {
         clusterizerrunkmeans(&s, nclusters, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         if (pass == 0) {
         // Save clusters
            ae_matrix_set_length(&c, rep.c.rows, rep.c.cols);
            for (i = 0; i < rep.c.rows; i++) {
               for (j = 0; j < rep.c.cols; j++) {
                  c.xyR[i][j] = rep.c.xyR[i][j];
               }
            }
         } else {
         // Compare clusters with ones returned from first run.
            for (i = 0; i < rep.c.rows; i++) {
               for (j = 0; j < rep.c.cols; j++) {
                  allsame = allsame && c.xyR[i][j] == rep.c.xyR[i][j];
               }
            }
         }
      }
      Ok = Ok && allsame;
   // Clusterize with default seed.
   //
   // Perform multiple runs, compare results with
   // first one returned - all results must be same.
      clusterizercreate(&s);
      clusterizersetpoints(&s, &xy, npoints, nfeatures, 2);
      clusterizersetkmeanslimits(&s, 1, 1);
      clusterizersetkmeansinit(&s, initalgo);
      allsame = true;
      for (pass = 0; pass <= 10; pass++) {
         clusterizerrunkmeans(&s, nclusters, &rep);
         Ok = Ok && rep.terminationtype > 0;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         if (pass == 0) {
         // Save clusters
            ae_matrix_set_length(&c, rep.c.rows, rep.c.cols);
            for (i = 0; i < rep.c.rows; i++) {
               for (j = 0; j < rep.c.cols; j++) {
                  c.xyR[i][j] = rep.c.xyR[i][j];
               }
            }
         } else {
         // Compare clusters with ones returned from first run.
            for (i = 0; i < rep.c.rows; i++) {
               for (j = 0; j < rep.c.cols; j++) {
                  allsame = allsame && c.xyR[i][j] == rep.c.xyR[i][j];
               }
            }
         }
      }
      Ok = Ok && allsame;
   }
   ae_frame_leave();
   return Ok;
}

// This test checks algorithm ability to handle degenerate problems without
// causing infinite loop.
static bool testclusteringunit_kmeansinfinitelooptest() {
   ae_frame _frame_block;
   ae_int_t npoints;
   ae_int_t nfeatures;
   ae_int_t nclusters;
   ae_int_t restarts;
   ae_int_t i;
   ae_int_t j;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(clusterizerstate, s);
   NewObj(kmeansreport, rep);
// Problem 1: all points are same.
//
// For NClusters == 1 we must get correct solution, for NClusters > 1 we must get failure.
   npoints = 100;
   nfeatures = 1;
   restarts = 5;
   ae_matrix_set_length(&xy, npoints, nfeatures);
   for (j = 0; j < nfeatures; j++) {
      xy.xyR[0][j] = randomreal();
   }
   for (i = 1; i < npoints; i++) {
      for (j = 0; j < nfeatures; j++) {
         xy.xyR[i][j] = xy.xyR[0][j];
      }
   }
   nclusters = 1;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, npoints, nfeatures, 2);
   clusterizersetkmeanslimits(&s, restarts, 0);
   clusterizerrunkmeans(&s, nclusters, &rep);
   Ok = Ok && rep.terminationtype > 0;
   for (i = 0; i < nfeatures; i++) {
      Ok = Ok && NearAtR(rep.c.xyR[0][i], xy.xyR[0][i], 1000.0 * machineepsilon);
   }
   for (i = 0; i < npoints; i++) {
      Ok = Ok && rep.cidx.xZ[i] == 0;
   }
   nclusters = 5;
   clusterizerrunkmeans(&s, nclusters, &rep);
   Ok = Ok && rep.terminationtype <= 0;
// Problem 2: degenerate dataset (report by Andreas).
   npoints = 57;
   nfeatures = 1;
   restarts = 1;
   nclusters = 4;
   ae_matrix_set_length(&xy, npoints, nfeatures);
   xy.xyR[0][0] = 12.244689632138986;
   xy.xyR[1][0] = 12.244689632138982;
   xy.xyR[2][0] = 12.244689632138986;
   xy.xyR[3][0] = 12.244689632138982;
   xy.xyR[4][0] = 12.244689632138986;
   xy.xyR[5][0] = 12.244689632138986;
   xy.xyR[6][0] = 12.244689632138986;
   xy.xyR[7][0] = 12.244689632138986;
   xy.xyR[8][0] = 12.244689632138986;
   xy.xyR[9][0] = 12.244689632138986;
   xy.xyR[10][0] = 12.244689632138989;
   xy.xyR[11][0] = 12.244689632138984;
   xy.xyR[12][0] = 12.244689632138986;
   xy.xyR[13][0] = 12.244689632138986;
   xy.xyR[14][0] = 12.244689632138989;
   xy.xyR[15][0] = 12.244689632138986;
   xy.xyR[16][0] = 12.244689632138986;
   xy.xyR[17][0] = 12.244689632138986;
   xy.xyR[18][0] = 12.244689632138986;
   xy.xyR[19][0] = 12.244689632138989;
   xy.xyR[20][0] = 12.244689632138972;
   xy.xyR[21][0] = 12.244689632138986;
   xy.xyR[22][0] = 12.244689632138986;
   xy.xyR[23][0] = 12.244689632138986;
   xy.xyR[24][0] = 12.244689632138984;
   xy.xyR[25][0] = 12.244689632138982;
   xy.xyR[26][0] = 12.244689632138986;
   xy.xyR[27][0] = 12.244689632138986;
   xy.xyR[28][0] = 12.244689632138986;
   xy.xyR[29][0] = 12.244689632138986;
   xy.xyR[30][0] = 12.244689632138986;
   xy.xyR[31][0] = 12.244689632138986;
   xy.xyR[32][0] = 12.244689632138986;
   xy.xyR[33][0] = 12.244689632138986;
   xy.xyR[34][0] = 12.244689632138986;
   xy.xyR[35][0] = 12.244689632138982;
   xy.xyR[36][0] = 12.244689632138989;
   xy.xyR[37][0] = 12.244689632138986;
   xy.xyR[38][0] = 12.244689632138986;
   xy.xyR[39][0] = 12.244689632138986;
   xy.xyR[40][0] = 12.244689632138986;
   xy.xyR[41][0] = 12.244689632138986;
   xy.xyR[42][0] = 12.244689632138986;
   xy.xyR[43][0] = 12.244689632138986;
   xy.xyR[44][0] = 12.244689632138986;
   xy.xyR[45][0] = 12.244689632138986;
   xy.xyR[46][0] = 12.244689632138986;
   xy.xyR[47][0] = 12.244689632138986;
   xy.xyR[48][0] = 12.244689632138986;
   xy.xyR[49][0] = 12.244689632138986;
   xy.xyR[50][0] = 12.244689632138984;
   xy.xyR[51][0] = 12.244689632138986;
   xy.xyR[52][0] = 12.244689632138986;
   xy.xyR[53][0] = 12.244689632138986;
   xy.xyR[54][0] = 12.244689632138986;
   xy.xyR[55][0] = 12.244689632138986;
   xy.xyR[56][0] = 12.244689632138986;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, npoints, nfeatures, 2);
   clusterizersetkmeanslimits(&s, restarts, 0);
   clusterizerrunkmeans(&s, nclusters, &rep);
   Ok = Ok && rep.terminationtype > 0;
   ae_frame_leave();
   return Ok;
}

// This non-deterministic test checks that Restarts > 1 significantly  improves
// quality of results.
//
// Subroutine generates random task 3 unit balls in 2D, each with 20  points,
// separated by 5 units wide gaps, and solves it  with  Restarts == 1  and  with
// Restarts == 5. Potential functions are compared,  outcome  of  the  trial  is
// either 0 or 1 (depending on what is better).
//
// Sequence of 1000 such tasks is  solved.  If  Restarts > 1  actually  improve
// quality of solution, sum of outcome will be non-binomial.  If  it  doesn't
// matter, it will be binomially distributed.
//
// P.S. This test was added after report from Gianluca  Borello  who  noticed
// error in the handling of multiple restarts.
static bool testclusteringunit_kmeansrestartstest(bool *ConvOkP) {
   ae_frame _frame_block;
   ae_int_t npoints;
   ae_int_t nvars;
   ae_int_t nclusters;
   ae_int_t clustersize;
   ae_int_t restarts;
   ae_int_t passcount;
   double sigmathreshold;
   double p;
   double s;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   double ea;
   double eb;
   double v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewObj(clusterizerstate, state);
   NewObj(kmeansreport, rep1);
   NewObj(kmeansreport, rep2);
   restarts = 5;
   passcount = 1000;
   clustersize = 20;
   nclusters = 3;
   nvars = 2;
   npoints = nclusters * clustersize;
   sigmathreshold = 5.0;
   ae_matrix_set_length(&xy, npoints, nvars);
   ae_vector_set_length(&tmp, nvars);
   p = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
   // Fill
      for (i = 0; i < npoints; i++) {
         testclusteringunit_rsphere(&xy, nvars, i);
         for (j = 0; j < nvars; j++) {
            xy.xyR[i][j] += (double)i / clustersize * 5;
         }
      }
      clusterizercreate(&state);
      clusterizersetpoints(&state, &xy, npoints, nvars, 2);
   // Test: Restarts == 1
      clusterizersetkmeanslimits(&state, 1, 0);
      clusterizerrunkmeans(&state, nclusters, &rep1);
      if (rep1.terminationtype <= 0) {
         *ConvOkP = false;
         ae_frame_leave();
         return Ok;
      }
      ea = 0.0;
      for (i = 0; i < npoints; i++) {
         ae_v_move(tmp.xR, 1, xy.xyR[i], 1, nvars);
         ae_v_sub(tmp.xR, 1, rep1.c.xyR[rep1.cidx.xZ[i]], 1, nvars);
         v = ae_v_dotproduct(tmp.xR, 1, tmp.xR, 1, nvars);
         ea += v;
      }
   // Test: Restarts > 1
      clusterizersetkmeanslimits(&state, restarts, 0);
      clusterizerrunkmeans(&state, nclusters, &rep2);
      if (rep2.terminationtype <= 0) {
         *ConvOkP = false;
         ae_frame_leave();
         return Ok;
      }
      eb = 0.0;
      for (i = 0; i < npoints; i++) {
         ae_v_move(tmp.xR, 1, xy.xyR[i], 1, nvars);
         ae_v_sub(tmp.xR, 1, rep2.c.xyR[rep2.cidx.xZ[i]], 1, nvars);
         v = ae_v_dotproduct(tmp.xR, 1, tmp.xR, 1, nvars);
         eb += v;
      }
   // Calculate statistic.
      if (ea < eb) {
         p++;
      }
      if (ea == eb) {
         p += 0.5;
      }
   }
// If Restarts doesn't influence quality of centers found, P must be
// binomially distributed random value with mean 0.5*PassCount and
// standard deviation sqrt(PassCount/4).
//
// If Restarts do influence quality of solution, P must be significantly
// lower than 0.5*PassCount.
   s = (p - 0.5 * passcount) / sqrt((double)passcount / 4.0);
   Ok = Ok && s <= -sigmathreshold;
   ae_frame_leave();
   return Ok;
}

// Testing clustering
bool testclustering() {
   bool Ok;
   ae_int_t passcount;
   ae_int_t nf;
   ae_int_t nc;
// AHC tests
   bool basicahcOk = testclusteringunit_basicahctests();
   bool generalahcOk = testclusteringunit_advancedahctests();
   bool ahcOk = basicahcOk && generalahcOk;
// k-means tests
   passcount = 10;
   bool kmeansotherOk = testclusteringunit_kmeansspecialtests() && testclusteringunit_kmeansinfinitelooptest();
   bool kmeansconvOk = true;
   bool kmeansrestartsOk = testclusteringunit_kmeansrestartstest(&kmeansconvOk); //(@)
   bool kmeanssimpleOk = true;
   for (nf = 1; nf <= 5; nf++) {
      for (nc = 1; nc <= 5; nc++) {
         kmeanssimpleOk = kmeanssimpleOk && testclusteringunit_kmeanssimpletest1(nf, nc, passcount, &kmeansconvOk, &kmeansotherOk);
      }
   }
   bool kmeansOk = kmeansconvOk && kmeansotherOk && kmeanssimpleOk && kmeansrestartsOk;
// The final report.
   Ok = ahcOk && kmeansOk;
   if (!Ok || !silent) {
      printf("Clustering Tests\n");
      printf("* AHC:                                    %s\n", ahcOk? "Ok": "Failed");
      if (!ahcOk) {
         printf("* - Basic Tests:                          %s\n", basicahcOk? "Ok": "Failed");
         printf("* - General Tests:                        %s\n", generalahcOk? "Ok": "Failed");
      }
      printf("* K-Means:                                %s\n", kmeansOk? "Ok": "Failed");
      if (!kmeansOk) {
         printf("* - Convergence:                          %s\n", kmeansconvOk? "Ok": "Failed");
         printf("* - Simple Tasks:                         %s\n", kmeanssimpleOk? "Ok": "Failed");
         printf("* - Other Properties:                     %s\n", kmeansotherOk? "Ok": "Failed");
         printf("* - Restarts Properties:                  %s\n", kmeansrestartsOk? "Ok": "Failed");
      }
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === dforest testing unit ===
static const ae_int_t testdforestunit_algomax = 0;
static const ae_int_t testdforestunit_splitmax = 2;

// Unsets DF
static void testdforestunit_unsetdf(decisionforest *df) {
   ae_frame _frame_block;
   ae_int_t info;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(dfreport, rep);
   ae_matrix_set_length(&xy, 0 + 1, 1 + 1);
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = 0.0;
   dfbuildinternal(&xy, 1, 1, 1, 1, 1, 1, 0, &info, df, &rep);
   ae_frame_leave();
}

// Processing functions test
static bool testdforestunit_testprocessing() {
   ae_frame _frame_block;
   ae_int_t nvars;
   ae_int_t nclasses;
   ae_int_t ntrees;
   ae_int_t foresttype;
   ae_int_t npoints;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   bool allsame;
   double v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(decisionforest, df1);
   NewObj(decisionforest, df2);
   NewObj(decisionforestbuilder, builder);
   NewObj(dfreport, rep);
   NewObj(decisionforestbuffer, buf);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   passcount = 100;
   hqrndrandomize(&rs);
// Main cycle
   for (pass = 1; pass <= passcount; pass++) {
   // initialize parameters
      nvars = 1 + hqrnduniformi(&rs, 5);
      nclasses = 1 + hqrnduniformi(&rs, 3);
      ntrees = 1 + hqrnduniformi(&rs, 4);
      foresttype = hqrnduniformi(&rs, 3);
   // Initialize arrays and data
      npoints = 10 + randominteger(50);
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      ae_vector_set_length(&y1, nclasses);
      ae_vector_set_length(&y2, nclasses);
      ae_matrix_set_length(&xy, npoints, nvars + 1);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            if (j % 2 == 0) {
               xy.xyR[i][j] = randommid();
            } else {
               xy.xyR[i][j] = (double)randominteger(2);
            }
         }
         if (nclasses == 1) {
            xy.xyR[i][nvars] = randommid();
         } else {
            xy.xyR[i][nvars] = (double)randominteger(nclasses);
         }
      }
   // create forest
      dfbuildercreate(&builder);
      dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
      dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
      dfbuildersetrdfsplitstrength(&builder, randominteger(testdforestunit_splitmax + 1));
      if (foresttype == 0) {
      // Build uncompressed random forest
         dfbuilderbuildrandomforest(&builder, ntrees, &df1, &rep);
      }
      if (foresttype == 1) {
      // Build uncompressed random forest, then perform 16-bit compression
         dfbuilderbuildrandomforest(&builder, ntrees, &df1, &rep);
         dfbinarycompression(&df1);
      }
      if (foresttype == 2) {
      // Build uncompressed random forest, then perform 8-bit compression
         dfbuilderbuildrandomforest(&builder, ntrees, &df1, &rep);
         dfbinarycompression8(&df1);
      }
      dfcreatebuffer(&df1, &buf);
   // Same inputs leads to same outputs
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nclasses; i++) {
         y1.xR[i] = randommid();
         y2.xR[i] = randommid();
      }
      dfprocess(&df1, &x1, &y1);
      dfprocess(&df1, &x2, &y2);
      allsame = true;
      for (i = 0; i < nclasses; i++) {
         allsame = allsame && y1.xR[i] == y2.xR[i];
      }
      Ok = Ok && allsame;
   // DFProcess0 works as expected
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      ae_vector_set_length(&y1, nclasses);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nclasses; i++) {
         y1.xR[i] = hqrndnormal(&rs);
      }
      dfprocess(&df1, &x1, &y1);
      Ok = Ok && NearAtR(y1.xR[0], dfprocess0(&df1, &x2), 100.0 * machineepsilon);
   // DFClassify works as expected
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      ae_vector_set_length(&y1, nclasses);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      if (nclasses > 1) {
         for (i = 0; i < nclasses; i++) {
            y1.xR[i] = hqrndnormal(&rs);
         }
         dfprocess(&df1, &x1, &y1);
         j = dfclassify(&df1, &x2);
         for (i = 0; i < nclasses; i++) {
            Ok = Ok && y1.xR[i] <= y1.xR[j];
         }
      } else {
         Ok = Ok && dfclassify(&df1, &x2) == -1;
      }
   // DFTsProcess() works as expected
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nclasses; i++) {
         y1.xR[i] = randommid();
         y2.xR[i] = randommid();
      }
      dfprocess(&df1, &x1, &y1);
      dftsprocess(&df1, &buf, &x2, &y2);
      allsame = true;
      for (i = 0; i < nclasses; i++) {
         allsame = allsame && y1.xR[i] == y2.xR[i];
      }
      Ok = Ok && allsame;
   // Same inputs on original forest leads to same outputs
   // on copy created using DFCopy
      testdforestunit_unsetdf(&df2);
      dfcopy(&df1, &df2);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nclasses; i++) {
         y1.xR[i] = randommid();
         y2.xR[i] = randommid();
      }
      dfprocess(&df1, &x1, &y1);
      dfprocess(&df2, &x2, &y2);
      allsame = true;
      for (i = 0; i < nclasses; i++) {
         allsame = allsame && y1.xR[i] == y2.xR[i];
      }
      Ok = Ok && allsame;
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      Ok = Ok && NearAtR(dfprocess0(&df1, &x1), dfprocess0(&df2, &x2), 100.0 * machineepsilon);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      Ok = Ok && dfclassify(&df1, &x1) == dfclassify(&df2, &x2);
   // Same inputs on original forest leads to same outputs
   // on copy created using DFSerialize
      testdforestunit_unsetdf(&df2);
      {
      // This code passes data structure through serializers
      // (serializes it to string and loads back)
         ae_frame _local_frame_block;
         ae_frame_make(&_local_frame_block);
         NewSerializer(_local_serializer);
         ae_serializer_alloc_start(&_local_serializer);
         dfalloc(&_local_serializer, &df1);
         ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
         NewBlock(_local_dynamic_block, _local_ssize + 1);
         ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
         dfserialize(&_local_serializer, &df1);
         ae_serializer_stop(&_local_serializer);
         ae_serializer_init(&_local_serializer);
         ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
         dfunserialize(&_local_serializer, &df2);
         ae_serializer_stop(&_local_serializer);
         ae_frame_leave();
      }
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nclasses; i++) {
         y1.xR[i] = randommid();
         y2.xR[i] = randommid();
      }
      dfprocess(&df1, &x1, &y1);
      dfprocess(&df2, &x2, &y2);
      allsame = true;
      for (i = 0; i < nclasses; i++) {
         allsame = allsame && y1.xR[i] == y2.xR[i];
      }
      Ok = Ok && allsame;
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      Ok = Ok && NearAtR(dfprocess0(&df1, &x1), dfprocess0(&df2, &x2), 100.0 * machineepsilon);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      Ok = Ok && dfclassify(&df1, &x1) == dfclassify(&df2, &x2);
   // Normalization properties
      if (nclasses > 1) {
         for (i = 0; i < nvars; i++) {
            x1.xR[i] = randommid();
         }
         dfprocess(&df1, &x1, &y1);
         v = 0.0;
         for (i = 0; i < nclasses; i++) {
            v += y1.xR[i];
            Ok = Ok && y1.xR[i] >= 0.0;
         }
         Ok = Ok && NearAtR(v, 1, 1000.0 * machineepsilon);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Basic test:  one-tree uncompressed forest built using full sample must
// remember all training cases.
//
// Special relaxed testing is performed for compressed forests.
static bool testdforestunit_basictest1() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t i;
   ae_int_t j;
   double s;
   ae_int_t info;
   ae_int_t nvars;
   ae_int_t nclasses;
   ae_int_t passcount;
   double tol16;
   double tol8;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforestbuilder, builder);
   NewObj(decisionforest, df);
   NewObj(decisionforest, df1);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(dfreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   tol16 = 0.0001;
   tol8 = 0.01;
// Test uncompressed forest
   passcount = 10;
   for (nvars = 1; nvars <= 4; nvars++) {
      for (nclasses = 1; nclasses <= 3; nclasses++) {
         for (pass = 0; pass < passcount; pass++) {
         // select number of points
            if (pass < 3 && passcount > 3) {
               npoints = 1 + pass;
            } else {
               npoints = 100 + hqrnduniformi(&rs, 100);
            }
         // Prepare task
            ae_matrix_set_length(&xy, npoints, nvars + 1);
            ae_vector_set_length(&x, nvars);
            ae_vector_set_length(&y, nclasses);
            for (i = 0; i < npoints; i++) {
               xy.xyR[i][0] = (double)i;
               for (j = 1; j < nvars; j++) {
                  xy.xyR[i][j] = hqrndnormal(&rs);
               }
               if (nclasses > 1) {
                  xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
               } else {
                  xy.xyR[i][nvars] = hqrndnormal(&rs);
               }
            }
         // Train
         //
         // NOTE: we also test obsolete forest construction functions
            ae_assert(passcount >= 2, "RDF: test integrity failed");
            ntrees = 1;
            if (pass > 0) {
            // Test new interface
               dfbuildercreate(&builder);
               dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
               dfbuildersetsubsampleratio(&builder, 1.0);
               if (randombool()) {
                  dfbuildersetrndvars(&builder, nvars);
               } else {
                  dfbuildersetrndvarsratio(&builder, 1.0);
               }
               dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
               dfbuildersetrdfsplitstrength(&builder, randominteger(testdforestunit_splitmax + 1));
               dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
            } else {
            // Test old interface
               if (hqrnduniformi(&rs, 2) == 0) {
                  dfbuildrandomdecisionforest(&xy, npoints, nvars, nclasses, ntrees, 1.0, &info, &df, &rep);
               } else {
                  dfbuildrandomdecisionforestx1(&xy, npoints, nvars, nclasses, ntrees, 1, 1.0, &info, &df, &rep);
               }
               if (info <= 0) {
                  Ok = false;
                  ae_frame_leave();
                  return Ok;
               }
            }
         // Test
            Ok = Ok && SmallAtR(rep.rmserror, 1.0E-9);
            Ok = Ok && SmallAtR(rep.avgerror, 1.0E-9);
            Ok = Ok && SmallAtR(rep.avgrelerror, 1.0E-9);
            Ok = Ok && SmallAtR(rep.relclserror, 0.0);
            Ok = Ok && SmallAtR(rep.avgce, 0.0);
            for (i = 0; i < npoints; i++) {
               ae_v_move(x.xR, 1, xy.xyR[i], 1, nvars);
               dfprocess(&df, &x, &y);
               if (nclasses > 1) {
               // Checks for classification tasks
                  s = 0.0;
                  for (j = 0; j < nclasses; j++) {
                     Ok = Ok && y.xR[j] >= 0.0;
                     s += y.xR[j];
                  }
                  Ok = Ok && NearAtR(s, 1.0, 1000.0 * machineepsilon);
                  Ok = Ok && NearAtR(y.xR[iround(xy.xyR[i][nvars])], 1.0, 1000.0 * machineepsilon);
               } else {
               // Regression problem
                  Ok = Ok && NearAtR(y.xR[0], xy.xyR[i][nvars], 1000.0 * machineepsilon);
               }
            }
         }
      }
   }
// Test compressed forest
   nvars = 1;
   npoints = 100;
   for (nclasses = 1; nclasses <= 3; nclasses++) {
      for (pass = 0; pass < passcount; pass++) {
      // Dataset
         ae_matrix_set_length(&xy, npoints, nvars + 1);
         ae_vector_set_length(&x, nvars);
         ae_vector_set_length(&y, nclasses);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = (double)i;
            if (nclasses > 1) {
               xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
            } else {
               xy.xyR[i][nvars] = hqrnduniformr(&rs) - 0.5;
            }
         }
      // Train
         ntrees = 1;
         dfbuildercreate(&builder);
         dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
         dfbuildersetsubsampleratio(&builder, 1.0);
         dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
         Ok = Ok && SmallAtR(rep.rmserror, 1.0E-9);
         Ok = Ok && SmallAtR(rep.avgerror, 1.0E-9);
         Ok = Ok && SmallAtR(rep.avgrelerror, 1.0E-9);
         Ok = Ok && SmallAtR(rep.relclserror, 0.0);
         Ok = Ok && SmallAtR(rep.avgce, 0.0);
      // Test 16-bit compression
         dfcopy(&df, &df1);
         dfbinarycompression(&df1);
         for (i = 0; i < npoints; i++) {
            x.xR[0] = xy.xyR[i][0];
            dfprocess(&df1, &x, &y);
            if (nclasses > 1) {
            // Checks for classification tasks
               s = 0.0;
               for (j = 0; j < nclasses; j++) {
                  Ok = Ok && y.xR[j] >= 0.0;
                  s += y.xR[j];
               }
               Ok = Ok && NearAtR(s, 1.0, 1000.0 * machineepsilon);
               Ok = Ok && NearAtR(y.xR[iround(xy.xyR[i][nvars])], 1.0, 1000.0 * machineepsilon);
            } else {
            // Regression problem
               Ok = Ok && NearAtR(y.xR[0], xy.xyR[i][nvars], tol16);
            }
         }
      // Test 8-bit compression
         dfcopy(&df, &df1);
         dfbinarycompression8(&df1);
         for (i = 0; i < npoints; i++) {
            x.xR[0] = xy.xyR[i][0];
            dfprocess(&df1, &x, &y);
            if (nclasses > 1) {
            // Checks for classification tasks
               s = 0.0;
               for (j = 0; j < nclasses; j++) {
                  Ok = Ok && y.xR[j] >= 0.0;
                  s += y.xR[j];
               }
               Ok = Ok && NearAtR(s, 1.0, 1000.0 * machineepsilon);
               Ok = Ok && NearAtR(y.xR[iround(xy.xyR[i][nvars])], 1.0, 1000.0 * machineepsilon);
            } else {
            // Regression problem
               Ok = Ok && NearAtR(y.xR[0], xy.xyR[i][nvars], tol8);
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Basic test:  tests generalization ability on a simple noisy classification
// task:
// * 0 < x < 1 - P(class == 0) == 1
// * 1 < x < 2 - P(class == 0) == 2-x
// * 2 < x < 3 - P(class == 0) == 0
static bool testdforestunit_basictest2() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t i;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforest, df);
   NewObj(decisionforestbuilder, builder);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(dfreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   passcount = 1;
   for (pass = 1; pass <= passcount; pass++) {
   // select npoints and ntrees
      npoints = 3000;
      ntrees = 100;
   // Prepare task
      ae_matrix_set_length(&xy, npoints, 2);
      ae_vector_set_length(&x, 1);
      ae_vector_set_length(&y, 2);
      for (i = 0; i < npoints; i++) {
         xy.xyR[i][0] = 3.0 * hqrnduniformr(&rs);
         if (xy.xyR[i][0] <= 1.0) {
            xy.xyR[i][1] = 0.0;
         } else {
            if (xy.xyR[i][0] <= 2.0) {
               if (hqrnduniformr(&rs) < xy.xyR[i][0] - 1) {
                  xy.xyR[i][1] = 1.0;
               } else {
                  xy.xyR[i][1] = 0.0;
               }
            } else {
               xy.xyR[i][1] = 1.0;
            }
         }
      }
   // Build forest
      dfbuildercreate(&builder);
      dfbuildersetdataset(&builder, &xy, npoints, 1, 2);
      dfbuildersetsubsampleratio(&builder, 0.05);
      dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
      dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
   // Check report fields
      Ok = Ok && NearAtR(rep.oobrelclserror, 1.0 / 12.0, 0.50 * (1.0 / 12.0));
      Ok = Ok && rep.relclserror <= rep.oobrelclserror;
      Ok = Ok && rep.avgce < rep.oobavgce;
      Ok = Ok && rep.rmserror < rep.oobrmserror;
      Ok = Ok && rep.avgerror < rep.oobavgerror;
      Ok = Ok && rep.avgrelerror < rep.oobavgrelerror;
   // Check outputs
      x.xR[0] = 0.0;
      while (x.xR[0] <= 3.0) {
         dfprocess(&df, &x, &y);
      // Test for basic properties
         Ok = Ok && y.xR[0] >= 0.0;
         Ok = Ok && y.xR[1] >= 0.0;
         Ok = Ok && NearAtR(y.xR[0] + y.xR[1], 1.0, 1000.0 * machineepsilon);
      // test for good correlation with results
         if (x.xR[0] < 1.0) {
            Ok = Ok && y.xR[0] >= 0.8;
         }
         if (x.xR[0] >= 1.0 && x.xR[0] <= 2.0) {
            Ok = Ok && NearAtR(y.xR[1], x.xR[0] - 1, 0.5);
         }
         if (x.xR[0] > 2.0) {
            Ok = Ok && y.xR[1] >= 0.8;
         }
      // Advance
         x.xR[0] += 0.01;
      }
   }
   ae_frame_leave();
   return Ok;
}

// Basic test:  tests  generalization ability on a simple classification task
// (no noise):
// * |x| < 1, |y| < 1
// * x^2+y^2 <= 0.25 - P(class == 0) == 1
// * x^2+y^2 > 0.25  - P(class == 0) == 0
static bool testdforestunit_basictest3() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t i;
   ae_int_t j;
   ae_int_t info;
   ae_int_t testgridsize;
   double r;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforestbuilder, builder);
   NewObj(decisionforest, df);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(dfreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   passcount = 2;
   testgridsize = 50;
   for (pass = 0; pass < passcount; pass++) {
   // select npoints and ntrees
      npoints = 2000;
      ntrees = 100;
   // Prepare task
      ae_matrix_set_length(&xy, npoints, 3);
      ae_vector_set_length(&x, 2);
      ae_vector_set_length(&y, 2);
      for (i = 0; i < npoints; i++) {
         xy.xyR[i][0] = hqrndmiduniformr(&rs);
         xy.xyR[i][1] = hqrndmiduniformr(&rs);
         if (sqr(xy.xyR[i][0]) + sqr(xy.xyR[i][1]) <= 0.25) {
            xy.xyR[i][2] = 0.0;
         } else {
            xy.xyR[i][2] = 1.0;
         }
      }
   // Build forest
   //
   // NOTE: we also test obsolete forest construction functions
      ae_assert(passcount >= 2, "RDF: test integrity failed");
      if (pass > 0) {
      // Test new interface
         dfbuildercreate(&builder);
         dfbuildersetdataset(&builder, &xy, npoints, 2, 2);
         dfbuildersetsubsampleratio(&builder, 0.10);
         dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
         dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
      } else {
      // Test old interface
         if (hqrnduniformi(&rs, 2) == 0) {
            dfbuildrandomdecisionforest(&xy, npoints, 2, 2, ntrees, 0.10, &info, &df, &rep);
         } else {
            dfbuildrandomdecisionforestx1(&xy, npoints, 2, 2, ntrees, 1, 0.10, &info, &df, &rep);
         }
         if (info <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   // Test
      for (i = -testgridsize / 2; i <= testgridsize / 2; i++) {
         for (j = -testgridsize / 2; j <= testgridsize / 2; j++) {
            x.xR[0] = (double)i / (testgridsize / 2);
            x.xR[1] = (double)j / (testgridsize / 2);
            dfprocess(&df, &x, &y);
         // Test for basic properties
            Ok = Ok && y.xR[0] >= 0.0;
            Ok = Ok && y.xR[1] >= 0.0;
            Ok = Ok && NearAtR(y.xR[0] + y.xR[1], 1.0, 1000.0 * machineepsilon);
         // test for good correlation with results
            r = sqrt(sqr(x.xR[0]) + sqr(x.xR[1]));
            if (r < 0.66 * 0.5) {
               Ok = Ok && y.xR[0] >= 0.66;
            }
            if (r > 1.33 * 0.5) {
               Ok = Ok && y.xR[1] >= 0.66;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Basic test: simple regression task without noise:
// * |x| < 1, |y| < 1
// * F(x,y) = x^2+y
static bool testdforestunit_basictest4() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t i;
   ae_int_t j;
   ae_int_t info;
   ae_int_t testgridsize;
   double maxerr;
   double avgerr;
   ae_int_t cnt;
   double ey;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforest, df);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(dfreport, rep);
   NewObj(decisionforestbuilder, builder);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   passcount = 2;
   testgridsize = 50;
   for (pass = 0; pass < passcount; pass++) {
   // select npoints and ntrees
      npoints = 5000;
      ntrees = 100;
   // Prepare task
      ae_matrix_set_length(&xy, npoints, 3);
      ae_vector_set_length(&x, 2);
      ae_vector_set_length(&y, 1);
      for (i = 0; i < npoints; i++) {
         xy.xyR[i][0] = hqrndmiduniformr(&rs);
         xy.xyR[i][1] = hqrndmiduniformr(&rs);
         xy.xyR[i][2] = sqr(xy.xyR[i][0]) + xy.xyR[i][1];
      }
   // Build forest
   //
   // NOTE: we also test obsolete forest construction functions
      ae_assert(passcount >= 2, "RDF: test integrity failed");
      if (pass > 0) {
      // Test new interface
         dfbuildercreate(&builder);
         dfbuildersetdataset(&builder, &xy, npoints, 2, 1);
         dfbuildersetsubsampleratio(&builder, 0.10);
         dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
         dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
      } else {
      // Test old interface
         if (hqrnduniformi(&rs, 2) == 0) {
            dfbuildrandomdecisionforest(&xy, npoints, 2, 1, ntrees, 0.10, &info, &df, &rep);
         } else {
            dfbuildrandomdecisionforestx1(&xy, npoints, 2, 1, ntrees, 1, 0.10, &info, &df, &rep);
         }
         if (info <= 0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   // Check report fields
      Ok = Ok && rep.relclserror == 0.0;
      Ok = Ok && rep.avgce == 0.0;
      Ok = Ok && rep.oobrelclserror == 0.0;
      Ok = Ok && rep.oobavgce == 0.0;
      Ok = Ok && rep.rmserror < rep.oobrmserror;
      Ok = Ok && rep.avgerror < rep.oobavgerror;
      Ok = Ok && rep.avgrelerror < rep.oobavgrelerror;
      Ok = Ok && rep.oobrmserror <= 0.05;
      Ok = Ok && rep.oobavgerror <= 0.05;
      Ok = Ok && rep.oobrmserror >= 0.001;
      Ok = Ok && rep.oobavgerror >= 0.001;
   // Test
      maxerr = 0.0;
      avgerr = 0.0;
      cnt = 0;
      for (i = iround(-0.7 * testgridsize / 2); i <= iround(0.7 * testgridsize / 2); i++) {
         for (j = iround(-0.7 * testgridsize / 2); j <= iround(0.7 * testgridsize / 2); j++) {
            x.xR[0] = (double)i / (testgridsize / 2);
            x.xR[1] = (double)j / (testgridsize / 2);
            ey = sqr(x.xR[0]) + x.xR[1];
            dfprocess(&df, &x, &y);
            maxerr = rmax2(maxerr, fabs(y.xR[0] - ey));
            avgerr += fabs(y.xR[0] - ey);
            cnt++;
         }
      }
      avgerr /= cnt;
      Ok = Ok && maxerr <= 0.15;
      Ok = Ok && avgerr <= 0.05;
   }
   ae_frame_leave();
   return Ok;
}

// Basic test: extended variable selection leads to better results.
//
// Next task CAN be solved without EVS but it is very unlikely. With EVS
// it can be easily and exactly solved.
//
// Task matrix:
//     1 0 0 0 ... 0   0
//     0 1 0 0 ... 0   1
//     0 0 1 0 ... 0   2
//     0 0 0 1 ... 0   3
//     0 0 0 0 ... 1   N-1
static bool testdforestunit_basictest5() {
   ae_frame _frame_block;
   ae_int_t nvars;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t i;
   ae_int_t j;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforestbuilder, builder);
   NewObj(decisionforest, df);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(dfreport, rep);
// select npoints and ntrees
   npoints = 50;
   nvars = npoints;
   ntrees = 1;
// Prepare task
   ae_matrix_set_length(&xy, npoints, nvars + 1);
   ae_vector_set_length(&x, nvars);
   ae_vector_set_length(&y, 1);
   for (i = 0; i < npoints; i++) {
      for (j = 0; j < nvars; j++) {
         xy.xyR[i][j] = 0.0;
      }
      xy.xyR[i][i] = 1.0;
      xy.xyR[i][nvars] = (double)i;
   }
// Build forest
   dfbuildercreate(&builder);
   dfbuildersetdataset(&builder, &xy, npoints, nvars, 1);
   dfbuildersetsubsampleratio(&builder, 1.00);
   dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
   dfbuildersetrdfsplitstrength(&builder, randominteger(testdforestunit_splitmax + 1));
   dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
// Test
   Ok = Ok && rep.rmserror < rep.oobrmserror;
   Ok = Ok && rep.avgerror < rep.oobavgerror;
   Ok = Ok && rep.avgrelerror < rep.oobavgrelerror;
   Ok = Ok && SmallAtR(rep.rmserror, 1000.0 * machineepsilon);
   Ok = Ok && SmallAtR(rep.avgerror, 1000.0 * machineepsilon);
   Ok = Ok && SmallAtR(rep.avgrelerror, 1000.0 * machineepsilon);
   for (i = 0; i < npoints; i++) {
      ae_v_move(x.xR, 1, xy.xyR[i], 1, nvars);
      dfprocess(&df, &x, &y);
      if (!NearAtR(y.xR[0], xy.xyR[i][nvars], 1000.0 * machineepsilon)) {
         Ok = false;
      }
   }
   ae_frame_leave();
   return Ok;
}

// Basic test: test correctness of error reports on completely random problem;
// test that OOB errors are roughly unbiased.
static bool testdforestunit_basictestrandom() {
   ae_frame _frame_block;
   ae_int_t nvars;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t nclasses;
   ae_int_t i;
   ae_int_t j;
   ae_int_t factor;
   double meanlevel;
   double sigma;
   double v;
   double refavgce;
   double refrms;
   double refavg;
   double refavgrel;
   ae_int_t relcnt;
   double oobtol;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforestbuilder, builder);
   NewObj(decisionforest, df);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(dfreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   npoints = 200;
   nvars = 10;
   ntrees = 1000;
   oobtol = 0.20;
   for (nclasses = 1; nclasses <= 3; nclasses++) {
   // Prepare task
      ae_matrix_set_length(&xy, npoints, nvars + 1);
      meanlevel = 10 * hqrndnormal(&rs);
      sigma = pow(10.0, hqrndnormal(&rs));
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            xy.xyR[i][j] = 0.0;
            if (j % 3 == 0) {
               xy.xyR[i][j] = hqrndnormal(&rs);
            }
            if (j % 3 == 1 && hqrnduniformr(&rs) < 0.05) {
               xy.xyR[i][j] = 1.0;
            }
            if (j % 3 == 2 && hqrnduniformr(&rs) < 0.05) {
               xy.xyR[i][j] = (double)(1 + hqrnduniformi(&rs, 3));
            }
         }
         if (nclasses == 1) {
            xy.xyR[i][nvars] = meanlevel + sigma * hqrndnormal(&rs);
            if (hqrnduniformr(&rs) < 0.05) {
               xy.xyR[i][nvars] = 0.0;
            }
         } else {
            xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
         }
      }
      ae_vector_set_length(&x, nvars);
      ae_vector_set_length(&y, nclasses);
   // Build forest using 50% and 66% of the samples.
   // Check TRN and OOB errors (OOB should be 2x and 3x larger in these cases)
      for (factor = 2; factor <= 3; factor++) {
         j = hqrnduniformi(&rs, 3);
         dfbuildercreate(&builder);
         dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
         dfbuildersetsubsampleratio(&builder, 1 - 1.0 / factor);
         if (j > 0) {
            dfbuildersetrndvars(&builder, 1 + hqrnduniformi(&rs, 5));
         }
         if (j == 0) {
            dfbuildersetrndvarsauto(&builder);
         }
         if (j < 0) {
            dfbuildersetrndvarsratio(&builder, hqrnduniformr(&rs));
         }
         dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
         dfbuildersetrdfsplitstrength(&builder, randominteger(testdforestunit_splitmax + 1));
         Ok = Ok && dfbuildergetprogress(&builder) == 0.0;
         Ok = Ok && dfbuilderpeekprogress(&builder) == 0.0;
         dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
         Ok = Ok && dfbuildergetprogress(&builder) == 1.0;
         Ok = Ok && dfbuilderpeekprogress(&builder) == 1.0;
         refavgce = 0.0;
         refrms = 0.0;
         refavg = 0.0;
         refavgrel = 0.0;
         relcnt = 0;
         if (nclasses == 1) {
         // Check training set errors
            for (i = 0; i < npoints; i++) {
               for (j = 0; j < nvars; j++) {
                  x.xR[j] = xy.xyR[i][j];
               }
               dfprocess(&df, &x, &y);
               v = y.xR[0] - xy.xyR[i][nvars];
               refrms += sqr(v);
               refavg += fabs(v);
               if (xy.xyR[i][nvars] != 0.0) {
                  refavgrel += fabs(v / xy.xyR[i][nvars]);
                  relcnt++;
               }
            }
            refrms = sqrt(refrms / npoints);
            refavg /= npoints;
            refavgrel /= coalesce((double)relcnt, 1.0);
            Ok = Ok && rep.relclserror == 0.0;
            Ok = Ok && rep.avgce == 0.0;
            Ok = Ok && NearAtR(rep.rmserror, refrms, refrms * 1.0E-6);
            Ok = Ok && NearAtR(rep.avgerror, refavg, refavg * 1.0E-6);
            Ok = Ok && NearAtR(rep.avgrelerror, refavgrel, refavgrel * 1.0E-6);
            Ok = Ok && dfrelclserror(&df, &xy, npoints) == 0.0;
            Ok = Ok && dfavgce(&df, &xy, npoints) == 0.0;
            Ok = Ok && NearAtR(dfrmserror(&df, &xy, npoints), refrms, refrms * 1.0E-6);
            Ok = Ok && NearAtR(dfavgerror(&df, &xy, npoints), refavg, refavg * 1.0E-6);
            Ok = Ok && NearAtR(dfavgrelerror(&df, &xy, npoints), refavgrel, refavgrel * 1.0E-6);
         // Check OOB errors against training set errors:
         // * RelCLS and AvgCE are not calculated for regression problems
         // * RMS and AVG should be roughly FACTOR times larger
         // * AVG-REL should be just larger (it is more prone to sampling noise than previous two)
            Ok = Ok && rep.oobrelclserror == 0.0;
            Ok = Ok && rep.oobavgce == 0.0;
            Ok = Ok && NearAtR(rep.oobrmserror / rep.rmserror, factor, oobtol);
            Ok = Ok && NearAtR(rep.oobavgerror / rep.avgerror, factor, oobtol);
            Ok = Ok && rep.oobavgrelerror >= rep.avgrelerror;
         } else {
         // Check training set errors
            for (i = 0; i < npoints; i++) {
               for (j = 0; j < nvars; j++) {
                  x.xR[j] = xy.xyR[i][j];
               }
               dfprocess(&df, &x, &y);
               for (j = 0; j < nclasses; j++) {
                  v = y.xR[j];
                  if (j == xy.xyR[i][nvars]) {
                     refavgce -= log(coalesce(v, minrealnumber)); //(@) Added.
                     v--;
                  }
                  refrms += sqr(v);
                  refavg += fabs(v);
                  if (j == xy.xyR[i][nvars]) {
                     refavgrel += fabs(v);
                  // refavgce -= log(v); //(@) Removed.
                  }
               }
            }
            refrms = sqrt(refrms / (npoints * nclasses));
            refavg /= npoints * nclasses;
            refavgrel /= npoints;
            refavgce /= npoints;
            Ok = Ok && NearAtR(rep.avgce, refavgce, refavgce * 1.0E-6);
            Ok = Ok && NearAtR(rep.rmserror, refrms, refrms * 1.0E-6);
            Ok = Ok && NearAtR(rep.avgerror, refavg, refavg * 1.0E-6);
            Ok = Ok && NearAtR(rep.avgrelerror, refavgrel, refavgrel * 1.0E-6);
            Ok = Ok && fabs(dfrelclserror(&df, &xy, npoints) - rep.relclserror) * npoints <= 5.0;
            Ok = Ok && NearAtR(dfavgce(&df, &xy, npoints), refavgce, refavgce * 1.0E-6);
            Ok = Ok && NearAtR(dfrmserror(&df, &xy, npoints), refrms, refrms * 1.0E-6);
            Ok = Ok && NearAtR(dfavgerror(&df, &xy, npoints), refavg, refavg * 1.0E-6);
            Ok = Ok && NearAtR(dfavgrelerror(&df, &xy, npoints), refavgrel, refavgrel * 1.0E-6);
         // Check OOB errors against training set errors
         // * RelCLS, AvgCE and AvgRel should be just larger (too prone to sampling noise to perform more sensitive tests)
         // * RMS and AVG should be roughly FACTOR times larger
         //
            Ok = Ok && rep.oobrelclserror >= rep.relclserror;
            Ok = Ok && rep.oobavgce >= rep.avgce;
            Ok = Ok && rep.oobavgrelerror >= rep.avgrelerror;
            Ok = Ok && NearAtR(rep.oobrmserror / rep.rmserror, factor, oobtol);
            Ok = Ok && NearAtR(rep.oobavgerror / rep.avgerror, factor, oobtol);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test behavior of the RDF algorithm on problem where all values of variables
// are same
static bool testdforestunit_basictestallsame() {
   ae_frame _frame_block;
   ae_int_t nvars;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t nclasses;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double refavgce;
   double refrms;
   double refavg;
   double refavgrel;
   ae_int_t relcnt;
   double oobtol;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforestbuilder, builder);
   NewObj(decisionforest, df);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(dfreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   npoints = 100;
   nvars = 10;
   ntrees = 100;
   oobtol = 0.25;
   for (nclasses = 1; nclasses <= 3; nclasses++) {
   // Prepare task
      ae_matrix_set_length(&xy, npoints, nvars + 1);
      k = hqrnduniformi(&rs, 11) - 5;
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            xy.xyR[i][j] = (double)k;
         }
         if (nclasses == 1) {
            xy.xyR[i][nvars] = hqrndnormal(&rs);
         } else {
            xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
         }
      }
      ae_vector_set_length(&x, nvars);
      ae_vector_set_length(&y, nclasses);
   // Build forest.
   // Check TRN and OOB errors.
      j = hqrnduniformi(&rs, 3);
      dfbuildercreate(&builder);
      dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
      dfbuildersetsubsampleratio(&builder, 0.5);
      if (j > 0) {
         dfbuildersetrndvars(&builder, 1 + hqrnduniformi(&rs, 5));
      }
      if (j == 0) {
         dfbuildersetrndvarsauto(&builder);
      }
      if (j < 0) {
         dfbuildersetrndvarsratio(&builder, hqrnduniformr(&rs));
      }
      dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
      dfbuildersetrdfsplitstrength(&builder, randominteger(testdforestunit_splitmax + 1));
      dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
      refavgce = 0.0;
      refrms = 0.0;
      refavg = 0.0;
      refavgrel = 0.0;
      relcnt = 0;
      if (nclasses == 1) {
      // Check training set errors
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nvars; j++) {
               x.xR[j] = xy.xyR[i][j];
            }
            dfprocess(&df, &x, &y);
            v = y.xR[0] - xy.xyR[i][nvars];
            refrms += sqr(v);
            refavg += fabs(v);
            if (xy.xyR[i][nvars] != 0.0) {
               refavgrel += fabs(v / xy.xyR[i][nvars]);
               relcnt++;
            }
         }
         refrms = sqrt(refrms / npoints);
         refavg /= npoints;
         refavgrel /= coalesce((double)relcnt, 1.0);
         Ok = Ok && rep.relclserror == 0.0;
         Ok = Ok && rep.avgce == 0.0;
         Ok = Ok && NearAtR(rep.rmserror, refrms, refrms * 1.0E-6);
         Ok = Ok && NearAtR(rep.avgerror, refavg, refavg * 1.0E-6);
         Ok = Ok && NearAtR(rep.avgrelerror, refavgrel, refavgrel * 1.0E-6);
      // Check OOB errors against training set errors:
      // * RelCLS and AvgCE are not calculated for regression problems
      // * RMS and AVG should be roughly same
         Ok = Ok && rep.oobrelclserror == 0.0;
         Ok = Ok && rep.oobavgce == 0.0;
         Ok = Ok && NearAtR(rep.oobrmserror / rep.rmserror, 1.0, oobtol);
         Ok = Ok && NearAtR(rep.oobavgerror / rep.avgerror, 1.0, oobtol);
      } else {
      // Check training set errors
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nvars; j++) {
               x.xR[j] = xy.xyR[i][j];
            }
            dfprocess(&df, &x, &y);
            for (j = 0; j < nclasses; j++) {
               v = y.xR[j];
               if (j == xy.xyR[i][nvars]) {
                  refavgce -= log(coalesce(v, minrealnumber)); //(@) Added.
                  v--;
               }
               refrms += sqr(v);
               refavg += fabs(v);
               if (j == xy.xyR[i][nvars]) {
                  refavgrel += fabs(v);
               // refavgce -= log(v); //(@) Removed.
               }
            }
         }
         refrms = sqrt(refrms / (npoints * nclasses));
         refavg /= npoints * nclasses;
         refavgrel /= npoints;
         refavgce /= npoints;
         Ok = Ok && NearAtR(rep.avgce, refavgce, refavgce * 1.0E-6);
         Ok = Ok && NearAtR(rep.rmserror, refrms, refrms * 1.0E-6);
         Ok = Ok && NearAtR(rep.avgerror, refavg, refavg * 1.0E-6);
         Ok = Ok && NearAtR(rep.avgrelerror, refavgrel, refavgrel * 1.0E-6);
      // Check OOB errors against training set errors
      // * RMS and AVG should be roughly same
      //
         Ok = Ok && NearAtR(rep.oobrmserror / rep.rmserror, 1.0, oobtol);
         Ok = Ok && NearAtR(rep.oobavgerror / rep.avgerror, 1.0, oobtol);
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test model compression - that it works and generates forests which correctly
// reproduce original one
static bool testdforestunit_testcompression() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t nvars;
   ae_int_t nclasses;
   double tol16;
   double tol8;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforestbuilder, builder);
   NewObj(decisionforest, dfraw);
   NewObj(decisionforest, df16);
   NewObj(decisionforest, df8);
   NewVector(x, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewObj(dfreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   tol16 = 0.0001;
   tol8 = 0.01;
// Test compression on small-scale problems:
// * a K-dimensional input, with 3^K distinct points located at integer grid
// * we test that compressed model produces roughly same results as uncompressed
//   one (predicts same class / predicts same scalar output subject to small
//   truncation error)
   for (nvars = 1; nvars <= 5; nvars++) {
      for (nclasses = 1; nclasses <= 3; nclasses++) {
         ae_vector_set_length(&x, nvars);
         ae_vector_set_length(&y0, nclasses);
         ae_vector_set_length(&y1, nclasses);
      // Generate dataset
         npoints = iround(pow(3.0, (double)nvars));
         ae_matrix_set_length(&xy, npoints, nvars + 1);
         for (i = 0; i < npoints; i++) {
            k = i;
            for (j = 0; j < nvars; j++) {
               xy.xyR[i][j] = (double)(k % 3 - 1);
               k /= 3;
            }
            if (nclasses == 1) {
               xy.xyR[i][nvars] = hqrnduniformr(&rs) - 0.5;
            } else {
               xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
            }
         }
      // Train uncompressed
         ntrees = 1 + hqrnduniformi(&rs, 10);
         dfbuildercreate(&builder);
         dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
         dfbuildersetsubsampleratio(&builder, 0.66);
         dfbuilderbuildrandomforest(&builder, ntrees, &dfraw, &rep);
      // Test 16-bit compression
         dfcopy(&dfraw, &df16);
         dfbinarycompression(&df16);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nvars; j++) {
               x.xR[j] = xy.xyR[i][j];
            }
            dfprocess(&dfraw, &x, &y0);
            dfprocess(&df16, &x, &y1);
            if (nclasses > 1) {
            // Compare output probabilities for classification problem
               for (j = 0; j < nclasses; j++) {
                  Ok = Ok && NearAtR(y0.xR[j], y1.xR[j], 1000.0 * machineepsilon);
               }
            } else {
            // Compare output values for regression problem
               Ok = Ok && NearAtR(y0.xR[0], y1.xR[0], tol16);
            }
         }
      // Test 8-bit compression
         dfcopy(&dfraw, &df8);
         dfbinarycompression8(&df8);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nvars; j++) {
               x.xR[j] = xy.xyR[i][j];
            }
            dfprocess(&dfraw, &x, &y0);
            dfprocess(&df8, &x, &y1);
            if (nclasses > 1) {
            // Compare output probabilities for classification problem
               for (j = 0; j < nclasses; j++) {
                  Ok = Ok && NearAtR(y0.xR[j], y1.xR[j], 1000.0 * machineepsilon);
               }
            } else {
            // Compare output values for regression problem
               Ok = Ok && NearAtR(y0.xR[0], y1.xR[0], tol8);
            }
         }
      }
   }
// Test compression on large-scale problems:
// * NVars == 500, NPoints == 500, I-th point is zero except for I-th position
// * NClasses == 1 (random output) or NClasses == 400
// * NTrees is in 1...5
   for (pass = 0; pass <= 1; pass++) {
   // Set up problem
      ae_assert(pass == 0 || pass == 1, "DF: integrity check failed");
      nvars = 500;
      npoints = 500;
      nclasses = 1;
      if (pass == 1) {
         nclasses = 400;
      }
      ae_matrix_set_length(&xy, npoints, nvars + 1);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            xy.xyR[i][j] = 0.0;
         }
         xy.xyR[i][i] = 1.0;
         if (nclasses == 1) {
            xy.xyR[i][nvars] = hqrnduniformr(&rs) - 0.5;
         } else {
            xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
         }
      }
      ae_vector_set_length(&x, nvars);
      ae_vector_set_length(&y0, nclasses);
      ae_vector_set_length(&y1, nclasses);
   // Train uncompressed
      ntrees = 1 + hqrnduniformi(&rs, 5);
      dfbuildercreate(&builder);
      dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
      dfbuildersetsubsampleratio(&builder, 0.66);
      dfbuilderbuildrandomforest(&builder, ntrees, &dfraw, &rep);
   // Test 16-bit compression
      dfcopy(&dfraw, &df16);
      dfbinarycompression(&df16);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            x.xR[j] = xy.xyR[i][j];
         }
         dfprocess(&dfraw, &x, &y0);
         dfprocess(&df16, &x, &y1);
         if (nclasses > 1) {
         // Compare output probabilities for classification problem
            for (j = 0; j < nclasses; j++) {
               Ok = Ok && NearAtR(y0.xR[j], y1.xR[j], 1000.0 * machineepsilon);
            }
         } else {
         // Compare output values for regression problem
            Ok = Ok && NearAtR(y0.xR[0], y1.xR[0], tol16);
         }
      }
   // Test 8-bit compression
      dfcopy(&dfraw, &df8);
      dfbinarycompression8(&df8);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            x.xR[j] = xy.xyR[i][j];
         }
         dfprocess(&dfraw, &x, &y0);
         dfprocess(&df8, &x, &y1);
         if (nclasses > 1) {
         // Compare output probabilities for classification problem
            for (j = 0; j < nclasses; j++) {
               Ok = Ok && NearAtR(y0.xR[j], y1.xR[j], 1000.0 * machineepsilon);
            }
         } else {
         // Compare output values for regression problem
            Ok = Ok && NearAtR(y0.xR[0], y1.xR[0], tol8);
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Randomly rearranges XY, using one of the algorithms:
// * in 50% of cases does nothing
// * in 50% of cases sorts by dependent variable (last column)
//
// Such rearrangement can be used to catch errors related to different processing
// of different parts of dataset
static void testdforestunit_randomlyrearrange(RMatrix *xy, ae_int_t npoints, ae_int_t nvars, hqrndstate *rs) {
   ae_frame _frame_block;
   ae_int_t kind;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewVector(y, 0, DT_REAL);
   NewVector(p1, 0, DT_INT);
   NewVector(p2, 0, DT_INT);
   kind = hqrnduniformi(rs, nvars + 2);
   if (kind == nvars + 1) {
      ae_frame_leave();
      return;
   }
   ae_vector_set_length(&y, npoints);
   for (i = 0; i < npoints; i++) {
      y.xR[i] = xy->xyR[i][kind];
   }
   tagsort(&y, npoints, &p1, &p2);
   for (i = 0; i < npoints; i++) {
      swaprows(xy, i, p2.xZ[i], nvars + 1);
   }
   ae_frame_leave();
}

// Test variable importance
static bool testdforestunit_testimportance() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t npoints;
   ae_int_t npoints2;
   ae_int_t nvars;
   ae_int_t nclasses;
   ae_int_t ntrees;
   double v;
   double unimportantlo;
   double unimportanthi;
   double importantlo;
   double importanthi;
   ae_int_t ntype;
   ae_int_t ntypes;
   ae_int_t stype;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewMatrix(xyp, 0, 0, DT_REAL);
   NewVector(c, 0, DT_REAL);
   NewVector(vloss, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewObj(decisionforestbuilder, builder);
   NewObj(decisionforest, df);
   NewObj(dfreport, rep);
   NewObj(hqrndstate, rs);
   ntypes = 3;
   hqrndrandomize(&rs);
// Test that default state of importance estimation is off
   npoints = 50;
   ntrees = 50;
   for (nclasses = 1; nclasses <= 3; nclasses++) {
   // Generate dataset
      nvars = 1 + hqrnduniformi(&rs, 3);
      ae_matrix_set_length(&xy, npoints, nvars + 1);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            xy.xyR[i][j] = hqrndnormal(&rs);
         }
         if (nclasses == 1) {
            xy.xyR[i][nvars] = hqrnduniformr(&rs) - 0.5;
         } else {
            xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
         }
      }
   // Train with default settings, check that variable importances reported are zero
      dfbuildercreate(&builder);
      dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
      dfbuildersetsubsampleratio(&builder, 0.66);
      dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
      Ok = Ok && rep.varimportances.cnt == nvars;
      Ok = Ok && rep.topvars.cnt == nvars;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      for (j = 0; j < nvars; j++) {
         Ok = Ok && rep.varimportances.xR[j] == 0.0;
         Ok = Ok && rep.topvars.xZ[j] == j;
      }
   }
// Test that degenerate cases are handled correctly
   npoints = 50;
   ntrees = 50;
   for (nclasses = 1; nclasses <= 3; nclasses++) {
      for (npoints = 1; npoints <= 2; npoints++) {
         for (stype = 0; stype <= 1; stype++) {
            for (ntype = 0; ntype < ntypes; ntype++) {
            // Generate dataset
               nvars = 1 + hqrnduniformi(&rs, 3);
               ae_matrix_set_length(&xy, npoints, nvars + 1);
               for (i = 0; i < npoints; i++) {
                  for (j = 0; j < nvars; j++) {
                     xy.xyR[i][j] = hqrndnormal(&rs);
                  }
                  if (nclasses == 1) {
                     xy.xyR[i][nvars] = hqrnduniformr(&rs) - 0.5;
                  } else {
                     xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
                  }
               }
            // Train
               dfbuildercreate(&builder);
               dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
               dfbuildersetsubsampleratio(&builder, 1.0 - stype * 0.5);
               ae_assert(ntype <= 2, "integrity check in the test");
               if (ntype == 0) {
                  dfbuildersetimportanceoobgini(&builder);
               }
               if (ntype == 1) {
                  dfbuildersetimportancepermutation(&builder);
               }
               if (ntype == 2) {
                  dfbuildersetimportancetrngini(&builder);
               }
               dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
               Ok = Ok && rep.varimportances.cnt == nvars;
               Ok = Ok && rep.topvars.cnt == nvars;
               if (!Ok) {
                  ae_frame_leave();
                  return Ok;
               }
               if (npoints == 1 || stype == 1) {
                  for (j = 0; j < nvars; j++) {
                     Ok = Ok && rep.varimportances.xR[j] == 0.0;
                     Ok = Ok && rep.topvars.xZ[j] == j;
                  }
               }
            }
         }
      }
   }
// Test various importance types
   for (ntype = 0; ntype < ntypes; ntype++) {
   // Select variables count
      nvars = 1 + hqrnduniformi(&rs, 3);
   // Select preferred problem metrics for this importance type
      npoints = -1;
      ntrees = -1;
      unimportantlo = -1.0;
      unimportanthi = -1.0;
      importantlo = -1.0;
      importanthi = -1.0;
      if (ntype == 0) {
      // OOB Gini importance averages individual importances between multiple trees,
      // so its variance is inversely proportional to the tree count. Tasks with large number
      // of trees are preferred.
         npoints = 250;
         ntrees = 1000;
         unimportantlo = 0.00;
         unimportanthi = 0.25;
         importantlo = 0.75 * (1.0 / nvars);
         importanthi = rmin2(1.25 * (1.0 / nvars), 1.00);
      }
      if (ntype == 1) {
      // Variance of permutation importance estimate is inversely proportional to the
      // dataset size. Tasks with large number of points are preferred, trees count
      // does not matter much here.
         npoints = 5000;
         ntrees = 10;
         unimportantlo = 0.00;
         unimportanthi = 0.15;
         importantlo = 0.85;
         importanthi = 1.00;
      }
      if (ntype == 2) {
      // TRN Gini importance averages individual importances between multiple trees,
      // so its variance is inversely proportional to the tree count. Tasks with large number
      // of trees are preferred.
         npoints = 250;
         ntrees = 1000;
         unimportantlo = 0.75 * (1.0 / nvars);
         unimportanthi = rmin2(1.25 * (1.0 / nvars), 1.00);
         importantlo = 0.75 * (1.0 / nvars);
         importanthi = rmin2(1.25 * (1.0 / nvars), 1.00);
      }
   // Test on a problem with completely random outputs
      for (nclasses = 1; nclasses <= 3; nclasses++) {
      // Generate dataset
         ae_matrix_set_length(&xy, npoints, nvars + 1);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nvars; j++) {
               xy.xyR[i][j] = hqrndnormal(&rs);
            }
            if (nclasses == 1) {
               xy.xyR[i][nvars] = hqrnduniformr(&rs) - 0.5;
            } else {
               xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
            }
         }
         testdforestunit_randomlyrearrange(&xy, npoints, nvars, &rs);
      // Train
         dfbuildercreate(&builder);
         dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
         dfbuildersetsubsampleratio(&builder, 0.66);
         dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
         ae_assert(ntype <= 2, "integrity check in the test");
         if (ntype == 0) {
            dfbuildersetimportanceoobgini(&builder);
         }
         if (ntype == 1) {
            dfbuildersetimportancepermutation(&builder);
         }
         if (ntype == 2) {
            dfbuildersetimportancetrngini(&builder);
         }
         dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
         Ok = Ok && rep.varimportances.cnt == nvars;
         Ok = Ok && rep.topvars.cnt == nvars;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (j = 0; j < nvars; j++) {
            Ok = Ok && rep.varimportances.xR[j] >= unimportantlo;
            Ok = Ok && rep.varimportances.xR[j] <= unimportanthi;
         }
         setlengthzero(&tmp, nvars);
         for (j = 0; j < nvars; j++) {
            Ok = Ok && rep.topvars.xZ[j] >= 0;
            Ok = Ok && rep.topvars.xZ[j] < nvars;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            Ok = Ok && tmp.xR[rep.topvars.xZ[j]] == 0.0;
            tmp.xR[rep.topvars.xZ[j]]++;
         }
         for (j = 0; j < nvars - 1; j++) {
            Ok = Ok && rep.varimportances.xR[rep.topvars.xZ[j]] >= rep.varimportances.xR[rep.topvars.xZ[j + 1]];
         }
         if (ntype == 2) {
         // TRN-Gini importances sum to 1.0
            v = 0.0;
            for (j = 0; j < nvars; j++) {
               v += rep.varimportances.xR[j];
            }
            Ok = Ok && NearAtR(v, 1.0, 1.0e-6);
         }
      }
   // Test that on a problem where:
   // * every variable matters
   // * every variable is critical
   // * result is completely predictable.
      for (nclasses = 1; nclasses <= 3; nclasses++) {
      // Generate dataset
         ae_matrix_set_length(&xy, npoints, nvars + 1);
         for (i = 0; i < npoints; i++) {
            if (nclasses == 1) {
               xy.xyR[i][nvars] = 0.0;
               k = i;
               for (j = 0; j < nvars; j++) {
                  xy.xyR[i][j] = (double)(k % 3);
                  xy.xyR[i][nvars] += round(xy.xyR[i][j]);
                  k /= 3;
               }
               xy.xyR[i][nvars] = (double)(iround(xy.xyR[i][nvars]) % 3 - 1);
            } else {
               xy.xyR[i][nvars] = 0.0;
               k = i;
               for (j = 0; j < nvars; j++) {
                  xy.xyR[i][j] = (double)(k % nclasses);
                  xy.xyR[i][nvars] += round(xy.xyR[i][j]);
                  k /= nclasses;
               }
               xy.xyR[i][nvars] = (double)(iround(xy.xyR[i][nvars]) % nclasses);
            }
         }
         testdforestunit_randomlyrearrange(&xy, npoints, nvars, &rs);
      // Train
         dfbuildercreate(&builder);
         dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
         dfbuildersetsubsampleratio(&builder, 0.5);
         dfbuildersetrndvars(&builder, nvars);
         ae_assert(ntype <= 2, "integrity check in the test");
         if (ntype == 0) {
            dfbuildersetimportanceoobgini(&builder);
         }
         if (ntype == 1) {
            dfbuildersetimportancepermutation(&builder);
         }
         if (ntype == 2) {
            dfbuildersetimportancetrngini(&builder);
         }
         dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
         Ok = Ok && rep.varimportances.cnt == nvars;
         Ok = Ok && rep.topvars.cnt == nvars;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (j = 0; j < nvars; j++) {
            Ok = Ok && rep.varimportances.xR[j] >= importantlo;
            Ok = Ok && rep.varimportances.xR[j] <= importanthi;
         }
         setlengthzero(&tmp, nvars);
         for (j = 0; j < nvars; j++) {
            Ok = Ok && rep.topvars.xZ[j] >= 0;
            Ok = Ok && rep.topvars.xZ[j] < nvars;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            Ok = Ok && tmp.xR[rep.topvars.xZ[j]] == 0.0;
            tmp.xR[rep.topvars.xZ[j]]++;
         }
         for (j = 0; j < nvars - 1; j++) {
            Ok = Ok && rep.varimportances.xR[rep.topvars.xZ[j]] >= rep.varimportances.xR[rep.topvars.xZ[j + 1]];
         }
         if (ntype == 2) {
         // TRN-Gini importances sum to 1.0
            v = 0.0;
            for (j = 0; j < nvars; j++) {
               v += rep.varimportances.xR[j];
            }
            Ok = Ok && NearAtR(v, 1.0, 1.0e-6);
         }
      }
   }
// Test values computed by the fast MDA (permutation) algorithm against
// ones computed by definition (by simply running model on permuted dataset).
//
// We solve regression and 2-class classification problems.
//
// Large "reference" dataset is used to compute reference importances in order
// to reduce variance of at least one component in the difference |I_reference-I_computed|
   npoints = 5000;
   ntrees = 10;
   npoints2 = npoints;
   for (nclasses = 1; nclasses <= 2; nclasses++) {
   // Generate dataset
      nvars = 3;
      ae_vector_set_length(&c, nvars);
      for (j = 0; j < nvars; j++) {
         c.xR[j] = pow(2.0, (double)-j);
      }
      ae_matrix_set_length(&xy2, npoints + npoints2, nvars + 1);
      for (i = 0; i < npoints + npoints2; i++) {
         xy2.xyR[i][nvars] = 0.01 * hqrndnormal(&rs);
         for (j = 0; j < nvars; j++) {
            xy2.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
            xy2.xyR[i][nvars] += xy2.xyR[i][j] * c.xR[j];
         }
         if (nclasses == 2) {
            if (xy2.xyR[i][nvars] > 0.0) {
               xy2.xyR[i][nvars] = 0.0;
            } else {
               xy2.xyR[i][nvars] = 1.0;
            }
         }
      }
      ae_matrix_set_length(&xy, npoints, nvars + 1);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j <= nvars; j++) {
            xy.xyR[i][j] = xy2.xyR[npoints2 + i][j];
         }
      }
      rmatrixresize(&xy2, npoints2, nvars + 1);
      testdforestunit_randomlyrearrange(&xy, npoints, nvars, &rs);
   // Train model
      dfbuildercreate(&builder);
      dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
      dfbuildersetsubsampleratio(&builder, 0.5);
      dfbuildersetimportancepermutation(&builder);
      dfbuildersetrndvars(&builder, nvars);
      dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
      Ok = Ok && rep.varimportances.cnt == nvars;
      Ok = Ok && rep.topvars.cnt == nvars;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Compute importances by definition
      ae_matrix_set_length(&xyp, npoints2, nvars + 1);
      ae_vector_set_length(&vloss, nvars + 2);
      for (k = 0; k <= nvars + 1; k++) {
         for (i = 0; i < npoints2; i++) {
            for (j = 0; j <= nvars; j++) {
               xyp.xyR[i][j] = xy2.xyR[i][j];
            }
         }
         if (k < nvars) {
            for (i = 0; i < npoints2; i++) {
               swapr(&xyp.xyR[i][k], &xyp.xyR[i + hqrnduniformi(&rs, npoints2 - i)][k]);
            }
         }
         if (k == nvars + 1) {
            for (j = 0; j < nvars; j++) {
               for (i = 0; i < npoints2; i++) {
                  swapr(&xyp.xyR[i][j], &xyp.xyR[i + hqrnduniformi(&rs, npoints2 - i)][j]);
               }
            }
         }
         vloss.xR[k] = sqr(dfrmserror(&df, &xyp, npoints2)) * npoints2 * nclasses + 1.0e-20;
      }
   // Compare
      for (k = 0; k < nvars; k++) {
         v = 1 - vloss.xR[nvars] / vloss.xR[nvars + 1] - (1 - vloss.xR[k] / vloss.xR[nvars + 1]);
         Ok = Ok && NearAtR(v, rep.varimportances.xR[k], 0.25);
      }
   }
   ae_frame_leave();
   return Ok;
}

bool testdforest() {
// Tests
   bool procOk = testdforestunit_testprocessing();
   bool basic1Ok = testdforestunit_basictest1();
   bool basic2Ok = testdforestunit_basictest2();
   bool basic3Ok = testdforestunit_basictest3();
   bool basic4Ok = testdforestunit_basictest4();
   bool basic5Ok = testdforestunit_basictest5();
   bool randomOk = testdforestunit_basictestrandom();
   bool allSameOk = testdforestunit_basictestallsame();
// Primary settings
   bool basicOk = basic1Ok && basic2Ok && basic3Ok && basic4Ok && basic5Ok && randomOk && allSameOk;
   bool compressionOk = testdforestunit_testcompression();
   bool importanceOk = testdforestunit_testimportance();
// The final report.
   bool Ok = procOk && basicOk && compressionOk && importanceOk;
   if (!Ok || !silent) {
      printf("Random Forest Tests\n");
      printf("* Processing Functions:                   %s\n", procOk? "Ok": "Failed");
      printf("* Basic Tests:                            %s\n", basicOk? "Ok": "Failed");
      if (!basicOk) {
         printf("* - Basic Test 1:                         %s\n", basic1Ok? "Ok": "Failed");
         printf("* - Basic Test 2:                         %s\n", basic2Ok? "Ok": "Failed");
         printf("* - Basic Test 3:                         %s\n", basic3Ok? "Ok": "Failed");
         printf("* - Basic Test 4:                         %s\n", basic4Ok? "Ok": "Failed");
         printf("* - Basic Test 5:                         %s\n", basic5Ok? "Ok": "Failed");
         printf("* - Random Test:                          %s\n", randomOk? "Ok": "Failed");
         printf("* - All Same Test:                        %s\n", allSameOk? "Ok": "Failed");
      }
      printf("* Compression Tests:                      %s\n", compressionOk? "Ok": "Failed");
      printf("* Variable Importance Tests:              %s\n", importanceOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === linreg testing unit ===
// Task generation. Meaningless task, just random numbers.
static void testlinregunit_generaterandomtask(double xl, double xr, bool randomx, double ymin, double ymax, double smin, double smax, ae_int_t n, RMatrix *xy, RVector *s) {
   ae_int_t i;
   ae_matrix_set_length(xy, n, 1 + 1);
   ae_vector_set_length(s, n);
   for (i = 0; i < n; i++) {
      if (randomx) {
         xy->xyR[i][0] = xl + (xr - xl) * randomreal();
      } else {
         xy->xyR[i][0] = xl + (xr - xl) * i / (n - 1);
      }
      xy->xyR[i][1] = ymin + (ymax - ymin) * randomreal();
      s->xR[i] = smin + (smax - smin) * randomreal();
   }
}

// Normal random numbers
static double testlinregunit_generatenormal(double mean, double sigma) {
   double u;
   double v;
   double sum;
   double result;
   result = mean;
   while (true) {
      u = (2 * randominteger(2) - 1) * randomreal();
      v = (2 * randominteger(2) - 1) * randomreal();
      sum = u * u + v * v;
      if (sum < 1.0 && sum > 0.0) {
         sum = sqrt(-2 * log(sum) / sum);
         result = sigma * u * sum + mean;
         break;
      }
   }
   return result;
}

// Task generation.
static void testlinregunit_generatetask(double a, double b, double xl, double xr, bool randomx, double smin, double smax, ae_int_t n, RMatrix *xy, RVector *s) {
   ae_int_t i;
   ae_matrix_set_length(xy, n, 1 + 1);
   ae_vector_set_length(s, n);
   for (i = 0; i < n; i++) {
      if (randomx) {
         xy->xyR[i][0] = xl + (xr - xl) * randomreal();
      } else {
         xy->xyR[i][0] = xl + (xr - xl) * i / (n - 1);
      }
      s->xR[i] = smin + (smax - smin) * randomreal();
      xy->xyR[i][1] = a + b * xy->xyR[i][0] + testlinregunit_generatenormal(0.0, s->xR[i]);
   }
}

// Task generation.
// y[i] are filled based on A, B, X[I], S[I]
static void testlinregunit_filltaskwithy(double a, double b, ae_int_t n, RMatrix *xy, RVector *s) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      xy->xyR[i][1] = a + b * xy->xyR[i][0] + testlinregunit_generatenormal(0.0, s->xR[i]);
   }
}

// Moments estimates and their errors
static void testlinregunit_calculatemv(RVector *x, ae_int_t n, double *mean, double *means, double *stddev, double *stddevs) {
   ae_int_t i;
   double v1;
   double v2;
   double variance;
   *mean = 0;
   *means = 0;
   *stddev = 0;
   *stddevs = 0;
   *mean = 0.0;
   *means = 1.0;
   *stddev = 0.0;
   *stddevs = 1.0;
   variance = 0.0;
   if (n <= 1) {
      return;
   }
// Mean
   for (i = 0; i < n; i++) {
      *mean += x->xR[i];
   }
   *mean /= n;
// Variance (using corrected two-pass algorithm)
   if (n != 1) {
      v1 = 0.0;
      for (i = 0; i < n; i++) {
         v1 += sqr(x->xR[i] - (*mean));
      }
      v2 = 0.0;
      for (i = 0; i < n; i++) {
         v2 += x->xR[i] - (*mean);
      }
      v2 = sqr(v2) / n;
      variance = (v1 - v2) / (n - 1);
      if (variance < 0.0) {
         variance = 0.0;
      }
      *stddev = sqrt(variance);
   }
// Errors
   *means = *stddev / sqrt(n);
   *stddevs = *stddev * sqrt(2.0) / sqrt(n - 1);
}

// Unsets LR
static void testlinregunit_unsetlr(linearmodel *lr) {
   ae_frame _frame_block;
   ae_int_t info;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(lrreport, rep);
   ae_matrix_set_length(&xy, 5 + 1, 1 + 1);
   for (i = 0; i <= 5; i++) {
      xy.xyR[i][0] = 0.0;
      xy.xyR[i][1] = 0.0;
   }
   lrbuild(&xy, 6, 1, &info, lr, &rep);
   ae_assert(info > 0, "Assertion failed");
   ae_frame_leave();
}

bool testlinreg() {
   ae_frame _frame_block;
   double sigmathreshold;
   ae_int_t maxn;
   ae_int_t passcount;
   ae_int_t estpasscount;
   double threshold;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t tmpi;
   ae_int_t pass;
   ae_int_t epass;
   ae_int_t m;
   ae_int_t tasktype;
   ae_int_t modeltype;
   ae_int_t m1;
   ae_int_t m2;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t info;
   ae_int_t info2;
   double y1;
   double y2;
   bool allsame;
   double ea;
   double eb;
   double varatested;
   double varbtested;
   double a;
   double b;
   double vara;
   double varb;
   double a2;
   double b2;
   double covab;
   double corrab;
   double p;
   ae_int_t qcnt;
   double f;
   double fp;
   double fm;
   double v;
   double vv;
   double cvrmserror;
   double cvavgerror;
   double cvavgrelerror;
   double rmserror;
   double avgerror;
   double avgrelerror;
   bool nondefect;
   double sinshift;
   double tasklevel;
   double noiselevel;
   double hstep;
   double sigma;
   double mean;
   double means;
   double stddev;
   double stddevs;
   bool slcOk;
   bool slOk;
   bool grcovOk;
   bool groptOk;
   bool grestOk;
   bool grotherOk;
   bool grconvOk;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(s2, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(ta, 0, DT_REAL);
   NewVector(tb, 0, DT_REAL);
   NewVector(tc, 0, DT_REAL);
   NewVector(xy0, 0, DT_REAL);
   NewVector(tmpweights, 0, DT_REAL);
   NewObj(linearmodel, w);
   NewObj(linearmodel, wt);
   NewObj(linearmodel, wt2);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(qtbl, 0, DT_REAL);
   NewVector(qvals, 0, DT_REAL);
   NewVector(qsigma, 0, DT_REAL);
   NewObj(lrreport, ar);
   NewObj(lrreport, ar2);
// Primary settings
   maxn = 40;
   passcount = 3;
   estpasscount = 1000;
   sigmathreshold = 7.0;
   threshold = 1000000.0 * machineepsilon;
   slOk = true;
   slcOk = true;
   grcovOk = true;
   groptOk = true;
   grestOk = true;
   grotherOk = true;
   grconvOk = true;
   Ok = true;
// Quantiles table setup
   qcnt = 5;
   ae_vector_set_length(&qtbl, qcnt);
   ae_vector_set_length(&qvals, qcnt);
   ae_vector_set_length(&qsigma, qcnt);
   qtbl.xR[0] = 0.5;
   qtbl.xR[1] = 0.25;
   qtbl.xR[2] = 0.10;
   qtbl.xR[3] = 0.05;
   qtbl.xR[4] = 0.025;
   for (i = 0; i < qcnt; i++) {
      qsigma.xR[i] = sqrt(qtbl.xR[i] * (1 - qtbl.xR[i]) / estpasscount);
   }
// Other setup
   ae_vector_set_length(&ta, estpasscount);
   ae_vector_set_length(&tb, estpasscount);
// Test straight line regression
   for (n = 2; n <= maxn; n++) {
   // Fail/pass test
      testlinregunit_generaterandomtask(-1.0, 1.0, false, -1.0, 1.0, 1.0, 2.0, n, &xy, &s);
      lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
      slcOk = slcOk && info == 1;
      testlinregunit_generaterandomtask(1.0, 1.0, false, -1.0, 1.0, 1.0, 2.0, n, &xy, &s);
      lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
      slcOk = slcOk && info == -3;
      testlinregunit_generaterandomtask(-1.0, 1.0, false, -1.0, 1.0, -1.0, -1.0, n, &xy, &s);
      lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
      slcOk = slcOk && info == -2;
      testlinregunit_generaterandomtask(-1.0, 1.0, false, -1.0, 1.0, 2.0, 1.0, 2, &xy, &s);
      lrlines(&xy, &s, 1, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
      slcOk = slcOk && info == -1;
   // Multipass tests
      for (pass = 1; pass <= passcount; pass++) {
      // Test S variant against non-S variant
         ea = randommid();
         eb = randommid();
         testlinregunit_generatetask(ea, eb, -5.0 * randomreal(), +5.0 * randomreal(), randombool(), 1.0, 1.0, n, &xy, &s);
         lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
         lrline(&xy, n, &info2, &a2, &b2);
         if (info != 1 || info2 != 1) {
            slcOk = false;
         } else {
            slOk = slOk && NearAtR(a, a2, threshold) && NearAtR(b, b2, threshold);
         }
      // Test for A/B
      //
      // Generate task with exact, non-perturbed y[i],
      // then make non-zero s[i]
         ea = randommid();
         eb = randommid();
         testlinregunit_generatetask(ea, eb, -5.0 * randomreal(), +5.0 * randomreal(), n > 4, 0.0, 0.0, n, &xy, &s);
         for (i = 0; i < n; i++) {
            s.xR[i] = 1 + randomreal();
         }
         lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
         if (info != 1) {
            slcOk = false;
         } else {
            slOk = slOk && NearAtR(a, ea, 0.001) && NearAtR(b, eb, 0.001);
         }
      // Test for VarA, VarB, P (P is being tested only for N > 2)
         for (i = 0; i < qcnt; i++) {
            qvals.xR[i] = 0.0;
         }
         ea = randommid();
         eb = randommid();
         testlinregunit_generatetask(ea, eb, -5.0 * randomreal(), +5.0 * randomreal(), n > 4, 1.0, 2.0, n, &xy, &s);
         lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
         if (info != 1) {
            slcOk = false;
            continue;
         }
         varatested = vara;
         varbtested = varb;
         for (epass = 0; epass < estpasscount; epass++) {
         // Generate
            testlinregunit_filltaskwithy(ea, eb, n, &xy, &s);
            lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
            if (info != 1) {
               slcOk = false;
               continue;
            }
         // A, B, P
         // (P is being tested for uniformity, additional p-tests are below)
            ta.xR[epass] = a;
            tb.xR[epass] = b;
            for (i = 0; i < qcnt; i++) {
               if (p <= qtbl.xR[i]) {
                  qvals.xR[i] += 1.0 / estpasscount;
               }
            }
         }
         testlinregunit_calculatemv(&ta, estpasscount, &mean, &means, &stddev, &stddevs);
         slOk = slOk && NearR(mean, ea, means * sigmathreshold);
         slOk = slOk && NearR(stddev, sqrt(varatested), stddevs * sigmathreshold);
         testlinregunit_calculatemv(&tb, estpasscount, &mean, &means, &stddev, &stddevs);
         slOk = slOk && NearR(mean, eb, means * sigmathreshold);
         slOk = slOk && NearR(stddev, sqrt(varbtested), stddevs * sigmathreshold);
         if (n > 2) {
            for (i = 0; i < qcnt; i++) {
               if (!NearAtR(qtbl.xR[i], qvals.xR[i], qsigma.xR[i] * sigmathreshold)) {
                  slOk = false;
               }
            }
         }
      // Additional tests for P: correlation with fit quality
         if (n > 2) {
            testlinregunit_generatetask(ea, eb, -5.0 * randomreal(), +5.0 * randomreal(), false, 0.0, 0.0, n, &xy, &s);
            for (i = 0; i < n; i++) {
               s.xR[i] = 1 + randomreal();
            }
            lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
            if (info != 1) {
               slcOk = false;
               continue;
            }
            slOk = slOk && p >= 0.999;
            testlinregunit_generatetask(0.0, 0.0, -5.0 * randomreal(), +5.0 * randomreal(), false, 1.0, 1.0, n, &xy, &s);
            for (i = 0; i < n; i++) {
               if (i % 2 == 0) {
                  xy.xyR[i][1] = 5.0;
               } else {
                  xy.xyR[i][1] = -5.0;
               }
            }
            if (n % 2 != 0) {
               xy.xyR[n - 1][1] = 0.0;
            }
            lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
            if (info != 1) {
               slcOk = false;
               continue;
            }
            slOk = slOk && p <= 0.001;
         }
      }
   }
// General regression tests:
// Simple linear tests (small sample, optimum point, covariance)
   for (n = 3; n <= maxn; n++) {
      ae_vector_set_length(&s, n);
   // Linear tests:
   // a. random points, sigmas
   // b. no sigmas
      ae_matrix_set_length(&xy, n, 1 + 1);
      for (i = 0; i < n; i++) {
         xy.xyR[i][0] = randommid();
         xy.xyR[i][1] = randommid();
         s.xR[i] = 1 + randomreal();
      }
      lrbuilds(&xy, &s, n, 1, &info, &wt, &ar);
      if (info != 1) {
         grconvOk = false;
         continue;
      }
      lrunpack(&wt, &tmpweights, &tmpi);
      lrlines(&xy, &s, n, &info2, &a, &b, &vara, &varb, &covab, &corrab, &p);
      groptOk = groptOk && NearAtR(a, tmpweights.xR[1], threshold);
      groptOk = groptOk && NearAtR(b, tmpweights.xR[0], threshold);
      grcovOk = grcovOk && NearAtR(vara, ar.c.xyR[1][1], threshold);
      grcovOk = grcovOk && NearAtR(varb, ar.c.xyR[0][0], threshold);
      grcovOk = grcovOk && NearAtR(covab, ar.c.xyR[1][0], threshold);
      grcovOk = grcovOk && NearAtR(covab, ar.c.xyR[0][1], threshold);
      lrbuild(&xy, n, 1, &info, &wt, &ar);
      if (info != 1) {
         grconvOk = false;
         continue;
      }
      lrunpack(&wt, &tmpweights, &tmpi);
      lrline(&xy, n, &info2, &a, &b);
      groptOk = groptOk && NearAtR(a, tmpweights.xR[1], threshold);
      groptOk = groptOk && NearAtR(b, tmpweights.xR[0], threshold);
   }
// S covariance versus S-less covariance.
// Slightly skewed task, large sample size.
// Will S-less subroutine estimate covariance matrix good enough?
   n = 1000 + randominteger(3000);
   sigma = 0.1 + randomreal() * 1.9;
   ae_matrix_set_length(&xy, n, 1 + 1);
   ae_vector_set_length(&s, n);
   for (i = 0; i < n; i++) {
      xy.xyR[i][0] = 1.5 * randomreal() - 0.5;
      xy.xyR[i][1] = 1.2 * xy.xyR[i][0] - 0.3 + testlinregunit_generatenormal(0.0, sigma);
      s.xR[i] = sigma;
   }
   lrbuild(&xy, n, 1, &info, &wt, &ar);
   lrlines(&xy, &s, n, &info2, &a, &b, &vara, &varb, &covab, &corrab, &p);
   if (info != 1 || info2 != 1) {
      grconvOk = false;
   } else {
      grcovOk = grcovOk && SmallAtR(log(ar.c.xyR[0][0] / varb), log(1.2));
      grcovOk = grcovOk && SmallAtR(log(ar.c.xyR[1][1] / vara), log(1.2));
      grcovOk = grcovOk && SmallAtR(log(ar.c.xyR[0][1] / covab), log(1.2));
      grcovOk = grcovOk && SmallAtR(log(ar.c.xyR[1][0] / covab), log(1.2));
   }
// General tests:
// * basis functions - up to cubic
// * task types:
// * data set is noisy sine half-period with random shift
// * tests:
//   unpacking/packing
//   optimality
//   error estimates
// * tasks:
//   0 = noised sine
//   1 = degenerate task with 1-of-n encoded categorical variables
//   2 = random task with large variation (for 1-type models)
//   3 = random task with small variation (for 1-type models)
//
//   Additional tasks TODO
//   specially designed task with defective vectors which leads to
//   the failure of the fast CV formula.
//
   m1 = 0;
   m2 = -1;
   n1 = 0;
   n2 = -1;
   for (modeltype = 0; modeltype <= 1; modeltype++) {
      for (tasktype = 0; tasktype <= 3; tasktype++) {
         if (tasktype == 0) {
            m1 = 1;
            m2 = 3;
         }
         if (tasktype == 1) {
            m1 = 9;
            m2 = 9;
         }
         if (tasktype == 2 || tasktype == 3) {
            m1 = 9;
            m2 = 9;
         }
         for (m = m1; m <= m2; m++) {
            if (tasktype == 0) {
               n1 = m + 3;
               n2 = m + 20;
            }
            if (tasktype == 1) {
               n1 = 70 + randominteger(70);
               n2 = n1;
            }
            if (tasktype == 2 || tasktype == 3) {
               n1 = 100;
               n2 = n1;
            }
            for (n = n1; n <= n2; n++) {
               ae_matrix_set_length(&xy, n, m + 1);
               ae_vector_set_length(&xy0, n);
               ae_vector_set_length(&s, n);
               hstep = 0.001;
               noiselevel = 0.2;
            // Prepare task
               if (tasktype == 0) {
                  for (i = 0; i < n; i++) {
                     xy.xyR[i][0] = randommid();
                  }
                  for (i = 0; i < n; i++) {
                     for (j = 1; j < m; j++) {
                        xy.xyR[i][j] = xy.xyR[i][0] * xy.xyR[i][j - 1];
                     }
                  }
                  sinshift = randomreal() * pi;
                  for (i = 0; i < n; i++) {
                     xy0.xR[i] = sin(sinshift + pi * 0.5 * (xy.xyR[i][0] + 1));
                     xy.xyR[i][m] = xy0.xR[i] + noiselevel * testlinregunit_generatenormal(0.0, 1.0);
                  }
               }
               if (tasktype == 1) {
                  ae_assert(m == 9, "Assertion failed");
                  ae_vector_set_length(&ta, 8 + 1);
                  ta.xR[0] = 1.0;
                  ta.xR[1] = 2.0;
                  ta.xR[2] = 3.0;
                  ta.xR[3] = 0.25;
                  ta.xR[4] = 0.5;
                  ta.xR[5] = 0.75;
                  ta.xR[6] = 0.06;
                  ta.xR[7] = 0.12;
                  ta.xR[8] = 0.18;
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        xy.xyR[i][j] = 0.0;
                     }
                     xy.xyR[i][0 + i % 3] = 1.0;
                     xy.xyR[i][3 + i / 3 % 3] = 1.0;
                     xy.xyR[i][6 + i / 9 % 3] = 1.0;
                     v = ae_v_dotproduct(xy.xyR[i], 1, ta.xR, 1, 8 + 1);
                     xy0.xR[i] = v;
                     xy.xyR[i][m] = v + noiselevel * testlinregunit_generatenormal(0.0, 1.0);
                  }
               }
               if (tasktype == 2 || tasktype == 3) {
                  ae_assert(m == 9, "Assertion failed");
                  ae_vector_set_length(&ta, 8 + 1);
                  ta.xR[0] = 1.0;
                  ta.xR[1] = -2.0;
                  ta.xR[2] = 3.0;
                  ta.xR[3] = 0.25;
                  ta.xR[4] = -0.5;
                  ta.xR[5] = 0.75;
                  ta.xR[6] = -0.06;
                  ta.xR[7] = 0.12;
                  ta.xR[8] = -0.18;
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        if (tasktype == 2) {
                           xy.xyR[i][j] = 1 + testlinregunit_generatenormal(0.0, 3.0);
                        } else {
                           xy.xyR[i][j] = 1 + testlinregunit_generatenormal(0.0, 0.05);
                        }
                     }
                     v = ae_v_dotproduct(xy.xyR[i], 1, ta.xR, 1, 8 + 1);
                     xy0.xR[i] = v;
                     xy.xyR[i][m] = v + noiselevel * testlinregunit_generatenormal(0.0, 1.0);
                  }
               }
               for (i = 0; i < n; i++) {
                  s.xR[i] = 1 + randomreal();
               }
            // Solve (using S-variant, non-S-variant is not tested)
               if (modeltype == 0) {
                  lrbuilds(&xy, &s, n, m, &info, &wt, &ar);
               } else {
                  lrbuildzs(&xy, &s, n, m, &info, &wt, &ar);
               }
               if (info != 1) {
                  grconvOk = false;
                  continue;
               }
               lrunpack(&wt, &tmpweights, &tmpi);
            // LRProcess test
               ae_vector_set_length(&x, m);
               v = tmpweights.xR[m];
               for (i = 0; i < m; i++) {
                  x.xR[i] = randommid();
                  v += tmpweights.xR[i] * x.xR[i];
               }
               grotherOk = grotherOk && NearAtR(v, lrprocess(&wt, &x), rmax2(fabs(v), 1.0) * threshold); //(@)
            // LRPack test
               lrpack(&tmpweights, m, &wt2);
               ae_vector_set_length(&x, m);
               for (i = 0; i < m; i++) {
                  x.xR[i] = randommid();
               }
               v = lrprocess(&wt, &x);
               grotherOk = grotherOk && NearAtR(v, lrprocess(&wt2, &x), fabs(v) * threshold); //(@)
            // Optimality test
               for (k = 0; k <= m; k++) {
                  if (modeltype == 1 && k == m) {
                  // 0-type models (with non-zero constant term)
                  // are tested for optimality of all coefficients.
                  //
                  // 1-type models (with zero constant term)
                  // are tested for optimality of non-constant terms only.
                     continue;
                  }
                  f = 0.0;
                  fp = 0.0;
                  fm = 0.0;
                  for (i = 0; i < n; i++) {
                     v = tmpweights.xR[m];
                     for (j = 0; j < m; j++) {
                        v += xy.xyR[i][j] * tmpweights.xR[j];
                     }
                     f += sqr((v - xy.xyR[i][m]) / s.xR[i]);
                     if (k < m) {
                        vv = xy.xyR[i][k];
                     } else {
                        vv = 1.0;
                     }
                     fp += sqr((v + vv * hstep - xy.xyR[i][m]) / s.xR[i]);
                     fm += sqr((v - vv * hstep - xy.xyR[i][m]) / s.xR[i]);
                  }
                  groptOk = groptOk && f <= fp && f <= fm;
               }
            // Covariance matrix test:
            // generate random vector, project coefficients on it,
            // compare variance of projection with estimate provided
            // by cov.matrix
               ae_vector_set_length(&ta, estpasscount);
               ae_vector_set_length(&tb, m + 1);
               ae_vector_set_length(&tc, m + 1);
               ae_matrix_set_length(&xy2, n, m + 1);
               for (i = 0; i <= m; i++) {
                  tb.xR[i] = testlinregunit_generatenormal(0.0, 1.0);
               }
               for (epass = 0; epass < estpasscount; epass++) {
                  for (i = 0; i < n; i++) {
                     ae_v_move(xy2.xyR[i], 1, xy.xyR[i], 1, m);
                     xy2.xyR[i][m] = xy0.xR[i] + s.xR[i] * testlinregunit_generatenormal(0.0, 1.0);
                  }
                  if (modeltype == 0) {
                     lrbuilds(&xy2, &s, n, m, &info, &wt, &ar2);
                  } else {
                     lrbuildzs(&xy2, &s, n, m, &info, &wt, &ar2);
                  }
                  if (info != 1) {
                     ta.xR[epass] = 0.0;
                     grconvOk = false;
                     continue;
                  }
                  lrunpack(&wt, &w2, &tmpi);
                  v = ae_v_dotproduct(tb.xR, 1, w2.xR, 1, m + 1);
                  ta.xR[epass] = v;
               }
               testlinregunit_calculatemv(&ta, estpasscount, &mean, &means, &stddev, &stddevs);
               for (i = 0; i <= m; i++) {
                  v = ae_v_dotproduct(tb.xR, 1, &ar.c.xyR[0][i], ar.c.stride, m + 1);
                  tc.xR[i] = v;
               }
               v = ae_v_dotproduct(tc.xR, 1, tb.xR, 1, m + 1);
               grcovOk = grcovOk && NearR(sqrt(v), stddev, stddevs * sigmathreshold);
            // Test for the fast CV error:
            // calculate CV error by definition (leaving out N
            // points and recalculating solution).
            //
            // Test for the training set error
               cvrmserror = 0.0;
               cvavgerror = 0.0;
               cvavgrelerror = 0.0;
               rmserror = 0.0;
               avgerror = 0.0;
               avgrelerror = 0.0;
               ae_matrix_set_length(&xy2, n - 1, m + 1);
               ae_vector_set_length(&s2, n - 1);
               for (i = 0; i < n - 1; i++) {
                  ae_v_move(xy2.xyR[i], 1, xy.xyR[i + 1], 1, m + 1);
                  s2.xR[i] = s.xR[i + 1];
               }
               for (i = 0; i < n; i++) {
               // Trn
                  v = ae_v_dotproduct(xy.xyR[i], 1, tmpweights.xR, 1, m);
                  v += tmpweights.xR[m];
                  rmserror += sqr(v - xy.xyR[i][m]);
                  avgerror += fabs(v - xy.xyR[i][m]);
                  avgrelerror += fabs((v - xy.xyR[i][m]) / xy.xyR[i][m]);
               // CV: non-defect vectors only
                  nondefect = true;
                  for (k = 0; k < ar.ncvdefects; k++) {
                     if (ar.cvdefects.xZ[k] == i) {
                        nondefect = false;
                     }
                  }
                  if (nondefect) {
                     if (modeltype == 0) {
                        lrbuilds(&xy2, &s2, n - 1, m, &info2, &wt, &ar2);
                     } else {
                        lrbuildzs(&xy2, &s2, n - 1, m, &info2, &wt, &ar2);
                     }
                     if (info2 != 1) {
                        grconvOk = false;
                        continue;
                     }
                     lrunpack(&wt, &w2, &tmpi);
                     v = ae_v_dotproduct(xy.xyR[i], 1, w2.xR, 1, m);
                     v += w2.xR[m];
                     cvrmserror += sqr(v - xy.xyR[i][m]);
                     cvavgerror += fabs(v - xy.xyR[i][m]);
                     cvavgrelerror += fabs((v - xy.xyR[i][m]) / xy.xyR[i][m]);
                  }
               // Next set
                  if (i != n - 1) {
                     ae_v_move(xy2.xyR[i], 1, xy.xyR[i], 1, m + 1);
                     s2.xR[i] = s.xR[i];
                  }
               }
               cvrmserror = sqrt(cvrmserror / (n - ar.ncvdefects));
               cvavgerror /= n - ar.ncvdefects;
               cvavgrelerror /= n - ar.ncvdefects;
               rmserror = sqrt(rmserror / n);
               avgerror /= n;
               avgrelerror /= n;
               grestOk = grestOk && SmallAtR(log(ar.cvrmserror / cvrmserror), log(1 + 1.0E-5));
               grestOk = grestOk && SmallAtR(log(ar.cvavgerror / cvavgerror), log(1 + 1.0E-5));
               grestOk = grestOk && SmallAtR(log(ar.cvavgrelerror / cvavgrelerror), log(1 + 1.0E-5));
               grestOk = grestOk && SmallAtR(log(ar.rmserror / rmserror), log(1 + 1.0E-5));
               grestOk = grestOk && SmallAtR(log(ar.avgerror / avgerror), log(1 + 1.0E-5));
               grestOk = grestOk && SmallAtR(log(ar.avgrelerror / avgrelerror), log(1 + 1.0E-5));
            }
         }
      }
   }
// Additional subroutines
   for (pass = 1; pass <= 50; pass++) {
      n = 2;
      do {
         noiselevel = randomreal() + 0.1;
         tasklevel = randommid();
      } while (NearAtR(noiselevel, tasklevel, 0.05));
      ae_matrix_set_length(&xy, 3 * n, 1 + 1);
      for (i = 0; i < n; i++) {
         xy.xyR[3 * i][0] = (double)i;
         xy.xyR[3 * i + 1][0] = (double)i;
         xy.xyR[3 * i + 2][0] = (double)i;
         xy.xyR[3 * i][1] = tasklevel - noiselevel;
         xy.xyR[3 * i + 1][1] = tasklevel;
         xy.xyR[3 * i + 2][1] = tasklevel + noiselevel;
      }
      lrbuild(&xy, 3 * n, 1, &info, &wt, &ar);
      if (info == 1) {
         lrunpack(&wt, &tmpweights, &tmpi);
         v = lrrmserror(&wt, &xy, 3 * n);
         grotherOk = grotherOk && NearAtR(v, noiselevel * sqrt(2.0 / 3.0), threshold); //(@)
         v = lravgerror(&wt, &xy, 3 * n);
         grotherOk = grotherOk && NearAtR(v, noiselevel * (2.0 / 3.0), threshold); //(@)
         v = lravgrelerror(&wt, &xy, 3 * n);
         vv = (fabs(noiselevel / (tasklevel - noiselevel)) + fabs(noiselevel / (tasklevel + noiselevel))) / 3;
         grotherOk = grotherOk && NearAtR(v, vv, threshold * vv); //(@)
      } else {
         grotherOk = false; //(@)
      }
      for (i = 0; i < n; i++) {
         xy.xyR[3 * i][0] = (double)i;
         xy.xyR[3 * i + 1][0] = (double)i;
         xy.xyR[3 * i + 2][0] = (double)i;
         xy.xyR[3 * i][1] = -noiselevel;
         xy.xyR[3 * i + 1][1] = 0.0;
         xy.xyR[3 * i + 2][1] = noiselevel;
      }
      lrbuild(&xy, 3 * n, 1, &info, &wt, &ar);
      if (info == 1) {
         lrunpack(&wt, &tmpweights, &tmpi);
         v = lravgrelerror(&wt, &xy, 3 * n);
         grotherOk = grotherOk && NearAtR(v, 1, threshold); //(@)
      } else {
         grotherOk = false; //(@)
      }
   }
   for (pass = 1; pass <= 10; pass++) {
      m = 1 + randominteger(5);
      n = 10 + randominteger(10);
      ae_matrix_set_length(&xy, n, m + 1);
      for (i = 0; i < n; i++) {
         for (j = 0; j <= m; j++) {
            xy.xyR[i][j] = randommid();
         }
      }
      lrbuild(&xy, n, m, &info, &w, &ar);
      if (info < 0) {
         grotherOk = false; //(@)
         break;
      }
      ae_vector_set_length(&x1, m);
      ae_vector_set_length(&x2, m);
   // Same inputs on original leads to same outputs
   // on copy created using LRCopy
      testlinregunit_unsetlr(&wt);
      lrcopy(&w, &wt);
      for (i = 0; i < m; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      y1 = lrprocess(&w, &x1);
      y2 = lrprocess(&wt, &x2);
      allsame = y1 == y2;
      grotherOk = grotherOk && allsame; //(@)
   }
// TODO: Degenerate tests (when design matrix and right part are zero)
// The final report.
   Ok = slOk && slcOk && groptOk && grcovOk && grestOk && grotherOk && grconvOk;
   if (!Ok || !silent) {
      printf("Regression Tests\n");
      printf("* Straight Line Regression:               %s\n", slOk? "Ok": "Failed");
      printf("* Straight Line Regression Convergence:   %s\n", slcOk? "Ok": "Failed");
      printf("* General Linear Regression:\n");
      printf("* - Optimality:                           %s\n", groptOk? "Ok": "Failed");
      printf("* - Covariance Matrix:                    %s\n", grcovOk? "Ok": "Failed");
      printf("* - Error Estimates:                      %s\n", grestOk? "Ok": "Failed");
      printf("* - Convergence:                          %s\n", grconvOk? "Ok": "Failed");
      printf("* - Other Subroutines:                    %s\n", grotherOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === filters testing unit ===
// This function tests SMA(k) filter.
// The constant "silent" controls detailed error reporting.
static bool testsma() {
   ae_frame _frame_block;
   bool precomputedOk;
   bool zerohandlingOk;
   double threshold;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   threshold = 1000.0 * machineepsilon;
   if (!silent) {
      printf("SMA(K) Test\n");
   }
// Test several pre-computed problems.
//
// NOTE: tests below rely on the fact that floating point
//       additions and subtractions are exact when dealing
//       with integer values.
   precomputedOk = true;
   ae_vector_set_length(&x, 1);
   x.xR[0] = 7.0;
   filtersma(&x, 1, 1);
   precomputedOk = precomputedOk && x.xR[0] == 7.0;
   ae_vector_set_length(&x, 3);
   x.xR[0] = 7.0;
   x.xR[1] = 8.0;
   x.xR[2] = 9.0;
   filtersma(&x, 3, 1);
   precomputedOk = precomputedOk && x.xR[0] == 7.0 && x.xR[1] == 8.0 && x.xR[2] == 9.0;
   filtersma(&x, 3, 2);
   precomputedOk = precomputedOk && x.xR[0] == 7.0 && x.xR[1] == 7.5 && x.xR[2] == 8.5;
   ae_vector_set_length(&x, 3);
   x.xR[0] = 7.0;
   x.xR[1] = 8.0;
   x.xR[2] = 9.0;
   filtersma(&x, 3, 4);
   precomputedOk = precomputedOk && x.xR[0] == 7.0 && x.xR[1] == 7.5 && x.xR[2] == 8.0;
// Test zero-handling:
// a) when we have non-zero sequence (N1 elements) followed by zero sequence
//    (N2 elements), then first N1+K-1 elements of the processed sequence are
//    non-zero, but elements since (N1+K)th must be exactly zero.
// b) similar property holds for zero sequence followed by non-zero one
//
// Naive implementation of SMA does not have such property.
//
// NOTE: it is important to initialize X with non-integer elements with long
// binary mantissas, because this test tries to test behaviour in the presence
// of roundoff errors, and it will be useless when used with integer inputs.
   zerohandlingOk = true;
   ae_vector_set_length(&x, 10);
   x.xR[0] = sqrt(2.0);
   x.xR[1] = sqrt(3.0);
   x.xR[2] = sqrt(5.0);
   x.xR[3] = sqrt(6.0);
   x.xR[4] = sqrt(7.0);
   x.xR[5] = 0.0;
   x.xR[6] = 0.0;
   x.xR[7] = 0.0;
   x.xR[8] = 0.0;
   x.xR[9] = 0.0;
   filtersma(&x, 10, 3);
   zerohandlingOk = zerohandlingOk && NearAtR(x.xR[0], sqrt(2.0), threshold);
   zerohandlingOk = zerohandlingOk && NearAtR(x.xR[1], (sqrt(2.0) + sqrt(3.0)) / 2, threshold);
   zerohandlingOk = zerohandlingOk && NearAtR(x.xR[2], (sqrt(2.0) + sqrt(3.0) + sqrt(5.0)) / 3, threshold);
   zerohandlingOk = zerohandlingOk && NearAtR(x.xR[3], (sqrt(3.0) + sqrt(5.0) + sqrt(6.0)) / 3, threshold);
   zerohandlingOk = zerohandlingOk && NearAtR(x.xR[4], (sqrt(5.0) + sqrt(6.0) + sqrt(7.0)) / 3, threshold);
   zerohandlingOk = zerohandlingOk && NearAtR(x.xR[5], (sqrt(6.0) + sqrt(7.0)) / 3, threshold);
   zerohandlingOk = zerohandlingOk && NearAtR(x.xR[6], sqrt(7.0) / 3, threshold);
   zerohandlingOk = zerohandlingOk && x.xR[7] == 0.0;
   zerohandlingOk = zerohandlingOk && x.xR[8] == 0.0;
   zerohandlingOk = zerohandlingOk && x.xR[9] == 0.0;
   x.xR[0] = 0.0;
   x.xR[1] = 0.0;
   x.xR[2] = 0.0;
   x.xR[3] = 0.0;
   x.xR[4] = 0.0;
   x.xR[5] = sqrt(2.0);
   x.xR[6] = sqrt(3.0);
   x.xR[7] = sqrt(5.0);
   x.xR[8] = sqrt(6.0);
   x.xR[9] = sqrt(7.0);
   filtersma(&x, 10, 3);
   zerohandlingOk = zerohandlingOk && x.xR[0] == 0.0;
   zerohandlingOk = zerohandlingOk && x.xR[1] == 0.0;
   zerohandlingOk = zerohandlingOk && x.xR[2] == 0.0;
   zerohandlingOk = zerohandlingOk && x.xR[3] == 0.0;
   zerohandlingOk = zerohandlingOk && x.xR[4] == 0.0;
   zerohandlingOk = zerohandlingOk && NearAtR(x.xR[5], sqrt(2.0) / 3, threshold);
   zerohandlingOk = zerohandlingOk && NearAtR(x.xR[6], (sqrt(2.0) + sqrt(3.0)) / 3, threshold);
   zerohandlingOk = zerohandlingOk && NearAtR(x.xR[7], (sqrt(2.0) + sqrt(3.0) + sqrt(5.0)) / 3, threshold);
   zerohandlingOk = zerohandlingOk && NearAtR(x.xR[8], (sqrt(3.0) + sqrt(5.0) + sqrt(6.0)) / 3, threshold);
   zerohandlingOk = zerohandlingOk && NearAtR(x.xR[9], (sqrt(5.0) + sqrt(6.0) + sqrt(7.0)) / 3, threshold);
// Final result
   Ok = precomputedOk && zerohandlingOk;
   ae_frame_leave();
   return Ok;
}

// This function tests EMA(alpha) filter.
// The constant "silent" controls detailed error reporting.
static bool testema() {
   ae_frame _frame_block;
   bool precomputedOk;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   if (!silent) {
      printf("EMA(Alpha) Test\n");
   }
// Test several pre-computed problems.
//
// NOTE: tests below rely on the fact that floating point
//       additions and subtractions are exact when dealing
//       with integer values.
   precomputedOk = true;
   ae_vector_set_length(&x, 1);
   x.xR[0] = 7.0;
   filterema(&x, 1, 1.0);
   precomputedOk = precomputedOk && x.xR[0] == 7.0;
   filterema(&x, 1, 0.5);
   precomputedOk = precomputedOk && x.xR[0] == 7.0;
   ae_vector_set_length(&x, 3);
   x.xR[0] = 7.0;
   x.xR[1] = 8.0;
   x.xR[2] = 9.0;
   filterema(&x, 3, 1.0);
   precomputedOk = precomputedOk && x.xR[0] == 7.0 && x.xR[1] == 8.0 && x.xR[2] == 9.0;
   filterema(&x, 3, 0.5);
   precomputedOk = precomputedOk && x.xR[0] == 7.0 && x.xR[1] == 7.5 && x.xR[2] == 8.25;
// Final result
   Ok = precomputedOk;
   ae_frame_leave();
   return Ok;
}

// This function tests LRMA(k) filter.
// The constant "silent" controls detailed error reporting.
static bool testlrma() {
   ae_frame _frame_block;
   bool precomputedOk;
   double threshold;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   threshold = 1000.0 * machineepsilon;
   if (!silent) {
      printf("LRMA(K) Test\n");
   }
   precomputedOk = true;
// First, check that filter does not changes points for K == 1 or K == 2
   ae_vector_set_length(&x, 1);
   x.xR[0] = 7.0;
   filterlrma(&x, 1, 1);
   precomputedOk = precomputedOk && x.xR[0] == 7.0;
   ae_vector_set_length(&x, 6);
   x.xR[0] = 7.0;
   x.xR[1] = 8.0;
   x.xR[2] = 9.0;
   x.xR[3] = 10.0;
   x.xR[4] = 11.0;
   x.xR[5] = 12.0;
   filterlrma(&x, 6, 1);
   precomputedOk = precomputedOk && x.xR[0] == 7.0 && x.xR[1] == 8.0 && x.xR[2] == 9.0 && x.xR[3] == 10.0 && x.xR[4] == 11.0 && x.xR[5] == 12.0;
   filterlrma(&x, 6, 2);
   precomputedOk = precomputedOk && x.xR[0] == 7.0 && x.xR[1] == 8.0 && x.xR[2] == 9.0 && x.xR[3] == 10.0 && x.xR[4] == 11.0 && x.xR[5] == 12.0;
// Check several precomputed problems
   ae_vector_set_length(&x, 6);
   x.xR[0] = 7.0;
   x.xR[1] = 8.0;
   x.xR[2] = 9.0;
   x.xR[3] = 10.0;
   x.xR[4] = 11.0;
   x.xR[5] = 12.0;
   filterlrma(&x, 6, 3);
   precomputedOk = precomputedOk && NearAtR(x.xR[0], 7, threshold);
   precomputedOk = precomputedOk && NearAtR(x.xR[1], 8, threshold);
   precomputedOk = precomputedOk && NearAtR(x.xR[2], 9, threshold);
   precomputedOk = precomputedOk && NearAtR(x.xR[3], 10, threshold);
   precomputedOk = precomputedOk && NearAtR(x.xR[4], 11, threshold);
   precomputedOk = precomputedOk && NearAtR(x.xR[5], 12, threshold);
   ae_vector_set_length(&x, 6);
   x.xR[0] = 7.0;
   x.xR[1] = 8.0;
   x.xR[2] = 8.0;
   x.xR[3] = 9.0;
   x.xR[4] = 12.0;
   x.xR[5] = 12.0;
   filterlrma(&x, 6, 3);
   precomputedOk = precomputedOk && NearAtR(x.xR[0], 7.0000000000, 1.0E-5);
   precomputedOk = precomputedOk && NearAtR(x.xR[1], 8.0000000000, 1.0E-5);
   precomputedOk = precomputedOk && NearAtR(x.xR[2], 8.1666666667, 1.0E-5);
   precomputedOk = precomputedOk && NearAtR(x.xR[3], 8.8333333333, 1.0E-5);
   precomputedOk = precomputedOk && NearAtR(x.xR[4], 11.6666666667, 1.0E-5);
   precomputedOk = precomputedOk && NearAtR(x.xR[5], 12.5000000000, 1.0E-5);
// Final result
   Ok = precomputedOk;
   ae_frame_leave();
   return Ok;
}

bool testfilters() {
   bool Ok;
   bool smaOk;
   bool emaOk;
   bool lrmaOk;
   if (!silent) printf("Filter Test Breakdown\n");
   smaOk = testsma();
   emaOk = testema();
   lrmaOk = testlrma();
// The final report.
   Ok = smaOk && emaOk && lrmaOk;
   if (!Ok || !silent) {
      printf("Filter Tests\n");
      printf("* SMA:                                    %s\n", smaOk? "Ok": "Failed");
      printf("* EMA:                                    %s\n", emaOk? "Ok": "Failed");
      printf("* LRMA:                                   %s\n", lrmaOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === ssa testing unit ===
// This function tests SSA on several general purpose analysis/prediction
// problems.
static bool testssaunit_testgeneral() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   ae_int_t pass;
   ae_int_t ntracks;
   ae_int_t windowwidth;
   ae_int_t nlasttracklen;
   ae_int_t nzeros;
   ae_int_t nlinear;
   double sinefreq;
   double sineoffs;
   double sineamp;
   ae_int_t windowwidth2;
   ae_int_t nbasis;
   ae_int_t nbasis2;
   ae_int_t ninitial;
   ae_int_t algotype;
   ae_int_t nticks;
   ae_int_t nnoise;
   ae_int_t navg;
   double tol;
   ae_int_t datalen;
   ae_int_t forecastlen;
   ae_int_t mlimit;
   ae_int_t passcount;
   double skipprob;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(ssamodel, state);
   NewObj(ssamodel, state2);
   NewVector(x, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(trend, 0, DT_REAL);
   NewVector(noise, 0, DT_REAL);
   NewVector(sv, 0, DT_REAL);
   NewVector(sv2, 0, DT_REAL);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(trend2, 0, DT_REAL);
   NewVector(noise2, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
// Initialize RNG, test pass count and skip probability.
//
// When we perform several sequential tests on the same model, we may
// skip some of them with probability SkipProb in order to make sure
// that no carry-over effect is observed between tests.
   hqrndrandomize(&rs);
   passcount = 500;
   skipprob = 0.50;
// Iterate over several algorithm types.
// Algorithms unsupported by tests are skipped within tests.
   for (algotype = 1; algotype <= 3; algotype++) {
   // Test that on perfectly constant dataset SSA correctly predicts
   // perfectly constant trend. Additionally test that analysis phase
   // correctly returns nearly-zero noise and nearly-constant trend.
   //
   // Dataset is a one/few sequences with different constants; top-1
   // algorithm is used (or precomputed unit-normalized vector of 1's).
      for (pass = 1; pass <= passcount; pass++) {
         nlasttracklen = -9999999;
         ntracks = 1 + hqrnduniformi(&rs, 3);
         windowwidth = 2 + hqrnduniformi(&rs, 3);
         ssacreate(&state);
         ssasetwindow(&state, windowwidth);
         for (k = 0; k < ntracks; k++) {
            nlasttracklen = windowwidth + hqrnduniformi(&rs, windowwidth);
            v = hqrndnormal(&rs);
            ae_vector_set_length(&x, nlasttracklen);
            for (i = 0; i < nlasttracklen; i++) {
               x.xR[i] = v;
            }
            ssaaddsequence(&state, &x, nlasttracklen);
         }
         if (algotype == 1) {
            ae_matrix_set_length(&b, windowwidth, 1);
            for (i = 0; i < windowwidth; i++) {
               b.xyR[i][0] = 1 / sqrt(windowwidth);
            }
            ssasetalgoprecomputed(&state, &b, windowwidth, 1);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, 1);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, 1);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         tol = 1.0E-6;
         if (hqrnduniformr(&rs) > skipprob) {
            ssaanalyzelastwindow(&state, &trend, &noise, &nticks);
            Ok = Ok && nticks == windowwidth;
            Ok = Ok && noise.cnt == windowwidth;
            Ok = Ok && trend.cnt == windowwidth;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < windowwidth; i++) {
               Ok = Ok && NearAtR(trend.xR[i], x.xR[nlasttracklen + i - windowwidth], tol);
               Ok = Ok && SmallAtR(noise.xR[i], tol);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            ssaanalyzelast(&state, nlasttracklen, &trend, &noise);
            Ok = Ok && noise.cnt == nlasttracklen;
            Ok = Ok && trend.cnt == nlasttracklen;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < nlasttracklen; i++) {
               Ok = Ok && NearAtR(trend.xR[i], x.xR[i], tol);
               Ok = Ok && SmallAtR(noise.xR[i], tol);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 2 * windowwidth);
            ae_vector_set_length(&trend, 0);
            ssaforecastlast(&state, nticks, &trend);
            Ok = Ok && trend.cnt == nticks;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < trend.cnt; i++) {
               Ok = Ok && NearAtR(trend.xR[i], x.xR[nlasttracklen - 1], tol);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 2 * windowwidth);
            navg = 1 + hqrnduniformi(&rs, windowwidth + 3);
            ae_vector_set_length(&trend, 0);
            ssaforecastavglast(&state, navg, nticks, &trend);
            Ok = Ok && trend.cnt == nticks;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < trend.cnt; i++) {
               Ok = Ok && NearAtR(trend.xR[i], x.xR[nlasttracklen - 1], tol);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            datalen = windowwidth + hqrnduniformi(&rs, 10);
            forecastlen = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&x, datalen);
            x.xR[0] = hqrndnormal(&rs);
            for (i = 1; i < datalen; i++) {
               x.xR[i] = x.xR[i - 1];
            }
            ae_vector_set_length(&trend, 0);
            ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
            Ok = Ok && trend.cnt == forecastlen;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < forecastlen; i++) {
               Ok = Ok && NearAtR(trend.xR[i], x.xR[datalen - 1], tol);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            datalen = windowwidth + hqrnduniformi(&rs, 10);
            navg = 1 + hqrnduniformi(&rs, windowwidth + 3);
            forecastlen = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&x, datalen);
            x.xR[0] = hqrndnormal(&rs);
            for (i = 1; i < datalen; i++) {
               x.xR[i] = x.xR[i - 1];
            }
            ae_vector_set_length(&trend, 0);
            ssaforecastavgsequence(&state, &x, datalen, navg, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
            Ok = Ok && trend.cnt == forecastlen;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < forecastlen; i++) {
               Ok = Ok && NearAtR(trend.xR[i], x.xR[datalen - 1], tol);
            }
         }
      }
   // Test that on specially designed linear dataset SSA correctly
   // predicts perfectly linear trend. Additionally test that analysis
   // phase correctly returns nearly-zero noise and nearly-linear trend.
   // Also test that correct basis vectors are returned.
   //
   // Dataset consists of many WindowWidth-sized (exactly) sequences with
   // linear trend. Trend coefficients vary accross sequences. Top-2
   // algorithm is used (or precomputed unit-normalized linear trend basis).
   //
   // NOTE: this test requires NTracks >= 2, WindowWidth >= 3 and TopK == 2 to work;
   //       however, in order to improve numerical properties (diversity among
   //       samples, different slopes and offsets) we set NTracks to be
   //       at least 5.
   //
   // NOTE: one more version of this test verifies scaling properties
   //       by solving larger task (WindowWidth == 100, NTracks == 5,
   //       TrackLen == 2*WindowWidth). This version makes just 5 checks because
   //       of higher cost.
      for (pass = 1; pass <= passcount; pass++) {
         ntracks = 5 + hqrnduniformi(&rs, 10);
         windowwidth = 3 + hqrnduniformi(&rs, 3);
         ssacreate(&state);
         ssasetwindow(&state, windowwidth);
         ae_vector_set_length(&x, windowwidth);
         for (k = 0; k < ntracks; k++) {
            v = hqrndnormal(&rs);
            x.xR[0] = hqrndnormal(&rs);
            for (i = 1; i < windowwidth; i++) {
               x.xR[i] = x.xR[i - 1] + v;
            }
            ssaaddsequence(&state, &x, windowwidth);
         }
         if (algotype == 1) {
            ae_matrix_set_length(&b, windowwidth, 2);
            v = 0.0;
            for (i = 0; i < windowwidth; i++) {
               b.xyR[i][0] = 1 / sqrt(windowwidth);
               b.xyR[i][1] = (double)i;
               v += (double)i / windowwidth;
            }
            vv = 0.0;
            for (i = 0; i < windowwidth; i++) {
               b.xyR[i][1] -= v;
               vv += sqr(b.xyR[i][1]);
            }
            for (i = 0; i < windowwidth; i++) {
               b.xyR[i][1] /= sqrt(vv);
            }
            ssasetalgoprecomputed(&state, &b, windowwidth, 2);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, 2);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, 2);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         tol = 1.0E-6;
         if (hqrnduniformr(&rs) > skipprob) {
         // Basis vectors must be linear/constant functions
            ssagetbasis(&state, &a, &sv, &windowwidth2, &nbasis);
            Ok = Ok && windowwidth2 == windowwidth;
            Ok = Ok && nbasis == 2;
            Ok = Ok && a.cols == nbasis;
            Ok = Ok && a.rows == windowwidth;
            Ok = Ok && sv.cnt == nbasis;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (j = 0; j < nbasis; j++) {
               v = a.xyR[1][j] - a.xyR[0][j];
               for (i = 2; i < windowwidth; i++) {
                  Ok = Ok && NearAtR(a.xyR[i][j], a.xyR[i - 1][j] + v, tol);
               }
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            ssaanalyzelastwindow(&state, &trend, &noise, &nticks);
            Ok = Ok && nticks == windowwidth;
            Ok = Ok && noise.cnt == windowwidth;
            Ok = Ok && trend.cnt == windowwidth;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < windowwidth; i++) {
               Ok = Ok && NearAtR(trend.xR[i], x.xR[i], tol);
               Ok = Ok && SmallAtR(noise.xR[i], tol);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            ssaanalyzelast(&state, windowwidth, &trend, &noise);
            Ok = Ok && noise.cnt == windowwidth;
            Ok = Ok && trend.cnt == windowwidth;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < windowwidth; i++) {
               Ok = Ok && NearAtR(trend.xR[i], x.xR[i], tol);
               Ok = Ok && SmallAtR(noise.xR[i], tol);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 2 * windowwidth);
            ssaforecastlast(&state, nticks, &trend);
            Ok = Ok && trend.cnt == nticks;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            v = x.xR[windowwidth - 1] - x.xR[windowwidth - 2];
            Ok = Ok && NearAtR(trend.xR[0] - x.xR[windowwidth - 1], v, tol);
            for (i = 1; i < nticks; i++) {
               Ok = Ok && NearAtR(trend.xR[i] - trend.xR[i - 1], v, tol);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 2 * windowwidth);
            navg = 1 + hqrnduniformi(&rs, windowwidth + 5);
            ae_vector_set_length(&trend, 0);
            ssaforecastavglast(&state, navg, nticks, &trend);
            Ok = Ok && trend.cnt == nticks;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            v = x.xR[windowwidth - 1] - x.xR[windowwidth - 2];
            Ok = Ok && NearAtR(trend.xR[0] - x.xR[windowwidth - 1], v, tol);
            for (i = 1; i < nticks; i++) {
               Ok = Ok && NearAtR(trend.xR[i] - trend.xR[i - 1], v, tol);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            datalen = windowwidth + hqrnduniformi(&rs, 10);
            forecastlen = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&x, datalen);
            v = hqrndnormal(&rs);
            x.xR[0] = hqrndnormal(&rs);
            for (i = 1; i < datalen; i++) {
               x.xR[i] = x.xR[i - 1] + v;
            }
            ae_vector_set_length(&trend, 0);
            ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
            Ok = Ok && trend.cnt == forecastlen;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            Ok = Ok && NearAtR(trend.xR[0] - x.xR[datalen - 1], v, tol);
            for (i = 1; i < forecastlen; i++) {
               Ok = Ok && NearAtR(trend.xR[i] - trend.xR[i - 1], v, tol);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            datalen = windowwidth + hqrnduniformi(&rs, 10);
            navg = 1 + hqrnduniformi(&rs, windowwidth + 5);
            forecastlen = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&x, datalen);
            v = hqrndnormal(&rs);
            x.xR[0] = hqrndnormal(&rs);
            for (i = 1; i < datalen; i++) {
               x.xR[i] = x.xR[i - 1] + v;
            }
            ae_vector_set_length(&trend, 0);
            ssaforecastavgsequence(&state, &x, datalen, navg, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
            Ok = Ok && trend.cnt == forecastlen;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            Ok = Ok && NearAtR(trend.xR[0] - x.xR[datalen - 1], v, tol);
            for (i = 1; i < forecastlen; i++) {
               Ok = Ok && NearAtR(trend.xR[i] - trend.xR[i - 1], v, tol);
            }
         }
      }
      for (pass = 1; pass <= 5; pass++) {
         ntracks = 5 + hqrnduniformi(&rs, 10);
         windowwidth = 100;
         nlasttracklen = 2 * windowwidth;
         ssacreate(&state);
         ssasetwindow(&state, windowwidth);
         ae_vector_set_length(&x, nlasttracklen);
         for (k = 0; k < ntracks; k++) {
            v = hqrndnormal(&rs);
            x.xR[0] = hqrndnormal(&rs);
            for (i = 1; i < nlasttracklen; i++) {
               x.xR[i] = x.xR[i - 1] + v;
            }
            ssaaddsequence(&state, &x, nlasttracklen);
         }
         if (algotype == 1) {
            ae_matrix_set_length(&b, windowwidth, 2);
            v = 0.0;
            for (i = 0; i < windowwidth; i++) {
               b.xyR[i][0] = 1 / sqrt(windowwidth);
               b.xyR[i][1] = (double)i;
               v += (double)i / windowwidth;
            }
            vv = 0.0;
            for (i = 0; i < windowwidth; i++) {
               b.xyR[i][1] -= v;
               vv += sqr(b.xyR[i][1]);
            }
            for (i = 0; i < windowwidth; i++) {
               b.xyR[i][1] /= sqrt(vv);
            }
            ssasetalgoprecomputed(&state, &b, windowwidth, 2);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, 2);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, 2);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         tol = 1.0E-6;
         if (hqrnduniformr(&rs) > skipprob) {
            ssaanalyzelastwindow(&state, &trend, &noise, &nticks);
            Ok = Ok && nticks == windowwidth;
            Ok = Ok && noise.cnt == windowwidth;
            Ok = Ok && trend.cnt == windowwidth;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < windowwidth; i++) {
               Ok = Ok && NearAtR(trend.xR[i], x.xR[nlasttracklen + i - windowwidth], tol);
               Ok = Ok && SmallAtR(noise.xR[i], tol);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            ssaanalyzelast(&state, nlasttracklen, &trend, &noise);
            Ok = Ok && noise.cnt == nlasttracklen;
            Ok = Ok && trend.cnt == nlasttracklen;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < nlasttracklen; i++) {
               Ok = Ok && NearAtR(trend.xR[i], x.xR[i], tol);
               Ok = Ok && SmallAtR(noise.xR[i], tol);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 10);
            ssaforecastlast(&state, nticks, &trend);
            Ok = Ok && trend.cnt == nticks;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            v = x.xR[nlasttracklen - 1] - x.xR[nlasttracklen - 2];
            Ok = Ok && NearAtR(trend.xR[0] - x.xR[nlasttracklen - 1], v, tol);
            for (i = 1; i < nticks; i++) {
               Ok = Ok && NearAtR(trend.xR[i] - trend.xR[i - 1], v, tol);
            }
         }
      }
   // Test that on specially designed dataset with two sinusoidal components
   // with significantly different amplitudes, whose periods are integer
   // divisors of window width, SSA correctly separates leading sine from
   // its smaller counterpart. Also test that we can correctly predict future
   // values of the sequence.
   //
   // Dataset consists of many sequences, each of them featuring either
   // sine with period == WindowWidth or sine with period == WindowWidth/2. Such
   // dataset is necessary because sum of two sines is not well separated by
   // SVD (it performs only approximate, asymptotic separation). But when
   // every sequence is either one of the sines, but not two together, we
   // can easily separate them.
   //
   // Sine coefficients are changed from sequence to sequence.
   //
   // NOTE: this test requires large WindowWidth and TopK == 2 to work.
   //
   // NOTE: this test uses reduced number of passes because of higher computational complexity
      for (pass = 1; pass <= 10; pass++) {
      // Skip "precomputed basis" algorithm
         if (algotype == 1) {
            continue;
         }
      // Generate dataset
         ntracks = 100 + hqrnduniformi(&rs, 2);
         windowwidth = 64;
         nlasttracklen = windowwidth + hqrnduniformi(&rs, 10);
         ssacreate(&state);
         ae_vector_set_length(&x, nlasttracklen);
         for (k = 0; k < ntracks; k++) {
            sineoffs = (double)hqrnduniformi(&rs, windowwidth);
            if (k % 2 == 0) {
               sineamp = 1.0 + hqrnduniformr(&rs);
               sinefreq = 1.0;
            } else {
               sineamp = 0.1 * (1.0 + hqrnduniformr(&rs));
               sinefreq = 2.0;
            }
            for (i = 0; i < nlasttracklen; i++) {
               x.xR[i] = sineamp * sin((i + sineoffs) / windowwidth * 2 * pi * sinefreq);
            }
            ssaaddsequence(&state, &x, nlasttracklen);
         }
         if (algotype == 2) {
            ssasetalgotopkdirect(&state, 2);
         } else {
            if (algotype == 3) {
               ssasetalgotopkrealtime(&state, 2);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
         tol = 1.0E-6;
      // Test analysis with WindowWidth == SinePeriod:
      // * analyze sine with frequency == 1, it must be recognized as trend
      // * analyze sine with frequency == 2, with smoothing enabled
      //   it must be discarded as noise;
         ssasetwindow(&state, windowwidth);
         nticks = windowwidth + 1 + hqrnduniformi(&rs, windowwidth);
         sineoffs = (double)hqrnduniformi(&rs, windowwidth);
         sineamp = 1.0 + hqrnduniformr(&rs);
         sinefreq = 1.0;
         ae_vector_set_length(&x, nticks);
         for (i = 0; i < nticks; i++) {
            x.xR[i] = sineamp * sin((i + sineoffs) / windowwidth * 2 * pi * sinefreq);
         }
         ssaanalyzesequence(&state, &x, nticks, &trend, &noise);
         Ok = Ok && noise.cnt == nticks;
         Ok = Ok && trend.cnt == nticks;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < nticks; i++) {
            v = sineamp * sin((i + sineoffs) / windowwidth * 2 * pi * sinefreq);
            Ok = Ok && NearAtR(trend.xR[i], v, tol);
            Ok = Ok && SmallAtR(noise.xR[i], tol);
         }
         forecastlen = 1 + hqrnduniformi(&rs, nticks - windowwidth);
         datalen = nticks - forecastlen;
         ae_vector_set_length(&x2, datalen);
         for (i = 0; i < datalen; i++) {
            x2.xR[i] = x.xR[i];
         }
         ssaforecastsequence(&state, &x2, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
         for (i = 0; i < forecastlen; i++) {
            Ok = Ok && NearAtR(trend.xR[i], x.xR[datalen + i], tol);
         }
         ae_vector_set_length(&tmp0, 0);
         windowwidth2 = -1;
         ssagetlrr(&state, &tmp0, &windowwidth2);
         Ok = Ok && windowwidth2 == windowwidth;
         Ok = Ok && tmp0.cnt == windowwidth - 1;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = windowwidth - 1; i < nticks; i++) {
            v = ae_v_dotproduct(&x.xR[i - (windowwidth - 1)], 1, tmp0.xR, 1, windowwidth - 1);
            Ok = Ok && NearAtR(v, x.xR[i], tol);
         }
         nticks = windowwidth + 1 + hqrnduniformi(&rs, windowwidth);
         sineoffs = (double)hqrnduniformi(&rs, windowwidth);
         sineamp = 1.0 + hqrnduniformr(&rs);
         sinefreq = 2.0;
         ae_vector_set_length(&x, nticks);
         for (i = 0; i < nticks; i++) {
            x.xR[i] = sineamp * sin((i + sineoffs) / windowwidth * 2 * pi * sinefreq);
         }
         ssaanalyzesequence(&state, &x, nticks, &trend, &noise);
         Ok = Ok && noise.cnt == nticks;
         Ok = Ok && trend.cnt == nticks;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < nticks; i++) {
            v = sineamp * sin((i + sineoffs) / windowwidth * 2 * pi * sinefreq);
            Ok = Ok && SmallAtR(trend.xR[i], tol);
            Ok = Ok && NearAtR(noise.xR[i], v, tol);
         }
         forecastlen = 1 + hqrnduniformi(&rs, nticks - windowwidth);
         datalen = nticks - forecastlen;
         ae_vector_set_length(&x2, datalen);
         for (i = 0; i < datalen; i++) {
            x2.xR[i] = x.xR[i];
         }
         ssaforecastsequence(&state, &x2, datalen, forecastlen, true, &trend);
         for (i = 0; i < forecastlen; i++) {
            Ok = Ok && SmallAtR(trend.xR[i], tol);
         }
      }
   // Test appendPoint() functionality.
   //
   // We have specially designed dataset:
   // * NZeros ticks of exactly zero values
   // * NLinear ticks of series which linearly grow from 0 to 1
   // * NLinear ticks of series which linearly decrease from 1 to 0
   // * NZeros ticks of exactly zero values
   // * NZeros == 100
   // * NLinear == 20
   //
   // SSA settings have following values:
   // * WindowWidth == 4 or 25 (large widths are more problematic for
   //   iterative solvers, so they help to debug incremental updates)
   // * NBasis == 2
   //
   // We choose number of initial values to start with NInitial
   // in [1..2*WindowWidth], then add points one
   // by one with SSAAppendPointAndUpdate(). In the end we compare
   // results returned by SSAGetBasis() with that returned by model
   // which was created from full dataset.
   //
   // NOTE: we perform limited amount of passes because this test
   //       has high cost.
      for (pass = 1; pass <= 25; pass++) {
      // Generate dataset
         tol = 1.0E-6;
         nzeros = 100;
         nlinear = 50;
         if (hqrndnormal(&rs) > 0.0) {
            windowwidth = 25;
         } else {
            windowwidth = 4;
         }
         nbasis = 2;
         ninitial = 1 + hqrnduniformi(&rs, 2 * windowwidth);
         ae_vector_set_length(&x, 2 * nzeros + 2 * nlinear);
         for (i = 0; i < x.cnt; i++) {
            x.xR[i] = 0.0;
         }
         for (i = 0; i < nlinear; i++) {
            x.xR[nzeros + i] = (double)i / nlinear;
            x.xR[nzeros + nlinear + i] = 1 - (double)i / nlinear;
         }
         rmatrixrndorthogonal(windowwidth, &b);
      // Build model using many sequential appends
      //
      // NOTE: for NInitial >= WindowWidth with probability 50%
      //       we enforce basis calculation before first
      //       append() call. It helps to debug different
      //       branches of algorithms.
      //
      // NOTE: we may also request delayed power-up of the
      //       algorithm. It also checks various branches of
      //       the algo, although with such settings delayed
      //       power-up is hard to check (initial dataset is
      //       just zeros, zeros, zeros..).
         ae_vector_set_length(&x2, ninitial);
         for (i = 0; i < x2.cnt; i++) {
            x2.xR[i] = x.xR[i];
         }
         ssacreate(&state);
         ssasetwindow(&state, windowwidth);
         ssaaddsequence(&state, &x2, x2.cnt);
         if (algotype == 1) {
            ssasetalgoprecomputed(&state, &b, windowwidth, nbasis);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, nbasis);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, nbasis);
                  if (hqrnduniformr(&rs) > 0.5) {
                     ssasetpoweruplength(&state, 10);
                  }
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         if (ninitial >= windowwidth && hqrnduniformr(&rs) > 0.5) {
            ae_matrix_set_length(&a, 0, 0);
            ae_vector_set_length(&sv, 0);
            windowwidth2 = -1;
            nbasis2 = -1;
            ssagetbasis(&state, &a, &sv, &windowwidth2, &nbasis2);
            Ok = Ok && windowwidth2 == windowwidth;
            Ok = Ok && nbasis2 == nbasis;
            Ok = Ok && a.rows == windowwidth;
            Ok = Ok && a.cols == nbasis;
            Ok = Ok && sv.cnt == nbasis;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         }
         for (i = x2.cnt; i < x.cnt; i++) {
            ssaappendpointandupdate(&state, x.xR[i], 1.0);
         }
         ae_matrix_set_length(&a, 0, 0);
         ae_vector_set_length(&sv, 0);
         windowwidth2 = -1;
         nbasis2 = -1;
         ssagetbasis(&state, &a, &sv, &windowwidth2, &nbasis2);
         Ok = Ok && windowwidth2 == windowwidth;
         Ok = Ok && nbasis2 == nbasis;
         Ok = Ok && a.rows == windowwidth;
         Ok = Ok && a.cols == nbasis;
         Ok = Ok && sv.cnt == nbasis;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Build model using one big sequence
         ssacreate(&state2);
         ssasetwindow(&state2, windowwidth);
         ssaaddsequence(&state2, &x, x.cnt);
         if (algotype == 1) {
            ssasetalgoprecomputed(&state2, &b, windowwidth, nbasis);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state2, nbasis);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state2, nbasis);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         ae_matrix_set_length(&a2, 0, 0);
         ae_vector_set_length(&sv2, 0);
         windowwidth2 = -1;
         nbasis2 = -1;
         ssagetbasis(&state2, &a2, &sv2, &windowwidth2, &nbasis2);
         Ok = Ok && windowwidth2 == windowwidth;
         Ok = Ok && nbasis2 == nbasis;
         Ok = Ok && a2.rows == windowwidth;
         Ok = Ok && a2.cols == nbasis;
         Ok = Ok && sv2.cnt == nbasis;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
      // Compare results
         for (i = 0; i < nbasis; i++) {
            Ok = Ok && NearAtR(sv.xR[i], sv2.xR[i], tol);
         }
         for (j = 0; j < nbasis; j++) {
            v = ae_v_dotproduct(&a.xyR[0][j], a.stride, &a2.xyR[0][j], a2.stride, windowwidth);
            for (i = 0; i < windowwidth; i++) {
               Ok = Ok && NearAtR(a.xyR[i][j], sign(v) * a2.xyR[i][j], tol);
            }
         }
      }
   // Test appendSequence() functionality.
   //
   // We have specially designed dataset:
   // * NNoise sequences of Gaussian noise
   // * NLinear linear sequences partially corrupted by noise
   // * NZeros exactly zero sequences (used to let incremental algo converge)
   // * all sequences have random size in [WindowWidth-2,WindowWidth+2]
   // * NNoise == 20
   // * NLinear == 20
   //
   // SSA settings have following values:
   // * WindowWidth == 4 or 25 (large widths are more problematic for
   //   iterative solvers, so they help to debug incremental updates)
   // * NBasis == 2
   //
   // We have two solvers:
   // * one is trained on complete dataset
   // * another one starts from NNoise noisy sequences, linear/zero sequenes
   //   are incrementally appended with AppendSequence
   //
   // NOTE: we perform limited amount of passes because this test
   //       has high cost.
      for (pass = 1; pass <= 25; pass++) {
      // Problem metrics
         tol = 1.0E-5;
         nnoise = 20;
         nlinear = 20;
         nzeros = 50;
         if (hqrndnormal(&rs) > 0.0) {
            windowwidth = 25;
         } else {
            windowwidth = 4;
         }
         nbasis = 2;
      // Initialize solvers
      //
      // NOTE: we set State.DefaultSubspaceIts to large value in order
      //       to ensure convergence to same basis.
         rmatrixrndorthogonal(windowwidth, &b);
         ssacreate(&state);
         ssacreate(&state2);
         state.defaultsubspaceits = 50;
         ssasetwindow(&state, windowwidth);
         ssasetwindow(&state2, windowwidth);
         if (algotype == 1) {
            ssasetalgoprecomputed(&state, &b, windowwidth, nbasis);
            ssasetalgoprecomputed(&state2, &b, windowwidth, nbasis);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, nbasis);
               ssasetalgotopkdirect(&state2, nbasis);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, nbasis);
                  ssasetalgotopkrealtime(&state2, nbasis);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
      // Feed noisy sequences
         for (i = 0; i < nnoise; i++) {
            k = windowwidth + (hqrnduniformi(&rs, 5) - 2);
            ae_vector_set_length(&x, k);
            for (j = 0; j < k; j++) {
               x.xR[j] = hqrndnormal(&rs);
            }
            ssaaddsequence(&state, &x, x.cnt);
            ssaaddsequence(&state2, &x, x.cnt);
         }
      // Feed linear and zero sequences.
      //
      // NOTE: with probability 50% we call SSAGetBasis(State2).
      //       Ideally, SSA should be able to handle appends correctly
      //       with or without preceeding call which requires basis
      //       to be evaluated.
         if (hqrnduniformr(&rs) > 0.5) {
            ae_matrix_set_length(&a2, 0, 0);
            ae_vector_set_length(&sv2, 0);
            windowwidth2 = -1;
            nbasis2 = -1;
            ssagetbasis(&state2, &a2, &sv2, &windowwidth2, &nbasis2);
            Ok = Ok && windowwidth2 == windowwidth;
            Ok = Ok && nbasis2 == nbasis;
            Ok = Ok && a2.rows == windowwidth;
            Ok = Ok && a2.cols == nbasis;
            Ok = Ok && sv2.cnt == nbasis;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
         }
         for (i = 0; i < nlinear; i++) {
            k = windowwidth + (hqrnduniformi(&rs, 5) - 2);
            v = hqrndnormal(&rs);
            vv = hqrndnormal(&rs);
            ae_vector_set_length(&x, k);
            x.xR[0] = v;
            for (j = 1; j < k; j++) {
               x.xR[j] = x.xR[j - 1] + vv + 0.1 * hqrndnormal(&rs);
            }
            ssaaddsequence(&state, &x, x.cnt);
            ssaappendsequenceandupdate(&state2, &x, x.cnt, 1.0);
         }
         for (i = 0; i < nzeros; i++) {
            k = windowwidth + (hqrnduniformi(&rs, 5) - 2);
            ae_vector_set_length(&x, k);
            for (j = 0; j < k; j++) {
               x.xR[j] = 0.0;
            }
            ssaaddsequence(&state, &x, x.cnt);
            ssaappendsequenceandupdate(&state2, &x, x.cnt, 1.0);
         }
      // Compare results
         ae_matrix_set_length(&a, 0, 0);
         ae_vector_set_length(&sv, 0);
         windowwidth2 = -1;
         nbasis2 = -1;
         ssagetbasis(&state, &a, &sv, &windowwidth2, &nbasis2);
         Ok = Ok && windowwidth2 == windowwidth;
         Ok = Ok && nbasis2 == nbasis;
         Ok = Ok && a.rows == windowwidth;
         Ok = Ok && a.cols == nbasis;
         Ok = Ok && sv.cnt == nbasis;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         ae_matrix_set_length(&a2, 0, 0);
         ae_vector_set_length(&sv2, 0);
         windowwidth2 = -1;
         nbasis2 = -1;
         ssagetbasis(&state2, &a2, &sv2, &windowwidth2, &nbasis2);
         Ok = Ok && windowwidth2 == windowwidth;
         Ok = Ok && nbasis2 == nbasis;
         Ok = Ok && a2.rows == windowwidth;
         Ok = Ok && a2.cols == nbasis;
         Ok = Ok && sv2.cnt == nbasis;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < nbasis; i++) {
            Ok = Ok && NearAtR(sv.xR[i], sv2.xR[i], tol);
         }
         for (j = 0; j < nbasis; j++) {
            v = ae_v_dotproduct(&a.xyR[0][j], a.stride, &a2.xyR[0][j], a2.stride, windowwidth);
            for (i = 0; i < windowwidth; i++) {
               Ok = Ok && NearAtR(a.xyR[i][j], sign(v) * a2.xyR[i][j], tol);
            }
         }
      }
   // Test memory limit functionality.
   //
   // Compare results obtained with HUGE limit vs ones obtained with small limit.
      for (windowwidth = 1; windowwidth <= 20; windowwidth++) {
         for (mlimit = -1; mlimit <= 16; mlimit++) {
         // Not tested
            if (algotype == 1) {
               continue;
            }
         // Problem metrics
            tol = 1.0E-5;
            nticks = 1000 + hqrnduniformi(&rs, 1000);
            if (windowwidth > 5) {
               nbasis = 1 + hqrnduniformi(&rs, 5);
            } else {
               nbasis = 1;
            }
         // Create solvers, dataset, set limits
            ssacreate(&state);
            ssacreate(&state2);
            if (mlimit >= 0) {
               ssasetmemorylimit(&state, iround(pow(2.0, (double)mlimit)));
            } else {
               ssasetmemorylimit(&state, 0);
            }
            ssasetmemorylimit(&state2, 999999999);
            ssasetwindow(&state, windowwidth);
            ssasetwindow(&state2, windowwidth);
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, nbasis);
               ssasetalgotopkdirect(&state2, nbasis);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, nbasis);
                  ssasetalgotopkrealtime(&state2, nbasis);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
            ae_vector_set_length(&x, nticks);
            for (i = 0; i < nticks; i++) {
               x.xR[i] = hqrndnormal(&rs);
            }
            ssaaddsequence(&state, &x, x.cnt);
            ssaaddsequence(&state2, &x, x.cnt);
         // Reset internal temporaries for this test.
         // Implementation-dependent, may fail due to future changes in the core.
            ae_matrix_set_length(&state.uxbatch, 0, 0);
            ae_matrix_set_length(&state.aseqtrajectory, 0, 0);
            ae_matrix_set_length(&state.aseqtbproduct, 0, 0);
         // Test
            ssaanalyzelast(&state, nticks, &trend, &noise);
            ssaanalyzelast(&state2, nticks, &trend2, &noise2);
            for (i = 0; i < nticks; i++) {
               Ok = Ok && NearAtR(trend.xR[i], trend2.xR[i], tol);
               Ok = Ok && NearAtR(noise.xR[i], noise2.xR[i], tol);
            }
         // Additional tests for sizes of internal arrays.
         // Implementation-dependent, may fail due to future changes in the core.
            if (mlimit >= 0) {
               k = imax2(4 * windowwidth * windowwidth, iround(pow(2.0, (double)mlimit)));
               Ok = Ok && state.uxbatch.cols * state.uxbatch.rows <= k;
               Ok = Ok && state.aseqtrajectory.cols * state.aseqtrajectory.rows <= k;
               Ok = Ok && state.aseqtbproduct.cols * state.aseqtbproduct.rows <= k;
            } else {
               Ok = Ok && state.uxbatch.rows == nticks - windowwidth + 1;
               Ok = Ok && state.aseqtrajectory.rows == nticks - windowwidth + 1;
               Ok = Ok && state.aseqtbproduct.rows == nticks - windowwidth + 1;
            }
         }
      }
   }
// Test power-up ability of the real-time algorithm.
//
// We have specially designed dataset:
// * NTicks ticks of linearly descending from 1 to 0 linear trend,
//   corrupted by random Gaussian noise
// * NZeros ticks of exactly zero values
// * NTicks == 100
// * NZeros == 100
//
// SSA settings have following values:
// * WindowWidth == 4 or 25 (large widths are more problematic for
//   iterative solvers, so they help to debug incremental updates)
// * NBasis == 1..2 (only top vectors converge stable enough for unit testing)
// * powerup length is 10
//
// We perform two SSAs:
// * one with full dataset and no powerup
// * one with powerup, NTicks+WindowWidth first elements, followed by appending of NZeros zeros
//
// We check that:
// * basis found by second model (right after initialization) is different
//   from basis of the first one
// * basis found by second model after last append is same as the first one
//
// NOTE: we perform limited amount of passes because this test
//       has high cost.
   for (pass = 1; pass <= 25; pass++) {
   // Generate dataset
      tol = 1.0E-3;
      nticks = 100;
      nzeros = 50;
      if (hqrndnormal(&rs) > 0.0) {
         windowwidth = 25;
      } else {
         windowwidth = 4;
      }
      nbasis = 1 + hqrnduniformi(&rs, 2);
      ae_vector_set_length(&x, nticks + nzeros);
      for (i = 0; i < x.cnt; i++) {
         x.xR[i] = 0.0;
      }
      for (i = 0; i < nticks; i++) {
         x.xR[i] = 1 - (double)i / nticks + 0.05 * hqrndnormal(&rs);
      }
   // Build complete model
   //
   // NOTE: we tweak S.DefaultSubspaceIts in order to enforce convergence to
   //       same basis; for this test we need extra-precise convergence.
      ssacreate(&state2);
      ssasetwindow(&state2, windowwidth);
      ssaaddsequence(&state2, &x, x.cnt);
      ssasetalgotopkrealtime(&state2, nbasis);
      ae_matrix_set_length(&a2, 0, 0);
      ae_vector_set_length(&sv2, 0);
      windowwidth2 = -1;
      nbasis2 = -1;
      ssagetbasis(&state2, &a2, &sv2, &windowwidth2, &nbasis2);
      Ok = Ok && windowwidth2 == windowwidth;
      Ok = Ok && nbasis2 == nbasis;
      Ok = Ok && a2.rows == windowwidth;
      Ok = Ok && a2.cols == nbasis;
      Ok = Ok && sv2.cnt == nbasis;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // Build model with power-up cycle
   //
   // NOTE: with probability 50% we enforce basis calculation
   //       before first append() call and compare basis with
   //       one returned by full analysis. We do it only in 50%
   //       of the cases because randomness helps to debug different
   //       branches of algorithms.
      ae_vector_set_length(&x2, nticks + windowwidth);
      for (i = 0; i < x2.cnt; i++) {
         x2.xR[i] = x.xR[i];
      }
      ssacreate(&state);
      ssasetwindow(&state, windowwidth);
      ssaaddsequence(&state, &x2, x2.cnt);
      ssasetalgotopkrealtime(&state, nbasis);
      ssasetpoweruplength(&state, 10);
      if (hqrnduniformr(&rs) > 0.5) {
         ae_matrix_set_length(&a, 0, 0);
         ae_vector_set_length(&sv, 0);
         windowwidth2 = -1;
         nbasis2 = -1;
         ssagetbasis(&state, &a, &sv, &windowwidth2, &nbasis2);
         Ok = Ok && windowwidth2 == windowwidth;
         Ok = Ok && nbasis2 == nbasis;
         Ok = Ok && a.rows == windowwidth;
         Ok = Ok && a.cols == nbasis;
         Ok = Ok && sv.cnt == nbasis;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         vv = 0.0;
         for (i = 0; i < nbasis; i++) {
            vv = rmax2(vv, fabs(sv.xR[i] - sv2.xR[i]));
         }
         for (j = 0; j < nbasis; j++) {
            v = ae_v_dotproduct(&a.xyR[0][j], a.stride, &a2.xyR[0][j], a2.stride, windowwidth);
            for (i = 0; i < windowwidth; i++) {
               vv = rmax2(vv, fabs(a.xyR[i][j] - sign(v) * a2.xyR[i][j]));
            }
         }
         Ok = Ok && !SmallR(vv, tol);
      }
      for (i = x2.cnt; i < x.cnt; i++) {
         ssaappendpointandupdate(&state, x.xR[i], 1.0);
      }
      ae_matrix_set_length(&a, 0, 0);
      ae_vector_set_length(&sv, 0);
      windowwidth2 = -1;
      nbasis2 = -1;
      ssagetbasis(&state, &a, &sv, &windowwidth2, &nbasis2);
      Ok = Ok && windowwidth2 == windowwidth;
      Ok = Ok && nbasis2 == nbasis;
      Ok = Ok && a.rows == windowwidth;
      Ok = Ok && a.cols == nbasis;
      Ok = Ok && sv.cnt == nbasis;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
      vv = 0.0;
      for (i = 0; i < nbasis; i++) {
         vv = rmax2(vv, fabs(sv.xR[i] - sv2.xR[i]));
      }
      for (j = 0; j < nbasis; j++) {
         v = ae_v_dotproduct(&a.xyR[0][j], a.stride, &a2.xyR[0][j], a2.stride, windowwidth);
         for (i = 0; i < windowwidth; i++) {
            vv = rmax2(vv, fabs(a.xyR[i][j] - sign(v) * a2.xyR[i][j]));
         }
      }
      Ok = Ok && SmallAtR(vv, tol);
   }
// Test that SSAForecastAvgLast/Sequence() actually performs averaging.
// We test it by comparing its results vs manually averaged predictions.
//
// Dataset is a small linear trend + Gaussian noise. We are not interested
// in getting meaningful components, we just want to check correctness of math.
   for (pass = 1; pass <= 100; pass++) {
      nticks = 75 + hqrnduniformi(&rs, 75);
      windowwidth = 5 + hqrnduniformi(&rs, 5);
      navg = 1 + hqrnduniformi(&rs, 2 * windowwidth);
      forecastlen = 1 + hqrnduniformi(&rs, 2 * windowwidth);
      ssacreate(&state);
      ssasetwindow(&state, windowwidth);
      ae_vector_set_length(&x, nticks);
      for (i = 0; i < nticks; i++) {
         x.xR[i] = 0.1 * i + hqrndnormal(&rs);
      }
      ssaaddsequence(&state, &x, nticks);
      ssasetalgotopkdirect(&state, 1 + hqrnduniformi(&rs, 3));
      tol = 1.0E-9;
      ssaforecastavglast(&state, navg, forecastlen, &trend);
      ae_vector_set_length(&trend2, forecastlen);
      for (i = 0; i < forecastlen; i++) {
         trend2.xR[i] = 0.0;
      }
      for (i = 0; i < navg; i++) {
         ssaforecastsequence(&state, &x, nticks - i, forecastlen + i, true, &tmp0);
         for (j = 0; j < forecastlen; j++) {
            trend2.xR[j] += tmp0.xR[i + j] / navg;
         }
      }
      for (i = 0; i < forecastlen; i++) {
         Ok = Ok && NearAtR(trend.xR[i], trend2.xR[i], tol * rmax3(fabs(trend.xR[i]), fabs(trend2.xR[i]), 1.0));
      }
      nticks = 75 + hqrnduniformi(&rs, 75);
      j = hqrnduniformi(&rs, 150) - 75;
      ae_vector_set_length(&x2, nticks);
      for (i = 0; i < nticks; i++) {
         x2.xR[i] = 0.1 * (i + j) + hqrndnormal(&rs);
      }
      ssaforecastavgsequence(&state, &x2, nticks, navg, forecastlen, true, &trend);
      ae_vector_set_length(&trend2, forecastlen);
      for (i = 0; i < forecastlen; i++) {
         trend2.xR[i] = 0.0;
      }
      for (i = 0; i < navg; i++) {
         ssaforecastsequence(&state, &x2, nticks - i, forecastlen + i, true, &tmp0);
         for (j = 0; j < forecastlen; j++) {
            trend2.xR[j] += tmp0.xR[i + j] / navg;
         }
      }
      for (i = 0; i < forecastlen; i++) {
         Ok = Ok && NearAtR(trend.xR[i], trend2.xR[i], tol * rmax3(fabs(trend.xR[i]), fabs(trend2.xR[i]), 1.0));
      }
      nticks = 75 + hqrnduniformi(&rs, 75);
      j = hqrnduniformi(&rs, 150) - 75;
      ae_vector_set_length(&x2, nticks);
      for (i = 0; i < nticks; i++) {
         x2.xR[i] = 0.1 * (i + j) + hqrndnormal(&rs);
      }
      ssaforecastavgsequence(&state, &x2, nticks, navg, forecastlen, false, &trend);
      ae_vector_set_length(&trend2, forecastlen);
      for (i = 0; i < forecastlen; i++) {
         trend2.xR[i] = 0.0;
      }
      for (i = 0; i < navg; i++) {
         ssaforecastsequence(&state, &x2, nticks - i, forecastlen + i, false, &tmp0);
         for (j = 0; j < forecastlen; j++) {
            trend2.xR[j] += tmp0.xR[i + j] / navg;
         }
      }
      for (i = 0; i < forecastlen; i++) {
         Ok = Ok && NearAtR(trend.xR[i], trend2.xR[i], tol * rmax3(fabs(trend.xR[i]), fabs(trend2.xR[i]), 1.0));
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function tests different special cases (mostly - degenerate ones).
static bool testssaunit_testspecial() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_int_t pass;
   ae_int_t algotype;
   ae_int_t nticks;
   ae_int_t nanalyzed;
   ae_int_t nlasttracklen;
   ae_int_t ntracks;
   ae_int_t maxtracklen;
   ae_int_t mintracklen;
   ae_int_t datalen;
   ae_int_t forecastlen;
   ae_int_t windowwidth;
   ae_int_t nbasis;
   ae_int_t windowwidth2;
   ae_int_t passcount;
   double skipprob;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(ssamodel, state);
   NewObj(ssamodel, state2);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(sv, 0, DT_REAL);
   NewVector(trend, 0, DT_REAL);
   NewVector(noise, 0, DT_REAL);
   NewVector(trend2, 0, DT_REAL);
   NewVector(noise2, 0, DT_REAL);
   NewMatrix(tracksmatrix, 0, 0, DT_REAL);
   NewVector(trackssizes, 0, DT_INT);
   NewObj(hqrndstate, rs);
// Initialize RNG, test pass count and skip probability.
//
// When we perform several sequential tests on the same model, we may
// skip some of them with probability SkipProb in order to make sure
// that no carry-over effect is observed between tests.
   hqrndrandomize(&rs);
   passcount = 500;
   skipprob = 0.50;
// Test that for empty model in default state:
// * SSAGetBasis() returns zero 1x1 basis
// * SSAAnalyzeLastWindow() returns zeros as trend/noise
// * SSAAnalyzeLast() returns zeros as trend/noise
// * SSAAnalyzeSequence() returns zeros as trend, sequence as noise
// * SSAForecastLast() returns zero trend
// * SSAForecastSequence() returns zero trend
   for (pass = 1; pass <= passcount; pass++) {
      ssacreate(&state);
      if (hqrnduniformr(&rs) > skipprob) {
         ssagetbasis(&state, &a, &sv, &windowwidth, &nbasis);
         Ok = Ok && windowwidth == 1;
         Ok = Ok && nbasis == 1;
         Ok = Ok && a.rows == 1;
         Ok = Ok && a.cols == 1;
         Ok = Ok && sv.cnt == 1;
         for (i = 0; i < a.rows; i++) {
            for (j = 0; j < a.cols; j++) {
               Ok = Ok && a.xyR[i][j] == 0.0;
            }
         }
         for (i = 0; i < sv.cnt; i++) {
            Ok = Ok && sv.xR[i] == 0.0;
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         windowwidth = -1;
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzelastwindow(&state, &trend, &noise, &windowwidth);
         Ok = Ok && windowwidth == 1;
         Ok = Ok && trend.cnt == 1 && trend.xR[0] == 0.0;
         Ok = Ok && noise.cnt == 1 && noise.xR[0] == 0.0;
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzelast(&state, nticks, &trend, &noise);
         Ok = Ok && trend.cnt == nticks;
         Ok = Ok && noise.cnt == nticks;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < nticks; i++) {
            Ok = Ok && trend.xR[i] == 0.0;
            Ok = Ok && noise.xR[i] == 0.0;
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&x, nticks);
         for (i = 0; i < nticks; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzesequence(&state, &x, nticks, &trend, &noise);
         Ok = Ok && trend.cnt == nticks;
         Ok = Ok && noise.cnt == nticks;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < nticks; i++) {
            Ok = Ok && trend.xR[i] == 0.0;
            Ok = Ok && noise.xR[i] == x.xR[i];
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&trend, 0);
         ssaforecastlast(&state, nticks, &trend);
         Ok = Ok && trend.cnt == nticks;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < nticks; i++) {
            Ok = Ok && trend.xR[i] == 0.0;
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         datalen = 1 + hqrnduniformi(&rs, 10);
         forecastlen = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&x, datalen);
         for (i = 0; i < datalen; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&trend, 0);
         ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
         Ok = Ok && trend.cnt == forecastlen;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < forecastlen; i++) {
            Ok = Ok && trend.xR[i] == 0.0;
         }
      }
   }
// Test that for empty model with non-default window, but default
// algorithm and no data:
// * SSAGetBasis() returns zero WINDOWx1 basis
// * SSAAnalyzeLastWindow() returns zeros as trend/noise
// * SSAAnalyzeLast() returns zeros as trend/noise
// * SSAAnalyzeSequence() returns zeros as trend, sequence as noise
// * SSAForecastLast() returns zero trend
// * SSAForecastSequence() returns zero trend
   for (pass = 1; pass <= passcount; pass++) {
      windowwidth2 = 1 + hqrnduniformi(&rs, 10);
      ssacreate(&state);
      ssasetwindow(&state, windowwidth2);
      if (hqrnduniformr(&rs) > skipprob) {
         ssagetbasis(&state, &a, &sv, &windowwidth, &nbasis);
         Ok = Ok && windowwidth == windowwidth2;
         Ok = Ok && nbasis == 1;
         Ok = Ok && a.rows == windowwidth;
         Ok = Ok && a.cols == 1;
         Ok = Ok && sv.cnt == 1;
         for (i = 0; i < a.rows; i++) {
            for (j = 0; j < a.cols; j++) {
               Ok = Ok && a.xyR[i][j] == 0.0;
            }
         }
         for (i = 0; i < sv.cnt; i++) {
            Ok = Ok && sv.xR[i] == 0.0;
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         windowwidth = -1;
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzelastwindow(&state, &trend, &noise, &windowwidth);
         Ok = Ok && windowwidth == windowwidth2;
         Ok = Ok && trend.cnt == windowwidth2;
         Ok = Ok && noise.cnt == windowwidth2;
         for (i = 0; i < trend.cnt; i++) {
            Ok = Ok && trend.xR[i] == 0.0;
         }
         for (i = 0; i < noise.cnt; i++) {
            Ok = Ok && noise.xR[i] == 0.0;
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzelast(&state, nticks, &trend, &noise);
         Ok = Ok && trend.cnt == nticks;
         Ok = Ok && noise.cnt == nticks;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < nticks; i++) {
            Ok = Ok && trend.xR[i] == 0.0;
            Ok = Ok && noise.xR[i] == 0.0;
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&x, nticks);
         for (i = 0; i < nticks; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzesequence(&state, &x, nticks, &trend, &noise);
         Ok = Ok && trend.cnt == nticks;
         Ok = Ok && noise.cnt == nticks;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < nticks; i++) {
            Ok = Ok && trend.xR[i] == 0.0;
            Ok = Ok && noise.xR[i] == x.xR[i];
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&trend, 0);
         ssaforecastlast(&state, nticks, &trend);
         Ok = Ok && trend.cnt == nticks;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < nticks; i++) {
            Ok = Ok && trend.xR[i] == 0.0;
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         datalen = 1 + hqrnduniformi(&rs, 10);
         forecastlen = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&x, datalen);
         for (i = 0; i < datalen; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&trend, 0);
         ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
         Ok = Ok && trend.cnt == forecastlen;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < forecastlen; i++) {
            Ok = Ok && trend.xR[i] == 0.0;
         }
      }
   }
// Test that for empty model with default algorithm and one/few tracks
// (which are sometimes shorter than window, sometimes longer than window)
// * SSAGetBasis() returns zero WINDOWx1 basis
// * SSAAnalyzeLastWindow() returns zeros as trend and correctly aligned
//   cropped/padded copy of X in the noise
// * SSAAnalyzeLast() returns zeros as trend and correctly aligned
//   cropped/padded copy of X in the noise
// * SSAAnalyzeSequence() returns zeros as trend, sequence as noise
// * SSAForecastLast() returns zero trend
// * SSAForecastSequence() returns zero trend
   for (pass = 1; pass <= passcount; pass++) {
   // Generate task; last track is stored in X, its length in NLastTrackLen
      nlasttracklen = -999999;
      windowwidth2 = 1 + hqrnduniformi(&rs, 10);
      ntracks = 1 + hqrnduniformi(&rs, 3);
      ssacreate(&state);
      ssasetwindow(&state, windowwidth2);
      ae_matrix_set_length(&tracksmatrix, ntracks, 2 * windowwidth2);
      ae_vector_set_length(&trackssizes, ntracks);
      for (k = 0; k < ntracks; k++) {
         nlasttracklen = hqrnduniformi(&rs, 2 * windowwidth2);
         ae_vector_set_length(&x, nlasttracklen);
         for (i = 0; i < nlasttracklen; i++) {
            x.xR[i] = hqrndnormal(&rs);
            tracksmatrix.xyR[k][i] = x.xR[i];
         }
         trackssizes.xZ[k] = nlasttracklen;
         ssaaddsequence(&state, &x, nlasttracklen);
      }
   // Test
      if (hqrnduniformr(&rs) > skipprob) {
         ssagetbasis(&state, &a, &sv, &windowwidth, &nbasis);
         Ok = Ok && windowwidth == windowwidth2;
         Ok = Ok && nbasis == 1;
         Ok = Ok && a.rows == windowwidth;
         Ok = Ok && a.cols == 1;
         Ok = Ok && sv.cnt == 1;
         for (i = 0; i < a.rows; i++) {
            for (j = 0; j < a.cols; j++) {
               Ok = Ok && a.xyR[i][j] == 0.0;
            }
         }
         for (i = 0; i < sv.cnt; i++) {
            Ok = Ok && sv.xR[i] == 0.0;
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         windowwidth = -1;
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzelastwindow(&state, &trend, &noise, &windowwidth);
         Ok = Ok && windowwidth == windowwidth2;
         Ok = Ok && trend.cnt == windowwidth2;
         Ok = Ok && noise.cnt == windowwidth2;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < windowwidth; i++) {
            Ok = Ok && trend.xR[i] == 0.0;
         }
         for (i = 0; i < imax2(windowwidth - nlasttracklen, 0); i++) {
            Ok = Ok && noise.xR[i] == 0.0;
         }
         for (i = imax2(windowwidth - nlasttracklen, 0); i < windowwidth; i++) {
            Ok = Ok && noise.xR[i] == x.xR[nlasttracklen + (i - windowwidth)];
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nanalyzed = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzelast(&state, nanalyzed, &trend, &noise);
         Ok = Ok && trend.cnt == nanalyzed;
         Ok = Ok && noise.cnt == nanalyzed;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < nanalyzed; i++) {
            Ok = Ok && trend.xR[i] == 0.0;
         }
         for (i = 0; i < imax2(nanalyzed - nlasttracklen, 0); i++) {
            Ok = Ok && noise.xR[i] == 0.0;
         }
         for (i = imax2(nanalyzed - nlasttracklen, 0); i < nanalyzed; i++) {
            Ok = Ok && noise.xR[i] == x.xR[nlasttracklen + (i - nanalyzed)];
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&x, nticks);
         for (i = 0; i < nticks; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzesequence(&state, &x, nticks, &trend, &noise);
         Ok = Ok && trend.cnt == nticks;
         Ok = Ok && noise.cnt == nticks;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < nticks; i++) {
            Ok = Ok && trend.xR[i] == 0.0;
            Ok = Ok && noise.xR[i] == x.xR[i];
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&trend, 0);
         ssaforecastlast(&state, nticks, &trend);
         Ok = Ok && trend.cnt == nticks;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < nticks; i++) {
            Ok = Ok && trend.xR[i] == 0.0;
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         datalen = 1 + hqrnduniformi(&rs, 10);
         forecastlen = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&x, datalen);
         for (i = 0; i < datalen; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&trend, 0);
         ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
         Ok = Ok && trend.cnt == forecastlen;
         if (!Ok) {
            ae_frame_leave();
            return Ok;
         }
         for (i = 0; i < forecastlen; i++) {
            Ok = Ok && trend.xR[i] == 0.0;
         }
      }
   }
// Tests below are performed for all algorithms supported.
   for (algotype = 1; algotype <= 3; algotype++) {
   // Test that SSAClearData() actually clears data
      for (pass = 1; pass <= passcount; pass++) {
         if (algotype == 1) {
            continue;
         }
      // Create two models, one is created after cleardata() call
      // which should erase all traces of the previous dataset.
         ssacreate(&state);
         ssacreate(&state2);
         ssasetwindow(&state, 5);
         ssasetwindow(&state2, 5);
         if (algotype == 2) {
            ssasetalgotopkdirect(&state, 2);
            ssasetalgotopkdirect(&state2, 2);
         } else {
            if (algotype == 3) {
               ssasetalgotopkrealtime(&state, 2);
               ssasetalgotopkrealtime(&state2, 2);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
         ae_vector_set_length(&x, 10);
         for (i = 0; i < x.cnt; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ssaaddsequence(&state, &x, x.cnt);
         ssacleardata(&state);
         for (i = 0; i < x.cnt; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ssaaddsequence(&state, &x, x.cnt);
         ssaaddsequence(&state2, &x, x.cnt);
      // Test
         ssaanalyzelast(&state, x.cnt, &trend, &noise);
         ssaanalyzelast(&state2, x.cnt, &trend2, &noise2);
         for (i = 0; i < x.cnt; i++) {
            Ok = Ok && NearAtR(trend.xR[i], trend2.xR[i], 1.0E-5);
            Ok = Ok && NearAtR(noise.xR[i], noise2.xR[i], 1.0E-5);
         }
      }
   // Test that for model with some algo being set, one/few tracks and unit window length:
   // * SSAGetBasis() returns 1x1 basis (unit matrix)
   // * SSAAnalyzeLastWindow() returns last element of track as trend and zeros
   //   as noise (with minor rounding error)
   // * SSAAnalyzeLast() returns tracks as trend and zeros as noise (with
   //   minor rounding error possible). For NTicks > TrackLength result is correctly
   //   prepended with zeros.
   // * SSAAnalyzeSequence() returns sequence as trend, zeros as noise (up to
   //   machine precision)
   // * SSAForecastLast() returns just copies of the last element
   // * SSAForecastSequence() returns just copies of the last element
      for (pass = 1; pass <= passcount; pass++) {
      // Generate task; last track is stored in X, its length in NLastTrackLen
         nlasttracklen = -999999;
         maxtracklen = 10;
         ntracks = 1 + hqrnduniformi(&rs, 3);
         ssacreate(&state);
         ssasetwindow(&state, 1);
         ae_matrix_set_length(&tracksmatrix, ntracks, maxtracklen);
         ae_vector_set_length(&trackssizes, ntracks);
         for (k = 0; k < ntracks; k++) {
            nlasttracklen = 1 + hqrnduniformi(&rs, maxtracklen);
            ae_vector_set_length(&x, nlasttracklen);
            for (i = 0; i < nlasttracklen; i++) {
               x.xR[i] = hqrndnormal(&rs);
               tracksmatrix.xyR[k][i] = x.xR[i];
            }
            trackssizes.xZ[k] = nlasttracklen;
            ssaaddsequence(&state, &x, nlasttracklen);
         }
         if (algotype == 1) {
            ae_matrix_set_length(&b, 1, 1);
            b.xyR[0][0] = (double)(2 * hqrnduniformi(&rs, 2) - 1);
            ssasetalgoprecomputed(&state, &b, 1, 1);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, 1);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, 1);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
      // Test
         if (hqrnduniformr(&rs) > skipprob) {
            ssagetbasis(&state, &a, &sv, &windowwidth, &nbasis);
            Ok = Ok && windowwidth == 1;
            Ok = Ok && nbasis == 1;
            Ok = Ok && a.rows == 1;
            Ok = Ok && a.cols == 1;
            Ok = Ok && sv.cnt == 1;
            Ok = Ok && NearAtR(fabs(a.xyR[0][0]), 1.0, 100.0 * machineepsilon);
         }
         if (hqrnduniformr(&rs) > skipprob) {
            windowwidth = -1;
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzelastwindow(&state, &trend, &noise, &windowwidth);
            Ok = Ok && windowwidth == 1;
            Ok = Ok && trend.cnt == 1;
            Ok = Ok && noise.cnt == 1;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            Ok = Ok && NearAtR(trend.xR[0], x.xR[nlasttracklen - 1], 100.0 * machineepsilon);
            Ok = Ok && SmallAtR(noise.xR[0], 100.0 * machineepsilon);
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nanalyzed = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzelast(&state, nanalyzed, &trend, &noise);
            Ok = Ok && trend.cnt == nanalyzed;
            Ok = Ok && noise.cnt == nanalyzed;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < imax2(nanalyzed - nlasttracklen, 0); i++) {
               Ok = Ok && trend.xR[i] == 0.0;
               Ok = Ok && noise.xR[i] == 0.0;
            }
            for (i = imax2(nanalyzed - nlasttracklen, 0); i < nanalyzed; i++) {
               Ok = Ok && NearAtR(trend.xR[i], x.xR[i - nanalyzed + nlasttracklen], 100.0 * machineepsilon);
               Ok = Ok && SmallAtR(noise.xR[i], 100.0 * machineepsilon);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&x2, nticks);
            for (i = 0; i < nticks; i++) {
               x2.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzesequence(&state, &x2, nticks, &trend, &noise);
            Ok = Ok && trend.cnt == nticks;
            Ok = Ok && noise.cnt == nticks;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < nticks; i++) {
               Ok = Ok && NearAtR(trend.xR[i], x2.xR[i], 100.0 * machineepsilon);
               Ok = Ok && SmallAtR(noise.xR[i], 100.0 * machineepsilon);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&trend, 0);
            ssaforecastlast(&state, nticks, &trend);
            Ok = Ok && trend.cnt == nticks;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < nticks; i++) {
               Ok = Ok && trend.xR[i] == x.xR[nlasttracklen - 1];
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            datalen = 1 + hqrnduniformi(&rs, 10);
            forecastlen = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&x, datalen);
            for (i = 0; i < datalen; i++) {
               x.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&trend, 0);
            ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
            Ok = Ok && trend.cnt == forecastlen;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < forecastlen; i++) {
               Ok = Ok && trend.xR[i] == x.xR[datalen - 1];
            }
         }
      }
   // Test that for model with non-unit window, some algo being set to calculate ALL
   // components, and one/few tracks which have at least window length ticks:
   // * SSAGetBasis() returns full orthonormal basis
   // * SSAAnalyzeLastWindow() returns last elements of track as trend and zeros
   //   as noise (with minor rounding error)
   // * SSAAnalyzeLast() returns track as trend and zeros as noise (with
   //   minor rounding error possible). For NTicks > TrackLength result is correctly
   //   prepended with zeros.
   // * SSAAnalyzeSequence() returns:
   //   * for sequences with length at least window width - sequence as trend,
   //     zeros as noise (up to machine precision)
   //   * for sequences shorter than window width - zeros as trend,
   //     sequence as noise (exactly)
   // * SSAForecastLast() returns just copies of the last element
   // * SSAForecastSequence() returns just copies of the last element for long enough
   //   sequences, zeros for shorter sequences
      for (pass = 1; pass <= passcount; pass++) {
      // Generate task; last track is stored in X, its length in NLastTrackLen
         windowwidth = 1 + hqrnduniformi(&rs, 5);
         ntracks = 1 + hqrnduniformi(&rs, 3);
         mintracklen = windowwidth;
         maxtracklen = mintracklen + 2 * windowwidth;
         ssacreate(&state);
         ssasetwindow(&state, windowwidth);
         ae_matrix_set_length(&tracksmatrix, ntracks, maxtracklen);
         ae_vector_set_length(&trackssizes, ntracks);
         nlasttracklen = 0;
         for (k = 0; k < ntracks; k++) {
            nlasttracklen = mintracklen + hqrnduniformi(&rs, maxtracklen - mintracklen + 1);
            ae_vector_set_length(&x, nlasttracklen);
            for (i = 0; i < nlasttracklen; i++) {
               x.xR[i] = hqrndnormal(&rs);
               tracksmatrix.xyR[k][i] = x.xR[i];
            }
            trackssizes.xZ[k] = nlasttracklen;
            ssaaddsequence(&state, &x, nlasttracklen);
         }
         if (algotype == 1) {
            rmatrixrndorthogonal(windowwidth, &b);
            ssasetalgoprecomputed(&state, &b, windowwidth, windowwidth);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, windowwidth);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, windowwidth);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
      // Test
         if (hqrnduniformr(&rs) > skipprob) {
            ssagetbasis(&state, &a, &sv, &windowwidth2, &nbasis);
            Ok = Ok && windowwidth2 == windowwidth;
            Ok = Ok && nbasis == windowwidth;
            Ok = Ok && a.rows == windowwidth;
            Ok = Ok && a.cols == windowwidth;
            Ok = Ok && sv.cnt == windowwidth;
            for (i = 0; i < windowwidth; i++) {
               for (j = 0; j < windowwidth; j++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, a.xyR[j], 1, windowwidth);
                  if (i == j) {
                     v--;
                  }
                  Ok = Ok && SmallAtR(v, 100.0 * machineepsilon);
               }
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            windowwidth2 = -1;
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzelastwindow(&state, &trend, &noise, &windowwidth2);
            Ok = Ok && windowwidth2 == windowwidth;
            Ok = Ok && trend.cnt == windowwidth;
            Ok = Ok && noise.cnt == windowwidth;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < windowwidth; i++) {
               Ok = Ok && NearAtR(trend.xR[i], x.xR[i - windowwidth + nlasttracklen], 100.0 * machineepsilon);
               Ok = Ok && SmallAtR(noise.xR[i], 100.0 * machineepsilon);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nanalyzed = 1 + hqrnduniformi(&rs, 2 * maxtracklen);
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzelast(&state, nanalyzed, &trend, &noise);
            Ok = Ok && trend.cnt == nanalyzed;
            Ok = Ok && noise.cnt == nanalyzed;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < imax2(nanalyzed - nlasttracklen, 0); i++) {
               Ok = Ok && trend.xR[i] == 0.0;
               Ok = Ok && noise.xR[i] == 0.0;
            }
            for (i = imax2(nanalyzed - nlasttracklen, 0); i < nanalyzed; i++) {
               Ok = Ok && NearAtR(trend.xR[i], x.xR[i - nanalyzed + nlasttracklen], 100.0 * machineepsilon);
               Ok = Ok && SmallAtR(noise.xR[i], 100.0 * machineepsilon);
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 2 * windowwidth);
            ae_vector_set_length(&x2, nticks);
            for (i = 0; i < nticks; i++) {
               x2.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzesequence(&state, &x2, nticks, &trend, &noise);
            Ok = Ok && trend.cnt == nticks;
            Ok = Ok && noise.cnt == nticks;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < nticks; i++) {
               if (nticks >= windowwidth) {
                  Ok = Ok && NearAtR(trend.xR[i], x2.xR[i], 100.0 * machineepsilon);
                  Ok = Ok && SmallAtR(noise.xR[i], 100.0 * machineepsilon);
               } else {
                  Ok = Ok && SmallAtR(trend.xR[i], 100.0 * machineepsilon);
                  Ok = Ok && NearAtR(noise.xR[i], x2.xR[i], 100.0 * machineepsilon);
               }
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&trend, 0);
            ssaforecastlast(&state, nticks, &trend);
            Ok = Ok && trend.cnt == nticks;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < nticks; i++) {
               Ok = Ok && trend.xR[i] == x.xR[nlasttracklen - 1];
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            if (windowwidth > 2) {
               datalen = 1 + hqrnduniformi(&rs, windowwidth - 1);
               forecastlen = 1 + hqrnduniformi(&rs, 10);
               ae_vector_set_length(&x, datalen);
               for (i = 0; i < datalen; i++) {
                  x.xR[i] = hqrndnormal(&rs);
               }
               ae_vector_set_length(&trend, 0);
               ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
               Ok = Ok && trend.cnt == forecastlen;
               if (!Ok) {
                  ae_frame_leave();
                  return Ok;
               }
               for (i = 0; i < forecastlen; i++) {
                  Ok = Ok && trend.xR[i] == 0.0;
               }
            }
            datalen = windowwidth + hqrnduniformi(&rs, windowwidth);
            forecastlen = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&x, datalen);
            for (i = 0; i < datalen; i++) {
               x.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&trend, 0);
            ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
            Ok = Ok && trend.cnt == forecastlen;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < forecastlen; i++) {
               Ok = Ok && trend.xR[i] == x.xR[datalen - 1];
            }
         }
      }
   // Test that for model with
   //
   // * strictly non-unit window
   // * some algo being set to calculate one leading component
   // * a few tracks which have at least window length ticks
   // * and last track which has LESS than window length minus 1 ticks
   //
   // we have:
   //
   // * SSAAnalyzeLastWindow() returns zero trend and sequence as noise,
   //   correctly padded by zeros
   // * SSAAnalyzeLast() returns zero trend and sequence as noise,
   //   correctly padded by zeros
   // * SSAForecastLast() returns zero trend
   //
   // This test checks correct handling of the situatuon when last sequence
   // stored in the dataset is too short.
      for (pass = 1; pass <= passcount; pass++) {
      // Generate task; last track is stored in X, its length in NLastTrackLen
         windowwidth = 3 + hqrnduniformi(&rs, 5);
         ntracks = 1 + hqrnduniformi(&rs, 3);
         mintracklen = windowwidth;
         maxtracklen = mintracklen + 2 * windowwidth;
         ssacreate(&state);
         ssasetwindow(&state, windowwidth);
         for (k = 0; k < ntracks; k++) {
            nlasttracklen = mintracklen + hqrnduniformi(&rs, maxtracklen - mintracklen + 1);
            ae_vector_set_length(&x, nlasttracklen);
            for (i = 0; i < nlasttracklen; i++) {
               x.xR[i] = hqrndnormal(&rs);
            }
            ssaaddsequence(&state, &x, nlasttracklen);
         }
         nlasttracklen = windowwidth - 2;
         ae_vector_set_length(&x, nlasttracklen);
         for (i = 0; i < nlasttracklen; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ssaaddsequence(&state, &x, nlasttracklen);
         if (algotype == 1) {
            rmatrixrndorthogonal(windowwidth, &b);
            ssasetalgoprecomputed(&state, &b, windowwidth, 1);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, 1);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, 1);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
      // Test
         if (hqrnduniformr(&rs) > skipprob) {
            windowwidth2 = -1;
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzelastwindow(&state, &trend, &noise, &windowwidth2);
            Ok = Ok && windowwidth2 == windowwidth;
            Ok = Ok && trend.cnt == windowwidth;
            Ok = Ok && noise.cnt == windowwidth;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < windowwidth; i++) {
               Ok = Ok && trend.xR[i] == 0.0;
               j = nlasttracklen + (i - windowwidth);
               if (j >= 0) {
                  Ok = Ok && noise.xR[i] == x.xR[j];
               } else {
                  Ok = Ok && noise.xR[i] == 0.0;
               }
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nanalyzed = 1 + hqrnduniformi(&rs, 2 * windowwidth);
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzelast(&state, nanalyzed, &trend, &noise);
            Ok = Ok && trend.cnt == nanalyzed;
            Ok = Ok && noise.cnt == nanalyzed;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < imax2(nanalyzed - nlasttracklen, 0); i++) {
               Ok = Ok && trend.xR[i] == 0.0;
               Ok = Ok && noise.xR[i] == 0.0;
            }
            for (i = imax2(nanalyzed - nlasttracklen, 0); i < nanalyzed; i++) {
               Ok = Ok && trend.xR[i] == 0.0;
               Ok = Ok && noise.xR[i] == x.xR[nlasttracklen + (i - nanalyzed)];
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&trend, 0);
            ssaforecastlast(&state, nticks, &trend);
            Ok = Ok && trend.cnt == nticks;
            if (!Ok) {
               ae_frame_leave();
               return Ok;
            }
            for (i = 0; i < nticks; i++) {
               Ok = Ok && trend.xR[i] == 0.0;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

bool testssa() {
   bool specOk;
   bool genOk;
   bool Ok;
   specOk = true;
   genOk = true;
   specOk = specOk && testssaunit_testspecial();
   genOk = genOk && testssaunit_testgeneral();
// The final report.
   Ok = specOk && genOk;
   if (!Ok || !silent) {
      printf("SSA Test\n");
      printf("* General Test Suite:                     %s\n", genOk? "Ok": "Failed");
      printf("* Special Cases:                          %s\n", specOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === lda testing unit ===
// Normal random number
static double testldaunit_generatenormal(double mean, double sigma) {
   double u;
   double v;
   double sum;
   double result;
   result = mean;
   while (true) {
      u = (2 * randominteger(2) - 1) * randomreal();
      v = (2 * randominteger(2) - 1) * randomreal();
      sum = u * u + v * v;
      if (sum < 1.0 && sum > 0.0) {
         sum = sqrt(-2 * log(sum) / sum);
         result = sigma * u * sum + mean;
         break;
      }
   }
   return result;
}

// Generates 'simple' set - a sequence of unit 'balls' at (0,0), (1,0), (2,0)
// and so on.
static void testldaunit_gensimpleset(ae_int_t nfeatures, ae_int_t nclasses, ae_int_t nsamples, ae_int_t axis, RMatrix *xy) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t c;
   SetMatrix(xy);
   ae_assert(axis >= 0 && axis < nfeatures, "GenSimpleSet: wrong Axis!");
   ae_matrix_set_length(xy, nsamples, nfeatures + 1);
   for (i = 0; i < nsamples; i++) {
      for (j = 0; j < nfeatures; j++) {
         xy->xyR[i][j] = testldaunit_generatenormal(0.0, 1.0);
      }
      c = i % nclasses;
      xy->xyR[i][axis] += c;
      xy->xyR[i][nfeatures] = (double)c;
   }
}

// Generates 'degenerate' set #1.
// NFeatures >= 3.
static void testldaunit_gendeg1set(ae_int_t nfeatures, ae_int_t nclasses, ae_int_t nsamples, ae_int_t axis, RMatrix *xy) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t c;
   SetMatrix(xy);
   ae_assert(axis >= 0 && axis < nfeatures, "GenDeg1Set: wrong Axis!");
   ae_assert(nfeatures >= 3, "GenDeg1Set: wrong NFeatures!");
   ae_matrix_set_length(xy, nsamples, nfeatures + 1);
   if (axis >= nfeatures - 2) {
      axis = nfeatures - 3;
   }
   for (i = 0; i < nsamples; i++) {
      for (j = 0; j < nfeatures - 1; j++) {
         xy->xyR[i][j] = testldaunit_generatenormal(0.0, 1.0);
      }
      xy->xyR[i][nfeatures - 1] = xy->xyR[i][nfeatures - 2];
      c = i % nclasses;
      xy->xyR[i][axis] += c;
      xy->xyR[i][nfeatures] = (double)c;
   }
}

// Calculates J
static double testldaunit_calcj(ae_int_t nf, RMatrix *st, RMatrix *sw, RVector *w, double *p, double *q) {
   ae_frame _frame_block;
   ae_int_t i;
   double v;
   double result;
   ae_frame_make(&_frame_block);
   *p = 0;
   *q = 0;
   NewVector(tx, 0, DT_REAL);
   ae_vector_set_length(&tx, nf);
   for (i = 0; i < nf; i++) {
      v = ae_v_dotproduct(st->xyR[i], 1, w->xR, 1, nf);
      tx.xR[i] = v;
   }
   v = ae_v_dotproduct(w->xR, 1, tx.xR, 1, nf);
   *p = v;
   for (i = 0; i < nf; i++) {
      v = ae_v_dotproduct(sw->xyR[i], 1, w->xR, 1, nf);
      tx.xR[i] = v;
   }
   v = ae_v_dotproduct(w->xR, 1, tx.xR, 1, nf);
   *q = v;
   result = *p / (*q);
   ae_frame_leave();
   return result;
}

// Calculates ST/SW
static void testldaunit_fishers(RMatrix *xy, ae_int_t npoints, ae_int_t nfeatures, ae_int_t nclasses, RMatrix *st, RMatrix *sw) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_frame_make(&_frame_block);
   SetMatrix(st);
   SetMatrix(sw);
   NewVector(c, 0, DT_INT);
   NewVector(mu, 0, DT_REAL);
   NewMatrix(muc, 0, 0, DT_REAL);
   NewVector(nc, 0, DT_INT);
   NewVector(tf, 0, DT_REAL);
   NewVector(work, 0, DT_REAL);
// Prepare temporaries
   ae_vector_set_length(&tf, nfeatures);
   ae_vector_set_length(&work, nfeatures + 1);
// Convert class labels from reals to integers (just for convenience)
   ae_vector_set_length(&c, npoints);
   for (i = 0; i < npoints; i++) {
      c.xZ[i] = iround(xy->xyR[i][nfeatures]);
   }
// Calculate class sizes and means
   ae_vector_set_length(&mu, nfeatures);
   ae_matrix_set_length(&muc, nclasses, nfeatures);
   ae_vector_set_length(&nc, nclasses);
   for (j = 0; j < nfeatures; j++) {
      mu.xR[j] = 0.0;
   }
   for (i = 0; i < nclasses; i++) {
      nc.xZ[i] = 0;
      for (j = 0; j < nfeatures; j++) {
         muc.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < npoints; i++) {
      ae_v_add(mu.xR, 1, xy->xyR[i], 1, nfeatures);
      ae_v_add(muc.xyR[c.xZ[i]], 1, xy->xyR[i], 1, nfeatures);
      nc.xZ[c.xZ[i]]++;
   }
   for (i = 0; i < nclasses; i++) {
      v = 1.0 / nc.xZ[i];
      ae_v_muld(muc.xyR[i], 1, nfeatures, v);
   }
   v = 1.0 / npoints;
   ae_v_muld(mu.xR, 1, nfeatures, v);
// Create ST matrix
   ae_matrix_set_length(st, nfeatures, nfeatures);
   for (i = 0; i < nfeatures; i++) {
      for (j = 0; j < nfeatures; j++) {
         st->xyR[i][j] = 0.0;
      }
   }
   for (k = 0; k < npoints; k++) {
      ae_v_move(tf.xR, 1, xy->xyR[k], 1, nfeatures);
      ae_v_sub(tf.xR, 1, mu.xR, 1, nfeatures);
      for (i = 0; i < nfeatures; i++) {
         v = tf.xR[i];
         ae_v_addd(st->xyR[i], 1, tf.xR, 1, nfeatures, v);
      }
   }
// Create SW matrix
   ae_matrix_set_length(sw, nfeatures, nfeatures);
   for (i = 0; i < nfeatures; i++) {
      for (j = 0; j < nfeatures; j++) {
         sw->xyR[i][j] = 0.0;
      }
   }
   for (k = 0; k < npoints; k++) {
      ae_v_move(tf.xR, 1, xy->xyR[k], 1, nfeatures);
      ae_v_sub(tf.xR, 1, muc.xyR[c.xZ[k]], 1, nfeatures);
      for (i = 0; i < nfeatures; i++) {
         v = tf.xR[i];
         ae_v_addd(sw->xyR[i], 1, tf.xR, 1, nfeatures, v);
      }
   }
   ae_frame_leave();
}

// Tests WN for correctness
static bool testldaunit_testwn(RMatrix *xy, RMatrix *wn, ae_int_t ns, ae_int_t nf, ae_int_t nc, ae_int_t ndeg) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   double wprev;
   double tol;
   double p;
   double q;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewMatrix(st, 0, 0, DT_REAL);
   NewMatrix(sw, 0, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewVector(tx, 0, DT_REAL);
   NewVector(jp, 0, DT_REAL);
   NewVector(jq, 0, DT_REAL);
   NewVector(work, 0, DT_REAL);
   tol = 10000.0;
   Ok = true;
   testldaunit_fishers(xy, ns, nf, nc, &st, &sw);
// Test for decreasing of J
   ae_vector_set_length(&tx, nf);
   ae_vector_set_length(&jp, nf);
   ae_vector_set_length(&jq, nf);
   for (j = 0; j < nf; j++) {
      ae_v_move(tx.xR, 1, &wn->xyR[0][j], wn->stride, nf);
      v = testldaunit_calcj(nf, &st, &sw, &tx, &p, &q);
      jp.xR[j] = p;
      jq.xR[j] = q;
   }
   for (i = 1; i < nf - ndeg; i++) {
      Ok = Ok && jp.xR[i - 1] / jq.xR[i - 1] >= (1 - tol * machineepsilon) * jp.xR[i] / jq.xR[i];
   }
   for (i = nf - 1 - ndeg + 1; i < nf; i++) {
      Ok = Ok && jp.xR[i] <= tol * machineepsilon * jp.xR[0];
   }
// Test for J optimality
   ae_v_move(tx.xR, 1, wn->xyR[0], wn->stride, nf);
   v = testldaunit_calcj(nf, &st, &sw, &tx, &p, &q);
   for (i = 0; i < nf; i++) {
      wprev = tx.xR[i];
      tx.xR[i] = wprev + 0.01;
      Ok = Ok && v >= (1 - tol * machineepsilon) * testldaunit_calcj(nf, &st, &sw, &tx, &p, &q);
      tx.xR[i] = wprev - 0.01;
      Ok = Ok && v >= (1 - tol * machineepsilon) * testldaunit_calcj(nf, &st, &sw, &tx, &p, &q);
      tx.xR[i] = wprev;
   }
// Test for linear independence of W
   ae_vector_set_length(&work, nf + 1);
   ae_matrix_set_length(&a, nf, nf);
   matrixmatrixmultiply(wn, 0, nf - 1, 0, nf - 1, false, wn, 0, nf - 1, 0, nf - 1, true, 1.0, &a, 0, nf - 1, 0, nf - 1, 0.0, &work);
   if (smatrixevd(&a, nf, 1, true, &tx, &z)) {
      Ok = Ok && tx.xR[0] > tx.xR[nf - 1] * 1000.0 * machineepsilon;
   }
// Test for other properties
   for (j = 0; j < nf; j++) {
      v = ae_v_dotproduct(&wn->xyR[0][j], wn->stride, &wn->xyR[0][j], wn->stride, nf);
      v = sqrt(v);
      Ok = Ok && NearAtR(v, 1.0, 1000.0 * machineepsilon);
      v = 0.0;
      for (i = 0; i < nf; i++) {
         v += wn->xyR[i][j];
      }
      Ok = Ok && v >= 0.0;
   }
   ae_frame_leave();
   return Ok;
}

bool testlda() {
   ae_frame _frame_block;
   ae_int_t maxnf;
   ae_int_t maxns;
   ae_int_t maxnc;
   ae_int_t passcount;
   bool ldanOk;
   bool lda1Ok;
   bool Ok;
   ae_int_t nf;
   ae_int_t nc;
   ae_int_t ns;
   ae_int_t i;
   ae_int_t info;
   ae_int_t pass;
   ae_int_t axis;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(wn, 0, 0, DT_REAL);
   NewVector(w1, 0, DT_REAL);
// Primary settings
   maxnf = 10;
   maxns = 1000;
   maxnc = 5;
   passcount = 1;
   Ok = true;
   ldanOk = true;
   lda1Ok = true;
// General tests
   for (nf = 1; nf <= maxnf; nf++) {
      for (nc = 2; nc <= maxnc; nc++) {
         for (pass = 1; pass <= passcount; pass++) {
         // Simple test for LDA-N/LDA-1
            axis = randominteger(nf);
            ns = maxns / 2 + randominteger(maxns / 2);
            testldaunit_gensimpleset(nf, nc, ns, axis, &xy);
            fisherldan(&xy, ns, nf, nc, &info, &wn);
            if (info != 1) {
               ldanOk = false;
               continue;
            }
            ldanOk = ldanOk && testldaunit_testwn(&xy, &wn, ns, nf, nc, 0);
            ldanOk = ldanOk && !SmallAtR(wn.xyR[axis][0], 0.75);
            fisherlda(&xy, ns, nf, nc, &info, &w1);
            for (i = 0; i < nf; i++) {
               lda1Ok = lda1Ok && w1.xR[i] == wn.xyR[i][0];
            }
         // Degenerate test for LDA-N
            if (nf >= 3) {
               ns = maxns / 2 + randominteger(maxns / 2);
            // there are two duplicate features,
            // axis is oriented along non-duplicate feature
               axis = randominteger(nf - 2);
               testldaunit_gendeg1set(nf, nc, ns, axis, &xy);
               fisherldan(&xy, ns, nf, nc, &info, &wn);
               if (info != 2) {
                  ldanOk = false;
                  continue;
               }
               ldanOk = ldanOk && wn.xyR[axis][0] > 0.75;
               fisherlda(&xy, ns, nf, nc, &info, &w1);
               for (i = 0; i < nf; i++) {
                  lda1Ok = lda1Ok && w1.xR[i] == wn.xyR[i][0];
               }
            }
         }
      }
   }
// The final report.
   Ok = ldanOk && lda1Ok;
   if (!Ok || !silent) {
      printf("LDA Tests\n");
      printf("Fisher LDA-N:                             %s\n", ldanOk? "Ok": "Failed");
      printf("Fisher LDA-1:                             %s\n", lda1Ok? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === mcpd testing unit ===
// Simple test with no "entry"/"exit" states
static bool testmcpdunit_testsimple() {
   ae_frame _frame_block;
   ae_int_t n;
   double threshold;
   ae_int_t i;
   ae_int_t j;
   double v;
   double v0;
   double offdiagonal;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(pexact, 0, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(p, 0, 0, DT_REAL);
   NewObj(mcpdstate, s);
   NewObj(mcpdreport, rep);
   threshold = 1.0E-2;
// First test:
// * N-dimensional problem
// * proportional data
// * no "entry"/"exit" states
// * N tracks, each includes only two states
// * first record in I-th track is [0 ... 1 ... 0] with 1 is in I-th position
// * all tracks are modelled using randomly generated transition matrix P
   for (n = 1; n <= 5; n++) {
   // Initialize "exact" P:
   // * fill by random values
   // * make sure that each column sums to non-zero value
   // * normalize
      ae_matrix_set_length(&pexact, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            pexact.xyR[i][j] = randomreal();
         }
      }
      for (j = 0; j < n; j++) {
         i = randominteger(n);
         pexact.xyR[i][j] += 0.1;
      }
      for (j = 0; j < n; j++) {
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += pexact.xyR[i][j];
         }
         for (i = 0; i < n; i++) {
            pexact.xyR[i][j] /= v;
         }
      }
   // Initialize solver:
   // * create object
   // * add tracks
      mcpdcreate(n, &s);
      for (i = 0; i < n; i++) {
         ae_matrix_set_length(&xy, 2, n);
         for (j = 0; j < n; j++) {
            xy.xyR[0][j] = 0.0;
         }
         xy.xyR[0][i] = 1.0;
         for (j = 0; j < n; j++) {
            xy.xyR[1][j] = pexact.xyR[j][i];
         }
         mcpdaddtrack(&s, &xy, 2);
      }
   // Solve and test
      mcpdsolve(&s);
      mcpdresults(&s, &p, &rep);
      if (rep.terminationtype > 0) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               Ok = Ok && NearAtR(p.xyR[i][j], pexact.xyR[i][j], threshold);
            }
         }
      } else {
         Ok = false;
      }
   }
// Second test:
// * N-dimensional problem
// * proportional data
// * no "entry"/"exit" states
// * N tracks, each includes only two states
// * first record in I-th track is [0 ...0.1 0.8 0.1 ... 0] with 0.8 is in I-th position
// * all tracks are modelled using randomly generated transition matrix P
   offdiagonal = 0.1;
   for (n = 1; n <= 5; n++) {
   // Initialize "exact" P:
   // * fill by random values
   // * make sure that each column sums to non-zero value
   // * normalize
      ae_matrix_set_length(&pexact, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            pexact.xyR[i][j] = randomreal();
         }
      }
      for (j = 0; j < n; j++) {
         i = randominteger(n);
         pexact.xyR[i][j] += 0.1;
      }
      for (j = 0; j < n; j++) {
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += pexact.xyR[i][j];
         }
         for (i = 0; i < n; i++) {
            pexact.xyR[i][j] /= v;
         }
      }
   // Initialize solver:
   // * create object
   // * add tracks
      mcpdcreate(n, &s);
      for (i = 0; i < n; i++) {
         ae_matrix_set_length(&xy, 2, n);
         for (j = 0; j < n; j++) {
            xy.xyR[0][j] = 0.0;
         }
      // "main" element
         xy.xyR[0][i] = 1.0 - 2 * offdiagonal;
         for (j = 0; j < n; j++) {
            xy.xyR[1][j] = (1.0 - 2 * offdiagonal) * pexact.xyR[j][i];
         }
      // off-diagonal ones
         if (i > 0) {
            xy.xyR[0][i - 1] = offdiagonal;
            for (j = 0; j < n; j++) {
               xy.xyR[1][j] += offdiagonal * pexact.xyR[j][i - 1];
            }
         }
         if (i < n - 1) {
            xy.xyR[0][i + 1] = offdiagonal;
            for (j = 0; j < n; j++) {
               xy.xyR[1][j] += offdiagonal * pexact.xyR[j][i + 1];
            }
         }
         mcpdaddtrack(&s, &xy, 2);
      }
   // Solve and test
      mcpdsolve(&s);
      mcpdresults(&s, &p, &rep);
      if (rep.terminationtype > 0) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               Ok = Ok && NearAtR(p.xyR[i][j], pexact.xyR[i][j], threshold);
            }
         }
      } else {
         Ok = false;
      }
   }
// Third test:
// * N-dimensional problem
// * population data
// * no "entry"/"exit" states
// * N tracks, each includes only two states
// * first record in I-th track is V*[0 ...0.1 0.8 0.1 ... 0] with 0.8 is in I-th position, V in [1,10]
// * all tracks are modelled using randomly generated transition matrix P
   offdiagonal = 0.1;
   for (n = 1; n <= 5; n++) {
   // Initialize "exact" P:
   // * fill by random values
   // * make sure that each column sums to non-zero value
   // * normalize
      ae_matrix_set_length(&pexact, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            pexact.xyR[i][j] = randomreal();
         }
      }
      for (j = 0; j < n; j++) {
         i = randominteger(n);
         pexact.xyR[i][j] += 0.1;
      }
      for (j = 0; j < n; j++) {
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += pexact.xyR[i][j];
         }
         for (i = 0; i < n; i++) {
            pexact.xyR[i][j] /= v;
         }
      }
   // Initialize solver:
   // * create object
   // * add tracks
      mcpdcreate(n, &s);
      for (i = 0; i < n; i++) {
         ae_matrix_set_length(&xy, 2, n);
         for (j = 0; j < n; j++) {
            xy.xyR[0][j] = 0.0;
         }
      // "main" element
         v0 = 9.0 * randomreal() + 1;
         xy.xyR[0][i] = v0 * (1.0 - 2 * offdiagonal);
         for (j = 0; j < n; j++) {
            xy.xyR[1][j] = v0 * (1.0 - 2 * offdiagonal) * pexact.xyR[j][i];
         }
      // off-diagonal ones
         if (i > 0) {
            xy.xyR[0][i - 1] = v0 * offdiagonal;
            for (j = 0; j < n; j++) {
               xy.xyR[1][j] += v0 * offdiagonal * pexact.xyR[j][i - 1];
            }
         }
         if (i < n - 1) {
            xy.xyR[0][i + 1] = v0 * offdiagonal;
            for (j = 0; j < n; j++) {
               xy.xyR[1][j] += v0 * offdiagonal * pexact.xyR[j][i + 1];
            }
         }
         mcpdaddtrack(&s, &xy, 2);
      }
   // Solve and test
      mcpdsolve(&s);
      mcpdresults(&s, &p, &rep);
      if (rep.terminationtype > 0) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               Ok = Ok && NearAtR(p.xyR[i][j], pexact.xyR[i][j], threshold);
            }
         }
      } else {
         Ok = false;
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test for different combinations of "entry"/"exit" models
static bool testmcpdunit_testentryexit() {
   ae_frame _frame_block;
   ae_int_t n;
   double threshold;
   ae_int_t entrystate;
   ae_int_t exitstate;
   ae_int_t entrykind;
   ae_int_t exitkind;
   ae_int_t popkind;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(p, 0, 0, DT_REAL);
   NewMatrix(pexact, 0, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(mcpdstate, s);
   NewObj(mcpdreport, rep);
   threshold = 1.0E-3;
//
   for (n = 2; n <= 5; n++) {
      for (entrykind = 0; entrykind <= 1; entrykind++) {
         for (exitkind = 0; exitkind <= 1; exitkind++) {
            for (popkind = 0; popkind <= 1; popkind++) {
            // Generate EntryState/ExitState such that one of the following is True:
            // * EntryState != ExitState
            // * EntryState == -1 or ExitState == -1
               do {
                  if (entrykind == 0) {
                     entrystate = -1;
                  } else {
                     entrystate = randominteger(n);
                  }
                  if (exitkind == 0) {
                     exitstate = -1;
                  } else {
                     exitstate = randominteger(n);
                  }
               } while (entrystate != -1 && exitstate != -1 && entrystate == exitstate);
            // Generate transition matrix P such that:
            // * columns corresponding to non-exit states sums to 1.0
            // * columns corresponding to exit states sums to 0.0
            // * rows corresponding to entry states are zero
               ae_matrix_set_length(&pexact, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     pexact.xyR[i][j] = (double)(1 + randominteger(5));
                     if (i == entrystate) {
                        pexact.xyR[i][j] = 0.0;
                     }
                     if (j == exitstate) {
                        pexact.xyR[i][j] = 0.0;
                     }
                  }
               }
               for (j = 0; j < n; j++) {
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     v += pexact.xyR[i][j];
                  }
                  if (v != 0.0) {
                     for (i = 0; i < n; i++) {
                        pexact.xyR[i][j] /= v;
                     }
                  }
               }
            // Create MCPD solver
               if (entrystate < 0 && exitstate < 0) {
                  mcpdcreate(n, &s);
               }
               if (entrystate >= 0 && exitstate < 0) {
                  mcpdcreateentry(n, entrystate, &s);
               }
               if (entrystate < 0 && exitstate >= 0) {
                  mcpdcreateexit(n, exitstate, &s);
               }
               if (entrystate >= 0 && exitstate >= 0) {
                  mcpdcreateentryexit(n, entrystate, exitstate, &s);
               }
            // Add N tracks.
            //
            // K-th track starts from vector with large value of
            // K-th component and small random noise in other components.
            //
            // Track contains from 2 to 4 elements.
            //
            // Tracks contain proportional (normalized) or
            // population data, depending on PopKind variable.
               for (k = 0; k < n; k++) {
               // Generate track whose length is in 2..4
                  ae_matrix_set_length(&xy, 2 + randominteger(3), n);
                  for (j = 0; j < n; j++) {
                     xy.xyR[0][j] = 0.05 * randomreal();
                  }
                  xy.xyR[0][k] = 1 + randomreal();
                  for (i = 1; i < xy.rows; i++) {
                     for (j = 0; j < n; j++) {
                        if (j != entrystate) {
                           v = ae_v_dotproduct(pexact.xyR[j], 1, xy.xyR[i - 1], 1, n);
                           xy.xyR[i][j] = v;
                        } else {
                           xy.xyR[i][j] = randomreal();
                        }
                     }
                  }
               // Normalize, if needed
                  if (popkind == 1) {
                     for (i = 0; i < xy.rows; i++) {
                        v = 0.0;
                        for (j = 0; j < n; j++) {
                           v += xy.xyR[i][j];
                        }
                        if (v > 0.0) {
                           for (j = 0; j < n; j++) {
                              xy.xyR[i][j] /= v;
                           }
                        }
                     }
                  }
               // Add track
                  mcpdaddtrack(&s, &xy, xy.rows);
               }
            // Solve and test
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               if (rep.terminationtype > 0) {
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        Ok = Ok && NearAtR(p.xyR[i][j], pexact.xyR[i][j], threshold);
                     }
                  }
               } else {
                  Ok = false;
               }
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// This function is used to create MCPD object with arbitrary combination of
// entry and exit states
static void testmcpdunit_createee(ae_int_t n, ae_int_t entrystate, ae_int_t exitstate, mcpdstate *s) {
   SetObj(mcpdstate, s);
   if (entrystate < 0 && exitstate < 0) {
      mcpdcreate(n, s);
   }
   if (entrystate >= 0 && exitstate < 0) {
      mcpdcreateentry(n, entrystate, s);
   }
   if (entrystate < 0 && exitstate >= 0) {
      mcpdcreateexit(n, exitstate, s);
   }
   if (entrystate >= 0 && exitstate >= 0) {
      mcpdcreateentryexit(n, entrystate, exitstate, s);
   }
}

// Test equality constraints.
static bool testmcpdunit_testec() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t entrystate;
   ae_int_t exitstate;
   ae_int_t entrykind;
   ae_int_t exitkind;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ic;
   ae_int_t jc;
   double vc;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(p, 0, 0, DT_REAL);
   NewMatrix(ec, 0, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(mcpdstate, s);
   NewObj(mcpdreport, rep);
// We try different problems with following properties:
// * N is large enough - we won't have problems with inconsistent constraints
// * first state is either "entry" or "normal"
// * last state is either "exit" or "normal"
// * we have one long random track
//
// We test several properties which are described in comments below
   for (n = 4; n <= 6; n++) {
      for (entrykind = 0; entrykind <= 1; entrykind++) {
         for (exitkind = 0; exitkind <= 1; exitkind++) {
         // Prepare problem
            if (entrykind == 0) {
               entrystate = -1;
            } else {
               entrystate = 0;
            }
            if (exitkind == 0) {
               exitstate = -1;
            } else {
               exitstate = n - 1;
            }
            ae_matrix_set_length(&xy, 2 * n, n);
            for (i = 0; i < xy.rows; i++) {
               for (j = 0; j < xy.cols; j++) {
                  xy.xyR[i][j] = randomreal();
               }
            }
         // Test that single equality constraint on non-entry
         // non-exit elements of P is satisfied.
         //
         // NOTE: this test needs N >= 4 because smaller values
         // can give us inconsistent constraints
            ae_assert(n >= 4, "TestEC: expectation failed");
            ic = 1 + randominteger(n - 2);
            jc = 1 + randominteger(n - 2);
            vc = randomreal();
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            mcpdaddec(&s, ic, jc, vc);
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            if (rep.terminationtype > 0) {
               Ok = Ok && p.xyR[ic][jc] == vc;
            } else {
               Ok = false;
            }
         // Test interaction with default "sum-to-one" constraint
         // on columns of P.
         //
         // We set N-1 equality constraints on random non-exit column
         // of P, which are inconsistent with this default constraint
         // (sum will be greater that 1.0).
         //
         // Algorithm must detect inconsistency.
         //
         // NOTE:
         // 1. we do not set constraints for the first element of
         //    the column, because this element may be constrained by
         //    "exit state" constraint.
         // 2. this test needs N >= 3
            ae_assert(n >= 3, "TestEC: expectation failed");
            jc = randominteger(n - 1);
            vc = 0.95;
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            for (i = 1; i < n; i++) {
               mcpdaddec(&s, i, jc, vc);
            }
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            Ok = Ok && rep.terminationtype == -3;
         // Test interaction with constrains on entry states.
         //
         // When model has entry state, corresponding row of P
         // must be zero. We try to set two kinds of constraints
         // on random element of this row:
         // * zero equality constraint, which must be consistent
         // * non-zero equality constraint, which must be inconsistent
            if (entrystate >= 0) {
               jc = randominteger(n);
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddec(&s, entrystate, jc, 0.0);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               Ok = Ok && rep.terminationtype > 0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddec(&s, entrystate, jc, 0.5);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               Ok = Ok && rep.terminationtype == -3;
            }
         // Test interaction with constrains on exit states.
         //
         // When model has exit state, corresponding column of P
         // must be zero. We try to set two kinds of constraints
         // on random element of this column:
         // * zero equality constraint, which must be consistent
         // * non-zero equality constraint, which must be inconsistent
            if (exitstate >= 0) {
               ic = randominteger(n);
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddec(&s, ic, exitstate, 0.0);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               Ok = Ok && rep.terminationtype > 0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddec(&s, ic, exitstate, 0.5);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               Ok = Ok && rep.terminationtype == -3;
            }
         // Test SetEC() call - we constrain subset of non-entry
         // non-exit elements and test it.
            ae_assert(n >= 4, "TestEC: expectation failed");
            ae_matrix_set_length(&ec, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  ec.xyR[i][j] = NAN;
               }
            }
            for (j = 1; j < n - 1; j++) {
               ec.xyR[1 + randominteger(n - 2)][j] = 0.1 + 0.1 * randomreal();
            }
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            mcpdsetec(&s, &ec);
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            if (rep.terminationtype > 0) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     if (isfinite(ec.xyR[i][j])) {
                        Ok = Ok && p.xyR[i][j] == ec.xyR[i][j];
                     }
                  }
               }
            } else {
               Ok = false;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test bound constraints.
static bool testmcpdunit_testbc() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t entrystate;
   ae_int_t exitstate;
   ae_int_t entrykind;
   ae_int_t exitkind;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ic;
   ae_int_t jc;
   double vl;
   double vu;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(p, 0, 0, DT_REAL);
   NewMatrix(bndl, 0, 0, DT_REAL);
   NewMatrix(bndu, 0, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(mcpdstate, s);
   NewObj(mcpdreport, rep);
// We try different problems with following properties:
// * N is large enough - we won't have problems with inconsistent constraints
// * first state is either "entry" or "normal"
// * last state is either "exit" or "normal"
// * we have one long random track
//
// We test several properties which are described in comments below
   for (n = 4; n <= 6; n++) {
      for (entrykind = 0; entrykind <= 1; entrykind++) {
         for (exitkind = 0; exitkind <= 1; exitkind++) {
         // Prepare problem
            if (entrykind == 0) {
               entrystate = -1;
            } else {
               entrystate = 0;
            }
            if (exitkind == 0) {
               exitstate = -1;
            } else {
               exitstate = n - 1;
            }
            ae_matrix_set_length(&xy, 2 * n, n);
            for (i = 0; i < xy.rows; i++) {
               for (j = 0; j < xy.cols; j++) {
                  xy.xyR[i][j] = randomreal();
               }
            }
         // Test that single bound constraint on non-entry
         // non-exit elements of P is satisfied.
         //
         // NOTE 1: this test needs N >= 4 because smaller values
         // can give us inconsistent constraints
            ae_assert(n >= 4, "TestBC: expectation failed");
            ic = 1 + randominteger(n - 2);
            jc = 1 + randominteger(n - 2);
            if (randombool()) {
               vl = 0.3 * randomreal();
            } else {
               vl = -INFINITY;
            }
            if (randombool()) {
               vu = 0.5 + 0.3 * randomreal();
            } else {
               vu = +INFINITY;
            }
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            mcpdaddbc(&s, ic, jc, vl, vu);
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            if (rep.terminationtype > 0) {
               Ok = Ok && p.xyR[ic][jc] >= vl;
               Ok = Ok && p.xyR[ic][jc] <= vu;
            } else {
               Ok = false;
            }
         // Test interaction with default "sum-to-one" constraint
         // on columns of P.
         //
         // We set N-1 bound constraints on random non-exit column
         // of P, which are inconsistent with this default constraint
         // (sum will be greater that 1.0).
         //
         // Algorithm must detect inconsistency.
         //
         // NOTE:
         // 1. we do not set constraints for the first element of
         //    the column, because this element may be constrained by
         //    "exit state" constraint.
         // 2. this test needs N >= 3
            ae_assert(n >= 3, "TestEC: expectation failed");
            jc = randominteger(n - 1);
            vl = 0.85;
            vu = 0.95;
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            for (i = 1; i < n; i++) {
               mcpdaddbc(&s, i, jc, vl, vu);
            }
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            Ok = Ok && rep.terminationtype == -3;
         // Test interaction with constrains on entry states.
         //
         // When model has entry state, corresponding row of P
         // must be zero. We try to set two kinds of constraints
         // on random element of this row:
         // * bound constraint with zero lower bound, which must be consistent
         // * bound constraint with non-zero lower bound, which must be inconsistent
            if (entrystate >= 0) {
               jc = randominteger(n);
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddbc(&s, entrystate, jc, 0.0, 1.0);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               Ok = Ok && rep.terminationtype > 0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddbc(&s, entrystate, jc, 0.5, 1.0);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               Ok = Ok && rep.terminationtype == -3;
            }
         // Test interaction with constrains on exit states.
         //
         // When model has exit state, corresponding column of P
         // must be zero. We try to set two kinds of constraints
         // on random element of this column:
         // * bound constraint with zero lower bound, which must be consistent
         // * bound constraint with non-zero lower bound, which must be inconsistent
            if (exitstate >= 0) {
               ic = randominteger(n);
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddbc(&s, ic, exitstate, 0.0, 1.0);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               Ok = Ok && rep.terminationtype > 0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddbc(&s, ic, exitstate, 0.5, 1.0);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               Ok = Ok && rep.terminationtype == -3;
            }
         // Test SetBC() call - we constrain subset of non-entry
         // non-exit elements and test it.
            ae_assert(n >= 4, "TestBC: expectation failed");
            ae_matrix_set_length(&bndl, n, n);
            ae_matrix_set_length(&bndu, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  bndl.xyR[i][j] = -INFINITY;
                  bndu.xyR[i][j] = +INFINITY;
               }
            }
            for (j = 1; j < n - 1; j++) {
               i = 1 + randominteger(n - 2);
               bndl.xyR[i][j] = 0.5 - 0.1 * randomreal();
               bndu.xyR[i][j] = 0.5 + 0.1 * randomreal();
            }
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            mcpdsetbc(&s, &bndl, &bndu);
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            if (rep.terminationtype > 0) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     Ok = Ok && p.xyR[i][j] >= bndl.xyR[i][j];
                     Ok = Ok && p.xyR[i][j] <= bndu.xyR[i][j];
                  }
               }
            } else {
               Ok = false;
            }
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

// Test bound constraints.
static bool testmcpdunit_testlc() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t entrystate;
   ae_int_t exitstate;
   ae_int_t entrykind;
   ae_int_t exitkind;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t t;
   ae_int_t jc;
   double v;
   double threshold;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewMatrix(p, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(mcpdstate, s);
   NewObj(mcpdreport, rep);
   threshold = 1.0E5 * machineepsilon;
// We try different problems with following properties:
// * N is large enough - we won't have problems with inconsistent constraints
// * first state is either "entry" or "normal"
// * last state is either "exit" or "normal"
// * we have one long random track
//
// We test several properties which are described in comments below
   for (n = 4; n <= 6; n++) {
      for (entrykind = 0; entrykind <= 1; entrykind++) {
         for (exitkind = 0; exitkind <= 1; exitkind++) {
         // Prepare problem
            if (entrykind == 0) {
               entrystate = -1;
            } else {
               entrystate = 0;
            }
            if (exitkind == 0) {
               exitstate = -1;
            } else {
               exitstate = n - 1;
            }
            ae_matrix_set_length(&xy, 2 * n, n);
            for (i = 0; i < xy.rows; i++) {
               for (j = 0; j < xy.cols; j++) {
                  xy.xyR[i][j] = randomreal();
               }
            }
         // Test that single linear equality/inequality constraint
         // on non-entry non-exit elements of P is satisfied.
         //
         // NOTE 1: this test needs N >= 4 because smaller values
         //         can give us inconsistent constraints
         // NOTE 2: Constraints are generated is such a way that P == (1/N ... 1/N)
         //         is always feasible. It guarantees that there always exists
         //         at least one feasible point
         // NOTE 3: If we have inequality constraint, we "shift" right part
         //         in order to make feasible some neighborhood of P == (1/N ... 1/N).
            ae_assert(n >= 4, "TestLC: expectation failed");
            ae_matrix_set_length(&c, 1, n * n + 1);
            ae_vector_set_length(&ct, 1);
            v = 0.0;
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (i == 0 || i == n - 1 || j == 0 || j == n - 1) {
                     c.xyR[0][i * n + j] = 0.0;
                  } else {
                     c.xyR[0][i * n + j] = randomreal();
                     v += c.xyR[0][i * n + j] * (1.0 / n);
                  }
               }
            }
            c.xyR[0][n * n] = v;
            ct.xZ[0] = randominteger(3) - 1;
            if (ct.xZ[0] < 0) {
               c.xyR[0][n * n] += 0.1;
            }
            if (ct.xZ[0] > 0) {
               c.xyR[0][n * n] -= 0.1;
            }
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            mcpdsetlc(&s, &c, &ct, 1);
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            if (rep.terminationtype > 0) {
               v = 0.0;
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     v += p.xyR[i][j] * c.xyR[0][i * n + j];
                  }
               }
               if (ct.xZ[0] < 0) {
                  Ok = Ok && v < c.xyR[0][n * n] + threshold;
               }
               if (ct.xZ[0] == 0) {
                  Ok = Ok && NearR(v, c.xyR[0][n * n], threshold);
               }
               if (ct.xZ[0] > 0) {
                  Ok = Ok && v > c.xyR[0][n * n] - threshold;
               }
            } else {
               Ok = false;
            }
         // Test interaction with default "sum-to-one" constraint
         // on columns of P.
         //
         // We set linear constraint which has for "sum-to-X" on
         // on random non-exit column of P. This constraint can be
         // either consistent (X == 1.0) or inconsistent (X != 1.0) with
         // this default constraint.
         //
         // Algorithm must detect inconsistency.
         //
         // NOTE:
         // 1. this test needs N >= 2
            ae_assert(n >= 2, "TestLC: expectation failed");
            jc = randominteger(n - 1);
            ae_matrix_set_length(&c, 1, n * n + 1);
            ae_vector_set_length(&ct, 1);
            for (i = 0; i < n * n; i++) {
               c.xyR[0][i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               c.xyR[0][n * i + jc] = 1.0;
            }
            c.xyR[0][n * n] = 1.0;
            ct.xZ[0] = 0;
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            mcpdsetlc(&s, &c, &ct, 1);
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            Ok = Ok && rep.terminationtype > 0;
            c.xyR[0][n * n] = 2.0;
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            mcpdsetlc(&s, &c, &ct, 1);
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            Ok = Ok && rep.terminationtype == -3;
         // Test interaction with constrains on entry states.
         //
         // When model has entry state, corresponding row of P
         // must be zero. We try to set two kinds of constraints
         // on elements of this row:
         // * sums-to-zero constraint, which must be consistent
         // * sums-to-one constraint, which must be inconsistent
            if (entrystate >= 0) {
               ae_matrix_set_length(&c, 1, n * n + 1);
               ae_vector_set_length(&ct, 1);
               for (i = 0; i < n * n; i++) {
                  c.xyR[0][i] = 0.0;
               }
               for (j = 0; j < n; j++) {
                  c.xyR[0][n * entrystate + j] = 1.0;
               }
               ct.xZ[0] = 0;
               c.xyR[0][n * n] = 0.0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdsetlc(&s, &c, &ct, 1);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               Ok = Ok && rep.terminationtype > 0;
               c.xyR[0][n * n] = 1.0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdsetlc(&s, &c, &ct, 1);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               Ok = Ok && rep.terminationtype == -3;
            }
         // Test interaction with constrains on exit states.
         //
         // When model has exit state, corresponding column of P
         // must be zero. We try to set two kinds of constraints
         // on elements of this column:
         // * sums-to-zero constraint, which must be consistent
         // * sums-to-one constraint, which must be inconsistent
            if (exitstate >= 0) {
               ae_matrix_set_length(&c, 1, n * n + 1);
               ae_vector_set_length(&ct, 1);
               for (i = 0; i < n * n; i++) {
                  c.xyR[0][i] = 0.0;
               }
               for (i = 0; i < n; i++) {
                  c.xyR[0][n * i + exitstate] = 1.0;
               }
               ct.xZ[0] = 0;
               c.xyR[0][n * n] = 0.0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdsetlc(&s, &c, &ct, 1);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               Ok = Ok && rep.terminationtype > 0;
               c.xyR[0][n * n] = 1.0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdsetlc(&s, &c, &ct, 1);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               Ok = Ok && rep.terminationtype == -3;
            }
         }
      }
   }
// Final test - we generate several random constraints and
// test SetLC() function.
//
// NOTES:
//
// 1. Constraints are generated is such a way that P == (1/N ... 1/N)
//    is always feasible. It guarantees that there always exists
//    at least one feasible point
// 2. For simplicity of the test we do not use entry/exit states
//    in our model
   for (n = 1; n <= 4; n++) {
      for (k = 1; k <= 2 * n; k++) {
      // Generate track
         ae_matrix_set_length(&xy, 2 * n, n);
         for (i = 0; i < xy.rows; i++) {
            for (j = 0; j < xy.cols; j++) {
               xy.xyR[i][j] = randomreal();
            }
         }
      // Generate random constraints
         ae_matrix_set_length(&c, k, n * n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < k; i++) {
         // Generate constraint and its right part
            c.xyR[i][n * n] = 0.0;
            for (j = 0; j < n * n; j++) {
               c.xyR[i][j] = randommid();
               c.xyR[i][n * n] += c.xyR[i][j] * (1.0 / n);
            }
            ct.xZ[i] = randominteger(3) - 1;
         // If we have inequality constraint, we "shift" right part
         // in order to make feasible some neighborhood of P == (1/N ... 1/N).
            if (ct.xZ[i] < 0) {
               c.xyR[i][n * n] += 0.1;
            }
            if (ct.xZ[i] > 0) {
               c.xyR[i][n * n] -= 0.1;
            }
         }
      // Test
         testmcpdunit_createee(n, -1, -1, &s);
         mcpdaddtrack(&s, &xy, xy.rows);
         mcpdsetlc(&s, &c, &ct, k);
         mcpdsolve(&s);
         mcpdresults(&s, &p, &rep);
         if (rep.terminationtype > 0) {
            for (t = 0; t < k; t++) {
               v = 0.0;
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     v += p.xyR[i][j] * c.xyR[t][i * n + j];
                  }
               }
               if (ct.xZ[t] < 0) {
                  Ok = Ok && v < c.xyR[t][n * n] + threshold;
               }
               if (ct.xZ[t] == 0) {
                  Ok = Ok && NearR(v, c.xyR[t][n * n], threshold);
               }
               if (ct.xZ[t] > 0) {
                  Ok = Ok && v > c.xyR[t][n * n] - threshold;
               }
            }
         } else {
            Ok = false;
         }
      }
   }
   ae_frame_leave();
   return Ok;
}

bool testmcpd() {
   bool Ok;
   bool simpleOk;
   bool entryexitOk;
   bool ecOk;
   bool bcOk;
   bool lcOk;
   bool otherOk;
// Init
   Ok = true;
   otherOk = true;
   simpleOk = true;
   entryexitOk = true;
   ecOk = true;
   bcOk = true;
   lcOk = true;
// Test
   simpleOk = simpleOk && testmcpdunit_testsimple(); //(@)
   entryexitOk = entryexitOk && testmcpdunit_testentryexit(); //(@)
   ecOk = ecOk && testmcpdunit_testec(); //(@)
   bcOk = bcOk && testmcpdunit_testbc(); //(@)
   lcOk = lcOk && testmcpdunit_testlc(); //(@)
// The final report.
   Ok = otherOk && simpleOk && entryexitOk && ecOk && bcOk && lcOk;
   if (!Ok || !silent) {
      printf("MCPD Tests\n");
      printf("* Simple:                                 %s\n", simpleOk? "Ok": "Failed");
      printf("* Entry/Exit:                             %s\n", entryexitOk? "Ok": "Failed");
      printf("* Equality Constraints:                   %s\n", ecOk? "Ok": "Failed");
      printf("* Bound Constraints:                      %s\n", bcOk? "Ok": "Failed");
      printf("* Linear Constraints:                     %s\n", lcOk? "Ok": "Failed");
      printf("* Other Properties:                       %s\n", otherOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === knn testing unit ===
// Unsets model
static void testknnunit_unsetknn(knnmodel *model) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(knnbuilder, builder);
   NewObj(knnreport, rep);
   ae_matrix_set_length(&xy, 1, 2);
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = randomreal() - 0.5;
   knnbuildercreate(&builder);
   knnbuildersetdatasetreg(&builder, &xy, 1, 1, 1);
   knnbuilderbuildknnmodel(&builder, 1, 0.0, model, &rep);
   model->nvars = -1;
   model->nout = -1;
   model->k = -1;
   model->eps = 0.0;
   model->isdummy = true;
   ae_frame_leave();
}

// Test set errors.
//
// Computes test set errors:
// * average cross-entropy
// * relative classification error (a range [RelCls0,RelCls1] is returned
//   because classification error can be computed differently in the presence
//   of the ties). All possible values of the classification error, no matter
//   how ties are resolved, are guaranteed to be within [RelCls0,RelCls1].
static void testknnunit_testseterrors(knnmodel *model, ae_int_t nvars, ae_int_t nout, bool iscls, RMatrix *xy, ae_int_t npoints, double *avgce, double *relcls0, double *relcls1, double *rms, double *avg, double *avgrel) {
   ae_frame _frame_block;
   ae_int_t relcnt;
   ae_int_t i;
   ae_int_t j;
   double v;
   double mxy;
   ae_frame_make(&_frame_block);
   *avgce = 0;
   *relcls0 = 0;
   *relcls1 = 0;
   *rms = 0;
   *avg = 0;
   *avgrel = 0;
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(ey, 0, DT_REAL);
   ae_vector_set_length(&x, nvars);
   ae_vector_set_length(&y, nout);
   ae_vector_set_length(&ey, nout);
   *avgce = 0.0;
   *relcls0 = 0.0;
   *relcls1 = 0.0;
   *rms = 0.0;
   *avg = 0.0;
   *avgrel = 0.0;
   relcnt = 0;
   for (i = 0; i < npoints; i++) {
      for (j = 0; j < nvars; j++) {
         x.xR[j] = xy->xyR[i][j];
      }
      knnprocess(model, &x, &y);
      if (iscls) {
         for (j = 0; j < nout; j++) {
            ey.xR[j] = 0.0;
         }
         ey.xR[iround(xy->xyR[i][nvars])] = 1.0;
      } else {
         for (j = 0; j < nout; j++) {
            ey.xR[j] = xy->xyR[i][nvars + j];
         }
      }
      for (j = 0; j < nout; j++) {
         v = y.xR[j] - ey.xR[j];
         if (iscls) {
            *avgce -= ey.xR[j] * log(y.xR[j] + minrealnumber);
         }
         *rms += sqr(v);
         *avg += fabs(v);
         if (ey.xR[j] != 0.0) {
            *avgrel += fabs(v / ey.xR[j]);
            relcnt++;
         }
      }
      if (iscls) {
         mxy = 0.0;
         for (j = 0; j < nout; j++) {
            mxy = rmax2(mxy, y.xR[j]);
         }
         if (y.xR[iround(xy->xyR[i][nvars])] == mxy) {
         // RelCls0 is NOT increased because correct value achieves maximum.
         // However, if ties are present, we have to increase RelCls1, upper bound
         // of the uncertainty interval for the classification error.
            for (j = 0; j < nout; j++) {
               if (j != iround(xy->xyR[i][nvars]) && y.xR[j] == mxy) {
                  ++*relcls1;
                  break;
               }
            }
         } else {
         // Both bounds of the error range are increased by 1
            ++*relcls0;
            ++*relcls1;
         }
      }
   }
   *relcls0 /= npoints;
   *relcls1 /= npoints;
   *avgce /= npoints;
   *rms = sqrt(*rms / (npoints * nout));
   *avg /= npoints * nout;
   *avgrel /= coalesce((double)relcnt, 1.0);
   ae_frame_leave();
}

// Processing functions test
static bool testknnunit_testknnalgo() {
   ae_frame _frame_block;
   ae_int_t nvars;
   ae_int_t nout;
   bool iscls;
   ae_int_t ny;
   ae_int_t k;
   double eps;
   ae_int_t npoints;
   ae_int_t testnpoints;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   bool allsame;
   double v;
   double refavgce;
   double refcls0;
   double refcls1;
   double refrms;
   double refavg;
   double refavgrel;
   double maxerr;
   double avgerr;
   ae_int_t cnt;
   bool Ok = true;
   ae_frame_make(&_frame_block);
   NewObj(knnmodel, model1);
   NewObj(knnmodel, model2);
   NewObj(knnmodel, modelus);
   NewObj(knnbuilder, builder);
   NewObj(knnreport, rep);
   NewObj(knnreport, rep2);
   NewObj(knnreport, tstrep);
   NewObj(knnbuffer, buf);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(testxy, 0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(y3, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Test on randomly generated sets with randomly generated algo settings
//
// We test:
// * process
// * processi
// * process0
// * classify
// * serialization/unserialization
// * reports and test set error evaluation
// * knnrewritekeps()
   for (pass = 1; pass <= 100; pass++) {
   // initialize parameters
      nvars = 1 + hqrnduniformi(&rs, 5);
      if (hqrndnormal(&rs) > 0.0) {
         iscls = true;
         nout = 2 + hqrnduniformi(&rs, 3);
         ny = 1;
      } else {
         iscls = false;
         nout = 1 + hqrnduniformi(&rs, 3);
         ny = nout;
      }
      k = 1 + hqrnduniformi(&rs, 3);
      eps = hqrnduniformi(&rs, 2) * 0.1 * hqrnduniformr(&rs);
   // Initialize arrays and data: training and test sets
      npoints = 10 + hqrnduniformi(&rs, 100);
      ae_matrix_set_length(&xy, npoints, nvars + ny);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            if (j % 2 == 0) {
               xy.xyR[i][j] = hqrndnormal(&rs);
            } else {
               xy.xyR[i][j] = (double)hqrnduniformi(&rs, 2);
            }
         }
         if (iscls) {
            xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nout);
         } else {
            for (j = 0; j < nout; j++) {
               xy.xyR[i][nvars + j] = hqrndnormal(&rs);
            }
         }
      }
      testnpoints = 10 + hqrnduniformi(&rs, 100);
      ae_matrix_set_length(&testxy, testnpoints, nvars + ny);
      for (i = 0; i < testnpoints; i++) {
         for (j = 0; j < nvars; j++) {
            if (j % 2 == 0) {
               testxy.xyR[i][j] = hqrndnormal(&rs);
            } else {
               testxy.xyR[i][j] = (double)hqrnduniformi(&rs, 2);
            }
         }
         if (iscls) {
            testxy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nout);
         } else {
            for (j = 0; j < nout; j++) {
               testxy.xyR[i][nvars + j] = hqrndnormal(&rs);
            }
         }
      }
   // create model
      testknnunit_unsetknn(&model1);
      knnbuildercreate(&builder);
      if (iscls) {
         knnbuildersetdatasetcls(&builder, &xy, npoints, nvars, nout);
      } else {
         knnbuildersetdatasetreg(&builder, &xy, npoints, nvars, nout);
      }
      knnbuildersetnorm(&builder, hqrnduniformi(&rs, 3));
      knnbuilderbuildknnmodel(&builder, k, eps, &model1, &rep);
      knncreatebuffer(&model1, &buf);
   // Check that:
   // * knnprocess()   does not shrink output array, only increases
   // * knntsprocess() does not shrink output array, only increases
   // * knnprocessi() fits length exactly to NOut
      ae_vector_set_length(&x1, nvars);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&y1, nout + 1);
      knnprocess(&model1, &x1, &y1);
      Ok = Ok && y1.cnt == nout + 1;
      ae_vector_set_length(&y1, nout - 1);
      knnprocess(&model1, &x1, &y1);
      Ok = Ok && y1.cnt == nout;
      ae_vector_set_length(&y1, nout + 1);
      knntsprocess(&model1, &buf, &x1, &y1);
      Ok = Ok && y1.cnt == nout + 1;
      ae_vector_set_length(&y1, nout - 1);
      knntsprocess(&model1, &buf, &x1, &y1);
      Ok = Ok && y1.cnt == nout;
      ae_vector_set_length(&y1, nout + 1);
      knnprocessi(&model1, &x1, &y1);
      Ok = Ok && y1.cnt == nout;
      ae_vector_set_length(&y1, nout - 1);
      knnprocessi(&model1, &x1, &y1);
      Ok = Ok && y1.cnt == nout;
      if (!Ok) {
         ae_frame_leave();
         return Ok;
      }
   // knnprocess(), knnprocessi() and knntsprocess() return same results
      ae_vector_set_length(&x1, nvars);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
      }
      knnprocess(&model1, &x1, &y1);
      knnprocessi(&model1, &x1, &y2);
      knntsprocess(&model1, &buf, &x1, &y3);
      for (i = 0; i < nout; i++) {
         Ok = Ok && NearAtR(y2.xR[i], y1.xR[i], 100.0 * machineepsilon);
         Ok = Ok && NearAtR(y3.xR[i], y1.xR[i], 100.0 * machineepsilon);
      }
   // Same inputs leads to same outputs
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      ae_vector_set_length(&y1, nout);
      ae_vector_set_length(&y2, nout);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nout; i++) {
         y1.xR[i] = hqrndnormal(&rs);
         y2.xR[i] = hqrndnormal(&rs);
      }
      knnprocess(&model1, &x1, &y1);
      knnprocess(&model1, &x2, &y2);
      allsame = true;
      for (i = 0; i < nout; i++) {
         allsame = allsame && y1.xR[i] == y2.xR[i];
      }
      Ok = Ok && allsame;
   // Same inputs on original forest leads to same outputs
   // on copy created using KNNSerialize
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      ae_vector_set_length(&y1, nout);
      ae_vector_set_length(&y2, nout);
      testknnunit_unsetknn(&modelus);
      {
      // This code passes data structure through serializers
      // (serializes it to string and loads back)
         ae_frame _local_frame_block;
         ae_frame_make(&_local_frame_block);
         NewSerializer(_local_serializer);
         ae_serializer_alloc_start(&_local_serializer);
         knnalloc(&_local_serializer, &model1);
         ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
         NewBlock(_local_dynamic_block, _local_ssize + 1);
         ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
         knnserialize(&_local_serializer, &model1);
         ae_serializer_stop(&_local_serializer);
         ae_serializer_init(&_local_serializer);
         ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
         knnunserialize(&_local_serializer, &modelus);
         ae_serializer_stop(&_local_serializer);
         ae_frame_leave();
      }
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nout; i++) {
         y1.xR[i] = hqrndnormal(&rs);
         y2.xR[i] = hqrndnormal(&rs);
      }
      knnprocess(&model1, &x1, &y1);
      knnprocess(&modelus, &x2, &y2);
      allsame = true;
      for (i = 0; i < nout; i++) {
         allsame = allsame && y1.xR[i] == y2.xR[i];
      }
      Ok = Ok && allsame;
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      Ok = Ok && NearAtR(knnprocess0(&model1, &x1), knnprocess0(&modelus, &x2), 100.0 * machineepsilon);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      Ok = Ok && knnclassify(&model1, &x1) == knnclassify(&modelus, &x2);
   // KNNProcess0 works as expected
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      ae_vector_set_length(&y1, nout);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nout; i++) {
         y1.xR[i] = hqrndnormal(&rs);
      }
      knnprocess(&model1, &x1, &y1);
      Ok = Ok && NearAtR(y1.xR[0], knnprocess0(&model1, &x2), 100.0 * machineepsilon);
   // KNNClassify works as expected
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      ae_vector_set_length(&y1, nout);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      if (iscls) {
         for (i = 0; i < nout; i++) {
            y1.xR[i] = hqrndnormal(&rs);
         }
         knnprocess(&model1, &x1, &y1);
         j = knnclassify(&model1, &x2);
         for (i = 0; i < nout; i++) {
            Ok = Ok && y1.xR[i] <= y1.xR[j];
         }
      } else {
         Ok = Ok && knnclassify(&model1, &x2) == -1;
      }
   // Normalization properties
      if (iscls) {
         for (i = 0; i < nvars; i++) {
            x1.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&y1, 0);
         knnprocess(&model1, &x1, &y1);
         v = 0.0;
         for (i = 0; i < nout; i++) {
            v += y1.xR[i];
            Ok = Ok && y1.xR[i] >= 0.0;
         }
         Ok = Ok && NearAtR(v, 1.0, 1000.0 * machineepsilon);
      }
   // Test various error metrics reported by algorithm:
   // * training set errors included in the report
   // * errors on the test set
   //
   // NOTE: cross-entropy metric is tested only for training set.
   //       because model can produce exactly zero probabilities
   //       for completely unknown values
      testknnunit_testseterrors(&model1, nvars, nout, iscls, &xy, npoints, &refavgce, &refcls0, &refcls1, &refrms, &refavg, &refavgrel);
      if (iscls) {
         Ok = Ok && NearAtR(rep.avgce, refavgce, 1.0E-6);
         Ok = Ok && NearAtR(knnavgce(&model1, &xy, npoints), refavgce, 1.0E-6);
         Ok = Ok && rep.relclserror >= refcls0 - 1.0E-6;
         Ok = Ok && rep.relclserror <= refcls1 + 1.0E-6;
         Ok = Ok && knnrelclserror(&model1, &xy, npoints) >= refcls0 - 1.0E-6;
         Ok = Ok && knnrelclserror(&model1, &xy, npoints) <= refcls1 + 1.0E-6;
      } else {
         Ok = Ok && rep.avgce == 0.0;
         Ok = Ok && knnavgce(&model1, &xy, npoints) == 0.0;
         Ok = Ok && rep.relclserror == 0.0;
         Ok = Ok && knnrelclserror(&model1, &xy, npoints) == 0.0;
      }
      Ok = Ok && NearAtR(rep.rmserror, refrms, 1.0E-6);
      Ok = Ok && NearAtR(rep.avgerror, refavg, 1.0E-6);
      Ok = Ok && NearAtR(rep.avgrelerror, refavgrel, 1.0E-6);
      Ok = Ok && NearAtR(knnrmserror(&model1, &xy, npoints), refrms, 1.0E-6);
      Ok = Ok && NearAtR(knnavgerror(&model1, &xy, npoints), refavg, 1.0E-6);
      Ok = Ok && NearAtR(knnavgrelerror(&model1, &xy, npoints), refavgrel, 1.0E-6);
      testknnunit_testseterrors(&model1, nvars, nout, iscls, &testxy, testnpoints, &refavgce, &refcls0, &refcls1, &refrms, &refavg, &refavgrel);
      knnallerrors(&model1, &testxy, testnpoints, &tstrep);
      if (iscls) {
         Ok = Ok && tstrep.relclserror >= refcls0 - 1.0E-6;
         Ok = Ok && tstrep.relclserror <= refcls1 + 1.0E-6;
      } else {
         Ok = Ok && tstrep.avgce == 0.0;
         Ok = Ok && tstrep.relclserror == 0.0;
      }
      Ok = Ok && NearAtR(tstrep.rmserror, refrms, 1.0E-6);
      Ok = Ok && NearAtR(tstrep.avgerror, refavg, 1.0E-6);
      Ok = Ok && NearAtR(tstrep.avgrelerror, refavgrel, 1.0E-6);
   }
// Test that model built with K == 1 and Eps == 0 remembers all training cases
   for (nvars = 1; nvars <= 4; nvars++) {
      for (pass = 0; pass <= 10; pass++) {
      // Prepare task
         npoints = 1 + hqrnduniformi(&rs, 20);
         if (hqrndnormal(&rs) > 0.0) {
            iscls = true;
            nout = 2 + hqrnduniformi(&rs, 3);
            ny = 1;
         } else {
            iscls = false;
            nout = 1 + hqrnduniformi(&rs, 3);
            ny = nout;
         }
         ae_matrix_set_length(&xy, npoints, nvars + ny);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = i * 0.000001;
            for (j = 1; j < nvars; j++) {
               xy.xyR[i][j] = hqrndnormal(&rs);
            }
            if (iscls) {
               xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nout);
            } else {
               for (j = 0; j < nout; j++) {
                  xy.xyR[i][nvars + j] = hqrndnormal(&rs);
               }
            }
         }
      // Create model
         testknnunit_unsetknn(&model1);
         knnbuildercreate(&builder);
         if (iscls) {
            knnbuildersetdatasetcls(&builder, &xy, npoints, nvars, nout);
         } else {
            knnbuildersetdatasetreg(&builder, &xy, npoints, nvars, nout);
         }
         knnbuildersetnorm(&builder, hqrnduniformi(&rs, 3));
         knnbuilderbuildknnmodel(&builder, 1, 0.0, &model1, &rep);
         Ok = Ok && rep.avgce <= 0.0;
         Ok = Ok && rep.relclserror <= 0.0;
         Ok = Ok && rep.rmserror <= 1.0E-6;
         Ok = Ok && rep.avgerror <= 1.0E-6;
         Ok = Ok && rep.avgrelerror <= 1.0E-6;
         ae_vector_set_length(&x1, nvars);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nvars; j++) {
               x1.xR[j] = xy.xyR[i][j];
            }
            knnprocess(&model1, &x1, &y1);
            if (iscls) {
               Ok = Ok && NearAtR(y1.xR[iround(xy.xyR[i][nvars])], 1.0, 10.0 * machineepsilon);
            } else {
               for (j = 0; j < nout; j++) {
                  Ok = Ok && NearAtR(y1.xR[j], xy.xyR[i][nvars + j], 10.0 * machineepsilon);
               }
            }
         }
      }
   }
// Test that model rewrite works as expected
   for (nvars = 1; nvars <= 20; nvars++) {
   // Prepare task
      npoints = 50 + 5 * nvars;
      if (hqrndnormal(&rs) > 0.0) {
         iscls = true;
         nout = 2 + hqrnduniformi(&rs, 3);
         ny = 1;
      } else {
         iscls = false;
         nout = 1 + hqrnduniformi(&rs, 3);
         ny = nout;
      }
      ae_matrix_set_length(&xy, npoints, nvars + ny);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            xy.xyR[i][j] = hqrndnormal(&rs);
         }
         if (iscls) {
            xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nout);
         } else {
            for (j = 0; j < nout; j++) {
               xy.xyR[i][nvars + j] = hqrndnormal(&rs);
            }
         }
      }
   // Select K, Eps
      k = 1 + hqrnduniformi(&rs, 10);
      eps = hqrnduniformi(&rs, 2) * (1.0 + 3.0 * hqrnduniformr(&rs));
   // Create model 1 using K, EPS.
   // Create model 2 using other (K,Eps), then rewrite search settings
      knnbuildercreate(&builder);
      if (iscls) {
         knnbuildersetdatasetcls(&builder, &xy, npoints, nvars, nout);
      } else {
         knnbuildersetdatasetreg(&builder, &xy, npoints, nvars, nout);
      }
      testknnunit_unsetknn(&model1);
      knnbuilderbuildknnmodel(&builder, k, eps, &model1, &rep);
      testknnunit_unsetknn(&model2);
      knnbuilderbuildknnmodel(&builder, 1 + hqrnduniformi(&rs, 10), hqrnduniformi(&rs, 2) * (1.0 + 3.0 * hqrnduniformr(&rs)), &model2, &rep2);
      knnrewritekeps(&model2, k, eps);
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      knnprocess(&model1, &x1, &y1);
      knnprocess(&model2, &x2, &y2);
      for (i = 0; i < nout; i++) {
         Ok = Ok && NearAtR(y1.xR[i], y2.xR[i], 1000.0 * machineepsilon);
      }
   }
// Test generalization ability on a simple noisy classification task:
// * 0 < x < 1 - P(class == 0) == 1
// * 1 < x < 2 - P(class == 0) == 2-x
// * 2 < x < 3 - P(class == 0) == 0
//
// An algorithm with K == 100 and Eps == {0,0.1} is tested
   for (pass = 0; pass <= 1; pass++) {
   // Prepare task
      npoints = 3000;
      ae_matrix_set_length(&xy, npoints, 2);
      for (i = 0; i < npoints; i++) {
         xy.xyR[i][0] = 3.0 * hqrnduniformr(&rs);
         if (xy.xyR[i][0] <= 1.0) {
            xy.xyR[i][1] = 0.0;
         } else {
            if (xy.xyR[i][0] <= 2.0) {
               if (hqrnduniformr(&rs) < xy.xyR[i][0] - 1) {
                  xy.xyR[i][1] = 1.0;
               } else {
                  xy.xyR[i][1] = 0.0;
               }
            } else {
               xy.xyR[i][1] = 1.0;
            }
         }
      }
   // Select K and Eps, create model
      k = 100;
      eps = 0.1 * (pass % 2);
      testknnunit_unsetknn(&model1);
      knnbuildercreate(&builder);
      knnbuildersetdatasetcls(&builder, &xy, npoints, 1, 2);
      knnbuildersetnorm(&builder, hqrnduniformi(&rs, 3));
      knnbuilderbuildknnmodel(&builder, k, eps, &model1, &rep);
   // Check model quality
      ae_vector_set_length(&x1, 1);
      x1.xR[0] = 0.0;
      while (x1.xR[0] <= 3.0) {
         knnprocess(&model1, &x1, &y1);
         Ok = Ok && y1.xR[0] >= 0.0;
         Ok = Ok && y1.xR[1] >= 0.0;
         Ok = Ok && NearAtR(y1.xR[0] + y1.xR[1], 1.0, 1000.0 * machineepsilon);
         if (x1.xR[0] < 1.0) {
            Ok = Ok && y1.xR[0] >= 0.8;
         }
         if (x1.xR[0] >= 1.0 && x1.xR[0] <= 2.0) {
            Ok = Ok && NearAtR(y1.xR[1], x1.xR[0] - 1.0, 0.5);
         }
         if (x1.xR[0] > 2.0) {
            Ok = Ok && y1.xR[1] >= 0.8;
         }
         x1.xR[0] += 0.01;
      }
   }
// Test simple regression task without noise:
// * |x| < 1, |y| < 1
// * F(x,y) = x^2+y
//
// A model with K == 50 is used, we check that
// * Eps == 0 is good enough
// * having Eps > 0 results in worse error metrics, but not too bad
// Prepare task
   npoints = 5000;
   ae_matrix_set_length(&xy, npoints, 3);
   for (i = 0; i < npoints; i++) {
      xy.xyR[i][0] = hqrndmiduniformr(&rs);
      xy.xyR[i][1] = hqrndmiduniformr(&rs);
      xy.xyR[i][2] = sqr(xy.xyR[i][0]) + xy.xyR[i][1];
   }
// Build model with Eps == 0, check model quality
   k = 50;
   testknnunit_unsetknn(&model1);
   knnbuildercreate(&builder);
   knnbuildersetdatasetreg(&builder, &xy, npoints, 2, 1);
   knnbuildersetnorm(&builder, hqrnduniformi(&rs, 3));
   knnbuilderbuildknnmodel(&builder, k, 0.0, &model1, &rep);
   ae_vector_set_length(&x1, 2);
   maxerr = 0.0;
   avgerr = 0.0;
   cnt = 0;
   for (i = 0; i <= 1000; i++) {
   // NOTE: we test model in the inner points, it deteriorates near the bounds
      x1.xR[0] = 0.8 * hqrndmiduniformr(&rs);
      x1.xR[1] = 0.8 * hqrndmiduniformr(&rs);
      v = sqr(x1.xR[0]) + x1.xR[1];
      knnprocess(&model1, &x1, &y1);
      v = fabs(y1.xR[0] - v);
      maxerr = rmax2(maxerr, v);
      avgerr += v;
      cnt++;
   }
   avgerr /= cnt;
   Ok = Ok && maxerr <= 0.15;
   Ok = Ok && avgerr <= 0.05;
// Build model with Eps == 1.0, compare error metrics with Eps == 0
   knnbuilderbuildknnmodel(&builder, k, 1.0, &model2, &rep2);
   Ok = Ok && rep2.rmserror > rep.rmserror;
   Ok = Ok && rep2.rmserror > rep.rmserror + 0.001;
   Ok = Ok && rep2.rmserror < rep.rmserror + 0.020;
   ae_frame_leave();
   return Ok;
}

bool testknn() {
   bool Ok;
   bool knnOk;
// Primary settings
   knnOk = true;
   Ok = true;
// Tests
   knnOk = knnOk && testknnunit_testknnalgo();
// The final report.
   Ok = knnOk;
   if (!Ok || !silent) {
      printf("KNN Classifier/Regression Tests\n");
      printf("* KNN (AKNN) Algorithm:                   %s\n", knnOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === mlptrain testing unit ===
// This function tests MLPTrainES().
static bool testmlptrainunit_testmlptraines() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t nrestarts;
   ae_int_t info;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewMatrix(trnxy, 0, 0, DT_REAL);
   NewMatrix(valxy, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(mlpreport, rep);
   Ok = true;
// First test checks that MLPTrainES() - when training set is equal to the validation
// set, MLPTrainES() behaves just like a "normal" training algorithm.
//
// Test sequence:
// * generate training set - 100 random points from 2D square [-1,+1]*[-1,+1]
// * generate network with 2 inputs, no hidden layers, nonlinear output layer,
//   use its outputs as target values for the test set
// * randomize network
// * train with MLPTrainES(), using original set as both training and validation set
// * trained network must reproduce training set with good precision
//
// NOTE: it is important to test algorithm on nonlinear network because linear
//       problems converge too fast. Slow convergence is important to detect
//       some kinds of bugs.
//
// NOTE: it is important to have NRestarts at least equal to 5, because with just
//       one restart algorithm fails test about once in several thousands of passes.
   passcount = 10;
   nrestarts = 5;
   for (pass = 1; pass <= passcount; pass++) {
   // Create network, generate training/validation sets
      mlpcreater0(2, 1, -2.0, 2.0, &network);
      mlprandomize(&network);
      n = 100;
      ae_matrix_set_length(&trnxy, n, 3);
      ae_matrix_set_length(&valxy, n, 3);
      ae_vector_set_length(&x, 2);
      ae_vector_set_length(&y, 1);
      for (i = 0; i < n; i++) {
         for (j = 0; j <= 1; j++) {
            trnxy.xyR[i][j] = randommid();
            valxy.xyR[i][j] = trnxy.xyR[i][j];
            x.xR[j] = trnxy.xyR[i][j];
         }
         mlpprocess(&network, &x, &y);
         trnxy.xyR[i][2] = y.xR[0];
         valxy.xyR[i][2] = y.xR[0];
      }
      mlprandomize(&network);
      mlptraines(&network, &trnxy, n, &valxy, n, 0.0001, nrestarts, &info, &rep);
      if (info <= 0) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
      if (sqrt(mlperror(&network, &valxy, n) / n) > 0.01) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   ae_frame_leave();
   return Ok;
}

// This  function   tests   MLPTrainLM,  MLPTrainLBFGS   and  MLPTrainNetwork
// functions  for regression.  It check that  train functions  work correctly.
// Test use Create1 with 10 neurons.
// Test function is f(x,y) == X^2+cos(3*Pi*y).
static bool testmlptrainunit_testmlptrainregr() {
   ae_frame _frame_block;
   ae_int_t info;
   ae_int_t n;
   ae_int_t sn;
   ae_int_t nneurons;
   double vdecay;
   double averr;
   double st;
   double eps;
   double traineps;
   ae_int_t nneedrest;
   ae_int_t trainits;
   ae_int_t shift;
   ae_int_t i;
   ae_int_t j;
   ae_int_t vtrain;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net);
   NewObj(mlptrainer, trainer);
   NewObj(mlpreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(sparsematrix, sm);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   eps = 0.01;
   vdecay = 0.001;
   nneurons = 10;
   nneedrest = 5;
   traineps = 1.0E-3;
   trainits = 0;
   sn = 5;
   n = sn * sn;
   st = 2.0 / (sn - 1);
   sparsecreate(n, 3, n * 3, &sm);
   ae_matrix_set_length(&xy, n, 3);
   ae_vector_set_length(&x, 2);
   for (vtrain = 0; vtrain <= 3; vtrain++) {
      averr = 0.0;
   // Create a train set(uniformly distributed set of points).
      for (i = 0; i < sn; i++) {
         for (j = 0; j < sn; j++) {
            shift = i * sn + j;
            xy.xyR[shift][0] = i * st - 1.0;
            xy.xyR[shift][1] = j * st - 1.0;
            xy.xyR[shift][2] = xy.xyR[shift][0] * xy.xyR[shift][0] + cos(3 * pi * xy.xyR[shift][1]);
         }
      }
   // Create and train a neural network
      mlpcreate1(2, nneurons, 1, &net);
      if (vtrain == 0) {
         mlptrainlm(&net, &xy, n, vdecay, nneedrest, &info, &rep);
      }
      if (vtrain == 1) {
         mlptrainlbfgs(&net, &xy, n, vdecay, nneedrest, traineps, trainits, &info, &rep);
      }
   // Train with trainer, using:
   // * dense matrix;
      if (vtrain == 2) {
         mlpcreatetrainer(2, 1, &trainer);
         mlpsetdataset(&trainer, &xy, n);
         mlpsetdecay(&trainer, vdecay);
         mlpsetcond(&trainer, traineps, trainits);
         mlptrainnetwork(&trainer, &net, nneedrest, &rep);
      }
   // * sparse matrix.
      if (vtrain == 3) {
         for (i = 0; i < n; i++) {
            for (j = 0; j <= 2; j++) {
               sparseset(&sm, i, j, xy.xyR[i][j]);
            }
         }
         mlpcreatetrainer(2, 1, &trainer);
         mlpsetsparsedataset(&trainer, &sm, n);
         mlpsetdecay(&trainer, vdecay);
         mlpsetcond(&trainer, traineps, trainits);
         mlptrainnetwork(&trainer, &net, nneedrest, &rep);
      }
   // Check that network is trained correctly
      for (i = 0; i < n; i++) {
         x.xR[0] = xy.xyR[i][0];
         x.xR[1] = xy.xyR[i][1];
         mlpprocess(&net, &x, &y);
      // Calculate average error
         averr += fabs(y.xR[0] - xy.xyR[i][2]);
      }
      if (averr / n > eps) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This  function tests  MLPTrainNetwork/MLPStartTraining/MLPContinueTraining
// functions for  regression.  It check  that train  functions work correctly.
// Test use Create1 with 2 neurons.
// Test function is XOR(x,y).
static bool testmlptrainunit_testmlpxorregr() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t sn;
   ae_int_t nneurons;
   double vdecay;
   double averr;
   double eps;
   ae_int_t numxp;
   double traineps;
   ae_int_t nneedrest;
   ae_int_t trainits;
   ae_int_t shift;
   ae_int_t i;
   ae_int_t j;
   ae_int_t vtrain;
   ae_int_t xp;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net);
   NewObj(mlptrainer, trainer);
   NewObj(mlpreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(sparsematrix, sm);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   eps = 0.01;
   numxp = 15;
   vdecay = 0.001;
   nneurons = 3;
   nneedrest = 1;
   traineps = 1.0E-4;
   trainits = 0;
   sn = 2;
   n = sn * sn;
   sparsecreate(n, 3, n * 3, &sm);
   ae_matrix_set_length(&xy, n, 3);
   ae_vector_set_length(&x, 2);
   for (xp = 1; xp <= numxp; xp++) {
      for (vtrain = 0; vtrain <= 3; vtrain++) {
         averr = 0.0;
      // Create a train set(uniformly distributed set of points).
         for (i = 0; i < sn; i++) {
            for (j = 0; j < sn; j++) {
               shift = i * sn + j;
               xy.xyR[shift][0] = (double)i;
               xy.xyR[shift][1] = (double)j;
               if (xy.xyR[shift][0] == xy.xyR[shift][1]) {
                  xy.xyR[shift][2] = 0.0;
               } else {
                  xy.xyR[shift][2] = 1.0;
               }
            }
         }
      // Create and train a neural network
         mlpcreate1(2, nneurons, 1, &net);
      // Train with trainer, using:
      // * dense matrix;
         if (vtrain == 0) {
            mlpcreatetrainer(2, 1, &trainer);
            mlpsetdataset(&trainer, &xy, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net, nneedrest, &rep);
         }
         if (vtrain == 1) {
            mlpcreatetrainer(2, 1, &trainer);
            mlpsetdataset(&trainer, &xy, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            for (mlpstarttraining(&trainer, &net, true); mlpcontinuetraining(&trainer, &net); ) { }
         }
      // * sparse matrix.
         if (vtrain == 2) {
            for (i = 0; i < n; i++) {
               for (j = 0; j <= 2; j++) {
                  sparseset(&sm, i, j, xy.xyR[i][j]);
               }
            }
            mlpcreatetrainer(2, 1, &trainer);
            mlpsetsparsedataset(&trainer, &sm, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net, nneedrest, &rep);
         }
         if (vtrain == 3) {
            for (i = 0; i < n; i++) {
               for (j = 0; j <= 2; j++) {
                  sparseset(&sm, i, j, xy.xyR[i][j]);
               }
            }
            mlpcreatetrainer(2, 1, &trainer);
            mlpsetsparsedataset(&trainer, &sm, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            for (mlpstarttraining(&trainer, &net, true); mlpcontinuetraining(&trainer, &net); ) { }
         }
      // Check that network is trained correctly
         for (i = 0; i < n; i++) {
            x.xR[0] = xy.xyR[i][0];
            x.xR[1] = xy.xyR[i][1];
            mlpprocess(&net, &x, &y);
         // Calculate average error
            averr += fabs(y.xR[0] - xy.xyR[i][2]);
         }
         if (averr / n > eps) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This  function   tests   MLPTrainLM,  MLPTrainLBFGS  and   MLPTrainNetwork
// functions for classification problems. It check that train  functions work
// correctly  when  is used CreateC1  function.  Here  the network  tries  to
// distinguish positive from negative numbers.
static bool testmlptrainunit_testmlptrainclass() {
   ae_frame _frame_block;
   ae_int_t info;
   ae_int_t n;
   double vdecay;
   double traineps;
   ae_int_t nneedrest;
   ae_int_t trainits;
   double mnc;
   double mxc;
   ae_int_t nxp;
   ae_int_t i;
   ae_int_t rndind;
   ae_int_t vtrain;
   ae_int_t xp;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net);
   NewObj(mlptrainer, trainer);
   NewObj(mlpreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(sparsematrix, sm);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   mnc = 10.0;
   mxc = 11.0;
   nxp = 15;
   vdecay = 0.001;
   nneedrest = 10;
   traineps = 1.0E-4;
   trainits = 0;
   n = 100;
   sparsecreate(n, 2, n * 2, &sm);
   ae_vector_set_length(&x, 1);
   ae_matrix_set_length(&xy, n, 2);
   for (xp = 1; xp <= nxp; xp++) {
      for (vtrain = 0; vtrain <= 3; vtrain++) {
      // Initialization:
      // * create negative part of the set;
         for (i = 0; i < n / 2; i++) {
            xy.xyR[i][0] = -1 * ((mxc - mnc) * randomreal() + mnc);
            xy.xyR[i][1] = 0.0;
         }
      // * create positive part of the set;
         for (i = n / 2; i < n; i++) {
            xy.xyR[i][0] = (mxc - mnc) * randomreal() + mnc;
            xy.xyR[i][1] = 1.0;
         }
      // * mix two parts.
         for (i = 0; i < n; i++) {
            do {
               rndind = randominteger(n);
            } while (rndind == i);
            swapr(&xy.xyR[i][0], &xy.xyR[rndind][0]);
            swapr(&xy.xyR[i][1], &xy.xyR[rndind][1]);
         }
      // Create and train a neural network
         mlpcreatec0(1, 2, &net);
         if (vtrain == 0) {
            mlptrainlm(&net, &xy, n, vdecay, nneedrest, &info, &rep);
         }
         if (vtrain == 1) {
            mlptrainlbfgs(&net, &xy, n, vdecay, nneedrest, traineps, trainits, &info, &rep);
         }
      // Train with trainer, using:
      // * dense matrix;
         if (vtrain == 2) {
            mlpcreatetrainercls(1, 2, &trainer);
            mlpsetdataset(&trainer, &xy, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net, nneedrest, &rep);
         }
      // * sparse matrix.
         if (vtrain == 3) {
            for (i = 0; i < n; i++) {
               sparseset(&sm, i, 0, xy.xyR[i][0]);
               sparseset(&sm, i, 1, xy.xyR[i][1]);
            }
            mlpcreatetrainercls(1, 2, &trainer);
            mlpsetsparsedataset(&trainer, &sm, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net, nneedrest, &rep);
         }
      // Test on training set
         for (i = 0; i < n; i++) {
            x.xR[0] = xy.xyR[i][0];
            mlpprocess(&net, &x, &y);
         // Negative number has to be negative and
         // positive number has to be positive.
            if (x.xR[0] < 0.0? y.xR[0] < 0.95 && y.xR[1] > 0.05: y.xR[0] > 0.05 && y.xR[1] < 0.95) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      // Test on random set
         for (i = 0; i < n; i++) {
            x.xR[0] = pow(-1.0, (double)randominteger(2)) * ((mxc - mnc) * randomreal() + mnc);
            mlpprocess(&net, &x, &y);
            if (x.xR[0] < 0.0? y.xR[0] < 0.95 && y.xR[1] > 0.05: y.xR[0] > 0.05 && y.xR[1] < 0.95) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This function tests   MLPTrainNetwork/MLPStartTraining/MLPContinueTraining
// functions for classification problems. It check that train  functions work
// correctly  when  is used CreateC1  function.  Here  the network  tries  to
// distinguish positive from negative numbers.
static bool testmlptrainunit_testmlpxorcls() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nin;
   ae_int_t nout;
   ae_int_t wcount;
   double e;
   double ebest;
   double v;
   double vdecay;
   double traineps;
   ae_int_t nneurons;
   ae_int_t nneedrest;
   ae_int_t trainits;
   ae_int_t nxp;
   ae_int_t i;
   ae_int_t vtrain;
   ae_int_t xp;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net);
   NewObj(mlptrainer, trainer);
   NewObj(mlpreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(sparsematrix, sm);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(wbest, 0, DT_REAL);
   nxp = 15;
   nneurons = 3;
   vdecay = 0.001;
   nneedrest = 3;
   traineps = 1.0E-4;
   trainits = 0;
   n = 4;
   sparsecreate(n, 3, n * 3, &sm);
   ae_vector_set_length(&x, 2);
   ae_matrix_set_length(&xy, n, 3);
// Initialization:
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = 0.0;
   xy.xyR[0][2] = 0.0;
   xy.xyR[1][0] = 0.0;
   xy.xyR[1][1] = 1.0;
   xy.xyR[1][2] = 1.0;
   xy.xyR[2][0] = 1.0;
   xy.xyR[2][1] = 0.0;
   xy.xyR[2][2] = 1.0;
   xy.xyR[3][0] = 1.0;
   xy.xyR[3][1] = 1.0;
   xy.xyR[3][2] = 0.0;
// Create a neural network
   mlpcreatec1(2, nneurons, 2, &net);
   mlpproperties(&net, &nin, &nout, &wcount);
   ae_vector_set_length(&wbest, wcount);
// Test
   for (xp = 1; xp <= nxp; xp++) {
      for (vtrain = 0; vtrain <= 3; vtrain++) {
      // Train with trainer, using:
      // * dense matrix;
         if (vtrain == 0) {
            mlpcreatetrainercls(2, 2, &trainer);
            mlpsetdataset(&trainer, &xy, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net, nneedrest, &rep);
         }
         if (vtrain == 1) {
            mlpcreatetrainercls(2, 2, &trainer);
            mlpsetdataset(&trainer, &xy, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            ebest = maxrealnumber;
            for (i = 1; i <= nneedrest; i++) {
               for (mlpstarttraining(&trainer, &net, true); mlpcontinuetraining(&trainer, &net); ) { }
               v = ae_v_dotproduct(net.weights.xR, 1, net.weights.xR, 1, wcount);
               e = mlperror(&net, &xy, n) + 0.5 * vdecay * v;
            // Compare with the best answer.
               if (e < ebest) {
                  ae_v_move(wbest.xR, 1, net.weights.xR, 1, wcount);
                  ebest = e;
               }
            }
         // The best result
            ae_v_move(net.weights.xR, 1, wbest.xR, 1, wcount);
         }
      // * sparse matrix.
         if (vtrain == 2) {
            for (i = 0; i < n; i++) {
               sparseset(&sm, i, 0, xy.xyR[i][0]);
               sparseset(&sm, i, 1, xy.xyR[i][1]);
               sparseset(&sm, i, 2, xy.xyR[i][2]);
            }
            mlpcreatetrainercls(2, 2, &trainer);
            mlpsetsparsedataset(&trainer, &sm, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net, nneedrest, &rep);
         }
         if (vtrain == 3) {
            for (i = 0; i < n; i++) {
               sparseset(&sm, i, 0, xy.xyR[i][0]);
               sparseset(&sm, i, 1, xy.xyR[i][1]);
               sparseset(&sm, i, 2, xy.xyR[i][2]);
            }
            mlpcreatetrainercls(2, 2, &trainer);
            mlpsetsparsedataset(&trainer, &sm, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            ebest = maxrealnumber;
            for (i = 1; i <= nneedrest; i++) {
               for (mlpstarttraining(&trainer, &net, true); mlpcontinuetraining(&trainer, &net); ) { }
               v = ae_v_dotproduct(net.weights.xR, 1, net.weights.xR, 1, wcount);
               e = mlperror(&net, &xy, n) + 0.5 * vdecay * v;
            // Compare with the best answer.
               if (e < ebest) {
                  ae_v_move(wbest.xR, 1, net.weights.xR, 1, wcount);
                  ebest = e;
               }
            }
         // The best result
            ae_v_move(net.weights.xR, 1, wbest.xR, 1, wcount);
         }
      // Test on training set
         for (i = 0; i < n; i++) {
            x.xR[0] = xy.xyR[i][0];
            x.xR[1] = xy.xyR[i][1];
            mlpprocess(&net, &x, &y);
            if (x.xR[0] == x.xR[1]? y.xR[0] < 0.95 && y.xR[1] > 0.05: y.xR[0] > 0.05 && y.xR[1] < 0.95) {
               Ok = false;
               ae_frame_leave();
               return Ok;
            }
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// The  test  check,  that  all weights are zero after training with trainer
// using empty dataset(either zero size or is't used MLPSetDataSet function).
// Test  on  regression and classification problems given by dense or sparse
// matrix.
//
// NOTE: Result of the function is written in MLPTrainRegrOk variable in
//       unit test.
static bool testmlptrainunit_testmlpzeroweights() {
   ae_frame _frame_block;
   ae_int_t nin;
   ae_int_t nout;
   ae_int_t wcount;
   ae_int_t mxnin;
   ae_int_t mxnout;
   double vdecay;
   double traineps;
   ae_int_t trainits;
   ae_int_t nneedrest;
   bool iscls;
   bool issparse;
   ae_int_t c;
   ae_int_t n;
   ae_int_t xp;
   ae_int_t nxp;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(mlptrainer, trainer);
   NewObj(multilayerperceptron, net);
   NewObj(mlpreport, rep);
   NewMatrix(dds, 0, 0, DT_REAL);
   NewObj(sparsematrix, sds);
   mxnin = 10;
   mxnout = 10;
   vdecay = 1.0E-3;
   nneedrest = 1;
   traineps = 1.0E-3;
   trainits = 0;
   sparsecreate(1, 1, 0, &sds);
   sparseconverttocrs(&sds);
   nxp = 10;
   for (xp = 1; xp <= nxp; xp++) {
      c = randominteger(2);
      iscls = c == 1;
      c = randominteger(2);
      issparse = c == 1;
   // Create trainer and network
      if (!iscls) {
      // Regression
         nin = randominteger(mxnin) + 1;
         nout = randominteger(mxnout) + 1;
         mlpcreatetrainer(nin, nout, &trainer);
         mlpcreate0(nin, nout, &net);
      } else {
      // Classification
         nin = randominteger(mxnin) + 1;
         nout = randominteger(mxnout) + 2;
         mlpcreatetrainercls(nin, nout, &trainer);
         mlpcreatec0(nin, nout, &net);
      }
      n = randominteger(2) - 1;
      if (n == 0) {
         if (!issparse) {
            mlpsetdataset(&trainer, &dds, n);
         } else {
            mlpsetsparsedataset(&trainer, &sds, n);
         }
      }
      mlpsetdecay(&trainer, vdecay);
      mlpsetcond(&trainer, traineps, trainits);
      if (randombool()) {
         mlptrainnetwork(&trainer, &net, nneedrest, &rep);
      } else {
         for (mlpstarttraining(&trainer, &net, true); mlpcontinuetraining(&trainer, &net); ) { }
      }
   // Check weights
      mlpproperties(&net, &nin, &nout, &wcount);
      for (c = 0; c < wcount; c++) {
         if (net.weights.xR[c] != 0.0) {
            Ok = false;
            ae_frame_leave();
            return Ok;
         }
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// This function tests that increasing numbers of restarts lead to statistical
// improvement quality of solution.
// Neural network created by Create1(10 neurons) and trained by MLPTrainLBFGS.
//
// TEST's DISCRIPTION:
//
// Net0   -   network trained with one restart (denoted as R1)
// Net1   -   network trained with more than one restart (denoted as Rn)
//
// We must refuse hypothesis that R1 equivalent to Rn.
// Here Mean = N/2, Sigma = sqrt(N)/2.
//       _
//      | 0   -   R1 worse than Rn;
// ri = |
//      |_1   -   Rn same or worse then R1.
//
// If Sum(ri) < Mean-5*Sigma then hypothesis is refused and test is passed.
// In another case if Mean-5*Sigma <= Sum(ri) <= Mean+5*Sigma then hypothesis
// is't refused and test is broken; and if Mean+5*Sigma < Sum(ri) then test
// broken too hard!
static bool testmlptrainunit_testmlprestarts() {
   ae_frame _frame_block;
   ae_int_t info;
   ae_int_t n;
   ae_int_t nneurons;
   double vdecay;
   ae_int_t wcount0;
   ae_int_t wcount1;
   ae_int_t nin;
   ae_int_t nout;
   double avval;
   double e0;
   double e1;
   double mean;
   double numsigma;
   ae_int_t numxp;
   double traineps;
   ae_int_t nneedrest;
   ae_int_t trainits;
   ae_int_t i;
   ae_int_t vtrain;
   ae_int_t xp;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net0);
   NewObj(multilayerperceptron, net1);
   NewObj(mlptrainer, trainer);
   NewObj(mlpreport, rep);
   NewObj(sparsematrix, sm);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   vdecay = 0.001;
   nneurons = 4;
   nneedrest = 3;
   traineps = 0.00;
   trainits = 2;
   n = 20;
   numxp = 400;
   ae_matrix_set_length(&xy, n, 2);
   ae_vector_set_length(&x, 1);
   sparsecreate(n, 2, n * 2, &sm);
   mean = numxp / 2.0;
   numsigma = 5.0 * sqrt(numxp) / 2.0;
   for (vtrain = 0; vtrain <= 2; vtrain++) {
      avval = 0.0;
      for (xp = 1; xp <= numxp; xp++) {
      // Create a train set
         for (i = 0; i < n; i++) {
            xy.xyR[i][0] = randommid();
            xy.xyR[i][1] = randommid();
         }
      // Create and train a neural network
         mlpcreate1(1, nneurons, 1, &net0);
         mlpcreate1(1, nneurons, 1, &net1);
         if (vtrain == 0) {
            mlptrainlbfgs(&net0, &xy, n, vdecay, 1, traineps, trainits, &info, &rep);
            mlptrainlbfgs(&net1, &xy, n, vdecay, nneedrest, traineps, trainits, &info, &rep);
         }
         if (vtrain == 1) {
            mlpcreatetrainer(1, 1, &trainer);
            mlpsetdataset(&trainer, &xy, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net0, 1, &rep);
            mlptrainnetwork(&trainer, &net1, nneedrest, &rep);
         }
         if (vtrain == 2) {
            for (i = 0; i < n; i++) {
               sparseset(&sm, i, 0, xy.xyR[i][0]);
               sparseset(&sm, i, 1, xy.xyR[i][1]);
            }
            mlpcreatetrainer(1, 1, &trainer);
            mlpsetsparsedataset(&trainer, &sm, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net0, 1, &rep);
            mlptrainnetwork(&trainer, &net1, nneedrest, &rep);
         }
      // Calculate errors for...
      //
      // ...for Net0, trained with 1 restart.
         mlpproperties(&net0, &nin, &nout, &wcount0);
         e0 = ae_v_dotproduct(net0.weights.xR, 1, net0.weights.xR, 1, wcount0);
         e0 = mlperrorn(&net0, &xy, n) + 0.5 * vdecay * e0;
      // ...for Net1, trained with NNeedRest > 1 restarts.
         mlpproperties(&net1, &nin, &nout, &wcount1);
         e1 = ae_v_dotproduct(net1.weights.xR, 1, net1.weights.xR, 1, wcount1);
         e1 = mlperrorn(&net1, &xy, n) + 0.5 * vdecay * e1;
         if (e0 <= e1) {
            avval++;
         }
      }
      if (mean - numsigma < avval) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// The function test function MLPKFoldCV.
static bool testmlptrainunit_testmlpcverror() {
   ae_frame _frame_block;
   ae_int_t nin;
   ae_int_t nout;
   ae_int_t nneurons;
   ae_int_t rowsz;
   double decay;
   double wstep;
   ae_int_t maxits;
   ae_int_t foldscount;
   ae_int_t nneedrest;
   ae_int_t npoints;
   ae_int_t ntstpoints;
   double mean;
   double numsigma;
   double diffms;
   double tstrelclserror;
   double tstavgce;
   double tstrmserror;
   double tstavgerror;
   double tstavgrelerror;
   ae_int_t r0;
   ae_int_t r1;
   ae_int_t r2;
   ae_int_t r3;
   ae_int_t r4;
   ae_int_t ntest;
   ae_int_t xp;
   ae_int_t nxp;
   bool isregr;
   ae_int_t issparse;
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net);
   NewObj(mlptrainer, trainer);
   NewObj(mlpreport, rep);
   NewObj(mlpreport, cvrep);
   NewObj(sparsematrix, sptrainingset);
   NewMatrix(trainingset, 0, 0, DT_REAL);
   NewMatrix(testset, 0, 0, DT_REAL);
   decay = 1.0E-6;
   wstep = 0.0;
   foldscount = 5;
   nneedrest = 1;
   ntest = randominteger(4);
   nxp = 1000;
   maxits = 50;
   nin = 1;
   nout = 1;
   npoints = 5;
   ntstpoints = 100;
   isregr = true;
   nneurons = 3;
   if (ntest == 1) {
      nxp = 1000;
      maxits = 50;
      nin = 1;
      nout = 10;
      npoints = 5;
      ntstpoints = 100;
      isregr = true;
   }
   if (ntest == 2) {
      nxp = 1000;
      maxits = 50;
      nin = 10;
      nout = 1;
      npoints = 20;
      ntstpoints = 100;
      isregr = true;
   }
   if (ntest == 3) {
      nxp = 2000;
      maxits = 10;
      nin = 1;
      nneurons = 3;
      nout = 3;
      npoints = 10;
      ntstpoints = 100;
      isregr = false;
   }
   mean = nxp / 2.0;
   numsigma = 5.0 * sqrt(nxp) / 2.0;
   diffms = mean - numsigma;
   issparse = randominteger(2);
   if (isregr) {
      mlpcreate0(nin, nout, &net);
      mlpcreatetrainer(nin, nout, &trainer);
   } else {
      mlpcreatec1(nin, nneurons, nout, &net);
      mlpcreatetrainercls(nin, nout, &trainer);
   }
   mlpsetcond(&trainer, wstep, maxits);
   mlpsetdecay(&trainer, decay);
   if (isregr) {
      rowsz = nin + nout;
   } else {
      rowsz = nin + 1;
   }
   r0 = 0;
   r1 = 0;
   r2 = 0;
   r3 = 0;
   r4 = 0;
   for (xp = 1; xp <= nxp; xp++) {
   // Dense matrix
      if (issparse == 0) {
         matrixsetlengthatleast(&trainingset, npoints, rowsz);
      // Create training set
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nin; j++) {
               trainingset.xyR[i][j] = randommid();
            }
         }
         if (isregr) {
            for (i = 0; i < npoints; i++) {
               for (j = nin; j < rowsz; j++) {
                  trainingset.xyR[i][j] = 2.0 * randomreal() + 1;
               }
            }
         } else {
            for (i = 0; i < npoints; i++) {
               for (j = nin; j < rowsz; j++) {
                  trainingset.xyR[i][j] = (double)randominteger(nout);
               }
            }
         }
         mlpsetdataset(&trainer, &trainingset, npoints);
      }
   // Sparse matrix
      if (issparse == 1) {
         sparsecreate(npoints, rowsz, npoints * rowsz, &sptrainingset);
      // Create training set
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nin; j++) {
               sparseset(&sptrainingset, i, j, randommid());
            }
         }
         if (isregr) {
            for (i = 0; i < npoints; i++) {
               for (j = nin; j < rowsz; j++) {
                  sparseset(&sptrainingset, i, j, 2.0 * randomreal() + 1);
               }
            }
         } else {
            for (i = 0; i < npoints; i++) {
               for (j = nin; j < rowsz; j++) {
                  sparseset(&sptrainingset, i, j, (double)randominteger(nout));
               }
            }
         }
         sparseconverttocrs(&sptrainingset);
         mlpsetsparsedataset(&trainer, &sptrainingset, npoints);
      }
      matrixsetlengthatleast(&testset, ntstpoints, rowsz);
   // Create test set
      for (i = 0; i < ntstpoints; i++) {
         for (j = 0; j < nin; j++) {
            testset.xyR[i][j] = randommid();
         }
      }
      if (isregr) {
         for (i = 0; i < ntstpoints; i++) {
            for (j = nin; j < rowsz; j++) {
               testset.xyR[i][j] = 2.0 * randomreal() + 1;
            }
         }
      } else {
         for (i = 0; i < ntstpoints; i++) {
            for (j = nin; j < rowsz; j++) {
               testset.xyR[i][j] = (double)randominteger(nout);
            }
         }
      }
      mlptrainnetwork(&trainer, &net, nneedrest, &rep);
      tstrelclserror = 0.0;
      tstavgce = 0.0;
      tstrmserror = 0.0;
      tstavgerror = 0.0;
      tstavgrelerror = 0.0;
      if (!isregr) {
         tstrelclserror = mlprelclserror(&net, &testset, ntstpoints);
         tstavgce = mlpavgce(&net, &testset, ntstpoints);
      }
      tstrmserror = mlprmserror(&net, &testset, ntstpoints);
      tstavgerror = mlpavgerror(&net, &testset, ntstpoints);
      tstavgrelerror = mlpavgrelerror(&net, &testset, ntstpoints);
   // Cross-validation
      mlpkfoldcv(&trainer, &net, nneedrest, foldscount, &cvrep);
      if (!isregr) {
         if (fabs(tstrelclserror - rep.relclserror) < fabs(tstrelclserror - cvrep.relclserror)) {
            r0++;
         }
         if (fabs(tstavgce - rep.avgce) < fabs(tstavgce - cvrep.avgce)) {
            r1++;
         }
      }
      if (fabs(tstrmserror - rep.rmserror) < fabs(tstrmserror - cvrep.rmserror)) {
         r2++;
      }
      if (fabs(tstavgerror - rep.avgerror) < fabs(tstavgerror - cvrep.avgerror)) {
         r3++;
      }
      if (fabs(tstavgrelerror - rep.avgrelerror) < fabs(tstavgrelerror - cvrep.avgrelerror)) {
         r4++;
      }
   }
   if (!isregr) {
      if (diffms <= r0 || diffms <= r1) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   if (diffms <= r2 || diffms <= r3 || diffms <= r4) {
      Ok = false;
      ae_frame_leave();
      return Ok;
   }
// Test FoldCV when  no dataset  was specified with
// MLPSetDataset/SetSparseDataset(), or subset with
// only one point  was  given.
//
// NPoints values:
// * -1 - don't set dataset with using MLPSetDataset..;
// *  0 - zero dataset;
// *  1 - dataset with one point.
   for (npoints = -1; npoints <= 1; npoints++) {
      if (isregr) {
         mlpcreatetrainer(nin, nout, &trainer);
      } else {
         mlpcreatetrainercls(nin, nout, &trainer);
      }
      if (npoints > -1) {
         if (issparse == 0) {
            mlpsetdataset(&trainer, &trainingset, npoints);
         }
         if (issparse == 1) {
            mlpsetsparsedataset(&trainer, &sptrainingset, npoints);
         }
      }
      mlpkfoldcv(&trainer, &net, nneedrest, foldscount, &cvrep);
      if (cvrep.relclserror != 0.0 || cvrep.avgce != 0.0 || cvrep.rmserror != 0.0 || cvrep.avgerror != 0.0 || cvrep.avgrelerror != 0.0 || cvrep.ngrad != 0 || cvrep.nhess != 0 || cvrep.ncholesky != 0) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

// The  function  tests  functions  for  training  ensembles:  MLPEBaggingLM,
// MLPEBaggingLBFGS.
static bool testmlptrainunit_testmlptrainens() {
   ae_frame _frame_block;
   ae_int_t info;
   ae_int_t nin;
   ae_int_t nout;
   ae_int_t npoints;
   ae_int_t nhid;
   ae_int_t algtype;
   ae_int_t tasktype;
   ae_int_t pass;
   double e;
   ae_int_t nless;
   ae_int_t nall;
   ae_int_t nclasses;
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(mlpensemble, ensemble);
   NewObj(mlpreport, rep);
   NewObj(mlpcvreport, oobrep);
   NewMatrix(xy, 0, 0, DT_REAL);
   Ok = true;
// network training must reduce error
// test on random regression task
   nin = 3;
   nout = 2;
   nhid = 5;
   npoints = 100;
   nless = 0;
   nall = 0;
   for (pass = 1; pass <= 10; pass++) {
      for (algtype = 0; algtype <= 1; algtype++) {
         for (tasktype = 0; tasktype <= 1; tasktype++) {
            if (tasktype == 0) {
               ae_matrix_set_length(&xy, npoints, nin + nout);
               for (i = 0; i < npoints; i++) {
                  for (j = 0; j < nin + nout; j++) {
                     xy.xyR[i][j] = randommid();
                  }
               }
               mlpecreate1(nin, nhid, nout, 1 + randominteger(3), &ensemble);
            } else {
               ae_matrix_set_length(&xy, npoints, nin + 1);
               nclasses = 2 + randominteger(2);
               for (i = 0; i < npoints; i++) {
                  for (j = 0; j < nin; j++) {
                     xy.xyR[i][j] = randommid();
                  }
                  xy.xyR[i][nin] = (double)randominteger(nclasses);
               }
               mlpecreatec1(nin, nhid, nclasses, 1 + randominteger(3), &ensemble);
            }
            e = mlpermserror(&ensemble, &xy, npoints);
            if (algtype == 0) {
               mlpebagginglm(&ensemble, &xy, npoints, 0.001, 1, &info, &rep, &oobrep);
            } else {
               mlpebagginglbfgs(&ensemble, &xy, npoints, 0.001, 1, 0.01, 0, &info, &rep, &oobrep);
            }
            if (info < 0) {
               Ok = false;
            } else {
               if (mlpermserror(&ensemble, &xy, npoints) < e) {
                  nless++;
               }
            }
            nall++;
         }
      }
   }
   Ok = Ok && nall - nless <= 0.3 * nall;
   ae_frame_leave();
   return Ok;
}

// Testing  for  functions  MLPETrainES and MLPTrainEnsembleES  on regression
// problems.
static bool testmlptrainunit_testmlptrainensregr() {
   ae_frame _frame_block;
   ae_int_t info;
   ae_int_t nin;
   ae_int_t nout;
   ae_int_t nneurons;
   double decay;
   double wstep;
   ae_int_t maxits;
   ae_int_t nneedrest;
   ae_int_t enssize;
   double mnval;
   double mxval;
   ae_int_t ntrain;
   ae_int_t ntest;
   double avgerr;
   ae_int_t issparse;
   ae_int_t withtrainer;
   double eps;
   ae_int_t xp;
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(mlptrainer, trainer);
   NewObj(mlpensemble, netens);
   NewObj(mlpreport, rep);
   NewObj(modelerrors, repx);
   NewObj(sparsematrix, xytrainsp);
   NewMatrix(xytrain, 0, 0, DT_REAL);
   NewMatrix(xytest, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   Ok = true;
// This test checks ability to train ensemble on simple regression
// problem "f(x0,x1,x2,...) = x0 + x1 + x2 + ...".
   eps = 5.0E-2;
   mnval = -1.0;
   mxval = 1.0;
   ntrain = 40;
   ntest = 20;
   decay = 1.0E-3;
   wstep = 1.0E-3;
   maxits = 20;
   nneedrest = 1;
   nneurons = 20;
   nout = 1;
   enssize = 100;
   for (xp = 1; xp <= 2; xp++) {
      nin = randominteger(3) + 1;
      vectorsetlengthatleast(&x, nin);
      mlpcreatetrainer(nin, nout, &trainer);
      mlpsetdecay(&trainer, decay);
      mlpsetcond(&trainer, wstep, maxits);
      matrixsetlengthatleast(&xytrain, ntrain, nin + nout);
      matrixsetlengthatleast(&xytest, ntest, nin + nout);
      withtrainer = randominteger(2);
      issparse = 0;
      if (withtrainer == 0) {
         issparse = 0;
      }
      if (withtrainer == 1) {
         issparse = randominteger(2);
      }
   // Training set
      for (i = 0; i < ntrain; i++) {
         for (j = 0; j < nin; j++) {
            xytrain.xyR[i][j] = (mxval - mnval) * randomreal() + mnval;
         }
         xytrain.xyR[i][nin] = 0.0;
         for (j = 0; j < nin; j++) {
            xytrain.xyR[i][nin] += xytrain.xyR[i][j];
         }
      }
      if (withtrainer == 1) {
      // Dense matrix
         if (issparse == 0) {
            mlpsetdataset(&trainer, &xytrain, ntrain);
         }
      // Sparse matrix
         if (issparse == 1) {
            sparsecreate(ntrain, nin + nout, ntrain * (nin + nout), &xytrainsp);
         // Just copy dense matrix to sparse matrix(using SparseGet() is too expensive).
            for (i = 0; i < ntrain; i++) {
               for (j = 0; j < nin + nout; j++) {
                  sparseset(&xytrainsp, i, j, xytrain.xyR[i][j]);
               }
            }
            sparseconverttocrs(&xytrainsp);
            mlpsetsparsedataset(&trainer, &xytrainsp, ntrain);
         }
      }
   // Test set
      for (i = 0; i < ntest; i++) {
         for (j = 0; j < nin; j++) {
            xytest.xyR[i][j] = (mxval - mnval) * randomreal() + mnval;
         }
         xytest.xyR[i][nin] = 0.0;
         for (j = 0; j < nin; j++) {
            xytest.xyR[i][nin] += xytest.xyR[i][j];
         }
      }
   // Create ensemble
      mlpecreate1(nin, nneurons, nout, enssize, &netens);
   // Train ensembles:
   // * without trainer;
      if (withtrainer == 0) {
         mlpetraines(&netens, &xytrain, ntrain, decay, nneedrest, &info, &rep);
      }
   // * with trainer.
      if (withtrainer == 1) {
         mlptrainensemblees(&trainer, &netens, nneedrest, &rep);
      }
   // Test that Rep contains correct error values
      mlpeallerrorsx(&netens, &xytrain, &xytrainsp, ntrain, 0, &netens.network.dummyidx, 0, ntrain, 0, &netens.network.buf, &repx);
      Ok = Ok && RelNear(rep.relclserror, repx.relclserror, 1.0E-4, 1.0E-2);
      Ok = Ok && RelNear(rep.avgce, repx.avgce, 1.0E-4, 1.0E-2);
      Ok = Ok && RelNear(rep.rmserror, repx.rmserror, 1.0E-4, 1.0E-2);
      Ok = Ok && RelNear(rep.avgerror, repx.avgerror, 1.0E-4, 1.0E-2);
      Ok = Ok && RelNear(rep.avgrelerror, repx.avgrelerror, 1.0E-4, 1.0E-2);
   // Test that network fits data well. Calculate average error:
   // * on training dataset;
   // * on test dataset. (here we reduce the accuracy
   //   requirements - average error is compared with 2*Eps).
      avgerr = 0.0;
      for (i = 0; i < ntrain; i++) {
         if (issparse == 0) {
            ae_v_move(x.xR, 1, xytrain.xyR[i], 1, nin);
         }
         if (issparse == 1) {
            sparsegetrow(&xytrainsp, i, &x);
         }
         mlpeprocess(&netens, &x, &y);
         avgerr += fabs(y.xR[0] - xytrain.xyR[i][nin]);
      }
      avgerr /= ntrain;
      Ok = Ok && avgerr <= eps;
      avgerr = 0.0;
      for (i = 0; i < ntest; i++) {
         ae_v_move(x.xR, 1, xytest.xyR[i], 1, nin);
         mlpeprocess(&netens, &x, &y);
         avgerr += fabs(y.xR[0] - xytest.xyR[i][nin]);
      }
      avgerr /= ntest;
      Ok = Ok && avgerr <= 2 * eps;
   }
// Catch bug in implementation of MLPTrainEnsembleX:
// test ensemble training on empty dataset.
//
// Unfixed version should crash with violation of array
// bounds (at least in C#).
   nin = 2;
   nout = 2;
   nneurons = 3;
   enssize = 3;
   nneedrest = 2;
   wstep = 0.001;
   maxits = 2;
   mlpcreatetrainer(nin, nout, &trainer);
   mlpsetcond(&trainer, wstep, maxits);
   mlpecreate1(nin, nneurons, nout, enssize, &netens);
   mlptrainensemblees(&trainer, &netens, nneedrest, &rep);
   ae_frame_leave();
   return Ok;
}

// Testing for functions MLPETrainES and MLPTrainEnsembleES on classification
// problems.
static bool testmlptrainunit_testmlptrainenscls() {
   ae_frame _frame_block;
   ae_int_t info;
   ae_int_t nin;
   ae_int_t nout;
   double decay;
   double wstep;
   ae_int_t maxits;
   ae_int_t nneedrest;
   ae_int_t enssize;
   ae_int_t val;
   ae_int_t ntrain;
   ae_int_t ntest;
   double avgerr;
   double eps;
   double delta;
   ae_int_t issparse;
   ae_int_t withtrainer;
   ae_int_t xp;
   ae_int_t nxp;
   ae_int_t i;
   ae_int_t j;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(mlptrainer, trainer);
   NewObj(mlpensemble, netens);
   NewObj(mlpreport, rep);
   NewObj(sparsematrix, xytrainsp);
   NewMatrix(xytrain, 0, 0, DT_REAL);
   NewMatrix(xytest, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   eps = 5.0E-2;
   delta = 0.1;
   ntrain = 90;
   ntest = 90;
   nin = 3;
   nout = 3;
   vectorsetlengthatleast(&x, nin);
   matrixsetlengthatleast(&xytrain, ntrain, nin + 1);
   matrixsetlengthatleast(&xytest, ntest, nin + 1);
   decay = 1.0E-3;
   wstep = 1.0E-3;
   maxits = 100;
   nneedrest = 1;
   mlpcreatetrainercls(nin, nout, &trainer);
   mlpsetdecay(&trainer, decay);
   mlpsetcond(&trainer, wstep, maxits);
   nxp = 5;
   for (xp = 1; xp <= nxp; xp++) {
      enssize = iround(pow(10.0, (double)(randominteger(2) + 1)));
      withtrainer = randominteger(2);
      issparse = 0;
      if (withtrainer == 0) {
         issparse = 0;
      }
      if (withtrainer == 1) {
         issparse = randominteger(2);
      }
      for (i = 0; i < ntrain; i++) {
         val = i % nin;
         for (j = 0; j < nin; j++) {
            xytrain.xyR[i][j] = delta * (randomreal() - 1);
         }
         xytrain.xyR[i][val]++;
         xytrain.xyR[i][nin] = (double)val;
      }
   // Set dense dataset in trainer
      if (issparse == 0) {
         mlpsetdataset(&trainer, &xytrain, ntrain);
      }
   // * Sparse dataset(create it with using dense dataset).
      if (issparse == 1) {
         sparsecreate(ntrain, nin + 1, ntrain * (nin + 1), &xytrainsp);
         for (i = 0; i < ntrain; i++) {
            for (j = 0; j < nin; j++) {
               sparseset(&xytrainsp, i, j, xytrain.xyR[i][j]);
            }
            sparseset(&xytrainsp, i, nin, xytrain.xyR[i][nin]);
         }
         sparseconverttocrs(&xytrainsp);
      // Set sparse dataset in trainer
         mlpsetsparsedataset(&trainer, &xytrainsp, ntrain);
      }
   // Create test set
      for (i = 0; i < ntest; i++) {
         val = randominteger(nin);
         for (j = 0; j < nin; j++) {
            xytest.xyR[i][j] = delta * (randomreal() - 1);
         }
         xytest.xyR[i][val]++;
         xytest.xyR[i][nin] = (double)val;
      }
   // Create ensemble
      mlpecreatec0(nin, nout, enssize, &netens);
   // Train ensembles:
   // * without trainer;
      if (withtrainer == 0) {
         mlpetraines(&netens, &xytrain, ntrain, decay, nneedrest, &info, &rep);
      }
   // * with trainer.
      if (withtrainer == 1) {
         mlptrainensemblees(&trainer, &netens, nneedrest, &rep);
      }
   // Calculate average error:
   // * on training dataset;
      avgerr = 0.0;
      for (i = 0; i < ntrain; i++) {
         if (issparse == 0) {
            ae_v_move(x.xR, 1, xytrain.xyR[i], 1, nin);
         }
         if (issparse == 1) {
            sparsegetrow(&xytrainsp, i, &x);
         }
         mlpeprocess(&netens, &x, &y);
         for (j = 0; j < nout; j++) {
            if (j != xytrain.xyR[i][nin]) {
               avgerr += y.xR[j];
            } else {
               avgerr += 1 - y.xR[j];
            }
         }
      }
      avgerr /= ntrain * nout;
      if (avgerr > eps) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   // * on test dataset.
      avgerr = 0.0;
      for (i = 0; i < ntest; i++) {
         ae_v_move(x.xR, 1, xytest.xyR[i], 1, nin);
         mlpeprocess(&netens, &x, &y);
         for (j = 0; j < nout; j++) {
            if (j != xytest.xyR[i][nin]) {
               avgerr += y.xR[j];
            } else {
               avgerr += 1 - y.xR[j];
            }
         }
      }
      avgerr /= ntest * nout;
      if (avgerr > eps) {
         Ok = false;
         ae_frame_leave();
         return Ok;
      }
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

bool testmlptrain() {
   ae_frame _frame_block;
   bool Ok;
   ae_int_t info;
   bool trnOk;
   bool mlpcverrorOk;
   bool mlptrainregrOk;
   bool mlptrainclassOk;
   bool mlprestartsOk;
   bool mlpxorregrOk;
   bool mlpxorclsOk;
   bool mlptrainensOk;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewObj(multilayerperceptron, network2);
   NewObj(mlpreport, rep);
   NewObj(mlpcvreport, cvrep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(valxy, 0, 0, DT_REAL);
   Ok = true;
   trnOk = true;
   mlpcverrorOk = true;
   mlptrainregrOk = true;
   mlptrainclassOk = true;
   mlprestartsOk = true;
   mlpxorregrOk = true;
   mlpxorclsOk = true;
   mlptrainensOk = true;
// Test network training on simple XOR problem
   ae_matrix_set_length(&xy, 3 + 1, 2 + 1);
   xy.xyR[0][0] = -1.0;
   xy.xyR[0][1] = -1.0;
   xy.xyR[0][2] = -1.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[1][1] = -1.0;
   xy.xyR[1][2] = 1.0;
   xy.xyR[2][0] = -1.0;
   xy.xyR[2][1] = 1.0;
   xy.xyR[2][2] = 1.0;
   xy.xyR[3][0] = 1.0;
   xy.xyR[3][1] = 1.0;
   xy.xyR[3][2] = -1.0;
   mlpcreate1(2, 2, 1, &network);
   mlptrainlm(&network, &xy, 4, 0.001, 10, &info, &rep);
   trnOk = trnOk && mlprmserror(&network, &xy, 4) <= 0.1;
// Test early stopping
   trnOk = trnOk && testmlptrainunit_testmlptraines();
// Test for function MLPFoldCV()
   mlpcverrorOk = testmlptrainunit_testmlpcverror();
// Test for training functions
   mlptrainregrOk = testmlptrainunit_testmlptrainregr() && testmlptrainunit_testmlpzeroweights();
   mlptrainclassOk = testmlptrainunit_testmlptrainclass();
   mlprestartsOk = testmlptrainunit_testmlprestarts();
   mlpxorregrOk = testmlptrainunit_testmlpxorregr();
   mlpxorclsOk = testmlptrainunit_testmlpxorcls();
// Training for ensembles
   mlptrainensOk = testmlptrainunit_testmlptrainens() && testmlptrainunit_testmlptrainensregr() && testmlptrainunit_testmlptrainenscls();
// The final report.
   Ok = trnOk && mlptrainregrOk && mlptrainclassOk && mlprestartsOk && mlpxorregrOk && mlpxorclsOk && mlpcverrorOk && mlptrainensOk;
   if (!Ok || !silent) {
      printf("MLP Tests\n");
      printf("Cross-Validation Errors:                  %s\n", mlpcverrorOk? "Ok": "Failed");
      printf("Training:                                 %s\n", trnOk? "Ok": "Failed");
      printf("Train -LM -LBFGS For Regression:          %s\n", mlptrainregrOk? "Ok": "Failed");
      printf("Train -LM -LBFGS For Classifier:          %s\n", mlptrainclassOk? "Ok": "Failed");
      printf("Parameter Restarts In Train - LBFGS:      %s\n", mlprestartsOk? "Ok": "Failed");
      printf("Training With Trainer For Regression:     %s\n", mlpxorregrOk? "Ok": "Failed");
      printf("Training With Trainer For Classifier:     %s\n", mlpxorclsOk? "Ok": "Failed");
      printf("Training Ensembles:                       %s\n", mlptrainensOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// === alglibbasics testing unit ===
struct rec4serialization {
   ae_vector b;
   ae_vector i;
   ae_vector r;
};

static void rec4serialization_init(void *_p, bool make_automatic) {
   rec4serialization *p = (rec4serialization *)_p;
   ae_vector_init(&p->b, 0, DT_BOOL, make_automatic);
   ae_vector_init(&p->i, 0, DT_INT, make_automatic);
   ae_vector_init(&p->r, 0, DT_REAL, make_automatic);
}

static void rec4serialization_copy(void *_dst, void *_src, bool make_automatic) {
   rec4serialization *dst = (rec4serialization *)_dst;
   rec4serialization *src = (rec4serialization *)_src;
   ae_vector_copy(&dst->b, &src->b, make_automatic);
   ae_vector_copy(&dst->i, &src->i, make_automatic);
   ae_vector_copy(&dst->r, &src->r, make_automatic);
}

static void rec4serialization_free(void *_p, bool make_automatic) {
   rec4serialization *p = (rec4serialization *)_p;
   ae_vector_free(&p->b, make_automatic);
   ae_vector_free(&p->i, make_automatic);
   ae_vector_free(&p->r, make_automatic);
}

static void rec4serializationalloc(ae_serializer *s, rec4serialization *v) {
   ae_int_t i;
// boolean fields
   ae_serializer_alloc_entry(s);
   for (i = 0; i < v->b.cnt; i++) {
      ae_serializer_alloc_entry(s);
   }
// integer fields
   ae_serializer_alloc_entry(s);
   for (i = 0; i < v->i.cnt; i++) {
      ae_serializer_alloc_entry(s);
   }
// real fields
   ae_serializer_alloc_entry(s);
   for (i = 0; i < v->r.cnt; i++) {
      ae_serializer_alloc_entry(s);
   }
}

static void rec4serializationserialize(ae_serializer *s, rec4serialization *v) {
   ae_int_t i;
// boolean fields
   ae_serializer_serialize_int(s, v->b.cnt);
   for (i = 0; i < v->b.cnt; i++) {
      ae_serializer_serialize_bool(s, v->b.xB[i]);
   }
// integer fields
   ae_serializer_serialize_int(s, v->i.cnt);
   for (i = 0; i < v->i.cnt; i++) {
      ae_serializer_serialize_int(s, v->i.xZ[i]);
   }
// real fields
   ae_serializer_serialize_int(s, v->r.cnt);
   for (i = 0; i < v->r.cnt; i++) {
      ae_serializer_serialize_double(s, v->r.xR[i]);
   }
}

static void rec4serializationunserialize(ae_serializer *s, rec4serialization *v) {
   ae_int_t i;
   ae_int_t k;
   SetObj(rec4serialization, v);
// boolean fields
   k = ae_serializer_unserialize_int(s);
   if (k > 0) {
      ae_vector_set_length(&v->b, k);
      for (i = 0; i < k; i++) {
         v->b.xB[i] = ae_serializer_unserialize_bool(s);
      }
   }
// integer fields
   k = ae_serializer_unserialize_int(s);
   if (k > 0) {
      ae_vector_set_length(&v->i, k);
      for (i = 0; i < k; i++) {
         v->i.xZ[i] = ae_serializer_unserialize_int(s);
      }
   }
// real fields
   k = ae_serializer_unserialize_int(s);
   if (k > 0) {
      ae_vector_set_length(&v->r, k);
      for (i = 0; i < k; i++) {
         v->r.xR[i] = ae_serializer_unserialize_double(s);
      }
   }
}

struct poolrec1 {
   complex cval;
   double rval;
   ae_int_t ival;
   bool bval;
   ae_vector i1val;
};

static void poolrec1_init(void *_p, bool make_automatic) {
   poolrec1 *p = (poolrec1 *)_p;
   ae_vector_init(&p->i1val, 0, DT_INT, make_automatic);
}

static void poolrec1_copy(void *_dst, void *_src, bool make_automatic) {
   poolrec1 *dst = (poolrec1 *)_dst;
   poolrec1 *src = (poolrec1 *)_src;
   dst->cval = src->cval;
   dst->rval = src->rval;
   dst->ival = src->ival;
   dst->bval = src->bval;
   ae_vector_copy(&dst->i1val, &src->i1val, make_automatic);
}

static void poolrec1_free(void *_p, bool make_automatic) {
   poolrec1 *p = (poolrec1 *)_p;
   ae_vector_free(&p->i1val, make_automatic);
}

struct poolrec2 {
   bool bval;
   poolrec1 recval;
   ae_shared_pool pool;
};

static void poolrec2_init(void *_p, bool make_automatic) {
   poolrec2 *p = (poolrec2 *)_p;
   poolrec1_init(&p->recval, make_automatic);
   ae_shared_pool_init(&p->pool, make_automatic);
}

static void poolrec2_copy(void *_dst, void *_src, bool make_automatic) {
   poolrec2 *dst = (poolrec2 *)_dst;
   poolrec2 *src = (poolrec2 *)_src;
   dst->bval = src->bval;
   poolrec1_copy(&dst->recval, &src->recval, make_automatic);
   ae_shared_pool_copy(&dst->pool, &src->pool, make_automatic);
}

static void poolrec2_free(void *_p, bool make_automatic) {
   poolrec2 *p = (poolrec2 *)_p;
   poolrec1_free(&p->recval, make_automatic);
   ae_shared_pool_free(&p->pool, make_automatic);
}

struct poolsummand {
   ae_int_t val;
};

static void poolsummand_init(void *_p, bool make_automatic) {
}

static void poolsummand_copy(void *_dst, void *_src, bool make_automatic) {
   poolsummand *dst = (poolsummand *)_dst;
   poolsummand *src = (poolsummand *)_src;
   dst->val = src->val;
}

static void poolsummand_free(void *_p, bool make_automatic) {
}

// Tests for pool functions
static void testalglibbasicsunit_createpoolandrecords(poolrec2 *seedrec2, poolrec2 *seedrec2copy, ae_shared_pool *pool) {
   SetObj(poolrec2, seedrec2);
   SetObj(poolrec2, seedrec2copy);
   SetObj(ae_shared_pool, pool);
   seedrec2->bval = randombool();
   seedrec2->recval.bval = randombool();
   seedrec2->recval.ival = randominteger(10);
   seedrec2->recval.rval = randomreal();
   seedrec2->recval.cval = complex_from_d(randomreal(), randomreal());
   ae_vector_set_length(&seedrec2->recval.i1val, 3);
   seedrec2->recval.i1val.xZ[0] = randominteger(10);
   seedrec2->recval.i1val.xZ[1] = randominteger(10);
   seedrec2->recval.i1val.xZ[2] = randominteger(10);
   seedrec2copy->bval = seedrec2->bval;
   seedrec2copy->recval.bval = seedrec2->recval.bval;
   seedrec2copy->recval.ival = seedrec2->recval.ival;
   seedrec2copy->recval.rval = seedrec2->recval.rval;
   seedrec2copy->recval.cval = seedrec2->recval.cval;
   ae_vector_set_length(&seedrec2copy->recval.i1val, 3);
   seedrec2copy->recval.i1val.xZ[0] = seedrec2->recval.i1val.xZ[0];
   seedrec2copy->recval.i1val.xZ[1] = seedrec2->recval.i1val.xZ[1];
   seedrec2copy->recval.i1val.xZ[2] = seedrec2->recval.i1val.xZ[2];
   ae_shared_pool_set_seed(pool, seedrec2, sizeof(*seedrec2), poolrec2_init, poolrec2_copy, poolrec2_free);
}

static bool testalglibbasicsunit_sharedpoolerrors() {
   ae_frame _frame_block;
   ae_int_t val100cnt;
   ae_int_t val101cnt;
   ae_int_t val102cnt;
   ae_int_t tmpval;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(poolrec1, seedrec1);
   NewObj(poolrec2, seedrec2);
   NewObj(poolrec2, seedrec2copy);
   NewObj(ae_shared_pool, pool);
   NewObj(ae_shared_pool, pool2);
   RefObj(poolrec2, prec2);
   RefObj(poolrec2, p0);
   RefObj(poolrec2, p1);
   RefObj(poolrec2, p2);
   RefObj(poolrec1, q0);
   RefObj(poolrec1, q1);
   RefObj(ae_shared_pool, ppool0);
   RefObj(ae_shared_pool, ppool1);
   Ok = false;
// Test 1: test that:
// a) smart pointer is null by default
// b) "conventional local" is valid by default
// b) unitinitialized shared pool is "not initialized"
   if (prec2 != NULL) {
      ae_frame_leave();
      return Ok;
   }
   if (&seedrec1 == NULL) {
      ae_frame_leave();
      return Ok;
   }
   if (ae_shared_pool_is_initialized(&pool)) {
      ae_frame_leave();
      return Ok;
   }
// Test 2: basic copying of complex structures
// * check that pool is recognized as "initialized"
// * change original seed record,
// * retrieve value from pool,
// * check that it is valid
// * and it is unchanged.
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   if (!ae_shared_pool_is_initialized(&pool)) {
      ae_frame_leave();
      return Ok;
   }
   seedrec2.bval = !seedrec2.bval;
   seedrec2.recval.i1val.xZ[0]++;
   ae_shared_pool_retrieve(&pool, &_prec2);
   if (prec2 == NULL) {
      ae_frame_leave();
      return Ok;
   }
   if (seedrec2copy.bval != prec2->bval) {
      ae_frame_leave();
      return Ok;
   }
   if (seedrec2copy.recval.i1val.xZ[0] != prec2->recval.i1val.xZ[0]) {
      ae_frame_leave();
      return Ok;
   }
// Test 3: unrecycled values are lost
// * retrieve value from pool,
// * change it,
// * retrieve one more time,
// * check that it is unchanged.
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   ae_shared_pool_retrieve(&pool, &_prec2);
   prec2->recval.ival++;
   ae_shared_pool_retrieve(&pool, &_prec2);
   if (prec2->recval.ival != seedrec2copy.recval.ival) {
      ae_frame_leave();
      return Ok;
   }
// Test 4: recycled values are reused, PoolClearRecycled() removes recycled values
// * retrieve value from pool,
// * change it,
// * recycle,
// * check that recycled pointer is null
// * retrieve one more time,
// * check that modified value was returned,
// * recycle,
// * clear pool,
// * retrieve one more time,
// * check that unmodified value was returned,
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   ae_shared_pool_retrieve(&pool, &_prec2);
   prec2->recval.ival++;
   ae_shared_pool_recycle(&pool, &_prec2);
   if (prec2 != NULL) {
      ae_frame_leave();
      return Ok;
   }
   ae_shared_pool_retrieve(&pool, &_prec2);
   if (prec2 == NULL) {
      ae_frame_leave();
      return Ok;
   }
   if (prec2->recval.ival != seedrec2copy.recval.ival + 1) {
      ae_frame_leave();
      return Ok;
   }
   ae_shared_pool_recycle(&pool, &_prec2);
   ae_shared_pool_clear_recycled(&pool, true);
   ae_shared_pool_retrieve(&pool, &_prec2);
   if (prec2 == NULL) {
      ae_frame_leave();
      return Ok;
   }
   if (prec2->recval.ival != seedrec2copy.recval.ival) {
      ae_frame_leave();
      return Ok;
   }
// Test 5: basic enumeration
// * retrieve 3 values from pool
// * fill RecVal.iVal by 100, 101, 102
// * recycle values
// * enumerate, check that each iVal occurs only once during enumeration
// * repeat enumeration to make sure that it can be repeated
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   ae_shared_pool_retrieve(&pool, &_p0);
   ae_shared_pool_retrieve(&pool, &_p1);
   ae_shared_pool_retrieve(&pool, &_p2);
   p0->recval.ival = 100;
   p1->recval.ival = 101;
   p2->recval.ival = 102;
   ae_shared_pool_recycle(&pool, &_p1);
   ae_shared_pool_recycle(&pool, &_p2);
   ae_shared_pool_recycle(&pool, &_p0);
   val100cnt = 0;
   val101cnt = 0;
   val102cnt = 0;
   for (ae_shared_pool_first_recycled(&pool, &_prec2); prec2 != NULL; ae_shared_pool_next_recycled(&pool, &_prec2)) {
      if (prec2->recval.ival == 100) {
         val100cnt++;
      }
      if (prec2->recval.ival == 101) {
         val101cnt++;
      }
      if (prec2->recval.ival == 102) {
         val102cnt++;
      }
   }
   if (val100cnt != 1 || val101cnt != 1 || val102cnt != 1) {
      ae_frame_leave();
      return Ok;
   }
   val100cnt = 0;
   val101cnt = 0;
   val102cnt = 0;
   for (ae_shared_pool_first_recycled(&pool, &_prec2); prec2 != NULL; ae_shared_pool_next_recycled(&pool, &_prec2)) {
      if (prec2->recval.ival == 100) {
         val100cnt++;
      }
      if (prec2->recval.ival == 101) {
         val101cnt++;
      }
      if (prec2->recval.ival == 102) {
         val102cnt++;
      }
   }
   if (val100cnt != 1 || val101cnt != 1 || val102cnt != 1) {
      ae_frame_leave();
      return Ok;
   }
// Test 6: pool itself can be pooled
// * pool can be seeded with another pool
// * smart pointers to pool are correctly handled
// * pool correctly returns different references on "retrieve":
//   * we retrieve, modify and recycle back to PPool0
//   * we retrieve from PPool1 - unmodified value is returned
//   * we retrievefrom PPool0  - modified value is returned
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   ae_shared_pool_set_seed(&pool2, &pool, sizeof(pool), ae_shared_pool_init, ae_shared_pool_copy, ae_shared_pool_free);
   if (ppool0 != NULL || ppool1 != NULL) {
      ae_frame_leave();
      return Ok;
   }
   ae_shared_pool_retrieve(&pool2, &_ppool0);
   ae_shared_pool_retrieve(&pool2, &_ppool1);
   if (ppool0 == NULL || ppool1 == NULL) {
      ae_frame_leave();
      return Ok;
   }
   ae_shared_pool_retrieve(ppool0, &_p0);
   p0->recval.ival++;
   tmpval = p0->recval.ival;
   ae_shared_pool_recycle(ppool0, &_p0);
   ae_shared_pool_retrieve(ppool1, &_p1);
   if (p1->recval.ival == tmpval) {
      ae_frame_leave();
      return Ok;
   }
   ae_shared_pool_recycle(ppool1, &_p1);
   ae_shared_pool_retrieve(ppool0, &_p0);
   if (p0->recval.ival != tmpval) {
      ae_frame_leave();
      return Ok;
   }
// Test 7: pools which are fields of records are correctly handled
// * pool can be seeded with record which has initialized pool as its field
// * when record is retrieved from pool, its fields are correctly copied (including
//   fields which are pools)
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   tmpval = 99;
   seedrec1.ival = tmpval;
   ae_shared_pool_set_seed(&seedrec2.pool, &seedrec1, sizeof(seedrec1), poolrec1_init, poolrec1_copy, poolrec1_free);
   ae_shared_pool_set_seed(&pool, &seedrec2, sizeof(seedrec2), poolrec2_init, poolrec2_copy, poolrec2_free);
   ae_shared_pool_retrieve(&pool, &_p0);
   ae_shared_pool_retrieve(&p0->pool, &_q0);
   q0->ival = tmpval - 1;
   ae_shared_pool_recycle(&p0->pool, &_q0);
   ae_shared_pool_retrieve(&pool, &_p1);
   ae_shared_pool_retrieve(&p1->pool, &_q1);
   if (q1->ival != tmpval) {
      ae_frame_leave();
      return Ok;
   }
   ae_shared_pool_recycle(&p1->pool, &_q1);
   ae_shared_pool_retrieve(&p0->pool, &_q0);
   if (q0->ival != tmpval - 1) {
      ae_frame_leave();
      return Ok;
   }
// Test 8: after call to PoolReset(), call to PoolFirstRecycled() returns null references
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   ae_shared_pool_retrieve(&pool, &_p0);
   ae_shared_pool_retrieve(&pool, &_p1);
   ae_shared_pool_retrieve(&pool, &_p2);
   ae_shared_pool_recycle(&pool, &_p1);
   ae_shared_pool_recycle(&pool, &_p2);
   ae_shared_pool_recycle(&pool, &_p0);
   ae_shared_pool_first_recycled(&pool, &_p0);
   if (p0 == NULL) {
      ae_frame_leave();
      return Ok;
   }
   ae_shared_pool_next_recycled(&pool, &_p0);
   if (p0 == NULL) {
      ae_frame_leave();
      return Ok;
   }
   ae_shared_pool_next_recycled(&pool, &_p0);
   if (p0 == NULL) {
      ae_frame_leave();
      return Ok;
   }
   ae_shared_pool_next_recycled(&pool, &_p0);
   if (p0 != NULL) {
      ae_frame_leave();
      return Ok;
   }
   ae_shared_pool_reset(&pool);
   ae_shared_pool_first_recycled(&pool, &_p0);
   if (p0 != NULL) {
      ae_frame_leave();
      return Ok;
   }
   ae_shared_pool_next_recycled(&pool, &_p0);
   if (p0 != NULL) {
      ae_frame_leave();
      return Ok;
   }
   ae_shared_pool_next_recycled(&pool, &_p0);
   if (p0 != NULL) {
      ae_frame_leave();
      return Ok;
   }
   ae_shared_pool_next_recycled(&pool, &_p0);
   if (p0 != NULL) {
      ae_frame_leave();
      return Ok;
   }
// Test 9: invalid pointer is recognized as non-null (we do not reference it, just test)
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   ae_shared_pool_retrieve(&pool, &_p0);
   ae_shared_pool_retrieve(&pool, &_p1);
   ae_shared_pool_retrieve(&pool, &_p2);
   ae_shared_pool_recycle(&pool, &_p1);
   ae_shared_pool_recycle(&pool, &_p2);
   ae_shared_pool_recycle(&pool, &_p0);
   ae_shared_pool_first_recycled(&pool, &_p0);
   if (p0 == NULL) {
      ae_frame_leave();
      return Ok;
   }
   ae_shared_pool_clear_recycled(&pool, true);
   if (p0 == NULL) {
      ae_frame_leave();
      return Ok;
   }
// Test 10: non-null pointer is nulled by calling SetNull()
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   ae_shared_pool_retrieve(&pool, &_p0);
   if (p0 == NULL) {
      ae_frame_leave();
      return Ok;
   }
   ae_smart_ptr_assign(&_p0, NULL, false, false, NULL);
   if (p0 != NULL) {
      ae_frame_leave();
      return Ok;
   }
   Ok = true;
   ae_frame_leave();
   return Ok;
}

static bool testalglibbasicsunit_testsharedpool() {
   bool Ok;
   Ok = testalglibbasicsunit_sharedpoolerrors();
   if (!silent) {
      printf("Shared Pool:                              %s\n", Ok? "Ok": "Failed");
   }
   return Ok;
}

// This function merges sorted A[Idx0,Idx1) and A[Idx1,Idx2) into sorted array
// A[Idx0,Idx2) using corresponding elements of Buf.
static void testalglibbasicsunit_mergesortedarrays(ZVector *a, ZVector *buf, ae_int_t idx0, ae_int_t idx1, ae_int_t idx2) {
   ae_int_t srcleft;
   ae_int_t srcright;
   ae_int_t dst;
   srcleft = idx0;
   srcright = idx1;
   dst = idx0;
   while (true) {
      if (srcleft == idx1 && srcright == idx2) {
         break;
      }
      if (srcleft == idx1) {
         buf->xZ[dst] = a->xZ[srcright];
         srcright++;
         dst++;
         continue;
      }
      if (srcright == idx2) {
         buf->xZ[dst] = a->xZ[srcleft];
         srcleft++;
         dst++;
         continue;
      }
      if (a->xZ[srcleft] < a->xZ[srcright]) {
         buf->xZ[dst] = a->xZ[srcleft];
         srcleft++;
         dst++;
      } else {
         buf->xZ[dst] = a->xZ[srcright];
         srcright++;
         dst++;
      }
   }
   for (dst = idx0; dst < idx2; dst++) {
      a->xZ[dst] = buf->xZ[dst];
   }
}

// Tests for SMP functions
//
// testSort0: sort function
static void testalglibbasicsunit_testsort0func(ZVector *a, ZVector *buf, ae_int_t idx0, ae_int_t idx2) {
   ae_int_t idx1;
   if (idx2 <= idx0 + 1) {
      return;
   }
   idx1 = (idx0 + idx2) / 2;
   testalglibbasicsunit_testsort0func(a, buf, idx0, idx1);
   testalglibbasicsunit_testsort0func(a, buf, idx1, idx2);
   testalglibbasicsunit_mergesortedarrays(a, buf, idx0, idx1, idx2);
}

// testSort0: recursive sorting by splitting array into two subarrays.
static bool testalglibbasicsunit_performtestsort0() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t k;
   ae_int_t n;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(a, 0, DT_INT);
   NewVector(buf, 0, DT_INT);
   n = 100000;
   ae_vector_set_length(&a, n);
   ae_vector_set_length(&buf, n);
   for (i = 0; i < n; i++) {
      a.xZ[i] = i;
   }
   for (i = 0; i < n; i++) {
      k = randominteger(n);
      if (k != i) {
         swapi(&a.xZ[i], &a.xZ[k]);
      }
   }
   testalglibbasicsunit_testsort0func(&a, &buf, 0, n);
   Ok = true;
   for (i = 0; i < n; i++) {
      Ok = Ok && a.xZ[i] == i;
   }
   ae_frame_leave();
   return Ok;
}

// TestSort0: sort function
static void testalglibbasicsunit_testsort1func(ZVector *a, ZVector *buf, ae_int_t idx0, ae_int_t idx2, bool usesmp) {
   ae_int_t idxa;
   ae_int_t idxb;
   ae_int_t idxc;
   ae_int_t cnt4;
   if (idx2 <= idx0 + 1) {
      return;
   }
   if (idx2 == idx0 + 2) {
      testalglibbasicsunit_mergesortedarrays(a, buf, idx0, idx0 + 1, idx0 + 2);
      return;
   }
   if (idx2 == idx0 + 3) {
      testalglibbasicsunit_mergesortedarrays(a, buf, idx0 + 0, idx0 + 1, idx0 + 2);
      testalglibbasicsunit_mergesortedarrays(a, buf, idx0 + 0, idx0 + 2, idx0 + 3);
      return;
   }
   if (idx2 == idx0 + 4) {
      testalglibbasicsunit_mergesortedarrays(a, buf, idx0 + 0, idx0 + 1, idx0 + 2);
      testalglibbasicsunit_mergesortedarrays(a, buf, idx0 + 2, idx0 + 3, idx0 + 4);
      testalglibbasicsunit_mergesortedarrays(a, buf, idx0 + 0, idx0 + 2, idx0 + 4);
      return;
   }
   cnt4 = (idx2 - idx0) / 4;
   idxa = idx0 + cnt4;
   idxb = idx0 + 2 * cnt4;
   idxc = idx0 + 3 * cnt4;
   testalglibbasicsunit_testsort1func(a, buf, idx0, idxa, usesmp);
   testalglibbasicsunit_testsort1func(a, buf, idxa, idxb, usesmp);
   testalglibbasicsunit_testsort1func(a, buf, idxb, idxc, usesmp);
   testalglibbasicsunit_testsort1func(a, buf, idxc, idx2, usesmp);
   testalglibbasicsunit_mergesortedarrays(a, buf, idx0, idxa, idxb);
   testalglibbasicsunit_mergesortedarrays(a, buf, idxb, idxc, idx2);
   testalglibbasicsunit_mergesortedarrays(a, buf, idx0, idxb, idx2);
}

// TestSort0: recursive sorting by splitting array into 4 subarrays.
//
// Sorting is performed in three rounds:
// * parallel sorting of randomly permuted array
// * result is randomly shuffled and sequentially sorted
// * result is randomly shuffled (again) and sorted in parallel mode (again)
//
// The idea of such "multitry sort" is that we test ability of  SMP  core  to
// interleave highly parallel parts of code with long sequential parts.
static bool testalglibbasicsunit_performtestsort1() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t k;
   ae_int_t n;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(a, 0, DT_INT);
   NewVector(buf, 0, DT_INT);
// Generate array
   n = 100000;
   ae_vector_set_length(&a, n);
   ae_vector_set_length(&buf, n);
   for (i = 0; i < n; i++) {
      a.xZ[i] = i;
   }
// round 0: parallel sorting of randomly permuted array
   for (i = 0; i < n; i++) {
      k = randominteger(n);
      if (k != i) {
         swapi(&a.xZ[i], &a.xZ[k]);
      }
   }
   testalglibbasicsunit_testsort1func(&a, &buf, 0, n, true);
// round 1: result is randomly shuffled and sequentially sorted
   for (i = 0; i < n; i++) {
      k = randominteger(n);
      if (k != i) {
         swapi(&a.xZ[i], &a.xZ[k]);
      }
   }
   testalglibbasicsunit_testsort1func(&a, &buf, 0, n, false);
// round 2: result is randomly shuffled (again) and sorted in parallel mode (again)
   for (i = 0; i < n; i++) {
      k = randominteger(n);
      if (k != i) {
         swapi(&a.xZ[i], &a.xZ[k]);
      }
   }
   testalglibbasicsunit_testsort1func(&a, &buf, 0, n, true);
// Test
   Ok = true;
   for (i = 0; i < n; i++) {
      Ok = Ok && a.xZ[i] == i;
   }
   ae_frame_leave();
   return Ok;
}

// Tests for SMP functions
//
// testSort2: sort function
static void testalglibbasicsunit_testsort2func(ZVector *a, ZVector *buf, ae_int_t idx0, ae_int_t idx2) {
   ae_int_t idx1;
   if (idx2 <= idx0 + 1) {
      return;
   }
   idx1 = idx0 + 1 + randominteger(idx2 - idx0 - 1);
   testalglibbasicsunit_testsort0func(a, buf, idx0, idx1);
   testalglibbasicsunit_testsort0func(a, buf, idx1, idx2);
   testalglibbasicsunit_mergesortedarrays(a, buf, idx0, idx1, idx2);
}

// testSort2: recursive sorting by splitting array into two subarrays of
// different length (main difference from testsort0).
static bool testalglibbasicsunit_performtestsort2() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t k;
   ae_int_t n;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(a, 0, DT_INT);
   NewVector(buf, 0, DT_INT);
   n = 100000;
   ae_vector_set_length(&a, n);
   ae_vector_set_length(&buf, n);
   for (i = 0; i < n; i++) {
      a.xZ[i] = i;
   }
   for (i = 0; i < n; i++) {
      k = randominteger(n);
      if (k != i) {
         swapi(&a.xZ[i], &a.xZ[k]);
      }
   }
   testalglibbasicsunit_testsort2func(&a, &buf, 0, n);
   Ok = true;
   for (i = 0; i < n; i++) {
      Ok = Ok && a.xZ[i] == i;
   }
   ae_frame_leave();
   return Ok;
}

// Complex arithmetics test
static bool testalglibbasicsunit_testcomplexarithmetics() {
   bool absc;
   bool addcc;
   bool addcr;
   bool addrc;
   bool subcc;
   bool subcr;
   bool subrc;
   bool mulcc;
   bool mulcr;
   bool mulrc;
   bool divcc;
   bool divcr;
   bool divrc;
   complex ca;
   complex cb;
   complex res;
   double ra;
   double rb;
   double threshold;
   ae_int_t pass;
   ae_int_t passcount;
   bool Ok;
   threshold = 100.0 * machineepsilon;
   passcount = 1000;
   Ok = true;
   absc = true;
   addcc = true;
   addcr = true;
   addrc = true;
   subcc = true;
   subcr = true;
   subrc = true;
   mulcc = true;
   mulcr = true;
   mulrc = true;
   divcc = true;
   divcr = true;
   divrc = true;
   for (pass = 1; pass <= passcount; pass++) {
   // Test AbsC
      ca = complex_from_d(randommid(), randommid());
      ra = abscomplex(ca);
      absc = absc && NearR(ra, sqrt(sqr(ca.x) + sqr(ca.y)), threshold);
   // test Add
      ca = complex_from_d(randommid(), randommid());
      cb = complex_from_d(randommid(), randommid());
      ra = randommid();
      rb = randommid();
      res = ae_c_add(ca, cb);
      addcc = addcc && NearR(res.x, ca.x + cb.x, threshold) && NearR(res.y, ca.y + cb.y, threshold);
      res = ae_c_add_d(ca, rb);
      addcr = addcr && NearR(res.x - ca.x, rb, threshold) && NearR(res.y, ca.y, threshold);
      res = ae_c_add_d(cb, ra);
      addrc = addrc && NearR(res.x - ra, cb.x, threshold) && NearR(res.y, cb.y, threshold);
   // test Sub
      ca = complex_from_d(randommid(), randommid());
      cb = complex_from_d(randommid(), randommid());
      ra = randommid();
      rb = randommid();
      res = ae_c_sub(ca, cb);
      subcc = subcc && NearR(res.x, ca.x - cb.x, threshold) && NearR(res.y, ca.y - cb.y, threshold);
      res = ae_c_sub_d(ca, rb);
      subcr = subcr && NearR(res.x, ca.x - rb, threshold) && NearR(res.y, ca.y, threshold);
      res = ae_c_d_sub(ra, cb);
      subrc = subrc && NearR(res.x, ra - cb.x, threshold) && NearR(res.y, -cb.y, threshold);
   // test Mul
      ca = complex_from_d(randommid(), randommid());
      cb = complex_from_d(randommid(), randommid());
      ra = randommid();
      rb = randommid();
      res = ae_c_mul(ca, cb);
      mulcc = mulcc && NearR(res.x, ca.x * cb.x - ca.y * cb.y, threshold) && NearR(res.y, ca.x * cb.y + ca.y * cb.x, threshold);
      res = ae_c_mul_d(ca, rb);
      mulcr = mulcr && NearR(res.x, ca.x * rb, threshold) && NearR(res.y, ca.y * rb, threshold);
      res = ae_c_mul_d(cb, ra);
      mulrc = mulrc && NearR(res.x, ra * cb.x, threshold) && NearR(res.y, ra * cb.y, threshold);
   // test Div
      ca = complex_from_d(randommid(), randommid());
      do {
         cb = complex_from_d(randommid(), randommid());
      } while (SmallAtC(cb, 0.5));
      ra = randommid();
      do {
         rb = randommid();
      } while (SmallAtR(rb, 0.5));
      res = ae_c_div(ca, cb);
      divcc = divcc && NearR(ae_c_mul(res, cb).x, ca.x, threshold) && NearR(ae_c_mul(res, cb).y, ca.y, threshold);
      res = ae_c_div_d(ca, rb);
      divcr = divcr && NearR(res.x, ca.x / rb, threshold) && NearR(res.y, ca.y / rb, threshold);
      res = ae_c_d_div(ra, cb);
      divrc = divrc && NearR(ae_c_mul(res, cb).x, ra, threshold) && SmallR(ae_c_mul(res, cb).y, threshold);
   }
// summary
   Ok = Ok && absc && addcc && addcr && addrc;
   Ok = Ok && subcc && subcr && subrc && mulcc;
   Ok = Ok && mulcr && mulrc;
   Ok = Ok && divcc && divcr && divrc;
   if (!silent) {
      printf("Complex Arithmetic:                       %s\n", Ok? "Ok": "Failed");
      if (!Ok) {
         printf("* Add CC:                                 %s\n", addcc? "Ok": "Failed");
         printf("* Add CR:                                 %s\n", addcr? "Ok": "Failed");
         printf("* Add RC:                                 %s\n", addrc? "Ok": "Failed");
         printf("* Sub CC:                                 %s\n", subcc? "Ok": "Failed");
         printf("* Sub CR:                                 %s\n", subcr? "Ok": "Failed");
         printf("* Sub RC:                                 %s\n", subrc? "Ok": "Failed");
         printf("* Mul CC:                                 %s\n", mulcc? "Ok": "Failed");
         printf("* Mul CR:                                 %s\n", mulcr? "Ok": "Failed");
         printf("* Mul RC:                                 %s\n", mulrc? "Ok": "Failed");
         printf("* Div CC:                                 %s\n", divcc? "Ok": "Failed");
         printf("* Div CR:                                 %s\n", divcr? "Ok": "Failed");
         printf("* Div RC:                                 %s\n", divrc? "Ok": "Failed");
      }
   }
   return Ok;
}

// Tests for IEEE special quantities
static bool testalglibbasicsunit_testieeespecial() {
   bool oknan;
   bool okinf;
   bool okother;
   double v1;
   double v2;
   bool Ok;
   Ok = true;
   oknan = true;
   okinf = true;
   okother = true;
// Test classification functions
   okother = okother && !isinf(NAN);
   okother = okother && isinf(+INFINITY);
   okother = okother && !isinf(maxrealnumber);
   okother = okother && !isinf(1.0);
   okother = okother && !isinf(minrealnumber);
   okother = okother && !isinf(0.0);
   okother = okother && !isinf(-minrealnumber);
   okother = okother && !isinf(-1.0);
   okother = okother && !isinf(-maxrealnumber);
   okother = okother && isinf(-INFINITY);
   okother = okother && !isposinf(NAN);
   okother = okother && isposinf(+INFINITY);
   okother = okother && !isposinf(maxrealnumber);
   okother = okother && !isposinf(1.0);
   okother = okother && !isposinf(minrealnumber);
   okother = okother && !isposinf(0.0);
   okother = okother && !isposinf(-minrealnumber);
   okother = okother && !isposinf(-1.0);
   okother = okother && !isposinf(-maxrealnumber);
   okother = okother && !isposinf(-INFINITY);
   okother = okother && !isneginf(NAN);
   okother = okother && !isneginf(+INFINITY);
   okother = okother && !isneginf(maxrealnumber);
   okother = okother && !isneginf(1.0);
   okother = okother && !isneginf(minrealnumber);
   okother = okother && !isneginf(0.0);
   okother = okother && !isneginf(-minrealnumber);
   okother = okother && !isneginf(-1.0);
   okother = okother && !isneginf(-maxrealnumber);
   okother = okother && isneginf(-INFINITY);
   okother = okother && isnan(NAN);
   okother = okother && !isnan(+INFINITY);
   okother = okother && !isnan(maxrealnumber);
   okother = okother && !isnan(1.0);
   okother = okother && !isnan(minrealnumber);
   okother = okother && !isnan(0.0);
   okother = okother && !isnan(-minrealnumber);
   okother = okother && !isnan(-1.0);
   okother = okother && !isnan(-maxrealnumber);
   okother = okother && !isnan(-INFINITY);
   okother = okother && !isfinite(NAN);
   okother = okother && !isfinite(+INFINITY);
   okother = okother && isfinite(maxrealnumber);
   okother = okother && isfinite(1.0);
   okother = okother && isfinite(minrealnumber);
   okother = okother && isfinite(0.0);
   okother = okother && isfinite(-minrealnumber);
   okother = okother && isfinite(-1.0);
   okother = okother && isfinite(-maxrealnumber);
   okother = okother && !isfinite(-INFINITY);
// Test NAN
   v1 = NAN;
   v2 = NAN;
   oknan = oknan && isnan(v1);
   oknan = oknan && v1 != v2;
   oknan = oknan && !(v1 == v2);
// Test INF:
// * basic properties
// * comparisons involving PosINF on one of the sides
// * comparisons involving NegINF on one of the sides
   v1 = +INFINITY;
   v2 = -INFINITY;
   okinf = okinf && isinf(+INFINITY);
   okinf = okinf && isinf(v1);
   okinf = okinf && isinf(-INFINITY);
   okinf = okinf && isinf(v2);
   okinf = okinf && isposinf(+INFINITY);
   okinf = okinf && isposinf(v1);
   okinf = okinf && !isposinf(-INFINITY);
   okinf = okinf && !isposinf(v2);
   okinf = okinf && !isneginf(+INFINITY);
   okinf = okinf && !isneginf(v1);
   okinf = okinf && isneginf(-INFINITY);
   okinf = okinf && isneginf(v2);
   okinf = okinf && +INFINITY == +INFINITY;
   okinf = okinf && +INFINITY == v1;
   okinf = okinf && !(+INFINITY == -INFINITY);
   okinf = okinf && !(+INFINITY == v2);
   okinf = okinf && !(+INFINITY == 0.0);
   okinf = okinf && !(+INFINITY == 1.2);
   okinf = okinf && !(+INFINITY == -1.2);
   okinf = okinf && v1 == +INFINITY;
   okinf = okinf && !(-INFINITY == +INFINITY);
   okinf = okinf && !(v2 == +INFINITY);
   okinf = okinf && !(0.0 == +INFINITY);
   okinf = okinf && !(1.2 == +INFINITY);
   okinf = okinf && !(-1.2 == +INFINITY);
   okinf = okinf && !(+INFINITY != +INFINITY);
   okinf = okinf && !(+INFINITY != v1);
   okinf = okinf && +INFINITY != -INFINITY;
   okinf = okinf && +INFINITY != v2;
   okinf = okinf && +INFINITY != 0.0;
   okinf = okinf && +INFINITY != 1.2;
   okinf = okinf && +INFINITY != -1.2;
   okinf = okinf && !(v1 != +INFINITY);
   okinf = okinf && -INFINITY != +INFINITY;
   okinf = okinf && v2 != +INFINITY;
   okinf = okinf && 0.0 != +INFINITY;
   okinf = okinf && 1.2 != +INFINITY;
   okinf = okinf && -1.2 != +INFINITY;
   okinf = okinf && !(+INFINITY < +INFINITY);
   okinf = okinf && !(+INFINITY < v1);
   okinf = okinf && !(+INFINITY < -INFINITY);
   okinf = okinf && !(+INFINITY < v2);
   okinf = okinf && !(+INFINITY < 0.0);
   okinf = okinf && !(+INFINITY < 1.2);
   okinf = okinf && !(+INFINITY < -1.2);
   okinf = okinf && !(v1 < +INFINITY);
   okinf = okinf && -INFINITY < +INFINITY;
   okinf = okinf && v2 < +INFINITY;
   okinf = okinf && 0.0 < +INFINITY;
   okinf = okinf && 1.2 < +INFINITY;
   okinf = okinf && -1.2 < +INFINITY;
   okinf = okinf && +INFINITY <= +INFINITY;
   okinf = okinf && +INFINITY <= v1;
   okinf = okinf && !(+INFINITY <= -INFINITY);
   okinf = okinf && !(+INFINITY <= v2);
   okinf = okinf && !(+INFINITY <= 0.0);
   okinf = okinf && !(+INFINITY <= 1.2);
   okinf = okinf && !(+INFINITY <= -1.2);
   okinf = okinf && v1 <= +INFINITY;
   okinf = okinf && -INFINITY <= +INFINITY;
   okinf = okinf && v2 <= +INFINITY;
   okinf = okinf && 0.0 <= +INFINITY;
   okinf = okinf && 1.2 <= +INFINITY;
   okinf = okinf && -1.2 <= +INFINITY;
   okinf = okinf && !(+INFINITY > +INFINITY);
   okinf = okinf && !(+INFINITY > v1);
   okinf = okinf && +INFINITY > -INFINITY;
   okinf = okinf && +INFINITY > v2;
   okinf = okinf && +INFINITY > 0.0;
   okinf = okinf && +INFINITY > 1.2;
   okinf = okinf && +INFINITY > -1.2;
   okinf = okinf && !(v1 > +INFINITY);
   okinf = okinf && !(-INFINITY > +INFINITY);
   okinf = okinf && !(v2 > +INFINITY);
   okinf = okinf && !(0.0 > +INFINITY);
   okinf = okinf && !(1.2 > +INFINITY);
   okinf = okinf && !(-1.2 > +INFINITY);
   okinf = okinf && +INFINITY >= +INFINITY;
   okinf = okinf && +INFINITY >= v1;
   okinf = okinf && +INFINITY >= -INFINITY;
   okinf = okinf && +INFINITY >= v2;
   okinf = okinf && +INFINITY >= 0.0;
   okinf = okinf && +INFINITY >= 1.2;
   okinf = okinf && +INFINITY >= -1.2;
   okinf = okinf && v1 >= +INFINITY;
   okinf = okinf && !(-INFINITY >= +INFINITY);
   okinf = okinf && !(v2 >= +INFINITY);
   okinf = okinf && !(0.0 >= +INFINITY);
   okinf = okinf && !(1.2 >= +INFINITY);
   okinf = okinf && !(-1.2 >= +INFINITY);
   okinf = okinf && !(-INFINITY == +INFINITY);
   okinf = okinf && !(-INFINITY == v1);
   okinf = okinf && -INFINITY == -INFINITY;
   okinf = okinf && -INFINITY == v2;
   okinf = okinf && !(-INFINITY == 0.0);
   okinf = okinf && !(-INFINITY == 1.2);
   okinf = okinf && !(-INFINITY == -1.2);
   okinf = okinf && !(v1 == -INFINITY);
   okinf = okinf && -INFINITY == -INFINITY;
   okinf = okinf && v2 == -INFINITY;
   okinf = okinf && !(0.0 == -INFINITY);
   okinf = okinf && !(1.2 == -INFINITY);
   okinf = okinf && !(-1.2 == -INFINITY);
   okinf = okinf && -INFINITY != +INFINITY;
   okinf = okinf && -INFINITY != v1;
   okinf = okinf && !(-INFINITY != -INFINITY);
   okinf = okinf && !(-INFINITY != v2);
   okinf = okinf && -INFINITY != 0.0;
   okinf = okinf && -INFINITY != 1.2;
   okinf = okinf && -INFINITY != -1.2;
   okinf = okinf && v1 != -INFINITY;
   okinf = okinf && !(-INFINITY != -INFINITY);
   okinf = okinf && !(v2 != -INFINITY);
   okinf = okinf && 0.0 != -INFINITY;
   okinf = okinf && 1.2 != -INFINITY;
   okinf = okinf && -1.2 != -INFINITY;
   okinf = okinf && -INFINITY < +INFINITY;
   okinf = okinf && -INFINITY < v1;
   okinf = okinf && !(-INFINITY < -INFINITY);
   okinf = okinf && !(-INFINITY < v2);
   okinf = okinf && -INFINITY < 0.0;
   okinf = okinf && -INFINITY < 1.2;
   okinf = okinf && -INFINITY < -1.2;
   okinf = okinf && !(v1 < -INFINITY);
   okinf = okinf && !(-INFINITY < -INFINITY);
   okinf = okinf && !(v2 < -INFINITY);
   okinf = okinf && !(0.0 < -INFINITY);
   okinf = okinf && !(1.2 < -INFINITY);
   okinf = okinf && !(-1.2 < -INFINITY);
   okinf = okinf && -INFINITY <= +INFINITY;
   okinf = okinf && -INFINITY <= v1;
   okinf = okinf && -INFINITY <= -INFINITY;
   okinf = okinf && -INFINITY <= v2;
   okinf = okinf && -INFINITY <= 0.0;
   okinf = okinf && -INFINITY <= 1.2;
   okinf = okinf && -INFINITY <= -1.2;
   okinf = okinf && !(v1 <= -INFINITY);
   okinf = okinf && -INFINITY <= -INFINITY;
   okinf = okinf && v2 <= -INFINITY;
   okinf = okinf && !(0.0 <= -INFINITY);
   okinf = okinf && !(1.2 <= -INFINITY);
   okinf = okinf && !(-1.2 <= -INFINITY);
   okinf = okinf && !(-INFINITY > +INFINITY);
   okinf = okinf && !(-INFINITY > v1);
   okinf = okinf && !(-INFINITY > -INFINITY);
   okinf = okinf && !(-INFINITY > v2);
   okinf = okinf && !(-INFINITY > 0.0);
   okinf = okinf && !(-INFINITY > 1.2);
   okinf = okinf && !(-INFINITY > -1.2);
   okinf = okinf && v1 > -INFINITY;
   okinf = okinf && !(-INFINITY > -INFINITY);
   okinf = okinf && !(v2 > -INFINITY);
   okinf = okinf && 0.0 > -INFINITY;
   okinf = okinf && 1.2 > -INFINITY;
   okinf = okinf && -1.2 > -INFINITY;
   okinf = okinf && !(-INFINITY >= +INFINITY);
   okinf = okinf && !(-INFINITY >= v1);
   okinf = okinf && -INFINITY >= -INFINITY;
   okinf = okinf && -INFINITY >= v2;
   okinf = okinf && !(-INFINITY >= 0.0);
   okinf = okinf && !(-INFINITY >= 1.2);
   okinf = okinf && !(-INFINITY >= -1.2);
   okinf = okinf && v1 >= -INFINITY;
   okinf = okinf && -INFINITY >= -INFINITY;
   okinf = okinf && v2 >= -INFINITY;
   okinf = okinf && 0.0 >= -INFINITY;
   okinf = okinf && 1.2 >= -INFINITY;
   okinf = okinf && -1.2 >= -INFINITY;
// summary
   Ok = Ok && oknan && okinf && okother;
   if (!silent) {
      printf("IEEE Special Values:                      %s\n", Ok? "Ok": "Failed");
      if (!Ok) {
         printf("* NAN:                                    %s\n", oknan? "Ok": "Failed");
         printf("* Infinity:                               %s\n", okinf? "Ok": "Failed");
         printf("* Functions:                              %s\n", okother? "Ok": "Failed");
      }
   }
   return Ok;
}

// Tests for swapping functions
static bool testalglibbasicsunit_testswapfunctions() {
   ae_frame _frame_block;
   bool okb1;
   bool okb2;
   bool oki1;
   bool oki2;
   bool okr1;
   bool okr2;
   bool okc1;
   bool okc2;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewVector(b11, 0, DT_BOOL);
   NewVector(b12, 0, DT_BOOL);
   NewVector(i11, 0, DT_INT);
   NewVector(i12, 0, DT_INT);
   NewVector(r11, 0, DT_REAL);
   NewVector(r12, 0, DT_REAL);
   NewVector(c11, 0, DT_COMPLEX);
   NewVector(c12, 0, DT_COMPLEX);
   NewMatrix(b21, 0, 0, DT_BOOL);
   NewMatrix(b22, 0, 0, DT_BOOL);
   NewMatrix(i21, 0, 0, DT_INT);
   NewMatrix(i22, 0, 0, DT_INT);
   NewMatrix(r21, 0, 0, DT_REAL);
   NewMatrix(r22, 0, 0, DT_REAL);
   NewMatrix(c21, 0, 0, DT_COMPLEX);
   NewMatrix(c22, 0, 0, DT_COMPLEX);
   Ok = true;
   okb1 = true;
   okb2 = true;
   oki1 = true;
   oki2 = true;
   okr1 = true;
   okr2 = true;
   okc1 = true;
   okc2 = true;
// Test B1 swaps
   ae_vector_set_length(&b11, 1);
   ae_vector_set_length(&b12, 2);
   b11.xB[0] = true;
   b12.xB[0] = false;
   b12.xB[1] = true;
   ae_swap_vectors(&b11, &b12);
   if (b11.cnt == 2 && b12.cnt == 1) {
      okb1 = okb1 && !b11.xB[0];
      okb1 = okb1 && b11.xB[1];
      okb1 = okb1 && b12.xB[0];
   } else {
      okb1 = false;
   }
// Test I1 swaps
   ae_vector_set_length(&i11, 1);
   ae_vector_set_length(&i12, 2);
   i11.xZ[0] = 1;
   i12.xZ[0] = 2;
   i12.xZ[1] = 3;
   ae_swap_vectors(&i11, &i12);
   if (i11.cnt == 2 && i12.cnt == 1) {
      oki1 = oki1 && i11.xZ[0] == 2;
      oki1 = oki1 && i11.xZ[1] == 3;
      oki1 = oki1 && i12.xZ[0] == 1;
   } else {
      oki1 = false;
   }
// Test R1 swaps
   ae_vector_set_length(&r11, 1);
   ae_vector_set_length(&r12, 2);
   r11.xR[0] = 1.5;
   r12.xR[0] = 2.5;
   r12.xR[1] = 3.5;
   ae_swap_vectors(&r11, &r12);
   if (r11.cnt == 2 && r12.cnt == 1) {
      okr1 = okr1 && r11.xR[0] == 2.5;
      okr1 = okr1 && r11.xR[1] == 3.5;
      okr1 = okr1 && r12.xR[0] == 1.5;
   } else {
      okr1 = false;
   }
// Test C1 swaps
   ae_vector_set_length(&c11, 1);
   ae_vector_set_length(&c12, 2);
   c11.xC[0] = complex_from_i(1);
   c12.xC[0] = complex_from_i(2);
   c12.xC[1] = complex_from_i(3);
   ae_swap_vectors(&c11, &c12);
   if (c11.cnt == 2 && c12.cnt == 1) {
      okc1 = okc1 && ae_c_eq_d(c11.xC[0], 2.0);
      okc1 = okc1 && ae_c_eq_d(c11.xC[1], 3.0);
      okc1 = okc1 && ae_c_eq_d(c12.xC[0], 1.0);
   } else {
      okc1 = false;
   }
// Test B2 swaps
   ae_matrix_set_length(&b21, 1, 2);
   ae_matrix_set_length(&b22, 2, 1);
   b21.xyB[0][0] = true;
   b21.xyB[0][1] = false;
   b22.xyB[0][0] = false;
   b22.xyB[1][0] = true;
   ae_swap_matrices(&b21, &b22);
   if (b21.rows == 2 && b21.cols == 1 && b22.rows == 1 && b22.cols == 2) {
      okb2 = okb2 && !b21.xyB[0][0];
      okb2 = okb2 && b21.xyB[1][0];
      okb2 = okb2 && b22.xyB[0][0];
      okb2 = okb2 && !b22.xyB[0][1];
   } else {
      okb2 = false;
   }
// Test I2 swaps
   ae_matrix_set_length(&i21, 1, 2);
   ae_matrix_set_length(&i22, 2, 1);
   i21.xyZ[0][0] = 1;
   i21.xyZ[0][1] = 2;
   i22.xyZ[0][0] = 3;
   i22.xyZ[1][0] = 4;
   ae_swap_matrices(&i21, &i22);
   if (i21.rows == 2 && i21.cols == 1 && i22.rows == 1 && i22.cols == 2) {
      oki2 = oki2 && i21.xyZ[0][0] == 3;
      oki2 = oki2 && i21.xyZ[1][0] == 4;
      oki2 = oki2 && i22.xyZ[0][0] == 1;
      oki2 = oki2 && i22.xyZ[0][1] == 2;
   } else {
      oki2 = false;
   }
// Test R2 swaps
   ae_matrix_set_length(&r21, 1, 2);
   ae_matrix_set_length(&r22, 2, 1);
   r21.xyR[0][0] = 1.0;
   r21.xyR[0][1] = 2.0;
   r22.xyR[0][0] = 3.0;
   r22.xyR[1][0] = 4.0;
   ae_swap_matrices(&r21, &r22);
   if (r21.rows == 2 && r21.cols == 1 && r22.rows == 1 && r22.cols == 2) {
      okr2 = okr2 && r21.xyR[0][0] == 3.0;
      okr2 = okr2 && r21.xyR[1][0] == 4.0;
      okr2 = okr2 && r22.xyR[0][0] == 1.0;
      okr2 = okr2 && r22.xyR[0][1] == 2.0;
   } else {
      okr2 = false;
   }
// Test C2 swaps
   ae_matrix_set_length(&c21, 1, 2);
   ae_matrix_set_length(&c22, 2, 1);
   c21.xyC[0][0] = complex_from_i(1);
   c21.xyC[0][1] = complex_from_i(2);
   c22.xyC[0][0] = complex_from_i(3);
   c22.xyC[1][0] = complex_from_i(4);
   ae_swap_matrices(&c21, &c22);
   if (c21.rows == 2 && c21.cols == 1 && c22.rows == 1 && c22.cols == 2) {
      okc2 = okc2 && ae_c_eq_d(c21.xyC[0][0], 3.0);
      okc2 = okc2 && ae_c_eq_d(c21.xyC[1][0], 4.0);
      okc2 = okc2 && ae_c_eq_d(c22.xyC[0][0], 1.0);
      okc2 = okc2 && ae_c_eq_d(c22.xyC[0][1], 2.0);
   } else {
      okc2 = false;
   }
// summary
   Ok = Ok && okb1 && okb2;
   Ok = Ok && oki1 && oki2;
   Ok = Ok && okr1 && okr2;
   Ok = Ok && okc1 && okc2;
   if (!silent) {
      printf("Swapping Functions:                       %s\n", Ok? "Ok": "Failed");
   }
   ae_frame_leave();
   return Ok;
}

// Tests for standard functions
static bool testalglibbasicsunit_teststandardfunctions() {
   bool Ok;
   Ok = true;
// Test sign()
   Ok = Ok && sign(1.2) == 1 && sign(0.0) == 0 && sign(-1.2) == -1;
// summary
   if (!silent) {
      printf("Standard Functions:                       %s\n", Ok? "Ok": "Failed");
   }
   return Ok;
}

// Tests for serualization functions
static bool testalglibbasicsunit_testserializationfunctions() {
   ae_frame _frame_block;
   bool okb;
   bool oki;
   bool okr;
   ae_int_t nb;
   ae_int_t ni;
   ae_int_t nr;
   ae_int_t i;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(rec4serialization, r0);
   NewObj(rec4serialization, r1);
   Ok = true;
   okb = true;
   oki = true;
   okr = true;
   for (nb = 1; nb <= 4; nb++) {
      for (ni = 1; ni <= 4; ni++) {
         for (nr = 1; nr <= 4; nr++) {
            ae_vector_set_length(&r0.b, nb);
            for (i = 0; i < nb; i++) {
               r0.b.xB[i] = randominteger(2) != 0;
            }
            ae_vector_set_length(&r0.i, ni);
            for (i = 0; i < ni; i++) {
               r0.i.xZ[i] = randominteger(10) - 5;
            }
            ae_vector_set_length(&r0.r, nr);
            for (i = 0; i < nr; i++) {
               r0.r.xR[i] = randommid();
            }
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               rec4serializationalloc(&_local_serializer, &r0);
               ae_int_t _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               rec4serializationserialize(&_local_serializer, &r0);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               rec4serializationunserialize(&_local_serializer, &r1);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
            if (r0.b.cnt == r1.b.cnt && r0.i.cnt == r1.i.cnt && r0.r.cnt == r1.r.cnt) {
               for (i = 0; i < nb; i++) {
                  okb = okb && r0.b.xB[i] == r1.b.xB[i];
               }
               for (i = 0; i < ni; i++) {
                  oki = oki && r0.i.xZ[i] == r1.i.xZ[i];
               }
               for (i = 0; i < nr; i++) {
                  okr = okr && r0.r.xR[i] == r1.r.xR[i];
               }
            } else {
               oki = false;
            }
         }
      }
   }
// summary
   Ok = Ok && okb && oki && okr;
   if (!silent) {
      printf("Serialization Functions:                  %s\n", Ok? "Ok": "Failed");
      if (!Ok) {
         printf("* Boolean:                                %s\n", okb? "Ok": "Failed");
         printf("* Integer:                                %s\n", oki? "Ok": "Failed");
         printf("* Real:                                   %s\n", okr? "Ok": "Failed");
      }
   }
   ae_frame_leave();
   return Ok;
}

// Summation routune for parallel summation test.
static void testalglibbasicsunit_parallelpoolsum(ae_shared_pool *sumpool, ae_int_t ind0, ae_int_t ind1) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   RefObj(poolsummand, ptr);
   if (ind1 - ind0 <= 2) {
      ae_shared_pool_retrieve(sumpool, &_ptr);
      ptr->val += ind1 - ind0;
      ae_shared_pool_recycle(sumpool, &_ptr);
   } else {
      i = (ind0 + ind1) / 2;
      testalglibbasicsunit_parallelpoolsum(sumpool, ind0, i);
      testalglibbasicsunit_parallelpoolsum(sumpool, i, ind1);
   }
   ae_frame_leave();
}

// TestPoolSum: summation with pool
//
// We perform summation of 500000 numbers (each of them is equal to 1) in the
// recurrent manner, by accumulation of result in the pool.
//
// This test checks pool ability to handle continuous stream of operations.
static bool testalglibbasicsunit_performtestpoolsum() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t sum;
   bool Ok;
   ae_frame_make(&_frame_block);
   NewObj(ae_shared_pool, pool);
   RefObj(poolsummand, ptr);
   NewObj(poolsummand, seed);
   n = 500000;
   seed.val = 0;
   ae_shared_pool_set_seed(&pool, &seed, sizeof(seed), poolsummand_init, poolsummand_copy, poolsummand_free);
   testalglibbasicsunit_parallelpoolsum(&pool, 0, n);
   sum = 0;
   for (ae_shared_pool_first_recycled(&pool, &_ptr); ptr != NULL; ae_shared_pool_next_recycled(&pool, &_ptr)) {
      sum += ptr->val;
   }
   Ok = sum == n;
   ae_frame_leave();
   return Ok;
}

static bool testalglibbasicsunit_testsmp() {
   bool t0;
   bool t1;
   bool t2;
   bool ts;
   bool Ok;
   t0 = testalglibbasicsunit_performtestsort0();
   t1 = testalglibbasicsunit_performtestsort1();
   t2 = testalglibbasicsunit_performtestsort2();
   ts = testalglibbasicsunit_performtestpoolsum();
   Ok = t0 && t1 && t2 && ts;
   if (!silent) {
      printf("SMP Functions:                            %s\n", Ok? "Ok": "Failed");
      if (!Ok) {
         printf("* Test Sort0 (Sorting, Split-2):          %s\n", t0? "Ok": "Failed");
         printf("* Test Sort1 (Sorting, Split-4):          %s\n", t1? "Ok": "Failed");
         printf("* Test Sort2 (Sorting, Split-2, unequal): %s\n", t2? "Ok": "Failed");
         printf("* Test PoolSum (Accumulation With Pool):  %s\n", ts? "Ok": "Failed");
      }
   }
   return Ok;
}

bool testalglibbasics() {
   if (!silent) printf("AlgLib Basics Test Breakdown\n");
   bool complexOk = testalglibbasicsunit_testcomplexarithmetics();
   bool specialOk = testalglibbasicsunit_testieeespecial();
   bool swapOk = testalglibbasicsunit_testswapfunctions();
   bool standardOk = testalglibbasicsunit_teststandardfunctions();
   bool serializationOk = testalglibbasicsunit_testserializationfunctions();
   bool sharedpoolOk = testalglibbasicsunit_testsharedpool();
   bool smpOk = testalglibbasicsunit_testsmp();
// The final report.
   bool Ok = complexOk && specialOk && swapOk && standardOk && serializationOk && sharedpoolOk && smpOk;
   if (!Ok || !silent) {
      printf("AlgLib Basics Test\n");
      printf("* Complex Functions:                      %s\n", complexOk? "Ok": "Failed");
      printf("* IEEE Special Functions:                 %s\n", specialOk? "Ok": "Failed");
      printf("* Swap Functions:                         %s\n", swapOk? "Ok": "Failed");
      printf("* Standard Functions:                     %s\n", standardOk? "Ok": "Failed");
      printf("* Serialization Functions:                %s\n", serializationOk? "Ok": "Failed");
      printf("* Shared Pool Functions:                  %s\n", sharedpoolOk? "Ok": "Failed");
      printf("* SMP:                                    %s\n", smpOk? "Ok": "Failed");
      printf("Test %s\n", Ok? "Passed": "Failed");
   }
   return Ok;
}

// === main testing unit ===
// Configuration-dependent functions for mutexs and threads.
#if AE_OS == AE_POSIX || defined AE_DEBUG4POSIX
#   include <unistd.h>
#   include <pthread.h>
typedef pthread_mutex_t MutEx_t;
inline void acquire_mutex(MutEx_t *MutEx) { pthread_mutex_lock(MutEx); }
inline void release_mutex(MutEx_t *MutEx) { pthread_mutex_unlock(MutEx); }
inline void init_mutex(MutEx_t *MutEx) { pthread_mutex_init(MutEx, NULL); }
inline void free_mutex(MutEx_t *MutEx) { pthread_mutex_destroy(MutEx); }
typedef const pthread_attr_t ThAttr_t;
typedef void *ThArg_t;
typedef void *ThRet_t;
const ThRet_t ThNoRet = (ThRet_t)NULL;
typedef ThRet_t (*ThOp_t)(ThArg_t);
typedef pthread_t Thread_t;
inline int init_thread(Thread_t *Th, ThAttr_t *Attr, ThOp_t Op, ThArg_t Arg) { return pthread_create(Th, Attr, Op, Arg); }
inline void join_threads(long N, Thread_t *Bundle) { for (int T = 0; T < N; T++) pthread_join(Bundle[T], NULL); }
#elif AE_OS == AE_WINDOWS || defined AE_DEBUG4WINDOWS
#   include <windows.h>
typedef CRITICAL_SECTION MutEx_t;
inline void acquire_mutex(MutEx_t *MutEx) { EnterCriticalSection(MutEx); }
inline void release_mutex(MutEx_t *MutEx) { LeaveCriticalSection(MutEx); }
inline void init_mutex(MutEx_t *MutEx) { InitializeCriticalSection(MutEx); }
inline void free_mutex(MutEx_t *MutEx) { DeleteCriticalSection(MutEx); }
typedef LPSECURITY_ATTRIBUTES ThAttr_t;
typedef LPVOID ThArg_t;
typedef DWORD WINAPI ThRet_t;
const ThRet_t ThNoRet = (ThRet_t)0;
typedef LPTHREAD_START_ROUTINE ThOp_t;
typedef HANDLE Thread_t;
inline int init_thread(Thread_t *Th, ThAttr_t *Attr, ThOp_t Op, ThArg_t Arg) { *Th = CreateThread(Attr, 0, Op, Arg, 0, NULL); return *Th != NULL; }
inline void join_threads(long N, Thread_t *Bundle) { WaitForMultipleObjects(N, Bundle, TRUE, INFINITE); }
#else
// These are totally bogus stubs.
// You need to replace them with whatever specializations you need for your target configuration.
typedef void *MutEx_t;
inline void acquire_mutex(MutEx_t *MutEx) { }
inline void release_mutex(MutEx_t *MutEx) { }
inline void init_mutex(MutEx_t *MutEx) { }
inline void free_mutex(MutEx_t *MutEx) { }
typedef void *ThAttr_t;
typedef void *ThArg_t;
typedef void ThRet_t;
const ThRet_t ThNoRet = (ThRet_t)NULL;
typedef ThRet_t (*ThOp_t)(ThArg_t);
struct Thread_t { ThAttr_t Attr; ThOp_t Op; ThArg_t Arg; };
inline int init_thread(Thread_t *Th, ThAttr_t *Attr, ThOp_t Op, ThArg_t Arg) { Th->Attr = Attr, Th->Op = Op, Th->Arg = Arg; return 0; }
inline void join_threads(long N, Thread_t *Bundle) { }
#endif

static const enum {
   AE_NOENV, AE_SINGLECORE, AE_SEQUENTIAL_MULTICORE, AE_PARALLEL_SINGLECORE, AE_PARALLEL_MULTICORE, AE_SKIP_TEST
} TestMode = AE_SINGLECORE;

int global_failure_flag = EXIT_SUCCESS;
bool use_smp = false;

MutEx_t tests_mutex; //(@) Was initialized to NULL for the non-OS version.
MutEx_t print_mutex; //(@) Was initialized to NULL for the non-OS version.

bool call_unittest(bool (*testfunc)()) {
#ifndef AE_USE_CPP_ERROR_HANDLING
   ae_frame _frame_block;
   ae_state_init();
   TryX {
      return false;
   }
   if (use_smp) ae_state_set_flags(ParTH);
   ae_frame_make(&_frame_block);
   bool Ok = testfunc();
   ae_state_clear();
   return Ok;
#else
   try {
      ae_frame _frame_block;
      ae_state_init();
      ae_frame_make(&_frame_block);
      if (use_smp) ae_state_set_flags(ParTH);
      bool Ok = testfunc();
      ae_state_clear();
      return Ok;
   } catch(...) {
      return false;
   }
#endif
}

ThRet_t tester_function(ThArg_t T) {
   static struct {
      const char *name;
      bool (*testfunc)();
   } unittests[] = {
      { "ablasf", testablasf },
      { "hqrnd", testhqrnd },
      { "ablas", testablas },
      { "hblas", testhblas },
      { "creflections", testcreflections },
      { "sblas", testsblas },
      { "ortfac", testortfac },
      { "matgen", testmatgen },
      { "tsort", testtsort },
      { "sparse", testsparse },
      { "blas", testblas },
      { "evd", testevd },
      { "trfac", testtrfac },
      { "polynomialsolver", testpolynomialsolver },
      { "bdsvd", testbdsvd },
      { "svd", testsvd },
      { "trlinsolve", testtrlinsolve },
      { "safesolve", testsafesolve },
      { "rcond", testrcond },
      { "xblas", testxblas },
      { "directdensesolvers", testdirectdensesolvers },
      { "directsparsesolvers", testdirectsparsesolvers },
      { "fbls", testfbls },
      { "iterativesparse", testiterativesparse },
      { "lincg", testlincg },
      { "normestimator", testnormestimator },
      { "linlsqr", testlinlsqr },
      { "linmin", testlinmin },
      { "nleq", testnleq },
      { "matinv", testmatinv },
      { "optserv", testoptserv },
      { "minlbfgs", testminlbfgs },
      { "cqmodels", testcqmodels },
      { "snnls", testsnnls },
      { "sactivesets", testsactivesets },
      { "minbleic", testminbleic },
      { "minqp", testminqp },
      { "minlm", testminlm },
      { "mincg", testmincg },
      { "minlp", testminlp },
      { "minnlc", testminnlc },
      { "minns", testminns },
      { "minbc", testminbc },
      { "nearestneighbor", testnearestneighbor },
      { "odesolver", testodesolver },
      { "inverseupdate", testinverseupdate },
      { "schur", testschur },
      { "spdgevd", testspdgevd },
      { "gammafunc", testgammafunc },
      { "gq", testgq },
      { "gkq", testgkq },
      { "autogk", testautogk },
      { "normaldistr", testnormaldistr },
      { "basestat", testbasestat },
      { "wsr", testwsr },
      { "mannwhitneyu", testmannwhitneyu },
      { "stest", teststest },
      { "studentttests", teststudentttests },
      { "ratint", testratint },
      { "idw", testidw },
      { "polint", testpolint },
      { "spline1d", testspline1d },
      { "lsfit", testlsfit },
      { "fitsphere", testfitsphere },
      { "parametric", testparametric },
      { "spline2d", testspline2d },
      { "spline3d", testspline3d },
      { "rbf", testrbf },
      { "fft", testfft },
      { "fht", testfht },
      { "conv", testconv },
      { "corr", testcorr },
      { "chebyshev", testchebyshev },
      { "hermite", testhermite },
      { "legendre", testlegendre },
      { "laguerre", testlaguerre },
      { "pca", testpca },
      { "bdss", testbdss },
      { "mlpbase", testmlpbase },
      { "mlpe", testmlpe },
      { "clustering", testclustering },
      { "dforest", testdforest },
      { "linreg", testlinreg },
      { "filters", testfilters },
      { "ssa", testssa },
      { "lda", testlda },
      { "mcpd", testmcpd },
      { "knn", testknn },
      { "mlptrain", testmlptrain },
      { "alglibbasics", testalglibbasics }
   };
   const size_t tests = sizeof unittests/sizeof unittests[0];
   int unittests_processed = 0;
   while (true) {
   // Try to acquire the test record.
      acquire_mutex(&tests_mutex);
      int test = unittests_processed++;
      release_mutex(&tests_mutex);
      if (test >= tests) break;
   // Call the unit test.
      bool Ok = call_unittest(unittests[test].testfunc);
      if (!Ok) global_failure_flag = EXIT_FAILURE;
   // Display the test results.
      acquire_mutex(&print_mutex);
      printf("%2d/%d: %-32s %s\n", test + 1, tests, unittests[test].name, Ok? "Ok": "Failed");
      if (!silent) putchar('\n');
      fflush(stdout);
      release_mutex(&print_mutex);
   }
   return ThNoRet;
}

int main(int argc, char **argv) {
   time_t time_0, time_1;
   union {
      double a;
      ae_int32_t p[2];
   } u;
   unsigned seed;
   if (argc == 2)
      seed = (unsigned)atoi(argv[1]);
   else {
      time_t t;
      seed = (unsigned)time(&t);
   }
   init_mutex(&tests_mutex);
   init_mutex(&print_mutex);
// SMP settings
   use_smp = TestMode == AE_PARALLEL_MULTICORE || TestMode == AE_SEQUENTIAL_MULTICORE;
// Seed
   printf("Seed: %u (%x)\n", seed, seed);
   srand(seed);
// Compiler
#if AE_COMPILER == AE_GNUC
   printf("Compiler: GCC\n");
#elif AE_COMPILER == AE_SUNC
   printf("Compiler: SunStudio\n");
#elif AE_COMPILER == AE_MSVC
   printf("Compiler: MSVC\n");
#else
   printf("Compiler: Other\n");
#endif
// Architecture
   if (sizeof(void *) == 4)
      printf("Hardware: 32-bit\n");
   else if (sizeof(void *) == 8)
      printf("Hardware: 64-bit\n");
   else
      printf("Hardware: Other (non-32, non-64)\n");
// Determine the native byte order of the hardware.
// 1983 is a good number - a non-periodic double representation allows us to
// easily distinguish between the upper and lower halves and to detect mixed endian hardware.
   u.a = 1.0 / 1983.0;
   if (u.p[1] == 0x3f408642)
      printf("Byte Order: little-endian\n");
   else if (u.p[0] == 0x3f408642)
      printf("Byte Order: big-endian\n");
   else
      printf("Byte Order: mixed-endian\n");
// CPU (as defined)
#if AE_CPU == AE_INTEL
   printf("CPU: Intel\n");
#elif AE_CPU == AE_SPARC
   printf("CPU: SPARC\n");
#else
   printf("CPU: Other\n");
#endif
// Cores count
#ifdef _ALGLIB_HAS_WORKSTEALING
   printf("Cores: %d\n", (int)ae_cores_count());
#else
   printf("Cores: 1 (serial version)\n");
#endif
// Support for vendor libraries
#ifdef AE_MKL
   printf("Libs: MKL (Intel)\n");
#else
   printf("Libs: (None)\n");
#endif
// CPUID results
   printf("CPUID:%s%s%s\n", CurCPU & CPU_SSE2 ? " sse2" : "", CurCPU & CPU_AVX2 ? " avx2" : "", CurCPU & CPU_FMA ? " fma" : "");
// OS
#if AE_OS == AE_POSIX
   printf("OS: POSIX\n");
#elif AE_OS == AE_WINDOWS
   printf("OS: Windows\n");
#else
   printf("OS: Other\n");
#endif
// Testing mode
   switch (TestMode) {
      case AE_NOENV: case AE_SINGLECORE: printf("Testing Mode: single core\n"); break;
      case AE_PARALLEL_SINGLECORE: printf("Testing Mode: single core, parallel\n"); break;
      case AE_SEQUENTIAL_MULTICORE: printf("Testing Mode: multi-core, sequential\n"); break;
      case AE_PARALLEL_MULTICORE: printf("Testing Mode: multi-core, parallel\n"); break;
      case AE_SKIP_TEST: printf("Testing Mode: just compiling\nDone in 0 seconds\n"); return EXIT_SUCCESS;
      default: printf("Testing Mode: unknown\n"); return EXIT_FAILURE;
   }
// now we are ready to test!
   time(&time_0);
#ifdef _ALGLIB_HAS_WORKSTEALING
   bool smpOk = ae_smpselftests();
   printf("%-32s %s\n", "SMP self tests", smpOk ? "Ok" : "Failed");
   if (!smpOk) return EXIT_FAILURE;
#endif
   fflush(stdout);
   switch (TestMode) {
      case AE_NOENV: case AE_SINGLECORE: case AE_SEQUENTIAL_MULTICORE: case AE_SKIP_TEST:
         tester_function(NULL);
      break;
      case AE_PARALLEL_MULTICORE: case AE_PARALLEL_SINGLECORE: {
#ifdef _ALGLIB_HAS_WORKSTEALING
         setnworkers(0);
#endif
         long cpu_cnt = ae_cores_count();
         ae_assert(cpu_cnt >= 1, "processors count is less than 1");
         Thread_t *Bundle = (Thread_t *)malloc(cpu_cnt * sizeof *Bundle);
         ae_assert(Bundle != NULL, "malloc failure");
         for (int cpu = 0; cpu < cpu_cnt; cpu++) {
            int status = init_thread(&Bundle[cpu], NULL, tester_function, NULL);
            if (status != 0) {
               printf("Failed to create thread\n");
               abort();
            }
         }
         join_threads(cpu_cnt, Bundle);
      }
      break;
      default: printf("Unexpected test mode\n"); return EXIT_FAILURE;
   }
   time(&time_1);
   printf("Done in %ld seconds\n", (long)difftime(time_1, time_0));
// Free structures
   free_mutex(&tests_mutex);
   free_mutex(&print_mutex);
#ifdef AE_HPC
   ae_free_disposed_items();
   ae_complete_finalization_before_exit();
#endif
// Return the result.
   return global_failure_flag;
}
