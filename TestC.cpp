#include <time.h>
#define InAlgLib
#include "DataAnalysis.h"
#include "DiffEquations.h"
#include "FastTransforms.h"
#include "Interpolation.h"

using namespace alglib_impl;

// Error tracking facilities; this fields are modified every time set_error_flag()
// is called with non-zero cond. Thread unsafe access, but it does not matter actually.
static const char *sef_file = "";
static int sef_line = 0;
static const char *sef_xdesc = "";

void set_error_flag(bool *p_flag, bool cond, const char *filename, int lineno, const char *xdesc) {
   if (cond) {
      *p_flag = true;
      sef_file = filename;
      sef_line = lineno;
      sef_xdesc = xdesc;
#ifdef ALGLIB_ABORT_ON_ERROR_FLAG
      printf("[ALGLIB] aborting on set_error_flag(cond=true)\n");
      printf("[ALGLIB] %s:%d\n", filename, lineno);
      printf("[ALGLIB] %s\n", xdesc);
      fflush(stdout);
      abort();
#endif
   }
}

// Internally calls SetErrorFlag() with condition:
//
//     Abs(Val-RefVal)>Tol*Max(Abs(RefVal),S)
//
// This function is used to test relative error in Val against  RefVal,  with
// relative error being replaced by absolute when scale  of  RefVal  is  less
// than S.
//
// This function returns value of COND.
void seterrorflagdiff(bool *flag, double val, double refval, double tol, double s) {
   set_error_flag(flag, fabs(val - refval) > tol * rmax2(fabs(refval), s), __FILE__, __LINE__, "apserv.ap:162");
}

// === ablasf testing unit ===
struct ablasfplayground {
   double v0;
   ae_vector x0;
   ae_vector x1;
   ae_vector x2;
   ae_vector ix0;
   ae_vector ix1;
   ae_vector bx0;
   ae_vector bx1;
   ae_matrix a0;
   ae_matrix a1;
};

static void ablasfplayground_init(void *_p, bool make_automatic) {
   ablasfplayground *p = (ablasfplayground *)_p;
   ae_vector_init(&p->x0, 0, DT_REAL, make_automatic);
   ae_vector_init(&p->x1, 0, DT_REAL, make_automatic);
   ae_vector_init(&p->x2, 0, DT_REAL, make_automatic);
   ae_vector_init(&p->ix0, 0, DT_INT, make_automatic);
   ae_vector_init(&p->ix1, 0, DT_INT, make_automatic);
   ae_vector_init(&p->bx0, 0, DT_BOOL, make_automatic);
   ae_vector_init(&p->bx1, 0, DT_BOOL, make_automatic);
   ae_matrix_init(&p->a0, 0, 0, DT_REAL, make_automatic);
   ae_matrix_init(&p->a1, 0, 0, DT_REAL, make_automatic);
}

static void ablasfplayground_copy(void *_dst, void *_src, bool make_automatic) {
   ablasfplayground *dst = (ablasfplayground *)_dst;
   ablasfplayground *src = (ablasfplayground *)_src;
   dst->v0 = src->v0;
   ae_vector_copy(&dst->x0, &src->x0, make_automatic);
   ae_vector_copy(&dst->x1, &src->x1, make_automatic);
   ae_vector_copy(&dst->x2, &src->x2, make_automatic);
   ae_vector_copy(&dst->ix0, &src->ix0, make_automatic);
   ae_vector_copy(&dst->ix1, &src->ix1, make_automatic);
   ae_vector_copy(&dst->bx0, &src->bx0, make_automatic);
   ae_vector_copy(&dst->bx1, &src->bx1, make_automatic);
   ae_matrix_copy(&dst->a0, &src->a0, make_automatic);
   ae_matrix_copy(&dst->a1, &src->a1, make_automatic);
}

static void ablasfplayground_free(void *_p, bool make_automatic) {
   ablasfplayground *p = (ablasfplayground *)_p;
   ae_vector_free(&p->x0, make_automatic);
   ae_vector_free(&p->x1, make_automatic);
   ae_vector_free(&p->x2, make_automatic);
   ae_vector_free(&p->ix0, make_automatic);
   ae_vector_free(&p->ix1, make_automatic);
   ae_vector_free(&p->bx0, make_automatic);
   ae_vector_free(&p->bx1, make_automatic);
   ae_matrix_free(&p->a0, make_automatic);
   ae_matrix_free(&p->a1, make_automatic);
}

static double refrdotv(ae_int_t n, RVector *x, RVector *y) {
   ae_int_t i;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      result += x->xR[i] * y->xR[i];
   }
   return result;
}

static double refrdotvr(ae_int_t n, RVector *x, RMatrix *a, ae_int_t i) {
   ae_int_t j;
   double result;
   result = 0.0;
   for (j = 0; j < n; j++) {
      result += x->xR[j] * a->xyR[i][j];
   }
   return result;
}

static double refrdotrr(ae_int_t n, RMatrix *a, ae_int_t ia, RMatrix *b, ae_int_t ib) {
   ae_int_t j;
   double result;
   result = 0.0;
   for (j = 0; j < n; j++) {
      result += a->xyR[ia][j] * b->xyR[ib][j];
   }
   return result;
}

static double refrdotv2(ae_int_t n, RVector *x) {
   ae_int_t i;
   double v;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      v = x->xR[i];
      result += v * v;
   }
   return result;
}

static void refraddv(ae_int_t n, double alpha, RVector *y, RVector *x) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xR[i] += alpha * y->xR[i];
   }
}

static void refraddvx(ae_int_t n, double alpha, RVector *y, ae_int_t offsy, RVector *x, ae_int_t offsx) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xR[offsx + i] += alpha * y->xR[offsy + i];
   }
}

static void refraddvc(ae_int_t n, double alpha, RVector *y, RMatrix *x, ae_int_t colidx) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xyR[i][colidx] += alpha * y->xR[i];
   }
}

static void refraddvr(ae_int_t n, double alpha, RVector *y, RMatrix *x, ae_int_t rowidx) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xyR[rowidx][i] += alpha * y->xR[i];
   }
}

static void refraddrv(ae_int_t n, double alpha, RMatrix *y, ae_int_t ridx, RVector *x) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xR[i] += alpha * y->xyR[ridx][i];
   }
}

static void refraddrr(ae_int_t n, double alpha, RMatrix *y, ae_int_t ridxsrc, RMatrix *x, ae_int_t ridxdst) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xyR[ridxdst][i] += alpha * y->xyR[ridxsrc][i];
   }
}

static void refrsetv(ae_int_t n, double v, RVector *x) {
   ae_int_t j;
   for (j = 0; j < n; j++) {
      x->xR[j] = v;
   }
}

static void refrsetvx(ae_int_t n, double v, RVector *x, ae_int_t offsx) {
   ae_int_t j;
   for (j = 0; j < n; j++) {
      x->xR[offsx + j] = v;
   }
}

static void refisetv(ae_int_t n, ae_int_t v, ZVector *x) {
   ae_int_t j;
   for (j = 0; j < n; j++) {
      x->xZ[j] = v;
   }
}

static void refbsetv(ae_int_t n, bool v, BVector *x) {
   ae_int_t j;
   for (j = 0; j < n; j++) {
      x->xB[j] = v;
   }
}

static void refrsetm(ae_int_t m, ae_int_t n, double v, RMatrix *a) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         a->xyR[i][j] = v;
      }
   }
}

static void refrsetr(ae_int_t n, double v, RMatrix *a, ae_int_t i) {
   ae_int_t j;
   for (j = 0; j < n; j++) {
      a->xyR[i][j] = v;
   }
}

static void refrsetc(ae_int_t n, double v, RMatrix *a, ae_int_t j) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      a->xyR[i][j] = v;
   }
}

static void refrcopyv(ae_int_t n, RVector *x, RVector *y) {
   ae_int_t j;
   for (j = 0; j < n; j++) {
      y->xR[j] = x->xR[j];
   }
}

static void refbcopyv(ae_int_t n, BVector *x, BVector *y) {
   ae_int_t j;
   for (j = 0; j < n; j++) {
      y->xB[j] = x->xB[j];
   }
}

static void refrcopyvx(ae_int_t n, RVector *x, ae_int_t offsx, RVector *y, ae_int_t offsy) {
   ae_int_t j;
   for (j = 0; j < n; j++) {
      y->xR[offsy + j] = x->xR[offsx + j];
   }
}

static void reficopyv(ae_int_t n, ZVector *x, ZVector *y) {
   ae_int_t j;
   for (j = 0; j < n; j++) {
      y->xZ[j] = x->xZ[j];
   }
}

static void reficopyvx(ae_int_t n, ZVector *x, ae_int_t offsx, ZVector *y, ae_int_t offsy) {
   ae_int_t j;
   for (j = 0; j < n; j++) {
      y->xZ[offsy + j] = x->xZ[offsx + j];
   }
}

static void refrcopyvr(ae_int_t n, RVector *x, RMatrix *a, ae_int_t i) {
   ae_int_t j;
   for (j = 0; j < n; j++) {
      a->xyR[i][j] = x->xR[j];
   }
}

static void refrcopyrv(ae_int_t n, RMatrix *a, ae_int_t i, RVector *x) {
   ae_int_t j;
   for (j = 0; j < n; j++) {
      x->xR[j] = a->xyR[i][j];
   }
}

static void refrcopyrr(ae_int_t n, RMatrix *a, ae_int_t i, RMatrix *b, ae_int_t k) {
   ae_int_t j;
   for (j = 0; j < n; j++) {
      b->xyR[k][j] = a->xyR[i][j];
   }
}

static void refrcopyvc(ae_int_t n, RVector *x, RMatrix *a, ae_int_t j) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      a->xyR[i][j] = x->xR[i];
   }
}

static void refrcopycv(ae_int_t n, RMatrix *a, ae_int_t j, RVector *x) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xR[i] = a->xyR[i][j];
   }
}

static void refrcopymulv(ae_int_t n, double v, RVector *x, RVector *y) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      y->xR[i] = v * x->xR[i];
   }
}

static void refrcopymulvr(ae_int_t n, double v, RVector *x, RMatrix *y, ae_int_t ridx) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      y->xyR[ridx][i] = v * x->xR[i];
   }
}

static void refrcopymulvc(ae_int_t n, double v, RVector *x, RMatrix *y, ae_int_t cidx) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      y->xyR[i][cidx] = v * x->xR[i];
   }
}

static void refrmulv(ae_int_t n, double v, RVector *x) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xR[i] *= v;
   }
}

static void refrmulr(ae_int_t n, double v, RMatrix *x, ae_int_t rowidx) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xyR[rowidx][i] *= v;
   }
}

static void refrmulvx(ae_int_t n, double v, RVector *x, ae_int_t offsx) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xR[offsx + i] *= v;
   }
}

static void refrmergemulv(ae_int_t n, RVector *y, RVector *x) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xR[i] *= y->xR[i];
   }
}

static void refrmergemulvr(ae_int_t n, RVector *y, RMatrix *x, ae_int_t rowidx) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xyR[rowidx][i] *= y->xR[i];
   }
}

static void refrmergemulrv(ae_int_t n, RMatrix *y, ae_int_t rowidx, RVector *x) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xR[i] *= y->xyR[rowidx][i];
   }
}

static void refrmergemaxv(ae_int_t n, RVector *y, RVector *x) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xR[i] = rmax2(x->xR[i], y->xR[i]);
   }
}

static void refrmergemaxvr(ae_int_t n, RVector *y, RMatrix *x, ae_int_t rowidx) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xyR[rowidx][i] = rmax2(x->xyR[rowidx][i], y->xR[i]);
   }
}

static void refrmergemaxrv(ae_int_t n, RMatrix *y, ae_int_t rowidx, RVector *x) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xR[i] = rmax2(x->xR[i], y->xyR[rowidx][i]);
   }
}

static void refrmergeminv(ae_int_t n, RVector *y, RVector *x) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xR[i] = rmin2(x->xR[i], y->xR[i]);
   }
}

static void refrmergeminvr(ae_int_t n, RVector *y, RMatrix *x, ae_int_t rowidx) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xyR[rowidx][i] = rmin2(x->xyR[rowidx][i], y->xR[i]);
   }
}

static void refrmergeminrv(ae_int_t n, RMatrix *y, ae_int_t rowidx, RVector *x) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      x->xR[i] = rmin2(x->xR[i], y->xyR[rowidx][i]);
   }
}

static double refrmaxv(ae_int_t n, RVector *x) {
   ae_int_t i;
   double v;
   double result;
   if (n <= 0) {
      result = 0.0;
      return result;
   }
   result = x->xR[0];
   for (i = 0; i < n; i++) {
      v = x->xR[i];
      if (v > result) {
         result = v;
      }
   }
   return result;
}

static double refrmaxabsv(ae_int_t n, RVector *x) {
   ae_int_t i;
   double v;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      v = fabs(x->xR[i]);
      if (v > result) {
         result = v;
      }
   }
   return result;
}

static double refrmaxr(ae_int_t n, RMatrix *x, ae_int_t rowidx) {
   ae_int_t i;
   double v;
   double result;
   if (n <= 0) {
      result = 0.0;
      return result;
   }
   result = x->xyR[rowidx][0];
   for (i = 0; i < n; i++) {
      v = x->xyR[rowidx][i];
      if (v > result) {
         result = v;
      }
   }
   return result;
}

static double refrmaxabsr(ae_int_t n, RMatrix *x, ae_int_t rowidx) {
   ae_int_t i;
   double v;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      v = fabs(x->xyR[rowidx][i]);
      if (v > result) {
         result = v;
      }
   }
   return result;
}

static void refrgemvx(ae_int_t m, ae_int_t n, double alpha, RMatrix *a, ae_int_t ia, ae_int_t ja, ae_int_t opa, RVector *x, ae_int_t ix, double beta, RVector *y, ae_int_t iy) {
   ae_int_t i;
   double v;
// Quick exit for M=0, N=0 or Alpha=0.
//
// After this block we have M>0, N>0, Alpha != 0.
   if (m <= 0) {
      return;
   }
   if (n <= 0 || alpha == 0.0) {
      if (beta != 0.0) {
         for (i = 0; i < m; i++) {
            y->xR[iy + i] *= beta;
         }
      } else {
         for (i = 0; i < m; i++) {
            y->xR[iy + i] = 0.0;
         }
      }
      return;
   }
// Generic code
   if (opa == 0) {
   // y = A*x
      for (i = 0; i < m; i++) {
         v = ae_v_dotproduct(&a->xyR[ia + i][ja], 1, &x->xR[ix], 1, n);
         if (beta == 0.0) {
            y->xR[iy + i] = alpha * v;
         } else {
            y->xR[iy + i] = alpha * v + beta * y->xR[iy + i];
         }
      }
      return;
   }
   if (opa == 1) {
   // Prepare output array
      if (beta == 0.0) {
         for (i = 0; i < m; i++) {
            y->xR[iy + i] = 0.0;
         }
      } else {
         for (i = 0; i < m; i++) {
            y->xR[iy + i] *= beta;
         }
      }
   // y += A^T*x
      for (i = 0; i < n; i++) {
         v = alpha * x->xR[ix + i];
         ae_v_addd(&y->xR[iy], 1, &a->xyR[ia + i][ja], 1, iy + m - iy, v);
      }
      return;
   }
}

// Reference TRSV
static void reftrsvx(ae_int_t n, RMatrix *a, ae_int_t ia, ae_int_t ja, bool isupper, bool isunit, ae_int_t optype, RVector *x, ae_int_t ix) {
   ae_int_t i;
   ae_int_t j;
   double v;
// Quick exit
   if (n <= 0) {
      return;
   }
// Generic code
   if (optype == 0 && isupper) {
      for (i = n - 1; i >= 0; i--) {
         v = x->xR[ix + i];
         for (j = i + 1; j < n; j++) {
            v -= a->xyR[ia + i][ja + j] * x->xR[ix + j];
         }
         if (!isunit) {
            v /= a->xyR[ia + i][ja + i];
         }
         x->xR[ix + i] = v;
      }
      return;
   }
   if (optype == 0 && !isupper) {
      for (i = 0; i < n; i++) {
         v = x->xR[ix + i];
         for (j = 0; j < i; j++) {
            v -= a->xyR[ia + i][ja + j] * x->xR[ix + j];
         }
         if (!isunit) {
            v /= a->xyR[ia + i][ja + i];
         }
         x->xR[ix + i] = v;
      }
      return;
   }
   if (optype == 1 && isupper) {
      for (i = 0; i < n; i++) {
         v = x->xR[ix + i];
         if (!isunit) {
            v /= a->xyR[ia + i][ja + i];
         }
         x->xR[ix + i] = v;
         if (v == 0) {
            continue;
         }
         for (j = i + 1; j < n; j++) {
            x->xR[ix + j] -= v * a->xyR[ia + i][ja + j];
         }
      }
      return;
   }
   if (optype == 1 && !isupper) {
      for (i = n - 1; i >= 0; i--) {
         v = x->xR[ix + i];
         if (!isunit) {
            v /= a->xyR[ia + i][ja + i];
         }
         x->xR[ix + i] = v;
         if (v == 0) {
            continue;
         }
         for (j = 0; j < i; j++) {
            x->xR[ix + j] -= v * a->xyR[ia + i][ja + j];
         }
      }
      return;
   }
   ae_assert(false, "RMatrixTRSV: unexpected operation type");
}

static ae_int_t testablasfunit_pseudorandominit1(RVector *x, ae_int_t iseed) {
   ae_int_t i;
   ae_int_t result;
   for (i = 0; i < x->cnt; i++) {
      x->xR[i] = sin(iseed + sin((double)i));
      iseed++;
   }
   result = iseed;
   return result;
}

static ae_int_t testablasfunit_pseudorandominit1i(ZVector *x, ae_int_t iseed) {
   ae_int_t i;
   ae_int_t result;
   for (i = 0; i < x->cnt; i++) {
      x->xZ[i] = iround(100 * sin(iseed + sin((double)i)));
      iseed++;
   }
   result = iseed;
   return result;
}

static ae_int_t testablasfunit_pseudorandominit1b(BVector *x, ae_int_t iseed) {
   ae_int_t i;
   ae_int_t result;
   for (i = 0; i < x->cnt; i++) {
      x->xB[i] = sin(iseed + sin((double)i)) > 0.0;
      iseed++;
   }
   result = iseed;
   return result;
}

static ae_int_t testablasfunit_pseudorandominit2(RMatrix *x, ae_int_t iseed) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t result;
   ae_frame_make(&_frame_block);
   NewVector(xr, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   ae_vector_set_length(&xr, x->rows);
   for (i = 0; i < x->rows; i++) {
      xr.xR[i] = sin((double)(13 + 2 * i + iseed));
   }
   iseed++;
   ae_vector_set_length(&xc, x->cols);
   for (j = 0; j < x->cols; j++) {
      xc.xR[j] = sin((double)(17 + 3 * j + iseed));
   }
   iseed++;
   for (i = 0; i < x->rows; i++) {
      for (j = 0; j < x->cols; j++) {
         x->xyR[i][j] = xr.xR[i] + xc.xR[j];
         while (x->xyR[i][j] > 1.0) {
            x->xyR[i][j]--;
         }
         while (x->xyR[i][j] < -1.0) {
            x->xyR[i][j]++;
         }
      }
   }
   result = iseed;
   ae_frame_leave();
   return result;
}

static void testablasfunit_initplayground(ae_int_t minlen, ae_int_t iseed, ablasfplayground *s) {
   ae_int_t maxpad;
   ae_int_t k;
   SetObj(ablasfplayground, s);
   maxpad = 10;
   k = iseed + iseed * iseed * iseed;
   ae_vector_set_length(&s->x0, minlen + iround(maxpad * sqr(sin((double)k))));
   k++;
   ae_vector_set_length(&s->x1, minlen + iround(maxpad * sqr(sin((double)k))));
   k++;
   ae_vector_set_length(&s->x2, minlen + iround(maxpad * sqr(sin((double)k))));
   k++;
   ae_vector_set_length(&s->ix0, minlen + iround(maxpad * sqr(sin((double)k))));
   k++;
   ae_vector_set_length(&s->ix1, minlen + iround(maxpad * sqr(sin((double)k))));
   k++;
   ae_vector_set_length(&s->bx0, minlen + iround(maxpad * sqr(sin((double)k))));
   k++;
   ae_vector_set_length(&s->bx1, minlen + iround(maxpad * sqr(sin((double)k))));
   k++;
   ae_matrix_set_length(&s->a0, minlen + iround(maxpad * sqr(sin((double)k))), minlen + iround(maxpad * sqr(sin((double)(k + 1)))));
   k += 2;
   ae_matrix_set_length(&s->a1, minlen + iround(maxpad * sqr(sin((double)k))), minlen + iround(maxpad * sqr(sin((double)(k + 1)))));
   k += 2;
   s->v0 = 0.0;
   k = testablasfunit_pseudorandominit1(&s->x0, k);
   k = testablasfunit_pseudorandominit1(&s->x1, k);
   k = testablasfunit_pseudorandominit1(&s->x2, k);
   k = testablasfunit_pseudorandominit1i(&s->ix0, k);
   k = testablasfunit_pseudorandominit1i(&s->ix1, k);
   k = testablasfunit_pseudorandominit1b(&s->bx0, k);
   k = testablasfunit_pseudorandominit1b(&s->bx1, k);
   k = testablasfunit_pseudorandominit2(&s->a0, k);
   k = testablasfunit_pseudorandominit2(&s->a1, k);
}

static double testablasfunit_rmx3(double r0, double r1, double r2) {
   double result;
   result = r0;
   if (r1 > result) {
      result = r1;
   }
   if (r2 > result) {
      result = r2;
   }
   return result;
}

static double testablasfunit_rcmp1(RVector *x, RVector *y) {
   ae_int_t i;
   double mx;
   double result;
   ae_assert(x->cnt == y->cnt, "rcmp1: sizes do not match");
   result = 0.0;
   mx = 1.0;
   for (i = 0; i < x->cnt; i++) {
      result = rmax2(result, fabs(x->xR[i] - y->xR[i]));
      mx = rmax2(mx, fabs(x->xR[i]));
      mx = rmax2(mx, fabs(y->xR[i]));
   }
   result /= mx;
   return result;
}

static double testablasfunit_icmp1(ZVector *x, ZVector *y) {
   ae_int_t i;
   double result;
   ae_assert(x->cnt == y->cnt, "rcmp1: sizes do not match");
   result = 0.0;
   for (i = 0; i < x->cnt; i++) {
      result = rmax2(result, fabs((double)(x->xZ[i] - y->xZ[i])));
   }
   return result;
}

static double testablasfunit_bcmp1(BVector *x, BVector *y) {
   ae_int_t i;
   double result;
   ae_assert(x->cnt == y->cnt, "rcmp1: sizes do not match");
   result = 0.0;
   for (i = 0; i < x->cnt; i++) {
      if (x->xB[i] != y->xB[i]) {
         result = 1.0;
      }
   }
   return result;
}

static double testablasfunit_rcmp2(RMatrix *x, RMatrix *y) {
   ae_int_t i;
   ae_int_t j;
   double mx;
   double result;
   ae_assert(x->rows == y->rows, "rcmp2: rows do not match");
   ae_assert(x->cols == y->cols, "rcmp2: cols do not match");
   result = 0.0;
   mx = 1.0;
   for (i = 0; i < x->rows; i++) {
      for (j = 0; j < x->cols; j++) {
         result = rmax2(result, fabs(x->xyR[i][j] - y->xyR[i][j]));
         mx = rmax2(mx, fabs(x->xyR[i][j]));
         mx = rmax2(mx, fabs(y->xyR[i][j]));
      }
   }
   result /= mx;
   return result;
}

static double testablasfunit_compareplaygrounds(ablasfplayground *s0, ablasfplayground *s1) {
   double result;
   result = 0.0;
   result = rmax2(result, fabs(s0->v0 - s1->v0) / testablasfunit_rmx3(fabs(s0->v0), fabs(s1->v0), 1.0));
   result = rmax2(result, testablasfunit_rcmp1(&s0->x0, &s1->x0));
   result = rmax2(result, testablasfunit_rcmp1(&s0->x1, &s1->x1));
   result = rmax2(result, testablasfunit_icmp1(&s0->ix0, &s1->ix0));
   result = rmax2(result, testablasfunit_icmp1(&s0->ix1, &s1->ix1));
   result = rmax2(result, testablasfunit_bcmp1(&s0->bx0, &s1->bx0));
   result = rmax2(result, testablasfunit_bcmp1(&s0->bx1, &s1->bx1));
   result = rmax2(result, testablasfunit_rcmp1(&s0->x2, &s1->x2));
   result = rmax2(result, testablasfunit_rcmp2(&s0->a0, &s1->a0));
   result = rmax2(result, testablasfunit_rcmp2(&s0->a1, &s1->a1));
   return result;
}

static bool testablasfunit_testxdot(ae_int_t maxn, double tol) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t iseed;
   ae_int_t ridx;
   ae_int_t ridx2;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(ablasfplayground, s0);
   NewObj(ablasfplayground, s1);
   iseed = randominteger(10000);
   result = false;
   for (n = 0; n <= maxn; n++) {
   // Prepare two identical playground structures
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      iseed++;
   // Compute each rDot version twice - reference vs library.
   // Compare playground snapshots - should be identical.
      ridx = randominteger(imax2(n, 1));
      ridx2 = randominteger(imax2(n, 1));
      set_error_flag(&result, fabs(rdotv(n, &s0.x0, &s0.x1) - refrdotv(n, &s1.x0, &s1.x1)) > tol, __FILE__, __LINE__, "testablasfunit.ap:142");
      set_error_flag(&result, fabs(rdotvr(n, &s0.x0, &s0.a0, ridx) - refrdotvr(n, &s1.x0, &s1.a0, ridx)) > tol, __FILE__, __LINE__, "testablasfunit.ap:143");
      set_error_flag(&result, fabs(rdotrr(n, &s0.a0, ridx, &s0.a1, ridx2) - refrdotrr(n, &s1.a0, ridx, &s1.a1, ridx2)) > tol, __FILE__, __LINE__, "testablasfunit.ap:144");
      set_error_flag(&result, fabs(rdotv2(n, &s0.x0) - refrdotv2(n, &s1.x0)) > tol, __FILE__, __LINE__, "testablasfunit.ap:145");
   }
   ae_frame_leave();
   return result;
}

static bool testablasfunit_testxset(ae_int_t maxn, double tol) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t iseed;
   double alpha;
   ae_int_t ialpha;
   bool balpha;
   ae_int_t ridx;
   ae_int_t cidx;
   ae_int_t m0;
   ae_int_t m1;
   ae_int_t offsx;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(ablasfplayground, s0);
   NewObj(ablasfplayground, s1);
   iseed = randominteger(10000);
   result = false;
   for (n = 0; n <= maxn; n++) {
   // Prepare two identical playground structures
   // Compute each xSetXX version twice - reference vs library.
   // Compare playground snapshots - should be identical.
      m0 = randominteger(imax2(n, 1));
      m1 = randominteger(imax2(n, 1));
      ridx = randominteger(imax2(n, 1));
      cidx = randominteger(imax2(n, 1));
      offsx = randominteger(n / 2 + 1);
      alpha = randommid();
      ialpha = randominteger(21) - 10;
      balpha = randombool();
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rsetv(n, alpha, &s0.x0);
      refrsetv(n, alpha, &s1.x0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:183");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rsetr(n, alpha, &s0.a0, ridx);
      refrsetr(n, alpha, &s1.a0, ridx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:189");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rsetc(n, alpha, &s0.a0, cidx);
      refrsetc(n, alpha, &s1.a0, cidx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:195");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rsetm(m0, m1, alpha, &s0.a0);
      refrsetm(m0, m1, alpha, &s1.a0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:201");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      isetv(n, ialpha, &s0.ix0);
      refisetv(n, ialpha, &s1.ix0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:207");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      bsetv(n, balpha, &s0.bx0);
      refbsetv(n, balpha, &s1.bx0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:213");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rsetvx(n / 2, alpha, &s0.x0, offsx);
      refrsetvx(n / 2, alpha, &s1.x0, offsx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:219");
   // Increment seed
      iseed++;
   }
   ae_frame_leave();
   return result;
}

static bool testablasfunit_testxadd(ae_int_t maxn, double tol) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t iseed;
   double alpha;
   ae_int_t ridx;
   ae_int_t ridx2;
   ae_int_t cidx;
   ae_int_t offsx;
   ae_int_t offsy;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(ablasfplayground, s0);
   NewObj(ablasfplayground, s1);
   iseed = randominteger(10000);
   result = false;
   for (n = 0; n <= maxn; n++) {
   // Prepare two identical playground structures
   // Compute each xAddXX version twice - reference vs library.
   // Compare playground snapshots - should be identical.
      ridx = randominteger(imax2(n, 1));
      ridx2 = randominteger(imax2(n, 1));
      cidx = randominteger(imax2(n, 1));
      offsx = randominteger(n / 2 + 1);
      offsy = randominteger(n / 2 + 1);
      alpha = randommid();
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      raddv(n, alpha, &s0.x0, &s0.x1);
      refraddv(n, alpha, &s1.x0, &s1.x1);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:257");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      raddvr(n, alpha, &s0.x0, &s0.a0, cidx);
      refraddvr(n, alpha, &s1.x0, &s1.a0, cidx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:263");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      raddvc(n, alpha, &s0.x0, &s0.a0, cidx);
      refraddvc(n, alpha, &s1.x0, &s1.a0, cidx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:269");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      raddrv(n, alpha, &s0.a0, ridx, &s0.x0);
      refraddrv(n, alpha, &s1.a0, ridx, &s1.x0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:275");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      raddrr(n, alpha, &s0.a0, ridx, &s0.a1, ridx2);
      refraddrr(n, alpha, &s1.a0, ridx, &s1.a1, ridx2);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:281");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      raddvx(n / 2, alpha, &s0.x0, offsx, &s0.x1, offsy);
      refraddvx(n / 2, alpha, &s1.x0, offsx, &s1.x1, offsy);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:287");
   // Increment seed
      iseed++;
   }
   ae_frame_leave();
   return result;
}

static bool testablasfunit_testxmul(ae_int_t maxn, double tol) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t iseed;
   double alpha;
   ae_int_t ridx;
   ae_int_t offsx;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(ablasfplayground, s0);
   NewObj(ablasfplayground, s1);
   iseed = randominteger(10000);
   result = false;
   for (n = 0; n <= maxn; n++) {
   // Prepare two identical playground structures
   // Compute each xAddXX version twice - reference vs library.
   // Compare playground snapshots - should be identical.
      ridx = randominteger(imax2(n, 1));
      offsx = randominteger(n / 2 + 1);
      alpha = randommid();
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rmulv(n, alpha, &s0.x0);
      refrmulv(n, alpha, &s1.x0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:322");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rmulr(n, alpha, &s0.a0, ridx);
      refrmulr(n, alpha, &s1.a0, ridx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:328");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rmulvx(n / 2, alpha, &s0.x0, offsx);
      refrmulvx(n / 2, alpha, &s1.x0, offsx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:334");
   // Increment seed
      iseed++;
   }
   ae_frame_leave();
   return result;
}

static bool testablasfunit_testxmax(ae_int_t maxn, double tol) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t iseed;
   ae_int_t ridx;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(ablasfplayground, s0);
   NewObj(ablasfplayground, s1);
   iseed = randominteger(10000);
   result = false;
   for (n = 0; n <= maxn; n++) {
   // Prepare two identical playground structures
   // Compute each xAddXX version twice - reference vs library.
   // Compare playground snapshots - should be identical.
      ridx = randominteger(imax2(n, 1));
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      s0.v0 = rmaxv(n, &s0.x0);
      s1.v0 = refrmaxv(n, &s1.x0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:365");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      s0.v0 = rmaxabsv(n, &s0.x0);
      s1.v0 = refrmaxabsv(n, &s1.x0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:371");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      s0.v0 = rmaxr(n, &s0.a0, ridx);
      s1.v0 = refrmaxr(n, &s1.a0, ridx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:377");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      s0.v0 = rmaxabsr(n, &s0.a0, ridx);
      s1.v0 = refrmaxabsr(n, &s1.a0, ridx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:383");
   // Increment seed
      iseed++;
   }
   ae_frame_leave();
   return result;
}

static bool testablasfunit_testxmerge(ae_int_t maxn, double tol) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t iseed;
   ae_int_t ridx;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(ablasfplayground, s0);
   NewObj(ablasfplayground, s1);
   iseed = randominteger(10000);
   result = false;
   for (n = 0; n <= maxn; n++) {
   // Prepare two identical playground structures
   // Compute each xAddXX version twice - reference vs library.
   // Compare playground snapshots - should be identical.
      ridx = randominteger(imax2(n, 1));
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rmergemulv(n, &s0.x0, &s0.x1);
      refrmergemulv(n, &s1.x0, &s1.x1);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:414");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rmergemulvr(n, &s0.x0, &s0.a0, ridx);
      refrmergemulvr(n, &s1.x0, &s1.a0, ridx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:420");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rmergemulrv(n, &s0.a0, ridx, &s0.x0);
      refrmergemulrv(n, &s1.a0, ridx, &s1.x0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:426");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rmergemaxv(n, &s0.x0, &s0.x1);
      refrmergemaxv(n, &s1.x0, &s1.x1);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:432");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rmergemaxvr(n, &s0.x0, &s0.a0, ridx);
      refrmergemaxvr(n, &s1.x0, &s1.a0, ridx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:438");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rmergemaxrv(n, &s0.a0, ridx, &s0.x0);
      refrmergemaxrv(n, &s1.a0, ridx, &s1.x0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:444");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rmergeminv(n, &s0.x0, &s0.x1);
      refrmergeminv(n, &s1.x0, &s1.x1);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:450");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rmergeminvr(n, &s0.x0, &s0.a0, ridx);
      refrmergeminvr(n, &s1.x0, &s1.a0, ridx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:456");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rmergeminrv(n, &s0.a0, ridx, &s0.x0);
      refrmergeminrv(n, &s1.a0, ridx, &s1.x0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:462");
   // Increment seed
      iseed++;
   }
   ae_frame_leave();
   return result;
}

static bool testablasfunit_testxcopy(ae_int_t maxn, double tol) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t iseed;
   double alpha;
   ae_int_t ridx;
   ae_int_t ridx2;
   ae_int_t cidx;
   ae_int_t offsx;
   ae_int_t offsy;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(ablasfplayground, s0);
   NewObj(ablasfplayground, s1);
   iseed = randominteger(10000);
   result = false;
   for (n = 0; n <= maxn; n++) {
   // Prepare two identical playground structures
   // Compute each xAddXX version twice - reference vs library.
   // Compare playground snapshots - should be identical.
      ridx = randominteger(imax2(n, 1));
      ridx2 = randominteger(imax2(n, 1));
      cidx = randominteger(imax2(n, 1));
      offsx = randominteger(n / 2 + 1);
      offsy = randominteger(n / 2 + 1);
      alpha = randommid();
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rcopyv(n, &s0.x0, &s0.x1);
      refrcopyv(n, &s1.x0, &s1.x1);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:500");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      icopyv(n, &s0.ix0, &s0.ix1);
      reficopyv(n, &s1.ix0, &s1.ix1);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:506");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      bcopyv(n, &s0.bx0, &s0.bx1);
      refbcopyv(n, &s1.bx0, &s1.bx1);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:512");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rcopyvr(n, &s0.x0, &s0.a0, ridx);
      refrcopyvr(n, &s1.x0, &s1.a0, ridx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:518");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rcopyrv(n, &s0.a0, ridx, &s0.x0);
      refrcopyrv(n, &s1.a0, ridx, &s1.x0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:524");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rcopyrr(n, &s0.a0, ridx, &s0.a1, ridx2);
      refrcopyrr(n, &s1.a0, ridx, &s1.a1, ridx2);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:530");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rcopyvc(n, &s0.x0, &s0.a0, cidx);
      refrcopyvc(n, &s1.x0, &s1.a0, cidx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:536");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rcopycv(n, &s0.a0, cidx, &s0.x0);
      refrcopycv(n, &s1.a0, cidx, &s1.x0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:542");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rcopyvx(n / 2, &s0.x0, offsx, &s0.x1, offsy);
      refrcopyvx(n / 2, &s1.x0, offsx, &s1.x1, offsy);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:548");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      icopyvx(n / 2, &s0.ix0, offsx, &s0.ix1, offsy);
      reficopyvx(n / 2, &s1.ix0, offsx, &s1.ix1, offsy);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:554");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rcopymulv(n, alpha, &s0.x0, &s0.x1);
      refrcopymulv(n, alpha, &s1.x0, &s1.x1);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:560");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rcopymulvr(n, alpha, &s0.x0, &s0.a0, ridx);
      refrcopymulvr(n, alpha, &s1.x0, &s1.a0, ridx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:566");
      testablasfunit_initplayground(n, iseed, &s0);
      testablasfunit_initplayground(n, iseed, &s1);
      rcopymulvc(n, alpha, &s0.x0, &s0.a0, cidx);
      refrcopymulvc(n, alpha, &s1.x0, &s1.a0, cidx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:572");
   // Increment seed
      iseed++;
   }
   ae_frame_leave();
   return result;
}

static bool testablasfunit_testxgemv(ae_int_t maxn, double tol) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t iseed;
   double alpha;
   double beta;
   ae_int_t offs0;
   ae_int_t offs1;
   ae_int_t offsx;
   ae_int_t offsy;
   ae_int_t padding;
   ae_int_t opa;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(ablasfplayground, s0);
   NewObj(ablasfplayground, s1);
   iseed = randominteger(10000);
   result = false;
   for (n = 0; n <= maxn; n++) {
   // Prepare two identical playground structures
   // Compute each GEMV version twice - reference vs library.
   // Compare playground snapshots - should be identical.
      padding = randominteger(10);
      m = randominteger(n + 1);
      offs0 = randominteger(imax2(n, 1));
      offs1 = randominteger(imax2(n, 1));
      offsx = randominteger(imax2(n, 1));
      offsy = randominteger(imax2(n, 1));
      alpha = randommid() * randominteger(2);
      beta = randommid() * randominteger(2);
      opa = randominteger(2);
      testablasfunit_initplayground(2 * n + padding, iseed, &s0);
      testablasfunit_initplayground(2 * n + padding, iseed, &s1);
      rgemv(m, n, alpha, &s0.a0, opa, &s0.x0, beta, &s0.x1);
      refrgemvx(m, n, alpha, &s1.a0, 0, 0, opa, &s1.x0, 0, beta, &s1.x1, 0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:615");
      testablasfunit_initplayground(2 * n + padding, iseed, &s0);
      testablasfunit_initplayground(2 * n + padding, iseed, &s1);
      rgemvx(m, n, alpha, &s0.a0, offs0, offs1, opa, &s0.x0, offsx, beta, &s0.x1, offsy);
      refrgemvx(m, n, alpha, &s1.a0, offs0, offs1, opa, &s1.x0, offsx, beta, &s1.x1, offsy);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:621");
   // Increment seed
      iseed++;
   }
   ae_frame_leave();
   return result;
}

// Reference code
//
//      16.10.2017
//      Sergey Bochkanov
static void testablasfunit_refgerx(ae_int_t m, ae_int_t n, RMatrix *a, ae_int_t ia, ae_int_t ja, double alpha, RVector *u, ae_int_t iu, RVector *v, ae_int_t iv) {
   ae_int_t i;
   ae_int_t j;
   double s;
   if ((m <= 0 || n <= 0) || alpha == 0.0) {
      return;
   }
   for (i = 0; i < m; i++) {
      s = alpha * u->xR[iu + i];
      for (j = 0; j < n; j++) {
         a->xyR[ia + i][ja + j] += s * v->xR[iv + j];
      }
   }
}

static bool testablasfunit_testxger(ae_int_t maxn, double tol) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t iseed;
   double alpha;
   ae_int_t padding;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(ablasfplayground, s0);
   NewObj(ablasfplayground, s1);
   iseed = randominteger(10000);
   result = false;
   for (n = 0; n <= maxn; n++) {
   // Prepare two identical playground structures
   // Compute each GER version twice - reference vs library.
   // Compare playground snapshots - should be identical.
      padding = randominteger(10);
      m = randominteger(n + 1);
      alpha = randommid() * randominteger(2);
      testablasfunit_initplayground(2 * n + padding, iseed, &s0);
      testablasfunit_initplayground(2 * n + padding, iseed, &s1);
      rger(m, n, alpha, &s0.x0, &s0.x1, &s0.a0);
      testablasfunit_refgerx(m, n, &s1.a0, 0, 0, alpha, &s1.x0, 0, &s1.x1, 0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:656");
      testablasfunit_initplayground(2 * n + padding, iseed, &s0);
      testablasfunit_initplayground(2 * n + padding, iseed, &s1);
      rger(n, m, alpha, &s0.x0, &s0.x1, &s0.a0);
      testablasfunit_refgerx(n, m, &s1.a0, 0, 0, alpha, &s1.x0, 0, &s1.x1, 0);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:662");
   // Increment seed
      iseed++;
   }
   ae_frame_leave();
   return result;
}

static bool testablasfunit_testxtrsv(ae_int_t maxn, double tol) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t iseed;
   ae_int_t offs0;
   ae_int_t offs1;
   ae_int_t offsx;
   ae_int_t padding;
   ae_int_t opa;
   bool isupper;
   bool isunit;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(ablasfplayground, s0);
   NewObj(ablasfplayground, s1);
   iseed = randominteger(10000);
   result = false;
   for (n = 0; n <= maxn; n++) {
   // Prepare two identical playground structures
   // Compute each GEMV version twice - reference vs library.
   // Compare playground snapshots - should be identical.
      padding = randominteger(10);
      offs0 = randominteger(imax2(n, 1));
      offs1 = randominteger(imax2(n, 1));
      offsx = randominteger(imax2(n, 1));
      opa = randominteger(2);
      isupper = randombool();
      isunit = randombool();
      testablasfunit_initplayground(2 * n + padding, iseed, &s0);
      testablasfunit_initplayground(2 * n + padding, iseed, &s1);
      rtrsvx(n, &s0.a0, offs0, offs1, isupper, isunit, opa, &s0.x0, offsx);
      reftrsvx(n, &s1.a0, offs0, offs1, isupper, isunit, opa, &s1.x0, offsx);
      set_error_flag(&result, testablasfunit_compareplaygrounds(&s0, &s1) > tol, __FILE__, __LINE__, "testablasfunit.ap:703");
   // Increment seed
      iseed++;
   }
   ae_frame_leave();
   return result;
}

bool testablasf(bool silent) {
   ae_int_t maxn;
   double tol;
   bool wereerrors;
   bool xdoterrors;
   bool xseterrors;
   bool xadderrors;
   bool xmulerrors;
   bool xmaxerrors;
   bool xmergeerrors;
   bool xcopyerrors;
   bool xgemverrors;
   bool xgererrors;
   bool xtrsverrors;
   bool result;
   maxn = 100;
   tol = 10000 * machineepsilon;
   xdoterrors = testablasfunit_testxdot(maxn, tol);
   xseterrors = testablasfunit_testxset(maxn, tol);
   xadderrors = testablasfunit_testxadd(maxn, tol);
   xmulerrors = testablasfunit_testxmul(maxn, tol);
   xmaxerrors = testablasfunit_testxmax(maxn, tol);
   xmergeerrors = testablasfunit_testxmerge(maxn, tol);
   xcopyerrors = testablasfunit_testxcopy(maxn, tol);
   xgemverrors = testablasfunit_testxgemv(maxn, tol);
   xgererrors = testablasfunit_testxger(maxn, tol);
   xtrsverrors = testablasfunit_testxtrsv(maxn, tol);
   wereerrors = ((((((((xdoterrors || xseterrors) || xadderrors) || xmulerrors) || xmaxerrors) || xmergeerrors) || xcopyerrors) || xgemverrors) || xgererrors) || xtrsverrors;
// report
   if (!silent) {
      printf("TESTING ABLASF\n");
      printf("xDotXX:                                  ");
      if (xdoterrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("xSetXX:                                  ");
      if (xseterrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("xAddXX:                                  ");
      if (xadderrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("xMulXX:                                  ");
      if (xmulerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("xMaxXX:                                  ");
      if (xmaxerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("xMergeXX:                                ");
      if (xmergeerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("xCopyXX:                                 ");
      if (xcopyerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("xGEMVx:                                  ");
      if (xgemverrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("xGERx:                                   ");
      if (xgererrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("xTRSVx:                                  ");
      if (xtrsverrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (wereerrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !wereerrors;
   return result;
}

// === hqrnd testing unit ===
// Function for test HQRNDContinuous function
static bool hqrndcontinuoustest(bool silent) {
   ae_frame _frame_block;
   ae_int_t nb;
   ae_int_t samplesize;
   ae_int_t xp;
   ae_int_t i;
   ae_int_t j;
   double v;
   double sigma;
   double sigmamax;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(sample, 0, DT_REAL);
   NewVector(bins, 0, DT_INT);
   NewVector(binbounds, 0, DT_REAL);
   NewObj(hqrndstate, state);
   result = false;
// Test for sample size equal to 1
   ae_vector_set_length(&sample, 1);
   sample.xR[0] = randomreal();
   hqrndrandomize(&state);
   result = result || hqrndcontinuous(&state, &sample, 1) != sample.xR[0];
// Test for larger samples
   xp = 100000;
   sigmamax = 10.0;
   for (samplesize = 2; samplesize <= 5; samplesize++) {
   // 1. Generate random sample with SampleSize points
   // 2. Generate NB=3*(SampleSize-1) bins, with bounds as prescribed by (BinBounds[I],BinBounds[I+1]).
   //    Bin bounds are generated in such a way that value can fall into any bin with same probability
   // 3. Generate many random values
   // 4. Calculate number of values which fall into each bin
   // 5. Bins[I] should have binomial distribution with mean XP/NB and
   //    variance XP*(1/NB)*(1-1/NB)
      nb = 3 * (samplesize - 1);
      sigma = sqrt(xp * (1.0 / nb) * (1 - 1.0 / nb));
      ae_vector_set_length(&sample, samplesize);
      sample.xR[0] = randommid();
      for (i = 0; i < samplesize - 1; i++) {
         sample.xR[i + 1] = sample.xR[i] + 0.1 + randomreal();
      }
      ae_vector_set_length(&bins, nb);
      ae_vector_set_length(&binbounds, nb + 1);
      for (i = 0; i < samplesize - 1; i++) {
         bins.xZ[3 * i + 0] = 0;
         bins.xZ[3 * i + 1] = 0;
         bins.xZ[3 * i + 2] = 0;
         binbounds.xR[3 * i + 0] = sample.xR[i];
         binbounds.xR[3 * i + 1] = sample.xR[i] + (sample.xR[i + 1] - sample.xR[i]) / 3;
         binbounds.xR[3 * i + 2] = sample.xR[i] + (sample.xR[i + 1] - sample.xR[i]) * 2 / 3;
      }
      binbounds.xR[nb] = sample.xR[samplesize - 1];
      hqrndrandomize(&state);
      for (i = 0; i < xp; i++) {
         v = hqrndcontinuous(&state, &sample, samplesize);
         for (j = 0; j < nb; j++) {
            if (v > binbounds.xR[j] && v < binbounds.xR[j + 1]) {
               bins.xZ[j]++;
               break;
            }
         }
      }
      for (i = 0; i < nb; i++) {
         result = result || fabs(bins.xZ[i] - (double)xp / nb) > sigma * sigmamax;
      }
   }
   ae_frame_leave();
   return result;
}

// Function for test HQRNDDiscrete function
static bool hqrnddiscretetest(bool silent) {
   ae_frame _frame_block;
   double sigma;
   double sigmathreshold;
   double tsample;
   double max;
   double min;
   ae_int_t i;
   ae_int_t j;
   ae_int_t s1;
   ae_int_t s2;
   ae_int_t binscount;
   ae_int_t xp;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(sample, 0, DT_REAL);
   NewVector(nn, 0, DT_INT);
   NewObj(hqrndstate, state);
// We test that all values from discrete sample are generated with same probability.
// To do this, we generate random values many times, then we calculate actual probabilities
// and compare them with theoretical ones.
   max = 100.0;
   min = -100.0;
   xp = 100000;
   sigmathreshold = 10.0;
   for (binscount = 1; binscount <= 5; binscount++) {
      sigma = sqrt(xp * (1.0 / binscount) * (1 - 1.0 / binscount));
      ae_vector_set_length(&nn, binscount);
      for (i = 0; i < binscount; i++) {
         nn.xZ[i] = 0;
      }
      ae_vector_set_length(&sample, binscount);
      sample.xR[0] = (max - min) * randomreal() + min;
      for (i = 1; i < binscount; i++) {
         sample.xR[i] = sample.xR[i - 1] + max * randomreal() + 0.001;
      }
      s1 = 1 + randominteger(32000);
      s2 = 1 + randominteger(32000);
      hqrndseed(s1, s2, &state);
      for (i = 0; i < xp; i++) {
         tsample = hqrnddiscrete(&state, &sample, binscount);
         for (j = 0; j < binscount; j++) {
            if (tsample == sample.xR[j]) {
               nn.xZ[j]++;
               break;
            }
         }
      }
      for (i = 0; i < binscount; i++) {
         if ((double)nn.xZ[i] < (double)xp / binscount - sigmathreshold * sigma || (double)nn.xZ[i] > (double)xp / binscount + sigmathreshold * sigma) {
            if (!silent) {
               printf("HQRNDDiscreteTest::ErrorReport::\n");
               printf("nn[%0d]=%0d;\n   xp/BinsCount=%0.5f;\n   C*sigma=%0.5f\n", (int)i, (int)nn.xZ[i], (double)xp / binscount, sigmathreshold * sigma);
               printf("HQRNDDiscreteTest: test is FAILED!\n");
            }
            result = true;
            ae_frame_leave();
            return result;
         }
      }
      if (!silent) {
         printf("HQRNDDiscreteTest: test is OK.\n");
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

static void testhqrndunit_calculatemv(RVector *x, ae_int_t n, double *mean, double *means, double *stddev, double *stddevs) {
   ae_int_t i;
   double v1;
   double v2;
   double variance;
   *mean = 0;
   *means = 0;
   *stddev = 0;
   *stddevs = 0;
   *mean = 0.0;
   *means = 1.0;
   *stddev = 0.0;
   *stddevs = 1.0;
   variance = 0.0;
   if (n <= 1) {
      return;
   }
// Mean
   for (i = 0; i < n; i++) {
      *mean += x->xR[i];
   }
   *mean /= n;
// Variance (using corrected two-pass algorithm)
   if (n != 1) {
      v1 = 0.0;
      for (i = 0; i < n; i++) {
         v1 += sqr(x->xR[i] - (*mean));
      }
      v2 = 0.0;
      for (i = 0; i < n; i++) {
         v2 += (x->xR[i] - (*mean));
      }
      v2 = sqr(v2) / n;
      variance = (v1 - v2) / (n - 1);
      if (variance < 0.0) {
         variance = 0.0;
      }
      *stddev = sqrt(variance);
   }
// Errors
   *means = *stddev / sqrt((double)n);
   *stddevs = *stddev * sqrt(2.0) / sqrt((double)(n - 1));
}

// Unsets HQRNDState structure
static void testhqrndunit_unsetstate(hqrndstate *state) {
   state->s1 = 0;
   state->s2 = 0;
   state->magicv = 0;
}

bool testhqrnd(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   ae_int_t samplesize;
   double sigmathreshold;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t pass;
   ae_int_t s1;
   ae_int_t s2;
   ae_int_t i1;
   ae_int_t i2;
   double r1;
   double r2;
   ae_int_t am;
   ae_int_t an;
   double mean;
   double means;
   double stddev;
   double stddevs;
   double lambdav;
   bool seederrors;
   bool urerrors;
   double ursigmaerr;
   bool uierrors;
   double uisigmaerr;
   bool normerrors;
   double normsigmaerr;
   bool unit2errors;
   bool experrors;
   double expsigmaerr;
   bool discreteerr;
   bool continuouserr;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(dx, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(bins, 0, DT_INT);
   NewObj(hqrndstate, state);
   waserrors = false;
   sigmathreshold = 7.0;
   samplesize = 100000 + randominteger(100);
   passcount = 50;
   seederrors = false;
   urerrors = false;
   uierrors = false;
   normerrors = false;
   experrors = false;
   unit2errors = false;
   ae_vector_set_length(&x, samplesize - 1 + 1);
// Test seed errors
   for (pass = 1; pass <= passcount; pass++) {
      s1 = 1 + randominteger(32000);
      s2 = 1 + randominteger(32000);
      testhqrndunit_unsetstate(&state);
      hqrndseed(s1, s2, &state);
      i1 = hqrnduniformi(&state, 100);
      testhqrndunit_unsetstate(&state);
      hqrndseed(s1, s2, &state);
      i2 = hqrnduniformi(&state, 100);
      seederrors = seederrors || i1 != i2;
      testhqrndunit_unsetstate(&state);
      hqrndseed(s1, s2, &state);
      r1 = hqrnduniformr(&state);
      testhqrndunit_unsetstate(&state);
      hqrndseed(s1, s2, &state);
      r2 = hqrnduniformr(&state);
      seederrors = seederrors || r1 != r2;
   }
// Test HQRNDRandomize() and real uniform generator
   testhqrndunit_unsetstate(&state);
   hqrndrandomize(&state);
   ursigmaerr = 0.0;
   for (i = 0; i < samplesize; i++) {
      x.xR[i] = hqrnduniformr(&state);
   }
   for (i = 0; i < samplesize; i++) {
      urerrors = (urerrors || x.xR[i] <= 0.0) || x.xR[i] >= 1.0;
   }
   testhqrndunit_calculatemv(&x, samplesize, &mean, &means, &stddev, &stddevs);
   if (means != 0.0) {
      ursigmaerr = rmax2(ursigmaerr, fabs((mean - 0.5) / means));
   } else {
      urerrors = true;
   }
   if (stddevs != 0.0) {
      ursigmaerr = rmax2(ursigmaerr, fabs((stddev - sqrt(1.0 / 12.0)) / stddevs));
   } else {
      urerrors = true;
   }
   urerrors = urerrors || ursigmaerr > sigmathreshold;
// Test HQRNDRandomize() and integer uniform
   testhqrndunit_unsetstate(&state);
   hqrndrandomize(&state);
   uisigmaerr = 0.0;
   for (n = 2; n <= 10; n++) {
      for (i = 0; i < samplesize; i++) {
         x.xR[i] = (double)hqrnduniformi(&state, n);
      }
      for (i = 0; i < samplesize; i++) {
         uierrors = (uierrors || x.xR[i] < 0.0) || x.xR[i] >= (double)n;
      }
      testhqrndunit_calculatemv(&x, samplesize, &mean, &means, &stddev, &stddevs);
      if (means != 0.0) {
         uisigmaerr = rmax2(uisigmaerr, fabs((mean - 0.5 * (n - 1)) / means));
      } else {
         uierrors = true;
      }
      if (stddevs != 0.0) {
         uisigmaerr = rmax2(uisigmaerr, fabs((stddev - sqrt((sqr((double)n) - 1) / 12)) / stddevs));
      } else {
         uierrors = true;
      }
   }
   uierrors = uierrors || uisigmaerr > sigmathreshold;
// Special 'close-to-limit' test on uniformity of integers
// (straightforward implementation like 'RND mod N' will return
//  non-uniform numbers for N=2/3*LIMIT)
   testhqrndunit_unsetstate(&state);
   hqrndrandomize(&state);
   uisigmaerr = 0.0;
   n = 1431655708;
   for (i = 0; i < samplesize; i++) {
      x.xR[i] = (double)hqrnduniformi(&state, n);
   }
   for (i = 0; i < samplesize; i++) {
      uierrors = (uierrors || x.xR[i] < 0.0) || x.xR[i] >= (double)n;
   }
   testhqrndunit_calculatemv(&x, samplesize, &mean, &means, &stddev, &stddevs);
   if (means != 0.0) {
      uisigmaerr = rmax2(uisigmaerr, fabs((mean - 0.5 * (n - 1)) / means));
   } else {
      uierrors = true;
   }
   if (stddevs != 0.0) {
      uisigmaerr = rmax2(uisigmaerr, fabs((stddev - sqrt((sqr((double)n) - 1) / 12)) / stddevs));
   } else {
      uierrors = true;
   }
   uierrors = uierrors || uisigmaerr > sigmathreshold;
// Test normal
   testhqrndunit_unsetstate(&state);
   hqrndrandomize(&state);
   i = 0;
   while (i < samplesize) {
      hqrndnormal2(&state, &r1, &r2);
      x.xR[i] = r1;
      if (i + 1 < samplesize) {
         x.xR[i + 1] = r2;
      }
      i += 2;
   }
   normsigmaerr = 0.0;
   testhqrndunit_calculatemv(&x, samplesize, &mean, &means, &stddev, &stddevs);
   if (means != 0.0) {
      normsigmaerr = rmax2(normsigmaerr, fabs((mean - 0) / means));
   } else {
      normerrors = true;
   }
   if (stddevs != 0.0) {
      normsigmaerr = rmax2(normsigmaerr, fabs((stddev - 1) / stddevs));
   } else {
      normerrors = true;
   }
   set_error_flag(&normerrors, normsigmaerr > sigmathreshold, __FILE__, __LINE__, "testhqrndunit.ap:230");
   ae_vector_set_length(&x, 0);
   hqrndnormalv(&state, samplesize, &x);
   set_error_flag(&normerrors, x.cnt != samplesize, __FILE__, __LINE__, "testhqrndunit.ap:233");
   set_error_flag(&normerrors, !isfinitevector(&x, samplesize), __FILE__, __LINE__, "testhqrndunit.ap:234");
   if (!normerrors) {
   // Check mean/sigma of the distribution
      testhqrndunit_calculatemv(&x, samplesize, &mean, &means, &stddev, &stddevs);
      set_error_flag(&normerrors, means == 0.0, __FILE__, __LINE__, "testhqrndunit.ap:241");
      set_error_flag(&normerrors, stddevs == 0.0, __FILE__, __LINE__, "testhqrndunit.ap:242");
      normsigmaerr = 0.0;
      normsigmaerr = rmax2(normsigmaerr, fabs((mean - 0) / coalesce(means, 1.0)));
      normsigmaerr = rmax2(normsigmaerr, fabs((stddev - 1) / coalesce(stddevs, 1.0)));
      set_error_flag(&normerrors, normsigmaerr > sigmathreshold, __FILE__, __LINE__, "testhqrndunit.ap:246");
   // Check that subsequent differences are normally distributed too
      ae_vector_set_length(&dx, samplesize - 1);
      for (i = 0; i < samplesize - 1; i++) {
         dx.xR[i] = x.xR[i + 1] - x.xR[i];
      }
      testhqrndunit_calculatemv(&dx, samplesize - 1, &mean, &means, &stddev, &stddevs);
      set_error_flag(&normerrors, means == 0.0, __FILE__, __LINE__, "testhqrndunit.ap:255");
      set_error_flag(&normerrors, stddevs == 0.0, __FILE__, __LINE__, "testhqrndunit.ap:256");
      normsigmaerr = 0.0;
      normsigmaerr = rmax2(normsigmaerr, fabs((mean - 0) / coalesce(means, 1.0)));
      normsigmaerr = rmax2(normsigmaerr, fabs((stddev - sqrt(2.0)) / coalesce(stddevs, 1.0)));
      set_error_flag(&normerrors, normsigmaerr > sigmathreshold, __FILE__, __LINE__, "testhqrndunit.ap:260");
   }
   am = 1 + randominteger(iround(sqrt((double)samplesize)));
   an = 1 + samplesize / am;
   hqrndnormalm(&state, am, an, &a);
   set_error_flag(&normerrors, a.rows != am, __FILE__, __LINE__, "testhqrndunit.ap:265");
   set_error_flag(&normerrors, a.cols != an, __FILE__, __LINE__, "testhqrndunit.ap:266");
   set_error_flag(&normerrors, !apservisfinitematrix(&a, am, an), __FILE__, __LINE__, "testhqrndunit.ap:267");
   ae_vector_set_length(&x, am * an);
   for (i = 0; i < am; i++) {
      for (j = 0; j < an; j++) {
         x.xR[i * an + j] = a.xyR[i][j];
      }
   }
   testhqrndunit_calculatemv(&x, am * an, &mean, &means, &stddev, &stddevs);
   set_error_flag(&normerrors, means == 0.0, __FILE__, __LINE__, "testhqrndunit.ap:273");
   set_error_flag(&normerrors, stddevs == 0.0, __FILE__, __LINE__, "testhqrndunit.ap:274");
   normsigmaerr = 0.0;
   normsigmaerr = rmax2(normsigmaerr, fabs((mean - 0) / coalesce(means, 1.0)));
   normsigmaerr = rmax2(normsigmaerr, fabs((stddev - 1) / coalesce(stddevs, 1.0)));
   set_error_flag(&normerrors, normsigmaerr > sigmathreshold, __FILE__, __LINE__, "testhqrndunit.ap:278");
// Test unit2
   testhqrndunit_unsetstate(&state);
   hqrndrandomize(&state);
   n = 1000000;
   ae_vector_set_length(&bins, 10);
   for (i = 0; i < bins.cnt; i++) {
      bins.xZ[i] = 0;
   }
   for (pass = 0; pass < n; pass++) {
      hqrndunit2(&state, &r1, &r2);
      set_error_flag(&unit2errors, fabs(r1 * r1 + r2 * r2 - 1) > 100 * machineepsilon, __FILE__, __LINE__, "testhqrndunit.ap:292");
      k = ifloor((atan2(r1, r2) + pi) / (2 * pi) * bins.cnt);
      if (k < 0) {
         k = 0;
      }
      if (k >= bins.cnt) {
         k = bins.cnt - 1;
      }
      bins.xZ[k]++;
   }
   for (i = 0; i < bins.cnt; i++) {
      set_error_flag(&unit2errors, (double)bins.xZ[i] < 0.9 * n / bins.cnt || (double)bins.xZ[i] > 1.1 * n / bins.cnt, __FILE__, __LINE__, "testhqrndunit.ap:301");
   }
// Test exponential
   testhqrndunit_unsetstate(&state);
   hqrndrandomize(&state);
   expsigmaerr = 0.0;
   lambdav = 2 + 5 * randomreal();
   for (i = 0; i < samplesize; i++) {
      x.xR[i] = hqrndexponential(&state, lambdav);
   }
   for (i = 0; i < samplesize; i++) {
      uierrors = uierrors || x.xR[i] < 0.0;
   }
   testhqrndunit_calculatemv(&x, samplesize, &mean, &means, &stddev, &stddevs);
   if (means != 0.0) {
      expsigmaerr = rmax2(expsigmaerr, fabs((mean - 1.0 / lambdav) / means));
   } else {
      experrors = true;
   }
   if (stddevs != 0.0) {
      expsigmaerr = rmax2(expsigmaerr, fabs((stddev - 1.0 / lambdav) / stddevs));
   } else {
      experrors = true;
   }
   experrors = experrors || expsigmaerr > sigmathreshold;
// Discrete/Continuous tests
   discreteerr = hqrnddiscretetest(true);
   continuouserr = hqrndcontinuoustest(true);
// Final report
   waserrors = ((((((seederrors || urerrors) || uierrors) || normerrors) || unit2errors) || experrors) || discreteerr) || continuouserr;
   if (!silent) {
      printf("RNG TEST\n");
      printf("SEED TEST:                               ");
      if (!seederrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("UNIFORM CONTINUOUS:                      ");
      if (!urerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("UNIFORM INTEGER:                         ");
      if (!uierrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("NORMAL:                                  ");
      if (!normerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("UNIT2:                                   ");
      if (!unit2errors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("EXPONENTIAL:                             ");
      if (!experrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("DISCRETE:                                ");
      if (!discreteerr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("CONTINUOUS:                              ");
      if (!continuouserr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST SUMMARY: FAILED\n");
      } else {
         printf("TEST SUMMARY: PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === ablas testing unit ===
// Internal subroutine.
// Triangular matrix inversion
//
//   -- LAPACK routine (version 3.0) --
//      Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//      Courant Institute, Argonne National Lab, and Rice University
//      February 29, 1992
static bool testablasunit_internalrmatrixtrinverse(RMatrix *a, ae_int_t n, bool isupper, bool isunittriangular) {
   ae_frame _frame_block;
   bool nounit;
   ae_int_t i;
   ae_int_t j;
   double v;
   double ajj;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(t, 0, DT_REAL);
   result = true;
   ae_vector_set_length(&t, n - 1 + 1);
// Test the input parameters.
   nounit = !isunittriangular;
   if (isupper) {
   // Compute inverse of upper triangular matrix.
      for (j = 0; j < n; j++) {
         if (nounit) {
            if (a->xyR[j][j] == 0.0) {
               result = false;
               ae_frame_leave();
               return result;
            }
            a->xyR[j][j] = 1 / a->xyR[j][j];
            ajj = -a->xyR[j][j];
         } else {
            ajj = -1.0;
         }
      // Compute elements 1:j-1 of j-th column.
         if (j > 0) {
            ae_v_move(t.xR, 1, &a->xyR[0][j], a->stride, j);
            for (i = 0; i < j; i++) {
               if (i < j - 1) {
                  v = ae_v_dotproduct(&a->xyR[i][i + 1], 1, &t.xR[i + 1], 1, j - i - 1);
               } else {
                  v = 0.0;
               }
               if (nounit) {
                  a->xyR[i][j] = v + a->xyR[i][i] * t.xR[i];
               } else {
                  a->xyR[i][j] = v + t.xR[i];
               }
            }
            ae_v_muld(&a->xyR[0][j], a->stride, j, ajj);
         }
      }
   } else {
   // Compute inverse of lower triangular matrix.
      for (j = n - 1; j >= 0; j--) {
         if (nounit) {
            if (a->xyR[j][j] == 0.0) {
               result = false;
               ae_frame_leave();
               return result;
            }
            a->xyR[j][j] = 1 / a->xyR[j][j];
            ajj = -a->xyR[j][j];
         } else {
            ajj = -1.0;
         }
         if (j < n - 1) {
         // Compute elements j+1:n of j-th column.
            ae_v_move(&t.xR[j + 1], 1, &a->xyR[j + 1][j], a->stride, n - j - 1);
            for (i = j + 1; i < n; i++) {
               if (i > j + 1) {
                  v = ae_v_dotproduct(&a->xyR[i][j + 1], 1, &t.xR[j + 1], 1, i - j - 1);
               } else {
                  v = 0.0;
               }
               if (nounit) {
                  a->xyR[i][j] = v + a->xyR[i][i] * t.xR[i];
               } else {
                  a->xyR[i][j] = v + t.xR[i];
               }
            }
            ae_v_muld(&a->xyR[j + 1][j], a->stride, n - j - 1, ajj);
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Internal subroutine.
// Triangular matrix inversion
//
//   -- LAPACK routine (version 3.0) --
//      Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
//      Courant Institute, Argonne National Lab, and Rice University
//      February 29, 1992
static bool testablasunit_internalcmatrixtrinverse(CMatrix *a, ae_int_t n, bool isupper, bool isunittriangular) {
   ae_frame _frame_block;
   bool nounit;
   ae_int_t i;
   ae_int_t j;
   complex v;
   complex ajj;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(t, 0, DT_COMPLEX);
   result = true;
   ae_vector_set_length(&t, n - 1 + 1);
// Test the input parameters.
   nounit = !isunittriangular;
   if (isupper) {
   // Compute inverse of upper triangular matrix.
      for (j = 0; j < n; j++) {
         if (nounit) {
            if (ae_c_eq_d(a->xyC[j][j], 0.0)) {
               result = false;
               ae_frame_leave();
               return result;
            }
            a->xyC[j][j] = ae_c_d_div(1, a->xyC[j][j]);
            ajj = ae_c_neg(a->xyC[j][j]);
         } else {
            ajj = complex_from_i(-1);
         }
      // Compute elements 1:j-1 of j-th column.
         if (j > 0) {
            ae_v_cmove(t.xC, 1, &a->xyC[0][j], a->stride, "N", j);
            for (i = 0; i < j; i++) {
               if (i + 1 < j) {
                  v = ae_v_cdotproduct(&a->xyC[i][i + 1], 1, "N", &t.xC[i + 1], 1, "N", j - i - 1);
               } else {
                  v = complex_from_i(0);
               }
               if (nounit) {
                  a->xyC[i][j] = ae_c_add(v, ae_c_mul(a->xyC[i][i], t.xC[i]));
               } else {
                  a->xyC[i][j] = ae_c_add(v, t.xC[i]);
               }
            }
            ae_v_cmulc(&a->xyC[0][j], a->stride, j, ajj);
         }
      }
   } else {
   // Compute inverse of lower triangular matrix.
      for (j = n - 1; j >= 0; j--) {
         if (nounit) {
            if (ae_c_eq_d(a->xyC[j][j], 0.0)) {
               result = false;
               ae_frame_leave();
               return result;
            }
            a->xyC[j][j] = ae_c_d_div(1, a->xyC[j][j]);
            ajj = ae_c_neg(a->xyC[j][j]);
         } else {
            ajj = complex_from_i(-1);
         }
         if (j + 1 < n) {
         // Compute elements j+1:n of j-th column.
            ae_v_cmove(&t.xC[j + 1], 1, &a->xyC[j + 1][j], a->stride, "N", n - j - 1);
            for (i = j + 1; i < n; i++) {
               if (i > j + 1) {
                  v = ae_v_cdotproduct(&a->xyC[i][j + 1], 1, "N", &t.xC[j + 1], 1, "N", i - j - 1);
               } else {
                  v = complex_from_i(0);
               }
               if (nounit) {
                  a->xyC[i][j] = ae_c_add(v, ae_c_mul(a->xyC[i][i], t.xC[i]));
               } else {
                  a->xyC[i][j] = ae_c_add(v, t.xC[i]);
               }
            }
            ae_v_cmulc(&a->xyC[j + 1][j], a->stride, n - j - 1, ajj);
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Reference implementation
// ALGLIB Routine: Copyright 15.12.2009 by Sergey Bochkanov
static void testablasunit_refrmatrixrighttrsm(ae_int_t m, ae_int_t n, RMatrix *a, ae_int_t i1, ae_int_t j1, bool isupper, bool isunit, ae_int_t optype, RMatrix *x, ae_int_t i2, ae_int_t j2) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double vr;
   bool rupper;
   ae_frame_make(&_frame_block);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewVector(tx, 0, DT_REAL);
   if (n * m == 0) {
      ae_frame_leave();
      return;
   }
   ae_matrix_set_length(&a1, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a1.xyR[i][j] = 0.0;
      }
   }
   if (isupper) {
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            a1.xyR[i][j] = a->xyR[i1 + i][j1 + j];
         }
      }
   } else {
      for (i = 0; i < n; i++) {
         for (j = 0; j <= i; j++) {
            a1.xyR[i][j] = a->xyR[i1 + i][j1 + j];
         }
      }
   }
   rupper = isupper;
   if (isunit) {
      for (i = 0; i < n; i++) {
         a1.xyR[i][i] = 1.0;
      }
   }
   ae_matrix_set_length(&a2, n, n);
   if (optype == 0) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a2.xyR[i][j] = a1.xyR[i][j];
         }
      }
   }
   if (optype == 1) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a2.xyR[i][j] = a1.xyR[j][i];
         }
      }
      rupper = !rupper;
   }
   testablasunit_internalrmatrixtrinverse(&a2, n, rupper, false);
   ae_vector_set_length(&tx, n);
   for (i = 0; i < m; i++) {
      ae_v_move(tx.xR, 1, &x->xyR[i2 + i][j2], 1, n);
      for (j = 0; j < n; j++) {
         vr = ae_v_dotproduct(tx.xR, 1, &a2.xyR[0][j], a2.stride, n);
         x->xyR[i2 + i][j2 + j] = vr;
      }
   }
   ae_frame_leave();
}

// Reference implementation
// ALGLIB Routine: Copyright 15.12.2009 by Sergey Bochkanov
static void testablasunit_refcmatrixrighttrsm(ae_int_t m, ae_int_t n, CMatrix *a, ae_int_t i1, ae_int_t j1, bool isupper, bool isunit, ae_int_t optype, CMatrix *x, ae_int_t i2, ae_int_t j2) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   complex vc;
   bool rupper;
   ae_frame_make(&_frame_block);
   NewMatrix(a1, 0, 0, DT_COMPLEX);
   NewMatrix(a2, 0, 0, DT_COMPLEX);
   NewVector(tx, 0, DT_COMPLEX);
   if (n * m == 0) {
      ae_frame_leave();
      return;
   }
   ae_matrix_set_length(&a1, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a1.xyC[i][j] = complex_from_i(0);
      }
   }
   if (isupper) {
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            a1.xyC[i][j] = a->xyC[i1 + i][j1 + j];
         }
      }
   } else {
      for (i = 0; i < n; i++) {
         for (j = 0; j <= i; j++) {
            a1.xyC[i][j] = a->xyC[i1 + i][j1 + j];
         }
      }
   }
   rupper = isupper;
   if (isunit) {
      for (i = 0; i < n; i++) {
         a1.xyC[i][i] = complex_from_i(1);
      }
   }
   ae_matrix_set_length(&a2, n, n);
   if (optype == 0) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a2.xyC[i][j] = a1.xyC[i][j];
         }
      }
   }
   if (optype == 1) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a2.xyC[i][j] = a1.xyC[j][i];
         }
      }
      rupper = !rupper;
   }
   if (optype == 2) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a2.xyC[i][j] = conj(a1.xyC[j][i]);
         }
      }
      rupper = !rupper;
   }
   testablasunit_internalcmatrixtrinverse(&a2, n, rupper, false);
   ae_vector_set_length(&tx, n);
   for (i = 0; i < m; i++) {
      ae_v_cmove(tx.xC, 1, &x->xyC[i2 + i][j2], 1, "N", n);
      for (j = 0; j < n; j++) {
         vc = ae_v_cdotproduct(tx.xC, 1, "N", &a2.xyC[0][j], a2.stride, "N", n);
         x->xyC[i2 + i][j2 + j] = vc;
      }
   }
   ae_frame_leave();
}

// Reference implementation
// ALGLIB Routine: Copyright 15.12.2009 by Sergey Bochkanov
static void testablasunit_refrmatrixlefttrsm(ae_int_t m, ae_int_t n, RMatrix *a, ae_int_t i1, ae_int_t j1, bool isupper, bool isunit, ae_int_t optype, RMatrix *x, ae_int_t i2, ae_int_t j2) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double vr;
   bool rupper;
   ae_frame_make(&_frame_block);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewVector(tx, 0, DT_REAL);
   if (n * m == 0) {
      ae_frame_leave();
      return;
   }
   ae_matrix_set_length(&a1, m, m);
   for (i = 0; i < m; i++) {
      for (j = 0; j < m; j++) {
         a1.xyR[i][j] = 0.0;
      }
   }
   if (isupper) {
      for (i = 0; i < m; i++) {
         for (j = i; j < m; j++) {
            a1.xyR[i][j] = a->xyR[i1 + i][j1 + j];
         }
      }
   } else {
      for (i = 0; i < m; i++) {
         for (j = 0; j <= i; j++) {
            a1.xyR[i][j] = a->xyR[i1 + i][j1 + j];
         }
      }
   }
   rupper = isupper;
   if (isunit) {
      for (i = 0; i < m; i++) {
         a1.xyR[i][i] = 1.0;
      }
   }
   ae_matrix_set_length(&a2, m, m);
   if (optype == 0) {
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            a2.xyR[i][j] = a1.xyR[i][j];
         }
      }
   }
   if (optype == 1) {
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            a2.xyR[i][j] = a1.xyR[j][i];
         }
      }
      rupper = !rupper;
   }
   testablasunit_internalrmatrixtrinverse(&a2, m, rupper, false);
   ae_vector_set_length(&tx, m);
   for (j = 0; j < n; j++) {
      ae_v_move(tx.xR, 1, &x->xyR[i2][j2 + j], x->stride, m);
      for (i = 0; i < m; i++) {
         vr = ae_v_dotproduct(a2.xyR[i], 1, tx.xR, 1, m);
         x->xyR[i2 + i][j2 + j] = vr;
      }
   }
   ae_frame_leave();
}

// Reference implementation
// ALGLIB Routine: Copyright 15.12.2009 by Sergey Bochkanov
static void testablasunit_refcmatrixlefttrsm(ae_int_t m, ae_int_t n, CMatrix *a, ae_int_t i1, ae_int_t j1, bool isupper, bool isunit, ae_int_t optype, CMatrix *x, ae_int_t i2, ae_int_t j2) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   complex vc;
   bool rupper;
   ae_frame_make(&_frame_block);
   NewMatrix(a1, 0, 0, DT_COMPLEX);
   NewMatrix(a2, 0, 0, DT_COMPLEX);
   NewVector(tx, 0, DT_COMPLEX);
   if (n * m == 0) {
      ae_frame_leave();
      return;
   }
   ae_matrix_set_length(&a1, m, m);
   for (i = 0; i < m; i++) {
      for (j = 0; j < m; j++) {
         a1.xyC[i][j] = complex_from_i(0);
      }
   }
   if (isupper) {
      for (i = 0; i < m; i++) {
         for (j = i; j < m; j++) {
            a1.xyC[i][j] = a->xyC[i1 + i][j1 + j];
         }
      }
   } else {
      for (i = 0; i < m; i++) {
         for (j = 0; j <= i; j++) {
            a1.xyC[i][j] = a->xyC[i1 + i][j1 + j];
         }
      }
   }
   rupper = isupper;
   if (isunit) {
      for (i = 0; i < m; i++) {
         a1.xyC[i][i] = complex_from_i(1);
      }
   }
   ae_matrix_set_length(&a2, m, m);
   if (optype == 0) {
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            a2.xyC[i][j] = a1.xyC[i][j];
         }
      }
   }
   if (optype == 1) {
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            a2.xyC[i][j] = a1.xyC[j][i];
         }
      }
      rupper = !rupper;
   }
   if (optype == 2) {
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            a2.xyC[i][j] = conj(a1.xyC[j][i]);
         }
      }
      rupper = !rupper;
   }
   testablasunit_internalcmatrixtrinverse(&a2, m, rupper, false);
   ae_vector_set_length(&tx, m);
   for (j = 0; j < n; j++) {
      ae_v_cmove(tx.xC, 1, &x->xyC[i2][j2 + j], x->stride, "N", m);
      for (i = 0; i < m; i++) {
         vc = ae_v_cdotproduct(a2.xyC[i], 1, "N", tx.xC, 1, "N", m);
         x->xyC[i2 + i][j2 + j] = vc;
      }
   }
   ae_frame_leave();
}

// ?Matrix????TRSM tests
//
// Returns False for passed test, True - for failed
static bool testablasunit_testtrsm(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t optype;
   ae_int_t uppertype;
   ae_int_t unittype;
   ae_int_t xoffsi;
   ae_int_t xoffsj;
   ae_int_t aoffsitype;
   ae_int_t aoffsjtype;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   double threshold;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewMatrix(refrxl, 0, 0, DT_REAL);
   NewMatrix(refrxr, 0, 0, DT_REAL);
   NewMatrix(refca, 0, 0, DT_COMPLEX);
   NewMatrix(refcxl, 0, 0, DT_COMPLEX);
   NewMatrix(refcxr, 0, 0, DT_COMPLEX);
   NewMatrix(ra, 0, 0, DT_REAL);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewMatrix(rxr1, 0, 0, DT_REAL);
   NewMatrix(rxl1, 0, 0, DT_REAL);
   NewMatrix(cxr1, 0, 0, DT_COMPLEX);
   NewMatrix(cxl1, 0, 0, DT_COMPLEX);
   NewMatrix(rxr2, 0, 0, DT_REAL);
   NewMatrix(rxl2, 0, 0, DT_REAL);
   NewMatrix(cxr2, 0, 0, DT_COMPLEX);
   NewMatrix(cxl2, 0, 0, DT_COMPLEX);
   threshold = sqr((double)maxn) * 100 * machineepsilon;
   result = false;
   for (mx = minn; mx <= maxn; mx++) {
   // Select random M/N in [1,MX] such that max(M,N)=MX
      m = 1 + randominteger(mx);
      n = 1 + randominteger(mx);
      if (randombool()) {
         m = mx;
      } else {
         n = mx;
      }
   // Initialize RefRA/RefCA by random matrices whose upper
   // and lower triangle submatrices are non-degenerate
   // well-conditioned matrices.
   //
   // Matrix size is 2Mx2M (four copies of same MxM matrix
   // to test different offsets)
      ae_matrix_set_length(&refra, 2 * m, 2 * m);
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            refra.xyR[i][j] = 0.1 * randommid();
         }
      }
      for (i = 0; i < m; i++) {
         refra.xyR[i][i] = (2 * randominteger(1) - 1) * (2 * m + randomreal());
      }
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            refra.xyR[i + m][j] = refra.xyR[i][j];
            refra.xyR[i][j + m] = refra.xyR[i][j];
            refra.xyR[i + m][j + m] = refra.xyR[i][j];
         }
      }
      ae_matrix_set_length(&refca, 2 * m, 2 * m);
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            refca.xyC[i][j] = complex_from_d(0.1 * randommid(), 0.1 * randommid());
         }
      }
      for (i = 0; i < m; i++) {
         refca.xyC[i][i] = complex_from_d((2 * randominteger(2) - 1) * (2 * m + randomreal()), (2 * randominteger(2) - 1) * (2 * m + randomreal()));
      }
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            refca.xyC[i + m][j] = refca.xyC[i][j];
            refca.xyC[i][j + m] = refca.xyC[i][j];
            refca.xyC[i + m][j + m] = refca.xyC[i][j];
         }
      }
   // Generate random XL/XR.
   //
   // XR is NxM matrix (matrix for 'Right' subroutines)
   // XL is MxN matrix (matrix for 'Left' subroutines)
      ae_matrix_set_length(&refrxr, n, m);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            refrxr.xyR[i][j] = randommid();
         }
      }
      ae_matrix_set_length(&refrxl, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            refrxl.xyR[i][j] = randommid();
         }
      }
      ae_matrix_set_length(&refcxr, n, m);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            refcxr.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
      ae_matrix_set_length(&refcxl, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            refcxl.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
   // test different types of operations, offsets, and so on...
   //
   // to avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      ae_matrix_set_length(&ra, 2 * m, 2 * m);
      ae_matrix_set_length(&rxr1, n, m);
      ae_matrix_set_length(&rxr2, n, m);
      ae_matrix_set_length(&rxl1, m, n);
      ae_matrix_set_length(&rxl2, m, n);
      ae_matrix_set_length(&ca, 2 * m, 2 * m);
      ae_matrix_set_length(&cxr1, n, m);
      ae_matrix_set_length(&cxr2, n, m);
      ae_matrix_set_length(&cxl1, m, n);
      ae_matrix_set_length(&cxl2, m, n);
      optype = randominteger(3);
      uppertype = randominteger(2);
      unittype = randominteger(2);
      xoffsi = randominteger(2);
      xoffsj = randominteger(2);
      aoffsitype = randominteger(2);
      aoffsjtype = randominteger(2);
      aoffsi = m * aoffsitype;
      aoffsj = m * aoffsjtype;
   // copy A, XR, XL (fill unused parts with random garbage)
      for (i = 0; i < 2 * m; i++) {
         for (j = 0; j < 2 * m; j++) {
            if (((i >= aoffsi && i < aoffsi + m) && j >= aoffsj) && j < aoffsj + m) {
               ca.xyC[i][j] = refca.xyC[i][j];
               ra.xyR[i][j] = refra.xyR[i][j];
            } else {
               ca.xyC[i][j] = complex_from_d(randomreal());
               ra.xyR[i][j] = randomreal();
            }
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            if (i >= xoffsi && j >= xoffsj) {
               cxr1.xyC[i][j] = refcxr.xyC[i][j];
               cxr2.xyC[i][j] = refcxr.xyC[i][j];
               rxr1.xyR[i][j] = refrxr.xyR[i][j];
               rxr2.xyR[i][j] = refrxr.xyR[i][j];
            } else {
               cxr1.xyC[i][j] = complex_from_d(randomreal());
               cxr2.xyC[i][j] = cxr1.xyC[i][j];
               rxr1.xyR[i][j] = randomreal();
               rxr2.xyR[i][j] = rxr1.xyR[i][j];
            }
         }
      }
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            if (i >= xoffsi && j >= xoffsj) {
               cxl1.xyC[i][j] = refcxl.xyC[i][j];
               cxl2.xyC[i][j] = refcxl.xyC[i][j];
               rxl1.xyR[i][j] = refrxl.xyR[i][j];
               rxl2.xyR[i][j] = refrxl.xyR[i][j];
            } else {
               cxl1.xyC[i][j] = complex_from_d(randomreal());
               cxl2.xyC[i][j] = cxl1.xyC[i][j];
               rxl1.xyR[i][j] = randomreal();
               rxl2.xyR[i][j] = rxl1.xyR[i][j];
            }
         }
      }
   // Test CXR
      cmatrixrighttrsm(n - xoffsi, m - xoffsj, &ca, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &cxr1, xoffsi, xoffsj);
      testablasunit_refcmatrixrighttrsm(n - xoffsi, m - xoffsj, &ca, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &cxr2, xoffsi, xoffsj);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            result = result || abscomplex(ae_c_sub(cxr1.xyC[i][j], cxr2.xyC[i][j])) > threshold;
         }
      }
   // Test CXL
      cmatrixlefttrsm(m - xoffsi, n - xoffsj, &ca, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &cxl1, xoffsi, xoffsj);
      testablasunit_refcmatrixlefttrsm(m - xoffsi, n - xoffsj, &ca, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &cxl2, xoffsi, xoffsj);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            result = result || abscomplex(ae_c_sub(cxl1.xyC[i][j], cxl2.xyC[i][j])) > threshold;
         }
      }
      if (optype < 2) {
      // Test RXR
         rmatrixrighttrsm(n - xoffsi, m - xoffsj, &ra, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &rxr1, xoffsi, xoffsj);
         testablasunit_refrmatrixrighttrsm(n - xoffsi, m - xoffsj, &ra, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &rxr2, xoffsi, xoffsj);
         for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
               result = result || fabs(rxr1.xyR[i][j] - rxr2.xyR[i][j]) > threshold;
            }
         }
      // Test RXL
         rmatrixlefttrsm(m - xoffsi, n - xoffsj, &ra, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &rxl1, xoffsi, xoffsj);
         testablasunit_refrmatrixlefttrsm(m - xoffsi, n - xoffsj, &ra, aoffsi, aoffsj, uppertype == 0, unittype == 0, optype, &rxl2, xoffsi, xoffsj);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               result = result || fabs(rxl1.xyR[i][j] - rxl2.xyR[i][j]) > threshold;
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Reference SYRK subroutine.
// ALGLIB Routine: Copyright 16.12.2009 by Sergey Bochkanov
static void testablasunit_refrmatrixsyrk(ae_int_t n, ae_int_t k, double alpha, RMatrix *a, ae_int_t ia, ae_int_t ja, ae_int_t optypea, double beta, RMatrix *c, ae_int_t ic, ae_int_t jc, bool isupper) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double vr;
   ae_frame_make(&_frame_block);
   NewMatrix(ae, 0, 0, DT_REAL);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (isupper ? j >= i : j <= i) {
            if (beta == 0.0) {
               c->xyR[i + ic][j + jc] = 0.0;
            } else {
               c->xyR[i + ic][j + jc] *= beta;
            }
         }
      }
   }
   if (alpha == 0.0) {
      ae_frame_leave();
      return;
   }
   if (n * k > 0) {
      ae_matrix_set_length(&ae, n, k);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < k; j++) {
         if (optypea == 0) {
            ae.xyR[i][j] = a->xyR[ia + i][ja + j];
         }
         if (optypea == 1) {
            ae.xyR[i][j] = a->xyR[ia + j][ja + i];
         }
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         vr = 0.0;
         if (k > 0) {
            vr = ae_v_dotproduct(ae.xyR[i], 1, ae.xyR[j], 1, k);
         }
         vr *= alpha;
         if (isupper && j >= i) {
            c->xyR[ic + i][jc + j] += vr;
         }
         if (!isupper && j <= i) {
            c->xyR[ic + i][jc + j] += vr;
         }
      }
   }
   ae_frame_leave();
}

// Reference SYRK subroutine.
// ALGLIB Routine: Copyright 16.12.2009 by Sergey Bochkanov
static void testablasunit_refcmatrixherk(ae_int_t n, ae_int_t k, double alpha, CMatrix *a, ae_int_t ia, ae_int_t ja, ae_int_t optypea, double beta, CMatrix *c, ae_int_t ic, ae_int_t jc, bool isupper) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   complex vc;
   ae_frame_make(&_frame_block);
   NewMatrix(ae, 0, 0, DT_COMPLEX);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (isupper ? j >= i : j <= i) {
            if (beta == 0.0) {
               c->xyC[i + ic][j + jc] = complex_from_i(0);
            } else {
               c->xyC[i + ic][j + jc] = ae_c_mul_d(c->xyC[i + ic][j + jc], beta);
            }
         }
      }
   }
   if (alpha == 0.0) {
      ae_frame_leave();
      return;
   }
   if (n * k > 0) {
      ae_matrix_set_length(&ae, n, k);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < k; j++) {
         if (optypea == 0) {
            ae.xyC[i][j] = a->xyC[ia + i][ja + j];
         }
         if (optypea == 2) {
            ae.xyC[i][j] = conj(a->xyC[ia + j][ja + i]);
         }
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         vc = complex_from_i(0);
         if (k > 0) {
            vc = ae_v_cdotproduct(ae.xyC[i], 1, "N", ae.xyC[j], 1, "Conj", k);
         }
         vc = ae_c_mul_d(vc, alpha);
         if (isupper && j >= i) {
            c->xyC[ic + i][jc + j] = ae_c_add(vc, c->xyC[ic + i][jc + j]);
         }
         if (!isupper && j <= i) {
            c->xyC[ic + i][jc + j] = ae_c_add(vc, c->xyC[ic + i][jc + j]);
         }
      }
   }
   ae_frame_leave();
}

// SYRK tests
//
// Returns False for passed test, True - for failed
static bool testablasunit_testsyrk(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t k;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t uppertype;
   ae_int_t xoffsi;
   ae_int_t xoffsj;
   ae_int_t aoffsitype;
   ae_int_t aoffsjtype;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t alphatype;
   ae_int_t betatype;
   double alpha;
   double beta;
   double threshold;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewMatrix(refrc, 0, 0, DT_REAL);
   NewMatrix(refca, 0, 0, DT_COMPLEX);
   NewMatrix(refcc, 0, 0, DT_COMPLEX);
   NewMatrix(ra1, 0, 0, DT_REAL);
   NewMatrix(ra2, 0, 0, DT_REAL);
   NewMatrix(ca1, 0, 0, DT_COMPLEX);
   NewMatrix(ca2, 0, 0, DT_COMPLEX);
   NewMatrix(rc, 0, 0, DT_REAL);
   NewMatrix(rct, 0, 0, DT_REAL);
   NewMatrix(cc, 0, 0, DT_COMPLEX);
   NewMatrix(cct, 0, 0, DT_COMPLEX);
   threshold = maxn * 100 * machineepsilon;
   result = false;
   for (mx = minn; mx <= maxn; mx++) {
   // Select random M/N in [1,MX] such that max(M,N)=MX
      k = 1 + randominteger(mx);
      n = 1 + randominteger(mx);
      if (randombool()) {
         k = mx;
      } else {
         n = mx;
      }
   // Initialize RefRA/RefCA by random Hermitian matrices,
   // RefRC/RefCC by random matrices
   //
   // RA/CA size is 2Nx2N (four copies of same NxN matrix
   // to test different offsets)
      ae_matrix_set_length(&refra, 2 * n, 2 * n);
      ae_matrix_set_length(&refca, 2 * n, 2 * n);
      for (i = 0; i < n; i++) {
         refra.xyR[i][i] = randommid();
         refca.xyC[i][i] = complex_from_d(randommid());
         for (j = i + 1; j < n; j++) {
            refra.xyR[i][j] = randommid();
            refca.xyC[i][j] = complex_from_d(randommid(), randommid());
            refra.xyR[j][i] = refra.xyR[i][j];
            refca.xyC[j][i] = conj(refca.xyC[i][j]);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            refra.xyR[i + n][j] = refra.xyR[i][j];
            refra.xyR[i][j + n] = refra.xyR[i][j];
            refra.xyR[i + n][j + n] = refra.xyR[i][j];
            refca.xyC[i + n][j] = refca.xyC[i][j];
            refca.xyC[i][j + n] = refca.xyC[i][j];
            refca.xyC[i + n][j + n] = refca.xyC[i][j];
         }
      }
      ae_matrix_set_length(&refrc, n, k);
      ae_matrix_set_length(&refcc, n, k);
      for (i = 0; i < n; i++) {
         for (j = 0; j < k; j++) {
            refrc.xyR[i][j] = randommid();
            refcc.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
   // test different types of operations, offsets, and so on...
   //
   // to avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      ae_matrix_set_length(&ra1, 2 * n, 2 * n);
      ae_matrix_set_length(&ra2, 2 * n, 2 * n);
      ae_matrix_set_length(&ca1, 2 * n, 2 * n);
      ae_matrix_set_length(&ca2, 2 * n, 2 * n);
      ae_matrix_set_length(&rc, n, k);
      ae_matrix_set_length(&rct, k, n);
      ae_matrix_set_length(&cc, n, k);
      ae_matrix_set_length(&cct, k, n);
      uppertype = randominteger(2);
      xoffsi = randominteger(2);
      xoffsj = randominteger(2);
      aoffsitype = randominteger(2);
      aoffsjtype = randominteger(2);
      alphatype = randominteger(2);
      betatype = randominteger(2);
      aoffsi = n * aoffsitype;
      aoffsj = n * aoffsjtype;
      alpha = alphatype * randommid();
      beta = betatype * randommid();
   // copy A, C (fill unused parts with random garbage)
      for (i = 0; i < 2 * n; i++) {
         for (j = 0; j < 2 * n; j++) {
            if (((i >= aoffsi && i < aoffsi + n) && j >= aoffsj) && j < aoffsj + n) {
               ca1.xyC[i][j] = refca.xyC[i][j];
               ca2.xyC[i][j] = refca.xyC[i][j];
               ra1.xyR[i][j] = refra.xyR[i][j];
               ra2.xyR[i][j] = refra.xyR[i][j];
            } else {
               ca1.xyC[i][j] = complex_from_d(randomreal());
               ca2.xyC[i][j] = ca1.xyC[i][j];
               ra1.xyR[i][j] = randomreal();
               ra2.xyR[i][j] = ra1.xyR[i][j];
            }
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < k; j++) {
            if (i >= xoffsi && j >= xoffsj) {
               rc.xyR[i][j] = refrc.xyR[i][j];
               rct.xyR[j][i] = refrc.xyR[i][j];
               cc.xyC[i][j] = refcc.xyC[i][j];
               cct.xyC[j][i] = refcc.xyC[i][j];
            } else {
               rc.xyR[i][j] = randomreal();
               rct.xyR[j][i] = rc.xyR[i][j];
               cc.xyC[i][j] = complex_from_d(randomreal());
               cct.xyC[j][i] = cc.xyC[i][j]; //(@) Was cct.xyC[j][i] = cct.xyC[j][i];
            }
         }
      }
   // Test complex
   // Only one of transform types is selected and tested
      if (randombool()) {
         cmatrixherk(n - xoffsi, k - xoffsj, alpha, &cc, xoffsi, xoffsj, 0, beta, &ca1, aoffsi, aoffsj, uppertype == 0);
         testablasunit_refcmatrixherk(n - xoffsi, k - xoffsj, alpha, &cc, xoffsi, xoffsj, 0, beta, &ca2, aoffsi, aoffsj, uppertype == 0);
      } else {
         cmatrixherk(n - xoffsi, k - xoffsj, alpha, &cct, xoffsj, xoffsi, 2, beta, &ca1, aoffsi, aoffsj, uppertype == 0);
         testablasunit_refcmatrixherk(n - xoffsi, k - xoffsj, alpha, &cct, xoffsj, xoffsi, 2, beta, &ca2, aoffsi, aoffsj, uppertype == 0);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            result = result || abscomplex(ae_c_sub(ca1.xyC[i][j], ca2.xyC[i][j])) > threshold;
         }
      }
   // Test old version of HERK (named SYRK)
   // Only one of transform types is selected and tested
      if (randombool()) {
         cmatrixsyrk(n - xoffsi, k - xoffsj, alpha, &cc, xoffsi, xoffsj, 0, beta, &ca1, aoffsi, aoffsj, uppertype == 0);
         testablasunit_refcmatrixherk(n - xoffsi, k - xoffsj, alpha, &cc, xoffsi, xoffsj, 0, beta, &ca2, aoffsi, aoffsj, uppertype == 0);
      } else {
         cmatrixsyrk(n - xoffsi, k - xoffsj, alpha, &cct, xoffsj, xoffsi, 2, beta, &ca1, aoffsi, aoffsj, uppertype == 0);
         testablasunit_refcmatrixherk(n - xoffsi, k - xoffsj, alpha, &cct, xoffsj, xoffsi, 2, beta, &ca2, aoffsi, aoffsj, uppertype == 0);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            result = result || abscomplex(ae_c_sub(ca1.xyC[i][j], ca2.xyC[i][j])) > threshold;
         }
      }
   // Test real
   // Only one of transform types is selected and tested
      if (randombool()) {
         rmatrixsyrk(n - xoffsi, k - xoffsj, alpha, &rc, xoffsi, xoffsj, 0, beta, &ra1, aoffsi, aoffsj, uppertype == 0);
         testablasunit_refrmatrixsyrk(n - xoffsi, k - xoffsj, alpha, &rc, xoffsi, xoffsj, 0, beta, &ra2, aoffsi, aoffsj, uppertype == 0);
      } else {
         rmatrixsyrk(n - xoffsi, k - xoffsj, alpha, &rct, xoffsj, xoffsi, 1, beta, &ra1, aoffsi, aoffsj, uppertype == 0);
         testablasunit_refrmatrixsyrk(n - xoffsi, k - xoffsj, alpha, &rct, xoffsj, xoffsi, 1, beta, &ra2, aoffsi, aoffsj, uppertype == 0);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            result = result || fabs(ra1.xyR[i][j] - ra2.xyR[i][j]) > threshold;
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Reference GEMM,
// ALGLIB subroutine
static void testablasunit_refrmatrixgemm(ae_int_t m, ae_int_t n, ae_int_t k, double alpha, RMatrix *a, ae_int_t ia, ae_int_t ja, ae_int_t optypea, RMatrix *b, ae_int_t ib, ae_int_t jb, ae_int_t optypeb, double beta, RMatrix *c, ae_int_t ic, ae_int_t jc) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double vc;
   ae_frame_make(&_frame_block);
   NewMatrix(ae, 0, 0, DT_REAL);
   NewMatrix(be, 0, 0, DT_REAL);
   ae_matrix_set_length(&ae, m, k);
   for (i = 0; i < m; i++) {
      for (j = 0; j < k; j++) {
         if (optypea == 0) {
            ae.xyR[i][j] = a->xyR[ia + i][ja + j];
         }
         if (optypea == 1) {
            ae.xyR[i][j] = a->xyR[ia + j][ja + i];
         }
      }
   }
   ae_matrix_set_length(&be, k, n);
   for (i = 0; i < k; i++) {
      for (j = 0; j < n; j++) {
         if (optypeb == 0) {
            be.xyR[i][j] = b->xyR[ib + i][jb + j];
         }
         if (optypeb == 1) {
            be.xyR[i][j] = b->xyR[ib + j][jb + i];
         }
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         vc = ae_v_dotproduct(ae.xyR[i], 1, &be.xyR[0][j], be.stride, k);
         vc *= alpha;
         if (beta != 0.0) {
            vc += beta * c->xyR[ic + i][jc + j];
         }
         c->xyR[ic + i][jc + j] = vc;
      }
   }
   ae_frame_leave();
}

// Reference GEMM,
// ALGLIB subroutine
static void testablasunit_refcmatrixgemm(ae_int_t m, ae_int_t n, ae_int_t k, complex alpha, CMatrix *a, ae_int_t ia, ae_int_t ja, ae_int_t optypea, CMatrix *b, ae_int_t ib, ae_int_t jb, ae_int_t optypeb, complex beta, CMatrix *c, ae_int_t ic, ae_int_t jc) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   complex vc;
   ae_frame_make(&_frame_block);
   NewMatrix(ae, 0, 0, DT_COMPLEX);
   NewMatrix(be, 0, 0, DT_COMPLEX);
   ae_matrix_set_length(&ae, m, k);
   for (i = 0; i < m; i++) {
      for (j = 0; j < k; j++) {
         if (optypea == 0) {
            ae.xyC[i][j] = a->xyC[ia + i][ja + j];
         }
         if (optypea == 1) {
            ae.xyC[i][j] = a->xyC[ia + j][ja + i];
         }
         if (optypea == 2) {
            ae.xyC[i][j] = conj(a->xyC[ia + j][ja + i]);
         }
      }
   }
   ae_matrix_set_length(&be, k, n);
   for (i = 0; i < k; i++) {
      for (j = 0; j < n; j++) {
         if (optypeb == 0) {
            be.xyC[i][j] = b->xyC[ib + i][jb + j];
         }
         if (optypeb == 1) {
            be.xyC[i][j] = b->xyC[ib + j][jb + i];
         }
         if (optypeb == 2) {
            be.xyC[i][j] = conj(b->xyC[ib + j][jb + i]);
         }
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         vc = ae_v_cdotproduct(ae.xyC[i], 1, "N", &be.xyC[0][j], be.stride, "N", k);
         vc = ae_c_mul(alpha, vc);
         if (ae_c_neq_d(beta, 0.0)) {
            vc = ae_c_add(vc, ae_c_mul(beta, c->xyC[ic + i][jc + j]));
         }
         c->xyC[ic + i][jc + j] = vc;
      }
   }
   ae_frame_leave();
}

// GEMM tests
//
// Returns False for passed test, True - for failed
static bool testablasunit_testgemm(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t k;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t aoptype;
   ae_int_t aoptyper;
   ae_int_t boffsi;
   ae_int_t boffsj;
   ae_int_t boptype;
   ae_int_t boptyper;
   ae_int_t coffsi;
   ae_int_t coffsj;
   double alphar;
   double betar;
   complex alphac;
   complex betac;
   double threshold;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewMatrix(refrb, 0, 0, DT_REAL);
   NewMatrix(refrc, 0, 0, DT_REAL);
   NewMatrix(refca, 0, 0, DT_COMPLEX);
   NewMatrix(refcb, 0, 0, DT_COMPLEX);
   NewMatrix(refcc, 0, 0, DT_COMPLEX);
   NewMatrix(rc1, 0, 0, DT_REAL);
   NewMatrix(rc2, 0, 0, DT_REAL);
   NewMatrix(cc1, 0, 0, DT_COMPLEX);
   NewMatrix(cc2, 0, 0, DT_COMPLEX);
   threshold = maxn * 100 * machineepsilon;
   result = false;
   for (mx = minn; mx <= maxn; mx++) {
   // Select random M/N/K in [1,MX] such that max(M,N,K)=MX
      m = 1 + randominteger(mx);
      n = 1 + randominteger(mx);
      k = 1 + randominteger(mx);
      i = randominteger(3);
      if (i == 0) {
         m = mx;
      }
      if (i == 1) {
         n = mx;
      }
      if (i == 2) {
         k = mx;
      }
   // Initialize A/B/C by random matrices with size (MaxN+1)*(MaxN+1)
      ae_matrix_set_length(&refra, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refrb, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refrc, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refca, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refcb, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refcc, maxn + 1, maxn + 1);
      for (i = 0; i <= maxn; i++) {
         for (j = 0; j <= maxn; j++) {
            refra.xyR[i][j] = randommid();
            refrb.xyR[i][j] = randommid();
            refrc.xyR[i][j] = randommid();
            refca.xyC[i][j] = complex_from_d(randommid(), randommid());
            refcb.xyC[i][j] = complex_from_d(randommid(), randommid());
            refcc.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
   // test different types of operations, offsets, and so on...
   //
   // to avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      ae_matrix_set_length(&rc1, maxn + 1, maxn + 1);
      ae_matrix_set_length(&rc2, maxn + 1, maxn + 1);
      ae_matrix_set_length(&cc1, maxn + 1, maxn + 1);
      ae_matrix_set_length(&cc2, maxn + 1, maxn + 1);
      aoffsi = randominteger(2);
      aoffsj = randominteger(2);
      aoptype = randominteger(3);
      aoptyper = randominteger(2);
      boffsi = randominteger(2);
      boffsj = randominteger(2);
      boptype = randominteger(3);
      boptyper = randominteger(2);
      coffsi = randominteger(2);
      coffsj = randominteger(2);
      alphar = randominteger(2) * randommid();
      betar = randominteger(2) * randommid();
      if (randombool()) {
         alphac = complex_from_d(randommid(), randommid());
      } else {
         alphac = complex_from_i(0);
      }
      if (randombool()) {
         betac = complex_from_d(randommid(), randommid());
      } else {
         betac = complex_from_i(0);
      }
   // copy C
      for (i = 0; i <= maxn; i++) {
         for (j = 0; j <= maxn; j++) {
            rc1.xyR[i][j] = refrc.xyR[i][j];
            rc2.xyR[i][j] = refrc.xyR[i][j];
            cc1.xyC[i][j] = refcc.xyC[i][j];
            cc2.xyC[i][j] = refcc.xyC[i][j];
         }
      }
   // Test complex
      cmatrixgemm(m, n, k, alphac, &refca, aoffsi, aoffsj, aoptype, &refcb, boffsi, boffsj, boptype, betac, &cc1, coffsi, coffsj);
      testablasunit_refcmatrixgemm(m, n, k, alphac, &refca, aoffsi, aoffsj, aoptype, &refcb, boffsi, boffsj, boptype, betac, &cc2, coffsi, coffsj);
      for (i = 0; i <= maxn; i++) {
         for (j = 0; j <= maxn; j++) {
            result = result || abscomplex(ae_c_sub(cc1.xyC[i][j], cc2.xyC[i][j])) > threshold;
         }
      }
   // Test real
      rmatrixgemm(m, n, k, alphar, &refra, aoffsi, aoffsj, aoptyper, &refrb, boffsi, boffsj, boptyper, betar, &rc1, coffsi, coffsj);
      testablasunit_refrmatrixgemm(m, n, k, alphar, &refra, aoffsi, aoffsj, aoptyper, &refrb, boffsi, boffsj, boptyper, betar, &rc2, coffsi, coffsj);
      for (i = 0; i <= maxn; i++) {
         for (j = 0; j <= maxn; j++) {
            result = result || fabs(rc1.xyR[i][j] - rc2.xyR[i][j]) > threshold;
         }
      }
   }
   ae_frame_leave();
   return result;
}

// transpose tests
//
// Returns False for passed test, True - for failed
static bool testablasunit_testtrans(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t boffsi;
   ae_int_t boffsj;
   double v1;
   double v2;
   double threshold;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewMatrix(refrb, 0, 0, DT_REAL);
   NewMatrix(refca, 0, 0, DT_COMPLEX);
   NewMatrix(refcb, 0, 0, DT_COMPLEX);
   result = false;
   threshold = 1000 * machineepsilon;
   for (mx = minn; mx <= maxn; mx++) {
   // Select random M/N in [1,MX] such that max(M,N)=MX
   // Generate random V1 and V2 which are used to fill
   // RefRB/RefCB with control values.
      m = 1 + randominteger(mx);
      n = 1 + randominteger(mx);
      if (randominteger(2) == 0) {
         m = mx;
      } else {
         n = mx;
      }
      v1 = randomreal();
      v2 = randomreal();
   // Initialize A by random matrix with size (MaxN+1)*(MaxN+1)
   // Fill B with control values
      ae_matrix_set_length(&refra, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refrb, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refca, maxn + 1, maxn + 1);
      ae_matrix_set_length(&refcb, maxn + 1, maxn + 1);
      for (i = 0; i <= maxn; i++) {
         for (j = 0; j <= maxn; j++) {
            refra.xyR[i][j] = randommid();
            refca.xyC[i][j] = complex_from_d(randommid(), randommid());
            refrb.xyR[i][j] = i * v1 + j * v2;
            refcb.xyC[i][j] = complex_from_d(i * v1 + j * v2);
         }
      }
   // test different offsets (zero or one)
   //
   // to avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      aoffsi = randominteger(2);
      aoffsj = randominteger(2);
      boffsi = randominteger(2);
      boffsj = randominteger(2);
      rmatrixtranspose(m, n, &refra, aoffsi, aoffsj, &refrb, boffsi, boffsj);
      for (i = 0; i <= maxn; i++) {
         for (j = 0; j <= maxn; j++) {
            if (((i < boffsi || i >= boffsi + n) || j < boffsj) || j >= boffsj + m) {
               result = result || fabs(refrb.xyR[i][j] - (v1 * i + v2 * j)) > threshold;
            } else {
               result = result || fabs(refrb.xyR[i][j] - refra.xyR[aoffsi + j - boffsj][aoffsj + i - boffsi]) > threshold;
            }
         }
      }
      cmatrixtranspose(m, n, &refca, aoffsi, aoffsj, &refcb, boffsi, boffsj);
      for (i = 0; i <= maxn; i++) {
         for (j = 0; j <= maxn; j++) {
            if (((i < boffsi || i >= boffsi + n) || j < boffsj) || j >= boffsj + m) {
               result = result || abscomplex(ae_c_sub_d(refcb.xyC[i][j], v1 * i + v2 * j)) > threshold;
            } else {
               result = result || abscomplex(ae_c_sub(refcb.xyC[i][j], refca.xyC[aoffsi + j - boffsj][aoffsj + i - boffsi])) > threshold;
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// rank-1tests
//
// Returns False for passed test, True - for failed
static bool testablasunit_testrank1(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t uoffs;
   ae_int_t voffs;
   double threshold;
   double ralpha;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewMatrix(refrb, 0, 0, DT_REAL);
   NewMatrix(refca, 0, 0, DT_COMPLEX);
   NewMatrix(refcb, 0, 0, DT_COMPLEX);
   NewVector(ru, 0, DT_REAL);
   NewVector(rv, 0, DT_REAL);
   NewVector(cu, 0, DT_COMPLEX);
   NewVector(cv, 0, DT_COMPLEX);
   result = false;
   threshold = 1000 * machineepsilon;
   for (mx = minn; mx <= maxn; mx++) {
   // Select random M/N in [1,MX] such that max(M,N)=MX
      m = 1 + randominteger(mx);
      n = 1 + randominteger(mx);
      if (randominteger(2) == 0) {
         m = mx;
      } else {
         n = mx;
      }
   // Initialize A by random matrix with size (MaxN+1)*(MaxN+1)
   // Fill B with control values
      ae_matrix_set_length(&refra, maxn + maxn, maxn + maxn);
      ae_matrix_set_length(&refrb, maxn + maxn, maxn + maxn);
      ae_matrix_set_length(&refca, maxn + maxn, maxn + maxn);
      ae_matrix_set_length(&refcb, maxn + maxn, maxn + maxn);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            refrb.xyR[i][j] = randommid();
            refcb.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
      ae_vector_set_length(&ru, 2 * m);
      ae_vector_set_length(&cu, 2 * m);
      for (i = 0; i < 2 * m; i++) {
         ru.xR[i] = randommid();
         cu.xC[i] = complex_from_d(randommid(), randommid());
      }
      ae_vector_set_length(&rv, 2 * n);
      ae_vector_set_length(&cv, 2 * n);
      for (i = 0; i < 2 * n; i++) {
         rv.xR[i] = randommid();
         cv.xC[i] = complex_from_d(randommid(), randommid());
      }
   // Generate random offsets of all operands and random coefficients.
      aoffsi = randominteger(maxn);
      aoffsj = randominteger(maxn);
      uoffs = randominteger(m);
      voffs = randominteger(n);
      ralpha = randomreal() - 0.5;
   // Test CMatrixRank1() and deprecated RMatrixRank1()
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            refca.xyC[i][j] = refcb.xyC[i][j];
         }
      }
      cmatrixrank1(m, n, &refca, aoffsi, aoffsj, &cu, uoffs, &cv, voffs);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            if (((i < aoffsi || i >= aoffsi + m) || j < aoffsj) || j >= aoffsj + n) {
               result = result || abscomplex(ae_c_sub(refca.xyC[i][j], refcb.xyC[i][j])) > threshold;
            } else {
               result = result || abscomplex(ae_c_sub(refca.xyC[i][j], ae_c_add(refcb.xyC[i][j], ae_c_mul(cu.xC[i - aoffsi + uoffs], cv.xC[j - aoffsj + voffs])))) > threshold;
            }
         }
      }
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            refra.xyR[i][j] = refrb.xyR[i][j];
         }
      }
      rmatrixrank1(m, n, &refra, aoffsi, aoffsj, &ru, uoffs, &rv, voffs);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            if (((i < aoffsi || i >= aoffsi + m) || j < aoffsj) || j >= aoffsj + n) {
               result = result || fabs(refra.xyR[i][j] - refrb.xyR[i][j]) > threshold;
            } else {
               result = result || fabs(refra.xyR[i][j] - (refrb.xyR[i][j] + ru.xR[i - aoffsi + uoffs] * rv.xR[j - aoffsj + voffs])) > threshold;
            }
         }
      }
   // Test modern RMatrixGER()
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            refra.xyR[i][j] = refrb.xyR[i][j];
         }
      }
      rmatrixger(m, n, &refra, aoffsi, aoffsj, ralpha, &ru, uoffs, &rv, voffs);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            if (((i < aoffsi || i >= aoffsi + m) || j < aoffsj) || j >= aoffsj + n) {
               set_error_flag(&result, fabs(refra.xyR[i][j] - refrb.xyR[i][j]) != 0.0, __FILE__, __LINE__, "testablasunit.ap:1145");
            } else {
               set_error_flag(&result, fabs(refra.xyR[i][j] - (refrb.xyR[i][j] + ralpha * ru.xR[i - aoffsi + uoffs] * rv.xR[j - aoffsj + voffs])) > threshold, __FILE__, __LINE__, "testablasunit.ap:1147");
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// MV tests
//
// Returns False for passed test, True - for failed
static bool testablasunit_testgemv(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t xoffs;
   ae_int_t yoffs;
   ae_int_t opca;
   ae_int_t opra;
   double threshold;
   double ralpha;
   double rbeta;
   double rv1;
   double rv2;
   complex cv1;
   complex cv2;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewMatrix(refca, 0, 0, DT_COMPLEX);
   NewVector(rx, 0, DT_REAL);
   NewVector(ry, 0, DT_REAL);
   NewVector(cx, 0, DT_COMPLEX);
   NewVector(cy, 0, DT_COMPLEX);
   result = false;
   threshold = 1000 * machineepsilon;
   for (mx = minn; mx <= maxn; mx++) {
   // Select random M/N in [1,MX] such that max(M,N)=MX
      m = 1 + randominteger(mx);
      n = 1 + randominteger(mx);
      if (randominteger(2) == 0) {
         m = mx;
      } else {
         n = mx;
      }
   // Initialize A by random matrix with size (MaxN+MaxN)*(MaxN+MaxN)
   // Initialize X by random vector with size (MaxN+MaxN)
   // Fill Y by control values
      ae_matrix_set_length(&refra, maxn + maxn, maxn + maxn);
      ae_matrix_set_length(&refca, maxn + maxn, maxn + maxn);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            refra.xyR[i][j] = randommid();
            refca.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
      ae_vector_set_length(&rx, 2 * maxn);
      ae_vector_set_length(&cx, 2 * maxn);
      ae_vector_set_length(&ry, 2 * maxn);
      ae_vector_set_length(&cy, 2 * maxn);
      for (i = 0; i < 2 * maxn; i++) {
         rx.xR[i] = randommid();
         cx.xC[i] = complex_from_d(randommid(), randommid());
      }
   // Select random offsets and operations.
   //
   // To avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      aoffsi = randominteger(maxn);
      aoffsj = randominteger(maxn);
      xoffs = randominteger(maxn);
      yoffs = randominteger(maxn);
      opca = randominteger(3);
      opra = randominteger(2);
      ralpha = (randomreal() - 0.5) * randominteger(2);
      rbeta = (randomreal() - 0.5) * randominteger(2);
   // Test CMatrixMV and deprecated RMatrixMV
      for (i = 0; i < 2 * maxn; i++) {
         cy.xC[i] = complex_from_i(i);
      }
      cmatrixmv(m, n, &refca, aoffsi, aoffsj, opca, &cx, xoffs, &cy, yoffs);
      for (i = 0; i < 2 * maxn; i++) {
         if (i < yoffs || i >= yoffs + m) {
            result = result || ae_c_neq_d(cy.xC[i], (double)i);
         } else {
            cv1 = cy.xC[i];
            cv2 = complex_from_d(0.0);
            if (opca == 0) {
               cv2 = ae_v_cdotproduct(&refca.xyC[aoffsi + i - yoffs][aoffsj], 1, "N", &cx.xC[xoffs], 1, "N", n);
            }
            if (opca == 1) {
               cv2 = ae_v_cdotproduct(&refca.xyC[aoffsi][aoffsj + i - yoffs], refca.stride, "N", &cx.xC[xoffs], 1, "N", n);
            }
            if (opca == 2) {
               cv2 = ae_v_cdotproduct(&refca.xyC[aoffsi][aoffsj + i - yoffs], refca.stride, "Conj", &cx.xC[xoffs], 1, "N", n);
            }
            result = result || abscomplex(ae_c_sub(cv1, cv2)) > threshold;
         }
      }
      for (i = 0; i < 2 * maxn; i++) {
         ry.xR[i] = (double)i;
      }
      rmatrixmv(m, n, &refra, aoffsi, aoffsj, opra, &rx, xoffs, &ry, yoffs);
      for (i = 0; i < 2 * maxn; i++) {
         if (i < yoffs || i >= yoffs + m) {
            result = result || ry.xR[i] != (double)i;
         } else {
            rv1 = ry.xR[i];
            rv2 = 0.0;
            if (opra == 0) {
               rv2 = ae_v_dotproduct(&refra.xyR[aoffsi + i - yoffs][aoffsj], 1, &rx.xR[xoffs], 1, n);
            }
            if (opra == 1) {
               rv2 = ae_v_dotproduct(&refra.xyR[aoffsi][aoffsj + i - yoffs], refra.stride, &rx.xR[xoffs], 1, n);
            }
            result = result || fabs(rv1 - rv2) > threshold;
         }
      }
   // Test modern RMatrixGEMV()
      for (i = 0; i < 2 * maxn; i++) {
         ry.xR[i] = (double)i;
      }
      rmatrixgemv(m, n, ralpha, &refra, aoffsi, aoffsj, opra, &rx, xoffs, rbeta, &ry, yoffs);
      for (i = 0; i < 2 * maxn; i++) {
         if (i < yoffs || i >= yoffs + m) {
            set_error_flag(&result, ry.xR[i] != (double)i, __FILE__, __LINE__, "testablasunit.ap:1295");
         } else {
            rv1 = ry.xR[i];
            rv2 = 0.0;
            if (opra == 0) {
               rv2 = ae_v_dotproduct(&refra.xyR[aoffsi + i - yoffs][aoffsj], 1, &rx.xR[xoffs], 1, n);
            }
            if (opra == 1) {
               rv2 = ae_v_dotproduct(&refra.xyR[aoffsi][aoffsj + i - yoffs], refra.stride, &rx.xR[xoffs], 1, n);
            }
            rv2 = rbeta * i + ralpha * rv2;
            set_error_flag(&result, fabs(rv1 - rv2) > threshold, __FILE__, __LINE__, "testablasunit.ap:1305");
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Reference SYMV,
// ALGLIB subroutine
static void testablasunit_refrmatrixsymv(ae_int_t n, double alpha, RMatrix *a, ae_int_t ia, ae_int_t ja, bool isupper, RVector *x, ae_int_t ix, double beta, RVector *y, ae_int_t iy) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_frame_make(&_frame_block);
   NewMatrix(b, 0, 0, DT_REAL);
// Convert problem to traditional dense GEMV
   ae_matrix_set_length(&b, n, n);
   if (isupper) {
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            b.xyR[i][j] = a->xyR[ia + i][ja + j];
            b.xyR[j][i] = a->xyR[ia + i][ja + j];
         }
      }
   } else {
      for (i = 0; i < n; i++) {
         for (j = 0; j <= i; j++) {
            b.xyR[i][j] = a->xyR[ia + i][ja + j];
            b.xyR[j][i] = a->xyR[ia + i][ja + j];
         }
      }
   }
// Calculate result
   for (i = 0; i < n; i++) {
      v = beta * y->xR[iy + i];
      for (j = 0; j < n; j++) {
         v += alpha * b.xyR[i][j] * x->xR[ix + j];
      }
      y->xR[iy + i] = v;
   }
   ae_frame_leave();
}

// Reference SYVMV,
// ALGLIB subroutine
static double testablasunit_refrmatrixsyvmv(ae_int_t n, RMatrix *a, ae_int_t ia, ae_int_t ja, bool isupper, RVector *x, ae_int_t ix) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double result;
   ae_frame_make(&_frame_block);
   NewMatrix(b, 0, 0, DT_REAL);
// Convert problem to traditional dense GEMV
   ae_matrix_set_length(&b, n, n);
   if (isupper) {
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            b.xyR[i][j] = a->xyR[ia + i][ja + j];
            b.xyR[j][i] = a->xyR[ia + i][ja + j];
         }
      }
   } else {
      for (i = 0; i < n; i++) {
         for (j = 0; j <= i; j++) {
            b.xyR[i][j] = a->xyR[ia + i][ja + j];
            b.xyR[j][i] = a->xyR[ia + i][ja + j];
         }
      }
   }
// Calculate result
   result = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         result += x->xR[ix + i] * b.xyR[i][j] * x->xR[ix + j];
      }
   }
   ae_frame_leave();
   return result;
}

// SYMV/SYVMV tests
//
// Sets error flag on failure, ignores on success.
static void testablasunit_testsymv(ae_int_t minn, ae_int_t maxn, bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t xoffs;
   ae_int_t yoffs;
   bool isuppera;
   double threshold;
   double ralpha;
   double rbeta;
   double rv1;
   double rv2;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewVector(rx, 0, DT_REAL);
   NewVector(ry, 0, DT_REAL);
   NewVector(rz, 0, DT_REAL);
   threshold = 1000 * machineepsilon;
   for (n = minn; n <= maxn; n++) {
   // Initialize A by random matrix with size (MaxN+MaxN)*(MaxN+MaxN)
   // Initialize X by random vector with size (MaxN+MaxN)
   // Fill Y by control values
      ae_matrix_set_length(&refra, maxn + maxn, maxn + maxn);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            refra.xyR[i][j] = randommid();
         }
      }
      ae_vector_set_length(&rx, 2 * maxn);
      ae_vector_set_length(&ry, 2 * maxn);
      ae_vector_set_length(&rz, 2 * maxn);
      for (i = 0; i < 2 * maxn; i++) {
         rx.xR[i] = randommid();
      }
   // Select random offsets and operations.
   //
   // To avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      aoffsi = randominteger(maxn);
      aoffsj = randominteger(maxn);
      xoffs = randominteger(maxn);
      yoffs = randominteger(maxn);
      isuppera = randombool();
      ralpha = (randomreal() - 0.5) * randominteger(2);
      rbeta = (randomreal() - 0.5) * randominteger(2);
   // Test RMatrixSYMV()
      for (i = 0; i < 2 * maxn; i++) {
         ry.xR[i] = (double)i;
         rz.xR[i] = (double)i;
      }
      rmatrixsymv(n, ralpha, &refra, aoffsi, aoffsj, isuppera, &rx, xoffs, rbeta, &ry, yoffs);
      testablasunit_refrmatrixsymv(n, ralpha, &refra, aoffsi, aoffsj, isuppera, &rx, xoffs, rbeta, &rz, yoffs);
      for (i = 0; i < 2 * maxn; i++) {
         if (i < yoffs || i >= yoffs + n) {
            set_error_flag(errorflag, ry.xR[i] != (double)i, __FILE__, __LINE__, "testablasunit.ap:1393");
         } else {
            set_error_flag(errorflag, fabs(ry.xR[i] - rz.xR[i]) > threshold * rmax3(fabs(ry.xR[i]), fabs(rz.xR[i]), 1.0), __FILE__, __LINE__, "testablasunit.ap:1395");
         }
      }
   // Test RMatrixSYVMV()
      rv1 = rmatrixsyvmv(n, &refra, aoffsi, aoffsj, isuppera, &rx, xoffs, &ry);
      rv2 = testablasunit_refrmatrixsyvmv(n, &refra, aoffsi, aoffsj, isuppera, &rx, xoffs);
      set_error_flag(errorflag, fabs(rv1 - rv2) > threshold * rmax3(fabs(rv1), fabs(rv2), 1.0), __FILE__, __LINE__, "testablasunit.ap:1409");
   }
   ae_frame_leave();
}

// TRSV tests
//
// Sets error flag on failure, ignores on success.
static void testablasunit_testtrsv(ae_int_t minn, ae_int_t maxn, bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t xoffs;
   bool isuppera;
   bool isunita;
   ae_int_t opa;
   double threshold;
   double v;
   ae_frame_make(&_frame_block);
   NewMatrix(refra, 0, 0, DT_REAL);
   NewMatrix(ea, 0, 0, DT_REAL);
   NewVector(rx, 0, DT_REAL);
   NewVector(ry, 0, DT_REAL);
   for (n = minn; n <= maxn; n++) {
   // Decreased threshold because of ill-conditioning of randomly generated matrices
      threshold = 1.0E-6 * (1 + n);
   // Initialize A by random matrix with size (MaxN+MaxN)*(MaxN+MaxN)
   // Initialize X by sparse random vector with size (MaxN+MaxN) (sparsity is important to test some branches of algorithm)
   // Fill Y by control values
      ae_matrix_set_length(&refra, maxn + maxn, maxn + maxn);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            refra.xyR[i][j] = randommid();
         }
      }
      ae_vector_set_length(&rx, 2 * maxn);
      ae_vector_set_length(&ry, 2 * maxn);
      for (i = 0; i < 2 * maxn; i++) {
         rx.xR[i] = randommid() * randominteger(3);
      }
   // Select random offsets and operations.
   //
   // To avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
   //
   // NOTE: in order to improve conditioning properties we add 10*Identity
   //       to purported diagonal of A
      aoffsi = randominteger(maxn);
      aoffsj = randominteger(maxn);
      xoffs = randominteger(maxn);
      isuppera = randombool();
      isunita = randombool();
      opa = randominteger(2);
      for (i = 0; i < n; i++) {
         refra.xyR[aoffsi + i][aoffsj + i] += 10;
      }
   // Test RMatrixTRSV():
   // * check that elements of RX beyond [XOffs,XOffs+N-1] are unchanged
   // * calculate RX:=TRSV(RX)
   // * extract effective A from RefRA to EA=array[N,N]
   // * compare product EA*RX, compare with copy of RX stored in RY
      for (i = 0; i < 2 * maxn; i++) {
         ry.xR[i] = rx.xR[i];
      }
      rmatrixtrsv(n, &refra, aoffsi, aoffsj, isuppera, isunita, opa, &rx, xoffs);
      for (i = 0; i < 2 * maxn; i++) {
         if (i < xoffs || i > xoffs + n - 1) {
            set_error_flag(errorflag, rx.xR[i] != ry.xR[i], __FILE__, __LINE__, "testablasunit.ap:1493");
         }
      }
      ae_matrix_set_length(&ea, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            v = refra.xyR[aoffsi + i][aoffsj + j];
            if (isuppera ? j < i : j > i) {
               v = 0.0;
            }
            if (isunita && i == j) {
               v = 1.0;
            }
            if (opa == 0) {
               ea.xyR[i][j] = v;
            } else {
               ea.xyR[j][i] = v;
            }
         }
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(ea.xyR[i], 1, &rx.xR[xoffs], 1, n);
         set_error_flag(errorflag, fabs(v - ry.xR[xoffs + i]) > threshold, __FILE__, __LINE__, "testablasunit.ap:1516");
      }
   }
   ae_frame_leave();
}

// Special test.
// On failure sets error flag, on success does not change it.
static void testablasunit_spectest(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t pass;
   ae_frame_make(&_frame_block);
   NewMatrix(emptyr2, 0, 0, DT_REAL);
   NewMatrix(emptyc2, 0, 0, DT_COMPLEX);
   NewMatrix(outputr2, 0, 0, DT_REAL);
   NewMatrix(outputc2, 0, 0, DT_COMPLEX);
// Test that SYRK, GEMM and TRSM does not reference empty argument at all.
//
// In order to perform this test we pass empty (unallocated) matrix
// with large offset; incorrect implementation will crash on such data.
   n = 128 + randominteger(65) - 32;
   ae_matrix_set_length(&outputr2, n, n);
   ae_matrix_set_length(&outputc2, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         outputr2.xyR[i][j] = 0.0;
         outputc2.xyC[i][j] = complex_from_i(0);
      }
   }
   for (pass = 0; pass <= 10; pass++) {
      rmatrixgemm(n, n, 0, 1.0, &emptyr2, 35345, 23453, randominteger(2), &emptyr2, 74764, 26845, randominteger(2), 1.0 + randominteger(2), &outputr2, 0, 0);
      rmatrixgemm(n, n, n, 0.0, &emptyr2, 35345, 23453, randominteger(2), &emptyr2, 74764, 26845, randominteger(2), 1.0 + randominteger(2), &outputr2, 0, 0);
      cmatrixgemm(n, n, 0, complex_from_d(1.0), &emptyc2, 35345, 23453, randominteger(3), &emptyc2, 74764, 26845, randominteger(3), complex_from_d(1.0 + randominteger(2)), &outputc2, 0, 0);
      cmatrixgemm(n, n, n, complex_from_d(0.0), &emptyc2, 35345, 23453, randominteger(3), &emptyc2, 74764, 26845, randominteger(3), complex_from_d(1.0 + randominteger(2)), &outputc2, 0, 0);
      rmatrixsyrk(n, 0, 1.0, &emptyr2, 54674, 34657, 2 * randominteger(2), 1.0 + randominteger(2), &outputr2, 0, 0, randombool());
      rmatrixsyrk(n, n, 0.0, &emptyr2, 54674, 34657, 2 * randominteger(2), 1.0 + randominteger(2), &outputr2, 0, 0, randombool());
      cmatrixherk(n, 0, 1.0, &emptyc2, 54674, 34657, 2 * randominteger(2), 1.0 + randominteger(2), &outputc2, 0, 0, randombool());
      cmatrixherk(n, n, 0.0, &emptyc2, 54674, 34657, 2 * randominteger(2), 1.0 + randominteger(2), &outputc2, 0, 0, randombool());
      rmatrixrighttrsm(0, 0, &emptyr2, 63463, 36345, randombool(), randombool(), randominteger(2), &outputr2, 0, 0);
      rmatrixlefttrsm(0, 0, &emptyr2, 63463, 36345, randombool(), randombool(), randominteger(2), &outputr2, 0, 0);
      cmatrixrighttrsm(0, 0, &emptyc2, 63463, 36345, randombool(), randombool(), randominteger(3), &outputc2, 0, 0);
      cmatrixlefttrsm(0, 0, &emptyc2, 63463, 36345, randombool(), randombool(), randominteger(3), &outputc2, 0, 0);
   }
   ae_frame_leave();
}

// COPY (Level 2) tests
//
// Returns False for passed test, True - for failed
static bool testablasunit_testcopy(ae_int_t minn, ae_int_t maxn) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aoffsi;
   ae_int_t aoffsj;
   ae_int_t boffsi;
   ae_int_t boffsj;
   double threshold;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(ra, 0, 0, DT_REAL);
   NewMatrix(rb, 0, 0, DT_REAL);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewMatrix(cb, 0, 0, DT_COMPLEX);
   result = false;
   threshold = 1000 * machineepsilon;
   for (mx = minn; mx <= maxn; mx++) {
   // Select random M/N in [1,MX] such that max(M,N)=MX
      m = 1 + randominteger(mx);
      n = 1 + randominteger(mx);
      if (randominteger(2) == 0) {
         m = mx;
      } else {
         n = mx;
      }
   // Initialize A by random matrix with size (MaxN+MaxN)*(MaxN+MaxN)
   // Initialize X by random vector with size (MaxN+MaxN)
   // Fill Y by control values
      ae_matrix_set_length(&ra, maxn + maxn, maxn + maxn);
      ae_matrix_set_length(&ca, maxn + maxn, maxn + maxn);
      ae_matrix_set_length(&rb, maxn + maxn, maxn + maxn);
      ae_matrix_set_length(&cb, maxn + maxn, maxn + maxn);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            ra.xyR[i][j] = randommid();
            ca.xyC[i][j] = complex_from_d(randommid(), randommid());
            rb.xyR[i][j] = (double)(1 + 2 * i + 3 * j);
            cb.xyC[i][j] = complex_from_i(1 + 2 * i + 3 * j);
         }
      }
   // test different offsets (zero or one)
   //
   // to avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      aoffsi = randominteger(maxn);
      aoffsj = randominteger(maxn);
      boffsi = randominteger(maxn);
      boffsj = randominteger(maxn);
      cmatrixcopy(m, n, &ca, aoffsi, aoffsj, &cb, boffsi, boffsj);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            if (((i < boffsi || i >= boffsi + m) || j < boffsj) || j >= boffsj + n) {
               result = result || ae_c_neq_d(cb.xyC[i][j], (double)(1 + 2 * i + 3 * j));
            } else {
               result = result || abscomplex(ae_c_sub(ca.xyC[aoffsi + i - boffsi][aoffsj + j - boffsj], cb.xyC[i][j])) > threshold;
            }
         }
      }
      rmatrixcopy(m, n, &ra, aoffsi, aoffsj, &rb, boffsi, boffsj);
      for (i = 0; i < 2 * maxn; i++) {
         for (j = 0; j < 2 * maxn; j++) {
            if (((i < boffsi || i >= boffsi + m) || j < boffsj) || j >= boffsj + n) {
               result = result || rb.xyR[i][j] != (double)(1 + 2 * i + 3 * j);
            } else {
               result = result || fabs(ra.xyR[aoffsi + i - boffsi][aoffsj + j - boffsj] - rb.xyR[i][j]) > threshold;
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// COPY (Level 1) tests
//
// On failure sets error flag, on success does not touch it
static void testablasunit_testcopy1(ae_int_t minn, ae_int_t maxn, bool *err) {
   ae_frame _frame_block;
   ae_int_t ss;
   ae_int_t i;
   ae_int_t aoffs;
   ae_int_t boffs;
   double threshold;
   ae_frame_make(&_frame_block);
   NewVector(ra, 0, DT_REAL);
   NewVector(rb, 0, DT_REAL);
   threshold = 1000 * machineepsilon;
   for (ss = minn; ss <= maxn; ss++) {
   // Initialize A by random vector
   // Initialize X by random vector
   // Fill Y by control values
      ae_vector_set_length(&ra, 2 * maxn);
      ae_vector_set_length(&rb, 2 * maxn);
      for (i = 0; i < 2 * maxn; i++) {
         ra.xR[i] = randommid();
         rb.xR[i] = (double)(1 + 2 * i);
      }
   // test different offsets (zero or one)
   //
   // to avoid unnecessary slowdown we don't test ALL possible
   // combinations of operation types. We just generate one random
   // set of parameters and test it.
      aoffs = randominteger(maxn);
      boffs = randominteger(maxn);
      rvectorcopy(ss, &ra, aoffs, &rb, boffs);
      for (i = 0; i < 2 * maxn; i++) {
         if (i < boffs || i >= boffs + ss) {
            set_error_flag(err, rb.xR[i] != (double)(1 + 2 * i), __FILE__, __LINE__, "testablasunit.ap:1762");
         } else {
            set_error_flag(err, fabs(ra.xR[aoffs + i - boffs] - rb.xR[i]) > threshold, __FILE__, __LINE__, "testablasunit.ap:1764");
         }
      }
   }
   ae_frame_leave();
}

static void testablasunit_testreflections(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t m;
   ae_int_t maxmn;
   double tmp;
   double beta;
   double tau;
   double err;
   double mer;
   double mel;
   double meg;
   ae_int_t pass;
   ae_int_t passcount;
   double threshold;
   ae_int_t tasktype;
   double xscale;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(v, 0, DT_REAL);
   NewVector(work, 0, DT_REAL);
   NewMatrix(h, 0, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   passcount = 10;
   threshold = 100 * machineepsilon;
   mer = 0.0;
   mel = 0.0;
   meg = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= 10; n++) {
         for (m = 1; m <= 10; m++) {
         // Task
            n = 1 + randominteger(10);
            m = 1 + randominteger(10);
            maxmn = imax2(m, n);
         // Initialize
            ae_vector_set_length(&x, maxmn + 1);
            ae_vector_set_length(&v, maxmn + 1);
            ae_vector_set_length(&work, maxmn + 1);
            ae_matrix_set_length(&h, maxmn + 1, maxmn + 1);
            ae_matrix_set_length(&a, maxmn + 1, maxmn + 1);
            ae_matrix_set_length(&b, maxmn + 1, maxmn + 1);
            ae_matrix_set_length(&c, maxmn + 1, maxmn + 1);
         // GenerateReflection, three tasks are possible:
         // * random X
         // * zero X
         // * non-zero X[1], all other are zeros
         // * random X, near underflow scale
         // * random X, near overflow scale
            for (tasktype = 0; tasktype <= 4; tasktype++) {
               xscale = 1.0;
               if (tasktype == 0) {
                  for (i = 1; i <= n; i++) {
                     x.xR[i] = randommid();
                  }
               }
               if (tasktype == 1) {
                  for (i = 1; i <= n; i++) {
                     x.xR[i] = 0.0;
                  }
               }
               if (tasktype == 2) {
                  x.xR[1] = randommid();
                  for (i = 2; i <= n; i++) {
                     x.xR[i] = 0.0;
                  }
               }
               if (tasktype == 3) {
                  for (i = 1; i <= n; i++) {
                     x.xR[i] = (randominteger(21) - 10) * minrealnumber;
                  }
                  xscale = 10 * minrealnumber;
               }
               if (tasktype == 4) {
                  for (i = 1; i <= n; i++) {
                     x.xR[i] = randommid() * maxrealnumber;
                  }
                  xscale = maxrealnumber;
               }
               ae_v_move(&v.xR[1], 1, &x.xR[1], 1, n);
               generatereflection(&v, n, &tau);
               beta = v.xR[1];
               v.xR[1] = 1.0;
               for (i = 1; i <= n; i++) {
                  for (j = 1; j <= n; j++) {
                     if (i == j) {
                        h.xyR[i][j] = 1 - tau * v.xR[i] * v.xR[j];
                     } else {
                        h.xyR[i][j] = -tau * v.xR[i] * v.xR[j];
                     }
                  }
               }
               err = 0.0;
               for (i = 1; i <= n; i++) {
                  tmp = ae_v_dotproduct(&h.xyR[i][1], 1, &x.xR[1], 1, n);
                  if (i == 1) {
                     err = rmax2(err, fabs(tmp - beta));
                  } else {
                     err = rmax2(err, fabs(tmp));
                  }
               }
               meg = rmax2(meg, err / xscale);
            }
         // ApplyReflectionFromTheLeft
            for (i = 1; i <= m; i++) {
               x.xR[i] = randommid();
               v.xR[i] = x.xR[i];
            }
            for (i = 1; i <= m; i++) {
               for (j = 1; j <= n; j++) {
                  a.xyR[i][j] = randommid();
                  b.xyR[i][j] = a.xyR[i][j];
               }
            }
            generatereflection(&v, m, &tau);
            beta = v.xR[1];
            v.xR[1] = 1.0;
            applyreflectionfromtheleft(&b, tau, &v, 1, m, 1, n, &work);
            for (i = 1; i <= m; i++) {
               for (j = 1; j <= m; j++) {
                  if (i == j) {
                     h.xyR[i][j] = 1 - tau * v.xR[i] * v.xR[j];
                  } else {
                     h.xyR[i][j] = -tau * v.xR[i] * v.xR[j];
                  }
               }
            }
            for (i = 1; i <= m; i++) {
               for (j = 1; j <= n; j++) {
                  tmp = ae_v_dotproduct(&h.xyR[i][1], 1, &a.xyR[1][j], a.stride, m);
                  c.xyR[i][j] = tmp;
               }
            }
            err = 0.0;
            for (i = 1; i <= m; i++) {
               for (j = 1; j <= n; j++) {
                  err = rmax2(err, fabs(b.xyR[i][j] - c.xyR[i][j]));
               }
            }
            mel = rmax2(mel, err);
         // ApplyReflectionFromTheRight
            for (i = 1; i <= n; i++) {
               x.xR[i] = randommid();
               v.xR[i] = x.xR[i];
            }
            for (i = 1; i <= m; i++) {
               for (j = 1; j <= n; j++) {
                  a.xyR[i][j] = randommid();
                  b.xyR[i][j] = a.xyR[i][j];
               }
            }
            generatereflection(&v, n, &tau);
            beta = v.xR[1];
            v.xR[1] = 1.0;
            applyreflectionfromtheright(&b, tau, &v, 1, m, 1, n, &work);
            for (i = 1; i <= n; i++) {
               for (j = 1; j <= n; j++) {
                  if (i == j) {
                     h.xyR[i][j] = 1 - tau * v.xR[i] * v.xR[j];
                  } else {
                     h.xyR[i][j] = -tau * v.xR[i] * v.xR[j];
                  }
               }
            }
            for (i = 1; i <= m; i++) {
               for (j = 1; j <= n; j++) {
                  tmp = ae_v_dotproduct(&a.xyR[i][1], 1, &h.xyR[1][j], h.stride, n);
                  c.xyR[i][j] = tmp;
               }
            }
            err = 0.0;
            for (i = 1; i <= m; i++) {
               for (j = 1; j <= n; j++) {
                  err = rmax2(err, fabs(b.xyR[i][j] - c.xyR[i][j]));
               }
            }
            mer = rmax2(mer, err);
         }
      }
   }
// Overflow crash test
   ae_vector_set_length(&x, 10 + 1);
   ae_vector_set_length(&v, 10 + 1);
   for (i = 1; i <= 10; i++) {
      v.xR[i] = maxrealnumber * 0.01 * randommid();
   }
   generatereflection(&v, 10, &tau);
// Result
   set_error_flag(errorflag, (meg > threshold || mel > threshold) || mer > threshold, __FILE__, __LINE__, "testablasunit.ap:1956");
   ae_frame_leave();
}

bool testablas(bool silent) {
   ae_frame _frame_block;
   ae_int_t n0;
   ae_int_t n1;
   bool trsmerrors;
   bool syrkerrors;
   bool gemmerrors;
   bool transerrors;
   bool rank1errors;
   bool gemverrors;
   bool symverrors;
   bool trsverrors;
   bool reflerrors;
   bool copyerrors;
   bool copy1errors;
   bool specerrors;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(ra, 0, 0, DT_REAL);
   trsmerrors = false;
   syrkerrors = false;
   gemmerrors = false;
   transerrors = false;
   rank1errors = false;
   gemverrors = false;
   symverrors = false;
   trsverrors = false;
   reflerrors = false;
   copyerrors = false;
   copy1errors = false;
   waserrors = false;
   specerrors = false;
   testablasunit_spectest(&specerrors);
   trsmerrors = trsmerrors || testablasunit_testtrsm(1, 3 * matrixtilesizea() + 1);
   syrkerrors = syrkerrors || testablasunit_testsyrk(1, 3 * matrixtilesizea() + 1);
   gemmerrors = gemmerrors || testablasunit_testgemm(1, 3 * matrixtilesizea() + 1);
   transerrors = transerrors || testablasunit_testtrans(1, 3 * matrixtilesizea() + 1);
   rank1errors = rank1errors || testablasunit_testrank1(1, 3 * matrixtilesizea() + 1);
   gemverrors = gemverrors || testablasunit_testgemv(1, 3 * matrixtilesizea() + 1);
   copyerrors = copyerrors || testablasunit_testcopy(1, 3 * matrixtilesizea() + 1);
   testablasunit_testsymv(1, 3 * matrixtilesizea() + 1, &symverrors);
   testablasunit_testtrsv(1, 3 * matrixtilesizea() + 1, &trsverrors);
   testablasunit_testreflections(&reflerrors);
   n0 = 6 * matrixtilesizeb();
   n1 = 6 * matrixtilesizeb();
   gemmerrors = gemmerrors || testablasunit_testgemm(n0, n1);
   trsmerrors = trsmerrors || testablasunit_testtrsm(n0, n1);
   syrkerrors = syrkerrors || testablasunit_testsyrk(n0, n1);
   testablasunit_testcopy1(1, 3 * matrixtilesizea() + 1, &copy1errors);
// report
   waserrors = ((((((((((trsmerrors || syrkerrors) || gemmerrors) || transerrors) || rank1errors) || gemverrors) || symverrors) || trsverrors) || reflerrors) || copyerrors) || copy1errors) || specerrors;
   if (!silent) {
      printf("TESTING ABLAS\n");
      printf("LEVEL 3 FUNCTIONS:\n");
      printf("* TRSM                                   ");
      if (trsmerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* SYRK                                   ");
      if (syrkerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* GEMM                                   ");
      if (gemmerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("LEVEL 2 FUNCTIONS:\n");
      printf("* TRANS                                  ");
      if (transerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* RANK1                                  ");
      if (rank1errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* GEMV                                   ");
      if (gemverrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* SYMV/SYVMV                             ");
      if (symverrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* TRSV                                   ");
      if (trsverrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* REFL                                   ");
      if (reflerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* COPY                                   ");
      if (copyerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("LEVEL 1 FUNCTIONS:\n");
      printf("* COPY                                   ");
      if (copy1errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("SPECIAL TESTS                            ");
      if (specerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === hblas testing unit ===
bool testhblas(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t i2;
   bool waserrors;
   double mverr;
   double threshold;
   complex alpha;
   complex v;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(ua, 0, 0, DT_COMPLEX);
   NewMatrix(la, 0, 0, DT_COMPLEX);
   NewVector(x, 0, DT_COMPLEX);
   NewVector(y1, 0, DT_COMPLEX);
   NewVector(y2, 0, DT_COMPLEX);
   NewVector(y3, 0, DT_COMPLEX);
   mverr = 0.0;
   waserrors = false;
   maxn = 10;
   threshold = 1000 * machineepsilon;
// Test MV
   for (n = 2; n <= maxn; n++) {
      ae_matrix_set_length(&a, n + 1, n + 1);
      ae_matrix_set_length(&ua, n + 1, n + 1);
      ae_matrix_set_length(&la, n + 1, n + 1);
      ae_vector_set_length(&x, n + 1);
      ae_vector_set_length(&y1, n + 1);
      ae_vector_set_length(&y2, n + 1);
      ae_vector_set_length(&y3, n + 1);
   // fill A, UA, LA
      for (i = 1; i <= n; i++) {
         a.xyC[i][i] = complex_from_d(randommid());
         for (j = i + 1; j <= n; j++) {
            a.xyC[i][j] = complex_from_d(randommid(), randommid());
            a.xyC[j][i] = conj(a.xyC[i][j]);
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= n; j++) {
            ua.xyC[i][j] = complex_from_i(0);
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = i; j <= n; j++) {
            ua.xyC[i][j] = a.xyC[i][j];
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= n; j++) {
            la.xyC[i][j] = complex_from_i(0);
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= i; j++) {
            la.xyC[i][j] = a.xyC[i][j];
         }
      }
   // test on different I1, I2
      for (i1 = 1; i1 <= n; i1++) {
         for (i2 = i1; i2 <= n; i2++) {
         // Fill X, choose Alpha
            for (i = 1; i <= i2 - i1 + 1; i++) {
               x.xC[i] = complex_from_d(randommid(), randommid());
            }
            alpha = complex_from_d(randommid(), randommid());
         // calculate A*x, UA*x, LA*x
            for (i = i1; i <= i2; i++) {
               v = ae_v_cdotproduct(&a.xyC[i][i1], 1, "N", &x.xC[1], 1, "N", i2 - i1 + 1);
               y1.xC[i - i1 + 1] = ae_c_mul(alpha, v);
            }
            hermitianmatrixvectormultiply(&ua, true, i1, i2, &x, alpha, &y2);
            hermitianmatrixvectormultiply(&la, false, i1, i2, &x, alpha, &y3);
         // Calculate error
            ae_v_csub(&y2.xC[1], 1, &y1.xC[1], 1, "N", i2 - i1 + 1);
            v = ae_v_cdotproduct(&y2.xC[1], 1, "N", &y2.xC[1], 1, "Conj", i2 - i1 + 1);
            mverr = rmax2(mverr, sqrt(abscomplex(v)));
            ae_v_csub(&y3.xC[1], 1, &y1.xC[1], 1, "N", i2 - i1 + 1);
            v = ae_v_cdotproduct(&y3.xC[1], 1, "N", &y3.xC[1], 1, "Conj", i2 - i1 + 1);
            mverr = rmax2(mverr, sqrt(abscomplex(v)));
         }
      }
   }
// report
   waserrors = mverr > threshold;
   if (!silent) {
      printf("TESTING HERMITIAN BLAS\n");
      printf("MV error:                                %5.3e\n", mverr);
      printf("Threshold:                               %5.3e\n", threshold);
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === creflections testing unit ===
bool testcreflections(bool silent) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t m;
   ae_int_t maxmn;
   complex tmp;
   complex beta;
   complex tau;
   double err;
   double mer;
   double mel;
   double meg;
   ae_int_t pass;
   ae_int_t passcount;
   bool waserrors;
   double threshold;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_COMPLEX);
   NewVector(v, 0, DT_COMPLEX);
   NewVector(work, 0, DT_COMPLEX);
   NewMatrix(h, 0, 0, DT_COMPLEX);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(b, 0, 0, DT_COMPLEX);
   NewMatrix(c, 0, 0, DT_COMPLEX);
   threshold = 1000 * machineepsilon;
   passcount = 1000;
   mer = 0.0;
   mel = 0.0;
   meg = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
   // Task
      n = 1 + randominteger(10);
      m = 1 + randominteger(10);
      maxmn = imax2(m, n);
   // Initialize
      ae_vector_set_length(&x, maxmn + 1);
      ae_vector_set_length(&v, maxmn + 1);
      ae_vector_set_length(&work, maxmn + 1);
      ae_matrix_set_length(&h, maxmn + 1, maxmn + 1);
      ae_matrix_set_length(&a, maxmn + 1, maxmn + 1);
      ae_matrix_set_length(&b, maxmn + 1, maxmn + 1);
      ae_matrix_set_length(&c, maxmn + 1, maxmn + 1);
   // GenerateReflection
      for (i = 1; i <= n; i++) {
         x.xC[i] = complex_from_d(randommid(), randommid());
         v.xC[i] = x.xC[i];
      }
      complexgeneratereflection(&v, n, &tau);
      beta = v.xC[1];
      v.xC[1] = complex_from_i(1);
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= n; j++) {
            if (i == j) {
               h.xyC[i][j] = ae_c_d_sub(1, ae_c_mul(ae_c_mul(tau, v.xC[i]), conj(v.xC[j])));
            } else {
               h.xyC[i][j] = ae_c_neg(ae_c_mul(ae_c_mul(tau, v.xC[i]), conj(v.xC[j])));
            }
         }
      }
      err = 0.0;
      for (i = 1; i <= n; i++) {
         tmp = ae_v_cdotproduct(&h.xyC[1][i], h.stride, "Conj", &x.xC[1], 1, "N", n);
         if (i == 1) {
            err = rmax2(err, abscomplex(ae_c_sub(tmp, beta)));
         } else {
            err = rmax2(err, abscomplex(tmp));
         }
      }
      err = rmax2(err, fabs(beta.y));
      meg = rmax2(meg, err);
   // ApplyReflectionFromTheLeft
      for (i = 1; i <= m; i++) {
         x.xC[i] = complex_from_d(randommid(), randommid());
         v.xC[i] = x.xC[i];
      }
      for (i = 1; i <= m; i++) {
         for (j = 1; j <= n; j++) {
            a.xyC[i][j] = complex_from_d(randommid(), randommid());
            b.xyC[i][j] = a.xyC[i][j];
         }
      }
      complexgeneratereflection(&v, m, &tau);
      beta = v.xC[1];
      v.xC[1] = complex_from_i(1);
      complexapplyreflectionfromtheleft(&b, tau, &v, 1, m, 1, n, &work);
      for (i = 1; i <= m; i++) {
         for (j = 1; j <= m; j++) {
            if (i == j) {
               h.xyC[i][j] = ae_c_d_sub(1, ae_c_mul(ae_c_mul(tau, v.xC[i]), conj(v.xC[j])));
            } else {
               h.xyC[i][j] = ae_c_neg(ae_c_mul(ae_c_mul(tau, v.xC[i]), conj(v.xC[j])));
            }
         }
      }
      for (i = 1; i <= m; i++) {
         for (j = 1; j <= n; j++) {
            tmp = ae_v_cdotproduct(&h.xyC[i][1], 1, "N", &a.xyC[1][j], a.stride, "N", m);
            c.xyC[i][j] = tmp;
         }
      }
      err = 0.0;
      for (i = 1; i <= m; i++) {
         for (j = 1; j <= n; j++) {
            err = rmax2(err, abscomplex(ae_c_sub(b.xyC[i][j], c.xyC[i][j])));
         }
      }
      mel = rmax2(mel, err);
   // ApplyReflectionFromTheRight
      for (i = 1; i <= n; i++) {
         x.xC[i] = complex_from_d(randommid());
         v.xC[i] = x.xC[i];
      }
      for (i = 1; i <= m; i++) {
         for (j = 1; j <= n; j++) {
            a.xyC[i][j] = complex_from_d(randommid());
            b.xyC[i][j] = a.xyC[i][j];
         }
      }
      complexgeneratereflection(&v, n, &tau);
      beta = v.xC[1];
      v.xC[1] = complex_from_i(1);
      complexapplyreflectionfromtheright(&b, tau, &v, 1, m, 1, n, &work);
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= n; j++) {
            if (i == j) {
               h.xyC[i][j] = ae_c_d_sub(1, ae_c_mul(ae_c_mul(tau, v.xC[i]), conj(v.xC[j])));
            } else {
               h.xyC[i][j] = ae_c_neg(ae_c_mul(ae_c_mul(tau, v.xC[i]), conj(v.xC[j])));
            }
         }
      }
      for (i = 1; i <= m; i++) {
         for (j = 1; j <= n; j++) {
            tmp = ae_v_cdotproduct(&a.xyC[i][1], 1, "N", &h.xyC[1][j], h.stride, "N", n);
            c.xyC[i][j] = tmp;
         }
      }
      err = 0.0;
      for (i = 1; i <= m; i++) {
         for (j = 1; j <= n; j++) {
            err = rmax2(err, abscomplex(ae_c_sub(b.xyC[i][j], c.xyC[i][j])));
         }
      }
      mer = rmax2(mer, err);
   }
// Overflow crash test
   ae_vector_set_length(&x, 10 + 1);
   ae_vector_set_length(&v, 10 + 1);
   for (i = 1; i <= 10; i++) {
      v.xC[i] = complex_from_d(maxrealnumber * 0.01 * randommid());
   }
   complexgeneratereflection(&v, 10, &tau);
// report
   waserrors = (meg > threshold || mel > threshold) || mer > threshold;
   if (!silent) {
      printf("TESTING COMPLEX REFLECTIONS\n");
      printf("Generate error:                          %5.3e\n", meg);
      printf("Apply(L) error:                          %5.3e\n", mel);
      printf("Apply(R) error:                          %5.3e\n", mer);
      printf("Threshold:                               %5.3e\n", threshold);
      printf("Overflow crash test:                     PASSED\n");
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === sblas testing unit ===
bool testsblas(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t i2;
   bool waserrors;
   double mverr;
   double threshold;
   double alpha;
   double v;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ua, 0, 0, DT_REAL);
   NewMatrix(la, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(y3, 0, DT_REAL);
   mverr = 0.0;
   waserrors = false;
   maxn = 10;
   threshold = 1000 * machineepsilon;
// Test MV
   for (n = 2; n <= maxn; n++) {
      ae_matrix_set_length(&a, n + 1, n + 1);
      ae_matrix_set_length(&ua, n + 1, n + 1);
      ae_matrix_set_length(&la, n + 1, n + 1);
      ae_vector_set_length(&x, n + 1);
      ae_vector_set_length(&y1, n + 1);
      ae_vector_set_length(&y2, n + 1);
      ae_vector_set_length(&y3, n + 1);
   // fill A, UA, LA
      for (i = 1; i <= n; i++) {
         a.xyR[i][i] = randommid();
         for (j = i + 1; j <= n; j++) {
            a.xyR[i][j] = randommid();
            a.xyR[j][i] = a.xyR[i][j];
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= n; j++) {
            ua.xyR[i][j] = 0.0;
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = i; j <= n; j++) {
            ua.xyR[i][j] = a.xyR[i][j];
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= n; j++) {
            la.xyR[i][j] = 0.0;
         }
      }
      for (i = 1; i <= n; i++) {
         for (j = 1; j <= i; j++) {
            la.xyR[i][j] = a.xyR[i][j];
         }
      }
   // test on different I1, I2
      for (i1 = 1; i1 <= n; i1++) {
         for (i2 = i1; i2 <= n; i2++) {
         // Fill X, choose Alpha
            for (i = 1; i <= i2 - i1 + 1; i++) {
               x.xR[i] = randommid();
            }
            alpha = randommid();
         // calculate A*x, UA*x, LA*x
            for (i = i1; i <= i2; i++) {
               v = ae_v_dotproduct(&a.xyR[i][i1], 1, &x.xR[1], 1, i2 - i1 + 1);
               y1.xR[i - i1 + 1] = alpha * v;
            }
            symmetricmatrixvectormultiply(&ua, true, i1, i2, &x, alpha, &y2);
            symmetricmatrixvectormultiply(&la, false, i1, i2, &x, alpha, &y3);
         // Calculate error
            ae_v_sub(&y2.xR[1], 1, &y1.xR[1], 1, i2 - i1 + 1);
            v = ae_v_dotproduct(&y2.xR[1], 1, &y2.xR[1], 1, i2 - i1 + 1);
            mverr = rmax2(mverr, sqrt(v));
            ae_v_sub(&y3.xR[1], 1, &y1.xR[1], 1, i2 - i1 + 1);
            v = ae_v_dotproduct(&y3.xR[1], 1, &y3.xR[1], 1, i2 - i1 + 1);
            mverr = rmax2(mverr, sqrt(v));
         }
      }
   }
// report
   waserrors = mverr > threshold;
   if (!silent) {
      printf("TESTING SYMMETRIC BLAS\n");
      printf("MV error:                                %5.3e\n", mverr);
      printf("Threshold:                               %5.3e\n", threshold);
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === ortfac testing unit ===
// Diff
static double testortfacunit_rmatrixdiff(RMatrix *a, RMatrix *b, ae_int_t m, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   double result;
   result = 0.0;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         result = rmax2(result, fabs(b->xyR[i][j] - a->xyR[i][j]));
      }
   }
   return result;
}

// Copy
static void testortfacunit_rmatrixmakeacopy(RMatrix *a, ae_int_t m, ae_int_t n, RMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m - 1 + 1, n - 1 + 1);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyR[i][j] = a->xyR[i][j];
      }
   }
}

// Copy
static void testortfacunit_cmatrixmakeacopy(CMatrix *a, ae_int_t m, ae_int_t n, CMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m - 1 + 1, n - 1 + 1);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyC[i][j] = a->xyC[i][j];
      }
   }
}

// Sparse fill
static void testortfacunit_rmatrixfillsparsea(RMatrix *a, ae_int_t m, ae_int_t n, double sparsity) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         if (randombool(sparsity)) {
            a->xyR[i][j] = 0.0;
         } else {
            a->xyR[i][j] = randommid();
         }
      }
   }
}

// Sparse fill
static void testortfacunit_cmatrixfillsparsea(CMatrix *a, ae_int_t m, ae_int_t n, double sparsity) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         if (randombool(sparsity)) {
            a->xyC[i][j] = complex_from_i(0);
         } else {
            a->xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
   }
}

// Matrix multiplication
static void testortfacunit_internalmatrixmatrixmultiply(RMatrix *a, ae_int_t ai1, ae_int_t ai2, ae_int_t aj1, ae_int_t aj2, bool transa, RMatrix *b, ae_int_t bi1, ae_int_t bi2, ae_int_t bj1, ae_int_t bj2, bool transb, RMatrix *c, ae_int_t ci1, ae_int_t ci2, ae_int_t cj1, ae_int_t cj2) {
   ae_frame _frame_block;
   ae_int_t arows;
   ae_int_t acols;
   ae_int_t brows;
   ae_int_t bcols;
   ae_int_t crows;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   ae_int_t r;
   double v;
   double beta;
   double alpha;
   ae_frame_make(&_frame_block);
   NewVector(work, 0, DT_REAL);
// Pre-setup
   k = imax2(ai2 - ai1 + 1, aj2 - aj1 + 1);
   k = imax2(k, bi2 - bi1 + 1);
   k = imax2(k, bj2 - bj1 + 1);
   ae_vector_set_length(&work, k + 1);
   beta = 0.0;
   alpha = 1.0;
// Setup
   if (!transa) {
      arows = ai2 - ai1 + 1;
      acols = aj2 - aj1 + 1;
   } else {
      arows = aj2 - aj1 + 1;
      acols = ai2 - ai1 + 1;
   }
   if (!transb) {
      brows = bi2 - bi1 + 1;
      bcols = bj2 - bj1 + 1;
   } else {
      brows = bj2 - bj1 + 1;
      bcols = bi2 - bi1 + 1;
   }
   ae_assert(acols == brows, "MatrixMatrixMultiply: incorrect matrix sizes!");
   if (((arows <= 0 || acols <= 0) || brows <= 0) || bcols <= 0) {
      ae_frame_leave();
      return;
   }
   crows = arows;
// Test WORK
   i = imax2(arows, acols);
   i = imax2(brows, i);
   i = imax2(i, bcols);
   work.xR[1] = 0.0;
   work.xR[i] = 0.0;
// Prepare C
   if (beta == 0.0) {
      for (i = ci1; i <= ci2; i++) {
         for (j = cj1; j <= cj2; j++) {
            c->xyR[i][j] = 0.0;
         }
      }
   } else {
      for (i = ci1; i <= ci2; i++) {
         ae_v_muld(&c->xyR[i][cj1], 1, cj2 - cj1 + 1, beta);
      }
   }
// A*B
   if (!transa && !transb) {
      for (l = ai1; l <= ai2; l++) {
         for (r = bi1; r <= bi2; r++) {
            v = alpha * a->xyR[l][aj1 + r - bi1];
            k = ci1 + l - ai1;
            ae_v_addd(&c->xyR[k][cj1], 1, &b->xyR[r][bj1], 1, cj2 - cj1 + 1, v);
         }
      }
      ae_frame_leave();
      return;
   }
// A*B'
   if (!transa && transb) {
      if (arows * acols < brows * bcols) {
         for (r = bi1; r <= bi2; r++) {
            for (l = ai1; l <= ai2; l++) {
               v = ae_v_dotproduct(&a->xyR[l][aj1], 1, &b->xyR[r][bj1], 1, aj2 - aj1 + 1);
               c->xyR[ci1 + l - ai1][cj1 + r - bi1] += alpha * v;
            }
         }
         ae_frame_leave();
         return;
      } else {
         for (l = ai1; l <= ai2; l++) {
            for (r = bi1; r <= bi2; r++) {
               v = ae_v_dotproduct(&a->xyR[l][aj1], 1, &b->xyR[r][bj1], 1, aj2 - aj1 + 1);
               c->xyR[ci1 + l - ai1][cj1 + r - bi1] += alpha * v;
            }
         }
         ae_frame_leave();
         return;
      }
   }
// A'*B
   if (transa && !transb) {
      for (l = aj1; l <= aj2; l++) {
         for (r = bi1; r <= bi2; r++) {
            v = alpha * a->xyR[ai1 + r - bi1][l];
            k = ci1 + l - aj1;
            ae_v_addd(&c->xyR[k][cj1], 1, &b->xyR[r][bj1], 1, cj2 - cj1 + 1, v);
         }
      }
      ae_frame_leave();
      return;
   }
// A'*B'
   if (transa && transb) {
      if (arows * acols < brows * bcols) {
         for (r = bi1; r <= bi2; r++) {
            for (i = 1; i <= crows; i++) {
               work.xR[i] = 0.0;
            }
            for (l = ai1; l <= ai2; l++) {
               v = alpha * b->xyR[r][bj1 + l - ai1];
               k = cj1 + r - bi1;
               ae_v_addd(&work.xR[1], 1, &a->xyR[l][aj1], 1, crows, v);
            }
            ae_v_add(&c->xyR[ci1][k], c->stride, &work.xR[1], 1, ci2 - ci1 + 1);
         }
         ae_frame_leave();
         return;
      } else {
         for (l = aj1; l <= aj2; l++) {
            k = ai2 - ai1 + 1;
            ae_v_move(&work.xR[1], 1, &a->xyR[ai1][l], a->stride, k);
            for (r = bi1; r <= bi2; r++) {
               v = ae_v_dotproduct(&work.xR[1], 1, &b->xyR[r][bj1], 1, k);
               c->xyR[ci1 + l - aj1][cj1 + r - bi1] += alpha * v;
            }
         }
         ae_frame_leave();
         return;
      }
   }
   ae_frame_leave();
}

// Problem testing
static void testortfacunit_testrqrproblem(RMatrix *a, ae_int_t m, ae_int_t n, double threshold, bool *qrerrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_frame_make(&_frame_block);
   NewMatrix(b, 0, 0, DT_REAL);
   NewVector(taub, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(r, 0, 0, DT_REAL);
   NewMatrix(q2, 0, 0, DT_REAL);
// Test decompose-and-unpack error
   testortfacunit_rmatrixmakeacopy(a, m, n, &b);
   rmatrixqr(&b, m, n, &taub);
   rmatrixqrunpackq(&b, m, n, &taub, m, &q);
   rmatrixqrunpackr(&b, m, n, &r);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(q.xyR[i], 1, &r.xyR[0][j], r.stride, m);
         *qrerrors = *qrerrors || fabs(v - a->xyR[i][j]) > threshold;
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < imin2(i, n - 1); j++) {
         *qrerrors = *qrerrors || r.xyR[i][j] != 0.0;
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(q.xyR[i], 1, q.xyR[j], 1, m);
         if (i == j) {
            v--;
         }
         *qrerrors = *qrerrors || fabs(v) >= threshold;
      }
   }
// Test for other errors
   k = 1 + randominteger(m);
   rmatrixqrunpackq(&b, m, n, &taub, k, &q2);
   for (i = 0; i < m; i++) {
      for (j = 0; j < k; j++) {
         *qrerrors = *qrerrors || fabs(q2.xyR[i][j] - q.xyR[i][j]) > 10 * machineepsilon;
      }
   }
   ae_frame_leave();
}

// Problem testing
static void testortfacunit_testcqrproblem(CMatrix *a, ae_int_t m, ae_int_t n, double threshold, bool *qrerrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   complex v;
   ae_frame_make(&_frame_block);
   NewMatrix(b, 0, 0, DT_COMPLEX);
   NewVector(taub, 0, DT_COMPLEX);
   NewMatrix(q, 0, 0, DT_COMPLEX);
   NewMatrix(r, 0, 0, DT_COMPLEX);
   NewMatrix(q2, 0, 0, DT_COMPLEX);
// Test decompose-and-unpack error
   testortfacunit_cmatrixmakeacopy(a, m, n, &b);
   cmatrixqr(&b, m, n, &taub);
   cmatrixqrunpackq(&b, m, n, &taub, m, &q);
   cmatrixqrunpackr(&b, m, n, &r);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(q.xyC[i], 1, "N", &r.xyC[0][j], r.stride, "N", m);
         *qrerrors = *qrerrors || abscomplex(ae_c_sub(v, a->xyC[i][j])) > threshold;
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < imin2(i, n - 1); j++) {
         *qrerrors = *qrerrors || ae_c_neq_d(r.xyC[i][j], 0.0);
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < m; j++) {
         v = ae_v_cdotproduct(q.xyC[i], 1, "N", q.xyC[j], 1, "Conj", m);
         if (i == j) {
            v = ae_c_sub_d(v, 1);
         }
         *qrerrors = *qrerrors || abscomplex(v) >= threshold;
      }
   }
// Test for other errors
   k = 1 + randominteger(m);
   cmatrixqrunpackq(&b, m, n, &taub, k, &q2);
   for (i = 0; i < m; i++) {
      for (j = 0; j < k; j++) {
         *qrerrors = *qrerrors || abscomplex(ae_c_sub(q2.xyC[i][j], q.xyC[i][j])) > 10 * machineepsilon;
      }
   }
   ae_frame_leave();
}

// Problem testing
static void testortfacunit_testrlqproblem(RMatrix *a, ae_int_t m, ae_int_t n, double threshold, bool *lqerrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_frame_make(&_frame_block);
   NewMatrix(b, 0, 0, DT_REAL);
   NewVector(taub, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(l, 0, 0, DT_REAL);
   NewMatrix(q2, 0, 0, DT_REAL);
// Test decompose-and-unpack error
   testortfacunit_rmatrixmakeacopy(a, m, n, &b);
   rmatrixlq(&b, m, n, &taub);
   rmatrixlqunpackq(&b, m, n, &taub, n, &q);
   rmatrixlqunpackl(&b, m, n, &l);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(l.xyR[i], 1, &q.xyR[0][j], q.stride, n);
         *lqerrors = *lqerrors || fabs(v - a->xyR[i][j]) >= threshold;
      }
   }
   for (i = 0; i < m; i++) {
      for (j = imin2(i, n - 1) + 1; j < n; j++) {
         *lqerrors = *lqerrors || l.xyR[i][j] != 0.0;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(q.xyR[i], 1, q.xyR[j], 1, n);
         if (i == j) {
            v--;
         }
         *lqerrors = *lqerrors || fabs(v) >= threshold;
      }
   }
// Test for other errors
   k = 1 + randominteger(n);
   rmatrixlqunpackq(&b, m, n, &taub, k, &q2);
   for (i = 0; i < k; i++) {
      for (j = 0; j < n; j++) {
         *lqerrors = *lqerrors || fabs(q2.xyR[i][j] - q.xyR[i][j]) > 10 * machineepsilon;
      }
   }
   ae_frame_leave();
}

// Problem testing
static void testortfacunit_testclqproblem(CMatrix *a, ae_int_t m, ae_int_t n, double threshold, bool *lqerrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   complex v;
   ae_frame_make(&_frame_block);
   NewMatrix(b, 0, 0, DT_COMPLEX);
   NewVector(taub, 0, DT_COMPLEX);
   NewMatrix(q, 0, 0, DT_COMPLEX);
   NewMatrix(l, 0, 0, DT_COMPLEX);
   NewMatrix(q2, 0, 0, DT_COMPLEX);
// Test decompose-and-unpack error
   testortfacunit_cmatrixmakeacopy(a, m, n, &b);
   cmatrixlq(&b, m, n, &taub);
   cmatrixlqunpackq(&b, m, n, &taub, n, &q);
   cmatrixlqunpackl(&b, m, n, &l);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(l.xyC[i], 1, "N", &q.xyC[0][j], q.stride, "N", n);
         *lqerrors = *lqerrors || abscomplex(ae_c_sub(v, a->xyC[i][j])) >= threshold;
      }
   }
   for (i = 0; i < m; i++) {
      for (j = imin2(i, n - 1) + 1; j < n; j++) {
         *lqerrors = *lqerrors || ae_c_neq_d(l.xyC[i][j], 0.0);
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(q.xyC[i], 1, "N", q.xyC[j], 1, "Conj", n);
         if (i == j) {
            v = ae_c_sub_d(v, 1);
         }
         *lqerrors = *lqerrors || abscomplex(v) >= threshold;
      }
   }
// Test for other errors
   k = 1 + randominteger(n);
   cmatrixlqunpackq(&b, m, n, &taub, k, &q2);
   for (i = 0; i < k; i++) {
      for (j = 0; j < n; j++) {
         *lqerrors = *lqerrors || abscomplex(ae_c_sub(q2.xyC[i][j], q.xyC[i][j])) > 10 * machineepsilon;
      }
   }
   ae_frame_leave();
}

// Problem testing
static void testortfacunit_testrbdproblem(RMatrix *a, ae_int_t m, ae_int_t n, double threshold, bool *bderrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   bool up;
   double v;
   ae_int_t mtsize;
   ae_frame_make(&_frame_block);
   NewMatrix(t, 0, 0, DT_REAL);
   NewMatrix(pt, 0, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(r, 0, 0, DT_REAL);
   NewMatrix(bd, 0, 0, DT_REAL);
   NewMatrix(x, 0, 0, DT_REAL);
   NewMatrix(r1, 0, 0, DT_REAL);
   NewMatrix(r2, 0, 0, DT_REAL);
   NewVector(taup, 0, DT_REAL);
   NewVector(tauq, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(e, 0, DT_REAL);
// Bidiagonal decomposition error
   testortfacunit_rmatrixmakeacopy(a, m, n, &t);
   rmatrixbd(&t, m, n, &tauq, &taup);
   rmatrixbdunpackq(&t, m, n, &tauq, m, &q);
   rmatrixbdunpackpt(&t, m, n, &taup, n, &pt);
   rmatrixbdunpackdiagonals(&t, m, n, &up, &d, &e);
   ae_matrix_set_length(&bd, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         bd.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < imin2(m, n); i++) {
      bd.xyR[i][i] = d.xR[i];
   }
   if (up) {
      for (i = 0; i < imin2(m, n) - 1; i++) {
         bd.xyR[i][i + 1] = e.xR[i];
      }
   } else {
      for (i = 0; i < imin2(m, n) - 1; i++) {
         bd.xyR[i + 1][i] = e.xR[i];
      }
   }
   ae_matrix_set_length(&r, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(q.xyR[i], 1, &bd.xyR[0][j], bd.stride, m);
         r.xyR[i][j] = v;
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(r.xyR[i], 1, &pt.xyR[0][j], pt.stride, n);
         *bderrors = *bderrors || fabs(v - a->xyR[i][j]) > threshold;
      }
   }
// Orthogonality test for Q/PT
   for (i = 0; i < m; i++) {
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&q.xyR[0][i], q.stride, &q.xyR[0][j], q.stride, m);
         if (i == j) {
            *bderrors = *bderrors || fabs(v - 1) > threshold;
         } else {
            *bderrors = *bderrors || fabs(v) > threshold;
         }
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(pt.xyR[i], 1, pt.xyR[j], 1, n);
         if (i == j) {
            *bderrors = *bderrors || fabs(v - 1) > threshold;
         } else {
            *bderrors = *bderrors || fabs(v) > threshold;
         }
      }
   }
// Partial unpacking test
   k = 1 + randominteger(m);
   rmatrixbdunpackq(&t, m, n, &tauq, k, &r);
   for (i = 0; i < m; i++) {
      for (j = 0; j < k; j++) {
         *bderrors = *bderrors || fabs(r.xyR[i][j] - q.xyR[i][j]) > 10 * machineepsilon;
      }
   }
   k = 1 + randominteger(n);
   rmatrixbdunpackpt(&t, m, n, &taup, k, &r);
   for (i = 0; i < k; i++) {
      for (j = 0; j < n; j++) {
         *bderrors = *bderrors || fabs(r.xyR[i][j] - pt.xyR[i][j]) > 10 * machineepsilon;
      }
   }
// Multiplication test
   ae_matrix_set_length(&x, imax2(m, n) - 1 + 1, imax2(m, n) - 1 + 1);
   ae_matrix_set_length(&r, imax2(m, n) - 1 + 1, imax2(m, n) - 1 + 1);
   ae_matrix_set_length(&r1, imax2(m, n) - 1 + 1, imax2(m, n) - 1 + 1);
   ae_matrix_set_length(&r2, imax2(m, n) - 1 + 1, imax2(m, n) - 1 + 1);
   for (i = 0; i < imax2(m, n); i++) {
      for (j = 0; j < imax2(m, n); j++) {
         x.xyR[i][j] = randommid();
      }
   }
   mtsize = 1 + randominteger(imax2(m, n));
   testortfacunit_rmatrixmakeacopy(&x, mtsize, m, &r);
   testortfacunit_internalmatrixmatrixmultiply(&r, 0, mtsize - 1, 0, m - 1, false, &q, 0, m - 1, 0, m - 1, false, &r1, 0, mtsize - 1, 0, m - 1);
   testortfacunit_rmatrixmakeacopy(&x, mtsize, m, &r2);
   rmatrixbdmultiplybyq(&t, m, n, &tauq, &r2, mtsize, m, true, false);
   *bderrors = *bderrors || testortfacunit_rmatrixdiff(&r1, &r2, mtsize, m) > threshold;
   testortfacunit_rmatrixmakeacopy(&x, mtsize, m, &r);
   testortfacunit_internalmatrixmatrixmultiply(&r, 0, mtsize - 1, 0, m - 1, false, &q, 0, m - 1, 0, m - 1, true, &r1, 0, mtsize - 1, 0, m - 1);
   testortfacunit_rmatrixmakeacopy(&x, mtsize, m, &r2);
   rmatrixbdmultiplybyq(&t, m, n, &tauq, &r2, mtsize, m, true, true);
   *bderrors = *bderrors || testortfacunit_rmatrixdiff(&r1, &r2, mtsize, m) > threshold;
   testortfacunit_rmatrixmakeacopy(&x, m, mtsize, &r);
   testortfacunit_internalmatrixmatrixmultiply(&q, 0, m - 1, 0, m - 1, false, &r, 0, m - 1, 0, mtsize - 1, false, &r1, 0, m - 1, 0, mtsize - 1);
   testortfacunit_rmatrixmakeacopy(&x, m, mtsize, &r2);
   rmatrixbdmultiplybyq(&t, m, n, &tauq, &r2, m, mtsize, false, false);
   *bderrors = *bderrors || testortfacunit_rmatrixdiff(&r1, &r2, m, mtsize) > threshold;
   testortfacunit_rmatrixmakeacopy(&x, m, mtsize, &r);
   testortfacunit_internalmatrixmatrixmultiply(&q, 0, m - 1, 0, m - 1, true, &r, 0, m - 1, 0, mtsize - 1, false, &r1, 0, m - 1, 0, mtsize - 1);
   testortfacunit_rmatrixmakeacopy(&x, m, mtsize, &r2);
   rmatrixbdmultiplybyq(&t, m, n, &tauq, &r2, m, mtsize, false, true);
   *bderrors = *bderrors || testortfacunit_rmatrixdiff(&r1, &r2, m, mtsize) > threshold;
   testortfacunit_rmatrixmakeacopy(&x, mtsize, n, &r);
   testortfacunit_internalmatrixmatrixmultiply(&r, 0, mtsize - 1, 0, n - 1, false, &pt, 0, n - 1, 0, n - 1, true, &r1, 0, mtsize - 1, 0, n - 1);
   testortfacunit_rmatrixmakeacopy(&x, mtsize, n, &r2);
   rmatrixbdmultiplybyp(&t, m, n, &taup, &r2, mtsize, n, true, false);
   *bderrors = *bderrors || testortfacunit_rmatrixdiff(&r1, &r2, mtsize, n) > threshold;
   testortfacunit_rmatrixmakeacopy(&x, mtsize, n, &r);
   testortfacunit_internalmatrixmatrixmultiply(&r, 0, mtsize - 1, 0, n - 1, false, &pt, 0, n - 1, 0, n - 1, false, &r1, 0, mtsize - 1, 0, n - 1);
   testortfacunit_rmatrixmakeacopy(&x, mtsize, n, &r2);
   rmatrixbdmultiplybyp(&t, m, n, &taup, &r2, mtsize, n, true, true);
   *bderrors = *bderrors || testortfacunit_rmatrixdiff(&r1, &r2, mtsize, n) > threshold;
   testortfacunit_rmatrixmakeacopy(&x, n, mtsize, &r);
   testortfacunit_internalmatrixmatrixmultiply(&pt, 0, n - 1, 0, n - 1, true, &r, 0, n - 1, 0, mtsize - 1, false, &r1, 0, n - 1, 0, mtsize - 1);
   testortfacunit_rmatrixmakeacopy(&x, n, mtsize, &r2);
   rmatrixbdmultiplybyp(&t, m, n, &taup, &r2, n, mtsize, false, false);
   *bderrors = *bderrors || testortfacunit_rmatrixdiff(&r1, &r2, n, mtsize) > threshold;
   testortfacunit_rmatrixmakeacopy(&x, n, mtsize, &r);
   testortfacunit_internalmatrixmatrixmultiply(&pt, 0, n - 1, 0, n - 1, false, &r, 0, n - 1, 0, mtsize - 1, false, &r1, 0, n - 1, 0, mtsize - 1);
   testortfacunit_rmatrixmakeacopy(&x, n, mtsize, &r2);
   rmatrixbdmultiplybyp(&t, m, n, &taup, &r2, n, mtsize, false, true);
   *bderrors = *bderrors || testortfacunit_rmatrixdiff(&r1, &r2, n, mtsize) > threshold;
   ae_frame_leave();
}

// Problem testing
static void testortfacunit_testrhessproblem(RMatrix *a, ae_int_t n, double threshold, bool *hesserrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_frame_make(&_frame_block);
   NewMatrix(b, 0, 0, DT_REAL);
   NewMatrix(h, 0, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(t1, 0, 0, DT_REAL);
   NewMatrix(t2, 0, 0, DT_REAL);
   NewVector(tau, 0, DT_REAL);
   testortfacunit_rmatrixmakeacopy(a, n, n, &b);
// Decomposition
   rmatrixhessenberg(&b, n, &tau);
   rmatrixhessenbergunpackq(&b, n, &tau, &q);
   rmatrixhessenbergunpackh(&b, n, &h);
// Matrix properties
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(&q.xyR[0][i], q.stride, &q.xyR[0][j], q.stride, n);
         if (i == j) {
            v--;
         }
         *hesserrors = *hesserrors || fabs(v) > threshold;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < i - 1; j++) {
         *hesserrors = *hesserrors || h.xyR[i][j] != 0.0;
      }
   }
// Decomposition error
   ae_matrix_set_length(&t1, n, n);
   ae_matrix_set_length(&t2, n, n);
   testortfacunit_internalmatrixmatrixmultiply(&q, 0, n - 1, 0, n - 1, false, &h, 0, n - 1, 0, n - 1, false, &t1, 0, n - 1, 0, n - 1);
   testortfacunit_internalmatrixmatrixmultiply(&t1, 0, n - 1, 0, n - 1, false, &q, 0, n - 1, 0, n - 1, true, &t2, 0, n - 1, 0, n - 1);
   *hesserrors = *hesserrors || testortfacunit_rmatrixdiff(&t2, a, n, n) > threshold;
   ae_frame_leave();
}

// Tridiagonal tester
static void testortfacunit_testrtdproblem(RMatrix *a, ae_int_t n, double threshold, bool *tderrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_frame_make(&_frame_block);
   NewMatrix(ua, 0, 0, DT_REAL);
   NewMatrix(la, 0, 0, DT_REAL);
   NewMatrix(t, 0, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(t2, 0, 0, DT_REAL);
   NewMatrix(t3, 0, 0, DT_REAL);
   NewVector(tau, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(e, 0, DT_REAL);
   ae_matrix_set_length(&ua, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&la, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&t, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&q, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&t2, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&t3, n - 1 + 1, n - 1 + 1);
// fill
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         ua.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = i; j < n; j++) {
         ua.xyR[i][j] = a->xyR[i][j];
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         la.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j <= i; j++) {
         la.xyR[i][j] = a->xyR[i][j];
      }
   }
// Test 2tridiagonal: upper
   smatrixtd(&ua, n, true, &tau, &d, &e);
   smatrixtdunpackq(&ua, n, true, &tau, &q);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         t.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < n; i++) {
      t.xyR[i][i] = d.xR[i];
   }
   for (i = 0; i < n - 1; i++) {
      t.xyR[i][i + 1] = e.xR[i];
      t.xyR[i + 1][i] = e.xR[i];
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(&q.xyR[0][i], q.stride, &a->xyR[0][j], a->stride, n);
         t2.xyR[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(t2.xyR[i], 1, &q.xyR[0][j], q.stride, n);
         t3.xyR[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         *tderrors = *tderrors || fabs(t3.xyR[i][j] - t.xyR[i][j]) > threshold;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(q.xyR[i], 1, q.xyR[j], 1, n);
         if (i == j) {
            v--;
         }
         *tderrors = *tderrors || fabs(v) > threshold;
      }
   }
// Test 2tridiagonal: lower
   smatrixtd(&la, n, false, &tau, &d, &e);
   smatrixtdunpackq(&la, n, false, &tau, &q);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         t.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < n; i++) {
      t.xyR[i][i] = d.xR[i];
   }
   for (i = 0; i < n - 1; i++) {
      t.xyR[i][i + 1] = e.xR[i];
      t.xyR[i + 1][i] = e.xR[i];
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(&q.xyR[0][i], q.stride, &a->xyR[0][j], a->stride, n);
         t2.xyR[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(t2.xyR[i], 1, &q.xyR[0][j], q.stride, n);
         t3.xyR[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         *tderrors = *tderrors || fabs(t3.xyR[i][j] - t.xyR[i][j]) > threshold;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(q.xyR[i], 1, q.xyR[j], 1, n);
         if (i == j) {
            v--;
         }
         *tderrors = *tderrors || fabs(v) > threshold;
      }
   }
   ae_frame_leave();
}

// Hermitian problem tester
static void testortfacunit_testctdproblem(CMatrix *a, ae_int_t n, double threshold, bool *tderrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   complex v;
   ae_frame_make(&_frame_block);
   NewMatrix(ua, 0, 0, DT_COMPLEX);
   NewMatrix(la, 0, 0, DT_COMPLEX);
   NewMatrix(t, 0, 0, DT_COMPLEX);
   NewMatrix(q, 0, 0, DT_COMPLEX);
   NewMatrix(t2, 0, 0, DT_COMPLEX);
   NewMatrix(t3, 0, 0, DT_COMPLEX);
   NewVector(tau, 0, DT_COMPLEX);
   NewVector(d, 0, DT_REAL);
   NewVector(e, 0, DT_REAL);
   ae_matrix_set_length(&ua, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&la, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&t, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&q, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&t2, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&t3, n - 1 + 1, n - 1 + 1);
// fill
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         ua.xyC[i][j] = complex_from_i(0);
      }
   }
   for (i = 0; i < n; i++) {
      for (j = i; j < n; j++) {
         ua.xyC[i][j] = a->xyC[i][j];
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         la.xyC[i][j] = complex_from_i(0);
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j <= i; j++) {
         la.xyC[i][j] = a->xyC[i][j];
      }
   }
// Test 2tridiagonal: upper
   hmatrixtd(&ua, n, true, &tau, &d, &e);
   hmatrixtdunpackq(&ua, n, true, &tau, &q);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         t.xyC[i][j] = complex_from_i(0);
      }
   }
   for (i = 0; i < n; i++) {
      t.xyC[i][i] = complex_from_d(d.xR[i]);
   }
   for (i = 0; i < n - 1; i++) {
      t.xyC[i][i + 1] = complex_from_d(e.xR[i]);
      t.xyC[i + 1][i] = complex_from_d(e.xR[i]);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(&q.xyC[0][i], q.stride, "Conj", &a->xyC[0][j], a->stride, "N", n);
         t2.xyC[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(t2.xyC[i], 1, "N", &q.xyC[0][j], q.stride, "N", n);
         t3.xyC[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         *tderrors = *tderrors || abscomplex(ae_c_sub(t3.xyC[i][j], t.xyC[i][j])) > threshold;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(q.xyC[i], 1, "N", q.xyC[j], 1, "Conj", n);
         if (i == j) {
            v = ae_c_sub_d(v, 1);
         }
         *tderrors = *tderrors || abscomplex(v) > threshold;
      }
   }
// Test 2tridiagonal: lower
   hmatrixtd(&la, n, false, &tau, &d, &e);
   hmatrixtdunpackq(&la, n, false, &tau, &q);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         t.xyC[i][j] = complex_from_i(0);
      }
   }
   for (i = 0; i < n; i++) {
      t.xyC[i][i] = complex_from_d(d.xR[i]);
   }
   for (i = 0; i < n - 1; i++) {
      t.xyC[i][i + 1] = complex_from_d(e.xR[i]);
      t.xyC[i + 1][i] = complex_from_d(e.xR[i]);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(&q.xyC[0][i], q.stride, "Conj", &a->xyC[0][j], a->stride, "N", n);
         t2.xyC[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(t2.xyC[i], 1, "N", &q.xyC[0][j], q.stride, "N", n);
         t3.xyC[i][j] = v;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         *tderrors = *tderrors || abscomplex(ae_c_sub(t3.xyC[i][j], t.xyC[i][j])) > threshold;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(q.xyC[i], 1, "N", q.xyC[j], 1, "Conj", n);
         if (i == j) {
            v = ae_c_sub_d(v, 1);
         }
         *tderrors = *tderrors || abscomplex(v) > threshold;
      }
   }
   ae_frame_leave();
}

// Main unittest subroutine
bool testortfac(bool silent) {
   ae_frame _frame_block;
   double threshold;
   ae_int_t mx;
   ae_int_t m;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   bool rqrerrors;
   bool rlqerrors;
   bool cqrerrors;
   bool clqerrors;
   bool rbderrors;
   bool rhesserrors;
   bool rtderrors;
   bool ctderrors;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(ra, 0, 0, DT_REAL);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   waserrors = false;
   rqrerrors = false;
   rlqerrors = false;
   cqrerrors = false;
   clqerrors = false;
   rbderrors = false;
   rhesserrors = false;
   rtderrors = false;
   ctderrors = false;
   threshold = 5 * 1000 * machineepsilon;
// Medium-scale problems with various sparseness profiles
   for (mx = 1; mx <= 3 * matrixtilesizea() + 1; mx++) {
   // Rectangular factorizations: QR, LQ, bidiagonal
   // Matrix types: zero, dense, sparse
      n = 1 + randominteger(mx);
      m = 1 + randominteger(mx);
      if (randombool()) {
         n = mx;
      } else {
         m = mx;
      }
      ae_matrix_set_length(&ra, m, n);
      ae_matrix_set_length(&ca, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            ra.xyR[i][j] = 0.0;
            ca.xyC[i][j] = complex_from_i(0);
         }
      }
      testortfacunit_testrqrproblem(&ra, m, n, threshold, &rqrerrors);
      testortfacunit_testrlqproblem(&ra, m, n, threshold, &rlqerrors);
      testortfacunit_testcqrproblem(&ca, m, n, threshold, &cqrerrors);
      testortfacunit_testclqproblem(&ca, m, n, threshold, &clqerrors);
      testortfacunit_testrbdproblem(&ra, m, n, threshold, &rbderrors);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            ra.xyR[i][j] = randommid();
            ca.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
      testortfacunit_testrqrproblem(&ra, m, n, threshold, &rqrerrors);
      testortfacunit_testrlqproblem(&ra, m, n, threshold, &rlqerrors);
      testortfacunit_testcqrproblem(&ca, m, n, threshold, &cqrerrors);
      testortfacunit_testclqproblem(&ca, m, n, threshold, &clqerrors);
      testortfacunit_testrbdproblem(&ra, m, n, threshold, &rbderrors);
      testortfacunit_rmatrixfillsparsea(&ra, m, n, 0.95);
      testortfacunit_cmatrixfillsparsea(&ca, m, n, 0.95);
      testortfacunit_testrqrproblem(&ra, m, n, threshold, &rqrerrors);
      testortfacunit_testrlqproblem(&ra, m, n, threshold, &rlqerrors);
      testortfacunit_testcqrproblem(&ca, m, n, threshold, &cqrerrors);
      testortfacunit_testclqproblem(&ca, m, n, threshold, &clqerrors);
      testortfacunit_testrbdproblem(&ra, m, n, threshold, &rbderrors);
   // Square factorizations: Hessenberg, tridiagonal
   // Matrix types: zero, dense, sparse
      ae_matrix_set_length(&ra, mx, mx);
      ae_matrix_set_length(&ca, mx, mx);
      for (i = 0; i < mx; i++) {
         for (j = 0; j < mx; j++) {
            ra.xyR[i][j] = 0.0;
            ca.xyC[i][j] = complex_from_i(0);
         }
      }
      testortfacunit_testrhessproblem(&ra, mx, threshold, &rhesserrors);
      for (i = 0; i < mx; i++) {
         for (j = 0; j < mx; j++) {
            ra.xyR[i][j] = randommid();
            ca.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
      testortfacunit_testrhessproblem(&ra, mx, threshold, &rhesserrors);
      testortfacunit_rmatrixfillsparsea(&ra, mx, mx, 0.95);
      testortfacunit_cmatrixfillsparsea(&ca, mx, mx, 0.95);
      testortfacunit_testrhessproblem(&ra, mx, threshold, &rhesserrors);
   // Symetric factorizations: tridiagonal
   // Matrix types: zero, dense, sparse
      ae_matrix_set_length(&ra, mx, mx);
      ae_matrix_set_length(&ca, mx, mx);
      for (i = 0; i < mx; i++) {
         for (j = 0; j < mx; j++) {
            ra.xyR[i][j] = 0.0;
            ca.xyC[i][j] = complex_from_i(0);
         }
      }
      testortfacunit_testrtdproblem(&ra, mx, threshold, &rtderrors);
      testortfacunit_testctdproblem(&ca, mx, threshold, &ctderrors);
      for (i = 0; i < mx; i++) {
         for (j = i; j < mx; j++) {
            ra.xyR[i][j] = randommid();
            ca.xyC[i][j] = complex_from_d(randommid(), randommid());
            ra.xyR[j][i] = ra.xyR[i][j];
            ca.xyC[j][i] = conj(ca.xyC[i][j]);
         }
      }
      for (i = 0; i < mx; i++) {
         ca.xyC[i][i] = complex_from_d(randommid());
      }
      testortfacunit_testrtdproblem(&ra, mx, threshold, &rtderrors);
      testortfacunit_testctdproblem(&ca, mx, threshold, &ctderrors);
      testortfacunit_rmatrixfillsparsea(&ra, mx, mx, 0.95);
      testortfacunit_cmatrixfillsparsea(&ca, mx, mx, 0.95);
      for (i = 0; i < mx; i++) {
         for (j = i; j < mx; j++) {
            ra.xyR[j][i] = ra.xyR[i][j];
            ca.xyC[j][i] = conj(ca.xyC[i][j]);
         }
      }
      for (i = 0; i < mx; i++) {
         ca.xyC[i][i] = complex_from_d(randommid());
      }
      testortfacunit_testrtdproblem(&ra, mx, threshold, &rtderrors);
      testortfacunit_testctdproblem(&ca, mx, threshold, &ctderrors);
   }
// Large-scale tests
   for (mx = 4 * matrixtilesizeb(); mx <= 4 * matrixtilesizeb(); mx++) {
   // Rectangular factorizations: QR, LQ, bidiagonal
   // Matrix types: dense
      n = 1 + randominteger(mx);
      m = 1 + randominteger(mx);
      if (randombool()) {
         n = mx;
      } else {
         m = mx;
      }
      ae_matrix_set_length(&ra, m, n);
      ae_matrix_set_length(&ca, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            ra.xyR[i][j] = randommid();
            ca.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
      testortfacunit_testrqrproblem(&ra, m, n, threshold, &rqrerrors);
      testortfacunit_testrlqproblem(&ra, m, n, threshold, &rlqerrors);
      testortfacunit_testcqrproblem(&ca, m, n, threshold, &cqrerrors);
      testortfacunit_testclqproblem(&ca, m, n, threshold, &clqerrors);
      testortfacunit_testrbdproblem(&ra, m, n, threshold, &rbderrors);
   // Square factorizations: Hessenberg, tridiagonal
   // Matrix types: dense
      ae_matrix_set_length(&ra, mx, mx);
      ae_matrix_set_length(&ca, mx, mx);
      for (i = 0; i < mx; i++) {
         for (j = 0; j < mx; j++) {
            ra.xyR[i][j] = randommid();
            ca.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
      testortfacunit_testrhessproblem(&ra, mx, threshold, &rhesserrors);
   // Symetric factorizations: tridiagonal
   // Matrix types: dense
      ae_matrix_set_length(&ra, mx, mx);
      ae_matrix_set_length(&ca, mx, mx);
      for (i = 0; i < mx; i++) {
         for (j = i; j < mx; j++) {
            ra.xyR[i][j] = randommid();
            ca.xyC[i][j] = complex_from_d(randommid(), randommid());
            ra.xyR[j][i] = ra.xyR[i][j];
            ca.xyC[j][i] = conj(ca.xyC[i][j]);
         }
      }
      for (i = 0; i < mx; i++) {
         ca.xyC[i][i] = complex_from_d(randommid());
      }
      testortfacunit_testrtdproblem(&ra, mx, threshold, &rtderrors);
      testortfacunit_testctdproblem(&ca, mx, threshold, &ctderrors);
   }
// report
   waserrors = ((((((rqrerrors || rlqerrors) || cqrerrors) || clqerrors) || rbderrors) || rhesserrors) || rtderrors) || ctderrors;
   if (!silent) {
      printf("TESTING ORTFAC UNIT\n");
      printf("RQR ERRORS:                              ");
      if (!rqrerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("RLQ ERRORS:                              ");
      if (!rlqerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("CQR ERRORS:                              ");
      if (!cqrerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("CLQ ERRORS:                              ");
      if (!clqerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("RBD ERRORS:                              ");
      if (!rbderrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("RHESS ERRORS:                            ");
      if (!rhesserrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("RTD ERRORS:                              ");
      if (!rtderrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("CTD ERRORS:                              ");
      if (!ctderrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === matgen testing unit ===
static const ae_int_t testmatgenunit_maxsvditerations = 60;

// Unsets 2D array.
static void testmatgenunit_unset2d(RMatrix *a) {
   ae_matrix_set_length(a, 0 + 1, 0 + 1);
   a->xyR[0][0] = randommid();
}

// Unsets 2D array.
static void testmatgenunit_unset2dc(CMatrix *a) {
   ae_matrix_set_length(a, 0 + 1, 0 + 1);
   a->xyC[0][0] = complex_from_d(randommid());
}

// Test whether matrix is SPD
static bool testmatgenunit_isspd(RMatrix *a, ae_int_t n, bool isupper) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double ajj;
   double v;
   bool result;
   ae_frame_make(&_frame_block);
   DupMatrix(a);
//     Test the input parameters.
   ae_assert(n >= 0, "Error in SMatrixCholesky: incorrect function arguments");
//     Quick return if possible
   result = true;
   if (n <= 0) {
      ae_frame_leave();
      return result;
   }
   if (isupper) {
   // Compute the Cholesky factorization A = U'*U.
      for (j = 0; j < n; j++) {
      // Compute U(J,J) and test for non-positive-definiteness.
         v = ae_v_dotproduct(&a->xyR[0][j], a->stride, &a->xyR[0][j], a->stride, j);
         ajj = a->xyR[j][j] - v;
         if (ajj <= 0.0) {
            result = false;
            ae_frame_leave();
            return result;
         }
         ajj = sqrt(ajj);
         a->xyR[j][j] = ajj;
      // Compute elements J+1:N of row J.
         if (j < n - 1) {
            for (i = j + 1; i < n; i++) {
               v = ae_v_dotproduct(&a->xyR[0][i], a->stride, &a->xyR[0][j], a->stride, j);
               a->xyR[j][i] -= v;
            }
            v = 1 / ajj;
            ae_v_muld(&a->xyR[j][j + 1], 1, n - j - 1, v);
         }
      }
   } else {
   // Compute the Cholesky factorization A = L*L'.
      for (j = 0; j < n; j++) {
      // Compute L(J,J) and test for non-positive-definiteness.
         v = ae_v_dotproduct(a->xyR[j], 1, a->xyR[j], 1, j);
         ajj = a->xyR[j][j] - v;
         if (ajj <= 0.0) {
            result = false;
            ae_frame_leave();
            return result;
         }
         ajj = sqrt(ajj);
         a->xyR[j][j] = ajj;
      // Compute elements J+1:N of column J.
         if (j < n - 1) {
            for (i = j + 1; i < n; i++) {
               v = ae_v_dotproduct(a->xyR[i], 1, a->xyR[j], 1, j);
               a->xyR[i][j] -= v;
            }
            v = 1 / ajj;
            ae_v_muld(&a->xyR[j + 1][j], a->stride, n - j - 1, v);
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Tests whether A is HPD
static bool testmatgenunit_ishpd(CMatrix *a, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t j;
   double ajj;
   complex v;
   double r;
   ae_int_t i;
   bool result;
   ae_frame_make(&_frame_block);
   DupMatrix(a);
   NewVector(t, 0, DT_COMPLEX);
   NewVector(t2, 0, DT_COMPLEX);
   NewVector(t3, 0, DT_COMPLEX);
   NewMatrix(a1, 0, 0, DT_COMPLEX);
   ae_vector_set_length(&t, n - 1 + 1);
   ae_vector_set_length(&t2, n - 1 + 1);
   ae_vector_set_length(&t3, n - 1 + 1);
   result = true;
// Compute the Cholesky factorization A = U'*U.
   for (j = 0; j < n; j++) {
   // Compute U(J,J) and test for non-positive-definiteness.
      v = ae_v_cdotproduct(&a->xyC[0][j], a->stride, "Conj", &a->xyC[0][j], a->stride, "N", j);
      ajj = ae_c_sub(a->xyC[j][j], v).x;
      if (ajj <= 0.0) {
         a->xyC[j][j] = complex_from_d(ajj);
         result = false;
         ae_frame_leave();
         return result;
      }
      ajj = sqrt(ajj);
      a->xyC[j][j] = complex_from_d(ajj);
   // Compute elements J+1:N-1 of row J.
      if (j < n - 1) {
         ae_v_cmove(t2.xC, 1, &a->xyC[0][j], a->stride, "Conj", j);
         ae_v_cmove(&t3.xC[j + 1], 1, &a->xyC[j][j + 1], 1, "N", n - j - 1);
         for (i = j + 1; i < n; i++) {
            v = ae_v_cdotproduct(&a->xyC[0][i], a->stride, "N", t2.xC, 1, "N", j);
            t3.xC[i] = ae_c_sub(t3.xC[i], v);
         }
         ae_v_cmove(&a->xyC[j][j + 1], 1, &t3.xC[j + 1], 1, "N", n - j - 1);
         r = 1 / ajj;
         ae_v_cmuld(&a->xyC[j][j + 1], 1, n - j - 1, r);
      }
   }
   ae_frame_leave();
   return result;
}

// The function check, that upper triangle from symmetric matrix is equal to
// lower triangle.
static bool testmatgenunit_testeult() {
   ae_frame _frame_block;
   double c;
   double range;
   double eps;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_COMPLEX);
   eps = 2 * machineepsilon;
   range = 100 * randommid();
   for (n = 1; n <= 15; n++) {
      c = 900 * randomreal() + 100;
   // Generate symmetric matrix and check it
      smatrixrndcond(n, c, &a);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (fabs(a.xyR[i][j] - a.xyR[j][i]) > eps) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
      spdmatrixrndcond(n, c, &a);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (fabs(a.xyR[i][j] - a.xyR[j][i]) > eps) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
      hmatrixrndcond(n, c, &b);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (fabs(b.xyC[i][j].x - b.xyC[j][i].x) > eps || fabs(b.xyC[i][j].y + b.xyC[j][i].y) > eps) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
      hpdmatrixrndcond(n, c, &b);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (fabs(b.xyC[i][j].x - b.xyC[j][i].x) > eps || fabs(b.xyC[i][j].y + b.xyC[j][i].y) > eps) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   // Prepare symmetric matrix with real values
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            a.xyR[i][j] = range * randommid();
         }
      }
      for (i = 0; i < n - 1; i++) {
         for (j = i + 1; j < n; j++) {
            a.xyR[j][i] = a.xyR[i][j];
         }
      }
      smatrixrndmultiply(&a, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (fabs(a.xyR[i][j] - a.xyR[j][i]) > eps) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   // Prepare symmetric matrix with complex values
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            b.xyC[i][j] = complex_from_d(range * randommid(), i == j ? 0.0 : range * randommid());
         }
      }
      for (i = 0; i < n; i++) {
         for (j = i + 1; j < n; j++) {
            b.xyC[i][j] = complex_from_d(b.xyC[j][i].x, -b.xyC[j][i].y);
         }
      }
      hmatrixrndmultiply(&b, n);
      for (i = 0; i < n; i++) {
         b.xyC[i][i].y = 0.0;
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (fabs(b.xyC[i][j].x - b.xyC[j][i].x) > eps || fabs(b.xyC[i][j].y + b.xyC[j][i].y) > eps) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

static double testmatgenunit_extsign(double a, double b) {
   double result;
   if (b >= 0.0) {
      result = fabs(a);
   } else {
      result = -fabs(a);
   }
   return result;
}

static double testmatgenunit_mymax(double a, double b) {
   double result;
   if (a > b) {
      result = a;
   } else {
      result = b;
   }
   return result;
}

static double testmatgenunit_pythag(double a, double b) {
   double result;
   if (fabs(a) < fabs(b)) {
      result = fabs(b) * sqrt(1 + sqr(a / b));
   } else {
      result = fabs(a) * sqrt(1 + sqr(b / a));
   }
   return result;
}

static bool testmatgenunit_obsoletesvddecomposition(RMatrix *a, ae_int_t m, ae_int_t n, RVector *w, RMatrix *v) {
   ae_frame _frame_block;
   ae_int_t nm;
   ae_int_t minmn;
   ae_int_t l;
   ae_int_t k;
   ae_int_t j;
   ae_int_t jj;
   ae_int_t its;
   ae_int_t i;
   double z;
   double y;
   double x;
   double vscale;
   double s;
   double h;
   double g;
   double f;
   double c;
   double anorm;
   bool flag;
   bool result;
   ae_frame_make(&_frame_block);
   SetVector(w);
   SetMatrix(v);
   NewVector(rv1, 0, DT_REAL);
   ae_vector_set_length(&rv1, n + 1);
   ae_vector_set_length(w, n + 1);
   ae_matrix_set_length(v, n + 1, n + 1);
   result = true;
   if (m < n) {
      minmn = m;
   } else {
      minmn = n;
   }
   g = 0.0;
   vscale = 0.0;
   anorm = 0.0;
   l = n;
   for (i = 1; i <= n; i++) {
      l = i + 1;
      rv1.xR[i] = vscale * g;
      g = 0.0;
      s = 0.0;
      vscale = 0.0;
      if (i <= m) {
         for (k = i; k <= m; k++) {
            vscale += fabs(a->xyR[k][i]);
         }
         if (vscale != 0.0) {
            for (k = i; k <= m; k++) {
               a->xyR[k][i] /= vscale;
               s += a->xyR[k][i] * a->xyR[k][i];
            }
            f = a->xyR[i][i];
            g = -testmatgenunit_extsign(sqrt(s), f);
            h = f * g - s;
            a->xyR[i][i] = f - g;
            if (i != n) {
               for (j = l; j <= n; j++) {
                  s = 0.0;
                  for (k = i; k <= m; k++) {
                     s += a->xyR[k][i] * a->xyR[k][j];
                  }
                  f = s / h;
                  for (k = i; k <= m; k++) {
                     a->xyR[k][j] += f * a->xyR[k][i];
                  }
               }
            }
            for (k = i; k <= m; k++) {
               a->xyR[k][i] *= vscale;
            }
         }
      }
      w->xR[i] = vscale * g;
      g = 0.0;
      s = 0.0;
      vscale = 0.0;
      if (i <= m && i != n) {
         for (k = l; k <= n; k++) {
            vscale += fabs(a->xyR[i][k]);
         }
         if (vscale != 0.0) {
            for (k = l; k <= n; k++) {
               a->xyR[i][k] /= vscale;
               s += a->xyR[i][k] * a->xyR[i][k];
            }
            f = a->xyR[i][l];
            g = -testmatgenunit_extsign(sqrt(s), f);
            h = f * g - s;
            a->xyR[i][l] = f - g;
            for (k = l; k <= n; k++) {
               rv1.xR[k] = a->xyR[i][k] / h;
            }
            if (i != m) {
               for (j = l; j <= m; j++) {
                  s = 0.0;
                  for (k = l; k <= n; k++) {
                     s += a->xyR[j][k] * a->xyR[i][k];
                  }
                  for (k = l; k <= n; k++) {
                     a->xyR[j][k] += s * rv1.xR[k];
                  }
               }
            }
            for (k = l; k <= n; k++) {
               a->xyR[i][k] *= vscale;
            }
         }
      }
      anorm = testmatgenunit_mymax(anorm, fabs(w->xR[i]) + fabs(rv1.xR[i]));
   }
   for (i = n; i >= 1; i--) {
      if (i < n) {
         if (g != 0.0) {
            for (j = l; j <= n; j++) {
               v->xyR[j][i] = a->xyR[i][j] / a->xyR[i][l] / g;
            }
            for (j = l; j <= n; j++) {
               s = 0.0;
               for (k = l; k <= n; k++) {
                  s += a->xyR[i][k] * v->xyR[k][j];
               }
               for (k = l; k <= n; k++) {
                  v->xyR[k][j] += s * v->xyR[k][i];
               }
            }
         }
         for (j = l; j <= n; j++) {
            v->xyR[i][j] = 0.0;
            v->xyR[j][i] = 0.0;
         }
      }
      v->xyR[i][i] = 1.0;
      g = rv1.xR[i];
      l = i;
   }
   for (i = minmn; i >= 1; i--) {
      l = i + 1;
      g = w->xR[i];
      if (i < n) {
         for (j = l; j <= n; j++) {
            a->xyR[i][j] = 0.0;
         }
      }
      if (g != 0.0) {
         g = 1.0 / g;
         if (i != n) {
            for (j = l; j <= n; j++) {
               s = 0.0;
               for (k = l; k <= m; k++) {
                  s += a->xyR[k][i] * a->xyR[k][j];
               }
               f = s / a->xyR[i][i] * g;
               for (k = i; k <= m; k++) {
                  a->xyR[k][j] += f * a->xyR[k][i];
               }
            }
         }
         for (j = i; j <= m; j++) {
            a->xyR[j][i] *= g;
         }
      } else {
         for (j = i; j <= m; j++) {
            a->xyR[j][i] = 0.0;
         }
      }
      a->xyR[i][i]++;
   }
   nm = 0;
   for (k = n; k >= 1; k--) {
      for (its = 1; its <= testmatgenunit_maxsvditerations; its++) {
         flag = true;
         for (l = k; l >= 1; l--) {
            nm = l - 1;
            if (fabs(rv1.xR[l]) + anorm == anorm) {
               flag = false;
               break;
            }
            if (fabs(w->xR[nm]) + anorm == anorm) {
               break;
            }
         }
         if (flag) {
            c = 0.0;
            s = 1.0;
            for (i = l; i <= k; i++) {
               f = s * rv1.xR[i];
               if (fabs(f) + anorm != anorm) {
                  g = w->xR[i];
                  h = testmatgenunit_pythag(f, g);
                  w->xR[i] = h;
                  h = 1.0 / h;
                  c = g * h;
                  s = -f * h;
                  for (j = 1; j <= m; j++) {
                     y = a->xyR[j][nm];
                     z = a->xyR[j][i];
                     a->xyR[j][nm] = y * c + z * s;
                     a->xyR[j][i] = -y * s + z * c;
                  }
               }
            }
         }
         z = w->xR[k];
         if (l == k) {
            if (z < 0.0) {
               w->xR[k] = -z;
               for (j = 1; j <= n; j++) {
                  v->xyR[j][k] = -v->xyR[j][k];
               }
            }
            break;
         }
         if (its == testmatgenunit_maxsvditerations) {
            result = false;
            ae_frame_leave();
            return result;
         }
         x = w->xR[l];
         nm = k - 1;
         y = w->xR[nm];
         g = rv1.xR[nm];
         h = rv1.xR[k];
         f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);
         g = testmatgenunit_pythag(f, 1.0);
         f = ((x - z) * (x + z) + h * (y / (f + testmatgenunit_extsign(g, f)) - h)) / x;
         c = 1.0;
         s = 1.0;
         for (j = l; j <= nm; j++) {
            i = j + 1;
            g = rv1.xR[i];
            y = w->xR[i];
            h = s * g;
            g *= c;
            z = testmatgenunit_pythag(f, h);
            rv1.xR[j] = z;
            c = f / z;
            s = h / z;
            f = x * c + g * s;
            g = -x * s + g * c;
            h = y * s;
            y *= c;
            for (jj = 1; jj <= n; jj++) {
               x = v->xyR[jj][j];
               z = v->xyR[jj][i];
               v->xyR[jj][j] = x * c + z * s;
               v->xyR[jj][i] = -x * s + z * c;
            }
            z = testmatgenunit_pythag(f, h);
            w->xR[j] = z;
            if (z != 0.0) {
               z = 1.0 / z;
               c = f * z;
               s = h * z;
            }
            f = c * g + s * y;
            x = -s * g + c * y;
            for (jj = 1; jj <= m; jj++) {
               y = a->xyR[jj][j];
               z = a->xyR[jj][i];
               a->xyR[jj][j] = y * c + z * s;
               a->xyR[jj][i] = -y * s + z * c;
            }
         }
         rv1.xR[l] = 0.0;
         rv1.xR[k] = f;
         w->xR[k] = x;
      }
   }
   ae_frame_leave();
   return result;
}

// SVD condition number
static double testmatgenunit_svdcond(RMatrix *a, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double minw;
   double maxw;
   double result;
   ae_frame_make(&_frame_block);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   ae_matrix_set_length(&a1, n + 1, n + 1);
   for (i = 1; i <= n; i++) {
      for (j = 1; j <= n; j++) {
         a1.xyR[i][j] = a->xyR[i - 1][j - 1];
      }
   }
   if (!testmatgenunit_obsoletesvddecomposition(&a1, n, n, &w, &v)) {
      result = 0.0;
      ae_frame_leave();
      return result;
   }
   minw = w.xR[1];
   maxw = w.xR[1];
   for (i = 2; i <= n; i++) {
      if (w.xR[i] < minw) {
         minw = w.xR[i];
      }
      if (w.xR[i] > maxw) {
         maxw = w.xR[i];
      }
   }
   result = maxw / minw;
   ae_frame_leave();
   return result;
}

bool testmatgen(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   ae_int_t passcount;
   bool waserrors;
   double cond;
   double threshold;
   double vt;
   complex ct;
   double minw;
   double maxw;
   bool serr;
   bool herr;
   bool spderr;
   bool hpderr;
   bool rerr;
   bool cerr;
   bool eulerr;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewMatrix(u, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewMatrix(cb, 0, 0, DT_COMPLEX);
   NewMatrix(r1, 0, 0, DT_REAL);
   NewMatrix(r2, 0, 0, DT_REAL);
   NewMatrix(c1, 0, 0, DT_COMPLEX);
   NewMatrix(c2, 0, 0, DT_COMPLEX);
   NewVector(w, 0, DT_REAL);
   rerr = false;
   cerr = false;
   serr = false;
   herr = false;
   spderr = false;
   hpderr = false;
   eulerr = false;
   waserrors = false;
   maxn = 20;
   passcount = 15;
   threshold = 1000 * machineepsilon;
// Testing orthogonal
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
         ae_matrix_set_length(&r1, n - 1 + 1, 2 * n - 1 + 1);
         ae_matrix_set_length(&r2, 2 * n - 1 + 1, n - 1 + 1);
         ae_matrix_set_length(&c1, n - 1 + 1, 2 * n - 1 + 1);
         ae_matrix_set_length(&c2, 2 * n - 1 + 1, n - 1 + 1);
      // Random orthogonal, real
         testmatgenunit_unset2d(&a);
         testmatgenunit_unset2d(&b);
         rmatrixrndorthogonal(n, &a);
         rmatrixrndorthogonal(n, &b);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
            // orthogonality test
               vt = ae_v_dotproduct(a.xyR[i], 1, a.xyR[j], 1, n);
               if (i == j) {
                  rerr = rerr || fabs(vt - 1) > threshold;
               } else {
                  rerr = rerr || fabs(vt) > threshold;
               }
               vt = ae_v_dotproduct(b.xyR[i], 1, b.xyR[j], 1, n);
               if (i == j) {
                  rerr = rerr || fabs(vt - 1) > threshold;
               } else {
                  rerr = rerr || fabs(vt) > threshold;
               }
            // test for difference in A and B
               if (n >= 2) {
                  rerr = rerr || a.xyR[i][j] == b.xyR[i][j];
               }
            }
         }
      // Random orthogonal, complex
         testmatgenunit_unset2dc(&ca);
         testmatgenunit_unset2dc(&cb);
         cmatrixrndorthogonal(n, &ca);
         cmatrixrndorthogonal(n, &cb);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
            // orthogonality test
               ct = ae_v_cdotproduct(ca.xyC[i], 1, "N", ca.xyC[j], 1, "Conj", n);
               if (i == j) {
                  cerr = cerr || abscomplex(ae_c_sub_d(ct, 1)) > threshold;
               } else {
                  cerr = cerr || abscomplex(ct) > threshold;
               }
               ct = ae_v_cdotproduct(cb.xyC[i], 1, "N", cb.xyC[j], 1, "Conj", n);
               if (i == j) {
                  cerr = cerr || abscomplex(ae_c_sub_d(ct, 1)) > threshold;
               } else {
                  cerr = cerr || abscomplex(ct) > threshold;
               }
            // test for difference in A and B
               if (n >= 2) {
                  cerr = cerr || ae_c_eq(ca.xyC[i][j], cb.xyC[i][j]);
               }
            }
         }
      // From the right real tests:
      // 1. E*Q is orthogonal
      // 2. Q1 != Q2 (routine result is changing)
      // 3. (E E)'*Q = (Q' Q')' (correct handling of non-square matrices)
         testmatgenunit_unset2d(&a);
         testmatgenunit_unset2d(&b);
         ae_matrix_set_length(&a, n - 1 + 1, n - 1 + 1);
         ae_matrix_set_length(&b, n - 1 + 1, n - 1 + 1);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
               b.xyR[i][j] = 0.0;
            }
            a.xyR[i][i] = 1.0;
            b.xyR[i][i] = 1.0;
         }
         rmatrixrndorthogonalfromtheright(&a, n, n);
         rmatrixrndorthogonalfromtheright(&b, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
            // orthogonality test
               vt = ae_v_dotproduct(a.xyR[i], 1, a.xyR[j], 1, n);
               if (i == j) {
                  rerr = rerr || fabs(vt - 1) > threshold;
               } else {
                  rerr = rerr || fabs(vt) > threshold;
               }
               vt = ae_v_dotproduct(b.xyR[i], 1, b.xyR[j], 1, n);
               if (i == j) {
                  rerr = rerr || fabs(vt - 1) > threshold;
               } else {
                  rerr = rerr || fabs(vt) > threshold;
               }
            // test for difference in A and B
               if (n >= 2) {
                  rerr = rerr || a.xyR[i][j] == b.xyR[i][j];
               }
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               r2.xyR[i][j] = randommid();
               r2.xyR[i + n][j] = r2.xyR[i][j];
            }
         }
         rmatrixrndorthogonalfromtheright(&r2, 2 * n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rerr = rerr || fabs(r2.xyR[i + n][j] - r2.xyR[i][j]) > threshold;
            }
         }
      // From the left real tests:
      // 1. Q*E is orthogonal
      // 2. Q1 != Q2 (routine result is changing)
      // 3. Q*(E E) = (Q Q) (correct handling of non-square matrices)
         testmatgenunit_unset2d(&a);
         testmatgenunit_unset2d(&b);
         ae_matrix_set_length(&a, n - 1 + 1, n - 1 + 1);
         ae_matrix_set_length(&b, n - 1 + 1, n - 1 + 1);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
               b.xyR[i][j] = 0.0;
            }
            a.xyR[i][i] = 1.0;
            b.xyR[i][i] = 1.0;
         }
         rmatrixrndorthogonalfromtheleft(&a, n, n);
         rmatrixrndorthogonalfromtheleft(&b, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
            // orthogonality test
               vt = ae_v_dotproduct(a.xyR[i], 1, a.xyR[j], 1, n);
               if (i == j) {
                  rerr = rerr || fabs(vt - 1) > threshold;
               } else {
                  rerr = rerr || fabs(vt) > threshold;
               }
               vt = ae_v_dotproduct(b.xyR[i], 1, b.xyR[j], 1, n);
               if (i == j) {
                  rerr = rerr || fabs(vt - 1) > threshold;
               } else {
                  rerr = rerr || fabs(vt) > threshold;
               }
            // test for difference in A and B
               if (n >= 2) {
                  rerr = rerr || a.xyR[i][j] == b.xyR[i][j];
               }
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               r1.xyR[i][j] = randommid();
               r1.xyR[i][j + n] = r1.xyR[i][j];
            }
         }
         rmatrixrndorthogonalfromtheleft(&r1, n, 2 * n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rerr = rerr || fabs(r1.xyR[i][j] - r1.xyR[i][j + n]) > threshold;
            }
         }
      // From the right complex tests:
      // 1. E*Q is orthogonal
      // 2. Q1 != Q2 (routine result is changing)
      // 3. (E E)'*Q = (Q' Q')' (correct handling of non-square matrices)
         testmatgenunit_unset2dc(&ca);
         testmatgenunit_unset2dc(&cb);
         ae_matrix_set_length(&ca, n - 1 + 1, n - 1 + 1);
         ae_matrix_set_length(&cb, n - 1 + 1, n - 1 + 1);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               ca.xyC[i][j] = complex_from_i(0);
               cb.xyC[i][j] = complex_from_i(0);
            }
            ca.xyC[i][i] = complex_from_i(1);
            cb.xyC[i][i] = complex_from_i(1);
         }
         cmatrixrndorthogonalfromtheright(&ca, n, n);
         cmatrixrndorthogonalfromtheright(&cb, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
            // orthogonality test
               ct = ae_v_cdotproduct(ca.xyC[i], 1, "N", ca.xyC[j], 1, "Conj", n);
               if (i == j) {
                  cerr = cerr || abscomplex(ae_c_sub_d(ct, 1)) > threshold;
               } else {
                  cerr = cerr || abscomplex(ct) > threshold;
               }
               ct = ae_v_cdotproduct(cb.xyC[i], 1, "N", cb.xyC[j], 1, "Conj", n);
               if (i == j) {
                  cerr = cerr || abscomplex(ae_c_sub_d(ct, 1)) > threshold;
               } else {
                  cerr = cerr || abscomplex(ct) > threshold;
               }
            // test for difference in A and B
               cerr = cerr || ae_c_eq(ca.xyC[i][j], cb.xyC[i][j]);
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               c2.xyC[i][j] = complex_from_d(randommid());
               c2.xyC[i + n][j] = c2.xyC[i][j];
            }
         }
         cmatrixrndorthogonalfromtheright(&c2, 2 * n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               cerr = cerr || abscomplex(ae_c_sub(c2.xyC[i + n][j], c2.xyC[i][j])) > threshold;
            }
         }
      // From the left complex tests:
      // 1. Q*E is orthogonal
      // 2. Q1 != Q2 (routine result is changing)
      // 3. Q*(E E) = (Q Q) (correct handling of non-square matrices)
         testmatgenunit_unset2dc(&ca);
         testmatgenunit_unset2dc(&cb);
         ae_matrix_set_length(&ca, n - 1 + 1, n - 1 + 1);
         ae_matrix_set_length(&cb, n - 1 + 1, n - 1 + 1);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               ca.xyC[i][j] = complex_from_i(0);
               cb.xyC[i][j] = complex_from_i(0);
            }
            ca.xyC[i][i] = complex_from_i(1);
            cb.xyC[i][i] = complex_from_i(1);
         }
         cmatrixrndorthogonalfromtheleft(&ca, n, n);
         cmatrixrndorthogonalfromtheleft(&cb, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
            // orthogonality test
               ct = ae_v_cdotproduct(ca.xyC[i], 1, "N", ca.xyC[j], 1, "Conj", n);
               if (i == j) {
                  cerr = cerr || abscomplex(ae_c_sub_d(ct, 1)) > threshold;
               } else {
                  cerr = cerr || abscomplex(ct) > threshold;
               }
               ct = ae_v_cdotproduct(cb.xyC[i], 1, "N", cb.xyC[j], 1, "Conj", n);
               if (i == j) {
                  cerr = cerr || abscomplex(ae_c_sub_d(ct, 1)) > threshold;
               } else {
                  cerr = cerr || abscomplex(ct) > threshold;
               }
            // test for difference in A and B
               cerr = cerr || ae_c_eq(ca.xyC[i][j], cb.xyC[i][j]);
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               c1.xyC[i][j] = complex_from_d(randommid());
               c1.xyC[i][j + n] = c1.xyC[i][j];
            }
         }
         cmatrixrndorthogonalfromtheleft(&c1, n, 2 * n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               cerr = cerr || abscomplex(ae_c_sub(c1.xyC[i][j], c1.xyC[i][j + n])) > threshold;
            }
         }
      }
   }
// Testing GCond
   for (n = 2; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
      // real test
         testmatgenunit_unset2d(&a);
         cond = exp(log(1000.0) * randomreal());
         rmatrixrndcond(n, cond, &a);
         ae_matrix_set_length(&b, n + 1, n + 1);
         for (i = 1; i <= n; i++) {
            for (j = 1; j <= n; j++) {
               b.xyR[i][j] = a.xyR[i - 1][j - 1];
            }
         }
         if (testmatgenunit_obsoletesvddecomposition(&b, n, n, &w, &v)) {
            maxw = w.xR[1];
            minw = w.xR[1];
            for (i = 2; i <= n; i++) {
               if (w.xR[i] > maxw) {
                  maxw = w.xR[i];
               }
               if (w.xR[i] < minw) {
                  minw = w.xR[i];
               }
            }
            vt = maxw / minw / cond;
            if (fabs(log(vt)) > log(1 + threshold)) {
               rerr = true;
            }
         }
      }
   }
// Symmetric/SPD
// N = 2 .. 30
   for (n = 2; n <= maxn; n++) {
   // SPD matrices
      for (pass = 1; pass <= passcount; pass++) {
      // Generate A
         testmatgenunit_unset2d(&a);
         cond = exp(log(1000.0) * randomreal());
         spdmatrixrndcond(n, cond, &a);
      // test condition number
         spderr = spderr || testmatgenunit_svdcond(&a, n) / cond - 1 > threshold;
      // test SPD
         spderr = spderr || !testmatgenunit_isspd(&a, n, true);
      // test that A is symmetic
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               spderr = spderr || fabs(a.xyR[i][j] - a.xyR[j][i]) > threshold;
            }
         }
      // test for difference between A and B (subsequent matrix)
         testmatgenunit_unset2d(&b);
         spdmatrixrndcond(n, cond, &b);
         if (n >= 2) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  spderr = spderr || a.xyR[i][j] == b.xyR[i][j];
               }
            }
         }
      }
   // HPD matrices
      for (pass = 1; pass <= passcount; pass++) {
      // Generate A
         testmatgenunit_unset2dc(&ca);
         cond = exp(log(1000.0) * randomreal());
         hpdmatrixrndcond(n, cond, &ca);
      // test HPD
         hpderr = hpderr || !testmatgenunit_ishpd(&ca, n);
      // test that A is Hermitian
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               hpderr = hpderr || abscomplex(ae_c_sub(ca.xyC[i][j], conj(ca.xyC[j][i]))) > threshold;
            }
         }
      // test for difference between A and B (subsequent matrix)
         testmatgenunit_unset2dc(&cb);
         hpdmatrixrndcond(n, cond, &cb);
         if (n >= 2) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  hpderr = hpderr || ae_c_eq(ca.xyC[i][j], cb.xyC[i][j]);
               }
            }
         }
      }
   // Symmetric matrices
      for (pass = 1; pass <= passcount; pass++) {
      // test condition number
         testmatgenunit_unset2d(&a);
         cond = exp(log(1000.0) * randomreal());
         smatrixrndcond(n, cond, &a);
         serr = serr || testmatgenunit_svdcond(&a, n) / cond - 1 > threshold;
      // test for difference between A and B
         testmatgenunit_unset2d(&b);
         smatrixrndcond(n, cond, &b);
         if (n >= 2) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  serr = serr || a.xyR[i][j] == b.xyR[i][j];
               }
            }
         }
      }
   // Hermitian matrices
      for (pass = 1; pass <= passcount; pass++) {
      // Generate A
         testmatgenunit_unset2dc(&ca);
         cond = exp(log(1000.0) * randomreal());
         hmatrixrndcond(n, cond, &ca);
      // test that A is Hermitian
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               herr = herr || abscomplex(ae_c_sub(ca.xyC[i][j], conj(ca.xyC[j][i]))) > threshold;
            }
         }
      // test for difference between A and B (subsequent matrix)
         testmatgenunit_unset2dc(&cb);
         hmatrixrndcond(n, cond, &cb);
         if (n >= 2) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  herr = herr || ae_c_eq(ca.xyC[i][j], cb.xyC[i][j]);
               }
            }
         }
      }
   }
// Test for symmetric matrices
   eulerr = testmatgenunit_testeult();
// report
   waserrors = (((((rerr || cerr) || serr) || spderr) || herr) || hpderr) || eulerr;
   if (!silent) {
      printf("TESTING MATRIX GENERATOR\n");
      printf("REAL TEST:                               ");
      if (!rerr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("COMPLEX TEST:                            ");
      if (!cerr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("SYMMETRIC TEST:                          ");
      if (!serr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("HERMITIAN TEST:                          ");
      if (!herr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("SPD TEST:                                ");
      if (!spderr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("HPD TEST:                                ");
      if (!hpderr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("TEST FOR SYMMETRIC MATRICES:             ");
      if (!eulerr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === tsort testing unit ===
// Unsets 1D array.
static void testtsortunit_unset1di(ZVector *a) {
   ae_vector_set_length(a, 0 + 1);
   a->xZ[0] = randominteger(3) - 1;
}

static void testtsortunit_testsortresults(RVector *asorted, ZVector *p1, ZVector *p2, RVector *aoriginal, ae_int_t n, bool *waserrors) {
   ae_frame _frame_block;
   ae_int_t i;
   double t;
   ae_frame_make(&_frame_block);
   NewVector(a2, 0, DT_REAL);
   NewVector(f, 0, DT_INT);
   ae_vector_set_length(&a2, n - 1 + 1);
   ae_vector_set_length(&f, n - 1 + 1);
// is set ordered?
   for (i = 0; i < n - 1; i++) {
      *waserrors = *waserrors || asorted->xR[i] > asorted->xR[i + 1];
   }
// P1 correctness
   for (i = 0; i < n; i++) {
      *waserrors = *waserrors || asorted->xR[i] != aoriginal->xR[p1->xZ[i]];
   }
   for (i = 0; i < n; i++) {
      f.xZ[i] = 0;
   }
   for (i = 0; i < n; i++) {
      f.xZ[p1->xZ[i]]++;
   }
   for (i = 0; i < n; i++) {
      *waserrors = *waserrors || f.xZ[i] != 1;
   }
// P2 correctness
   for (i = 0; i < n; i++) {
      a2.xR[i] = aoriginal->xR[i];
   }
   for (i = 0; i < n; i++) {
      if (p2->xZ[i] != i) {
         t = a2.xR[i];
         a2.xR[i] = a2.xR[p2->xZ[i]];
         a2.xR[p2->xZ[i]] = t;
      }
   }
   for (i = 0; i < n; i++) {
      *waserrors = *waserrors || asorted->xR[i] != a2.xR[i];
   }
   ae_frame_leave();
}

// Testing tag sort
bool testtsort(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   ae_int_t n;
   ae_int_t i;
   ae_int_t m;
   ae_int_t offs;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t maxn;
   bool distinctvals;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(a, 0, DT_REAL);
   NewVector(a0, 0, DT_REAL);
   NewVector(a1, 0, DT_REAL);
   NewVector(a2, 0, DT_REAL);
   NewVector(a3, 0, DT_REAL);
   NewVector(i1, 0, DT_INT);
   NewVector(i2, 0, DT_INT);
   NewVector(i3, 0, DT_INT);
   NewVector(a4, 0, DT_INT);
   NewVector(a5, 0, DT_INT);
   NewVector(pa4, 0, DT_INT);
   NewVector(ar, 0, DT_REAL);
   NewVector(ar2, 0, DT_REAL);
   NewVector(ai, 0, DT_INT);
   NewVector(p1, 0, DT_INT);
   NewVector(p2, 0, DT_INT);
   NewVector(bufr1, 0, DT_REAL);
   NewVector(bufr2, 0, DT_REAL);
   NewVector(bufi1, 0, DT_INT);
   waserrors = false;
   maxn = 100;
   passcount = 10;
// Test tagsort
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
      // Pprobably distinct sort:
      // * generate array of integer random numbers.
      //   Because of birthday paradox, random numbers have to be VERY large
      //   in order to avoid situation when we have distinct values.
      // * sort A0 using TagSort and test sort results
      // * now we can use A0 as reference point and test other functions
         testtsortunit_unset1di(&p1);
         testtsortunit_unset1di(&p2);
         ae_vector_set_length(&a, n);
         ae_vector_set_length(&a0, n);
         ae_vector_set_length(&a1, n);
         ae_vector_set_length(&a2, n);
         ae_vector_set_length(&a3, n);
         ae_vector_set_length(&a4, n);
         ae_vector_set_length(&a5, n);
         ae_vector_set_length(&ar, n);
         ae_vector_set_length(&ar2, n);
         ae_vector_set_length(&ai, n);
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)randominteger(100000000);
            a0.xR[i] = a.xR[i];
            a1.xR[i] = a.xR[i];
            a2.xR[i] = a.xR[i];
            a3.xR[i] = a.xR[i];
            a4.xZ[i] = iround(a.xR[i]);
            a5.xZ[i] = iround(a.xR[i]);
            ar.xR[i] = (double)i;
            ar2.xR[i] = (double)i;
            ai.xZ[i] = i;
         }
         tagsort(&a0, n, &p1, &p2);
         testtsortunit_testsortresults(&a0, &p1, &p2, &a, n, &waserrors);
         distinctvals = true;
         for (i = 1; i < n; i++) {
            distinctvals = distinctvals && a0.xR[i] != a0.xR[i - 1];
         }
         if (distinctvals) {
            tagsortfasti(&a1, &ai, &bufr1, &bufi1, n);
            for (i = 0; i < n; i++) {
               waserrors = (waserrors || a1.xR[i] != a0.xR[i]) || ai.xZ[i] != p1.xZ[i];
            }
            tagsortfastr(&a2, &ar, &bufr1, &bufr2, n);
            for (i = 0; i < n; i++) {
               waserrors = (waserrors || a2.xR[i] != a0.xR[i]) || ar.xR[i] != (double)p1.xZ[i];
            }
            tagsortfast(&a3, &bufr1, n);
            for (i = 0; i < n; i++) {
               waserrors = waserrors || a3.xR[i] != a0.xR[i];
            }
            tagsortmiddleir(&a4, &ar2, 0, n);
            for (i = 0; i < n; i++) {
               waserrors = (waserrors || (double)a4.xZ[i] != a0.xR[i]) || ar2.xR[i] != (double)p1.xZ[i];
            }
            sortmiddlei(&a5, 0, n);
            for (i = 0; i < n; i++) {
               waserrors = waserrors || (double)a5.xZ[i] != a0.xR[i];
            }
         }
      // Non-distinct sort.
      // We test that keys are correctly reordered, but do NOT test order of values.
         testtsortunit_unset1di(&p1);
         testtsortunit_unset1di(&p2);
         ae_vector_set_length(&a, n);
         ae_vector_set_length(&a0, n);
         ae_vector_set_length(&a1, n);
         ae_vector_set_length(&a2, n);
         ae_vector_set_length(&a3, n);
         ae_vector_set_length(&a4, n);
         ae_vector_set_length(&a5, n);
         ae_vector_set_length(&ar, n);
         ae_vector_set_length(&ar2, n);
         ae_vector_set_length(&ai, n);
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)((n - i) / 2);
            a0.xR[i] = a.xR[i];
            a1.xR[i] = a.xR[i];
            a2.xR[i] = a.xR[i];
            a3.xR[i] = a.xR[i];
            a4.xZ[i] = iround(a.xR[i]);
            a5.xZ[i] = iround(a.xR[i]);
            ar.xR[i] = (double)i;
            ar2.xR[i] = (double)i;
            ai.xZ[i] = i;
         }
         tagsort(&a0, n, &p1, &p2);
         testtsortunit_testsortresults(&a0, &p1, &p2, &a, n, &waserrors);
         tagsortfasti(&a1, &ai, &bufr1, &bufi1, n);
         for (i = 0; i < n; i++) {
            waserrors = waserrors || a1.xR[i] != a0.xR[i];
         }
         tagsortfastr(&a2, &ar, &bufr1, &bufr2, n);
         for (i = 0; i < n; i++) {
            waserrors = waserrors || a2.xR[i] != a0.xR[i];
         }
         tagsortfast(&a3, &bufr1, n);
         for (i = 0; i < n; i++) {
            waserrors = waserrors || a3.xR[i] != a0.xR[i];
         }
         tagsortmiddleir(&a4, &ar2, 0, n);
         for (i = 0; i < n; i++) {
            waserrors = waserrors || (double)a4.xZ[i] != a0.xR[i];
         }
         sortmiddlei(&a5, 0, n);
         for (i = 0; i < n; i++) {
            waserrors = waserrors || (double)a5.xZ[i] != a0.xR[i];
         }
      // 'All same' sort
      // We test that keys are correctly reordered, but do NOT test order of values.
         testtsortunit_unset1di(&p1);
         testtsortunit_unset1di(&p2);
         ae_vector_set_length(&a, n);
         ae_vector_set_length(&a0, n);
         ae_vector_set_length(&a1, n);
         ae_vector_set_length(&a2, n);
         ae_vector_set_length(&a3, n);
         ae_vector_set_length(&a4, n);
         ae_vector_set_length(&ar, n);
         ae_vector_set_length(&ar2, n);
         ae_vector_set_length(&ai, n);
         for (i = 0; i < n; i++) {
            a.xR[i] = 0.0;
            a0.xR[i] = a.xR[i];
            a1.xR[i] = a.xR[i];
            a2.xR[i] = a.xR[i];
            a3.xR[i] = a.xR[i];
            a4.xZ[i] = iround(a.xR[i]);
            ar.xR[i] = (double)i;
            ar2.xR[i] = (double)i;
            ai.xZ[i] = i;
         }
         tagsort(&a0, n, &p1, &p2);
         testtsortunit_testsortresults(&a0, &p1, &p2, &a, n, &waserrors);
         tagsortfasti(&a1, &ai, &bufr1, &bufi1, n);
         for (i = 0; i < n; i++) {
            waserrors = waserrors || a1.xR[i] != a0.xR[i];
         }
         tagsortfastr(&a2, &ar, &bufr1, &bufr2, n);
         for (i = 0; i < n; i++) {
            waserrors = waserrors || a2.xR[i] != a0.xR[i];
         }
         tagsortfast(&a3, &bufr1, n);
         for (i = 0; i < n; i++) {
            waserrors = waserrors || a3.xR[i] != a0.xR[i];
         }
         tagsortmiddleir(&a4, &ar2, 0, n);
         for (i = 0; i < n; i++) {
            waserrors = waserrors || (double)a4.xZ[i] != a0.xR[i];
         }
      // 0-1 sort
      // We test that keys are correctly reordered, but do NOT test order of values.
         testtsortunit_unset1di(&p1);
         testtsortunit_unset1di(&p2);
         ae_vector_set_length(&a, n);
         ae_vector_set_length(&a0, n);
         ae_vector_set_length(&a1, n);
         ae_vector_set_length(&a2, n);
         ae_vector_set_length(&a3, n);
         ae_vector_set_length(&a4, n);
         ae_vector_set_length(&ar, n);
         ae_vector_set_length(&ar2, n);
         ae_vector_set_length(&ai, n);
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)randominteger(2);
            a0.xR[i] = a.xR[i];
            a1.xR[i] = a.xR[i];
            a2.xR[i] = a.xR[i];
            a3.xR[i] = a.xR[i];
            a4.xZ[i] = iround(a.xR[i]);
            ar.xR[i] = (double)i;
            ar2.xR[i] = (double)i;
            ai.xZ[i] = i;
         }
         tagsort(&a0, n, &p1, &p2);
         testtsortunit_testsortresults(&a0, &p1, &p2, &a, n, &waserrors);
         tagsortfasti(&a1, &ai, &bufr1, &bufi1, n);
         for (i = 0; i < n; i++) {
            waserrors = waserrors || a1.xR[i] != a0.xR[i];
         }
         tagsortfastr(&a2, &ar, &bufr1, &bufr2, n);
         for (i = 0; i < n; i++) {
            waserrors = waserrors || a2.xR[i] != a0.xR[i];
         }
         tagsortfast(&a3, &bufr1, n);
         for (i = 0; i < n; i++) {
            waserrors = waserrors || a3.xR[i] != a0.xR[i];
         }
         tagsortmiddleir(&a4, &ar2, 0, n);
         for (i = 0; i < n; i++) {
            waserrors = waserrors || (double)a4.xZ[i] != a0.xR[i];
         }
      // Special test for TagSortMiddleIR: sorting in the middle gives same results
      // as sorting in the beginning of the array
         m = 3 * n;
         offs = randominteger(n);
         ae_vector_set_length(&i1, m);
         ae_vector_set_length(&i2, m);
         ae_vector_set_length(&i3, m);
         ae_vector_set_length(&ar, m);
         ae_vector_set_length(&ar2, m);
         for (i = 0; i < m; i++) {
            i1.xZ[i] = randominteger(100000000);
            i2.xZ[i] = i1.xZ[i];
            i3.xZ[i] = i1.xZ[i];
            ar.xR[i] = (double)i;
            ar2.xR[i] = (double)i;
         }
         for (i = 0; i < n; i++) {
            i1.xZ[i] = i1.xZ[offs + i];
            ar.xR[i] = ar.xR[offs + i];
         }
         tagsortmiddleir(&i1, &ar, 0, n);
         for (i = 1; i < n; i++) {
            distinctvals = distinctvals && i1.xZ[i] != i1.xZ[i - 1];
         }
         if (distinctvals) {
            tagsortmiddleir(&i2, &ar2, offs, n);
            for (i = 0; i < n; i++) {
               waserrors = (waserrors || i2.xZ[offs + i] != i1.xZ[i]) || ar2.xR[offs + i] != ar.xR[i];
            }
         }
      }
   }
// report
   if (!silent) {
      printf("TESTING TAGSORT\n");
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === sparse testing unit ===
static const ae_int_t testsparseunit_maxtype = 2;

struct sparsegenerator {
   ae_int_t n;
   ae_int_t m;
   ae_int_t matkind;
   ae_int_t triangle;
   ae_matrix bufa;
   hqrndstate rs;
   rcommstate rcs;
};

static void sparsegenerator_init(void *_p, bool make_automatic) {
   sparsegenerator *p = (sparsegenerator *)_p;
   ae_matrix_init(&p->bufa, 0, 0, DT_REAL, make_automatic);
   hqrndstate_init(&p->rs, make_automatic);
   rcommstate_init(&p->rcs, make_automatic);
}

static void sparsegenerator_copy(void *_dst, void *_src, bool make_automatic) {
   sparsegenerator *dst = (sparsegenerator *)_dst;
   sparsegenerator *src = (sparsegenerator *)_src;
   dst->n = src->n;
   dst->m = src->m;
   dst->matkind = src->matkind;
   dst->triangle = src->triangle;
   ae_matrix_copy(&dst->bufa, &src->bufa, make_automatic);
   hqrndstate_copy(&dst->rs, &src->rs, make_automatic);
   rcommstate_copy(&dst->rcs, &src->rcs, make_automatic);
}

static void sparsegenerator_free(void *_p, bool make_automatic) {
   sparsegenerator *p = (sparsegenerator *)_p;
   ae_matrix_free(&p->bufa, make_automatic);
   hqrndstate_free(&p->rs, make_automatic);
   rcommstate_free(&p->rcs, make_automatic);
}

// Function for testing basic SKS functional.
// Returns True on errors, False on success.
//
// ALGLIB Project: Copyright 16.01.1014 by Sergey Bochkanov
static bool skstest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nz;
   double pnz;
   ae_int_t i;
   ae_int_t j;
   ae_int_t t0;
   ae_int_t t1;
   double v0;
   double v1;
   ae_int_t uppercnt;
   ae_int_t lowercnt;
   ae_int_t bw;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, s1);
   NewObj(sparsematrix, s2);
   NewObj(sparsematrix, s3);
   NewObj(sparsematrix, s4);
   NewObj(sparsematrix, s5);
   NewObj(sparsematrix, s6);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(wasenumerated, 0, 0, DT_BOOL);
   NewVector(d, 0, DT_INT);
   NewVector(u, 0, DT_INT);
   NewObj(hqrndstate, rs);
   result = false;
   hqrndrandomize(&rs);
   for (n = 1; n <= 20; n++) {
      nz = n * n - n;
      while (true) {
      // Generate N*N matrix where probability of non-diagonal element
      // being non-zero is PNZ. We also generate D and U - subdiagonal
      // and superdiagonal profile sizes.
      //
      // Create matrix with either general SKS or banded SKS constructor function
         if (n > 1) {
            pnz = (double)nz / (n * n - n);
         } else {
            pnz = 1.0;
         }
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&u, n);
         ae_matrix_set_length(&a, n, n);
         if (hqrndnormal(&rs) > 0.0) {
         // Test SparseCreateSKS() functionality
            for (i = 0; i < n; i++) {
               d.xZ[i] = 0;
               u.xZ[i] = 0;
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (i == j || hqrnduniformr(&rs) <= pnz) {
                     a.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                     if (j < i) {
                        d.xZ[i] = imax2(d.xZ[i], i - j);
                     } else {
                        u.xZ[j] = imax2(u.xZ[j], j - i);
                     }
                  } else {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
            sparsecreatesks(n, n, &d, &u, &s0);
         } else {
         // Test SparseCreateSKSBand() functionality
            bw = hqrnduniformi(&rs, n + 1);
            for (i = 0; i < n; i++) {
               d.xZ[i] = imin2(bw, i);
               u.xZ[i] = imin2(bw, i);
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (ae_iabs(i - j) <= bw && hqrnduniformr(&rs) <= pnz) {
                     a.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                  } else {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
            sparsecreatesksband(n, n, bw, &s0);
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (a.xyR[i][j] != 0.0) {
                  if (hqrndnormal(&rs) > 0.0) {
                     set_error_flag(&result, !sparserewriteexisting(&s0, i, j, a.xyR[i][j]), __FILE__, __LINE__, "testsparseunit.ap:456");
                  } else {
                     sparseset(&s0, i, j, a.xyR[i][j]);
                  }
               }
            }
         }
         uppercnt = 0;
         lowercnt = 0;
         for (i = 0; i < n; i++) {
            uppercnt += u.xZ[i];
            lowercnt += d.xZ[i];
         }
      // Check correctness of SparseExists()
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (i >= j && i - j > d.xZ[i]) {
                  set_error_flag(&result, sparseexists(&s0, i, j), __FILE__, __LINE__, "testsparseunit.ap:475");
               }
               if (i >= j && i - j <= d.xZ[i]) {
                  set_error_flag(&result, !sparseexists(&s0, i, j), __FILE__, __LINE__, "testsparseunit.ap:477");
               }
               if (i <= j && j - i > u.xZ[j]) {
                  set_error_flag(&result, sparseexists(&s0, i, j), __FILE__, __LINE__, "testsparseunit.ap:479");
               }
               if (i <= j && j - i <= u.xZ[j]) {
                  set_error_flag(&result, !sparseexists(&s0, i, j), __FILE__, __LINE__, "testsparseunit.ap:481");
               }
            }
         }
      // Try to call SparseRewriteExisting() for out-of-band elements, make sure that it returns False.
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if ((i >= j && i - j > d.xZ[i]) || (i <= j && j - i > u.xZ[j])) {
                  set_error_flag(&result, sparserewriteexisting(&s0, i, j, 1.0), __FILE__, __LINE__, "testsparseunit.ap:490");
               }
            }
         }
      // Convert to several different formats, check their contents with SparseGet().
         sparsecopy(&s0, &s1);
         sparseconverttocrs(&s1);
         sparsecopytocrs(&s0, &s2);
         sparsecopytocrsbuf(&s0, &s3);
         sparsecopytohash(&s0, &s4);
         sparsecopytohashbuf(&s0, &s5);
         sparsecopy(&s0, &s6);
         sparseconverttohash(&s6);
         set_error_flag(&result, sparsegetnrows(&s0) != n, __FILE__, __LINE__, "testsparseunit.ap:503");
         set_error_flag(&result, sparsegetncols(&s0) != n, __FILE__, __LINE__, "testsparseunit.ap:504");
         set_error_flag(&result, sparsegetmatrixtype(&s0) != 2, __FILE__, __LINE__, "testsparseunit.ap:505");
         set_error_flag(&result, !sparseissks(&s0), __FILE__, __LINE__, "testsparseunit.ap:506");
         set_error_flag(&result, sparseiscrs(&s0), __FILE__, __LINE__, "testsparseunit.ap:507");
         set_error_flag(&result, sparseishash(&s0), __FILE__, __LINE__, "testsparseunit.ap:508");
         set_error_flag(&result, sparseissks(&s1), __FILE__, __LINE__, "testsparseunit.ap:509");
         set_error_flag(&result, !sparseiscrs(&s1), __FILE__, __LINE__, "testsparseunit.ap:510");
         set_error_flag(&result, sparseishash(&s1), __FILE__, __LINE__, "testsparseunit.ap:511");
         for (i = 0; i < n; i++) {
            v1 = a.xyR[i][i];
            v0 = sparsegetdiagonal(&s0, i);
            set_error_flag(&result, v0 != v1, __FILE__, __LINE__, "testsparseunit.ap:516");
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               v1 = a.xyR[i][j];
               v0 = sparseget(&s0, i, j);
               set_error_flag(&result, v0 != v1, __FILE__, __LINE__, "testsparseunit.ap:523");
               v0 = sparseget(&s1, i, j);
               set_error_flag(&result, v0 != v1, __FILE__, __LINE__, "testsparseunit.ap:525");
               v0 = sparseget(&s2, i, j);
               set_error_flag(&result, v0 != v1, __FILE__, __LINE__, "testsparseunit.ap:527");
               v0 = sparseget(&s3, i, j);
               set_error_flag(&result, v0 != v1, __FILE__, __LINE__, "testsparseunit.ap:529");
               v0 = sparseget(&s4, i, j);
               set_error_flag(&result, v0 != v1, __FILE__, __LINE__, "testsparseunit.ap:531");
               v0 = sparseget(&s5, i, j);
               set_error_flag(&result, v0 != v1, __FILE__, __LINE__, "testsparseunit.ap:533");
               v0 = sparseget(&s6, i, j);
               set_error_flag(&result, v0 != v1, __FILE__, __LINE__, "testsparseunit.ap:535");
            }
         }
      // Check enumeration capabilities:
      // * each element returned by SparseEnumerate() is returned only once
      // * each non-zero element of A was enumerated
         ae_matrix_set_length(&wasenumerated, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               wasenumerated.xyB[i][j] = false;
            }
         }
         t0 = 0;
         t1 = 0;
         while (sparseenumerate(&s0, &t0, &t1, &i, &j, &v0)) {
            set_error_flag(&result, wasenumerated.xyB[i][j], __FILE__, __LINE__, "testsparseunit.ap:551");
            wasenumerated.xyB[i][j] = true;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (a.xyR[i][j] != 0.0) {
                  set_error_flag(&result, !wasenumerated.xyB[i][j], __FILE__, __LINE__, "testsparseunit.ap:557");
               }
            }
         }
      // Check UpperCnt()/LowerCnt()
         set_error_flag(&result, sparsegetuppercount(&s0) != uppercnt, __FILE__, __LINE__, "testsparseunit.ap:562");
         set_error_flag(&result, sparsegetlowercount(&s0) != lowercnt, __FILE__, __LINE__, "testsparseunit.ap:563");
      // Check in-place transposition
         sparsecopy(&s0, &s1);
         sparsetransposesks(&s1);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               v0 = sparseget(&s0, i, j);
               v1 = sparseget(&s1, j, i);
               set_error_flag(&result, v0 != v1, __FILE__, __LINE__, "testsparseunit.ap:575");
            }
         }
      // One more check - matrix is initially created in some other format
      // (CRS or Hash) and converted to SKS later.
         sparsecreate(n, n, 0, &s0);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (a.xyR[i][j] != 0.0) {
                  sparseset(&s0, i, j, a.xyR[i][j]);
               }
            }
         }
         sparsecopy(&s0, &s1);
         sparseconverttosks(&s1);
         sparsecopytosks(&s0, &s2);
         sparsecopytosksbuf(&s0, &s3);
         set_error_flag(&result, !sparseissks(&s1), __FILE__, __LINE__, "testsparseunit.ap:591");
         set_error_flag(&result, sparseiscrs(&s1), __FILE__, __LINE__, "testsparseunit.ap:592");
         set_error_flag(&result, sparseishash(&s1), __FILE__, __LINE__, "testsparseunit.ap:593");
         set_error_flag(&result, !sparseissks(&s2), __FILE__, __LINE__, "testsparseunit.ap:594");
         set_error_flag(&result, sparseiscrs(&s2), __FILE__, __LINE__, "testsparseunit.ap:595");
         set_error_flag(&result, sparseishash(&s2), __FILE__, __LINE__, "testsparseunit.ap:596");
         set_error_flag(&result, !sparseissks(&s3), __FILE__, __LINE__, "testsparseunit.ap:597");
         set_error_flag(&result, sparseiscrs(&s3), __FILE__, __LINE__, "testsparseunit.ap:598");
         set_error_flag(&result, sparseishash(&s3), __FILE__, __LINE__, "testsparseunit.ap:599");
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               v1 = a.xyR[i][j];
               v0 = sparseget(&s1, i, j);
               set_error_flag(&result, v0 != v1, __FILE__, __LINE__, "testsparseunit.ap:605");
               v0 = sparseget(&s2, i, j);
               set_error_flag(&result, v0 != v1, __FILE__, __LINE__, "testsparseunit.ap:607");
               v0 = sparseget(&s3, i, j);
               set_error_flag(&result, v0 != v1, __FILE__, __LINE__, "testsparseunit.ap:609");
            }
         }
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ=0.
         if (nz == 0) {
            break;
         }
         nz = imin2(iround(nz * 0.95), nz - 1);
      }
   }
   ae_frame_leave();
   return result;
}

// Function for testing CRS-specific functionality.
// On failure sets ErrorFlag, on success does not touch it.
//
// ALGLIB Project: Copyright 30.01.2018 by Sergey Bochkanov
static void crstest(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t nz;
   double pnz;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, s1);
   NewObj(sparsematrix, s2);
   NewObj(sparsematrix, s3);
   NewObj(sparsematrix, s4);
   hqrndrandomize(&rs);
   for (n = 1; n <= 10; n++) {
      for (m = 1; m <= 10; m++) {
         nz = n * m;
         while (true) {
         // Generate N*N matrix where probability of non-diagonal element
         // being non-zero is PNZ. We also generate D and U - subdiagonal
         // and superdiagonal profile sizes.
         //
         // Create matrix with either general SKS or banded SKS constructor function
            if (n > 1) {
               pnz = (double)nz / (m * n);
            } else {
               pnz = 1.0;
            }
         // Generate random matrix in HASH format (testing SparseExists()
         // during process), copy it to CRS format, compare with original
            sparsecreate(m, n, iround(nz * hqrnduniformr(&rs)), &s0);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  set_error_flag(errorflag, sparseexists(&s0, i, j), __FILE__, __LINE__, "testsparseunit.ap:676");
                  if (hqrnduniformr(&rs) <= pnz) {
                     sparseset(&s0, i, j, hqrndnormal(&rs));
                     set_error_flag(errorflag, !sparseexists(&s0, i, j), __FILE__, __LINE__, "testsparseunit.ap:680");
                  }
               }
            }
            sparsecopytocrs(&s0, &s1);
            set_error_flag(errorflag, !sparseiscrs(&s1), __FILE__, __LINE__, "testsparseunit.ap:684");
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  set_error_flag(errorflag, sparseget(&s0, i, j) != sparseget(&s1, i, j), __FILE__, __LINE__, "testsparseunit.ap:688");
                  set_error_flag(errorflag, sparseexists(&s0, i, j) && !sparseexists(&s1, i, j), __FILE__, __LINE__, "testsparseunit.ap:689");
                  set_error_flag(errorflag, sparseexists(&s1, i, j) && !sparseexists(&s0, i, j), __FILE__, __LINE__, "testsparseunit.ap:690");
               }
            }
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
         // Check transposition
            sparsecopytocrs(&s1, &s2);
            sparsetransposecrs(&s2);
            set_error_flag(errorflag, !sparseiscrs(&s2), __FILE__, __LINE__, "testsparseunit.ap:700");
            set_error_flag(errorflag, sparsegetnrows(&s1) != sparsegetncols(&s2), __FILE__, __LINE__, "testsparseunit.ap:701");
            set_error_flag(errorflag, sparsegetncols(&s1) != sparsegetnrows(&s2), __FILE__, __LINE__, "testsparseunit.ap:702");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  set_error_flag(errorflag, sparseget(&s1, i, j) != sparseget(&s2, j, i), __FILE__, __LINE__, "testsparseunit.ap:707");
               }
            }
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
         // Check transposition
            sparsecopytransposecrs(&s1, &s3);
            set_error_flag(errorflag, !sparseiscrs(&s3), __FILE__, __LINE__, "testsparseunit.ap:715");
            set_error_flag(errorflag, sparsegetnrows(&s1) != sparsegetncols(&s3), __FILE__, __LINE__, "testsparseunit.ap:716");
            set_error_flag(errorflag, sparsegetncols(&s1) != sparsegetnrows(&s3), __FILE__, __LINE__, "testsparseunit.ap:717");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  set_error_flag(errorflag, sparseget(&s1, i, j) != sparseget(&s3, j, i), __FILE__, __LINE__, "testsparseunit.ap:722");
               }
            }
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
         // Check transposition
            sparsecopytransposecrs(&s1, &s4);
            set_error_flag(errorflag, !sparseiscrs(&s4), __FILE__, __LINE__, "testsparseunit.ap:730");
            set_error_flag(errorflag, sparsegetnrows(&s1) != sparsegetncols(&s4), __FILE__, __LINE__, "testsparseunit.ap:731");
            set_error_flag(errorflag, sparsegetncols(&s1) != sparsegetnrows(&s4), __FILE__, __LINE__, "testsparseunit.ap:732");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  set_error_flag(errorflag, sparseget(&s1, i, j) != sparseget(&s4, j, i), __FILE__, __LINE__, "testsparseunit.ap:737");
               }
            }
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
         // Increase problem sparsity and try one more time.
         // Stop after testing NZ=0.
            if (nz == 0) {
               break;
            }
            nz = imin2(iround(nz * 0.95), nz - 1);
         }
      }
   }
   ae_frame_leave();
}

// Function for testing serialization.
// On failure sets ErrorFlag, on success does not touch it.
//
// ALGLIB Project: Copyright 30.01.2018 by Sergey Bochkanov
static void testserialize(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t mtype;
   ae_int_t nz;
   double pnz;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, s1);
   NewObj(sparsematrix, s2);
   NewObj(sparsematrix, s3);
   NewObj(sparsematrix, s4);
   hqrndrandomize(&rs);
   for (n = 1; n <= 10; n++) {
      for (m = 1; m <= 10; m++) {
         for (mtype = 0; mtype <= testsparseunit_maxtype; mtype++) {
            if (mtype == 2 && m != n) {
               continue;
            }
            nz = n * m;
            while (true) {
            // Generate N*N matrix where probability of non-diagonal element
            // being non-zero is PNZ.
               if (n > 1) {
                  pnz = (double)nz / (m * n);
               } else {
                  pnz = 0.5;
               }
            // Generate random matrix in HASH format (testing SparseExists()
            // during process), convert it to HASH/CRS/SKS format
               sparsecreate(m, n, iround(nz * hqrnduniformr(&rs)), &s0);
               for (i = 0; i < m; i++) {
                  for (j = 0; j < n; j++) {
                     set_error_flag(errorflag, sparseexists(&s0, i, j), __FILE__, __LINE__, "testsparseunit.ap:797");
                     if (hqrnduniformr(&rs) <= pnz) {
                        sparseset(&s0, i, j, hqrndnormal(&rs));
                        set_error_flag(errorflag, !sparseexists(&s0, i, j), __FILE__, __LINE__, "testsparseunit.ap:801");
                     }
                  }
               }
               sparseconvertto(&s0, mtype);
               set_error_flag(errorflag, sparsegetmatrixtype(&s0) != mtype, __FILE__, __LINE__, "testsparseunit.ap:805");
            // Check copy-through-serialization
               {
               // This code passes data structure through serializers
               // (serializes it to string and loads back)
                  ae_int_t _local_ssize;
                  ae_frame _local_frame_block;
                  ae_frame_make(&_local_frame_block);
                  NewSerializer(_local_serializer);
                  ae_serializer_alloc_start(&_local_serializer);
                  sparsealloc(&_local_serializer, &s0);
                  _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                  NewBlock(_local_dynamic_block, _local_ssize + 1);
                  ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  sparseserialize(&_local_serializer, &s0);
                  ae_serializer_stop(&_local_serializer);
                  ae_serializer_init(&_local_serializer);
                  ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  sparseunserialize(&_local_serializer, &s1);
                  ae_serializer_stop(&_local_serializer);
                  ae_frame_leave();
               }
               set_error_flag(errorflag, sparsegetmatrixtype(&s1) != mtype, __FILE__, __LINE__, "testsparseunit.ap:811");
               set_error_flag(errorflag, sparsegetnrows(&s0) != sparsegetnrows(&s1), __FILE__, __LINE__, "testsparseunit.ap:812");
               set_error_flag(errorflag, sparsegetncols(&s0) != sparsegetncols(&s1), __FILE__, __LINE__, "testsparseunit.ap:813");
               if (*errorflag) {
                  ae_frame_leave();
                  return;
               }
               for (i = 0; i < m; i++) {
                  for (j = 0; j < n; j++) {
                     set_error_flag(errorflag, sparseget(&s0, i, j) != sparseget(&s1, i, j), __FILE__, __LINE__, "testsparseunit.ap:818");
                  }
               }
               if (*errorflag) {
                  ae_frame_leave();
                  return;
               }
            // Increase problem sparsity and try one more time.
            // Stop after testing NZ=0.
               if (nz == 0) {
                  break;
               }
               nz = imin2(iround(nz * 0.95), nz - 1);
            }
         }
      }
   }
   ae_frame_leave();
}

// Function for testing basic functional
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool basicfunctest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t j1;
   ae_int_t uppercnt;
   ae_int_t lowercnt;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewMatrix(a, 0, 0, DT_REAL);
   n = 10;
   m = 10;
   result = false;
   for (i = 1; i < m; i++) {
      for (j = 1; j < n; j++) {
         sparsecreate(i, j, 1, &s);
         ae_matrix_set_length(&a, i, j);
      // Checking for Matrix with hash table type
         uppercnt = 0;
         lowercnt = 0;
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               if (j1 > i1) {
                  uppercnt++;
               }
               if (j1 < i1) {
                  lowercnt++;
               }
               a.xyR[i1][j1] = i1 + j1 + (double)((i + j) * (m + n)) / 2.0;
               a.xyR[i1][j1]++;
               sparseset(&s, i1, j1, i1 + j1 + (double)((i + j) * (m + n)) / 2.0);
               sparseadd(&s, i1, j1, 1.0);
               if (a.xyR[i1][j1] != sparseget(&s, i1, j1)) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         }
         for (i1 = 0; i1 < imin2(i, j); i1++) {
            if (a.xyR[i1][i1] != sparsegetdiagonal(&s, i1)) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
         set_error_flag(&result, sparsegetuppercount(&s) != uppercnt, __FILE__, __LINE__, "testsparseunit.ap:887");
         set_error_flag(&result, sparsegetlowercount(&s) != lowercnt, __FILE__, __LINE__, "testsparseunit.ap:888");
      // Checking for Matrix with CRS type
         sparseconverttocrs(&s);
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               if (a.xyR[i1][j1] != sparseget(&s, i1, j1)) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         }
         for (i1 = 0; i1 < imin2(i, j); i1++) {
            if (a.xyR[i1][i1] != sparsegetdiagonal(&s, i1)) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
         set_error_flag(&result, sparsegetuppercount(&s) != uppercnt, __FILE__, __LINE__, "testsparseunit.ap:907");
         set_error_flag(&result, sparsegetlowercount(&s) != lowercnt, __FILE__, __LINE__, "testsparseunit.ap:908");
      }
   }
   ae_frame_leave();
   return result;
}

// This function initializes sparse matrix generator, which is used to generate
// a set of matrices with sequentially increasing sparsity.
//
// Parameters:
//     M, N        -   matrix size. If M=0, then matrix is square N*N.
//                     N and M must be small enough to store N*M dense matrix.
//     MatKind     -   matrix properties:
//                     * 0     -   general sparse (no structure)
//                     * 1     -   general sparse, but diagonal is always present and non-zero
//                     * 2     -   diagonally dominant, SPD
//     Triangle    -   triangle being returned:
//                     * +1    -   upper triangle
//                     * -1    -   lower triangle
//                     *  0    -   full matrix is returned
//
// Outputs:
//     G           -   generator
//     A           -   matrix A in dense format
//     SA          -   matrix A in sparse format (hash-table storage)
static void testsparseunit_initgenerator(ae_int_t m, ae_int_t n, ae_int_t matkind, ae_int_t triangle, sparsegenerator *g) {
   SetObj(sparsegenerator, g);
   g->n = n;
   g->m = m;
   g->matkind = matkind;
   g->triangle = triangle;
   hqrndrandomize(&g->rs);
   ae_vector_set_length(&g->rcs.ia, 5 + 1);
   ae_vector_set_length(&g->rcs.ra, 1 + 1);
   g->rcs.stage = -1;
}

static bool testsparseunit_generatenext(sparsegenerator *g, RMatrix *da, sparsematrix *sa) {
   ae_int_t n;
   ae_int_t m;
   ae_int_t nz;
   ae_int_t nzd;
   double pnz;
   ae_int_t i;
   ae_int_t j;
   double v;
   SetMatrix(da);
   SetObj(sparsematrix, sa);
// Manually threaded two-way signalling.
// Locals are set arbitrarily the first time around and are retained between pauses and subsequent resumes.
// A Spawn occurs when the routine is (re-)started.
// A Pause sends an event signal and waits for a response with data before carrying out the matching Resume.
// An Exit sends an exit signal indicating the end of the process.
   if (g->rcs.stage < 0) goto Spawn;
   n = g->rcs.ia.xZ[0];
   m = g->rcs.ia.xZ[1];
   nz = g->rcs.ia.xZ[2];
   nzd = g->rcs.ia.xZ[3];
   i = g->rcs.ia.xZ[4];
   j = g->rcs.ia.xZ[5];
   pnz = g->rcs.ra.xR[0];
   v = g->rcs.ra.xR[1];
   switch (g->rcs.stage) {
      case 0: goto Resume0; case 1: goto Resume1;
      default: goto Exit;
   }
Spawn:
   n = 359;
   m = -58;
   nz = -919;
   nzd = -909;
   i = 81;
   j = 255;
   pnz = 74;
   v = -788;
// Routine body
   n = g->n;
   if (g->m == 0) {
      m = n;
   } else {
      m = g->m;
   }
   ae_assert(m > 0 && n > 0, "GenerateNext: incorrect N/M");
   if (g->matkind == 0) { // Generate general sparse matrix
      for (nz = n * m; ; nz /= 2) {
      // Generate dense N*N matrix where probability of element
      // being non-zero is PNZ.
         pnz = (double)nz / (n * m);
         ae_matrix_set_length(&g->bufa, m, n);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               if (hqrnduniformr(&g->rs) <= pnz) {
                  g->bufa.xyR[i][j] = hqrnduniformr(&g->rs) - 0.5;
               } else {
                  g->bufa.xyR[i][j] = 0.0;
               }
            }
         }
      // Output matrix and RComm
         ae_matrix_set_length(da, m, n);
         sparsecreate(m, n, iround(pnz * m * n), sa);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               if ((j <= i && g->triangle <= 0) || (j >= i && g->triangle >= 0)) {
                  da->xyR[i][j] = g->bufa.xyR[i][j];
                  sparseset(sa, i, j, g->bufa.xyR[i][j]);
               } else {
                  da->xyR[i][j] = 0.0;
               }
            }
         }
         g->rcs.stage = 0; goto Pause; Resume0:
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ=0.
         if (nz == 0) {
            break;
         }
      }
   } else if (g->matkind == 1) { // Generate general sparse matrix with non-zero diagonal
      ae_assert(n == m, "GenerateNext: non-square matrix for MatKind=1");
      for (nz = n * n - n; ; nz /= 2) {
      // Generate dense N*N matrix where probability of non-diagonal element
      // being non-zero is PNZ.
         if (n > 1) {
            pnz = (double)nz / (n * n - n);
         } else {
            pnz = 1.0;
         }
         ae_matrix_set_length(&g->bufa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (i == j) {
                  do {
                     g->bufa.xyR[i][i] = hqrnduniformr(&g->rs) - 0.5;
                  } while (g->bufa.xyR[i][i] == 0.0);
                  g->bufa.xyR[i][i] += 1.5 * sign(g->bufa.xyR[i][i]);
                  continue;
               }
               if (hqrnduniformr(&g->rs) <= pnz) {
                  g->bufa.xyR[i][j] = hqrnduniformr(&g->rs) - 0.5;
               } else {
                  g->bufa.xyR[i][j] = 0.0;
               }
            }
         }
      // Output matrix and RComm
         ae_matrix_set_length(da, n, n);
         sparsecreate(n, n, iround(pnz * (n * n - n) + n), sa);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if ((j <= i && g->triangle <= 0) || (j >= i && g->triangle >= 0)) {
                  da->xyR[i][j] = g->bufa.xyR[i][j];
                  sparseset(sa, i, j, g->bufa.xyR[i][j]);
               } else {
                  da->xyR[i][j] = 0.0;
               }
            }
         }
         g->rcs.stage = 1; goto Pause; Resume1:
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ=0.
         if (nz == 0) {
            break;
         }
      }
   } else ae_assert(false, "Assertion failed");
Exit:
   g->rcs.stage = -1;
   return false;
// Saving state
Pause:
   g->rcs.ia.xZ[0] = n;
   g->rcs.ia.xZ[1] = m;
   g->rcs.ia.xZ[2] = nz;
   g->rcs.ia.xZ[3] = nzd;
   g->rcs.ia.xZ[4] = i;
   g->rcs.ia.xZ[5] = j;
   g->rcs.ra.xR[0] = pnz;
   g->rcs.ra.xR[1] = v;
   return true;
}

// Function for testing Level 2 unsymmetric linear algebra functions.
// Additionally it tests SparseGet() for several matrix formats.
// Returns True on failure.
//
// ALGLIB Project: Copyright 20.01.2014 by Sergey Bochkanov
static bool testlevel2unsymmetric() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   double eps;
   double v;
   ae_int_t ix;
   ae_int_t iy;
   double alpha;
   double beta;
   ae_int_t ops;
   ae_int_t opm;
   ae_int_t opn;
   ae_int_t alphakind;
   ae_int_t betakind;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, sa);
   NewObj(sparsegenerator, g);
   NewObj(hqrndstate, rs);
   eps = 10000 * machineepsilon;
   result = false;
   hqrndrandomize(&rs);
// Test linear algebra functions
   for (m = 1; m <= 20; m++) {
      for (n = 1; n <= 20; n++) {
         testsparseunit_initgenerator(m, n, 0, 0, &g);
         while (testsparseunit_generatenext(&g, &a, &sa)) {
         // Convert SA to desired storage format:
         // * to CRS if M != N
         // * with 50% probability to CRS or SKS, if M=N
            if (m != n || hqrnduniformr(&rs) < 0.5) {
               sparsecopytocrs(&sa, &s0);
            } else {
               sparsecopytosks(&sa, &s0);
            }
         // Test SparseGet() for SA and S0 against matrix returned in A
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  set_error_flag(&result, fabs(sparseget(&sa, i, j) - a.xyR[i][j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:966");
                  set_error_flag(&result, fabs(sparseget(&s0, i, j) - a.xyR[i][j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:967");
               }
            }
         // Test SparseMV
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&x1, n);
            for (j = 0; j < n; j++) {
               x0.xR[j] = hqrnduniformr(&rs) - 0.5;
               x1.xR[j] = x0.xR[j];
            }
            sparsemv(&s0, &x0, &y0);
            set_error_flag(&result, y0.cnt < m, __FILE__, __LINE__, "testsparseunit.ap:981");
            if (result) {
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < m; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
               set_error_flag(&result, fabs(v - y0.xR[i]) > eps, __FILE__, __LINE__, "testsparseunit.ap:987");
            }
         // Test SparseMTV
            ae_vector_set_length(&x0, m);
            ae_vector_set_length(&x1, m);
            for (j = 0; j < m; j++) {
               x0.xR[j] = hqrnduniformr(&rs) - 0.5;
               x1.xR[j] = x0.xR[j];
            }
            sparsemtv(&s0, &x0, &y0);
            set_error_flag(&result, y0.cnt < n, __FILE__, __LINE__, "testsparseunit.ap:1001");
            if (result) {
               ae_frame_leave();
               return result;
            }
            for (j = 0; j < n; j++) {
               v = ae_v_dotproduct(&a.xyR[0][j], a.stride, x1.xR, 1, m);
               set_error_flag(&result, fabs(v - y0.xR[j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1007");
            }
         // Sparse GEMV
            for (ops = 0; ops <= 1; ops++) {
               for (alphakind = 0; alphakind <= 1; alphakind++) {
                  for (betakind = 0; betakind <= 1; betakind++) {
                  // Prepare inputs for testing
                     ix = hqrnduniformi(&rs, 50);
                     iy = hqrnduniformi(&rs, 50);
                     alpha = alphakind * hqrndnormal(&rs);
                     beta = betakind * hqrndnormal(&rs);
                     if (ops == 0) {
                        opm = m;
                        opn = n;
                     } else {
                        opm = n;
                        opn = m;
                     }
                     ae_vector_set_length(&x0, ix + opn);
                     ae_vector_set_length(&x1, ix + opn);
                     for (j = 0; j < ix + opn; j++) {
                        x0.xR[j] = hqrnduniformr(&rs) - 0.5;
                        x1.xR[j] = x0.xR[j];
                     }
                     ae_vector_set_length(&y0, iy + opm);
                     ae_vector_set_length(&y1, iy + opm);
                     for (j = 0; j < iy + opm; j++) {
                        y0.xR[j] = hqrnduniformr(&rs) - 0.5;
                        y1.xR[j] = y0.xR[j];
                     }
                  // Prepare reference result in Y1
                     for (i = 0; i < opm; i++) {
                        v = 0.0;
                        for (j = 0; j < opn; j++) {
                           if (ops == 0) {
                              v += a.xyR[i][j] * x1.xR[ix + j];
                           } else {
                              v += a.xyR[j][i] * x1.xR[ix + j];
                           }
                        }
                        y1.xR[iy + i] = alpha * v + beta * y1.xR[iy + i];
                     }
                  // Test
                     sparsegemv(&s0, alpha, ops, &x0, ix, beta, &y0, iy);
                     for (j = 0; j < iy + opm; j++) {
                        set_error_flag(&result, fabs(y0.xR[j] - y1.xR[j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1068");
                     }
                  }
               }
            }
         // Test SparseMV2
            if (m == n) {
               ae_vector_set_length(&x0, n);
               ae_vector_set_length(&x1, n);
               for (j = 0; j < n; j++) {
                  x0.xR[j] = hqrnduniformr(&rs) - 0.5;
                  x1.xR[j] = x0.xR[j];
               }
               sparsemv2(&s0, &x0, &y0, &y1);
               set_error_flag(&result, y0.cnt < n, __FILE__, __LINE__, "testsparseunit.ap:1084");
               set_error_flag(&result, y1.cnt < n, __FILE__, __LINE__, "testsparseunit.ap:1085");
               if (result) {
                  ae_frame_leave();
                  return result;
               }
               for (j = 0; j < n; j++) {
                  v = ae_v_dotproduct(a.xyR[j], 1, x1.xR, 1, n);
                  set_error_flag(&result, fabs(v - y0.xR[j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1091");
                  v = ae_v_dotproduct(&a.xyR[0][j], a.stride, x1.xR, 1, n);
                  set_error_flag(&result, fabs(v - y1.xR[j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1093");
               }
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Function for testing Level 3 unsymmetric linear algebra functions.
// Additionally it tests SparseGet() for several matrix formats.
// Returns True on failure.
//
// ALGLIB Project: Copyright 20.01.2014 by Sergey Bochkanov
static bool testlevel3unsymmetric() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t k;
   ae_int_t i;
   ae_int_t j;
   double eps;
   double v;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(x0, 0, 0, DT_REAL);
   NewMatrix(x1, 0, 0, DT_REAL);
   NewMatrix(y0, 0, 0, DT_REAL);
   NewMatrix(y1, 0, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, sa);
   NewObj(sparsegenerator, g);
   NewObj(hqrndstate, rs);
   eps = 10000 * machineepsilon;
   result = false;
   hqrndrandomize(&rs);
// Test linear algebra functions
   for (m = 1; m <= 20; m++) {
      for (n = 1; n <= 20; n++) {
         testsparseunit_initgenerator(m, n, 0, 0, &g);
         while (testsparseunit_generatenext(&g, &a, &sa)) {
         // Choose matrix width K
            k = 1 + hqrnduniformi(&rs, 20);
         // Convert SA to desired storage format:
         // * to CRS if M != N
         // * with 50% probability to CRS or SKS, if M=N
            if (m != n || hqrnduniformr(&rs) < 0.5) {
               sparsecopytocrs(&sa, &s0);
            } else {
               sparsecopytosks(&sa, &s0);
            }
         // Test SparseGet() for SA and S0 against matrix returned in A
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  set_error_flag(&result, sparseget(&sa, i, j) != a.xyR[i][j], __FILE__, __LINE__, "testsparseunit.ap:1156");
                  set_error_flag(&result, sparseget(&s0, i, j) != a.xyR[i][j], __FILE__, __LINE__, "testsparseunit.ap:1157");
               }
            }
         // Test SparseMV
            ae_matrix_set_length(&x0, n, k);
            ae_matrix_set_length(&x1, n, k);
            for (i = 0; i < n; i++) {
               for (j = 0; j < k; j++) {
                  x0.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                  x1.xyR[i][j] = x0.xyR[i][j];
               }
            }
            sparsemm(&s0, &x0, k, &y0);
            set_error_flag(&result, y0.rows < m, __FILE__, __LINE__, "testsparseunit.ap:1172");
            set_error_flag(&result, y0.cols < k, __FILE__, __LINE__, "testsparseunit.ap:1173");
            if (result) {
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < k; j++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, &x1.xyR[0][j], x1.stride, n);
                  set_error_flag(&result, fabs(v - y0.xyR[i][j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1180");
               }
            }
         // Test SparseMTM
            ae_matrix_set_length(&x0, m, k);
            ae_matrix_set_length(&x1, m, k);
            for (i = 0; i < m; i++) {
               for (j = 0; j < k; j++) {
                  x0.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                  x1.xyR[i][j] = x0.xyR[i][j];
               }
            }
            sparsemtm(&s0, &x0, k, &y0);
            set_error_flag(&result, y0.rows < n, __FILE__, __LINE__, "testsparseunit.ap:1195");
            set_error_flag(&result, y0.cols < k, __FILE__, __LINE__, "testsparseunit.ap:1196");
            if (result) {
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < k; j++) {
                  v = ae_v_dotproduct(&a.xyR[0][i], a.stride, &x1.xyR[0][j], x1.stride, m);
                  set_error_flag(&result, fabs(v - y0.xyR[i][j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1203");
               }
            }
         // Test SparseMM2
            if (m == n) {
               ae_matrix_set_length(&x0, n, k);
               ae_matrix_set_length(&x1, n, k);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < k; j++) {
                     x0.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                     x1.xyR[i][j] = x0.xyR[i][j];
                  }
               }
               sparsemm2(&s0, &x0, k, &y0, &y1);
               set_error_flag(&result, y0.rows < n, __FILE__, __LINE__, "testsparseunit.ap:1220");
               set_error_flag(&result, y0.cols < k, __FILE__, __LINE__, "testsparseunit.ap:1221");
               set_error_flag(&result, y1.rows < n, __FILE__, __LINE__, "testsparseunit.ap:1222");
               set_error_flag(&result, y1.cols < k, __FILE__, __LINE__, "testsparseunit.ap:1223");
               if (result) {
                  ae_frame_leave();
                  return result;
               }
               for (i = 0; i < n; i++) {
                  for (j = 0; j < k; j++) {
                     v = ae_v_dotproduct(a.xyR[i], 1, &x1.xyR[0][j], x1.stride, n);
                     set_error_flag(&result, fabs(v - y0.xyR[i][j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1230");
                     v = ae_v_dotproduct(&a.xyR[0][i], a.stride, &x1.xyR[0][j], x1.stride, n);
                     set_error_flag(&result, fabs(v - y1.xyR[i][j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1232");
                  }
               }
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Function for testing Level 2 symmetric linear algebra functions.
// Additionally it tests SparseGet() for several matrix formats.
// Returns True on failure.
//
// ALGLIB Project: Copyright 20.01.2014 by Sergey Bochkanov
static bool testlevel2symmetric() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   double eps;
   double v;
   double va;
   double vb;
   bool isupper;
   ae_int_t triangletype;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, s1);
   NewObj(sparsematrix, sa);
   NewObj(sparsegenerator, g);
   NewObj(hqrndstate, rs);
   eps = 10000 * machineepsilon;
   result = false;
   hqrndrandomize(&rs);
// Test linear algebra functions
   for (n = 1; n <= 20; n++) {
      for (triangletype = -1; triangletype <= 1; triangletype++) {
         isupper = hqrnduniformr(&rs) > 0.5;
         if (triangletype < 0) {
            isupper = false;
         }
         if (triangletype > 0) {
            isupper = true;
         }
         testsparseunit_initgenerator(n, n, 0, triangletype, &g);
         while (testsparseunit_generatenext(&g, &a, &sa)) {
         // Convert SA to desired storage format:
         // * S0 stores unmodified copy
         // * S1 stores copy with unmodified triangle corresponding
         //   to IsUpper and another triangle being spoiled by random
         //   trash
            sparsecopytohash(&sa, &s1);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper ? j < i : j > i) {
                     sparseset(&s1, i, j, hqrnduniformr(&rs));
                  }
               }
            }
            if (hqrnduniformr(&rs) < 0.5) {
               sparsecopytocrs(&sa, &s0);
               sparseconverttocrs(&s1);
            } else {
               sparsecopytosks(&sa, &s0);
               sparseconverttosks(&s1);
            }
         // Test SparseGet() for SA and S0 against matrix returned in A
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  set_error_flag(&result, fabs(sparseget(&sa, i, j) - a.xyR[i][j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1311");
                  set_error_flag(&result, fabs(sparseget(&s0, i, j) - a.xyR[i][j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1312");
                  set_error_flag(&result, (j < i && triangletype == 1) && sparseget(&s0, i, j) != 0.0, __FILE__, __LINE__, "testsparseunit.ap:1313");
                  set_error_flag(&result, (j > i && triangletype == -1) && sparseget(&s0, i, j) != 0.0, __FILE__, __LINE__, "testsparseunit.ap:1314");
               }
            }
         // Before we proceed with testing, update empty triangle of A
         // with its copy from another part of the matrix.
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper ? j < i : j > i) {
                     a.xyR[i][j] = a.xyR[j][i];
                  }
               }
            }
         // Test SparseSMV
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&x1, n);
            for (j = 0; j < n; j++) {
               x0.xR[j] = hqrnduniformr(&rs) - 0.5;
               x1.xR[j] = x0.xR[j];
            }
            sparsesmv(&s0, isupper, &x0, &y0);
            set_error_flag(&result, y0.cnt < n, __FILE__, __LINE__, "testsparseunit.ap:1337");
            if (result) {
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
               set_error_flag(&result, fabs(v - y0.xR[i]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1343");
            }
            sparsesmv(&s1, isupper, &x0, &y1);
            set_error_flag(&result, y1.cnt < n, __FILE__, __LINE__, "testsparseunit.ap:1346");
            if (result) {
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
               set_error_flag(&result, fabs(v - y1.xR[i]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1352");
            }
         // Test SparseVSMV
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&x1, n);
            for (j = 0; j < n; j++) {
               x0.xR[j] = hqrnduniformr(&rs) - 0.5;
               x1.xR[j] = x0.xR[j];
            }
            vb = 0.0;
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  vb += x1.xR[i] * a.xyR[i][j] * x1.xR[j];
               }
            }
            va = sparsevsmv(&s0, isupper, &x0);
            set_error_flag(&result, fabs(va - vb) > eps, __FILE__, __LINE__, "testsparseunit.ap:1370");
            va = sparsevsmv(&s1, isupper, &x0);
            set_error_flag(&result, fabs(va - vb) > eps, __FILE__, __LINE__, "testsparseunit.ap:1372");
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Function for testing Level 2 symmetric linear algebra functions.
// Additionally it tests SparseGet() for several matrix formats.
// Returns True on failure.
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool testlevel3symmetric() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t k;
   ae_int_t i;
   ae_int_t j;
   double eps;
   double v;
   bool isupper;
   ae_int_t triangletype;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(x0, 0, 0, DT_REAL);
   NewMatrix(x1, 0, 0, DT_REAL);
   NewMatrix(y0, 0, 0, DT_REAL);
   NewMatrix(y1, 0, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, s1);
   NewObj(sparsematrix, sa);
   NewObj(sparsegenerator, g);
   NewObj(hqrndstate, rs);
   eps = 10000 * machineepsilon;
   result = false;
   hqrndrandomize(&rs);
// Test linear algebra functions
   for (n = 1; n <= 20; n++) {
      for (triangletype = -1; triangletype <= 1; triangletype++) {
         isupper = hqrnduniformr(&rs) > 0.5;
         if (triangletype < 0) {
            isupper = false;
         }
         if (triangletype > 0) {
            isupper = true;
         }
         testsparseunit_initgenerator(n, n, 0, triangletype, &g);
         while (testsparseunit_generatenext(&g, &a, &sa)) {
         // Choose matrix width K
            k = 1 + hqrnduniformi(&rs, 20);
         // Convert SA to desired storage format:
         // * S0 stores unmodified copy
         // * S1 stores copy with unmodified triangle corresponding
         //   to IsUpper and another triangle being spoiled by random
         //   trash
            sparsecopytohash(&sa, &s1);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper ? j < i : j > i) {
                     sparseset(&s1, i, j, hqrnduniformr(&rs));
                  }
               }
            }
            if (hqrnduniformr(&rs) < 0.5) {
               sparsecopytocrs(&sa, &s0);
               sparseconverttocrs(&s1);
            } else {
               sparsecopytosks(&sa, &s0);
               sparseconverttosks(&s1);
            }
         // Test SparseGet() for SA and S0 against matrix returned in A
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  set_error_flag(&result, fabs(sparseget(&sa, i, j) - a.xyR[i][j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1453");
                  set_error_flag(&result, fabs(sparseget(&s0, i, j) - a.xyR[i][j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1454");
                  set_error_flag(&result, (j < i && triangletype == 1) && sparseget(&s0, i, j) != 0.0, __FILE__, __LINE__, "testsparseunit.ap:1455");
                  set_error_flag(&result, (j > i && triangletype == -1) && sparseget(&s0, i, j) != 0.0, __FILE__, __LINE__, "testsparseunit.ap:1456");
               }
            }
         // Before we proceed with testing, update empty triangle of A
         // with its copy from another part of the matrix.
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper ? j < i : j > i) {
                     a.xyR[i][j] = a.xyR[j][i];
                  }
               }
            }
         // Test SparseSMM
            ae_matrix_set_length(&x0, n, k);
            ae_matrix_set_length(&x1, n, k);
            for (i = 0; i < n; i++) {
               for (j = 0; j < k; j++) {
                  x0.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                  x1.xyR[i][j] = x0.xyR[i][j];
               }
            }
            sparsesmm(&s0, isupper, &x0, k, &y0);
            set_error_flag(&result, y0.rows < n, __FILE__, __LINE__, "testsparseunit.ap:1480");
            set_error_flag(&result, y0.cols < k, __FILE__, __LINE__, "testsparseunit.ap:1481");
            if (result) {
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < k; j++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, &x1.xyR[0][j], x1.stride, n);
                  set_error_flag(&result, fabs(v - y0.xyR[i][j]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1488");
               }
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Function for testing sparse symmetric permutations
//
// ALGLIB Project: Copyright 07.10.2020 by Sergey Bochkanov
static bool testsymmetricperm() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t functype;
   ae_int_t i;
   ae_int_t j;
   bool isupper;
   double eps;
   double nzprob;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(da, 0, 0, DT_REAL);
   NewMatrix(db, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewObj(sparsematrix, sb);
   NewVector(ptbl, 0, DT_INT);
   NewVector(pprod, 0, DT_INT);
   eps = 10 * machineepsilon;
   result = false;
   hqrndrandomize(&rs);
// Try various N and fill factors
   for (n = 1; n <= 20; n++) {
      nzprob = 1.0;
      while (nzprob >= 0.1 / (n * n)) {
      // Generate matrix with desired fill factor, randomly select one triangle,
      // generate random permutation (in table and product form)
         sparsecreate(n, n, 0, &sa);
         ae_matrix_set_length(&da, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (hqrnduniformr(&rs) < nzprob) {
                  da.xyR[i][j] = hqrndnormal(&rs);
                  sparseset(&sa, i, j, da.xyR[i][j]);
               } else {
                  da.xyR[i][j] = 0.0;
               }
            }
         }
         sparseconverttocrs(&sa);
         isupper = hqrndnormal(&rs) > 0.0;
         for (i = 0; i < n; i++) {
            for (j = 0; j <= i; j++) {
               if (isupper) {
                  da.xyR[i][j] = da.xyR[j][i];
               } else {
                  da.xyR[j][i] = da.xyR[i][j];
               }
            }
         }
         ae_vector_set_length(&ptbl, n);
         ae_vector_set_length(&pprod, n);
         for (i = 0; i < n; i++) {
            ptbl.xZ[i] = i;
         }
         for (i = 0; i < n; i++) {
            pprod.xZ[i] = i + hqrnduniformi(&rs, n - i);
            j = ptbl.xZ[i];
            ptbl.xZ[i] = ptbl.xZ[pprod.xZ[i]];
            ptbl.xZ[pprod.xZ[i]] = j;
         }
         ae_matrix_set_length(&db, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               db.xyR[ptbl.xZ[i]][ptbl.xZ[j]] = da.xyR[i][j];
            }
         }
      // Select function to test, run and test
         functype = hqrnduniformi(&rs, 2);
         if (functype == 0) {
            sparsesymmpermtblbuf(&sa, isupper, &ptbl, &sb);
         }
         if (functype == 1) {
            sparsesymmpermtbl(&sa, isupper, &ptbl, &sb);
         }
         set_error_flag(&result, !sparseiscrs(&sb), __FILE__, __LINE__, "testsparseunit.ap:1582");
         set_error_flag(&result, sparsegetnrows(&sb) != n, __FILE__, __LINE__, "testsparseunit.ap:1583");
         set_error_flag(&result, sparsegetncols(&sb) != n, __FILE__, __LINE__, "testsparseunit.ap:1584");
         if (result) {
            ae_frame_leave();
            return result;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               set_error_flag(&result, (isupper && j >= i) && fabs(db.xyR[i][j] - sparseget(&sb, i, j)) > eps, __FILE__, __LINE__, "testsparseunit.ap:1590");
               set_error_flag(&result, (isupper && j < i) && sparseget(&sb, i, j) != 0.0, __FILE__, __LINE__, "testsparseunit.ap:1591");
            }
         }
      // Increase sparsity
         nzprob *= 0.75;
      }
   }
   ae_frame_leave();
   return result;
}

// Function for testing Level 2 triangular linear algebra functions.
// Returns True on failure.
//
// ALGLIB Project: Copyright 20.01.2014 by Sergey Bochkanov
static bool testlevel2triangular() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t j1;
   double eps;
   double v;
   bool isupper;
   bool isunit;
   ae_int_t optype;
   ae_int_t triangletype;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(ey, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ea, 0, 0, DT_REAL);
   NewObj(sparsematrix, s0);
   NewObj(sparsematrix, s1);
   NewObj(sparsematrix, sa);
   NewObj(sparsegenerator, g);
   NewObj(hqrndstate, rs);
   eps = 10000 * machineepsilon;
   result = false;
   hqrndrandomize(&rs);
// Test sparseTRMV
   for (n = 1; n <= 20; n++) {
      for (triangletype = -1; triangletype <= 1; triangletype++) {
         isupper = hqrnduniformr(&rs) > 0.5;
         if (triangletype < 0) {
            isupper = false;
         }
         if (triangletype > 0) {
            isupper = true;
         }
         testsparseunit_initgenerator(n, n, 0, triangletype, &g);
         while (testsparseunit_generatenext(&g, &a, &sa)) {
         // Settings (IsUpper was already set, handle the rest)
            isunit = hqrnduniformr(&rs) < 0.5;
            optype = hqrnduniformi(&rs, 2);
         // Convert SA to desired storage format:
         // * S0 stores unmodified copy
         // * S1 stores copy with unmodified triangle corresponding
         //   to IsUpper and another triangle being spoiled by random
         //   trash
            sparsecopytohash(&sa, &s1);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper ? j < i : j > i) {
                     sparseset(&s1, i, j, hqrnduniformr(&rs));
                  }
               }
            }
            if (hqrnduniformr(&rs) < 0.5) {
               sparsecopytocrs(&sa, &s0);
               sparseconverttocrs(&s1);
            } else {
               sparsecopytosks(&sa, &s0);
               sparseconverttosks(&s1);
            }
         // Generate "effective A"
            ae_matrix_set_length(&ea, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  ea.xyR[i][j] = 0.0;
               }
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper ? j >= i : j <= i) {
                     i1 = i;
                     j1 = j;
                     if (optype == 1) {
                        swapi(&i1, &j1);
                     }
                     ea.xyR[i1][j1] = a.xyR[i][j];
                     if (isunit && i1 == j1) {
                        ea.xyR[i1][j1] = 1.0;
                     }
                  }
               }
            }
         // Test SparseTRMV
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&x1, n);
            for (j = 0; j < n; j++) {
               x0.xR[j] = hqrnduniformr(&rs) - 0.5;
               x1.xR[j] = x0.xR[j];
            }
            sparsetrmv(&s0, isupper, isunit, optype, &x0, &y0);
            set_error_flag(&result, y0.cnt < n, __FILE__, __LINE__, "testsparseunit.ap:1706");
            if (result) {
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(ea.xyR[i], 1, x1.xR, 1, n);
               set_error_flag(&result, fabs(v - y0.xR[i]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1712");
            }
            sparsetrmv(&s0, isupper, isunit, optype, &x0, &y1);
            set_error_flag(&result, y1.cnt < n, __FILE__, __LINE__, "testsparseunit.ap:1715");
            if (result) {
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(ea.xyR[i], 1, x1.xR, 1, n);
               set_error_flag(&result, fabs(v - y1.xR[i]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1721");
            }
         }
      }
   }
// Test sparseTRSV
   for (n = 1; n <= 20; n++) {
      for (triangletype = -1; triangletype <= 1; triangletype++) {
         isupper = hqrnduniformr(&rs) > 0.5;
         if (triangletype == -1) {
            isupper = false;
         }
         if (triangletype == 1) {
            isupper = true;
         }
         testsparseunit_initgenerator(n, n, 1, triangletype, &g);
         while (testsparseunit_generatenext(&g, &a, &sa)) {
         // Settings (IsUpper was already set, handle the rest)
            isunit = hqrnduniformr(&rs) < 0.5;
            optype = hqrnduniformi(&rs, 2);
         // Convert SA to desired storage format:
         // * S0 stores unmodified copy
         // * S1 stores copy with unmodified triangle corresponding
         //   to IsUpper and another triangle being spoiled by random
         //   trash
            sparsecopytohash(&sa, &s1);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper ? j < i : j > i) {
                     sparseset(&s1, i, j, hqrnduniformr(&rs));
                  }
               }
            }
            if (hqrnduniformr(&rs) < 0.5) {
               sparsecopytocrs(&sa, &s0);
               sparseconverttocrs(&s1);
            } else {
               sparsecopytosks(&sa, &s0);
               sparseconverttosks(&s1);
            }
         // Generate "effective A" and EY = inv(EA)*x0
            ae_matrix_set_length(&ea, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  ea.xyR[i][j] = 0.0;
               }
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper ? j >= i : j <= i) {
                     i1 = i;
                     j1 = j;
                     if (optype == 1) {
                        swapi(&i1, &j1);
                     }
                     ea.xyR[i1][j1] = a.xyR[i][j];
                     if (isunit && i1 == j1) {
                        ea.xyR[i1][j1] = 1.0;
                     }
                  }
               }
            }
            ae_vector_set_length(&ey, n);
            for (i = 0; i < n; i++) {
               ey.xR[i] = hqrnduniformr(&rs) - 0.5;
            }
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&x1, n);
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(ea.xyR[i], 1, ey.xR, 1, n);
               x0.xR[i] = v;
               x1.xR[i] = v;
            }
         // Test SparseTRSV
            sparsetrsv(&s0, isupper, isunit, optype, &x0);
            set_error_flag(&result, x0.cnt < n, __FILE__, __LINE__, "testsparseunit.ap:1805");
            if (result) {
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < n; i++) {
               set_error_flag(&result, fabs(ey.xR[i] - x0.xR[i]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1809");
            }
            sparsetrsv(&s1, isupper, isunit, optype, &x1);
            set_error_flag(&result, x1.cnt < n, __FILE__, __LINE__, "testsparseunit.ap:1811");
            if (result) {
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < n; i++) {
               set_error_flag(&result, fabs(ey.xR[i] - x1.xR[i]) > eps, __FILE__, __LINE__, "testsparseunit.ap:1815");
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Function for testing basic functional
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool basicfuncrandomtest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t j1;
   ae_int_t mfigure;
   ae_int_t temp;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewMatrix(a, 0, 0, DT_REAL);
   n = 20;
   m = 20;
   mfigure = 10;
   for (i = 1; i < m; i++) {
      for (j = 1; j < n; j++) {
         sparsecreate(i, j, 0, &s);
         ae_matrix_set_length(&a, i, j);
      // Checking for Matrix with hash table type
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               temp = 2 * randominteger(mfigure) - mfigure;
               a.xyR[i1][j1] = (double)temp;
               if (randominteger(2) == 0) {
                  sparseset(&s, i1, j1, (double)temp);
                  sparseset(&s, i1, j1, (double)temp);
               } else {
                  sparseadd(&s, i1, j1, (double)temp);
                  sparseadd(&s, i1, j1, 0.0);
               }
               if (a.xyR[i1][j1] != sparseget(&s, i1, j1)) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         }
      // Nulling all elements
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               if (randominteger(2) == 0) {
                  sparseset(&s, i1, j1, 0.0);
               } else {
                  sparseadd(&s, i1, j1, -1 * sparseget(&s, i1, j1));
               }
            }
         }
      // Again initialization of the matrix and check new values
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               temp = 2 * randominteger(mfigure) - mfigure;
               a.xyR[i1][j1] = (double)temp;
               if (randominteger(2) == 0) {
                  sparseset(&s, i1, j1, (double)temp);
               } else {
                  sparseadd(&s, i1, j1, (double)temp);
               }
               if (a.xyR[i1][j1] != sparseget(&s, i1, j1)) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         }
      // Checking for Matrix with CRS type
         sparseconverttocrs(&s);
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               if (a.xyR[i1][j1] != sparseget(&s, i1, j1)) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// This function creates random sparse matrix with some prescribed pattern.
//
// Inputs:
//     M       -   number of rows
//     N       -   number of columns
//     PKind   -   sparsity pattern:
//                 *-1 = pattern is chosen at random as well as P0/P1
//                 * 0 = matrix with up to P0 non-zero elements at random locations
//                       (however, actual number of non-zero elements can be
//                       less than P0, and in fact can be zero)
//                 * 1 = band matrix with P0 non-zero elements below diagonal
//                       and P1 non-zero element above diagonal
//                 * 2 = matrix with random number of contiguous non-zero
//                       elements in the each row
//     CKind   -   creation type:
//                 *-1 = CKind is chosen at random
//                 * 0 = matrix is created in Hash-Table format and converted
//                       to CRS representation
//                 * 1 = matrix is created in CRS format
//                 * 2 = matrix is created in Hash-Table format and converted
//                       to SKS representation
//
// Outputs:
//     DA      -   dense representation of A, array[M,N]
//     SA      -   sparse representation of A, in CRS format
//
// ALGLIB Project: Copyright 31.10.2011 by Sergey Bochkanov
static void testsparseunit_createrandom(ae_int_t m, ae_int_t n, ae_int_t pkind, ae_int_t ckind, ae_int_t p0, ae_int_t p1, RMatrix *da, sparsematrix *sa) {
   ae_frame _frame_block;
   ae_int_t maxpkind;
   ae_int_t maxckind;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_frame_make(&_frame_block);
   SetMatrix(da);
   SetObj(sparsematrix, sa);
   NewVector(c0, 0, DT_INT);
   NewVector(c1, 0, DT_INT);
   NewVector(rowsizes, 0, DT_INT);
   maxpkind = 2;
   maxckind = 2;
   ae_assert(m >= 1, "CreateRandom: incorrect parameters");
   ae_assert(n >= 1, "CreateRandom: incorrect parameters");
   ae_assert(pkind >= -1 && pkind <= maxpkind, "CreateRandom: incorrect parameters");
   ae_assert(ckind >= -1 && ckind <= maxckind, "CreateRandom: incorrect parameters");
   ae_assert(!(ckind == 2 && m != n), "CreateRandom: incorrect parameters");
   if (pkind == -1) {
      pkind = randominteger(maxpkind + 1);
      if (pkind == 0) {
         p0 = randominteger(m * n);
      }
      if (pkind == 1) {
         p0 = randominteger(imin2(m, n));
         p1 = randominteger(imin2(m, n));
      }
   }
   if (ckind == -1) {
      do {
         ckind = randominteger(maxckind + 1);
      } while (ckind == 2 && m != n);
   }
   if (pkind == 0) {
   // Matrix with elements at random locations
      ae_matrix_set_length(da, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            da->xyR[i][j] = 0.0;
         }
      }
      if (ckind == 0 || ckind == 2) {
      // Create matrix in Hash format, convert to CRS or SKS
         sparsecreate(m, n, 1, sa);
         for (k = 0; k < p0; k++) {
            i = randominteger(m);
            j = randominteger(n);
            v = (double)(randominteger(17) - 8) / 8.0;
            if (randombool()) {
               da->xyR[i][j] = v;
               sparseset(sa, i, j, v);
            } else {
               da->xyR[i][j] += v;
               sparseadd(sa, i, j, v);
            }
         }
         if (ckind != 2) {
            sparseconverttocrs(sa);
         } else {
            sparseconverttosks(sa);
         }
         ae_frame_leave();
         return;
      }
      if (ckind == 1) {
      // Create matrix in CRS format
         for (k = 0; k < p0; k++) {
            i = randominteger(m);
            j = randominteger(n);
            v = (double)(randominteger(17) - 8) / 8.0;
            da->xyR[i][j] = v;
         }
         ae_vector_set_length(&rowsizes, m);
         for (i = 0; i < m; i++) {
            rowsizes.xZ[i] = 0;
            for (j = 0; j < n; j++) {
               if (da->xyR[i][j] != 0.0) {
                  rowsizes.xZ[i]++;
               }
            }
         }
         sparsecreatecrs(m, n, &rowsizes, sa);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               if (da->xyR[i][j] != 0.0) {
                  sparseset(sa, i, j, da->xyR[i][j]);
               }
            }
         }
         ae_frame_leave();
         return;
      }
      ae_assert(false, "CreateRandom: internal error");
   }
   if (pkind == 1) {
   // Band matrix
      ae_matrix_set_length(da, m, n);
      ae_vector_set_length(&rowsizes, m);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            da->xyR[i][j] = 0.0;
         }
      }
      for (i = 0; i < m; i++) {
         for (j = imax2(i - p0, 0); j <= i + p1 && j < n; j++) {
            do {
               da->xyR[i][j] = (double)(randominteger(17) - 8) / 8.0;
            } while (da->xyR[i][j] == 0.0);
         }
         rowsizes.xZ[i] = imax2(imin2(i + p1, n - 1) - imax2(i - p0, 0) + 1, 0);
      }
      if (ckind == 0) {
         sparsecreate(m, n, 1, sa);
      }
      if (ckind == 1) {
         sparsecreatecrs(m, n, &rowsizes, sa);
      }
      if (ckind == 2) {
         sparsecreate(m, n, 1, sa);
      }
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            if (da->xyR[i][j] != 0.0) {
               sparseset(sa, i, j, da->xyR[i][j]);
            }
         }
      }
      if (ckind != 2) {
         sparseconverttocrs(sa);
      } else {
         sparseconverttosks(sa);
      }
      ae_frame_leave();
      return;
   }
   if (pkind == 2) {
   // Matrix with one contiguous sequence of non-zero elements per row
      ae_matrix_set_length(da, m, n);
      ae_vector_set_length(&rowsizes, m);
      ae_vector_set_length(&c0, m);
      ae_vector_set_length(&c1, m);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            da->xyR[i][j] = 0.0;
         }
      }
      for (i = 0; i < m; i++) {
         c0.xZ[i] = randominteger(n);
         c1.xZ[i] = c0.xZ[i] + randominteger(n - c0.xZ[i] + 1);
         rowsizes.xZ[i] = c1.xZ[i] - c0.xZ[i];
      }
      for (i = 0; i < m; i++) {
         for (j = c0.xZ[i]; j < c1.xZ[i]; j++) {
            do {
               da->xyR[i][j] = (double)(randominteger(17) - 8) / 8.0;
            } while (da->xyR[i][j] == 0.0);
         }
      }
      if (ckind == 0) {
         sparsecreate(m, n, 1, sa);
      }
      if (ckind == 1) {
         sparsecreatecrs(m, n, &rowsizes, sa);
      }
      if (ckind == 2) {
         sparsecreate(m, n, 1, sa);
      }
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            if (da->xyR[i][j] != 0.0) {
               sparseset(sa, i, j, da->xyR[i][j]);
            }
         }
      }
      if (ckind != 2) {
         sparseconverttocrs(sa);
      } else {
         sparseconverttosks(sa);
      }
      ae_frame_leave();
      return;
   }
   ae_frame_leave();
}

// Function for testing multyplication matrix with vector
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool linearfunctionstest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t j1;
   double lb;
   double rb;
   double eps;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(ty, 0, DT_REAL);
   NewVector(tyt, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(yt, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(yt0, 0, DT_REAL);
// Accuracy
   eps = 1000 * machineepsilon;
// Size of the matrix (m*n)
   n = 10;
   m = 10;
// Left and right borders, limiting matrix values
   lb = -10.0;
   rb = 10.0;
// Test linear algebra functions for:
// a) sparse matrix converted to CRS from Hash-Table
// b) sparse matrix initially created as CRS
   for (i = 1; i < m; i++) {
      for (j = 1; j < n; j++) {
      // Prepare test problem
         testsparseunit_createrandom(i, j, -1, -1, -1, -1, &a, &s);
      // Initialize temporaries
         ae_vector_set_length(&ty, i);
         ae_vector_set_length(&tyt, j);
         for (i1 = 0; i1 < i; i1++) {
            ty.xR[i1] = 0.0;
         }
         for (i1 = 0; i1 < j; i1++) {
            tyt.xR[i1] = 0.0;
         }
         ae_vector_set_length(&x0, j);
         ae_vector_set_length(&x1, i);
         for (i1 = 0; i1 < j; i1++) {
            x0.xR[i1] = (rb - lb) * randomreal() + lb;
         }
         for (i1 = 0; i1 < i; i1++) {
            x1.xR[i1] = (rb - lb) * randomreal() + lb;
         }
      // Consider two cases: square matrix, and non-square matrix
         if (i != j) {
         // Searching true result
            for (i1 = 0; i1 < i; i1++) {
               for (j1 = 0; j1 < j; j1++) {
                  ty.xR[i1] += a.xyR[i1][j1] * x0.xR[j1];
                  tyt.xR[j1] += a.xyR[i1][j1] * x1.xR[i1];
               }
            }
         // Multiplication
            sparsemv(&s, &x0, &y);
            sparsemtv(&s, &x1, &yt);
         // Check for MV-result
            for (i1 = 0; i1 < i; i1++) {
               if (fabs(y.xR[i1] - ty.xR[i1]) >= eps) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         // Check for MTV-result
            for (i1 = 0; i1 < j; i1++) {
               if (fabs(yt.xR[i1] - tyt.xR[i1]) >= eps) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         } else {
         // Searching true result
            for (i1 = 0; i1 < i; i1++) {
               for (j1 = 0; j1 < j; j1++) {
                  ty.xR[i1] += a.xyR[i1][j1] * x0.xR[j1];
                  tyt.xR[j1] += a.xyR[i1][j1] * x0.xR[i1];
               }
            }
            sparsemv(&s, &x0, &y);
            sparsemtv(&s, &x0, &yt);
            sparsemv2(&s, &x0, &y0, &yt0);
         // Check for MV2-result
            for (i1 = 0; i1 < i; i1++) {
               if (fabs(y0.xR[i1] - ty.xR[i1]) >= eps || fabs(yt0.xR[i1] - tyt.xR[i1]) >= eps) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         // Check for MV- and MTV-result by help MV2
            for (i1 = 0; i1 < i; i1++) {
               if (fabs(y0.xR[i1] - y.xR[i1]) > eps || fabs(yt0.xR[i1] - yt.xR[i1]) > eps) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Function for testing multyplication for simmetric matrix with vector
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool linearfunctionsstest() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t i;
   ae_int_t i1;
   ae_int_t j1;
   double lb;
   double rb;
   double eps;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(ty, 0, DT_REAL);
   NewVector(tyt, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(yt, 0, DT_REAL);
// Accuracy
   eps = 1000 * machineepsilon;
// Size of the matrix (m*m)
   m = 10;
// Left and right borders, limiting matrix values
   lb = -10.0;
   rb = 10.0;
// Test linear algebra functions for:
// a) sparse matrix converted to CRS from Hash-Table
// b) sparse matrix initially created as CRS
   for (i = 1; i < m; i++) {
   // Prepare test problem
      testsparseunit_createrandom(i, i, -1, -1, -1, -1, &a, &s);
   // Initialize temporaries
      ae_vector_set_length(&ty, i);
      ae_vector_set_length(&tyt, i);
      ae_vector_set_length(&x0, i);
      ae_vector_set_length(&x1, i);
      for (i1 = 0; i1 < i; i1++) {
         ty.xR[i1] = 0.0;
         tyt.xR[i1] = 0.0;
         x0.xR[i1] = (rb - lb) * randomreal() + lb;
         x1.xR[i1] = (rb - lb) * randomreal() + lb;
      }
   // Searching true result for upper and lower triangles
   // of the matrix
      for (i1 = 0; i1 < i; i1++) {
         for (j1 = i1; j1 < i; j1++) {
            ty.xR[i1] += a.xyR[i1][j1] * x0.xR[j1];
            if (i1 != j1) {
               ty.xR[j1] += a.xyR[i1][j1] * x0.xR[i1];
            }
         }
      }
      for (i1 = 0; i1 < i; i1++) {
         for (j1 = 0; j1 <= i1; j1++) {
            tyt.xR[i1] += a.xyR[i1][j1] * x1.xR[j1];
            if (i1 != j1) {
               tyt.xR[j1] += a.xyR[i1][j1] * x1.xR[i1];
            }
         }
      }
   // Multiplication
      sparsesmv(&s, true, &x0, &y);
      sparsesmv(&s, false, &x1, &yt);
   // Check for SMV-result
      for (i1 = 0; i1 < i; i1++) {
         if (fabs(y.xR[i1] - ty.xR[i1]) >= eps || fabs(yt.xR[i1] - tyt.xR[i1]) >= eps) {
            result = true;
            ae_frame_leave();
            return result;
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Function for testing multyplication sparse matrix with nerrow dense matrix
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool linearfunctionsmmtest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t kmax;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t i1;
   ae_int_t j1;
   ae_int_t k1;
   double lb;
   double rb;
   double eps;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(x0, 0, 0, DT_REAL);
   NewMatrix(x1, 0, 0, DT_REAL);
   NewMatrix(ty, 0, 0, DT_REAL);
   NewMatrix(tyt, 0, 0, DT_REAL);
   NewMatrix(y, 0, 0, DT_REAL);
   NewMatrix(yt, 0, 0, DT_REAL);
   NewMatrix(y0, 0, 0, DT_REAL);
   NewMatrix(yt0, 0, 0, DT_REAL);
// Accuracy
   eps = 1000 * machineepsilon;
// Size of the matrix (m*n)
   n = 32;
   m = 32;
   kmax = 32;
// Left and right borders, limiting matrix values
   lb = -10.0;
   rb = 10.0;
// Test linear algebra functions for:
// a) sparse matrix converted to CRS from Hash-Table
// b) sparse matrix initially created as CRS
   for (i = 1; i < m; i++) {
      for (j = 1; j < n; j++) {
      // Prepare test problem
         testsparseunit_createrandom(i, j, -1, -1, -1, -1, &a, &s);
         ae_matrix_set_length(&x0, j, kmax);
         ae_matrix_set_length(&x1, i, kmax);
         for (i1 = 0; i1 < j; i1++) {
            for (j1 = 0; j1 < kmax; j1++) {
               x0.xyR[i1][j1] = (rb - lb) * randomreal() + lb;
            }
         }
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < kmax; j1++) {
               x1.xyR[i1][j1] = (rb - lb) * randomreal() + lb;
            }
         }
         ae_matrix_set_length(&ty, i, kmax);
         ae_matrix_set_length(&tyt, j, kmax);
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < kmax; j1++) {
               ty.xyR[i1][j1] = 0.0;
            }
         }
         for (i1 = 0; i1 < j; i1++) {
            for (j1 = 0; j1 < kmax; j1++) {
               tyt.xyR[i1][j1] = 0.0;
            }
         }
         if (i != j) {
            for (i1 = 0; i1 < i; i1++) {
               for (k1 = 0; k1 < kmax; k1++) {
                  for (j1 = 0; j1 < j; j1++) {
                     ty.xyR[i1][k1] += a.xyR[i1][j1] * x0.xyR[j1][k1];
                     tyt.xyR[j1][k1] += a.xyR[i1][j1] * x1.xyR[i1][k1];
                  }
               }
            }
         } else {
            for (i1 = 0; i1 < i; i1++) {
               for (k1 = 0; k1 < kmax; k1++) {
                  for (j1 = 0; j1 < j; j1++) {
                     ty.xyR[i1][k1] += a.xyR[i1][j1] * x0.xyR[j1][k1];
                     tyt.xyR[j1][k1] += a.xyR[i1][j1] * x0.xyR[i1][k1];
                  }
               }
            }
         }
         for (k = 1; k <= kmax; k++) {
         // Consider two cases: square matrix, and non-square matrix
            if (i != j) {
            // Multiplication
               sparsemm(&s, &x0, k, &y);
               sparsemtm(&s, &x1, k, &yt);
            // Check for MM-result
               for (i1 = 0; i1 < i; i1++) {
                  for (j1 = 0; j1 < k; j1++) {
                     if (fabs(y.xyR[i1][j1] - ty.xyR[i1][j1]) >= eps) {
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  }
               }
            // Check for MTM-result
               for (i1 = 0; i1 < j; i1++) {
                  for (j1 = 0; j1 < k; j1++) {
                     if (fabs(yt.xyR[i1][j1] - tyt.xyR[i1][j1]) >= eps) {
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  }
               }
            } else {
               sparsemm(&s, &x0, k, &y);
               sparsemtm(&s, &x0, k, &yt);
               sparsemm2(&s, &x0, k, &y0, &yt0);
            // Check for MM2-result
               for (i1 = 0; i1 < i; i1++) {
                  for (j1 = 0; j1 < k; j1++) {
                     if (fabs(y0.xyR[i1][j1] - ty.xyR[i1][j1]) >= eps || fabs(yt0.xyR[i1][j1] - tyt.xyR[i1][j1]) >= eps) {
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  }
               }
            // Check for MV- and MTM-result by help MV2
               for (i1 = 0; i1 < i; i1++) {
                  for (j1 = 0; j1 < k; j1++) {
                     if (fabs(y0.xyR[i1][j1] - y.xyR[i1][j1]) > eps || fabs(yt0.xyR[i1][j1] - yt.xyR[i1][j1]) > eps) {
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  }
               }
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Function for testing multyplication for simmetric sparse matrix with narrow
// dense matrix
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool linearfunctionssmmtest() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t k;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t j1;
   ae_int_t k1;
   double lb;
   double rb;
   double eps;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(x0, 0, 0, DT_REAL);
   NewMatrix(x1, 0, 0, DT_REAL);
   NewMatrix(ty, 0, 0, DT_REAL);
   NewMatrix(tyt, 0, 0, DT_REAL);
   NewMatrix(y, 0, 0, DT_REAL);
   NewMatrix(yt, 0, 0, DT_REAL);
// Accuracy
   eps = 1000 * machineepsilon;
// Size of the matrix (m*m)
   m = 32;
   k = 32;
// Left and right borders, limiting matrix values
   lb = -10.0;
   rb = 10.0;
// Test linear algebra functions for:
// a) sparse matrix converted to CRS from Hash-Table
// b) sparse matrix initially created as CRS
   for (i = 1; i < m; i++) {
      for (j = 1; j < k; j++) {
      // Prepare test problem
         testsparseunit_createrandom(i, i, -1, -1, -1, -1, &a, &s);
      // Initialize temporaries
         ae_matrix_set_length(&ty, i, j);
         ae_matrix_set_length(&tyt, i, j);
         ae_matrix_set_length(&x0, i, j);
         ae_matrix_set_length(&x1, i, j);
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               ty.xyR[i1][j1] = 0.0;
               tyt.xyR[i1][j1] = 0.0;
               x0.xyR[i1][j1] = (rb - lb) * randomreal() + lb;
               x1.xyR[i1][j1] = (rb - lb) * randomreal() + lb;
            }
         }
      // Searching true result for upper and lower triangles
      // of the matrix
         for (k1 = 0; k1 < j; k1++) {
            for (i1 = 0; i1 < i; i1++) {
               for (j1 = i1; j1 < i; j1++) {
                  ty.xyR[i1][k1] += a.xyR[i1][j1] * x0.xyR[j1][k1];
                  if (i1 != j1) {
                     ty.xyR[j1][k1] += a.xyR[i1][j1] * x0.xyR[i1][k1];
                  }
               }
            }
         }
         for (k1 = 0; k1 < j; k1++) {
            for (i1 = 0; i1 < i; i1++) {
               for (j1 = 0; j1 <= i1; j1++) {
                  tyt.xyR[i1][k1] += a.xyR[i1][j1] * x1.xyR[j1][k1];
                  if (i1 != j1) {
                     tyt.xyR[j1][k1] += a.xyR[i1][j1] * x1.xyR[i1][k1];
                  }
               }
            }
         }
      // Multiplication
         sparsesmm(&s, true, &x0, j, &y);
         sparsesmm(&s, false, &x1, j, &yt);
      // Check for SMM-result
         for (k1 = 0; k1 < j; k1++) {
            for (i1 = 0; i1 < i; i1++) {
               if (fabs(y.xyR[i1][k1] - ty.xyR[i1][k1]) >= eps || fabs(yt.xyR[i1][k1] - tyt.xyR[i1][k1]) >= eps) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Function for basic test SparseCopy
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool basiccopyfunctest(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t j1;
   double a0;
   double a1;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewObj(sparsematrix, ss);
   NewObj(sparsematrix, sss);
   NewVector(ner, 0, DT_INT);
   NewMatrix(a, 0, 0, DT_REAL);
   n = 30;
   m = 30;
   for (i = 1; i < m; i++) {
      for (j = 1; j < n; j++) {
         sparsecreate(i, j, 1, &s);
         ae_matrix_set_length(&a, i, j);
         ae_vector_set_length(&ner, i);
         for (i1 = 0; i1 < i; i1++) {
            if (i1 < j - 2) {
               ner.xZ[i1] = 2;
            } else {
               if (j - 3 < i1 && i1 < j - 1) {
                  ner.xZ[i1] = 1;
               } else {
                  ner.xZ[i1] = 0;
               }
            }
         }
         sparsecreatecrs(i, j, &ner, &sss);
      // Checking for Matrix with hash table type
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               if (j1 > i1 && j1 <= i1 + 2) {
                  a.xyR[i1][j1] = (double)(i1 + j1 + 1);
                  sparseset(&s, i1, j1, a.xyR[i1][j1]);
                  sparseadd(&s, i1, j1, 0.0);
                  sparseset(&sss, i1, j1, a.xyR[i1][j1]);
               } else {
                  a.xyR[i1][j1] = 0.0;
                  sparseset(&s, i1, j1, a.xyR[i1][j1]);
                  sparseadd(&s, i1, j1, 0.0);
               }
            // Check for SparseCreate
               sparsecopy(&s, &ss);
               a0 = sparseget(&s, i1, j1);
               a1 = sparseget(&ss, i1, j1);
               if (a0 != a1) {
                  if (!silent) {
                     printf("BasicCopyFuncTest::Report::SparseGet\n");
                     printf("S::[%0d,%0d]=%0.5f\n", (int)i1, (int)j1, a0);
                     printf("SS::[%0d,%0d]=%0.5f\n", (int)i1, (int)j1, a1);
                     printf("          TEST FAILED.\n");
                  }
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         }
      // Check for SparseCreateCRS
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               sparsecopy(&sss, &ss);
               a0 = sparseget(&sss, i1, j1);
               a1 = sparseget(&ss, i1, j1);
               if (a0 != a1) {
                  if (!silent) {
                     printf("BasicCopyFuncTest::Report::SparseGet\n");
                     printf("S::[%0d,%0d]=%0.5f\n", (int)i1, (int)j1, a0);
                     printf("SS::[%0d,%0d]=%0.5f\n", (int)i1, (int)j1, a1);
                     printf("          TEST FAILED.\n");
                  }
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         }
      // Check for Matrix with CRS type
         sparseconverttocrs(&s);
         sparsecopy(&s, &ss);
         for (i1 = 0; i1 < i; i1++) {
            for (j1 = 0; j1 < j; j1++) {
               a0 = sparseget(&s, i1, j1);
               a1 = sparseget(&ss, i1, j1);
               if (a0 != a1) {
                  if (!silent) {
                     printf("BasicCopyFuncTest::Report::SparseGet\n");
                     printf("S::[%0d,%0d]=%0.5f\n", (int)i1, (int)j1, a0);
                     printf("SS::[%0d,%0d]=%0.5f\n", (int)i1, (int)j1, a1);
                     printf("          TEST FAILED.\n");
                  }
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         }
      }
   }
   if (!silent) {
      printf("          TEST IS PASSED.\n");
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Function for testing SparseCopy
//
// ALGLIB Project: Copyright 14.10.2011 by Sergey Bochkanov
static bool copyfunctest(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t mtype;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i1;
   ae_int_t j1;
   double lb;
   double rb;
   double eps;
   double a0;
   double a1;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewObj(sparsematrix, ss);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(ty, 0, DT_REAL);
   NewVector(tyt, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(yt, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(yt0, 0, DT_REAL);
   NewVector(cpy, 0, DT_REAL);
   NewVector(cpyt, 0, DT_REAL);
   NewVector(cpy0, 0, DT_REAL);
   NewVector(cpyt0, 0, DT_REAL);
// Accuracy
   eps = 1000 * machineepsilon;
// Size of the matrix (m*n)
   n = 30;
   m = 30;
// Left and right borders, limiting matrix values
   lb = -10.0;
   rb = 10.0;
// Test linear algebra functions for:
// a) sparse matrix converted to CRS from Hash-Table
// b) sparse matrix initially created as CRS
   for (i = 1; i < m; i++) {
      for (j = 1; j < n; j++) {
         for (mtype = 0; mtype <= 1; mtype++) {
         // Prepare test problem
            testsparseunit_createrandom(i, j, -1, mtype, -1, -1, &a, &s);
            sparsecopy(&s, &ss);
         // Initialize temporaries
            ae_vector_set_length(&ty, i);
            ae_vector_set_length(&tyt, j);
            for (i1 = 0; i1 < i; i1++) {
               ty.xR[i1] = 0.0;
            }
            for (i1 = 0; i1 < j; i1++) {
               tyt.xR[i1] = 0.0;
            }
            ae_vector_set_length(&x0, j);
            ae_vector_set_length(&x1, i);
            for (i1 = 0; i1 < j; i1++) {
               x0.xR[i1] = (rb - lb) * randomreal() + lb;
            }
            for (i1 = 0; i1 < i; i1++) {
               x1.xR[i1] = (rb - lb) * randomreal() + lb;
            }
         // Consider two cases: square matrix, and non-square matrix
            if (i != j) {
            // Searching true result
               for (i1 = 0; i1 < i; i1++) {
                  for (j1 = 0; j1 < j; j1++) {
                     ty.xR[i1] += a.xyR[i1][j1] * x0.xR[j1];
                     tyt.xR[j1] += a.xyR[i1][j1] * x1.xR[i1];
                  }
               }
            // Multiplication
               sparsemv(&s, &x0, &y);
               sparsemtv(&s, &x1, &yt);
               sparsemv(&ss, &x0, &cpy);
               sparsemtv(&ss, &x1, &cpyt);
            // Check for MV-result
               for (i1 = 0; i1 < i; i1++) {
                  if ((fabs(y.xR[i1] - ty.xR[i1]) >= eps || fabs(cpy.xR[i1] - ty.xR[i1]) >= eps) || cpy.xR[i1] - y.xR[i1] != 0.0) {
                     if (!silent) {
                        printf("CopyFuncTest::Report::RES_MV\n");
                        printf("Y[%0d]=%0.5f; tY[%0d]=%0.5f\n", (int)i1, y.xR[i1], (int)i1, ty.xR[i1]);
                        printf("cpY[%0d]=%0.5f;\n", (int)i1, cpy.xR[i1]);
                        printf("          TEST FAILED.\n");
                     }
                     result = true;
                     ae_frame_leave();
                     return result;
                  }
               }
            // Check for MTV-result
               for (i1 = 0; i1 < j; i1++) {
                  if ((fabs(yt.xR[i1] - tyt.xR[i1]) >= eps || fabs(cpyt.xR[i1] - tyt.xR[i1]) >= eps) || cpyt.xR[i1] - yt.xR[i1] != 0.0) {
                     if (!silent) {
                        printf("CopyFuncTest::Report::RES_MTV\n");
                        printf("Yt[%0d]=%0.5f; tYt[%0d]=%0.5f\n", (int)i1, yt.xR[i1], (int)i1, tyt.xR[i1]);
                        printf("cpYt[%0d]=%0.5f;\n", (int)i1, cpyt.xR[i1]);
                        printf("          TEST FAILED.\n");
                     }
                     result = true;
                     ae_frame_leave();
                     return result;
                  }
               }
               sparsecopy(&s, &ss);
               for (i1 = 0; i1 < i; i1++) {
                  for (j1 = 0; j1 < j; j1++) {
                     a0 = sparseget(&s, i1, j1);
                     a1 = sparseget(&ss, i1, j1);
                     if (a0 != a1) {
                        if (!silent) {
                           printf("CopyFuncTest::Report::SparseGet\n");
                           printf("S::[%0d,%0d]=%0.5f\n", (int)i1, (int)j1, a0);
                           printf("SS::[%0d,%0d]=%0.5f\n", (int)i1, (int)j1, a1);
                           printf("          TEST FAILED.\n");
                        }
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  }
               }
            } else {
            // Searching true result
               for (i1 = 0; i1 < i; i1++) {
                  for (j1 = 0; j1 < j; j1++) {
                     ty.xR[i1] += a.xyR[i1][j1] * x0.xR[j1];
                     tyt.xR[j1] += a.xyR[i1][j1] * x0.xR[i1];
                  }
               }
            // Multiplication
               sparsemv(&s, &x0, &y);
               sparsemtv(&s, &x0, &yt);
               sparsemv2(&s, &x0, &y0, &yt0);
               sparsemv(&ss, &x0, &cpy);
               sparsemtv(&ss, &x0, &cpyt);
               sparsemv2(&ss, &x0, &cpy0, &cpyt0);
            // Check for MV2-result
               for (i1 = 0; i1 < i; i1++) {
                  if (((((fabs(y0.xR[i1] - ty.xR[i1]) >= eps || fabs(yt0.xR[i1] - tyt.xR[i1]) >= eps) || fabs(cpy0.xR[i1] - ty.xR[i1]) >= eps) || fabs(cpyt0.xR[i1] - tyt.xR[i1]) >= eps) || cpy0.xR[i1] - y0.xR[i1] != 0.0) || cpyt0.xR[i1] - yt0.xR[i1] != 0.0) {
                     if (!silent) {
                        printf("CopyFuncTest::Report::RES_MV2\n");
                        printf("Y0[%0d]=%0.5f; tY[%0d]=%0.5f\n", (int)i1, y0.xR[i1], (int)i1, ty.xR[i1]);
                        printf("Yt0[%0d]=%0.5f; tYt[%0d]=%0.5f\n", (int)i1, yt0.xR[i1], (int)i1, tyt.xR[i1]);
                        printf("cpY0[%0d]=%0.5f;\n", (int)i1, cpy0.xR[i1]);
                        printf("cpYt0[%0d]=%0.5f;\n", (int)i1, cpyt0.xR[i1]);
                        printf("          TEST FAILED.\n");
                     }
                     result = true;
                     ae_frame_leave();
                     return result;
                  }
               }
            // Check for MV- and MTV-result by help MV2
               for (i1 = 0; i1 < i; i1++) {
                  if (((fabs(y0.xR[i1] - y.xR[i1]) > eps || fabs(yt0.xR[i1] - yt.xR[i1]) > eps) || fabs(cpy0.xR[i1] - cpy.xR[i1]) > eps) || fabs(cpyt0.xR[i1] - cpyt.xR[i1]) > eps) {
                     if (!silent) {
                        printf("CopyFuncTest::Report::RES_MV_MVT\n");
                        printf("Y0[%0d]=%0.5f; Y[%0d]=%0.5f\n", (int)i1, y0.xR[i1], (int)i1, y.xR[i1]);
                        printf("Yt0[%0d]=%0.5f; Yt[%0d]=%0.5f\n", (int)i1, yt0.xR[i1], (int)i1, yt.xR[i1]);
                        printf("cpY0[%0d]=%0.5f; cpY[%0d]=%0.5f\n", (int)i1, cpy0.xR[i1], (int)i1, cpy.xR[i1]);
                        printf("cpYt0[%0d]=%0.5f; cpYt[%0d]=%0.5f\n", (int)i1, cpyt0.xR[i1], (int)i1, cpyt.xR[i1]);
                        printf("          TEST FAILED.\n");
                     }
                     result = true;
                     ae_frame_leave();
                     return result;
                  }
               }
               sparsecopy(&s, &ss);
               for (i1 = 0; i1 < i; i1++) {
                  for (j1 = 0; j1 < j; j1++) {
                     a0 = sparseget(&s, i1, j1);
                     a1 = sparseget(&ss, i1, j1);
                     if (a0 != a1) {
                        if (!silent) {
                           printf("CopyFuncTest::Report::SparseGet\n");
                           printf("S::[%0d,%0d]=%0.5f\n", (int)i1, (int)j1, a0);
                           printf("SS::[%0d,%0d]=%0.5f\n", (int)i1, (int)j1, a1);
                           printf("          TEST FAILED.\n");
                        }
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  }
               }
            }
         }
      }
   }
   if (!silent) {
      printf("          TEST IS PASSED.\n");
   }
   result = false;
   ae_frame_leave();
   return result;
}

// This function does test for SparseEnumerate function.
//
// ALGLIB Project: Copyright 14.03.2012 by Sergey Bochkanov
static bool testsparseunit_enumeratetest() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   double r;
   double v;
   ae_int_t ne;
   ae_int_t t0;
   ae_int_t t1;
   ae_int_t counter;
   ae_int_t c;
   ae_int_t hashcrs;
   ae_int_t i;
   ae_int_t j;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, spa);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ta, 0, 0, DT_BOOL);
   r = 10.5;
   for (m = 1; m <= 30; m++) {
      for (n = 1; n <= 30; n++) {
         ne = 0;
      // Create matrix with non-zero elements inside the region:
      // 0 <= I<S.M and 0 <= J<S.N
         ae_matrix_set_length(&a, m, n);
         ae_matrix_set_length(&ta, m, n);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
               ta.xyB[i][j] = false;
            }
         }
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               c = randominteger(2);
               if (c == 0) {
                  a.xyR[i][j] = 0.0;
               } else {
                  do {
                     a.xyR[i][j] = r * randommid();
                  } while (a.xyR[i][j] == 0.0);
               // Number of non-zero elements
                  ne++;
               }
            }
         }
         for (hashcrs = 0; hashcrs <= 1; hashcrs++) {
            sparsecreate(m, n, m * n, &spa);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  sparseset(&spa, i, j, a.xyR[i][j]);
               }
            }
            if (hashcrs == 1) {
               sparseconverttocrs(&spa);
            }
            t0 = 0;
            t1 = 0;
            counter = 0;
            while (sparseenumerate(&spa, &t0, &t1, &i, &j, &v)) {
               ta.xyB[i][j] = true;
               counter++;
               if (v != a.xyR[i][j]) {
                  set_error_flag(&result, true, __FILE__, __LINE__, "testsparseunit.ap:3112");
                  ae_frame_leave();
                  return result;
               }
            }
         // Check that all non-zero elements was enumerated
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  if (ta.xyB[i][j] && a.xyR[i][j] == 0.0) {
                     set_error_flag(&result, true, __FILE__, __LINE__, "testsparseunit.ap:3124");
                     ae_frame_leave();
                     return result;
                  }
               }
            }
            if (ne != counter) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testsparseunit.ap:3130");
               ae_frame_leave();
               return result;
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// This function does test for SparseRewriteExisting function.
//
// ALGLIB Project: Copyright 14.03.2012 by Sergey Bochkanov
static bool testsparseunit_rewriteexistingtest() {
   ae_frame _frame_block;
   double spaval;
   ae_int_t m;
   ae_int_t n;
   ae_int_t c;
   ae_int_t ne;
   ae_int_t nr;
   double r;
   double v;
   ae_int_t hashcrs;
   ae_int_t i;
   ae_int_t j;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, spa);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ta, 0, 0, DT_BOOL);
   r = 20.0;
   for (m = 1; m <= 30; m++) {
      for (n = 1; n <= 30; n++) {
         ae_matrix_set_length(&a, m, n);
         ae_matrix_set_length(&ta, m, n);
         for (hashcrs = 0; hashcrs <= 1; hashcrs++) {
            v = r * randommid();
         // Creating and filling of the matrix
            ne = 0;
            sparsecreate(m, n, m * n, &spa);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  c = randominteger(2);
                  if (c == 0) {
                     a.xyR[i][j] = 0.0;
                  }
                  if (c == 1) {
                     do {
                        a.xyR[i][j] = r * randommid();
                     } while (a.xyR[i][j] == 0.0);
                     sparseset(&spa, i, j, a.xyR[i][j]);
                     ne++;
                  }
                  ta.xyB[i][j] = false;
               }
            }
            if (hashcrs == 1) {
               sparseconverttocrs(&spa);
            }
         // Rewrite some elements
            nr = 0;
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  c = randominteger(2);
                  if (c == 1) {
                     ta.xyB[i][j] = sparserewriteexisting(&spa, i, j, v);
                     if (ta.xyB[i][j]) {
                        a.xyR[i][j] = v;
                        nr++;
                     }
                  }
               }
            }
         // Now we have to be sure, that all changes had made correctly
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  if (ta.xyB[i][j]) {
                     spaval = sparseget(&spa, i, j);
                     nr--;
                     if (spaval != v || spaval != a.xyR[i][j]) {
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  }
               }
            }
            if (nr != 0) {
               result = true;
               ae_frame_leave();
               return result;
            }
         // Rewrite all elements
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  ta.xyB[i][j] = sparserewriteexisting(&spa, i, j, v);
                  if (ta.xyB[i][j]) {
                     a.xyR[i][j] = v;
                  }
               }
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  if (ta.xyB[i][j]) {
                     ne--;
                  }
               }
            }
            if (ne != 0) {
               result = true;
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  spaval = sparseget(&spa, i, j);
                  if (ta.xyB[i][j]) {
                     if (spaval != v || spaval != a.xyR[i][j]) {
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  } else {
                     if (spaval != 0.0 || spaval != a.xyR[i][j]) {
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  }
               }
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Test  for  SparseGetRow/GetCompressedRow  function.   It  creates  random
// dense and sparse matrices;  then  get every  row from  sparse matrix  and
// compares it with every row in dense matrix.
//
// On failure sets error flag, on success leaves it unchanged.
//
// ALGLIB Project: Copyright 23.07.2012 by Sergey Bochkanov
static void testsparseunit_testgetrow(bool *err) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t msize;
   ae_int_t nsize;
   ae_int_t nz;
   ae_int_t mtype;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(vals, 0, DT_REAL);
   NewVector(mrow, 0, DT_REAL);
   NewVector(colidx, 0, DT_INT);
   NewVector(wasreturned, 0, DT_BOOL);
   msize = 15;
   nsize = 15;
   for (mtype = 1; mtype <= 2; mtype++) {
      for (m = 1; m <= msize; m++) {
         for (n = 1; n <= nsize; n++) {
         // Skip nonrectangular SKS matrices - not supported
            if (mtype == 2 && m != n) {
               continue;
            }
         // Create "reference" and sparse matrices
            ae_matrix_set_length(&a, m, n);
            sparsecreate(m, n, 1, &s);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  if (randominteger(5) == 3) {
                     a.xyR[i][j] = randommid();
                     sparseset(&s, i, j, a.xyR[i][j]);
                  } else {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
         // Choose matrix type to test
            if (mtype == 1) {
               sparseconverttocrs(&s);
            } else {
               sparseconverttosks(&s);
            }
         // Test SparseGetRow()
            for (i = 0; i < m; i++) {
               sparsegetrow(&s, i, &mrow);
               for (j = 0; j < n; j++) {
                  if (mrow.xR[j] != a.xyR[i][j] || mrow.xR[j] != sparseget(&s, i, j)) {
                     set_error_flag(err, true, __FILE__, __LINE__, "testsparseunit.ap:3355");
                     ae_frame_leave();
                     return;
                  }
               }
            }
         // Test SparseGetCompressedRow()
            ae_vector_set_length(&wasreturned, n);
            for (i = 0; i < m; i++) {
               sparsegetcompressedrow(&s, i, &colidx, &vals, &nz);
               if (nz < 0 || nz > n) {
                  set_error_flag(err, true, __FILE__, __LINE__, "testsparseunit.ap:3369");
                  ae_frame_leave();
                  return;
               }
               for (j = 0; j < n; j++) {
                  wasreturned.xB[j] = false;
               }
               for (j = 0; j < nz; j++) {
                  if (colidx.xZ[j] < 0 || colidx.xZ[j] > n) {
                     set_error_flag(err, true, __FILE__, __LINE__, "testsparseunit.ap:3378");
                     ae_frame_leave();
                     return;
                  }
                  set_error_flag(err, j > 0 && colidx.xZ[j] <= colidx.xZ[j - 1], __FILE__, __LINE__, "testsparseunit.ap:3381");
                  set_error_flag(err, vals.xR[j] != a.xyR[i][colidx.xZ[j]] || vals.xR[j] != sparseget(&s, i, colidx.xZ[j]), __FILE__, __LINE__, "testsparseunit.ap:3382");
                  wasreturned.xB[colidx.xZ[j]] = true;
               }
               for (j = 0; j < n; j++) {
                  set_error_flag(err, a.xyR[i][j] != 0.0 && !wasreturned.xB[j], __FILE__, __LINE__, "testsparseunit.ap:3386");
               }
            }
         }
      }
   }
   ae_frame_leave();
}

// Test for SparseConvert functions(isn't tested ConvertToCRS function). The
// function  create random  dense and sparse  matrices  in CRS  format. Then
// convert  sparse matrix  to some  format  by CONVERT_TO/COPY_TO  functions,
// then it does  some modification in matrices and compares that marices are
// identical.
//
// NOTE:
//     Result of the function assigned to variable CopyErrors in unit test.
//
// ALGLIB Project: Copyright 23.07.2012 by Sergey Bochkanov
static bool testsparseunit_testconvertsm() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t msize;
   ae_int_t nsize;
   double tmp;
   ae_int_t i;
   ae_int_t j;
   ae_int_t vartf;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewObj(sparsematrix, cs);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(ner, 0, DT_INT);
   msize = 15;
   nsize = 15;
   for (m = 1; m <= msize; m++) {
      for (n = 1; n <= nsize; n++) {
         for (vartf = 0; vartf <= 2; vartf++) {
            ae_matrix_set_length(&a, m, n);
            ae_vector_set_length(&ner, m);
            for (i = 0; i < m; i++) {
               ner.xZ[i] = 0;
               for (j = 0; j < n; j++) {
                  if (randominteger(5) == 3) {
                     ner.xZ[i]++;
                     do {
                        a.xyR[i][j] = randommid();
                     } while (a.xyR[i][j] == 0.0);
                  } else {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
         // Create sparse matrix
            sparsecreatecrs(m, n, &ner, &s);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  if (a.xyR[i][j] != 0.0) {
                     a.xyR[i][j] = randommid();
                     sparseset(&s, i, j, a.xyR[i][j]);
                  }
               }
            }
         // Set matrix type(we have to be sure that all formats
         // converted correctly)
            i = randominteger(2);
            if (i == 0) {
               sparseconverttohash(&s);
            }
            if (i == 1) {
               sparseconverttocrs(&s);
            }
         // Start test
            if (vartf == 0) {
               sparseconverttohash(&s);
               sparsecopy(&s, &cs);
            }
            if (vartf == 1) {
               sparsecopytohash(&s, &cs);
            }
            if (vartf == 2) {
               sparsecopytocrs(&s, &cs);
            }
         // Change some elements in row
            if (vartf != 2) {
               for (i = 0; i < m; i++) {
                  tmp = randommid();
                  j = randominteger(n);
                  a.xyR[i][j] = tmp;
                  sparseset(&cs, i, j, tmp);
                  tmp = randommid();
                  j = randominteger(n);
                  a.xyR[i][j] += tmp;
                  sparseadd(&cs, i, j, tmp);
               }
            }
         // Check that A is identical to S
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  if (a.xyR[i][j] != sparseget(&cs, i, j)) {
                     result = true;
                     ae_frame_leave();
                     return result;
                  }
               }
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Test for  check/get  type functions.  The function  create sparse matrix,
// converts it to desired type then check this type.
//
// NOTE:
//     Result of the function assigned to variable BasicErrors in unit test.
//
// ALGLIB Project: Copyright 23.07.2012 by Sergey Bochkanov
static bool testsparseunit_testgcmatrixtype() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t msize;
   ae_int_t nsize;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, s);
   NewObj(sparsematrix, cs);
   msize = 5;
   nsize = 5;
   for (m = 1; m <= msize; m++) {
      for (n = 1; n <= nsize; n++) {
         sparsecreate(m, n, 1, &s);
         sparseconverttocrs(&s);
         if ((sparseishash(&s) || !sparseiscrs(&s)) || sparsegetmatrixtype(&s) != 1) {
            result = true;
            ae_frame_leave();
            return result;
         }
         sparseconverttohash(&s);
         if ((!sparseishash(&s) || sparseiscrs(&s)) || sparsegetmatrixtype(&s) != 0) {
            result = true;
            ae_frame_leave();
            return result;
         }
         sparsecopytocrs(&s, &cs);
         if ((sparseishash(&cs) || !sparseiscrs(&cs)) || sparsegetmatrixtype(&cs) != 1) {
            result = true;
            ae_frame_leave();
            return result;
         }
         sparsecopytohash(&cs, &s);
         if ((!sparseishash(&s) || sparseiscrs(&s)) || sparsegetmatrixtype(&s) != 0) {
            result = true;
            ae_frame_leave();
            return result;
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

bool testsparse(bool silent) {
   bool waserrors;
   bool basicerrors;
   bool linearerrors;
   bool basicrnderrors;
   bool level2unsymmetricerrors;
   bool level2symmetricerrors;
   bool level2triangularerrors;
   bool level3unsymmetricerrors;
   bool level3symmetricerrors;
   bool symmetricpermerrors;
   bool linearserrors;
   bool linearmmerrors;
   bool linearsmmerrors;
   bool getrowerrors;
   bool serializeerrors;
   bool copyerrors;
   bool basiccopyerrors;
   bool enumerateerrors;
   bool rewriteexistingerr;
   bool skserrors;
   bool crserrors;
   bool result;
   getrowerrors = false;
   crserrors = false;
   serializeerrors = false;
   skserrors = skstest();
   crstest(&crserrors);
   basicerrors = basicfunctest() || testsparseunit_testgcmatrixtype();
   basicrnderrors = basicfuncrandomtest();
   linearerrors = linearfunctionstest();
   level2unsymmetricerrors = testlevel2unsymmetric();
   level2symmetricerrors = testlevel2symmetric();
   level2triangularerrors = testlevel2triangular();
   level3unsymmetricerrors = testlevel3unsymmetric();
   level3symmetricerrors = testlevel3symmetric();
   symmetricpermerrors = testsymmetricperm();
   linearserrors = linearfunctionsstest();
   linearmmerrors = linearfunctionsmmtest();
   linearsmmerrors = linearfunctionssmmtest();
   copyerrors = copyfunctest(true) || testsparseunit_testconvertsm();
   basiccopyerrors = basiccopyfunctest(true);
   enumerateerrors = testsparseunit_enumeratetest();
   rewriteexistingerr = testsparseunit_rewriteexistingtest();
   testsparseunit_testgetrow(&getrowerrors);
   testserialize(&serializeerrors);
// report
   waserrors = ((((((((((((((((((skserrors || crserrors) || getrowerrors) || serializeerrors) || basicerrors) || linearerrors) || basicrnderrors) || level2unsymmetricerrors) || level2symmetricerrors) || level2triangularerrors) || level3unsymmetricerrors) || level3symmetricerrors) || symmetricpermerrors) || linearserrors) || linearmmerrors) || linearsmmerrors) || copyerrors) || basiccopyerrors) || enumerateerrors) || rewriteexistingerr;
   if (!silent) {
      printf("TESTING SPARSE\n");
      printf("STORAGE FORMAT SPECIFICS:\n");
      printf("* SKS:                                   ");
      if (!skserrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* CRS:                                   ");
      if (!crserrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("OPERATIONS:\n");
      printf("* GETROW:                                ");
      if (!getrowerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* SERIALIZE:                             ");
      if (!serializeerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("BLAS:\n");
      printf("* LEVEL 2 GENERAL:                       ");
      if (!level2unsymmetricerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* LEVEL 2 SYMMETRIC:                     ");
      if (!level2symmetricerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* LEVEL 2 TRIANGULAR:                    ");
      if (!level2triangularerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* LEVEL 3 GENERAL:                       ");
      if (!level3unsymmetricerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* LEVEL 3 SYMMETRIC:                     ");
      if (!level3symmetricerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* PERMUTATIONS (SYMMETRIC):              ");
      if (!symmetricpermerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("BASIC TEST:                              ");
      if (!basicerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("COPY TEST:                               ");
      if (!copyerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("BASIC_COPY TEST:                         ");
      if (!basiccopyerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("BASIC_RND TEST:                          ");
      if (!basicrnderrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("LINEAR TEST:                             ");
      if (!linearerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("LINEAR TEST FOR SYMMETRIC MATRICES:      ");
      if (!linearserrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("LINEAR MxM TEST:                         ");
      if (!linearmmerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("LINEAR MxM TEST FOR SYMMETRIC MATRICES:  ");
      if (!linearsmmerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("ENUMERATE TEST:                          ");
      if (!enumerateerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("REWRITE EXISTING TEST:                   ");
      if (!rewriteexistingerr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === blas testing unit ===
static void testblasunit_naivematrixmatrixmultiply(RMatrix *a, ae_int_t ai1, ae_int_t ai2, ae_int_t aj1, ae_int_t aj2, bool transa, RMatrix *b, ae_int_t bi1, ae_int_t bi2, ae_int_t bj1, ae_int_t bj2, bool transb, double alpha, RMatrix *c, ae_int_t ci1, ae_int_t ci2, ae_int_t cj1, ae_int_t cj2, double beta) {
   ae_frame _frame_block;
   ae_int_t arows;
   ae_int_t acols;
   ae_int_t brows;
   ae_int_t bcols;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   ae_int_t r;
   double v;
   ae_frame_make(&_frame_block);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
// Setup
   if (!transa) {
      arows = ai2 - ai1 + 1;
      acols = aj2 - aj1 + 1;
   } else {
      arows = aj2 - aj1 + 1;
      acols = ai2 - ai1 + 1;
   }
   if (!transb) {
      brows = bi2 - bi1 + 1;
      bcols = bj2 - bj1 + 1;
   } else {
      brows = bj2 - bj1 + 1;
      bcols = bi2 - bi1 + 1;
   }
   ae_assert(acols == brows, "NaiveMatrixMatrixMultiply: incorrect matrix sizes!");
   if (((arows <= 0 || acols <= 0) || brows <= 0) || bcols <= 0) {
      ae_frame_leave();
      return;
   }
   l = arows;
   r = bcols;
   k = acols;
   ae_vector_set_length(&x1, k + 1);
   ae_vector_set_length(&x2, k + 1);
   for (i = 1; i <= l; i++) {
      for (j = 1; j <= r; j++) {
         if (!transa) {
            if (!transb) {
               v = ae_v_dotproduct(&b->xyR[bi1][bj1 + j - 1], b->stride, &a->xyR[ai1 + i - 1][aj1], 1, bi2 - bi1 + 1);
            } else {
               v = ae_v_dotproduct(&b->xyR[bi1 + j - 1][bj1], 1, &a->xyR[ai1 + i - 1][aj1], 1, bj2 - bj1 + 1);
            }
         } else {
            if (!transb) {
               v = ae_v_dotproduct(&b->xyR[bi1][bj1 + j - 1], b->stride, &a->xyR[ai1][aj1 + i - 1], a->stride, bi2 - bi1 + 1);
            } else {
               v = ae_v_dotproduct(&b->xyR[bi1 + j - 1][bj1], 1, &a->xyR[ai1][aj1 + i - 1], a->stride, bj2 - bj1 + 1);
            }
         }
         if (beta == 0.0) {
            c->xyR[ci1 + i - 1][cj1 + j - 1] = alpha * v;
         } else {
            c->xyR[ci1 + i - 1][cj1 + j - 1] = beta * c->xyR[ci1 + i - 1][cj1 + j - 1] + alpha * v;
         }
      }
   }
   ae_frame_leave();
}

bool testblas(bool silent) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t i;
   ae_int_t i1;
   ae_int_t i2;
   ae_int_t j;
   ae_int_t j1;
   ae_int_t j2;
   ae_int_t l;
   ae_int_t k;
   ae_int_t r;
   ae_int_t i3;
   ae_int_t j3;
   ae_int_t col1;
   ae_int_t col2;
   ae_int_t row1;
   ae_int_t row2;
   double err;
   double e1;
   double e2;
   double e3;
   double v;
   double scl1;
   double scl2;
   double scl3;
   bool was1;
   bool was2;
   bool trans1;
   bool trans2;
   double threshold;
   bool n2errors;
   bool hsnerrors;
   bool amaxerrors;
   bool mverrors;
   bool iterrors;
   bool cterrors;
   bool mmerrors;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewMatrix(c1, 0, 0, DT_REAL);
   NewMatrix(c2, 0, 0, DT_REAL);
   n2errors = false;
   amaxerrors = false;
   hsnerrors = false;
   mverrors = false;
   iterrors = false;
   cterrors = false;
   mmerrors = false;
   waserrors = false;
   threshold = 10000 * machineepsilon;
// Test Norm2
   passcount = 1000;
   e1 = 0.0;
   e2 = 0.0;
   e3 = 0.0;
   scl2 = 0.5 * maxrealnumber;
   scl3 = 2 * minrealnumber;
   for (pass = 1; pass <= passcount; pass++) {
      n = 1 + randominteger(1000);
      i1 = randominteger(10);
      i2 = n + i1 - 1;
      ae_vector_set_length(&x1, i2 + 1);
      ae_vector_set_length(&x2, i2 + 1);
      for (i = i1; i <= i2; i++) {
         x1.xR[i] = randommid();
      }
      v = 0.0;
      for (i = i1; i <= i2; i++) {
         v += sqr(x1.xR[i]);
      }
      v = sqrt(v);
      e1 = rmax2(e1, fabs(v - vectornorm2(&x1, i1, i2)));
      for (i = i1; i <= i2; i++) {
         x2.xR[i] = scl2 * x1.xR[i];
      }
      e2 = rmax2(e2, fabs(v * scl2 - vectornorm2(&x2, i1, i2)));
      for (i = i1; i <= i2; i++) {
         x2.xR[i] = scl3 * x1.xR[i];
      }
      e3 = rmax2(e3, fabs(v * scl3 - vectornorm2(&x2, i1, i2)));
   }
   e2 /= scl2;
   e3 /= scl3;
   n2errors = (e1 >= threshold || e2 >= threshold) || e3 >= threshold;
// Testing VectorAbsMax, Column/Row AbsMax
   ae_vector_set_length(&x1, 5 + 1);
   x1.xR[1] = 2.0;
   x1.xR[2] = 0.2;
   x1.xR[3] = -1.3;
   x1.xR[4] = 0.7;
   x1.xR[5] = -3.0;
   amaxerrors = (vectoridxabsmax(&x1, 1, 5) != 5 || vectoridxabsmax(&x1, 1, 4) != 1) || vectoridxabsmax(&x1, 2, 4) != 3;
   n = 30;
   ae_vector_set_length(&x1, n + 1);
   ae_matrix_set_length(&a, n + 1, n + 1);
   for (i = 1; i <= n; i++) {
      for (j = 1; j <= n; j++) {
         a.xyR[i][j] = randommid();
      }
   }
   was1 = false;
   was2 = false;
   for (pass = 1; pass <= 1000; pass++) {
      j = 1 + randominteger(n);
      i1 = 1 + randominteger(n);
      i2 = i1 + randominteger(n + 1 - i1);
      ae_v_move(&x1.xR[i1], 1, &a.xyR[i1][j], a.stride, i2 - i1 + 1);
      if (vectoridxabsmax(&x1, i1, i2) != columnidxabsmax(&a, i1, i2, j)) {
         was1 = true;
      }
      i = 1 + randominteger(n);
      j1 = 1 + randominteger(n);
      j2 = j1 + randominteger(n + 1 - j1);
      ae_v_move(&x1.xR[j1], 1, &a.xyR[i][j1], 1, j2 - j1 + 1);
      if (vectoridxabsmax(&x1, j1, j2) != rowidxabsmax(&a, j1, j2, i)) {
         was2 = true;
      }
   }
   amaxerrors = (amaxerrors || was1) || was2;
// Testing upper Hessenberg 1-norm
   ae_matrix_set_length(&a, 3 + 1, 3 + 1);
   ae_vector_set_length(&x1, 3 + 1);
   a.xyR[1][1] = 2.0;
   a.xyR[1][2] = 3.0;
   a.xyR[1][3] = 1.0;
   a.xyR[2][1] = 4.0;
   a.xyR[2][2] = -5.0;
   a.xyR[2][3] = 8.0;
   a.xyR[3][1] = 99.0;
   a.xyR[3][2] = 3.0;
   a.xyR[3][3] = 1.0;
   hsnerrors = fabs(upperhessenberg1norm(&a, 1, 3, 1, 3, &x1) - 11) > threshold;
// Testing MatrixVectorMultiply
   ae_matrix_set_length(&a, 3 + 1, 5 + 1);
   ae_vector_set_length(&x1, 3 + 1);
   ae_vector_set_length(&x2, 2 + 1);
   a.xyR[2][3] = 2.0;
   a.xyR[2][4] = -1.0;
   a.xyR[2][5] = -1.0;
   a.xyR[3][3] = 1.0;
   a.xyR[3][4] = -2.0;
   a.xyR[3][5] = 2.0;
   x1.xR[1] = 1.0;
   x1.xR[2] = 2.0;
   x1.xR[3] = 1.0;
   x2.xR[1] = -1.0;
   x2.xR[2] = -1.0;
   matrixvectormultiply(&a, 2, 3, 3, 5, false, &x1, 1, 3, 1.0, &x2, 1, 2, 1.0);
   matrixvectormultiply(&a, 2, 3, 3, 5, true, &x2, 1, 2, 1.0, &x1, 1, 3, 1.0);
   e1 = fabs(x1.xR[1] + 5) + fabs(x1.xR[2] - 8) + fabs(x1.xR[3] + 1) + fabs(x2.xR[1] + 2) + fabs(x2.xR[2] + 2);
   x1.xR[1] = 1.0;
   x1.xR[2] = 2.0;
   x1.xR[3] = 1.0;
   x2.xR[1] = -1.0;
   x2.xR[2] = -1.0;
   matrixvectormultiply(&a, 2, 3, 3, 5, false, &x1, 1, 3, 1.0, &x2, 1, 2, 0.0);
   matrixvectormultiply(&a, 2, 3, 3, 5, true, &x2, 1, 2, 1.0, &x1, 1, 3, 0.0);
   e2 = fabs(x1.xR[1] + 3) + fabs(x1.xR[2] - 3) + fabs(x1.xR[3] + 1) + fabs(x2.xR[1] + 1) + fabs(x2.xR[2] + 1);
   mverrors = e1 + e2 >= threshold;
// testing inplace transpose
   n = 10;
   ae_matrix_set_length(&a, n + 1, n + 1);
   ae_matrix_set_length(&b, n + 1, n + 1);
   ae_vector_set_length(&x1, n - 1 + 1);
   for (i = 1; i <= n; i++) {
      for (j = 1; j <= n; j++) {
         a.xyR[i][j] = randomreal();
      }
   }
   passcount = 10000;
   was1 = false;
   for (pass = 1; pass <= passcount; pass++) {
      i1 = 1 + randominteger(n);
      i2 = i1 + randominteger(n - i1 + 1);
      j1 = 1 + randominteger(n - (i2 - i1));
      j2 = j1 + (i2 - i1);
      copymatrix(&a, i1, i2, j1, j2, &b, i1, i2, j1, j2);
      inplacetranspose(&b, i1, i2, j1, j2, &x1);
      for (i = i1; i <= i2; i++) {
         for (j = j1; j <= j2; j++) {
            if (a.xyR[i][j] != b.xyR[i1 + (j - j1)][j1 + (i - i1)]) {
               was1 = true;
            }
         }
      }
   }
   iterrors = was1;
// testing copy and transpose
   n = 10;
   ae_matrix_set_length(&a, n + 1, n + 1);
   ae_matrix_set_length(&b, n + 1, n + 1);
   for (i = 1; i <= n; i++) {
      for (j = 1; j <= n; j++) {
         a.xyR[i][j] = randomreal();
      }
   }
   passcount = 10000;
   was1 = false;
   for (pass = 1; pass <= passcount; pass++) {
      i1 = 1 + randominteger(n);
      i2 = i1 + randominteger(n - i1 + 1);
      j1 = 1 + randominteger(n);
      j2 = j1 + randominteger(n - j1 + 1);
      copyandtranspose(&a, i1, i2, j1, j2, &b, j1, j2, i1, i2);
      for (i = i1; i <= i2; i++) {
         for (j = j1; j <= j2; j++) {
            if (a.xyR[i][j] != b.xyR[j][i]) {
               was1 = true;
            }
         }
      }
   }
   cterrors = was1;
// Testing MatrixMatrixMultiply
   n = 10;
   ae_matrix_set_length(&a, 2 * n + 1, 2 * n + 1);
   ae_matrix_set_length(&b, 2 * n + 1, 2 * n + 1);
   ae_matrix_set_length(&c1, 2 * n + 1, 2 * n + 1);
   ae_matrix_set_length(&c2, 2 * n + 1, 2 * n + 1);
   ae_vector_set_length(&x1, n + 1);
   ae_vector_set_length(&x2, n + 1);
   for (i = 1; i <= 2 * n; i++) {
      for (j = 1; j <= 2 * n; j++) {
         a.xyR[i][j] = randomreal();
         b.xyR[i][j] = randomreal();
      }
   }
   passcount = 1000;
   was1 = false;
   for (pass = 1; pass <= passcount; pass++) {
      for (i = 1; i <= 2 * n; i++) {
         for (j = 1; j <= 2 * n; j++) {
            c1.xyR[i][j] = 2.1 * i + 3.1 * j;
            c2.xyR[i][j] = c1.xyR[i][j];
         }
      }
      l = 1 + randominteger(n);
      k = 1 + randominteger(n);
      r = 1 + randominteger(n);
      i1 = 1 + randominteger(n);
      j1 = 1 + randominteger(n);
      i2 = 1 + randominteger(n);
      j2 = 1 + randominteger(n);
      i3 = 1 + randominteger(n);
      j3 = 1 + randominteger(n);
      trans1 = randombool();
      trans2 = randombool();
      if (trans1) {
         col1 = l;
         row1 = k;
      } else {
         col1 = k;
         row1 = l;
      }
      if (trans2) {
         col2 = k;
         row2 = r;
      } else {
         col2 = r;
         row2 = k;
      }
      scl1 = randomreal();
      scl2 = randomreal();
      matrixmatrixmultiply(&a, i1, i1 + row1 - 1, j1, j1 + col1 - 1, trans1, &b, i2, i2 + row2 - 1, j2, j2 + col2 - 1, trans2, scl1, &c1, i3, i3 + l - 1, j3, j3 + r - 1, scl2, &x1);
      testblasunit_naivematrixmatrixmultiply(&a, i1, i1 + row1 - 1, j1, j1 + col1 - 1, trans1, &b, i2, i2 + row2 - 1, j2, j2 + col2 - 1, trans2, scl1, &c2, i3, i3 + l - 1, j3, j3 + r - 1, scl2);
      err = 0.0;
      for (i = 1; i <= l; i++) {
         for (j = 1; j <= r; j++) {
            err = rmax2(err, fabs(c1.xyR[i3 + i - 1][j3 + j - 1] - c2.xyR[i3 + i - 1][j3 + j - 1]));
         }
      }
      if (err > threshold) {
         was1 = true;
         break;
      }
   }
   mmerrors = was1;
// report
   waserrors = (((((n2errors || amaxerrors) || hsnerrors) || mverrors) || iterrors) || cterrors) || mmerrors;
   if (!silent) {
      printf("TESTING BLAS\n");
      printf("VectorNorm2:                             ");
      if (n2errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("AbsMax (vector/row/column):              ");
      if (amaxerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("UpperHessenberg1Norm:                    ");
      if (hsnerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("MatrixVectorMultiply:                    ");
      if (mverrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("InplaceTranspose:                        ");
      if (iterrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("CopyAndTranspose:                        ");
      if (cterrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("MatrixMatrixMultiply:                    ");
      if (mmerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === evd testing unit ===
// Sparse fill
//
// Sparsity - sparsity level, in [0,1] (0=dense matrix).
// DiagMAg - magnitude of dense diagonal entries; zero value means that diagonal
// is sparse too, non-zero value means that diagonal is dense
static void testevdunit_rmatrixfillsparsea(RMatrix *a, ae_int_t m, ae_int_t n, double sparsity, double diagmag) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         if (randombool(sparsity)) {
            a->xyR[i][j] = 0.0;
         } else {
            a->xyR[i][j] = randommid();
         }
      }
   }
   if (diagmag > 0.0) {
      for (i = 0; i < imin2(m, n); i++) {
         a->xyR[i][i] = diagmag * randommid();
      }
   }
}

// Sparse fill
//
// Sparsity - sparsity level, in [0,1] (0=dense matrix).
// DiagMAg - magnitude of dense diagonal entries; zero value means that diagonal
// is sparse too, non-zero value means that diagonal is dense
static void testevdunit_cmatrixfillsparsea(CMatrix *a, ae_int_t m, ae_int_t n, double sparsity, double diagmag) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         if (randombool(sparsity)) {
            a->xyC[i][j] = complex_from_i(0);
         } else {
            a->xyC[i][j] = complex_from_d(randommid(), randommid());
         }
      }
   }
   if (diagmag > 0.0) {
      for (i = 0; i < imin2(m, n); i++) {
         a->xyC[i][i] = complex_from_d(diagmag * randommid(), diagmag * randommid());
      }
   }
}

// Copies A to AL (lower half) and AU (upper half), filling unused parts by
// random garbage.
static void testevdunit_rmatrixsymmetricsplit(RMatrix *a, ae_int_t n, RMatrix *al, RMatrix *au) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = i + 1; j < n; j++) {
         al->xyR[i][j] = randommid();
         al->xyR[j][i] = a->xyR[i][j];
         au->xyR[i][j] = a->xyR[i][j];
         au->xyR[j][i] = randommid();
      }
      al->xyR[i][i] = a->xyR[i][i];
      au->xyR[i][i] = a->xyR[i][i];
   }
}

// Copies A to AL (lower half) and AU (upper half), filling unused parts by
// random garbage.
static void testevdunit_cmatrixhermitiansplit(CMatrix *a, ae_int_t n, CMatrix *al, CMatrix *au) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = i + 1; j < n; j++) {
         al->xyC[i][j] = complex_from_d(randommid());
         al->xyC[j][i] = conj(a->xyC[i][j]);
         au->xyC[i][j] = a->xyC[i][j];
         au->xyC[j][i] = complex_from_d(randommid());
      }
      al->xyC[i][i] = a->xyC[i][i];
      au->xyC[i][i] = a->xyC[i][i];
   }
}

// Unsets 2D array.
static void testevdunit_unset2d(RMatrix *a) {
   SetMatrix(a);
   if (a->rows * a->cols > 0) {
      ae_matrix_set_length(a, 1, 1);
   }
}

// Unsets 2D array.
static void testevdunit_cunset2d(CMatrix *a) {
   ae_matrix_set_length(a, 0 + 1, 0 + 1);
   a->xyC[0][0] = complex_from_d(randommid());
}

// Unsets 1D array.
static void testevdunit_unset1d(RVector *a) {
   SetVector(a);
   if (a->cnt > 0) {
      ae_vector_set_length(a, 1);
   }
}

// Tests Z*Lambda*Z' against tridiag(D,E).
// Returns relative error.
static double testevdunit_tdtestproduct(RVector *d, RVector *e, ae_int_t n, RMatrix *z, RVector *lambdav) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double mx;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
      // Calculate V = A[i,j], A = Z*Lambda*Z'
         v = 0.0;
         for (k = 0; k < n; k++) {
            v += z->xyR[i][k] * lambdav->xR[k] * z->xyR[j][k];
         }
      // Compare
         if (ae_iabs(i - j) == 0) {
            result = rmax2(result, fabs(v - d->xR[i]));
         }
         if (ae_iabs(i - j) == 1) {
            result = rmax2(result, fabs(v - e->xR[imin2(i, j)]));
         }
         if (ae_iabs(i - j) > 1) {
            result = rmax2(result, fabs(v));
         }
      }
   }
   mx = 0.0;
   for (i = 0; i < n; i++) {
      mx = rmax2(mx, fabs(d->xR[i]));
   }
   for (i = 0; i < n - 1; i++) {
      mx = rmax2(mx, fabs(e->xR[i]));
   }
   if (mx == 0.0) {
      mx = 1.0;
   }
   result /= mx;
   return result;
}

// Tests Z*Lambda*Z' against A
// Returns relative error.
static double testevdunit_testproduct(RMatrix *a, ae_int_t n, RMatrix *z, RVector *lambdav) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double mx;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
      // Calculate V = A[i,j], A = Z*Lambda*Z'
         v = 0.0;
         for (k = 0; k < n; k++) {
            v += z->xyR[i][k] * lambdav->xR[k] * z->xyR[j][k];
         }
      // Compare
         result = rmax2(result, fabs(v - a->xyR[i][j]));
      }
   }
   mx = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         mx = rmax2(mx, fabs(a->xyR[i][j]));
      }
   }
   if (mx == 0.0) {
      mx = 1.0;
   }
   result /= mx;
   return result;
}

// Tests Z*Lambda*Z' against A
// Returns relative error.
static double testevdunit_testcproduct(CMatrix *a, ae_int_t n, CMatrix *z, RVector *lambdav) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   complex v;
   double mx;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
      // Calculate V = A[i,j], A = Z*Lambda*Z'
         v = complex_from_i(0);
         for (k = 0; k < n; k++) {
            v = ae_c_add(v, ae_c_mul(ae_c_mul_d(z->xyC[i][k], lambdav->xR[k]), conj(z->xyC[j][k])));
         }
      // Compare
         result = rmax2(result, abscomplex(ae_c_sub(v, a->xyC[i][j])));
      }
   }
   mx = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         mx = rmax2(mx, abscomplex(a->xyC[i][j]));
      }
   }
   if (mx == 0.0) {
      mx = 1.0;
   }
   result /= mx;
   return result;
}

// Tests Z*Z' against diag(1...1)
// Returns absolute error.
static double testevdunit_testort(RMatrix *z, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   double v;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(&z->xyR[0][i], z->stride, &z->xyR[0][j], z->stride, n);
         if (i == j) {
            v--;
         }
         result = rmax2(result, fabs(v));
      }
   }
   return result;
}

// Tests Z*Z' against diag(1...1)
// Returns absolute error.
static double testevdunit_testcort(CMatrix *z, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   complex v;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(&z->xyC[0][i], z->stride, "N", &z->xyC[0][j], z->stride, "Conj", n);
         if (i == j) {
            v = ae_c_sub_d(v, 1);
         }
         result = rmax2(result, abscomplex(v));
      }
   }
   return result;
}

// Tests SEVD problem
static void testevdunit_testsevdproblem(RMatrix *a, RMatrix *al, RMatrix *au, ae_int_t n, double threshold, bool *serrors, ae_int_t *failc, ae_int_t *runs) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewVector(lambdav, 0, DT_REAL);
   NewVector(lambdaref, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
// Test simple EVD: values and full vectors, lower A
   testevdunit_unset1d(&lambdaref);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevd(al, n, 1, false, &lambdaref, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   *serrors = *serrors || testevdunit_testproduct(a, n, &z, &lambdaref) > threshold;
   *serrors = *serrors || testevdunit_testort(&z, n) > threshold;
   for (i = 0; i < n - 1; i++) {
      if (lambdaref.xR[i + 1] < lambdaref.xR[i]) {
         *serrors = true;
         ae_frame_leave();
         return;
      }
   }
// Test simple EVD: values and full vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevd(au, n, 1, true, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   *serrors = *serrors || testevdunit_testproduct(a, n, &z, &lambdav) > threshold;
   *serrors = *serrors || testevdunit_testort(&z, n) > threshold;
   for (i = 0; i < n - 1; i++) {
      if (lambdav.xR[i + 1] < lambdav.xR[i]) {
         *serrors = true;
         ae_frame_leave();
         return;
      }
   }
// Test simple EVD: values only, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevd(al, n, 0, false, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (i = 0; i < n; i++) {
      *serrors = *serrors || fabs(lambdav.xR[i] - lambdaref.xR[i]) > threshold;
   }
// Test simple EVD: values only, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevd(au, n, 0, true, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (i = 0; i < n; i++) {
      *serrors = *serrors || fabs(lambdav.xR[i] - lambdaref.xR[i]) > threshold;
   }
   ae_frame_leave();
}

// Tests SEVD problem
static void testevdunit_testhevdproblem(CMatrix *a, CMatrix *al, CMatrix *au, ae_int_t n, double threshold, bool *herrors, ae_int_t *failc, ae_int_t *runs) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewVector(lambdav, 0, DT_REAL);
   NewVector(lambdaref, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_COMPLEX);
// Test simple EVD: values and full vectors, lower A
   testevdunit_unset1d(&lambdaref);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevd(al, n, 1, false, &lambdaref, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   *herrors = *herrors || testevdunit_testcproduct(a, n, &z, &lambdaref) > threshold;
   *herrors = *herrors || testevdunit_testcort(&z, n) > threshold;
   for (i = 0; i < n - 1; i++) {
      if (lambdaref.xR[i + 1] < lambdaref.xR[i]) {
         *herrors = true;
         ae_frame_leave();
         return;
      }
   }
// Test simple EVD: values and full vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevd(au, n, 1, true, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   *herrors = *herrors || testevdunit_testcproduct(a, n, &z, &lambdav) > threshold;
   *herrors = *herrors || testevdunit_testcort(&z, n) > threshold;
   for (i = 0; i < n - 1; i++) {
      if (lambdav.xR[i + 1] < lambdav.xR[i]) {
         *herrors = true;
         ae_frame_leave();
         return;
      }
   }
// Test simple EVD: values only, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevd(al, n, 0, false, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (i = 0; i < n; i++) {
      *herrors = *herrors || fabs(lambdav.xR[i] - lambdaref.xR[i]) > threshold;
   }
// Test simple EVD: values only, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevd(au, n, 0, true, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (i = 0; i < n; i++) {
      *herrors = *herrors || fabs(lambdav.xR[i] - lambdaref.xR[i]) > threshold;
   }
   ae_frame_leave();
}

// Tests EVD problem
//
// DistVals    -   is True, when eigenvalues are distinct. Is False, when we
//                 are solving sparse task with  lots  of  zero  eigenvalues.
//                 In such cases some tests related to the  eigenvectors  are
//                 not performed.
static void testevdunit_testsevdbiproblem(RMatrix *afull, RMatrix *al, RMatrix *au, ae_int_t n, bool distvals, double threshold, bool *serrors, ae_int_t *failc, ae_int_t *runs) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t m;
   ae_int_t i1;
   ae_int_t i2;
   double v;
   double a;
   double b;
   ae_frame_make(&_frame_block);
   NewVector(lambdav, 0, DT_REAL);
   NewVector(lambdaref, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewMatrix(zref, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewMatrix(ar, 0, 0, DT_REAL);
   ae_vector_set_length(&lambdaref, n - 1 + 1);
   ae_matrix_set_length(&zref, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&a1, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&a2, n - 1 + 1, n - 1 + 1);
// Reference EVD
   ++*runs;
   if (!smatrixevd(afull, n, 1, true, &lambdaref, &zref)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
// Select random interval boundaries.
// If there are non-distinct eigenvalues at the boundaries,
// we move indexes further until values splits. It is done to
// avoid situations where we can't get definite answer.
   i1 = randominteger(n);
   i2 = i1 + randominteger(n - i1);
   while (i1 > 0) {
      if (fabs(lambdaref.xR[i1 - 1] - lambdaref.xR[i1]) > 10 * threshold) {
         break;
      }
      i1--;
   }
   while (i2 < n - 1) {
      if (fabs(lambdaref.xR[i2 + 1] - lambdaref.xR[i2]) > 10 * threshold) {
         break;
      }
      i2++;
   }
// Select A, B
   if (i1 > 0) {
      a = 0.5 * (lambdaref.xR[i1] + lambdaref.xR[i1 - 1]);
   } else {
      a = lambdaref.xR[0] - 1;
   }
   if (i2 < n - 1) {
      b = 0.5 * (lambdaref.xR[i2] + lambdaref.xR[i2 + 1]);
   } else {
      b = lambdaref.xR[n - 1] + 1;
   }
// Test interval, no vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdr(al, n, 0, false, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (k = 0; k < m; k++) {
      *serrors = *serrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
// Test interval, no vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdr(au, n, 0, true, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (k = 0; k < m; k++) {
      *serrors = *serrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
// Test indexes, no vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdi(al, n, 0, false, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      *serrors = *serrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
// Test indexes, no vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdi(au, n, 0, true, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      *serrors = *serrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
// Test interval, vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdr(al, n, 1, false, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (k = 0; k < m; k++) {
      *serrors = *serrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&z.xyR[0][j], z.stride, &zref.xyR[0][i1 + j], zref.stride, n);
         if (v < 0.0) {
            ae_v_muld(&z.xyR[0][j], z.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            *serrors = *serrors || fabs(z.xyR[i][j] - zref.xyR[i][i1 + j]) > threshold;
         }
      }
   }
// Test interval, vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdr(au, n, 1, true, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (k = 0; k < m; k++) {
      *serrors = *serrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&z.xyR[0][j], z.stride, &zref.xyR[0][i1 + j], zref.stride, n);
         if (v < 0.0) {
            ae_v_muld(&z.xyR[0][j], z.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            *serrors = *serrors || fabs(z.xyR[i][j] - zref.xyR[i][i1 + j]) > threshold;
         }
      }
   }
// Test indexes, vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdi(al, n, 1, false, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      *serrors = *serrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&z.xyR[0][j], z.stride, &zref.xyR[0][i1 + j], zref.stride, n);
         if (v < 0.0) {
            ae_v_muld(&z.xyR[0][j], z.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            *serrors = *serrors || fabs(z.xyR[i][j] - zref.xyR[i][i1 + j]) > threshold;
         }
      }
   }
// Test indexes, vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_unset2d(&z);
   ++*runs;
   if (!smatrixevdi(au, n, 1, true, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      *serrors = *serrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&z.xyR[0][j], z.stride, &zref.xyR[0][i1 + j], zref.stride, n);
         if (v < 0.0) {
            ae_v_muld(&z.xyR[0][j], z.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            *serrors = *serrors || fabs(z.xyR[i][j] - zref.xyR[i][i1 + j]) > threshold;
         }
      }
   }
   ae_frame_leave();
}

// Tests EVD problem
//
// DistVals    -   is True, when eigenvalues are distinct. Is False, when we
//                 are solving sparse task with  lots  of  zero  eigenvalues.
//                 In such cases some tests related to the  eigenvectors  are
//                 not performed.
static void testevdunit_testhevdbiproblem(CMatrix *afull, CMatrix *al, CMatrix *au, ae_int_t n, bool distvals, double threshold, bool *herrors, ae_int_t *failc, ae_int_t *runs) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t m;
   ae_int_t i1;
   ae_int_t i2;
   complex v;
   double a;
   double b;
   ae_frame_make(&_frame_block);
   NewVector(lambdav, 0, DT_REAL);
   NewVector(lambdaref, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_COMPLEX);
   NewMatrix(zref, 0, 0, DT_COMPLEX);
   NewMatrix(a1, 0, 0, DT_COMPLEX);
   NewMatrix(a2, 0, 0, DT_COMPLEX);
   NewMatrix(ar, 0, 0, DT_COMPLEX);
   ae_vector_set_length(&lambdaref, n - 1 + 1);
   ae_matrix_set_length(&zref, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&a1, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&a2, n - 1 + 1, n - 1 + 1);
// Reference EVD
   ++*runs;
   if (!hmatrixevd(afull, n, 1, true, &lambdaref, &zref)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
// Select random interval boundaries.
// If there are non-distinct eigenvalues at the boundaries,
// we move indexes further until values splits. It is done to
// avoid situations where we can't get definite answer.
   i1 = randominteger(n);
   i2 = i1 + randominteger(n - i1);
   while (i1 > 0) {
      if (fabs(lambdaref.xR[i1 - 1] - lambdaref.xR[i1]) > 10 * threshold) {
         break;
      }
      i1--;
   }
   while (i2 < n - 1) {
      if (fabs(lambdaref.xR[i2 + 1] - lambdaref.xR[i2]) > 10 * threshold) {
         break;
      }
      i2++;
   }
// Select A, B
   if (i1 > 0) {
      a = 0.5 * (lambdaref.xR[i1] + lambdaref.xR[i1 - 1]);
   } else {
      a = lambdaref.xR[0] - 1;
   }
   if (i2 < n - 1) {
      b = 0.5 * (lambdaref.xR[i2] + lambdaref.xR[i2 + 1]);
   } else {
      b = lambdaref.xR[n - 1] + 1;
   }
// Test interval, no vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdr(al, n, 0, false, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (k = 0; k < m; k++) {
      *herrors = *herrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
// Test interval, no vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdr(au, n, 0, true, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (k = 0; k < m; k++) {
      *herrors = *herrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
// Test indexes, no vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdi(al, n, 0, false, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      *herrors = *herrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
// Test indexes, no vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdi(au, n, 0, true, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      *herrors = *herrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
// Test interval, vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdr(al, n, 1, false, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (k = 0; k < m; k++) {
      *herrors = *herrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_cdotproduct(&z.xyC[0][j], z.stride, "N", &zref.xyC[0][i1 + j], zref.stride, "Conj", n);
         v = conj(ae_c_div_d(v, abscomplex(v)));
         ae_v_cmulc(&z.xyC[0][j], z.stride, n, v);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            *herrors = *herrors || abscomplex(ae_c_sub(z.xyC[i][j], zref.xyC[i][i1 + j])) > threshold;
         }
      }
   }
// Test interval, vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdr(au, n, 1, true, a, b, &m, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (k = 0; k < m; k++) {
      *herrors = *herrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_cdotproduct(&z.xyC[0][j], z.stride, "N", &zref.xyC[0][i1 + j], zref.stride, "Conj", n);
         v = conj(ae_c_div_d(v, abscomplex(v)));
         ae_v_cmulc(&z.xyC[0][j], z.stride, n, v);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            *herrors = *herrors || abscomplex(ae_c_sub(z.xyC[i][j], zref.xyC[i][i1 + j])) > threshold;
         }
      }
   }
// Test indexes, vectors, lower A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdi(al, n, 1, false, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      *herrors = *herrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_cdotproduct(&z.xyC[0][j], z.stride, "N", &zref.xyC[0][i1 + j], zref.stride, "Conj", n);
         v = conj(ae_c_div_d(v, abscomplex(v)));
         ae_v_cmulc(&z.xyC[0][j], z.stride, n, v);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            *herrors = *herrors || abscomplex(ae_c_sub(z.xyC[i][j], zref.xyC[i][i1 + j])) > threshold;
         }
      }
   }
// Test indexes, vectors, upper A
   testevdunit_unset1d(&lambdav);
   testevdunit_cunset2d(&z);
   ++*runs;
   if (!hmatrixevdi(au, n, 1, true, i1, i2, &lambdav, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      *herrors = *herrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
   if (distvals) {
   // Distinct eigenvalues, test vectors
      for (j = 0; j < m; j++) {
         v = ae_v_cdotproduct(&z.xyC[0][j], z.stride, "N", &zref.xyC[0][i1 + j], zref.stride, "Conj", n);
         v = conj(ae_c_div_d(v, abscomplex(v)));
         ae_v_cmulc(&z.xyC[0][j], z.stride, n, v);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            *herrors = *herrors || abscomplex(ae_c_sub(z.xyC[i][j], zref.xyC[i][i1 + j])) > threshold;
         }
      }
   }
   ae_frame_leave();
}

// Tests EVD problem
static void testevdunit_testtdevdproblem(RVector *d, RVector *e, ae_int_t n, double threshold, bool *tderrors) {
   ae_frame _frame_block;
   bool wsucc;
   ae_int_t i;
   ae_int_t j;
   double v;
   double worstseparation;
   double requiredseparation;
   double specialthreshold;
   ae_frame_make(&_frame_block);
   NewVector(lambdav, 0, DT_REAL);
   NewVector(ee, 0, DT_REAL);
   NewVector(lambda2, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewMatrix(zref, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   ae_vector_set_length(&lambdav, n - 1 + 1);
   ae_vector_set_length(&lambda2, n - 1 + 1);
   ae_matrix_set_length(&zref, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&a1, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&a2, n - 1 + 1, n - 1 + 1);
   if (n > 1) {
      ae_vector_set_length(&ee, n - 2 + 1);
   }
// Test simple EVD: values and full vectors
   for (i = 0; i < n; i++) {
      lambdav.xR[i] = d->xR[i];
   }
   for (i = 0; i < n - 1; i++) {
      ee.xR[i] = e->xR[i];
   }
   testevdunit_unset2d(&z);
   wsucc = smatrixtdevd(&lambdav, &ee, n, 2, &z);
   if (!wsucc) {
      set_error_flag(tderrors, true, __FILE__, __LINE__, "testevdunit.ap:1113");
      ae_frame_leave();
      return;
   }
   set_error_flag(tderrors, testevdunit_tdtestproduct(d, e, n, &z, &lambdav) > threshold, __FILE__, __LINE__, "testevdunit.ap:1116");
   set_error_flag(tderrors, testevdunit_testort(&z, n) > threshold, __FILE__, __LINE__, "testevdunit.ap:1117");
   for (i = 0; i < n - 1; i++) {
      if (lambdav.xR[i + 1] < lambdav.xR[i]) {
         set_error_flag(tderrors, true, __FILE__, __LINE__, "testevdunit.ap:1121");
         ae_frame_leave();
         return;
      }
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         zref.xyR[i][j] = z.xyR[i][j];
      }
   }
// Test values only variant
   for (i = 0; i < n; i++) {
      lambda2.xR[i] = d->xR[i];
   }
   for (i = 0; i < n - 1; i++) {
      ee.xR[i] = e->xR[i];
   }
   testevdunit_unset2d(&z);
   wsucc = smatrixtdevd(&lambda2, &ee, n, 0, &z);
   if (!wsucc) {
      set_error_flag(tderrors, true, __FILE__, __LINE__, "testevdunit.ap:1139");
      ae_frame_leave();
      return;
   }
   for (i = 0; i < n; i++) {
      set_error_flag(tderrors, fabs(lambda2.xR[i] - lambdav.xR[i]) > threshold, __FILE__, __LINE__, "testevdunit.ap:1143");
   }
// Test multiplication variant
   for (i = 0; i < n; i++) {
      lambda2.xR[i] = d->xR[i];
   }
   for (i = 0; i < n - 1; i++) {
      ee.xR[i] = e->xR[i];
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a1.xyR[i][j] = randommid();
         a2.xyR[i][j] = a1.xyR[i][j];
      }
   }
   wsucc = smatrixtdevd(&lambda2, &ee, n, 1, &a1);
   if (!wsucc) {
      set_error_flag(tderrors, true, __FILE__, __LINE__, "testevdunit.ap:1161");
      ae_frame_leave();
      return;
   }
   for (i = 0; i < n; i++) {
      set_error_flag(tderrors, fabs(lambda2.xR[i] - lambdav.xR[i]) > threshold, __FILE__, __LINE__, "testevdunit.ap:1165");
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(a2.xyR[i], 1, &zref.xyR[0][j], zref.stride, n);
      // next line is a bit complicated because
      // depending on algorithm used we can get either
      // z or -z as eigenvector. so we compare result
      // with both A*ZRef and -A*ZRef
         set_error_flag(tderrors, fabs(v - a1.xyR[i][j]) > threshold && fabs(v + a1.xyR[i][j]) > threshold, __FILE__, __LINE__, "testevdunit.ap:1177");
      }
   }
// Test first row variant.
//
// NOTE: this test is special because ZNeeded=3 is ALGLIB-specific feature
//       which is NOT supported by Intel MKL. Thus, MKL-capable version of
//       ALGLIB will use different algorithms for ZNeeded=3 and for ZNeeded<3.
//
//       In most cases it is OK, but when problem happened to be degenerate
//       (two close eigenvalues), Z computed by ALGLIB may be different from
//       Z computed by MKL (up to arbitrary rotation), which will lead to
//       failure of the test, because ZNeeded=2 is used as reference value
//       for ZNeeded=3.
//
//       That's why this test is performed only for well-separated matrices,
//       and with custom threshold.
   requiredseparation = 1.0E-6;
   specialthreshold = 1.0E-6;
   worstseparation = maxrealnumber;
   for (i = 0; i < n - 1; i++) {
      worstseparation = rmin2(worstseparation, fabs(lambdav.xR[i + 1] - lambdav.xR[i]));
   }
   if (worstseparation > requiredseparation) {
      for (i = 0; i < n; i++) {
         lambda2.xR[i] = d->xR[i];
      }
      for (i = 0; i < n - 1; i++) {
         ee.xR[i] = e->xR[i];
      }
      testevdunit_unset2d(&z);
      wsucc = smatrixtdevd(&lambda2, &ee, n, 3, &z);
      if (!wsucc) {
         set_error_flag(tderrors, true, __FILE__, __LINE__, "testevdunit.ap:1211");
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(tderrors, fabs(lambda2.xR[i] - lambdav.xR[i]) > threshold, __FILE__, __LINE__, "testevdunit.ap:1216");
      // next line is a bit complicated because
      // depending on algorithm used we can get either
      // z or -z as eigenvector. so we compare result
      // with both z and -z
         set_error_flag(tderrors, fabs(z.xyR[0][i] - zref.xyR[0][i]) > specialthreshold && fabs(z.xyR[0][i] + zref.xyR[0][i]) > specialthreshold, __FILE__, __LINE__, "testevdunit.ap:1224");
      }
   }
   ae_frame_leave();
}

// Tests EVD problem
//
// DistVals    -   is True, when eigenvalues are distinct. Is False, when we
//                 are solving sparse task with  lots  of  zero  eigenvalues.
//                 In such cases some tests related to the  eigenvectors  are
//                 not performed.
static void testevdunit_testtdevdbiproblem(RVector *d, RVector *e, ae_int_t n, bool distvals, double threshold, bool *serrors, ae_int_t *failc, ae_int_t *runs) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t m;
   ae_int_t i1;
   ae_int_t i2;
   double v;
   double a;
   double b;
   ae_frame_make(&_frame_block);
   NewVector(lambdav, 0, DT_REAL);
   NewVector(lambdaref, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewMatrix(zref, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewMatrix(ar, 0, 0, DT_REAL);
   ae_vector_set_length(&lambdaref, n - 1 + 1);
   ae_matrix_set_length(&zref, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&a1, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&a2, n - 1 + 1, n - 1 + 1);
// Reference EVD
   ae_vector_set_length(&lambdaref, n);
   ae_v_move(lambdaref.xR, 1, d->xR, 1, n);
   ++*runs;
   if (!smatrixtdevd(&lambdaref, e, n, 2, &zref)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
// Select random interval boundaries.
// If there are non-distinct eigenvalues at the boundaries,
// we move indexes further until values splits. It is done to
// avoid situations where we can't get definite answer.
   i1 = randominteger(n);
   i2 = i1 + randominteger(n - i1);
   while (i1 > 0) {
      if (fabs(lambdaref.xR[i1 - 1] - lambdaref.xR[i1]) > 10 * threshold) {
         break;
      }
      i1--;
   }
   while (i2 < n - 1) {
      if (fabs(lambdaref.xR[i2 + 1] - lambdaref.xR[i2]) > 10 * threshold) {
         break;
      }
      i2++;
   }
// Test different combinations
// Select A, B
   if (i1 > 0) {
      a = 0.5 * (lambdaref.xR[i1] + lambdaref.xR[i1 - 1]);
   } else {
      a = lambdaref.xR[0] - 1;
   }
   if (i2 < n - 1) {
      b = 0.5 * (lambdaref.xR[i2] + lambdaref.xR[i2 + 1]);
   } else {
      b = lambdaref.xR[n - 1] + 1;
   }
// Test interval, no vectors
   ae_vector_set_length(&lambdav, n - 1 + 1);
   for (i = 0; i < n; i++) {
      lambdav.xR[i] = d->xR[i];
   }
   ++*runs;
   if (!smatrixtdevdr(&lambdav, e, n, 0, a, b, &m, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (k = 0; k < m; k++) {
      *serrors = *serrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
// Test indexes, no vectors
   ae_vector_set_length(&lambdav, n - 1 + 1);
   for (i = 0; i < n; i++) {
      lambdav.xR[i] = d->xR[i];
   }
   ++*runs;
   if (!smatrixtdevdi(&lambdav, e, n, 0, i1, i2, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      *serrors = *serrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
// Test interval, transform vectors
   ae_vector_set_length(&lambdav, n - 1 + 1);
   for (i = 0; i < n; i++) {
      lambdav.xR[i] = d->xR[i];
   }
   ae_matrix_set_length(&a1, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&a2, n - 1 + 1, n - 1 + 1);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a1.xyR[i][j] = randommid();
         a2.xyR[i][j] = a1.xyR[i][j];
      }
   }
   ++*runs;
   if (!smatrixtdevdr(&lambdav, e, n, 1, a, b, &m, &a1)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (k = 0; k < m; k++) {
      *serrors = *serrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
   if (distvals) {
      ae_matrix_set_length(&ar, n - 1 + 1, m - 1 + 1);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            v = ae_v_dotproduct(a2.xyR[i], 1, &zref.xyR[0][i1 + j], zref.stride, n);
            ar.xyR[i][j] = v;
         }
      }
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&a1.xyR[0][j], a1.stride, &ar.xyR[0][j], ar.stride, n);
         if (v < 0.0) {
            ae_v_muld(&ar.xyR[0][j], ar.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            *serrors = *serrors || fabs(a1.xyR[i][j] - ar.xyR[i][j]) > threshold;
         }
      }
   }
// Test indexes, transform vectors
   ae_vector_set_length(&lambdav, n - 1 + 1);
   for (i = 0; i < n; i++) {
      lambdav.xR[i] = d->xR[i];
   }
   ae_matrix_set_length(&a1, n - 1 + 1, n - 1 + 1);
   ae_matrix_set_length(&a2, n - 1 + 1, n - 1 + 1);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a1.xyR[i][j] = randommid();
         a2.xyR[i][j] = a1.xyR[i][j];
      }
   }
   ++*runs;
   if (!smatrixtdevdi(&lambdav, e, n, 1, i1, i2, &a1)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      *serrors = *serrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
   if (distvals) {
      ae_matrix_set_length(&ar, n - 1 + 1, m - 1 + 1);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            v = ae_v_dotproduct(a2.xyR[i], 1, &zref.xyR[0][i1 + j], zref.stride, n);
            ar.xyR[i][j] = v;
         }
      }
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&a1.xyR[0][j], a1.stride, &ar.xyR[0][j], ar.stride, n);
         if (v < 0.0) {
            ae_v_muld(&ar.xyR[0][j], ar.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            *serrors = *serrors || fabs(a1.xyR[i][j] - ar.xyR[i][j]) > threshold;
         }
      }
   }
// Test interval, do not transform vectors
   ae_vector_set_length(&lambdav, n - 1 + 1);
   for (i = 0; i < n; i++) {
      lambdav.xR[i] = d->xR[i];
   }
   ae_matrix_set_length(&z, 0 + 1, 0 + 1);
   ++*runs;
   if (!smatrixtdevdr(&lambdav, e, n, 2, a, b, &m, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   if (m != i2 - i1 + 1) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   for (k = 0; k < m; k++) {
      *serrors = *serrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
   if (distvals) {
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&z.xyR[0][j], z.stride, &zref.xyR[0][i1 + j], zref.stride, n);
         if (v < 0.0) {
            ae_v_muld(&z.xyR[0][j], z.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            *serrors = *serrors || fabs(z.xyR[i][j] - zref.xyR[i][i1 + j]) > threshold;
         }
      }
   }
// Test indexes, do not transform vectors
   ae_vector_set_length(&lambdav, n - 1 + 1);
   for (i = 0; i < n; i++) {
      lambdav.xR[i] = d->xR[i];
   }
   ae_matrix_set_length(&z, 0 + 1, 0 + 1);
   ++*runs;
   if (!smatrixtdevdi(&lambdav, e, n, 2, i1, i2, &z)) {
      ++*failc;
      ae_frame_leave();
      return;
   }
   m = i2 - i1 + 1;
   for (k = 0; k < m; k++) {
      *serrors = *serrors || fabs(lambdav.xR[k] - lambdaref.xR[i1 + k]) > threshold;
   }
   if (distvals) {
      for (j = 0; j < m; j++) {
         v = ae_v_dotproduct(&z.xyR[0][j], z.stride, &zref.xyR[0][i1 + j], zref.stride, n);
         if (v < 0.0) {
            ae_v_muld(&z.xyR[0][j], z.stride, n, -1);
         }
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            *serrors = *serrors || fabs(z.xyR[i][j] - zref.xyR[i][i1 + j]) > threshold;
         }
      }
   }
   ae_frame_leave();
}

// Non-symmetric problem
static void testevdunit_testnsevdproblem(RMatrix *a, ae_int_t n, double threshold, bool *nserrors) {
   ae_frame _frame_block;
   double mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t vjob;
   bool needl;
   bool needr;
   double curwr;
   double curwi;
   double vt;
   double tmp;
   double vnorm;
   ae_frame_make(&_frame_block);
   NewVector(wr0, 0, DT_REAL);
   NewVector(wi0, 0, DT_REAL);
   NewVector(wr1, 0, DT_REAL);
   NewVector(wi1, 0, DT_REAL);
   NewVector(wr0s, 0, DT_REAL);
   NewVector(wi0s, 0, DT_REAL);
   NewVector(wr1s, 0, DT_REAL);
   NewVector(wi1s, 0, DT_REAL);
   NewMatrix(vl, 0, 0, DT_REAL);
   NewMatrix(vr, 0, 0, DT_REAL);
   NewVector(vec1r, 0, DT_REAL);
   NewVector(vec1i, 0, DT_REAL);
   NewVector(vec2r, 0, DT_REAL);
   NewVector(vec2i, 0, DT_REAL);
   NewVector(vec3r, 0, DT_REAL);
   NewVector(vec3i, 0, DT_REAL);
   ae_vector_set_length(&vec1r, n - 1 + 1);
   ae_vector_set_length(&vec2r, n - 1 + 1);
   ae_vector_set_length(&vec3r, n - 1 + 1);
   ae_vector_set_length(&vec1i, n - 1 + 1);
   ae_vector_set_length(&vec2i, n - 1 + 1);
   ae_vector_set_length(&vec3i, n - 1 + 1);
   ae_vector_set_length(&wr0s, n - 1 + 1);
   ae_vector_set_length(&wr1s, n - 1 + 1);
   ae_vector_set_length(&wi0s, n - 1 + 1);
   ae_vector_set_length(&wi1s, n - 1 + 1);
   mx = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (fabs(a->xyR[i][j]) > mx) {
            mx = fabs(a->xyR[i][j]);
         }
      }
   }
   if (mx == 0.0) {
      mx = 1.0;
   }
// Load values-only
   if (!rmatrixevd(a, n, 0, &wr0, &wi0, &vl, &vr)) {
      set_error_flag(nserrors, true, __FILE__, __LINE__, "testevdunit.ap:1554");
      ae_frame_leave();
      return;
   }
// Test different jobs
   for (vjob = 1; vjob <= 3; vjob++) {
      needr = vjob == 1 || vjob == 3;
      needl = vjob == 2 || vjob == 3;
      if (!rmatrixevd(a, n, vjob, &wr1, &wi1, &vl, &vr)) {
         set_error_flag(nserrors, true, __FILE__, __LINE__, "testevdunit.ap:1567");
         ae_frame_leave();
         return;
      }
   // Test values:
   // 1. sort by real part
   // 2. test
      ae_v_move(wr0s.xR, 1, wr0.xR, 1, n);
      ae_v_move(wi0s.xR, 1, wi0.xR, 1, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n - 1 - i; j++) {
            if (wr0s.xR[j] > wr0s.xR[j + 1]) {
               tmp = wr0s.xR[j];
               wr0s.xR[j] = wr0s.xR[j + 1];
               wr0s.xR[j + 1] = tmp;
               tmp = wi0s.xR[j];
               wi0s.xR[j] = wi0s.xR[j + 1];
               wi0s.xR[j + 1] = tmp;
            }
         }
      }
      ae_v_move(wr1s.xR, 1, wr1.xR, 1, n);
      ae_v_move(wi1s.xR, 1, wi1.xR, 1, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n - 1 - i; j++) {
            if (wr1s.xR[j] > wr1s.xR[j + 1]) {
               tmp = wr1s.xR[j];
               wr1s.xR[j] = wr1s.xR[j + 1];
               wr1s.xR[j + 1] = tmp;
               tmp = wi1s.xR[j];
               wi1s.xR[j] = wi1s.xR[j + 1];
               wi1s.xR[j + 1] = tmp;
            }
         }
      }
      for (i = 0; i < n; i++) {
         set_error_flag(nserrors, fabs(wr0s.xR[i] - wr1s.xR[i]) > threshold, __FILE__, __LINE__, "testevdunit.ap:1604");
         set_error_flag(nserrors, fabs(wi0s.xR[i] - wi1s.xR[i]) > threshold, __FILE__, __LINE__, "testevdunit.ap:1605");
      }
   // Test right vectors
      if (needr) {
         k = 0;
         while (k < n) {
            curwr = 0.0;
            curwi = 0.0;
            if (wi1.xR[k] == 0.0) {
               ae_v_move(vec1r.xR, 1, &vr.xyR[0][k], vr.stride, n);
               for (i = 0; i < n; i++) {
                  vec1i.xR[i] = 0.0;
               }
               curwr = wr1.xR[k];
               curwi = 0.0;
            }
            if (wi1.xR[k] > 0.0) {
               ae_v_move(vec1r.xR, 1, &vr.xyR[0][k], vr.stride, n);
               ae_v_move(vec1i.xR, 1, &vr.xyR[0][k + 1], vr.stride, n);
               curwr = wr1.xR[k];
               curwi = wi1.xR[k];
            }
            if (wi1.xR[k] < 0.0) {
               ae_v_move(vec1r.xR, 1, &vr.xyR[0][k - 1], vr.stride, n);
               ae_v_moveneg(vec1i.xR, 1, &vr.xyR[0][k], vr.stride, n);
               curwr = wr1.xR[k];
               curwi = wi1.xR[k];
            }
            vnorm = 0.0;
            for (i = 0; i < n; i++) {
               vt = ae_v_dotproduct(a->xyR[i], 1, vec1r.xR, 1, n);
               vec2r.xR[i] = vt;
               vt = ae_v_dotproduct(a->xyR[i], 1, vec1i.xR, 1, n);
               vec2i.xR[i] = vt;
               vnorm += sqr(vec1r.xR[i]) + sqr(vec1i.xR[i]);
            }
            vnorm = sqrt(vnorm);
            ae_v_moved(vec3r.xR, 1, vec1r.xR, 1, n, curwr);
            ae_v_subd(vec3r.xR, 1, vec1i.xR, 1, n, curwi);
            ae_v_moved(vec3i.xR, 1, vec1r.xR, 1, n, curwi);
            ae_v_addd(vec3i.xR, 1, vec1i.xR, 1, n, curwr);
            set_error_flag(nserrors, vnorm < 1.0E-3 || !isfinite(vnorm), __FILE__, __LINE__, "testevdunit.ap:1654");
            for (i = 0; i < n; i++) {
               set_error_flag(nserrors, fabs(vec2r.xR[i] - vec3r.xR[i]) > threshold, __FILE__, __LINE__, "testevdunit.ap:1657");
               set_error_flag(nserrors, fabs(vec2i.xR[i] - vec3i.xR[i]) > threshold, __FILE__, __LINE__, "testevdunit.ap:1658");
            }
            k++;
         }
      }
   // Test left vectors
      curwr = 0.0;
      curwi = 0.0;
      if (needl) {
         k = 0;
         while (k < n) {
            if (wi1.xR[k] == 0.0) {
               ae_v_move(vec1r.xR, 1, &vl.xyR[0][k], vl.stride, n);
               for (i = 0; i < n; i++) {
                  vec1i.xR[i] = 0.0;
               }
               curwr = wr1.xR[k];
               curwi = 0.0;
            }
            if (wi1.xR[k] > 0.0) {
               ae_v_move(vec1r.xR, 1, &vl.xyR[0][k], vl.stride, n);
               ae_v_move(vec1i.xR, 1, &vl.xyR[0][k + 1], vl.stride, n);
               curwr = wr1.xR[k];
               curwi = wi1.xR[k];
            }
            if (wi1.xR[k] < 0.0) {
               ae_v_move(vec1r.xR, 1, &vl.xyR[0][k - 1], vl.stride, n);
               ae_v_moveneg(vec1i.xR, 1, &vl.xyR[0][k], vl.stride, n);
               curwr = wr1.xR[k];
               curwi = wi1.xR[k];
            }
            vnorm = 0.0;
            for (j = 0; j < n; j++) {
               vt = ae_v_dotproduct(vec1r.xR, 1, &a->xyR[0][j], a->stride, n);
               vec2r.xR[j] = vt;
               vt = ae_v_dotproduct(vec1i.xR, 1, &a->xyR[0][j], a->stride, n);
               vec2i.xR[j] = -vt;
               vnorm += sqr(vec1r.xR[j]) + sqr(vec1i.xR[j]);
            }
            vnorm = sqrt(vnorm);
            ae_v_moved(vec3r.xR, 1, vec1r.xR, 1, n, curwr);
            ae_v_addd(vec3r.xR, 1, vec1i.xR, 1, n, curwi);
            ae_v_moved(vec3i.xR, 1, vec1r.xR, 1, n, curwi);
            ae_v_addd(vec3i.xR, 1, vec1i.xR, 1, n, -curwr);
            set_error_flag(nserrors, vnorm < 1.0E-3 || !isfinite(vnorm), __FILE__, __LINE__, "testevdunit.ap:1710");
            for (i = 0; i < n; i++) {
               set_error_flag(nserrors, fabs(vec2r.xR[i] - vec3r.xR[i]) > threshold, __FILE__, __LINE__, "testevdunit.ap:1713");
               set_error_flag(nserrors, fabs(vec2i.xR[i] - vec3i.xR[i]) > threshold, __FILE__, __LINE__, "testevdunit.ap:1714");
            }
            k++;
         }
      }
   }
   ae_frame_leave();
}

// Testing EVD subroutines for one N
//
// NOTES:
// * BIThreshold is a threshold for bisection-and-inverse-iteration subroutines.
//   special threshold is needed because these subroutines may have much more
//   larger error than QR-based algorithms.
static void testevdunit_testevdset(ae_int_t n, double threshold, double bithreshold, ae_int_t *failc, ae_int_t *runs, bool *nserrors, bool *serrors, bool *herrors, bool *tderrors, bool *sbierrors, bool *hbierrors, bool *tdbierrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t mkind;
   ae_frame_make(&_frame_block);
   NewMatrix(ra, 0, 0, DT_REAL);
   NewMatrix(ral, 0, 0, DT_REAL);
   NewMatrix(rau, 0, 0, DT_REAL);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewMatrix(cal, 0, 0, DT_COMPLEX);
   NewMatrix(cau, 0, 0, DT_COMPLEX);
   NewVector(d, 0, DT_REAL);
   NewVector(e, 0, DT_REAL);
// Test symmetric problems
   ae_matrix_set_length(&ra, n, n);
   ae_matrix_set_length(&ral, n, n);
   ae_matrix_set_length(&rau, n, n);
   ae_matrix_set_length(&ca, n, n);
   ae_matrix_set_length(&cal, n, n);
   ae_matrix_set_length(&cau, n, n);
// Zero matrices
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         ra.xyR[i][j] = 0.0;
         ca.xyC[i][j] = complex_from_i(0);
      }
   }
   testevdunit_rmatrixsymmetricsplit(&ra, n, &ral, &rau);
   testevdunit_cmatrixhermitiansplit(&ca, n, &cal, &cau);
   testevdunit_testsevdproblem(&ra, &ral, &rau, n, threshold, serrors, failc, runs);
   testevdunit_testhevdproblem(&ca, &cal, &cau, n, threshold, herrors, failc, runs);
   testevdunit_testsevdbiproblem(&ra, &ral, &rau, n, false, bithreshold, sbierrors, failc, runs);
   testevdunit_testhevdbiproblem(&ca, &cal, &cau, n, false, bithreshold, hbierrors, failc, runs);
// Random matrix
   for (i = 0; i < n; i++) {
      for (j = i + 1; j < n; j++) {
         ra.xyR[i][j] = randommid();
         ca.xyC[i][j] = complex_from_d(randommid(), randommid());
         ra.xyR[j][i] = ra.xyR[i][j];
         ca.xyC[j][i] = conj(ca.xyC[i][j]);
      }
      ra.xyR[i][i] = randommid();
      ca.xyC[i][i] = complex_from_d(randommid());
   }
   testevdunit_rmatrixsymmetricsplit(&ra, n, &ral, &rau);
   testevdunit_cmatrixhermitiansplit(&ca, n, &cal, &cau);
   testevdunit_testsevdproblem(&ra, &ral, &rau, n, threshold, serrors, failc, runs);
   testevdunit_testhevdproblem(&ca, &cal, &cau, n, threshold, herrors, failc, runs);
// Random diagonally dominant matrix with distinct eigenvalues
   for (i = 0; i < n; i++) {
      for (j = i + 1; j < n; j++) {
         ra.xyR[i][j] = 0.1 * randommid() / n;
         ca.xyC[i][j] = complex_from_d(0.1 * randommid() / n, 0.1 * randommid() / n);
         ra.xyR[j][i] = ra.xyR[i][j];
         ca.xyC[j][i] = conj(ca.xyC[i][j]);
      }
      ra.xyR[i][i] = 0.1 * randommid() + i;
      ca.xyC[i][i] = complex_from_d(0.1 * randommid() + i);
   }
   testevdunit_rmatrixsymmetricsplit(&ra, n, &ral, &rau);
   testevdunit_cmatrixhermitiansplit(&ca, n, &cal, &cau);
   testevdunit_testsevdproblem(&ra, &ral, &rau, n, threshold, serrors, failc, runs);
   testevdunit_testhevdproblem(&ca, &cal, &cau, n, threshold, herrors, failc, runs);
   testevdunit_testsevdbiproblem(&ra, &ral, &rau, n, true, bithreshold, sbierrors, failc, runs);
   testevdunit_testhevdbiproblem(&ca, &cal, &cau, n, true, bithreshold, hbierrors, failc, runs);
// Sparse matrices
   testevdunit_rmatrixfillsparsea(&ra, n, n, 0.995, 0.0);
   testevdunit_cmatrixfillsparsea(&ca, n, n, 0.995, 0.0);
   for (i = 0; i < n; i++) {
      for (j = i + 1; j < n; j++) {
         ra.xyR[j][i] = ra.xyR[i][j];
         ca.xyC[j][i] = conj(ca.xyC[i][j]);
      }
      ca.xyC[i][i].y = 0.0;
   }
   testevdunit_rmatrixsymmetricsplit(&ra, n, &ral, &rau);
   testevdunit_cmatrixhermitiansplit(&ca, n, &cal, &cau);
   testevdunit_testsevdproblem(&ra, &ral, &rau, n, threshold, serrors, failc, runs);
   testevdunit_testhevdproblem(&ca, &cal, &cau, n, threshold, herrors, failc, runs);
   testevdunit_testsevdbiproblem(&ra, &ral, &rau, n, false, bithreshold, sbierrors, failc, runs);
   testevdunit_testhevdbiproblem(&ca, &cal, &cau, n, false, bithreshold, hbierrors, failc, runs);
// testing tridiagonal problems
   for (mkind = 0; mkind <= 7; mkind++) {
      ae_vector_set_length(&d, n);
      if (n > 1) {
         ae_vector_set_length(&e, n - 1);
      }
      if (mkind == 0) {
      // Zero matrix
         for (i = 0; i < n; i++) {
            d.xR[i] = 0.0;
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = 0.0;
         }
      }
      if (mkind == 1) {
      // Diagonal matrix
         for (i = 0; i < n; i++) {
            d.xR[i] = randommid();
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = 0.0;
         }
      }
      if (mkind == 2) {
      // Off-diagonal matrix
         for (i = 0; i < n; i++) {
            d.xR[i] = 0.0;
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = randommid();
         }
      }
      if (mkind == 3) {
      // Dense matrix with blocks
         for (i = 0; i < n; i++) {
            d.xR[i] = randommid();
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = randommid();
         }
         j = 1;
         i = 2;
         while (j < n - 1) {
            e.xR[j] = 0.0;
            j += i;
            i++;
         }
      }
      if (mkind == 4) {
      // dense matrix
         for (i = 0; i < n; i++) {
            d.xR[i] = randommid();
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = randommid();
         }
      }
      if (mkind == 5) {
      // Diagonal matrix with distinct eigenvalues
         for (i = 0; i < n; i++) {
            d.xR[i] = 0.1 * randommid() + i;
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = 0.0;
         }
      }
      if (mkind == 6) {
      // Off-diagonal matrix with distinct eigenvalues
         for (i = 0; i < n; i++) {
            d.xR[i] = 0.0;
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = 0.1 * randommid() + i + 1;
         }
      }
      if (mkind == 7) {
      // dense matrix with distinct eigenvalues
         for (i = 0; i < n; i++) {
            d.xR[i] = 0.1 * randommid() + i + 1;
         }
         for (i = 0; i < n - 1; i++) {
            e.xR[i] = 0.1 * randommid();
         }
      }
      testevdunit_testtdevdproblem(&d, &e, n, threshold, tderrors);
      testevdunit_testtdevdbiproblem(&d, &e, n, (mkind == 5 || mkind == 6) || mkind == 7, bithreshold, tdbierrors, failc, runs);
   }
// Test non-symmetric problems
// Test non-symmetric problems: zero, random, sparse matrices.
   ae_matrix_set_length(&ra, n, n);
   ae_matrix_set_length(&ca, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         ra.xyR[i][j] = 0.0;
         ca.xyC[i][j] = complex_from_i(0);
      }
   }
   testevdunit_testnsevdproblem(&ra, n, threshold, nserrors);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         ra.xyR[i][j] = randommid();
         ca.xyC[i][j] = complex_from_d(randommid(), randommid());
      }
   }
   testevdunit_testnsevdproblem(&ra, n, threshold, nserrors);
   ae_frame_leave();
}

// Testing symmetric mode of subspace iteration solver.
//
// On failure sets error flag, on success flag is not changed.
static void testevdunit_testsisymm(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t smode;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double sgn;
   double decaya;
   bool isupper;
   ae_int_t sformat;
   double v;
   double mx;
   double tollambda;
   double tolvector;
   ae_int_t itscount;
   ae_int_t callcount;
   ae_int_t requestsize;
   ae_int_t requesttype;
   ae_int_t pass;
   ae_int_t cnta;
   ae_int_t cntb;
   ae_int_t cntc;
   double nu;
   double eps;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewVector(diaga, 0, DT_REAL);
   NewMatrix(qa, 0, 0, DT_REAL);
   NewMatrix(densea, 0, 0, DT_REAL);
   NewMatrix(halfa, 0, 0, DT_REAL);
   NewMatrix(ra, 0, 0, DT_REAL);
   NewMatrix(rb, 0, 0, DT_REAL);
   NewMatrix(tmp2, 0, 0, DT_REAL);
   NewObj(sparsematrix, halfsa);
   NewObj(eigsubspacestate, s);
   NewObj(eigsubspacereport, rep);
   NewVector(sw, 0, DT_REAL);
   NewMatrix(sz, 0, 0, DT_REAL);
   NewVector(u, 0, DT_REAL);
   hqrndrandomize(&rs);
// Problem with weakly separated eigenvalues (but not too weak),
// either with alternating sign - or all positive. EPS-based
// stopping condition is used because we can not tell how many
// iterations is required to solve it.
   tollambda = 1.0E-9;
   tolvector = 1.0E-4;
   for (n = 1; n <= 25; n++) {
      for (m = 1; m <= n; m++) {
         for (smode = 0; smode <= 2; smode++) {
         // Generate eigenproblem
            sgn = (double)(2 * hqrnduniformi(&rs, 2) - 1);
            decaya = 1.05;
            ae_vector_set_length(&diaga, n);
            diaga.xR[0] = pow(10.0, 2 * hqrnduniformr(&rs) - 1);
            for (i = 1; i < n; i++) {
               diaga.xR[i] = diaga.xR[i - 1] * sgn / (decaya * (1 + 0.01 * hqrnduniformr(&rs)));
            }
            rmatrixrndorthogonal(n, &qa);
            ae_matrix_set_length(&densea, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = 0.0;
                  for (k = 0; k < n; k++) {
                     v += qa.xyR[k][i] * diaga.xR[k] * qa.xyR[k][j];
                  }
                  densea.xyR[i][j] = v;
               }
            }
            isupper = hqrnduniformr(&rs) > 0.5;
            ae_matrix_set_length(&halfa, n, n);
            sparsecreate(n, n, 0, &halfsa);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  halfa.xyR[i][j] = hqrnduniformr(&rs);
                  if (j >= i && isupper) {
                     halfa.xyR[i][j] = densea.xyR[i][j];
                     sparseset(&halfsa, i, j, densea.xyR[i][j]);
                  }
                  if (j <= i && !isupper) {
                     halfa.xyR[i][j] = densea.xyR[i][j];
                     sparseset(&halfsa, i, j, densea.xyR[i][j]);
                  }
               }
            }
            sformat = hqrnduniformi(&rs, 2);
            if (sformat == 0) {
               sparseconverttocrs(&halfsa);
            }
            if (sformat == 1) {
               sparseconverttosks(&halfsa);
            }
         // Solve with eigensolver operating in dense mode
            eigsubspacecreate(n, m, &s);
            eigsubspacesetcond(&s, tollambda / 100, 0);
            if (smode == 0) {
            // Dense mode
               eigsubspacesolvedenses(&s, &halfa, isupper, &sw, &sz, &rep);
            } else {
               if (smode == 1) {
               // Sparse mode
                  eigsubspacesolvesparses(&s, &halfsa, isupper, &sw, &sz, &rep);
               } else {
                  if (smode == 2) {
                  // Out-of-core mode, symmetric version
                     eigsubspaceoocstart(&s, 0);
                     while (eigsubspaceooccontinue(&s)) {
                        eigsubspaceoocgetrequestinfo(&s, &requesttype, &requestsize);
                        ae_assert(requesttype == 0, "EVDI: integrity check failed in unit test");
                        ae_assert(requestsize > 0, "EVDI: integrity check failed in unit test");
                        eigsubspaceoocgetrequestdata(&s, &ra);
                        matrixsetlengthatleast(&rb, n, requestsize);
                        rmatrixgemm(n, requestsize, n, 1.0, &densea, 0, 0, 0, &ra, 0, 0, 0, 0.0, &rb, 0, 0);
                        eigsubspaceoocsendresult(&s, &rb);
                     }
                     eigsubspaceoocstop(&s, &sw, &sz, &rep);
                  } else {
                     ae_assert(false, "unittest: integrity check failed");
                  }
               }
            }
         // Compare against reference values
            for (i = 0; i < m; i++) {
               set_error_flag(errorflag, fabs(sw.xR[i] - diaga.xR[i]) > tollambda, __FILE__, __LINE__, "testevdunit.ap:2126");
               v = ae_v_dotproduct(qa.xyR[i], 1, &sz.xyR[0][i], sz.stride, n);
               mx = 0.0;
               for (j = 0; j < n; j++) {
                  mx = rmax2(mx, fabs(sz.xyR[j][i] * sign(v) - qa.xyR[i][j]));
               }
               set_error_flag(errorflag, mx > tolvector, __FILE__, __LINE__, "testevdunit.ap:2131");
            }
         }
      }
   }
// Problem with highly separated eigenvalues (either with alternating
// sign - or all positive). Only a few iterations is performed, we
// want to check convergence properties on such problems.
   tollambda = 1.0E-9;
   tolvector = 1.0E-4;
   itscount = 5;
   for (n = 1; n <= 25; n++) {
      for (m = 1; m <= n; m++) {
         for (smode = 0; smode <= 2; smode++) {
         // Generate eigenproblem
            sgn = (double)(2 * hqrnduniformi(&rs, 2) - 1);
            decaya = 1.05;
            ae_vector_set_length(&diaga, n);
            diaga.xR[0] = pow(10.0, 2 * hqrnduniformr(&rs) - 1);
            for (i = 1; i < n; i++) {
               diaga.xR[i] = diaga.xR[i - 1] * sgn / (decaya * (1 + 0.01 * hqrnduniformr(&rs)));
            }
            for (i = m; i < n; i++) {
               diaga.xR[i] /= 100 + 10 * hqrnduniformr(&rs);
            }
            rmatrixrndorthogonal(n, &qa);
            ae_matrix_set_length(&densea, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = 0.0;
                  for (k = 0; k < n; k++) {
                     v += qa.xyR[k][i] * diaga.xR[k] * qa.xyR[k][j];
                  }
                  densea.xyR[i][j] = v;
               }
            }
            isupper = hqrnduniformr(&rs) > 0.5;
            ae_matrix_set_length(&halfa, n, n);
            sparsecreate(n, n, 0, &halfsa);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  halfa.xyR[i][j] = hqrnduniformr(&rs);
                  if (j >= i && isupper) {
                     halfa.xyR[i][j] = densea.xyR[i][j];
                     sparseset(&halfsa, i, j, densea.xyR[i][j]);
                  }
                  if (j <= i && !isupper) {
                     halfa.xyR[i][j] = densea.xyR[i][j];
                     sparseset(&halfsa, i, j, densea.xyR[i][j]);
                  }
               }
            }
            sformat = hqrnduniformi(&rs, 2);
            if (sformat == 0) {
               sparseconverttocrs(&halfsa);
            }
            if (sformat == 1) {
               sparseconverttosks(&halfsa);
            }
         // Solve with eigensolver operating in dense mode
            eigsubspacecreate(n, m, &s);
            eigsubspacesetcond(&s, 0.0, itscount);
            if (smode == 0) {
            // Dense mode
               eigsubspacesolvedenses(&s, &halfa, isupper, &sw, &sz, &rep);
            } else {
               if (smode == 1) {
               // Sparse mode
                  eigsubspacesolvesparses(&s, &halfsa, isupper, &sw, &sz, &rep);
               } else {
                  if (smode == 2) {
                  // Out-of-core mode, symmetric version
                  //
                  // NOTE: we check that solver performs no more than ItsCount+2 calls
                     callcount = 0;
                     eigsubspaceoocstart(&s, 0);
                     while (eigsubspaceooccontinue(&s)) {
                        eigsubspaceoocgetrequestinfo(&s, &requesttype, &requestsize);
                        ae_assert(requesttype == 0, "EVDI: integrity check failed in unit test");
                        ae_assert(requestsize > 0, "EVDI: integrity check failed in unit test");
                        eigsubspaceoocgetrequestdata(&s, &ra);
                        matrixsetlengthatleast(&rb, n, requestsize);
                        rmatrixgemm(n, requestsize, n, 1.0, &densea, 0, 0, 0, &ra, 0, 0, 0, 0.0, &rb, 0, 0);
                        eigsubspaceoocsendresult(&s, &rb);
                        callcount++;
                     }
                     eigsubspaceoocstop(&s, &sw, &sz, &rep);
                     set_error_flag(errorflag, callcount > itscount + 2, __FILE__, __LINE__, "testevdunit.ap:2238");
                  } else {
                     ae_assert(false, "unittest: integrity check failed");
                  }
               }
            }
         // Compare against reference values
            set_error_flag(errorflag, rep.iterationscount > itscount, __FILE__, __LINE__, "testevdunit.ap:2246");
            for (i = 0; i < m; i++) {
               set_error_flag(errorflag, fabs(sw.xR[i] - diaga.xR[i]) > tollambda, __FILE__, __LINE__, "testevdunit.ap:2249");
               v = ae_v_dotproduct(qa.xyR[i], 1, &sz.xyR[0][i], sz.stride, n);
               mx = 0.0;
               for (j = 0; j < n; j++) {
                  mx = rmax2(mx, fabs(sz.xyR[j][i] * sign(v) - qa.xyR[i][j]));
               }
               set_error_flag(errorflag, mx > tolvector, __FILE__, __LINE__, "testevdunit.ap:2254");
            }
         }
      }
   }
// Problem with numerically zero matrix. We check ability to stop
// and to return orthogonal vectors.
   tollambda = 1.0E-9;
   itscount = 5;
   for (n = 1; n <= 25; n++) {
      for (m = 1; m <= n; m++) {
      // Generate eigenproblem
         ae_matrix_set_length(&densea, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               densea.xyR[i][j] = 0.0;
            }
         }
      // Solve with eigensolver operating in dense mode,
      // iteration count based stopping condition.
         eigsubspacecreate(n, m, &s);
         eigsubspacesetcond(&s, 0.0, itscount);
         eigsubspacesolvedenses(&s, &densea, true, &sw, &sz, &rep);
         set_error_flag(errorflag, rep.iterationscount > itscount, __FILE__, __LINE__, "testevdunit.ap:2283");
         for (i = 0; i < m; i++) {
            for (j = i; j < m; j++) {
               v = ae_v_dotproduct(&sz.xyR[0][i], sz.stride, &sz.xyR[0][j], sz.stride, n);
               if (j == i) {
                  v--;
               }
               set_error_flag(errorflag, fabs(v) > 1.0E3 * machineepsilon, __FILE__, __LINE__, "testevdunit.ap:2291");
            }
            set_error_flag(errorflag, sw.xR[i] != 0.0, __FILE__, __LINE__, "testevdunit.ap:2293");
         }
      // Solve with eigensolver operating in dense mode,
      // eps-based stopping condition.
         eigsubspacecreate(n, m, &s);
         eigsubspacesetcond(&s, tollambda, 0);
         eigsubspacesolvedenses(&s, &densea, true, &sw, &sz, &rep);
         for (i = 0; i < m; i++) {
            for (j = i; j < m; j++) {
               v = ae_v_dotproduct(&sz.xyR[0][i], sz.stride, &sz.xyR[0][j], sz.stride, n);
               if (j == i) {
                  v--;
               }
               set_error_flag(errorflag, fabs(v) > 1.0E3 * machineepsilon, __FILE__, __LINE__, "testevdunit.ap:2310");
            }
            set_error_flag(errorflag, sw.xR[i] != 0.0, __FILE__, __LINE__, "testevdunit.ap:2312");
         }
      }
   }
// Test warm start functionality:
// * for many randomly generated problems...
// * ...solve original problem with EPS-based criterion
// * ...then apply small rank-1 correction to the matrix
// * ...and solve again, with warm start
// * ...and solve again, with explicit cold start
// * do so many times and calculate total iteration counts
//
// Iteration counts for warm starts should be significantly lower,
// whilst solution found should be within tolerances.
   cnta = 0;
   cntb = 0;
   cntc = 0;
   eps = 1.0E-3;
   nu = 0.001;
   for (pass = 1; pass <= 50; pass++) {
   // Generate eigenproblem and rank-1 update
      n = 50 + hqrnduniformi(&rs, 20);
      m = 1 + hqrnduniformi(&rs, 5);
      ae_matrix_set_length(&ra, n, n);
      ae_matrix_set_length(&tmp2, n, n);
      ae_vector_set_length(&u, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            tmp2.xyR[i][j] = hqrndnormal(&rs);
         }
      }
      rmatrixgemm(n, n, n, 1.0, &tmp2, 0, 0, 0, &tmp2, 0, 0, 1, 0.0, &ra, 0, 0);
   // Solve with eigensolver operating in cold-start mode,
   // iteration count based stopping condition.
      eigsubspacecreate(n, m, &s);
      eigsubspacesetcond(&s, eps, 0);
      eigsubspacesolvedenses(&s, &ra, true, &sw, &sz, &rep);
      cnta += rep.iterationscount;
   // Solve with eigensolver operating in warm-start mode,
   // iteration count based stopping condition.
      for (i = 0; i < n; i++) {
         u.xR[i] = hqrndnormal(&rs);
      }
      rmatrixger(n, n, &ra, 0, 0, nu, &u, 0, &u, 0);
      eigsubspacesetwarmstart(&s, true);
      eigsubspacesolvedenses(&s, &ra, true, &sw, &sz, &rep);
      cntb += rep.iterationscount;
   // Solve with eigensolver operating in explicit cold-start mode,
   // iteration count based stopping condition.
      for (i = 0; i < n; i++) {
         u.xR[i] = hqrndnormal(&rs);
      }
      rmatrixger(n, n, &ra, 0, 0, nu, &u, 0, &u, 0);
      eigsubspacesetwarmstart(&s, false);
      eigsubspacesolvedenses(&s, &ra, true, &sw, &sz, &rep);
      cntc += rep.iterationscount;
   }
   set_error_flag(errorflag, (double)cntb > 0.66 * cnta, __FILE__, __LINE__, "testevdunit.ap:2387");
   set_error_flag(errorflag, (double)cntc < 0.66 * cnta, __FILE__, __LINE__, "testevdunit.ap:2388");
   ae_frame_leave();
}

// Testing symmetric EVD subroutine
bool testevd(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t j;
   ae_int_t failc;
   ae_int_t runs;
   double failthreshold;
   double threshold;
   double bithreshold;
   bool waserrors;
   bool nserrors;
   bool serrors;
   bool herrors;
   bool tderrors;
   bool sbierrors;
   bool hbierrors;
   bool tdbierrors;
   bool sisymmerrors;
   bool wfailed;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(ra, 0, 0, DT_REAL);
   failthreshold = 0.005;
   threshold = 1.0E-8;
   bithreshold = 1.0E-6;
   nserrors = false;
   serrors = false;
   herrors = false;
   tderrors = false;
   sbierrors = false;
   hbierrors = false;
   tdbierrors = false;
   sisymmerrors = false;
   failc = 0;
   runs = 0;
// Test subspace iteration solver
   testevdunit_testsisymm(&sisymmerrors);
// Test dense solvers
   for (n = 1; n <= ablasblocksize(&ra); n++) {
      testevdunit_testevdset(n, threshold, bithreshold, &failc, &runs, &nserrors, &serrors, &herrors, &tderrors, &sbierrors, &hbierrors, &tdbierrors);
   }
   for (j = 2; j <= 3; j++) {
      for (n = j * ablasblocksize(&ra) - 1; n <= j * ablasblocksize(&ra) + 1; n++) {
         testevdunit_testevdset(n, threshold, bithreshold, &failc, &runs, &nserrors, &serrors, &herrors, &tderrors, &sbierrors, &hbierrors, &tdbierrors);
      }
   }
// report
   wfailed = (double)failc / runs > failthreshold;
   waserrors = (((((((nserrors || serrors) || herrors) || tderrors) || sbierrors) || hbierrors) || tdbierrors) || wfailed) || sisymmerrors;
   if (!silent) {
      printf("TESTING EVD UNIT\n");
      printf("DENSE DIRECT SOLVERS:\n");
      printf("* NS                                     ");
      if (!nserrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* S                                      ");
      if (!serrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* H                                      ");
      if (!herrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* TD                                     ");
      if (!tderrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* SBI                                    ");
      if (!sbierrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* HBI                                    ");
      if (!hbierrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* TDBI                                   ");
      if (!tdbierrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* FAILURE THRESHOLD                      ");
      if (!wfailed) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("ITERATIVE SOLVERS:\n");
      printf("* SUBSPACE ITERATION (S)                 ");
      if (!sisymmerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === trfac testing unit ===
// Function for testing sparse real Cholesky.
// Returns True on errors, False on success.
//
// ALGLIB Project: Copyright 16.01.1014 by Sergey Bochkanov
static bool sparserealcholeskytest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nz;
   double pnz;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_int_t t0;
   ae_int_t t1;
   bool isupper;
   double offscale;
   double tol;
   ae_int_t maxfmt;
   ae_int_t minperm;
   ae_int_t maxperm;
   ae_int_t routinetype;
   ae_int_t permtype;
   ae_int_t facttype;
   ae_int_t updatewidth;
   ae_int_t updaterank;
   ae_int_t targetwidth;
   ae_int_t bigsize;
   ae_int_t bottomsize;
   ae_int_t nbetter;
   ae_int_t nworse;
   ae_int_t pass;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewObj(sparsematrix, sa1);
   NewObj(sparsematrix, sc);
   NewObj(sparsematrix, sp);
   NewObj(sparsebuffers, sbuf);
   NewVector(p0, 0, DT_INT);
   NewVector(p1, 0, DT_INT);
   NewVector(d, 0, DT_REAL);
   NewVector(b1, 0, DT_BOOL);
   NewObj(hqrndstate, rs);
   NewObj(sparsedecompositionanalysis, analysis);
   result = false;
   hqrndrandomize(&rs);
// Settings
   maxfmt = 2;
   minperm = -3;
   maxperm = 3;
   offscale = 1.0E-3;
   tol = 1.0E-8;
// Modern Cholesky (SparseCholesky, SparseCholeskyP, Analyze/Factorize) tests:
// performed for positive definite matrices of all sizes in 1..20 and all sparsity percentages.
   for (n = 1; n <= 30; n++) {
      nz = n * n - n;
      while (true) {
      // Generate symmetric N*N matrix where probability of non-diagonal element
      // being non-zero is PNZ. Off-diagonal elements are set to very
      // small values, so positive definiteness is guaranteed.
         if (n > 1) {
            pnz = (double)nz / (n * n - n);
         } else {
            pnz = 1.0;
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j <= i; j++) {
               if (i == j) {
                  a.xyR[i][i] = 1 + hqrnduniformr(&rs);
                  continue;
               }
               if (hqrnduniformr(&rs) <= pnz) {
                  a.xyR[i][j] = 0.5 / n * (hqrnduniformr(&rs) - 0.5);
                  a.xyR[j][i] = a.xyR[i][j];
               } else {
                  a.xyR[i][j] = 0.0;
                  a.xyR[j][i] = 0.0;
               }
            }
         }
      // Create matrix in hash-based storage format, convert it to random storage format.
         isupper = randombool();
         sparsecreate(n, n, 0, &sa);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if ((j <= i && !isupper) || (j >= i && isupper)) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               }
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper ? j < i : j > i) {
                  if (hqrnduniformr(&rs) <= pnz) {
                     sparseset(&sa, i, j, hqrndnormal(&rs));
                  }
               }
            }
         }
         sparseconvertto(&sa, hqrnduniformi(&rs, maxfmt + 1));
      // Try various factorization routines:
      // * SparseCholesky() without permutation
      // * SparseCholeskyP()
      // * Analyze/Factorize family of functions
         for (routinetype = 0; routinetype <= 2; routinetype++) {
         // The factorization
            sparsecopy(&sa, &sc);
            if (routinetype == 0) {
            // Positive-definite Cholesky without permutation
               if (!sparsecholesky(&sc, isupper)) {
                  set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:697");
                  ae_frame_leave();
                  return result;
               }
               ae_vector_set_length(&p0, n);
               ae_vector_set_length(&d, n);
               for (i = 0; i < n; i++) {
                  p0.xZ[i] = i;
                  d.xR[i] = 1.0;
               }
            }
            if (routinetype == 1) {
            // Positive-definite Cholesky with permutation
               if (!sparsecholeskyp(&sc, isupper, &p0)) {
                  set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:715");
                  ae_frame_leave();
                  return result;
               }
               ae_vector_set_length(&d, n);
               for (i = 0; i < n; i++) {
                  d.xR[i] = 1.0;
               }
            }
            if (routinetype == 2) {
            // Positive-definite analyze/factorize with randomly chosen permutation.
            // We also check that we may analyze one matrix and factorize another one
            // with same sparsity pattern.
               sparsecopybuf(&sc, &sp);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     if (sparseexists(&sp, i, j)) {
                        sparserewriteexisting(&sp, i, j, 1.0);
                     }
                  }
               }
               permtype = minperm + hqrnduniformi(&rs, maxperm - minperm + 1);
               if (hqrndnormal(&rs) > 0.0) {
               // Test analyze/factorize sequence
                  if (!sparsecholeskyanalyze(&sc, isupper, 0, permtype, &analysis)) {
                     set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:742");
                     ae_frame_leave();
                     return result;
                  }
                  sparsecreate(1, 1, 0, &sc);
                  if (!sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
                     set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:748");
                     ae_frame_leave();
                     return result;
                  }
               } else {
               // Test analyze/reload/factorize sequence
                  if (!sparsecholeskyanalyze(&sp, isupper, 0, permtype, &analysis)) {
                     set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:759");
                     ae_frame_leave();
                     return result;
                  }
                  sparsecholeskyreload(&analysis, &sc, isupper);
                  sparsecreate(1, 1, 0, &sc);
                  if (!sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
                     set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:766");
                     ae_frame_leave();
                     return result;
                  }
               }
               if (d.cnt != n) {
                  set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:772");
                  ae_frame_leave();
                  return result;
               }
               for (i = 0; i < n; i++) {
                  set_error_flag(&result, d.xR[i] != 1.0, __FILE__, __LINE__, "testtrfacunit.ap:776");
               }
            }
         // Check output sizes and formats
            set_error_flag(&result, (!sparseiscrs(&sc) || sparsegetnrows(&sc) != n) || sparsegetncols(&sc) != n, __FILE__, __LINE__, "testtrfacunit.ap:784");
            set_error_flag(&result, p0.cnt != n, __FILE__, __LINE__, "testtrfacunit.ap:785");
            set_error_flag(&result, d.cnt != n, __FILE__, __LINE__, "testtrfacunit.ap:786");
            if (result) {
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < n; i++) {
               set_error_flag(&result, p0.xZ[i] < i || p0.xZ[i] >= n, __FILE__, __LINE__, "testtrfacunit.ap:791");
               set_error_flag(&result, !isfinite(d.xR[i]), __FILE__, __LINE__, "testtrfacunit.ap:792");
            }
            if (result) {
               ae_frame_leave();
               return result;
            }
            t0 = 0;
            t1 = 0;
            while (sparseenumerate(&sc, &t0, &t1, &i, &j, &v)) {
               set_error_flag(&result, j < i && isupper, __FILE__, __LINE__, "testtrfacunit.ap:800");
               set_error_flag(&result, j > i && !isupper, __FILE__, __LINE__, "testtrfacunit.ap:801");
            }
            if (result) {
               ae_frame_leave();
               return result;
            }
         // Now, test correctness of Cholesky decomposition itself.
         // We calculate U'*U (or L*L') and check it against permutation
         // of A given by P0.
         //
         // NOTE: we expect that only one triangle of SC is filled,
         //       and another one is exactly zero.
            ae_matrix_set_length(&a1, n, n);
            if (isupper) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     v = 0.0;
                     for (k = 0; k < n; k++) {
                        v += sparseget(&sc, k, j) * d.xR[k] * sparseget(&sc, k, i);
                     }
                     a1.xyR[i][j] = v;
                  }
               }
            } else {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     v = 0.0;
                     for (k = 0; k < n; k++) {
                        v += sparseget(&sc, j, k) * d.xR[k] * sparseget(&sc, i, k);
                     }
                     a1.xyR[i][j] = v;
                  }
               }
            }
            for (i = n - 1; i >= 0; i--) {
               swaprows(&a1, i, p0.xZ[i], n);
               swapcols(&a1, i, p0.xZ[i], n);
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  set_error_flag(&result, fabs(a.xyR[i][j] - a1.xyR[i][j]) > tol, __FILE__, __LINE__, "testtrfacunit.ap:844");
               }
            }
         }
      // Check handling of degenerate problems: zeros at main diagonal, negative definite matrices
         for (routinetype = 0; routinetype <= 1; routinetype++) {
         // Exact zero at diagonal
            sparsecopy(&sa, &sc);
            sparseconverttohash(&sc);
            k = hqrnduniformi(&rs, n);
            sparseset(&sc, k, k, 0.0);
            sparseconvertto(&sc, hqrnduniformi(&rs, maxfmt + 1));
            if (routinetype == 0) {
               set_error_flag(&result, sparsecholesky(&sc, isupper), __FILE__, __LINE__, "testtrfacunit.ap:861");
            }
            if (routinetype == 1) {
               set_error_flag(&result, sparsecholeskyp(&sc, isupper, &p0), __FILE__, __LINE__, "testtrfacunit.ap:863");
            }
         // Negative definite matrix
            sparsecopy(&sa, &sc);
            sparseconverttohash(&sc);
            k = hqrnduniformi(&rs, n);
            sparseset(&sc, k, k, -1.0E10);
            sparseconvertto(&sc, hqrnduniformi(&rs, maxfmt + 1));
            if (routinetype == 0) {
               set_error_flag(&result, sparsecholesky(&sc, isupper), __FILE__, __LINE__, "testtrfacunit.ap:874");
            }
            if (routinetype == 1) {
               set_error_flag(&result, sparsecholeskyp(&sc, isupper, &p0), __FILE__, __LINE__, "testtrfacunit.ap:876");
            }
         }
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ=0.
         if (nz == 0) {
            break;
         }
         nz /= 2;
      }
   }
// Negative definite LDLT factorization: performed for matrices with various sparsity factors
   for (n = 1; n <= 30; n++) {
      nz = n * n - n;
      while (true) {
      // Generate symmetric N*N matrix where probability of non-diagonal element
      // being non-zero is PNZ. Off-diagonal elements are set to very
      // small values, so positive definiteness is guaranteed.
         if (n > 1) {
            pnz = (double)nz / (n * n - n);
         } else {
            pnz = 1.0;
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j <= i; j++) {
               if (i == j) {
                  a.xyR[i][i] = possign(hqrndnormal(&rs)) * (1 + hqrnduniformr(&rs));
                  continue;
               }
               if (hqrnduniformr(&rs) <= pnz) {
                  a.xyR[i][j] = 0.5 / n * (hqrnduniformr(&rs) - 0.5);
                  a.xyR[j][i] = a.xyR[i][j];
               } else {
                  a.xyR[i][j] = 0.0;
                  a.xyR[j][i] = 0.0;
               }
            }
         }
      // Create matrix in hash-based storage format, convert it to random storage format.
         isupper = randombool();
         sparsecreate(n, n, 0, &sa);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if ((j <= i && !isupper) || (j >= i && isupper)) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               }
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper ? j < i : j > i) {
                  if (hqrnduniformr(&rs) <= pnz) {
                     sparseset(&sa, i, j, hqrndnormal(&rs));
                  }
               }
            }
         }
         sparseconvertto(&sa, hqrnduniformi(&rs, maxfmt + 1));
      // Try Analyze/Factorize family of functions
         sparsecopy(&sa, &sc);
         sparsecopybuf(&sc, &sp);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (sparseexists(&sp, i, j)) {
                  sparserewriteexisting(&sp, i, j, 1.0);
               }
            }
         }
         facttype = 1;
         permtype = minperm + hqrnduniformi(&rs, maxperm - minperm + 1);
         if (hqrndnormal(&rs) > 0.0) {
         // Test analyze/factorize sequence
            if (!sparsecholeskyanalyze(&sc, isupper, facttype, permtype, &analysis)) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:961");
               ae_frame_leave();
               return result;
            }
            sparsecreate(1, 1, 0, &sc);
            if (!sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:967");
               ae_frame_leave();
               return result;
            }
         } else {
         // Test analyze/reload/factorize sequence
            if (!sparsecholeskyanalyze(&sp, isupper, facttype, permtype, &analysis)) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:978");
               ae_frame_leave();
               return result;
            }
            sparsecholeskyreload(&analysis, &sc, isupper);
            sparsecreate(1, 1, 0, &sc);
            if (!sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:985");
               ae_frame_leave();
               return result;
            }
         }
      // Check output sizes and formats
         set_error_flag(&result, (!sparseiscrs(&sc) || sparsegetnrows(&sc) != n) || sparsegetncols(&sc) != n, __FILE__, __LINE__, "testtrfacunit.ap:993");
         set_error_flag(&result, p0.cnt != n, __FILE__, __LINE__, "testtrfacunit.ap:994");
         set_error_flag(&result, d.cnt != n, __FILE__, __LINE__, "testtrfacunit.ap:995");
         if (result) {
            ae_frame_leave();
            return result;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(&result, p0.xZ[i] < i || p0.xZ[i] >= n, __FILE__, __LINE__, "testtrfacunit.ap:1000");
            set_error_flag(&result, !isfinite(d.xR[i]), __FILE__, __LINE__, "testtrfacunit.ap:1001");
         }
         if (result) {
            ae_frame_leave();
            return result;
         }
         t0 = 0;
         t1 = 0;
         while (sparseenumerate(&sc, &t0, &t1, &i, &j, &v)) {
            set_error_flag(&result, j < i && isupper, __FILE__, __LINE__, "testtrfacunit.ap:1009");
            set_error_flag(&result, j > i && !isupper, __FILE__, __LINE__, "testtrfacunit.ap:1010");
         }
         if (result) {
            ae_frame_leave();
            return result;
         }
      // Now, test correctness of Cholesky decomposition itself.
      // We calculate U'*U (or L*L') and check it against permutation
      // of A given by P0.
      //
      // NOTE: we expect that only one triangle of SC is filled,
      //       and another one is exactly zero.
         ae_matrix_set_length(&a1, n, n);
         if (isupper) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = 0.0;
                  for (k = 0; k < n; k++) {
                     v += sparseget(&sc, k, j) * d.xR[k] * sparseget(&sc, k, i);
                  }
                  a1.xyR[i][j] = v;
               }
            }
         } else {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = 0.0;
                  for (k = 0; k < n; k++) {
                     v += sparseget(&sc, j, k) * d.xR[k] * sparseget(&sc, i, k);
                  }
                  a1.xyR[i][j] = v;
               }
            }
         }
         for (i = n - 1; i >= 0; i--) {
            swaprows(&a1, i, p0.xZ[i], n);
            swapcols(&a1, i, p0.xZ[i], n);
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               set_error_flag(&result, fabs(a.xyR[i][j] - a1.xyR[i][j]) > tol, __FILE__, __LINE__, "testtrfacunit.ap:1053");
            }
         }
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ=0.
         if (nz == 0) {
            break;
         }
         nz /= 2;
      }
   }
// Basis test of modified Cholesky.
//
// We do not perform deep tests here, basically the fact that with diagonal modification
// we can complete factorization that can't be completed without modification.
   for (n = 1; n <= 30; n++) {
      nz = n * n - n;
      while (true) {
      // Generate symmetric N*N matrix where probability of non-diagonal element
      // being non-zero is PNZ. One of diagonal elements is guaranteed to be
      // negative in order to test modification strategy.
         if (n > 1) {
            pnz = (double)nz / (n * n - n);
         } else {
            pnz = 1.0;
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j <= i; j++) {
               if (i == j) {
                  a.xyR[i][i] = hqrndnormal(&rs);
                  continue;
               }
               if (hqrnduniformr(&rs) <= pnz) {
                  a.xyR[i][j] = 0.5 / n * (hqrnduniformr(&rs) - 0.5);
                  a.xyR[j][i] = a.xyR[i][j];
               } else {
                  a.xyR[i][j] = 0.0;
                  a.xyR[j][i] = 0.0;
               }
            }
         }
         i = hqrnduniformi(&rs, n);
         a.xyR[i][i] = -1.0;
         sparsecreate(n, n, 0, &sa);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if ((j <= i && !isupper) || (j >= i && isupper)) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               }
            }
         }
      // Try Analyze/Factorize family of functions
         facttype = 0;
         permtype = minperm + hqrnduniformi(&rs, maxperm - minperm + 1);
         sparsecopy(&sa, &sc);
         if (!sparsecholeskyanalyze(&sc, isupper, facttype, permtype, &analysis)) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:1121");
            ae_frame_leave();
            return result;
         }
         if (sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:1126");
            ae_frame_leave();
            return result;
         }
         sparsecopy(&sa, &sc);
         sparsecholeskysetmodtype(&analysis, 1, 1.0, 0.0, 0.0, 0.0);
         sparsecholeskyreload(&analysis, &sc, isupper);
         if (!sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:1134");
            ae_frame_leave();
            return result;
         }
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ=0.
         if (nz == 0) {
            break;
         }
         nz /= 2;
      }
   }
// Specially designed matrix that allows us to test all internal supernodal update kernels,
// with all update ranks, update widths, target widths
   updaterank = 1;
   updatewidth = 3;
   targetwidth = updatewidth;
   for (updaterank = 1; updaterank <= spsymmgetmaxfastkernel(); updaterank++) {
      for (updatewidth = 1; updatewidth <= spsymmgetmaxfastkernel(); updatewidth++) {
         for (targetwidth = updatewidth; targetwidth <= spsymmgetmaxfastkernel(); targetwidth++) {
         // Generate test matrix A:
         //
         // [ U                  ]
         // [ UU                 ]
         // [ UUU                ]
         // [ UUUT               ]
         // [ UUUTT              ]
         // [ UUUTTT             ]
         // [    TTTT            ]
         // [    TTTTR           ]
         // [    TTTTRR          ]
         // [    TTTTRRR         ]
         // [    TTTTRRRR        ]
         // [    TTTTRRRRR       ]
         // [        RRRRRR      ]
         // [        RRRRRRR     ]
         // [        RRRRRRRR    ]
         // [        RRRRRRRRR   ]
         // [ UUUTTTTRRRRRRRRRR  ]
         // [ UUUTTTTRRRRRRRRRRR ]
         //
         // where U is update matrix, T is target matrix, heights of U and T are chosen in
         // such a way that supernode T will NOT be merged with supernode U, their sizes
         // are chosen to investigate all possible kinds of update kernels. The residual
         // R is also chosen in such a way that it is NOT merged with T.
            bigsize = 10;
            bottomsize = 2 + hqrnduniformi(&rs, 10);
            n = updaterank + targetwidth + 2 * bigsize + bottomsize;
            ae_matrix_set_length(&a, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (i == j) {
                     a.xyR[i][j] = 1 + hqrnduniformr(&rs);
                  } else {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
            for (j = 0; j < updaterank; j++) {
               for (i = j + 1; i < updaterank + updatewidth; i++) {
                  a.xyR[i][j] = 0.5 / n * (hqrnduniformr(&rs) - 0.5);
               }
               for (i = n - bottomsize; i < n; i++) {
                  a.xyR[i][j] = 0.5 / n * (hqrnduniformr(&rs) - 0.5);
               }
            }
            for (j = updaterank; j < updaterank + targetwidth; j++) {
               for (i = j + 1; i < updaterank + targetwidth + bigsize; i++) {
                  a.xyR[i][j] = 0.5 / n * (hqrnduniformr(&rs) - 0.5);
               }
               for (i = n - bottomsize; i < n; i++) {
                  a.xyR[i][j] = 0.5 / n * (hqrnduniformr(&rs) - 0.5);
               }
            }
            for (j = updaterank + targetwidth; j < n; j++) {
               for (i = j + 1; i < n; i++) {
                  a.xyR[i][j] = 0.5 / n * (hqrnduniformr(&rs) - 0.5);
               }
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < i; j++) {
                  a.xyR[j][i] = a.xyR[i][j];
               }
            }
         // Create matrix in hash-based storage format
            isupper = false;
            sparsecreate(n, n, 0, &sa);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               }
            }
         // Try analysis with random permutation and factorization
            facttype = hqrnduniformi(&rs, 2);
            permtype = minperm + hqrnduniformi(&rs, maxperm - minperm + 1);
            if (!sparsecholeskyanalyze(&sa, isupper, facttype, permtype, &analysis)) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:1234");
               ae_frame_leave();
               return result;
            }
            if (!sparsecholeskyfactorize(&analysis, isupper, &sc, &d, &p0)) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:1239");
               ae_frame_leave();
               return result;
            }
         // Check output sizes and formats
            set_error_flag(&result, (!sparseiscrs(&sc) || sparsegetnrows(&sc) != n) || sparsegetncols(&sc) != n, __FILE__, __LINE__, "testtrfacunit.ap:1247");
            set_error_flag(&result, p0.cnt != n, __FILE__, __LINE__, "testtrfacunit.ap:1248");
            set_error_flag(&result, d.cnt != n, __FILE__, __LINE__, "testtrfacunit.ap:1249");
            if (result) {
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < n; i++) {
               set_error_flag(&result, p0.xZ[i] < i || p0.xZ[i] >= n, __FILE__, __LINE__, "testtrfacunit.ap:1254");
               set_error_flag(&result, !isfinite(d.xR[i]), __FILE__, __LINE__, "testtrfacunit.ap:1255");
            }
            if (result) {
               ae_frame_leave();
               return result;
            }
            t0 = 0;
            t1 = 0;
            while (sparseenumerate(&sc, &t0, &t1, &i, &j, &v)) {
               set_error_flag(&result, j < i && isupper, __FILE__, __LINE__, "testtrfacunit.ap:1263");
               set_error_flag(&result, j > i && !isupper, __FILE__, __LINE__, "testtrfacunit.ap:1264");
            }
            if (result) {
               ae_frame_leave();
               return result;
            }
         // Now, test correctness of Cholesky decomposition itself.
         // We calculate U'*U (or L*L') and check it against permutation
         // of A given by P0.
         //
         // NOTE: we expect that only one triangle of SC is filled,
         //       and another one is exactly zero.
            ae_matrix_set_length(&a1, n, n);
            if (isupper) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     v = 0.0;
                     for (k = 0; k < n; k++) {
                        v += sparseget(&sc, k, j) * d.xR[k] * sparseget(&sc, k, i);
                     }
                     a1.xyR[i][j] = v;
                  }
               }
            } else {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     v = 0.0;
                     for (k = 0; k < n; k++) {
                        v += sparseget(&sc, j, k) * d.xR[k] * sparseget(&sc, i, k);
                     }
                     a1.xyR[i][j] = v;
                  }
               }
            }
            for (i = n - 1; i >= 0; i--) {
               swaprows(&a1, i, p0.xZ[i], n);
               swapcols(&a1, i, p0.xZ[i], n);
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  set_error_flag(&result, fabs(a.xyR[i][j] - a1.xyR[i][j]) > tol, __FILE__, __LINE__, "testtrfacunit.ap:1307");
               }
            }
         }
      }
   }
// SparseCholeskySkyline test: performed for matrices
// of all sizes in 1..20 and all sparsity percentages.
   for (n = 1; n <= 20; n++) {
      nz = n * n - n;
      while (true) {
      // Choose IsUpper - main triangle to work with.
      //
      // Generate A - symmetric N*N matrix where probability of non-diagonal
      // element being non-zero is PNZ. Off-diagonal elements are set to
      // very small values, so positive definiteness is guaranteed. Full matrix
      // is generated.
      //
      // Additionally, we create A1 - same as A, but one of the triangles is
      // asymmetrically spoiled. If IsUpper is True, we spoil lower one, or vice versa.
         isupper = randombool();
         if (n > 1) {
            pnz = (double)nz / (n * n - n);
         } else {
            pnz = 1.0;
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j <= i; j++) {
               if (i == j) {
                  a.xyR[i][i] = 1 + hqrnduniformr(&rs);
                  continue;
               }
               if (hqrnduniformr(&rs) <= pnz) {
                  a.xyR[i][j] = offscale * (hqrnduniformr(&rs) - 0.5);
                  a.xyR[j][i] = a.xyR[i][j];
               } else {
                  a.xyR[i][j] = 0.0;
                  a.xyR[j][i] = 0.0;
               }
            }
         }
         ae_matrix_set_length(&a1, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if ((j <= i && !isupper) || (j >= i && isupper)) {
               // Copy one triangle
                  a1.xyR[i][j] = a.xyR[i][j];
               } else {
               // Form another sparse pattern in different triangle.
                  if (hqrnduniformr(&rs) <= pnz) {
                     a1.xyR[i][j] = offscale * (hqrnduniformr(&rs) - 0.5);
                  } else {
                     a1.xyR[i][j] = 0.0;
                  }
               }
            }
         }
      // Create copies of A and A1 in hash-based storage format.
      // Only one triangle of A is copied, but A1 is copied fully.
      // Convert them to SKS
         sparsecreate(n, n, 0, &sa);
         sparsecreate(n, n, 0, &sa1);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if ((j <= i && !isupper) || (j >= i && isupper)) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               }
               sparseset(&sa1, i, j, a1.xyR[i][j]);
            }
         }
         sparseconverttosks(&sa);
         sparseconverttosks(&sa1);
      // Call SparseCholeskySkyline() for SA and make several tests:
      // * check that it is still SKS
      // * check that it has correct size (exactly N*N)
      // * check that correct triangle is returned (and another one is unchanged - zero)
      // * check that it is correct Cholesky decomposition.
      //   We calculate U'*U (or L*L') and check at against A. We expect
      //   that only one triangle of SA is filled, and another one is
      //   exactly zero.
         if (!sparsecholeskyskyline(&sa, n, isupper)) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:1409");
            ae_frame_leave();
            return result;
         }
         set_error_flag(&result, !sparseissks(&sa), __FILE__, __LINE__, "testtrfacunit.ap:1412");
         set_error_flag(&result, sparsegetncols(&sa) != n, __FILE__, __LINE__, "testtrfacunit.ap:1413");
         set_error_flag(&result, sparsegetnrows(&sa) != n, __FILE__, __LINE__, "testtrfacunit.ap:1414");
         t0 = 0;
         t1 = 0;
         while (sparseenumerate(&sa, &t0, &t1, &i, &j, &v)) {
            set_error_flag(&result, j < i && isupper, __FILE__, __LINE__, "testtrfacunit.ap:1419");
            set_error_flag(&result, j > i && !isupper, __FILE__, __LINE__, "testtrfacunit.ap:1420");
         }
         if (isupper) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = 0.0;
                  for (k = 0; k < n; k++) {
                     v += sparseget(&sa, k, j) * sparseget(&sa, k, i);
                  }
                  set_error_flag(&result, fabs(a.xyR[i][j] - v) > tol, __FILE__, __LINE__, "testtrfacunit.ap:1430");
               }
            }
         } else {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = 0.0;
                  for (k = 0; k < n; k++) {
                     v += sparseget(&sa, j, k) * sparseget(&sa, i, k);
                  }
                  set_error_flag(&result, fabs(a.xyR[i][j] - v) > tol, __FILE__, __LINE__, "testtrfacunit.ap:1441");
               }
            }
         }
      // Call SparseCholeskySkyline() for SA1 and make several tests:
      // * check that it is still SKS
      // * check that it has correct size (exactly N*N)
      // * check that factorized triangle matches contents of SA,
      //   and another triangle was unchanged (matches contents of A1).
         if (!sparsecholeskyskyline(&sa1, n, isupper)) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:1454");
            ae_frame_leave();
            return result;
         }
         set_error_flag(&result, !sparseissks(&sa1), __FILE__, __LINE__, "testtrfacunit.ap:1457");
         set_error_flag(&result, sparsegetncols(&sa1) != n, __FILE__, __LINE__, "testtrfacunit.ap:1458");
         set_error_flag(&result, sparsegetnrows(&sa1) != n, __FILE__, __LINE__, "testtrfacunit.ap:1459");
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if ((j <= i && !isupper) || (j >= i && isupper)) {
                  set_error_flag(&result, fabs(sparseget(&sa1, i, j) - sparseget(&sa, i, j)) > 10 * machineepsilon, __FILE__, __LINE__, "testtrfacunit.ap:1463");
               } else {
                  set_error_flag(&result, fabs(sparseget(&sa1, i, j) - a1.xyR[i][j]) > 10 * machineepsilon, __FILE__, __LINE__, "testtrfacunit.ap:1465");
               }
            }
         }
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ=0.
         if (nz == 0) {
            break;
         }
         nz /= 2;
      }
   }
// Test fill-in reducing permutation - on average, AMD and its variants must reduce fill-in.
// We check it by factorizing many matrices with AMD and without it, and by comparing average
// fill-in produced during the factorization.
//
// Test matrices being factorized are ones with mostly low-degree rows/cols, but (sometimes)
// a few nearly dense rows/cols.
   for (permtype = 0; permtype <= maxperm; permtype++) {
   // Evaluate all orderings except for supernodal one (does not reduce fill-in)
      if (permtype == 1) {
         continue;
      }
   // Compare fill-in with ordering and without it
      nbetter = 0;
      nworse = 0;
      for (pass = 0; pass <= 99; pass++) {
      // Generate test matrix:
      // * first, fill it with unit diagonal and typically 2 off-diagonal elements per row/col
      // * then, make some small number of rows/cols dense
         n = 30 + hqrnduniformi(&rs, 20);
         sparsecreate(n, n, 0, &sa);
         for (i = 0; i < n; i++) {
            sparseset(&sa, i, i, 1.0);
            for (k = 1; k <= 2; k++) {
               j = hqrnduniformi(&rs, n);
               if (j != i) {
                  sparseset(&sa, i, j, 0.01 / n);
                  sparseset(&sa, j, i, 0.01 / n);
               }
            }
         }
         while (hqrndnormal(&rs) > 0.0) {
            i = hqrnduniformi(&rs, n);
            for (j = 0; j < n; j++) {
               if (j != i) {
                  sparseset(&sa, i, j, 0.01 / n);
                  sparseset(&sa, j, i, 0.01 / n);
               }
            }
         }
         sparsecopy(&sa, &sa1);
      // Factorize with AMD and without it
         if (!sparsecholeskyanalyze(&sa, false, 0, permtype, &analysis)) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:1537");
            ae_frame_leave();
            return result;
         }
         if (!sparsecholeskyfactorize(&analysis, false, &sa, &d, &p0)) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:1542");
            ae_frame_leave();
            return result;
         }
         if (!sparsecholeskyanalyze(&sa1, false, 0, -2, &analysis)) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:1547");
            ae_frame_leave();
            return result;
         }
         if (!sparsecholeskyfactorize(&analysis, false, &sa1, &d, &p0)) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testtrfacunit.ap:1552");
            ae_frame_leave();
            return result;
         }
         if (sa.ridx.xZ[n] < sa1.ridx.xZ[n]) {
            nbetter++;
         } else {
            nworse++;
         }
      }
      set_error_flag(&result, (double)nbetter < 0.75 * (nbetter + nworse), __FILE__, __LINE__, "testtrfacunit.ap:1560");
   }
   ae_frame_leave();
   return result;
}

// Function for testing sparse real LU decomposition.
// Sets error flag on failure, leave is unchanged on success.
//
// ALGLIB Project: Copyright 16.01.1014 by Sergey Bochkanov
static void sparsereallutest(bool *err) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nz;
   double pnz;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   bool success;
   double tol;
   bool haszero;
   ae_int_t pivottype;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b1, 0, 0, DT_REAL);
   NewMatrix(b2, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(pivr, 0, DT_INT);
   NewVector(pivc, 0, DT_INT);
   NewObj(sparsematrix, sa);
   NewObj(sparsematrix, crsa);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   tol = 1.0E4 * machineepsilon;
// Test matrix sizes in 1...20 and with all sparsity percentages
   for (n = 1; n <= 20; n++) {
      nz = n * n;
      while (true) {
      // Generate N*N matrix where probability of element being
      // non-zero is PNZ. Create sparse matrix in hash-based storage format.
         pnz = (double)nz / (n * n);
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (hqrnduniformr(&rs) <= pnz) {
                  a.xyR[i][j] = hqrndnormal(&rs);
               } else {
                  a.xyR[i][j] = 0.0;
               }
            }
         }
         sparsecreate(n, n, 0, &sa);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               sparseset(&sa, i, j, a.xyR[i][j]);
            }
         }
      // Test SparseLU()
         for (pivottype = 0; pivottype <= 2; pivottype++) {
            sparsecopytocrs(&sa, &crsa);
            ae_vector_set_length(&pivr, 0);
            ae_vector_set_length(&pivc, 0);
            success = sparselu(&crsa, pivottype, &pivr, &pivc);
            set_error_flag(err, !sparseiscrs(&crsa), __FILE__, __LINE__, "testtrfacunit.ap:1630");
            set_error_flag(err, sparsegetncols(&crsa) != n, __FILE__, __LINE__, "testtrfacunit.ap:1631");
            set_error_flag(err, sparsegetnrows(&crsa) != n, __FILE__, __LINE__, "testtrfacunit.ap:1632");
            set_error_flag(err, pivr.cnt != n, __FILE__, __LINE__, "testtrfacunit.ap:1633");
            set_error_flag(err, pivc.cnt != n, __FILE__, __LINE__, "testtrfacunit.ap:1634");
            if (*err) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < n; i++) {
               set_error_flag(err, ((pivr.xZ[i] < 0 || pivr.xZ[i] >= n) || pivc.xZ[i] < 0) || pivc.xZ[i] >= n, __FILE__, __LINE__, "testtrfacunit.ap:1638");
            }
            for (i = 0; i < n; i++) {
               set_error_flag(err, pivottype == 1 && pivc.xZ[i] != i, __FILE__, __LINE__, "testtrfacunit.ap:1640");
            }
            ae_matrix_set_length(&b1, n, n);
            ae_matrix_set_length(&b2, n, n);
            haszero = false;
            for (i = 0; i < n; i++) {
               for (j = 0; j < i; j++) {
                  b1.xyR[i][j] = sparseget(&crsa, i, j);
               }
               b1.xyR[i][i] = 1.0;
               for (j = i + 1; j < n; j++) {
                  b1.xyR[i][j] = 0.0;
               }
               for (j = 0; j < i; j++) {
                  b2.xyR[i][j] = 0.0;
               }
               for (j = i; j < n; j++) {
                  b2.xyR[i][j] = sparseget(&crsa, i, j);
               }
               haszero = haszero || b2.xyR[i][i] == 0.0;
            }
            ae_matrix_set_length(&c, n, n);
            rmatrixgemm(n, n, n, 1.0, &b1, 0, 0, 0, &b2, 0, 0, 0, 0.0, &c, 0, 0);
            for (i = n - 1; i >= 0; i--) {
               j = pivr.xZ[i];
               for (k = 0; k < n; k++) {
                  v = c.xyR[i][k];
                  c.xyR[i][k] = c.xyR[j][k];
                  c.xyR[j][k] = v;
               }
            }
            for (i = n - 1; i >= 0; i--) {
               j = pivc.xZ[i];
               for (k = 0; k < n; k++) {
                  v = c.xyR[k][i];
                  c.xyR[k][i] = c.xyR[k][j];
                  c.xyR[k][j] = v;
               }
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  set_error_flag(err, fabs(c.xyR[i][j] - a.xyR[i][j]) > tol, __FILE__, __LINE__, "testtrfacunit.ap:1689");
               }
            }
            set_error_flag(err, success == haszero, __FILE__, __LINE__, "testtrfacunit.ap:1690");
         }
      // Increase problem sparsity and try one more time.
      // Stop after testing NZ=0.
         if (nz == 0) {
            break;
         }
         nz /= 2;
      }
   }
   ae_frame_leave();
}

static void testtrfacunit_testrluproblem(RMatrix *a, ae_int_t m, ae_int_t n, double threshold, bool *err, bool *properr) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t minmn;
   double v;
   ae_frame_make(&_frame_block);
   NewMatrix(ca, 0, 0, DT_REAL);
   NewMatrix(cl, 0, 0, DT_REAL);
   NewMatrix(cu, 0, 0, DT_REAL);
   NewMatrix(ca2, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_REAL);
   NewVector(p, 0, DT_INT);
   minmn = imin2(m, n);
// PLU test
   ae_matrix_set_length(&ca, m, n);
   for (i = 0; i < m; i++) {
      ae_v_move(ca.xyR[i], 1, a->xyR[i], 1, n);
   }
   rmatrixplu(&ca, m, n, &p);
   for (i = 0; i < minmn; i++) {
      if (p.xZ[i] < i || p.xZ[i] >= m) {
         *properr = true;
         ae_frame_leave();
         return;
      }
   }
   ae_matrix_set_length(&cl, m, minmn);
   for (j = 0; j < minmn; j++) {
      for (i = 0; i < j; i++) {
         cl.xyR[i][j] = 0.0;
      }
      cl.xyR[j][j] = 1.0;
      for (i = j + 1; i < m; i++) {
         cl.xyR[i][j] = ca.xyR[i][j];
      }
   }
   ae_matrix_set_length(&cu, minmn, n);
   for (i = 0; i < minmn; i++) {
      for (j = 0; j < i; j++) {
         cu.xyR[i][j] = 0.0;
      }
      for (j = i; j < n; j++) {
         cu.xyR[i][j] = ca.xyR[i][j];
      }
   }
   ae_matrix_set_length(&ca2, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(cl.xyR[i], 1, &cu.xyR[0][j], cu.stride, minmn);
         ca2.xyR[i][j] = v;
      }
   }
   ae_vector_set_length(&ct, n);
   for (i = minmn - 1; i >= 0; i--) {
      if (i != p.xZ[i]) {
         ae_v_move(ct.xR, 1, ca2.xyR[i], 1, n);
         ae_v_move(ca2.xyR[i], 1, ca2.xyR[p.xZ[i]], 1, n);
         ae_v_move(ca2.xyR[p.xZ[i]], 1, ct.xR, 1, n);
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         *err = *err || fabs(a->xyR[i][j] - ca2.xyR[i][j]) > threshold;
      }
   }
// LUP test
   ae_matrix_set_length(&ca, m, n);
   for (i = 0; i < m; i++) {
      ae_v_move(ca.xyR[i], 1, a->xyR[i], 1, n);
   }
   rmatrixlup(&ca, m, n, &p);
   for (i = 0; i < minmn; i++) {
      if (p.xZ[i] < i || p.xZ[i] >= n) {
         *properr = true;
         ae_frame_leave();
         return;
      }
   }
   ae_matrix_set_length(&cl, m, minmn);
   for (j = 0; j < minmn; j++) {
      for (i = 0; i < j; i++) {
         cl.xyR[i][j] = 0.0;
      }
      for (i = j; i < m; i++) {
         cl.xyR[i][j] = ca.xyR[i][j];
      }
   }
   ae_matrix_set_length(&cu, minmn, n);
   for (i = 0; i < minmn; i++) {
      for (j = 0; j < i; j++) {
         cu.xyR[i][j] = 0.0;
      }
      cu.xyR[i][i] = 1.0;
      for (j = i + 1; j < n; j++) {
         cu.xyR[i][j] = ca.xyR[i][j];
      }
   }
   ae_matrix_set_length(&ca2, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(cl.xyR[i], 1, &cu.xyR[0][j], cu.stride, minmn);
         ca2.xyR[i][j] = v;
      }
   }
   ae_vector_set_length(&ct, m);
   for (i = minmn - 1; i >= 0; i--) {
      if (i != p.xZ[i]) {
         ae_v_move(ct.xR, 1, &ca2.xyR[0][i], ca2.stride, m);
         ae_v_move(&ca2.xyR[0][i], ca2.stride, &ca2.xyR[0][p.xZ[i]], ca2.stride, m);
         ae_v_move(&ca2.xyR[0][p.xZ[i]], ca2.stride, ct.xR, 1, m);
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         *err = *err || fabs(a->xyR[i][j] - ca2.xyR[i][j]) > threshold;
      }
   }
   ae_frame_leave();
}

static void testtrfacunit_testcluproblem(CMatrix *a, ae_int_t m, ae_int_t n, double threshold, bool *err, bool *properr) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t minmn;
   complex v;
   ae_frame_make(&_frame_block);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewMatrix(cl, 0, 0, DT_COMPLEX);
   NewMatrix(cu, 0, 0, DT_COMPLEX);
   NewMatrix(ca2, 0, 0, DT_COMPLEX);
   NewVector(ct, 0, DT_COMPLEX);
   NewVector(p, 0, DT_INT);
   minmn = imin2(m, n);
// PLU test
   ae_matrix_set_length(&ca, m, n);
   for (i = 0; i < m; i++) {
      ae_v_cmove(ca.xyC[i], 1, a->xyC[i], 1, "N", n);
   }
   cmatrixplu(&ca, m, n, &p);
   for (i = 0; i < minmn; i++) {
      if (p.xZ[i] < i || p.xZ[i] >= m) {
         *properr = true;
         ae_frame_leave();
         return;
      }
   }
   ae_matrix_set_length(&cl, m, minmn);
   for (j = 0; j < minmn; j++) {
      for (i = 0; i < j; i++) {
         cl.xyC[i][j] = complex_from_d(0.0);
      }
      cl.xyC[j][j] = complex_from_d(1.0);
      for (i = j + 1; i < m; i++) {
         cl.xyC[i][j] = ca.xyC[i][j];
      }
   }
   ae_matrix_set_length(&cu, minmn, n);
   for (i = 0; i < minmn; i++) {
      for (j = 0; j < i; j++) {
         cu.xyC[i][j] = complex_from_d(0.0);
      }
      for (j = i; j < n; j++) {
         cu.xyC[i][j] = ca.xyC[i][j];
      }
   }
   ae_matrix_set_length(&ca2, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(cl.xyC[i], 1, "N", &cu.xyC[0][j], cu.stride, "N", minmn);
         ca2.xyC[i][j] = v;
      }
   }
   ae_vector_set_length(&ct, n);
   for (i = minmn - 1; i >= 0; i--) {
      if (i != p.xZ[i]) {
         ae_v_cmove(ct.xC, 1, ca2.xyC[i], 1, "N", n);
         ae_v_cmove(ca2.xyC[i], 1, ca2.xyC[p.xZ[i]], 1, "N", n);
         ae_v_cmove(ca2.xyC[p.xZ[i]], 1, ct.xC, 1, "N", n);
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         *err = *err || abscomplex(ae_c_sub(a->xyC[i][j], ca2.xyC[i][j])) > threshold;
      }
   }
// LUP test
   ae_matrix_set_length(&ca, m, n);
   for (i = 0; i < m; i++) {
      ae_v_cmove(ca.xyC[i], 1, a->xyC[i], 1, "N", n);
   }
   cmatrixlup(&ca, m, n, &p);
   for (i = 0; i < minmn; i++) {
      if (p.xZ[i] < i || p.xZ[i] >= n) {
         *properr = true;
         ae_frame_leave();
         return;
      }
   }
   ae_matrix_set_length(&cl, m, minmn);
   for (j = 0; j < minmn; j++) {
      for (i = 0; i < j; i++) {
         cl.xyC[i][j] = complex_from_d(0.0);
      }
      for (i = j; i < m; i++) {
         cl.xyC[i][j] = ca.xyC[i][j];
      }
   }
   ae_matrix_set_length(&cu, minmn, n);
   for (i = 0; i < minmn; i++) {
      for (j = 0; j < i; j++) {
         cu.xyC[i][j] = complex_from_d(0.0);
      }
      cu.xyC[i][i] = complex_from_d(1.0);
      for (j = i + 1; j < n; j++) {
         cu.xyC[i][j] = ca.xyC[i][j];
      }
   }
   ae_matrix_set_length(&ca2, m, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_cdotproduct(cl.xyC[i], 1, "N", &cu.xyC[0][j], cu.stride, "N", minmn);
         ca2.xyC[i][j] = v;
      }
   }
   ae_vector_set_length(&ct, m);
   for (i = minmn - 1; i >= 0; i--) {
      if (i != p.xZ[i]) {
         ae_v_cmove(ct.xC, 1, &ca2.xyC[0][i], ca2.stride, "N", m);
         ae_v_cmove(&ca2.xyC[0][i], ca2.stride, &ca2.xyC[0][p.xZ[i]], ca2.stride, "N", m);
         ae_v_cmove(&ca2.xyC[0][p.xZ[i]], ca2.stride, ct.xC, 1, "N", m);
      }
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         *err = *err || abscomplex(ae_c_sub(a->xyC[i][j], ca2.xyC[i][j])) > threshold;
      }
   }
   ae_frame_leave();
}

// Function for testing dense Cholesky updates
// Sets error flag to True on errors, does not change it on success.
//
// ALGLIB Project: Copyright 16.01.1014 by Sergey Bochkanov
static void testtrfacunit_testdensecholeskyupdates(bool *spdupderrorflag) {
   ae_frame _frame_block;
   ae_int_t n;
   double pfix;
   ae_int_t i;
   ae_int_t j;
   bool isupper;
   double tol;
   ae_frame_make(&_frame_block);
   NewMatrix(a0, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(u, 0, DT_REAL);
   NewVector(fix, 0, DT_BOOL);
   NewVector(bufr, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Settings
   tol = 1.0E-8;
// Test rank-1 updates
//
// For each matrix size in 1..30 select sparse update vector with probability of element
// being non-zero equal to 1/2.
   for (n = 1; n <= 30; n++) {
   // Generate two matrices A0=A1, fill one triangle with SPD matrix,
   // another one with trash. Prepare vector U.
      isupper = hqrnduniformr(&rs) < 0.5;
      spdmatrixrndcond(n, 1.0E4, &a0);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (isupper ? j < i : j > i) {
               a0.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
            }
         }
      }
      ae_matrix_set_length(&a1, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a1.xyR[i][j] = a0.xyR[i][j];
         }
      }
      ae_vector_set_length(&u, n);
      for (i = 0; i < n; i++) {
         if (hqrnduniformr(&rs) <= 0.5) {
            u.xR[i] = hqrnduniformr(&rs) - 0.5;
         } else {
            u.xR[i] = 0.0;
         }
      }
   // Factorize and compare:
   // * A0 is factorized as follows: first with full Cholesky, then
   //   we call SPDMatrixCholeskyUpdateAdd1
   // * A1 is transformed explicitly before factorization with full Cholesky
   //
   // We randomly test either SPDMatrixCholeskyUpdateFix() or its
   // buffered version, SPDMatrixCholeskyUpdateFixBuf()
      set_error_flag(spdupderrorflag, !spdmatrixcholesky(&a0, n, isupper), __FILE__, __LINE__, "testtrfacunit.ap:1772");
      if (*spdupderrorflag) {
         ae_frame_leave();
         return;
      }
      if (hqrnduniformr(&rs) < 0.5) {
         spdmatrixcholeskyupdateadd1(&a0, n, isupper, &u);
      } else {
         spdmatrixcholeskyupdateadd1buf(&a0, n, isupper, &u, &bufr);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (isupper ? j >= i : j <= i) {
               a1.xyR[i][j] += u.xR[i] * u.xR[j];
            }
         }
      }
      set_error_flag(spdupderrorflag, !spdmatrixcholesky(&a1, n, isupper), __FILE__, __LINE__, "testtrfacunit.ap:1783");
      if (*spdupderrorflag) {
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            set_error_flag(spdupderrorflag, fabs(a0.xyR[i][j] - a1.xyR[i][j]) > tol, __FILE__, __LINE__, "testtrfacunit.ap:1788");
         }
      }
   }
// Test variable fixing functions.
//
// For each matrix size in 1..30 select PFix - probability of each variable being fixed,
// and perform test.
   for (n = 1; n <= 30; n++) {
   // Generate two matrices A0=A1, fill one triangle with SPD matrix,
   // another one with trash. Prepare vector Fix.
      pfix = (double)hqrnduniformi(&rs, n + 1) / n;
      isupper = hqrnduniformr(&rs) < 0.5;
      spdmatrixrndcond(n, 1.0E4, &a0);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (isupper ? j < i : j > i) {
               a0.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
            }
         }
      }
      ae_matrix_set_length(&a1, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a1.xyR[i][j] = a0.xyR[i][j];
         }
      }
      ae_vector_set_length(&fix, n);
      for (i = 0; i < n; i++) {
         fix.xB[i] = hqrnduniformr(&rs) <= pfix;
      }
   // Factorize and compare:
   // * A0 is factorized as follows: first with full Cholesky, then
   //   variables are fixed with SPDMatrixCholeskyUpdateFix
   // * A1 is fixed explicitly before factorization with full Cholesky
   //
   // We randomly test either SPDMatrixCholeskyUpdateFix() or its
   // buffered version, SPDMatrixCholeskyUpdateFixBuf()
      set_error_flag(spdupderrorflag, !spdmatrixcholesky(&a0, n, isupper), __FILE__, __LINE__, "testtrfacunit.ap:1827");
      if (*spdupderrorflag) {
         ae_frame_leave();
         return;
      }
      if (hqrnduniformr(&rs) < 0.5) {
         spdmatrixcholeskyupdatefixbuf(&a0, n, isupper, &fix, &bufr);
      } else {
         spdmatrixcholeskyupdatefix(&a0, n, isupper, &fix);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (isupper ? j >= i : j <= i) {
               if (fix.xB[i] || fix.xB[j]) {
                  if (i == j) {
                     a1.xyR[i][j] = 1.0;
                  } else {
                     a1.xyR[i][j] = 0.0;
                  }
               }
            }
         }
      }
      set_error_flag(spdupderrorflag, !spdmatrixcholesky(&a1, n, isupper), __FILE__, __LINE__, "testtrfacunit.ap:1844");
      if (*spdupderrorflag) {
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            set_error_flag(spdupderrorflag, fabs(a0.xyR[i][j] - a1.xyR[i][j]) > tol, __FILE__, __LINE__, "testtrfacunit.ap:1849");
         }
      }
   }
   ae_frame_leave();
}

bool testtrfac(bool silent) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t mx;
   ae_int_t maxmn;
   ae_int_t largemn;
   ae_int_t i;
   ae_int_t j;
   complex vc;
   double vr;
   bool waserrors;
   bool dspderr;
   bool sspderr;
   bool srerr;
   bool hpderr;
   bool rerr;
   bool cerr;
   bool properr;
   bool dspdupderr;
   double threshold;
   ae_int_t pass;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(ra, 0, 0, DT_REAL);
   NewMatrix(ral, 0, 0, DT_REAL);
   NewMatrix(rau, 0, 0, DT_REAL);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewMatrix(cal, 0, 0, DT_COMPLEX);
   NewMatrix(cau, 0, 0, DT_COMPLEX);
   rerr = false;
   dspderr = false;
   sspderr = false;
   cerr = false;
   hpderr = false;
   properr = false;
   dspdupderr = false;
   srerr = false;
   waserrors = false;
   maxmn = 4 * matrixtilesizea() + 1;
   largemn = 256;
   threshold = 1000 * machineepsilon * maxmn;
// Sparse Cholesky
   sspderr = sparserealcholeskytest();
// Sparse LU
   sparsereallutest(&srerr);
// Cholesky updates
   testtrfacunit_testdensecholeskyupdates(&dspdupderr);
// test LU:
// * first, test on small-scale matrices
// * then, perform several large-scale tests
   for (mx = 1; mx <= maxmn; mx++) {
   // Initialize N/M, both are <= MX,
   // at least one of them is exactly equal to MX
      n = 1 + randominteger(mx);
      m = 1 + randominteger(mx);
      if (randombool()) {
         n = mx;
      } else {
         m = mx;
      }
   // First, test on zero matrix
      ae_matrix_set_length(&ra, m, n);
      ae_matrix_set_length(&ca, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            ra.xyR[i][j] = 0.0;
            ca.xyC[i][j] = complex_from_i(0);
         }
      }
      testtrfacunit_testcluproblem(&ca, m, n, threshold, &cerr, &properr);
      testtrfacunit_testrluproblem(&ra, m, n, threshold, &rerr, &properr);
   // Second, random matrix with moderate condition number
      ae_matrix_set_length(&ra, m, n);
      ae_matrix_set_length(&ca, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            ra.xyR[i][j] = 0.0;
            ca.xyC[i][j] = complex_from_i(0);
         }
      }
      for (i = 0; i < imin2(m, n); i++) {
         ra.xyR[i][i] = 1 + 10 * randomreal();
         ca.xyC[i][i] = complex_from_d(1 + 10 * randomreal());
      }
      cmatrixrndorthogonalfromtheleft(&ca, m, n);
      cmatrixrndorthogonalfromtheright(&ca, m, n);
      rmatrixrndorthogonalfromtheleft(&ra, m, n);
      rmatrixrndorthogonalfromtheright(&ra, m, n);
      testtrfacunit_testcluproblem(&ca, m, n, threshold, &cerr, &properr);
      testtrfacunit_testrluproblem(&ra, m, n, threshold, &rerr, &properr);
   }
   for (pass = 1; pass <= 2; pass++) {
      m = largemn + (randominteger(3) - 1);
      n = largemn + (randominteger(3) - 1);
   // Random matrix with moderate condition number
      ae_matrix_set_length(&ra, m, n);
      ae_matrix_set_length(&ca, m, n);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            ra.xyR[i][j] = 0.0;
            ca.xyC[i][j] = complex_from_i(0);
         }
      }
      for (i = 0; i < imin2(m, n); i++) {
         ra.xyR[i][i] = 1 + 10 * randomreal();
         ca.xyC[i][i] = complex_from_d(1 + 10 * randomreal());
      }
      cmatrixrndorthogonalfromtheleft(&ca, m, n);
      cmatrixrndorthogonalfromtheright(&ca, m, n);
      rmatrixrndorthogonalfromtheleft(&ra, m, n);
      rmatrixrndorthogonalfromtheright(&ra, m, n);
      testtrfacunit_testcluproblem(&ca, m, n, threshold, &cerr, &properr);
      testtrfacunit_testrluproblem(&ra, m, n, threshold, &rerr, &properr);
   }
// Test Cholesky
   for (n = 1; n <= maxmn; n++) {
   // Load CA (HPD matrix with low condition number),
   //      CAL and CAU - its lower and upper triangles
      hpdmatrixrndcond(n, 1 + 50 * randomreal(), &ca);
      ae_matrix_set_length(&cal, n, n);
      ae_matrix_set_length(&cau, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            cal.xyC[i][j] = complex_from_i(i);
            cau.xyC[i][j] = complex_from_i(j);
         }
      }
      for (i = 0; i < n; i++) {
         ae_v_cmove(cal.xyC[i], 1, ca.xyC[i], 1, "N", i + 1);
         ae_v_cmove(&cau.xyC[i][i], 1, &ca.xyC[i][i], 1, "N", n - i);
      }
   // Test HPDMatrixCholesky:
   // 1. it must leave upper (lower) part unchanged
   // 2. max(A-L*L^H) must be small
      if (hpdmatrixcholesky(&cal, n, false)) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (j > i) {
                  hpderr = hpderr || ae_c_neq_d(cal.xyC[i][j], (double)i);
               } else {
                  vc = ae_v_cdotproduct(cal.xyC[i], 1, "N", cal.xyC[j], 1, "Conj", j + 1);
                  hpderr = hpderr || abscomplex(ae_c_sub(ca.xyC[i][j], vc)) > threshold;
               }
            }
         }
      } else {
         hpderr = true;
      }
      if (hpdmatrixcholesky(&cau, n, true)) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (j < i) {
                  hpderr = hpderr || ae_c_neq_d(cau.xyC[i][j], (double)j);
               } else {
                  vc = ae_v_cdotproduct(&cau.xyC[0][i], cau.stride, "Conj", &cau.xyC[0][j], cau.stride, "N", i + 1);
                  hpderr = hpderr || abscomplex(ae_c_sub(ca.xyC[i][j], vc)) > threshold;
               }
            }
         }
      } else {
         hpderr = true;
      }
   // Load RA (SPD matrix with low condition number),
   //      RAL and RAU - its lower and upper triangles
   //
   // Test SPDMatrixCholesky:
   // 1. it must leave upper (lower) part unchanged
   // 2. max(A-L*L^H) must be small
   //
   // After testing SPDMatrixCholesky() we compare results
   // returned by SparseCholeskyX() against ones returned
   // by SPDMatrixCholesky().
      spdmatrixrndcond(n, 1 + 50 * randomreal(), &ra);
      ae_matrix_set_length(&ral, n, n);
      ae_matrix_set_length(&rau, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            ral.xyR[i][j] = (double)i;
            rau.xyR[i][j] = (double)j;
         }
      }
      for (i = 0; i < n; i++) {
         ae_v_move(ral.xyR[i], 1, ra.xyR[i], 1, i + 1);
         ae_v_move(&rau.xyR[i][i], 1, &ra.xyR[i][i], 1, n - i);
      }
      if (spdmatrixcholesky(&ral, n, false)) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (j > i) {
                  dspderr = dspderr || ral.xyR[i][j] != (double)i;
               } else {
                  vr = ae_v_dotproduct(ral.xyR[i], 1, ral.xyR[j], 1, j + 1);
                  dspderr = dspderr || fabs(ra.xyR[i][j] - vr) > threshold;
               }
            }
         }
      } else {
         dspderr = true;
      }
      if (spdmatrixcholesky(&rau, n, true)) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (j < i) {
                  dspderr = dspderr || rau.xyR[i][j] != (double)j;
               } else {
                  vr = ae_v_dotproduct(&rau.xyR[0][i], rau.stride, &rau.xyR[0][j], rau.stride, i + 1);
                  dspderr = dspderr || fabs(ra.xyR[i][j] - vr) > threshold;
               }
            }
         }
      } else {
         dspderr = true;
      }
   // Check algorithms on negative definite matrices -
   // correct error code must be returned.
      ae_matrix_set_length(&ra, n, n);
      ae_matrix_set_length(&ca, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            ra.xyR[i][j] = 0.0;
            ca.xyC[i][j] = complex_from_d(0.0);
         }
         ra.xyR[i][i] = 1.0;
         ca.xyC[i][i] = complex_from_d(1.0);
      }
      ra.xyR[n / 2][n / 2] = -1.0;
      ca.xyC[n / 2][n / 2] = complex_from_d(-1.0);
      set_error_flag(&dspderr, spdmatrixcholesky(&ra, n, randombool()), __FILE__, __LINE__, "testtrfacunit.ap:509");
      set_error_flag(&hpderr, hpdmatrixcholesky(&ca, n, randombool()), __FILE__, __LINE__, "testtrfacunit.ap:510");
   }
// report
   waserrors = ((((((rerr || srerr) || dspderr) || sspderr) || cerr) || hpderr) || properr) || dspdupderr;
   if (!silent) {
      printf("TESTING TRIANGULAR FACTORIZATIONS\n");
      printf("* REAL (dense):                          ");
      if (rerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* REAL (sparse):                         ");
      if (srerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* SPD (dense)                            ");
      if (dspderr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* SPD (sparse)                           ");
      if (sspderr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* COMPLEX:                               ");
      if (cerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* HPD:                                   ");
      if (hpderr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* OTHER PROPERTIES:                      ");
      if (properr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("TESTING UPDATED FACTORIZATIONS\n");
      printf("* SPD (dense)                            ");
      if (dspdupderr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === polynomialsolver testing unit ===
// Test
bool testpolynomialsolver(bool silent) {
   ae_frame _frame_block;
   bool wereerrors;
   double eps;
   ae_int_t n;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(a, 0, DT_REAL);
   NewVector(x, 0, DT_COMPLEX);
   NewObj(polynomialsolverreport, rep);
   wereerrors = false;
// Basic tests
   eps = 1.0E-6;
   n = 1;
   ae_vector_set_length(&a, n + 1);
   a.xR[0] = 2.0;
   a.xR[1] = 3.0;
   polynomialsolve(&a, n, &x, &rep);
   set_error_flag(&wereerrors, fabs(x.xC[0].x + 2.0 / 3.0) > eps, __FILE__, __LINE__, "testpolynomialsolverunit.ap:33");
   set_error_flag(&wereerrors, x.xC[0].y != 0.0, __FILE__, __LINE__, "testpolynomialsolverunit.ap:34");
   set_error_flag(&wereerrors, rep.maxerr > 100 * machineepsilon, __FILE__, __LINE__, "testpolynomialsolverunit.ap:35");
   n = 2;
   ae_vector_set_length(&a, n + 1);
   a.xR[0] = 1.0;
   a.xR[1] = -2.0;
   a.xR[2] = 1.0;
   polynomialsolve(&a, n, &x, &rep);
   set_error_flag(&wereerrors, abscomplex(ae_c_sub_d(x.xC[0], 1)) > eps, __FILE__, __LINE__, "testpolynomialsolverunit.ap:43");
   set_error_flag(&wereerrors, abscomplex(ae_c_sub_d(x.xC[1], 1)) > eps, __FILE__, __LINE__, "testpolynomialsolverunit.ap:44");
   set_error_flag(&wereerrors, rep.maxerr > 100 * machineepsilon, __FILE__, __LINE__, "testpolynomialsolverunit.ap:45");
   n = 2;
   ae_vector_set_length(&a, n + 1);
   a.xR[0] = 2.0;
   a.xR[1] = -3.0;
   a.xR[2] = 1.0;
   polynomialsolve(&a, n, &x, &rep);
   if (x.xC[0].x < x.xC[1].x) {
      set_error_flag(&wereerrors, fabs(x.xC[0].x - 1) > eps, __FILE__, __LINE__, "testpolynomialsolverunit.ap:55");
      set_error_flag(&wereerrors, fabs(x.xC[1].x - 2) > eps, __FILE__, __LINE__, "testpolynomialsolverunit.ap:56");
   } else {
      set_error_flag(&wereerrors, fabs(x.xC[0].x - 2) > eps, __FILE__, __LINE__, "testpolynomialsolverunit.ap:60");
      set_error_flag(&wereerrors, fabs(x.xC[1].x - 1) > eps, __FILE__, __LINE__, "testpolynomialsolverunit.ap:61");
   }
   set_error_flag(&wereerrors, x.xC[0].y != 0.0, __FILE__, __LINE__, "testpolynomialsolverunit.ap:63");
   set_error_flag(&wereerrors, x.xC[1].y != 0.0, __FILE__, __LINE__, "testpolynomialsolverunit.ap:64");
   set_error_flag(&wereerrors, rep.maxerr > 100 * machineepsilon, __FILE__, __LINE__, "testpolynomialsolverunit.ap:65");
   n = 2;
   ae_vector_set_length(&a, n + 1);
   a.xR[0] = 1.0;
   a.xR[1] = 0.0;
   a.xR[2] = 1.0;
   polynomialsolve(&a, n, &x, &rep);
   set_error_flag(&wereerrors, abscomplex(ae_c_add_d(ae_c_mul(x.xC[0], x.xC[0]), 1.0)) > eps, __FILE__, __LINE__, "testpolynomialsolverunit.ap:73");
   set_error_flag(&wereerrors, rep.maxerr > 100 * machineepsilon, __FILE__, __LINE__, "testpolynomialsolverunit.ap:74");
   n = 4;
   ae_vector_set_length(&a, n + 1);
   a.xR[0] = 0.0;
   a.xR[1] = 0.0;
   a.xR[2] = 0.0;
   a.xR[3] = 0.0;
   a.xR[4] = 1.0;
   polynomialsolve(&a, n, &x, &rep);
   set_error_flag(&wereerrors, ae_c_neq_d(x.xC[0], 0.0), __FILE__, __LINE__, "testpolynomialsolverunit.ap:84");
   set_error_flag(&wereerrors, ae_c_neq_d(x.xC[1], 0.0), __FILE__, __LINE__, "testpolynomialsolverunit.ap:85");
   set_error_flag(&wereerrors, ae_c_neq_d(x.xC[2], 0.0), __FILE__, __LINE__, "testpolynomialsolverunit.ap:86");
   set_error_flag(&wereerrors, ae_c_neq_d(x.xC[3], 0.0), __FILE__, __LINE__, "testpolynomialsolverunit.ap:87");
   set_error_flag(&wereerrors, rep.maxerr > 100 * machineepsilon, __FILE__, __LINE__, "testpolynomialsolverunit.ap:88");
   n = 2;
   ae_vector_set_length(&a, n + 1);
   a.xR[0] = 0.0;
   a.xR[1] = 3.0;
   a.xR[2] = 2.0;
   polynomialsolve(&a, n, &x, &rep);
   if (x.xC[0].x > x.xC[1].x) {
      set_error_flag(&wereerrors, ae_c_neq_d(x.xC[0], 0.0), __FILE__, __LINE__, "testpolynomialsolverunit.ap:98");
      set_error_flag(&wereerrors, fabs(x.xC[1].x + 3.0 / 2.0) > eps, __FILE__, __LINE__, "testpolynomialsolverunit.ap:99");
      set_error_flag(&wereerrors, x.xC[1].y != 0.0, __FILE__, __LINE__, "testpolynomialsolverunit.ap:100");
   } else {
      set_error_flag(&wereerrors, ae_c_neq_d(x.xC[1], 0.0), __FILE__, __LINE__, "testpolynomialsolverunit.ap:104");
      set_error_flag(&wereerrors, fabs(x.xC[0].x + 3.0 / 2.0) > eps, __FILE__, __LINE__, "testpolynomialsolverunit.ap:105");
      set_error_flag(&wereerrors, x.xC[0].y != 0.0, __FILE__, __LINE__, "testpolynomialsolverunit.ap:106");
   }
   set_error_flag(&wereerrors, rep.maxerr > 100 * machineepsilon, __FILE__, __LINE__, "testpolynomialsolverunit.ap:108");
   if (!silent) {
      printf("TESTING POLYNOMIAL SOLVER\n");
      if (wereerrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
   }
   result = !wereerrors;
   ae_frame_leave();
   return result;
}

// === bdsvd testing unit ===
static void testbdsvdunit_fillidentity(RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_matrix_set_length(a, n - 1 + 1, n - 1 + 1);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (i == j) {
            a->xyR[i][j] = 1.0;
         } else {
            a->xyR[i][j] = 0.0;
         }
      }
   }
}

static void testbdsvdunit_fillsparsede(RVector *d, RVector *e, ae_int_t n, double sparsity) {
   ae_int_t i;
   ae_vector_set_length(d, n - 1 + 1);
   ae_vector_set_length(e, imax2(0, n - 2) + 1);
   for (i = 0; i < n; i++) {
      if (randombool(sparsity)) {
         d->xR[i] = 0.0;
      } else {
         d->xR[i] = randommid();
      }
   }
   for (i = 0; i < n - 1; i++) {
      if (randombool(sparsity)) {
         e->xR[i] = 0.0;
      } else {
         e->xR[i] = randommid();
      }
   }
}

static void testbdsvdunit_getbdsvderror(RVector *d, RVector *e, ae_int_t n, bool isupper, RMatrix *u, RMatrix *c, RVector *w, RMatrix *vt, double *materr, double *orterr, bool *wsorted) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double locerr;
   double sm;
// decomposition error
   locerr = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         sm = 0.0;
         for (k = 0; k < n; k++) {
            sm += w->xR[k] * u->xyR[i][k] * vt->xyR[k][j];
         }
         if (isupper) {
            if (i == j) {
               locerr = rmax2(locerr, fabs(d->xR[i] - sm));
            } else {
               if (i == j - 1) {
                  locerr = rmax2(locerr, fabs(e->xR[i] - sm));
               } else {
                  locerr = rmax2(locerr, fabs(sm));
               }
            }
         } else {
            if (i == j) {
               locerr = rmax2(locerr, fabs(d->xR[i] - sm));
            } else {
               if (i - 1 == j) {
                  locerr = rmax2(locerr, fabs(e->xR[j] - sm));
               } else {
                  locerr = rmax2(locerr, fabs(sm));
               }
            }
         }
      }
   }
   *materr = rmax2(*materr, locerr);
// check for C = U'
// we consider it as decomposition error
   locerr = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         locerr = rmax2(locerr, fabs(u->xyR[i][j] - c->xyR[j][i]));
      }
   }
   *materr = rmax2(*materr, locerr);
// orthogonality error
   locerr = 0.0;
   for (i = 0; i < n; i++) {
      for (j = i; j < n; j++) {
         sm = ae_v_dotproduct(&u->xyR[0][i], u->stride, &u->xyR[0][j], u->stride, n);
         if (i != j) {
            locerr = rmax2(locerr, fabs(sm));
         } else {
            locerr = rmax2(locerr, fabs(sm - 1));
         }
         sm = ae_v_dotproduct(vt->xyR[i], 1, vt->xyR[j], 1, n);
         if (i != j) {
            locerr = rmax2(locerr, fabs(sm));
         } else {
            locerr = rmax2(locerr, fabs(sm - 1));
         }
      }
   }
   *orterr = rmax2(*orterr, locerr);
// values order error
   for (i = 1; i < n; i++) {
      if (w->xR[i] > w->xR[i - 1]) {
         *wsorted = false;
      }
   }
}

static void testbdsvdunit_checksvdmultiplication(RVector *d, RVector *e, ae_int_t n, bool isupper, RMatrix *u, RMatrix *c, RVector *w, RMatrix *vt, double *err) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t nru;
   ae_int_t ncc;
   ae_int_t ncvt;
   ae_int_t pass;
   double v;
   ae_frame_make(&_frame_block);
   NewVector(wt, 0, DT_REAL);
   NewMatrix(u2, 0, 0, DT_REAL);
   NewMatrix(c2, 0, 0, DT_REAL);
   NewMatrix(vt2, 0, 0, DT_REAL);
   NewMatrix(u1, 0, 0, DT_REAL);
   NewMatrix(c1, 0, 0, DT_REAL);
   NewMatrix(vt1, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   ae_vector_set_length(&wt, n);
// Perform nonsquare SVD
   for (pass = 1; pass <= 20; pass++) {
   // Problem size
      nru = hqrnduniformi(&rs, 2 * n);
      ncc = hqrnduniformi(&rs, 2 * n);
      ncvt = hqrnduniformi(&rs, 2 * n);
   // Reference matrices (copy 1) and working matrices (copy 2)
      for (i = 0; i < n; i++) {
         wt.xR[i] = d->xR[i];
      }
      if (nru > 0) {
      // init U1/U2
         ae_matrix_set_length(&u1, nru, n);
         ae_matrix_set_length(&u2, nru, n);
         for (i = 0; i < u1.rows; i++) {
            for (j = 0; j < u1.cols; j++) {
               u1.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               u2.xyR[i][j] = u1.xyR[i][j];
            }
         }
      } else {
      // Set U1/U2 to 1x1 matrices; working with 1x1 matrices allows
      // to test correctness of code which passes them to MKL.
         ae_matrix_set_length(&u1, 1, 1);
         ae_matrix_set_length(&u2, 1, 1);
      }
      if (ncc > 0) {
         ae_matrix_set_length(&c1, n, ncc);
         ae_matrix_set_length(&c2, n, ncc);
         for (i = 0; i < c1.rows; i++) {
            for (j = 0; j < c1.cols; j++) {
               c1.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               c2.xyR[i][j] = c1.xyR[i][j];
            }
         }
      } else {
      // Set C1/C1 to 1x1 matrices; working with 1x1 matrices allows
      // to test correctness of code which passes them to MKL.
         ae_matrix_set_length(&c1, 1, 1);
         ae_matrix_set_length(&c2, 1, 1);
      }
      if (ncvt > 0) {
         ae_matrix_set_length(&vt1, n, ncvt);
         ae_matrix_set_length(&vt2, n, ncvt);
         for (i = 0; i < vt1.rows; i++) {
            for (j = 0; j < vt1.cols; j++) {
               vt1.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               vt2.xyR[i][j] = vt1.xyR[i][j];
            }
         }
      } else {
      // Set VT1/VT1 to 1x1 matrices; working with 1x1 matrices allows
      // to test correctness of code which passes them to MKL.
         ae_matrix_set_length(&vt1, 1, 1);
         ae_matrix_set_length(&vt2, 1, 1);
      }
   // SVD with non-square U/C/VT
      if (!rmatrixbdsvd(&wt, e, n, isupper, hqrnduniformr(&rs) > 0.0, &u2, nru, &c2, ncc, &vt2, ncvt)) {
         *err = 1.0;
         ae_frame_leave();
         return;
      }
      for (i = 0; i < nru; i++) {
         for (j = 0; j < u2.cols; j++) {
            v = ae_v_dotproduct(u1.xyR[i], 1, &u->xyR[0][j], u->stride, n);
            *err = rmax2(*err, fabs(v - u2.xyR[i][j]));
         }
      }
      for (i = 0; i < c2.rows; i++) {
         for (j = 0; j < ncc; j++) {
            v = ae_v_dotproduct(c->xyR[i], 1, &c1.xyR[0][j], c1.stride, n);
            *err = rmax2(*err, fabs(v - c2.xyR[i][j]));
         }
      }
      for (i = 0; i < vt2.rows; i++) {
         for (j = 0; j < ncvt; j++) {
            v = ae_v_dotproduct(vt->xyR[i], 1, &vt1.xyR[0][j], vt1.stride, n);
            *err = rmax2(*err, fabs(v - vt2.xyR[i][j]));
         }
      }
   }
   ae_frame_leave();
}

static void testbdsvdunit_testbdsvdproblem(RVector *d, RVector *e, ae_int_t n, double *materr, double *orterr, bool *wsorted, bool *wfailed, ae_int_t *failcount, ae_int_t *succcount) {
   ae_frame _frame_block;
   ae_int_t i;
   double mx;
   ae_frame_make(&_frame_block);
   NewMatrix(u, 0, 0, DT_REAL);
   NewMatrix(vt, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   mx = 0.0;
   for (i = 0; i < n; i++) {
      if (fabs(d->xR[i]) > mx) {
         mx = fabs(d->xR[i]);
      }
   }
   for (i = 0; i < n - 1; i++) {
      if (fabs(e->xR[i]) > mx) {
         mx = fabs(e->xR[i]);
      }
   }
   if (mx == 0.0) {
      mx = 1.0;
   }
// Upper BDSVD tests
   ae_vector_set_length(&w, n - 1 + 1);
   testbdsvdunit_fillidentity(&u, n);
   testbdsvdunit_fillidentity(&vt, n);
   testbdsvdunit_fillidentity(&c, n);
   for (i = 0; i < n; i++) {
      w.xR[i] = d->xR[i];
   }
   if (!rmatrixbdsvd(&w, e, n, true, false, &u, n, &c, n, &vt, n)) {
      ++*failcount;
      *wfailed = true;
      ae_frame_leave();
      return;
   }
   testbdsvdunit_getbdsvderror(d, e, n, true, &u, &c, &w, &vt, materr, orterr, wsorted);
   testbdsvdunit_checksvdmultiplication(d, e, n, true, &u, &c, &w, &vt, materr);
   testbdsvdunit_fillidentity(&u, n);
   testbdsvdunit_fillidentity(&vt, n);
   testbdsvdunit_fillidentity(&c, n);
   for (i = 0; i < n; i++) {
      w.xR[i] = d->xR[i];
   }
   if (!rmatrixbdsvd(&w, e, n, true, true, &u, n, &c, n, &vt, n)) {
      ++*failcount;
      *wfailed = true;
      ae_frame_leave();
      return;
   }
   testbdsvdunit_getbdsvderror(d, e, n, true, &u, &c, &w, &vt, materr, orterr, wsorted);
   testbdsvdunit_checksvdmultiplication(d, e, n, true, &u, &c, &w, &vt, materr);
// Lower BDSVD tests
   ae_vector_set_length(&w, n - 1 + 1);
   testbdsvdunit_fillidentity(&u, n);
   testbdsvdunit_fillidentity(&vt, n);
   testbdsvdunit_fillidentity(&c, n);
   for (i = 0; i < n; i++) {
      w.xR[i] = d->xR[i];
   }
   if (!rmatrixbdsvd(&w, e, n, false, false, &u, n, &c, n, &vt, n)) {
      ++*failcount;
      *wfailed = true;
      ae_frame_leave();
      return;
   }
   testbdsvdunit_getbdsvderror(d, e, n, false, &u, &c, &w, &vt, materr, orterr, wsorted);
   testbdsvdunit_checksvdmultiplication(d, e, n, false, &u, &c, &w, &vt, materr);
   testbdsvdunit_fillidentity(&u, n);
   testbdsvdunit_fillidentity(&vt, n);
   testbdsvdunit_fillidentity(&c, n);
   for (i = 0; i < n; i++) {
      w.xR[i] = d->xR[i];
   }
   if (!rmatrixbdsvd(&w, e, n, false, true, &u, n, &c, n, &vt, n)) {
      ++*failcount;
      *wfailed = true;
      ae_frame_leave();
      return;
   }
   testbdsvdunit_getbdsvderror(d, e, n, false, &u, &c, &w, &vt, materr, orterr, wsorted);
   testbdsvdunit_checksvdmultiplication(d, e, n, false, &u, &c, &w, &vt, materr);
// update counter
   ++*succcount;
   ae_frame_leave();
}

// Testing bidiagonal SVD decomposition subroutine
bool testbdsvd(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t i;
   ae_int_t pass;
   bool waserrors;
   bool wsorted;
   bool wfailed;
   double materr;
   double orterr;
   double threshold;
   double failr;
   ae_int_t failcount;
   ae_int_t succcount;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(d, 0, DT_REAL);
   NewVector(e, 0, DT_REAL);
   NewMatrix(mempty, 0, 0, DT_REAL);
   failcount = 0;
   succcount = 0;
   materr = 0.0;
   orterr = 0.0;
   wsorted = true;
   wfailed = false;
   waserrors = false;
   maxn = 15;
   threshold = 5 * 100 * machineepsilon;
   ae_vector_set_length(&d, maxn - 1 + 1);
   ae_vector_set_length(&e, maxn - 2 + 1);
// special case: zero divide matrix
// unfixed LAPACK routine should fail on this problem
   n = 7;
   d.xR[0] = -6.96462904751731892700e-01;
   d.xR[1] = 0.00000000000000000000e+00;
   d.xR[2] = -5.73827770385971991400e-01;
   d.xR[3] = -6.62562624399371191700e-01;
   d.xR[4] = 5.82737148001782223600e-01;
   d.xR[5] = 3.84825263580925003300e-01;
   d.xR[6] = 9.84087420830525472200e-01;
   e.xR[0] = -7.30307931760612871800e-02;
   e.xR[1] = -2.30079042939542843800e-01;
   e.xR[2] = -6.87824621739351216300e-01;
   e.xR[3] = -1.77306437707837570600e-02;
   e.xR[4] = 1.78285126526551632000e-15;
   e.xR[5] = -4.89434737751289969400e-02;
   rmatrixbdsvd(&d, &e, n, true, false, &mempty, 0, &mempty, 0, &mempty, 0);
// zero matrix, several cases
   for (i = 0; i < maxn; i++) {
      d.xR[i] = 0.0;
   }
   for (i = 0; i < maxn - 1; i++) {
      e.xR[i] = 0.0;
   }
   for (n = 1; n <= maxn; n++) {
      testbdsvdunit_testbdsvdproblem(&d, &e, n, &materr, &orterr, &wsorted, &wfailed, &failcount, &succcount);
   }
// Dense matrix
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= 10; pass++) {
         for (i = 0; i < maxn; i++) {
            d.xR[i] = randommid();
         }
         for (i = 0; i < maxn - 1; i++) {
            e.xR[i] = randommid();
         }
         testbdsvdunit_testbdsvdproblem(&d, &e, n, &materr, &orterr, &wsorted, &wfailed, &failcount, &succcount);
      }
   }
// Sparse matrices, very sparse matrices, incredible sparse matrices
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= 10; pass++) {
         testbdsvdunit_fillsparsede(&d, &e, n, 0.5);
         testbdsvdunit_testbdsvdproblem(&d, &e, n, &materr, &orterr, &wsorted, &wfailed, &failcount, &succcount);
         testbdsvdunit_fillsparsede(&d, &e, n, 0.8);
         testbdsvdunit_testbdsvdproblem(&d, &e, n, &materr, &orterr, &wsorted, &wfailed, &failcount, &succcount);
         testbdsvdunit_fillsparsede(&d, &e, n, 0.9);
         testbdsvdunit_testbdsvdproblem(&d, &e, n, &materr, &orterr, &wsorted, &wfailed, &failcount, &succcount);
         testbdsvdunit_fillsparsede(&d, &e, n, 0.95);
         testbdsvdunit_testbdsvdproblem(&d, &e, n, &materr, &orterr, &wsorted, &wfailed, &failcount, &succcount);
      }
   }
// report
   failr = (double)failcount / (succcount + failcount);
   waserrors = ((wfailed || materr > threshold) || orterr > threshold) || !wsorted;
   if (!silent) {
      printf("TESTING BIDIAGONAL SVD DECOMPOSITION\n");
      printf("SVD decomposition error:                 %5.3e\n", materr);
      printf("SVD orthogonality error:                 %5.3e\n", orterr);
      printf("Singular values order:                   ");
      if (wsorted) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("Always converged:                        ");
      if (!wfailed) {
         printf("YES\n");
      } else {
         printf("NO\n");
         printf("Fail ratio:                              %5.3f\n", failr);
      }
      printf("Threshold:                               %5.3e\n", threshold);
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === svd testing unit ===
static void testsvdunit_fillsparsea(RMatrix *a, ae_int_t m, ae_int_t n, double sparsity) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         if (randombool(sparsity)) {
            a->xyR[i][j] = 0.0;
         } else {
            a->xyR[i][j] = randommid();
         }
      }
   }
}

static void testsvdunit_getsvderror(RMatrix *a, ae_int_t m, ae_int_t n, RMatrix *u, RVector *w, RMatrix *vt, double *materr, double *orterr, bool *wsorted) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t minmn;
   double locerr;
   double sm;
   minmn = imin2(m, n);
// decomposition error
   locerr = 0.0;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         sm = 0.0;
         for (k = 0; k < minmn; k++) {
            sm += w->xR[k] * u->xyR[i][k] * vt->xyR[k][j];
         }
         locerr = rmax2(locerr, fabs(a->xyR[i][j] - sm));
      }
   }
   *materr = rmax2(*materr, locerr);
// orthogonality error
   locerr = 0.0;
   for (i = 0; i < minmn; i++) {
      for (j = i; j < minmn; j++) {
         sm = ae_v_dotproduct(&u->xyR[0][i], u->stride, &u->xyR[0][j], u->stride, m);
         if (i != j) {
            locerr = rmax2(locerr, fabs(sm));
         } else {
            locerr = rmax2(locerr, fabs(sm - 1));
         }
         sm = ae_v_dotproduct(vt->xyR[i], 1, vt->xyR[j], 1, n);
         if (i != j) {
            locerr = rmax2(locerr, fabs(sm));
         } else {
            locerr = rmax2(locerr, fabs(sm - 1));
         }
      }
   }
   *orterr = rmax2(*orterr, locerr);
// values order error
   for (i = 1; i < minmn; i++) {
      if (w->xR[i] > w->xR[i - 1]) {
         *wsorted = false;
      }
   }
}

static void testsvdunit_testsvdproblem(RMatrix *a, ae_int_t m, ae_int_t n, double *materr, double *orterr, double *othererr, bool *wsorted, bool *wfailed, ae_int_t *failcount, ae_int_t *succcount) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ujob;
   ae_int_t vtjob;
   ae_int_t memjob;
   ae_int_t ucheck;
   ae_int_t vtcheck;
   ae_frame_make(&_frame_block);
   NewMatrix(u, 0, 0, DT_REAL);
   NewMatrix(vt, 0, 0, DT_REAL);
   NewMatrix(u2, 0, 0, DT_REAL);
   NewMatrix(vt2, 0, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
// Main SVD test
   if (!rmatrixsvd(a, m, n, 2, 2, 2, &w, &u, &vt)) {
      ++*failcount;
      *wfailed = true;
      ae_frame_leave();
      return;
   }
   testsvdunit_getsvderror(a, m, n, &u, &w, &vt, materr, orterr, wsorted);
// Additional SVD tests
   for (ujob = 0; ujob <= 2; ujob++) {
      for (vtjob = 0; vtjob <= 2; vtjob++) {
         for (memjob = 0; memjob <= 2; memjob++) {
            if (!rmatrixsvd(a, m, n, ujob, vtjob, memjob, &w2, &u2, &vt2)) {
               ++*failcount;
               *wfailed = true;
               ae_frame_leave();
               return;
            }
            ucheck = 0;
            if (ujob == 1) {
               ucheck = imin2(m, n);
            }
            if (ujob == 2) {
               ucheck = m;
            }
            vtcheck = 0;
            if (vtjob == 1) {
               vtcheck = imin2(m, n);
            }
            if (vtjob == 2) {
               vtcheck = n;
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < ucheck; j++) {
                  *othererr = rmax2(*othererr, fabs(u.xyR[i][j] - u2.xyR[i][j]));
               }
            }
            for (i = 0; i < vtcheck; i++) {
               for (j = 0; j < n; j++) {
                  *othererr = rmax2(*othererr, fabs(vt.xyR[i][j] - vt2.xyR[i][j]));
               }
            }
            for (i = 0; i < imin2(m, n); i++) {
               *othererr = rmax2(*othererr, fabs(w.xR[i] - w2.xR[i]));
            }
         }
      }
   }
// update counter
   ++*succcount;
   ae_frame_leave();
}

// Testing SVD decomposition subroutine
bool testsvd(bool silent) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t maxmn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t gpass;
   ae_int_t pass;
   bool waserrors;
   bool wsorted;
   bool wfailed;
   double materr;
   double orterr;
   double othererr;
   double threshold;
   double failr;
   ae_int_t failcount;
   ae_int_t succcount;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   failcount = 0;
   succcount = 0;
   materr = 0.0;
   orterr = 0.0;
   othererr = 0.0;
   wsorted = true;
   wfailed = false;
   waserrors = false;
   maxmn = 30;
   threshold = 5 * 100 * machineepsilon;
   ae_matrix_set_length(&a, maxmn - 1 + 1, maxmn - 1 + 1);
// TODO: div by zero fail, convergence fail
   for (gpass = 1; gpass <= 1; gpass++) {
   // zero matrix, several cases
      for (i = 0; i < maxmn; i++) {
         for (j = 0; j < maxmn; j++) {
            a.xyR[i][j] = 0.0;
         }
      }
      for (i = 1; i <= imin2(5, maxmn); i++) {
         for (j = 1; j <= imin2(5, maxmn); j++) {
            testsvdunit_testsvdproblem(&a, i, j, &materr, &orterr, &othererr, &wsorted, &wfailed, &failcount, &succcount);
         }
      }
   // Long dense matrix
      for (i = 0; i < maxmn; i++) {
         for (j = 0; j < imin2(5, maxmn); j++) {
            a.xyR[i][j] = randommid();
         }
      }
      for (i = 1; i <= maxmn; i++) {
         for (j = 1; j <= imin2(5, maxmn); j++) {
            testsvdunit_testsvdproblem(&a, i, j, &materr, &orterr, &othererr, &wsorted, &wfailed, &failcount, &succcount);
         }
      }
      for (i = 0; i < imin2(5, maxmn); i++) {
         for (j = 0; j < maxmn; j++) {
            a.xyR[i][j] = randommid();
         }
      }
      for (i = 1; i <= imin2(5, maxmn); i++) {
         for (j = 1; j <= maxmn; j++) {
            testsvdunit_testsvdproblem(&a, i, j, &materr, &orterr, &othererr, &wsorted, &wfailed, &failcount, &succcount);
         }
      }
   // Dense matrices
      for (m = 1; m <= imin2(10, maxmn); m++) {
         for (n = 1; n <= imin2(10, maxmn); n++) {
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = randommid();
               }
            }
            testsvdunit_testsvdproblem(&a, m, n, &materr, &orterr, &othererr, &wsorted, &wfailed, &failcount, &succcount);
         }
      }
   // Sparse matrices, very sparse matrices, incredible sparse matrices
      for (m = 1; m <= 10; m++) {
         for (n = 1; n <= 10; n++) {
            for (pass = 1; pass <= 2; pass++) {
               testsvdunit_fillsparsea(&a, m, n, 0.8);
               testsvdunit_testsvdproblem(&a, m, n, &materr, &orterr, &othererr, &wsorted, &wfailed, &failcount, &succcount);
               testsvdunit_fillsparsea(&a, m, n, 0.9);
               testsvdunit_testsvdproblem(&a, m, n, &materr, &orterr, &othererr, &wsorted, &wfailed, &failcount, &succcount);
               testsvdunit_fillsparsea(&a, m, n, 0.95);
               testsvdunit_testsvdproblem(&a, m, n, &materr, &orterr, &othererr, &wsorted, &wfailed, &failcount, &succcount);
            }
         }
      }
   }
// report
   failr = (double)failcount / (succcount + failcount);
   waserrors = (((wfailed || materr > threshold) || orterr > threshold) || othererr > threshold) || !wsorted;
   if (!silent) {
      printf("TESTING SVD DECOMPOSITION\n");
      printf("SVD decomposition error:                 %5.3e\n", materr);
      printf("SVD orthogonality error:                 %5.3e\n", orterr);
      printf("SVD with different parameters error:     %5.3e\n", othererr);
      printf("Singular values order:                   ");
      if (wsorted) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("Always converged:                        ");
      if (!wfailed) {
         printf("YES\n");
      } else {
         printf("NO\n");
         printf("Fail ratio:                              %5.3f\n", failr);
      }
      printf("Threshold:                               %5.3e\n", threshold);
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === trlinsolve testing unit ===
// Main unittest subroutine
bool testtrlinsolve(bool silent) {
   ae_frame _frame_block;
   ae_int_t maxmn;
   ae_int_t passcount;
   double threshold;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t cnts;
   ae_int_t cntu;
   ae_int_t cntt;
   ae_int_t cntm;
   bool waserrors;
   bool isupper;
   bool istrans;
   bool isunit;
   double v;
   double s;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(aeffective, 0, 0, DT_REAL);
   NewMatrix(aparam, 0, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   waserrors = false;
   maxmn = 15;
   passcount = 15;
   threshold = 1000 * machineepsilon;
// Different problems
   for (n = 1; n <= maxmn; n++) {
      ae_matrix_set_length(&aeffective, n - 1 + 1, n - 1 + 1);
      ae_matrix_set_length(&aparam, n - 1 + 1, n - 1 + 1);
      ae_vector_set_length(&xe, n - 1 + 1);
      ae_vector_set_length(&b, n - 1 + 1);
      for (pass = 1; pass <= passcount; pass++) {
         for (cnts = 0; cnts <= 1; cnts++) {
            for (cntu = 0; cntu <= 1; cntu++) {
               for (cntt = 0; cntt <= 1; cntt++) {
                  for (cntm = 0; cntm <= 2; cntm++) {
                     isupper = cnts == 0;
                     isunit = cntu == 0;
                     istrans = cntt == 0;
                  // Skip meaningless combinations of parameters:
                  // (matrix is singular) AND (matrix is unit diagonal)
                     if (cntm == 2 && isunit) {
                        continue;
                     }
                  // Clear matrices
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           aeffective.xyR[i][j] = 0.0;
                           aparam.xyR[i][j] = 0.0;
                        }
                     }
                  // Prepare matrices
                     if (isupper) {
                        for (i = 0; i < n; i++) {
                           for (j = i; j < n; j++) {
                              aeffective.xyR[i][j] = 0.9 * randommid();
                              aparam.xyR[i][j] = aeffective.xyR[i][j];
                           }
                           aeffective.xyR[i][i] = (2 * randominteger(2) - 1) * (0.8 + randomreal());
                           aparam.xyR[i][i] = aeffective.xyR[i][i];
                        }
                     } else {
                        for (i = 0; i < n; i++) {
                           for (j = 0; j <= i; j++) {
                              aeffective.xyR[i][j] = 0.9 * randommid();
                              aparam.xyR[i][j] = aeffective.xyR[i][j];
                           }
                           aeffective.xyR[i][i] = (2 * randominteger(2) - 1) * (0.8 + randomreal());
                           aparam.xyR[i][i] = aeffective.xyR[i][i];
                        }
                     }
                     if (isunit) {
                        for (i = 0; i < n; i++) {
                           aeffective.xyR[i][i] = 1.0;
                           aparam.xyR[i][i] = 0.0;
                        }
                     }
                     if (istrans) {
                        if (isupper) {
                           for (i = 0; i < n; i++) {
                              for (j = i + 1; j < n; j++) {
                                 aeffective.xyR[j][i] = aeffective.xyR[i][j];
                                 aeffective.xyR[i][j] = 0.0;
                              }
                           }
                        } else {
                           for (i = 0; i < n; i++) {
                              for (j = i + 1; j < n; j++) {
                                 aeffective.xyR[i][j] = aeffective.xyR[j][i];
                                 aeffective.xyR[j][i] = 0.0;
                              }
                           }
                        }
                     }
                  // Prepare task, solve, compare
                     for (i = 0; i < n; i++) {
                        xe.xR[i] = randommid();
                     }
                     for (i = 0; i < n; i++) {
                        v = ae_v_dotproduct(aeffective.xyR[i], 1, xe.xR, 1, n);
                        b.xR[i] = v;
                     }
                     rmatrixtrsafesolve(&aparam, n, &b, &s, isupper, istrans, isunit);
                     ae_v_muld(xe.xR, 1, n, s);
                     ae_v_sub(xe.xR, 1, b.xR, 1, n);
                     v = ae_v_dotproduct(xe.xR, 1, xe.xR, 1, n);
                     v = sqrt(v);
                     waserrors = waserrors || v > threshold;
                  }
               }
            }
         }
      }
   }
// report
   if (!silent) {
      printf("TESTING RMatrixTRSafeSolve\n");
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === safesolve testing unit ===
// Copy
static void testsafesolveunit_rmatrixmakeacopy(RMatrix *a, ae_int_t m, ae_int_t n, RMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m - 1 + 1, n - 1 + 1);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyR[i][j] = a->xyR[i][j];
      }
   }
}

// Copy
static void testsafesolveunit_cmatrixmakeacopy(CMatrix *a, ae_int_t m, ae_int_t n, CMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m - 1 + 1, n - 1 + 1);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyC[i][j] = a->xyC[i][j];
      }
   }
}

// Main unittest subroutine
bool testsafesolve(bool silent) {
   ae_frame _frame_block;
   ae_int_t maxmn;
   double threshold;
   bool rerrors;
   bool cerrors;
   bool waserrors;
   bool isupper;
   ae_int_t trans;
   bool isunit;
   double scalea;
   double growth;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t j1;
   ae_int_t j2;
   complex cv;
   double rv;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(ca, 0, 0, DT_COMPLEX);
   NewMatrix(cea, 0, 0, DT_COMPLEX);
   NewMatrix(ctmpa, 0, 0, DT_COMPLEX);
   NewVector(cxs, 0, DT_COMPLEX);
   NewVector(cxe, 0, DT_COMPLEX);
   NewMatrix(ra, 0, 0, DT_REAL);
   NewMatrix(rea, 0, 0, DT_REAL);
   NewMatrix(rtmpa, 0, 0, DT_REAL);
   NewVector(rxs, 0, DT_REAL);
   NewVector(rxe, 0, DT_REAL);
   maxmn = 30;
   threshold = 100000 * machineepsilon;
   rerrors = false;
   cerrors = false;
   waserrors = false;
// Different problems: general tests
   for (n = 1; n <= maxmn; n++) {
   // test complex solver with well-conditioned matrix:
   // 1. generate A: fill off-diagonal elements with small values,
   //    diagonal elements are filled with larger values
   // 2. generate 'effective' A
   // 3. prepare task (exact X is stored in CXE, right part - in CXS),
   //    solve and compare CXS and CXE
      isupper = randombool();
      trans = randominteger(3);
      isunit = randombool();
      scalea = randomreal() + 0.5;
      ae_matrix_set_length(&ca, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (i == j) {
               ca.xyC[i][j] = complex_from_d((2 * randominteger(2) - 1) * (5 + randomreal()), (2 * randominteger(2) - 1) * (5 + randomreal()));
            } else {
               ca.xyC[i][j] = complex_from_d(0.1 * randommid(), 0.1 * randommid());
            }
         }
      }
      testsafesolveunit_cmatrixmakeacopy(&ca, n, n, &ctmpa);
      for (i = 0; i < n; i++) {
         if (isupper) {
            j1 = 0;
            j2 = i - 1;
         } else {
            j1 = i + 1;
            j2 = n - 1;
         }
         for (j = j1; j <= j2; j++) {
            ctmpa.xyC[i][j] = complex_from_i(0);
         }
         if (isunit) {
            ctmpa.xyC[i][i] = complex_from_i(1);
         }
      }
      ae_matrix_set_length(&cea, n, n);
      for (i = 0; i < n; i++) {
         if (trans == 0) {
            ae_v_cmoved(cea.xyC[i], 1, ctmpa.xyC[i], 1, "N", n, scalea);
         }
         if (trans == 1) {
            ae_v_cmoved(&cea.xyC[0][i], cea.stride, ctmpa.xyC[i], 1, "N", n, scalea);
         }
         if (trans == 2) {
            ae_v_cmoved(&cea.xyC[0][i], cea.stride, ctmpa.xyC[i], 1, "Conj", n, scalea);
         }
      }
      ae_vector_set_length(&cxe, n);
      for (i = 0; i < n; i++) {
         cxe.xC[i] = complex_from_d(randommid(), randommid());
      }
      ae_vector_set_length(&cxs, n);
      for (i = 0; i < n; i++) {
         cv = ae_v_cdotproduct(cea.xyC[i], 1, "N", cxe.xC, 1, "N", n);
         cxs.xC[i] = cv;
      }
      if (cmatrixscaledtrsafesolve(&ca, scalea, n, &cxs, isupper, trans, isunit, sqrt(maxrealnumber))) {
         for (i = 0; i < n; i++) {
            cerrors = cerrors || abscomplex(ae_c_sub(cxs.xC[i], cxe.xC[i])) > threshold;
         }
      } else {
         cerrors = true;
      }
   // same with real
      isupper = randombool();
      trans = randominteger(2);
      isunit = randombool();
      scalea = randomreal() + 0.5;
      ae_matrix_set_length(&ra, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (i == j) {
               ra.xyR[i][j] = (2 * randominteger(2) - 1) * (5 + randomreal());
            } else {
               ra.xyR[i][j] = 0.1 * randommid();
            }
         }
      }
      testsafesolveunit_rmatrixmakeacopy(&ra, n, n, &rtmpa);
      for (i = 0; i < n; i++) {
         if (isupper) {
            j1 = 0;
            j2 = i - 1;
         } else {
            j1 = i + 1;
            j2 = n - 1;
         }
         for (j = j1; j <= j2; j++) {
            rtmpa.xyR[i][j] = 0.0;
         }
         if (isunit) {
            rtmpa.xyR[i][i] = 1.0;
         }
      }
      ae_matrix_set_length(&rea, n, n);
      for (i = 0; i < n; i++) {
         if (trans == 0) {
            ae_v_moved(rea.xyR[i], 1, rtmpa.xyR[i], 1, n, scalea);
         }
         if (trans == 1) {
            ae_v_moved(&rea.xyR[0][i], rea.stride, rtmpa.xyR[i], 1, n, scalea);
         }
      }
      ae_vector_set_length(&rxe, n);
      for (i = 0; i < n; i++) {
         rxe.xR[i] = randommid();
      }
      ae_vector_set_length(&rxs, n);
      for (i = 0; i < n; i++) {
         rv = ae_v_dotproduct(rea.xyR[i], 1, rxe.xR, 1, n);
         rxs.xR[i] = rv;
      }
      if (rmatrixscaledtrsafesolve(&ra, scalea, n, &rxs, isupper, trans, isunit, sqrt(maxrealnumber))) {
         for (i = 0; i < n; i++) {
            rerrors = rerrors || fabs(rxs.xR[i] - rxe.xR[i]) > threshold;
         }
      } else {
         rerrors = true;
      }
   }
// Special test with diagonal ill-conditioned matrix:
// * ability to solve it when resulting growth is less than threshold
// * ability to stop solve when resulting growth is greater than threshold
//
// A = diag(1, 1/growth)
// b = (1, 0.5)
   n = 2;
   growth = 10.0;
   ae_matrix_set_length(&ca, n, n);
   ca.xyC[0][0] = complex_from_i(1);
   ca.xyC[0][1] = complex_from_i(0);
   ca.xyC[1][0] = complex_from_i(0);
   ca.xyC[1][1] = complex_from_d(1 / growth);
   ae_vector_set_length(&cxs, n);
   cxs.xC[0] = complex_from_d(1.0);
   cxs.xC[1] = complex_from_d(0.5);
   cerrors = cerrors || !cmatrixscaledtrsafesolve(&ca, 1.0, n, &cxs, randombool(), randominteger(3), false, 1.05 * rmax2(abscomplex(cxs.xC[1]) * growth, 1.0));
   cerrors = cerrors || !cmatrixscaledtrsafesolve(&ca, 1.0, n, &cxs, randombool(), randominteger(3), false, 0.95 * rmax2(abscomplex(cxs.xC[1]) * growth, 1.0));
   ae_matrix_set_length(&ra, n, n);
   ra.xyR[0][0] = 1.0;
   ra.xyR[0][1] = 0.0;
   ra.xyR[1][0] = 0.0;
   ra.xyR[1][1] = 1 / growth;
   ae_vector_set_length(&rxs, n);
   rxs.xR[0] = 1.0;
   rxs.xR[1] = 0.5;
   rerrors = rerrors || !rmatrixscaledtrsafesolve(&ra, 1.0, n, &rxs, randombool(), randominteger(2), false, 1.05 * rmax2(fabs(rxs.xR[1]) * growth, 1.0));
   rerrors = rerrors || !rmatrixscaledtrsafesolve(&ra, 1.0, n, &rxs, randombool(), randominteger(2), false, 0.95 * rmax2(fabs(rxs.xR[1]) * growth, 1.0));
// Special test with diagonal degenerate matrix:
// * ability to solve it when resulting growth is less than threshold
// * ability to stop solve when resulting growth is greater than threshold
//
// A = diag(1, 0)
// b = (1, 0.5)
   n = 2;
   ae_matrix_set_length(&ca, n, n);
   ca.xyC[0][0] = complex_from_i(1);
   ca.xyC[0][1] = complex_from_i(0);
   ca.xyC[1][0] = complex_from_i(0);
   ca.xyC[1][1] = complex_from_i(0);
   ae_vector_set_length(&cxs, n);
   cxs.xC[0] = complex_from_d(1.0);
   cxs.xC[1] = complex_from_d(0.5);
   cerrors = cerrors || cmatrixscaledtrsafesolve(&ca, 1.0, n, &cxs, randombool(), randominteger(3), false, sqrt(maxrealnumber));
   ae_matrix_set_length(&ra, n, n);
   ra.xyR[0][0] = 1.0;
   ra.xyR[0][1] = 0.0;
   ra.xyR[1][0] = 0.0;
   ra.xyR[1][1] = 0.0;
   ae_vector_set_length(&rxs, n);
   rxs.xR[0] = 1.0;
   rxs.xR[1] = 0.5;
   rerrors = rerrors || rmatrixscaledtrsafesolve(&ra, 1.0, n, &rxs, randombool(), randominteger(2), false, sqrt(maxrealnumber));
// report
   waserrors = rerrors || cerrors;
   if (!silent) {
      printf("TESTING SAFE TR SOLVER\n");
      printf("REAL:                                    ");
      if (!rerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("COMPLEX:                                 ");
      if (!cerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === rcond testing unit ===
static const double testrcondunit_threshold50 = 0.25;
static const double testrcondunit_threshold90 = 0.10;

// Copy
static void testrcondunit_rmatrixmakeacopy(RMatrix *a, ae_int_t m, ae_int_t n, RMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m - 1 + 1, n - 1 + 1);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyR[i][j] = a->xyR[i][j];
      }
   }
}

// Copy
static void testrcondunit_cmatrixmakeacopy(CMatrix *a, ae_int_t m, ae_int_t n, CMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m - 1 + 1, n - 1 + 1);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyC[i][j] = a->xyC[i][j];
      }
   }
}

// Drops upper or lower half of the matrix - fills it by special pattern
// which may be used later to ensure that this part wasn't changed
static void testrcondunit_rmatrixdrophalf(RMatrix *a, ae_int_t n, bool droplower) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (droplower ? i > j : i < j) {
            a->xyR[i][j] = (double)(1 + 2 * i + 3 * j);
         }
      }
   }
}

// Drops upper or lower half of the matrix - fills it by special pattern
// which may be used later to ensure that this part wasn't changed
static void testrcondunit_cmatrixdrophalf(CMatrix *a, ae_int_t n, bool droplower) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (droplower ? i > j : i < j) {
            a->xyC[i][j] = complex_from_i(1 + 2 * i + 3 * j);
         }
      }
   }
}

// Generate matrix with given condition number C (2-norm)
static void testrcondunit_rmatrixgenzero(RMatrix *a0, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_matrix_set_length(a0, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a0->xyR[i][j] = 0.0;
      }
   }
}

// Generate matrix with given condition number C (2-norm)
static void testrcondunit_cmatrixgenzero(CMatrix *a0, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_matrix_set_length(a0, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a0->xyC[i][j] = complex_from_i(0);
      }
   }
}

// triangular inverse
static bool testrcondunit_rmatrixinvmattr(RMatrix *a, ae_int_t n, bool isupper, bool isunittriangular) {
   ae_frame _frame_block;
   bool nounit;
   ae_int_t i;
   ae_int_t j;
   double v;
   double ajj;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(t, 0, DT_REAL);
   result = true;
   ae_vector_set_length(&t, n - 1 + 1);
// Test the input parameters.
   nounit = !isunittriangular;
   if (isupper) {
   // Compute inverse of upper triangular matrix.
      for (j = 0; j < n; j++) {
         if (nounit) {
            if (a->xyR[j][j] == 0.0) {
               result = false;
               ae_frame_leave();
               return result;
            }
            a->xyR[j][j] = 1 / a->xyR[j][j];
            ajj = -a->xyR[j][j];
         } else {
            ajj = -1.0;
         }
      // Compute elements 1:j-1 of j-th column.
         if (j > 0) {
            ae_v_move(t.xR, 1, &a->xyR[0][j], a->stride, j);
            for (i = 0; i < j; i++) {
               if (i < j - 1) {
                  v = ae_v_dotproduct(&a->xyR[i][i + 1], 1, &t.xR[i + 1], 1, j - i - 1);
               } else {
                  v = 0.0;
               }
               if (nounit) {
                  a->xyR[i][j] = v + a->xyR[i][i] * t.xR[i];
               } else {
                  a->xyR[i][j] = v + t.xR[i];
               }
            }
            ae_v_muld(&a->xyR[0][j], a->stride, j, ajj);
         }
      }
   } else {
   // Compute inverse of lower triangular matrix.
      for (j = n - 1; j >= 0; j--) {
         if (nounit) {
            if (a->xyR[j][j] == 0.0) {
               result = false;
               ae_frame_leave();
               return result;
            }
            a->xyR[j][j] = 1 / a->xyR[j][j];
            ajj = -a->xyR[j][j];
         } else {
            ajj = -1.0;
         }
         if (j < n - 1) {
         // Compute elements j+1:n of j-th column.
            ae_v_move(&t.xR[j + 1], 1, &a->xyR[j + 1][j], a->stride, n - j - 1);
            for (i = j + 1; i < n; i++) {
               if (i > j + 1) {
                  v = ae_v_dotproduct(&a->xyR[i][j + 1], 1, &t.xR[j + 1], 1, i - j - 1);
               } else {
                  v = 0.0;
               }
               if (nounit) {
                  a->xyR[i][j] = v + a->xyR[i][i] * t.xR[i];
               } else {
                  a->xyR[i][j] = v + t.xR[i];
               }
            }
            ae_v_muld(&a->xyR[j + 1][j], a->stride, n - j - 1, ajj);
         }
      }
   }
   ae_frame_leave();
   return result;
}

// triangular inverse
static bool testrcondunit_cmatrixinvmattr(CMatrix *a, ae_int_t n, bool isupper, bool isunittriangular) {
   ae_frame _frame_block;
   bool nounit;
   ae_int_t i;
   ae_int_t j;
   complex v;
   complex ajj;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(t, 0, DT_COMPLEX);
   result = true;
   ae_vector_set_length(&t, n - 1 + 1);
// Test the input parameters.
   nounit = !isunittriangular;
   if (isupper) {
   // Compute inverse of upper triangular matrix.
      for (j = 0; j < n; j++) {
         if (nounit) {
            if (ae_c_eq_d(a->xyC[j][j], 0.0)) {
               result = false;
               ae_frame_leave();
               return result;
            }
            a->xyC[j][j] = ae_c_d_div(1, a->xyC[j][j]);
            ajj = ae_c_neg(a->xyC[j][j]);
         } else {
            ajj = complex_from_i(-1);
         }
      // Compute elements 1:j-1 of j-th column.
         if (j > 0) {
            ae_v_cmove(t.xC, 1, &a->xyC[0][j], a->stride, "N", j);
            for (i = 0; i < j; i++) {
               if (i < j - 1) {
                  v = ae_v_cdotproduct(&a->xyC[i][i + 1], 1, "N", &t.xC[i + 1], 1, "N", j - i - 1);
               } else {
                  v = complex_from_i(0);
               }
               if (nounit) {
                  a->xyC[i][j] = ae_c_add(v, ae_c_mul(a->xyC[i][i], t.xC[i]));
               } else {
                  a->xyC[i][j] = ae_c_add(v, t.xC[i]);
               }
            }
            ae_v_cmulc(&a->xyC[0][j], a->stride, j, ajj);
         }
      }
   } else {
   // Compute inverse of lower triangular matrix.
      for (j = n - 1; j >= 0; j--) {
         if (nounit) {
            if (ae_c_eq_d(a->xyC[j][j], 0.0)) {
               result = false;
               ae_frame_leave();
               return result;
            }
            a->xyC[j][j] = ae_c_d_div(1, a->xyC[j][j]);
            ajj = ae_c_neg(a->xyC[j][j]);
         } else {
            ajj = complex_from_i(-1);
         }
         if (j < n - 1) {
         // Compute elements j+1:n of j-th column.
            ae_v_cmove(&t.xC[j + 1], 1, &a->xyC[j + 1][j], a->stride, "N", n - j - 1);
            for (i = j + 1; i < n; i++) {
               if (i > j + 1) {
                  v = ae_v_cdotproduct(&a->xyC[i][j + 1], 1, "N", &t.xC[j + 1], 1, "N", i - j - 1);
               } else {
                  v = complex_from_i(0);
               }
               if (nounit) {
                  a->xyC[i][j] = ae_c_add(v, ae_c_mul(a->xyC[i][i], t.xC[i]));
               } else {
                  a->xyC[i][j] = ae_c_add(v, t.xC[i]);
               }
            }
            ae_v_cmulc(&a->xyC[j + 1][j], a->stride, n - j - 1, ajj);
         }
      }
   }
   ae_frame_leave();
   return result;
}

// LU inverse
static bool testrcondunit_rmatrixinvmatlu(RMatrix *a, ZVector *pivots, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t jp;
   double v;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(work, 0, DT_REAL);
   result = true;
// Quick return if possible
   if (n == 0) {
      ae_frame_leave();
      return result;
   }
   ae_vector_set_length(&work, n - 1 + 1);
// Form inv(U)
   if (!testrcondunit_rmatrixinvmattr(a, n, true, false)) {
      result = false;
      ae_frame_leave();
      return result;
   }
// Solve the equation inv(A)*L = inv(U) for inv(A).
   for (j = n - 1; j >= 0; j--) {
   // Copy current column of L to WORK and replace with zeros.
      for (i = j + 1; i < n; i++) {
         work.xR[i] = a->xyR[i][j];
         a->xyR[i][j] = 0.0;
      }
   // Compute current column of inv(A).
      if (j < n - 1) {
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(&a->xyR[i][j + 1], 1, &work.xR[j + 1], 1, n - j - 1);
            a->xyR[i][j] -= v;
         }
      }
   }
// Apply column interchanges.
   for (j = n - 2; j >= 0; j--) {
      jp = pivots->xZ[j];
      if (jp != j) {
         ae_v_move(work.xR, 1, &a->xyR[0][j], a->stride, n);
         ae_v_move(&a->xyR[0][j], a->stride, &a->xyR[0][jp], a->stride, n);
         ae_v_move(&a->xyR[0][jp], a->stride, work.xR, 1, n);
      }
   }
   ae_frame_leave();
   return result;
}

// LU inverse
static bool testrcondunit_cmatrixinvmatlu(CMatrix *a, ZVector *pivots, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t jp;
   complex v;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(work, 0, DT_COMPLEX);
   result = true;
// Quick return if possible
   if (n == 0) {
      ae_frame_leave();
      return result;
   }
   ae_vector_set_length(&work, n - 1 + 1);
// Form inv(U)
   if (!testrcondunit_cmatrixinvmattr(a, n, true, false)) {
      result = false;
      ae_frame_leave();
      return result;
   }
// Solve the equation inv(A)*L = inv(U) for inv(A).
   for (j = n - 1; j >= 0; j--) {
   // Copy current column of L to WORK and replace with zeros.
      for (i = j + 1; i < n; i++) {
         work.xC[i] = a->xyC[i][j];
         a->xyC[i][j] = complex_from_i(0);
      }
   // Compute current column of inv(A).
      if (j < n - 1) {
         for (i = 0; i < n; i++) {
            v = ae_v_cdotproduct(&a->xyC[i][j + 1], 1, "N", &work.xC[j + 1], 1, "N", n - j - 1);
            a->xyC[i][j] = ae_c_sub(a->xyC[i][j], v);
         }
      }
   }
// Apply column interchanges.
   for (j = n - 2; j >= 0; j--) {
      jp = pivots->xZ[j];
      if (jp != j) {
         ae_v_cmove(work.xC, 1, &a->xyC[0][j], a->stride, "N", n);
         ae_v_cmove(&a->xyC[0][j], a->stride, &a->xyC[0][jp], a->stride, "N", n);
         ae_v_cmove(&a->xyC[0][jp], a->stride, work.xC, 1, "N", n);
      }
   }
   ae_frame_leave();
   return result;
}

// Matrix inverse
static bool testrcondunit_rmatrixinvmat(RMatrix *a, ae_int_t n) {
   ae_frame _frame_block;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(pivots, 0, DT_INT);
   rmatrixlu(a, n, n, &pivots);
   result = testrcondunit_rmatrixinvmatlu(a, &pivots, n);
   ae_frame_leave();
   return result;
}

// Matrix inverse
static bool testrcondunit_cmatrixinvmat(CMatrix *a, ae_int_t n) {
   ae_frame _frame_block;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(pivots, 0, DT_INT);
   cmatrixlu(a, n, n, &pivots);
   result = testrcondunit_cmatrixinvmatlu(a, &pivots, n);
   ae_frame_leave();
   return result;
}

// reference RCond
static void testrcondunit_rmatrixrefrcond(RMatrix *a, ae_int_t n, double *rc1, double *rcinf) {
   ae_frame _frame_block;
   double nrm1a;
   double nrminfa;
   double nrm1inva;
   double nrminfinva;
   double v;
   ae_int_t k;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   *rc1 = 0;
   *rcinf = 0;
   NewMatrix(inva, 0, 0, DT_REAL);
// inv A
   testrcondunit_rmatrixmakeacopy(a, n, n, &inva);
   if (!testrcondunit_rmatrixinvmat(&inva, n)) {
      *rc1 = 0.0;
      *rcinf = 0.0;
      ae_frame_leave();
      return;
   }
// norm A
   nrm1a = 0.0;
   nrminfa = 0.0;
   for (k = 0; k < n; k++) {
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += fabs(a->xyR[i][k]);
      }
      nrm1a = rmax2(nrm1a, v);
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += fabs(a->xyR[k][i]);
      }
      nrminfa = rmax2(nrminfa, v);
   }
// norm inv A
   nrm1inva = 0.0;
   nrminfinva = 0.0;
   for (k = 0; k < n; k++) {
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += fabs(inva.xyR[i][k]);
      }
      nrm1inva = rmax2(nrm1inva, v);
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += fabs(inva.xyR[k][i]);
      }
      nrminfinva = rmax2(nrminfinva, v);
   }
// result
   *rc1 = nrm1inva * nrm1a;
   *rcinf = nrminfinva * nrminfa;
   ae_frame_leave();
}

// reference RCond
static void testrcondunit_cmatrixrefrcond(CMatrix *a, ae_int_t n, double *rc1, double *rcinf) {
   ae_frame _frame_block;
   double nrm1a;
   double nrminfa;
   double nrm1inva;
   double nrminfinva;
   double v;
   ae_int_t k;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   *rc1 = 0;
   *rcinf = 0;
   NewMatrix(inva, 0, 0, DT_COMPLEX);
// inv A
   testrcondunit_cmatrixmakeacopy(a, n, n, &inva);
   if (!testrcondunit_cmatrixinvmat(&inva, n)) {
      *rc1 = 0.0;
      *rcinf = 0.0;
      ae_frame_leave();
      return;
   }
// norm A
   nrm1a = 0.0;
   nrminfa = 0.0;
   for (k = 0; k < n; k++) {
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += abscomplex(a->xyC[i][k]);
      }
      nrm1a = rmax2(nrm1a, v);
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += abscomplex(a->xyC[k][i]);
      }
      nrminfa = rmax2(nrminfa, v);
   }
// norm inv A
   nrm1inva = 0.0;
   nrminfinva = 0.0;
   for (k = 0; k < n; k++) {
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += abscomplex(inva.xyC[i][k]);
      }
      nrm1inva = rmax2(nrm1inva, v);
      v = 0.0;
      for (i = 0; i < n; i++) {
         v += abscomplex(inva.xyC[k][i]);
      }
      nrminfinva = rmax2(nrminfinva, v);
   }
// result
   *rc1 = nrm1inva * nrm1a;
   *rcinf = nrminfinva * nrminfa;
   ae_frame_leave();
}

// Returns True for successful test, False - for failed test
static bool testrcondunit_testrmatrixtrrcond(ae_int_t maxn, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t j1;
   ae_int_t j2;
   ae_int_t pass;
   bool err50;
   bool err90;
   bool errspec;
   bool errless;
   double erc1;
   double ercinf;
   double v;
   bool isupper;
   bool isunit;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ea, 0, 0, DT_REAL);
   NewVector(p, 0, DT_INT);
   NewVector(q50, 0, DT_REAL);
   NewVector(q90, 0, DT_REAL);
   err50 = false;
   err90 = false;
   errless = false;
   errspec = false;
   ae_vector_set_length(&q50, 2);
   ae_vector_set_length(&q90, 2);
   for (n = 1; n <= maxn; n++) {
   // special test for zero matrix
      testrcondunit_rmatrixgenzero(&a, n);
      errspec = errspec || rmatrixtrrcond1(&a, n, randombool(), false) != 0.0;
      errspec = errspec || rmatrixtrrcondinf(&a, n, randombool(), false) != 0.0;
   // general test
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i <= 1; i++) {
         q50.xR[i] = 0.0;
         q90.xR[i] = 0.0;
      }
      for (pass = 1; pass <= passcount; pass++) {
         isupper = randombool();
         isunit = randombool();
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = randomreal() - 0.5;
            }
         }
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 1 + randomreal();
         }
         testrcondunit_rmatrixmakeacopy(&a, n, n, &ea);
         for (i = 0; i < n; i++) {
            if (isupper) {
               j1 = 0;
               j2 = i - 1;
            } else {
               j1 = i + 1;
               j2 = n - 1;
            }
            for (j = j1; j <= j2; j++) {
               ea.xyR[i][j] = 0.0;
            }
            if (isunit) {
               ea.xyR[i][i] = 1.0;
            }
         }
         testrcondunit_rmatrixrefrcond(&ea, n, &erc1, &ercinf);
      // 1-norm
         v = 1 / rmatrixtrrcond1(&a, n, isupper, isunit);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[0] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[0] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // Inf-norm
         v = 1 / rmatrixtrrcondinf(&a, n, isupper, isunit);
         if (v >= testrcondunit_threshold50 * ercinf) {
            q50.xR[1] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * ercinf) {
            q90.xR[1] += 1.0 / passcount;
         }
         errless = errless || v > ercinf * 1.001;
      }
      for (i = 0; i <= 1; i++) {
         err50 = err50 || q50.xR[i] < 0.50;
         err90 = err90 || q90.xR[i] < 0.90;
      }
   // degenerate matrix test
      if (n >= 3) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         a.xyR[0][0] = 1.0;
         a.xyR[n - 1][n - 1] = 1.0;
         errspec = errspec || rmatrixtrrcond1(&a, n, randombool(), false) != 0.0;
         errspec = errspec || rmatrixtrrcondinf(&a, n, randombool(), false) != 0.0;
      }
   // near-degenerate matrix test
      if (n >= 2) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 1.0;
         }
         i = randominteger(n);
         a.xyR[i][i] = 0.1 * maxrealnumber;
         errspec = errspec || rmatrixtrrcond1(&a, n, randombool(), false) != 0.0;
         errspec = errspec || rmatrixtrrcondinf(&a, n, randombool(), false) != 0.0;
      }
   }
// report
   result = !(((err50 || err90) || errless) || errspec);
   ae_frame_leave();
   return result;
}

// Returns True for successful test, False - for failed test
static bool testrcondunit_testcmatrixtrrcond(ae_int_t maxn, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t j1;
   ae_int_t j2;
   ae_int_t pass;
   bool err50;
   bool err90;
   bool errspec;
   bool errless;
   double erc1;
   double ercinf;
   double v;
   bool isupper;
   bool isunit;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(ea, 0, 0, DT_COMPLEX);
   NewVector(p, 0, DT_INT);
   NewVector(q50, 0, DT_REAL);
   NewVector(q90, 0, DT_REAL);
   err50 = false;
   err90 = false;
   errless = false;
   errspec = false;
   ae_vector_set_length(&q50, 2);
   ae_vector_set_length(&q90, 2);
   for (n = 1; n <= maxn; n++) {
   // special test for zero matrix
      testrcondunit_cmatrixgenzero(&a, n);
      errspec = errspec || cmatrixtrrcond1(&a, n, randombool(), false) != 0.0;
      errspec = errspec || cmatrixtrrcondinf(&a, n, randombool(), false) != 0.0;
   // general test
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i <= 1; i++) {
         q50.xR[i] = 0.0;
         q90.xR[i] = 0.0;
      }
      for (pass = 1; pass <= passcount; pass++) {
         isupper = randombool();
         isunit = randombool();
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyC[i][j] = complex_from_d(randomreal() - 0.5, randomreal() - 0.5);
            }
         }
         for (i = 0; i < n; i++) {
            a.xyC[i][i] = complex_from_d(1 + randomreal(), 1 + randomreal());
         }
         testrcondunit_cmatrixmakeacopy(&a, n, n, &ea);
         for (i = 0; i < n; i++) {
            if (isupper) {
               j1 = 0;
               j2 = i - 1;
            } else {
               j1 = i + 1;
               j2 = n - 1;
            }
            for (j = j1; j <= j2; j++) {
               ea.xyC[i][j] = complex_from_i(0);
            }
            if (isunit) {
               ea.xyC[i][i] = complex_from_i(1);
            }
         }
         testrcondunit_cmatrixrefrcond(&ea, n, &erc1, &ercinf);
      // 1-norm
         v = 1 / cmatrixtrrcond1(&a, n, isupper, isunit);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[0] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[0] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // Inf-norm
         v = 1 / cmatrixtrrcondinf(&a, n, isupper, isunit);
         if (v >= testrcondunit_threshold50 * ercinf) {
            q50.xR[1] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * ercinf) {
            q90.xR[1] += 1.0 / passcount;
         }
         errless = errless || v > ercinf * 1.001;
      }
      for (i = 0; i <= 1; i++) {
         err50 = err50 || q50.xR[i] < 0.50;
         err90 = err90 || q90.xR[i] < 0.90;
      }
   // degenerate matrix test
      if (n >= 3) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyC[i][j] = complex_from_d(0.0);
            }
         }
         a.xyC[0][0] = complex_from_i(1);
         a.xyC[n - 1][n - 1] = complex_from_i(1);
         errspec = errspec || cmatrixtrrcond1(&a, n, randombool(), false) != 0.0;
         errspec = errspec || cmatrixtrrcondinf(&a, n, randombool(), false) != 0.0;
      }
   // near-degenerate matrix test
      if (n >= 2) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyC[i][j] = complex_from_d(0.0);
            }
         }
         for (i = 0; i < n; i++) {
            a.xyC[i][i] = complex_from_i(1);
         }
         i = randominteger(n);
         a.xyC[i][i] = complex_from_d(0.1 * maxrealnumber);
         errspec = errspec || cmatrixtrrcond1(&a, n, randombool(), false) != 0.0;
         errspec = errspec || cmatrixtrrcondinf(&a, n, randombool(), false) != 0.0;
      }
   }
// report
   result = !(((err50 || err90) || errless) || errspec);
   ae_frame_leave();
   return result;
}

// Returns True for successful test, False - for failed test
static bool testrcondunit_testrmatrixrcond(ae_int_t maxn, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   bool err50;
   bool err90;
   bool errspec;
   bool errless;
   double erc1;
   double ercinf;
   double v;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(lua, 0, 0, DT_REAL);
   NewVector(p, 0, DT_INT);
   NewVector(q50, 0, DT_REAL);
   NewVector(q90, 0, DT_REAL);
   err50 = false;
   err90 = false;
   errless = false;
   errspec = false;
   ae_vector_set_length(&q50, 3 + 1);
   ae_vector_set_length(&q90, 3 + 1);
   for (n = 1; n <= maxn; n++) {
   // special test for zero matrix
      testrcondunit_rmatrixgenzero(&a, n);
      testrcondunit_rmatrixmakeacopy(&a, n, n, &lua);
      rmatrixlu(&lua, n, n, &p);
      errspec = errspec || rmatrixrcond1(&a, n) != 0.0;
      errspec = errspec || rmatrixrcondinf(&a, n) != 0.0;
      errspec = errspec || rmatrixlurcond1(&lua, n) != 0.0;
      errspec = errspec || rmatrixlurcondinf(&lua, n) != 0.0;
   // general test
      ae_matrix_set_length(&a, n - 1 + 1, n - 1 + 1);
      for (i = 0; i <= 3; i++) {
         q50.xR[i] = 0.0;
         q90.xR[i] = 0.0;
      }
      for (pass = 1; pass <= passcount; pass++) {
         rmatrixrndcond(n, exp(randomreal() * log(1000.0)), &a);
         testrcondunit_rmatrixmakeacopy(&a, n, n, &lua);
         rmatrixlu(&lua, n, n, &p);
         testrcondunit_rmatrixrefrcond(&a, n, &erc1, &ercinf);
      // 1-norm, normal
         v = 1 / rmatrixrcond1(&a, n);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[0] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[0] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // 1-norm, LU
         v = 1 / rmatrixlurcond1(&lua, n);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[1] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[1] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // Inf-norm, normal
         v = 1 / rmatrixrcondinf(&a, n);
         if (v >= testrcondunit_threshold50 * ercinf) {
            q50.xR[2] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * ercinf) {
            q90.xR[2] += 1.0 / passcount;
         }
         errless = errless || v > ercinf * 1.001;
      // Inf-norm, LU
         v = 1 / rmatrixlurcondinf(&lua, n);
         if (v >= testrcondunit_threshold50 * ercinf) {
            q50.xR[3] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * ercinf) {
            q90.xR[3] += 1.0 / passcount;
         }
         errless = errless || v > ercinf * 1.001;
      }
      for (i = 0; i <= 3; i++) {
         err50 = err50 || q50.xR[i] < 0.50;
         err90 = err90 || q90.xR[i] < 0.90;
      }
   // degenerate matrix test
      if (n >= 3) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         a.xyR[0][0] = 1.0;
         a.xyR[n - 1][n - 1] = 1.0;
         errspec = errspec || rmatrixrcond1(&a, n) != 0.0;
         errspec = errspec || rmatrixrcondinf(&a, n) != 0.0;
         errspec = errspec || rmatrixlurcond1(&a, n) != 0.0;
         errspec = errspec || rmatrixlurcondinf(&a, n) != 0.0;
      }
   // near-degenerate matrix test
      if (n >= 2) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 1.0;
         }
         i = randominteger(n);
         a.xyR[i][i] = 0.1 * maxrealnumber;
         errspec = errspec || rmatrixrcond1(&a, n) != 0.0;
         errspec = errspec || rmatrixrcondinf(&a, n) != 0.0;
         errspec = errspec || rmatrixlurcond1(&a, n) != 0.0;
         errspec = errspec || rmatrixlurcondinf(&a, n) != 0.0;
      }
   }
// report
   result = !(((err50 || err90) || errless) || errspec);
   ae_frame_leave();
   return result;
}

// Returns True for successful test, False - for failed test
static bool testrcondunit_testcmatrixrcond(ae_int_t maxn, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   bool err50;
   bool err90;
   bool errless;
   bool errspec;
   double erc1;
   double ercinf;
   double v;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(lua, 0, 0, DT_COMPLEX);
   NewVector(p, 0, DT_INT);
   NewVector(q50, 0, DT_REAL);
   NewVector(q90, 0, DT_REAL);
   ae_vector_set_length(&q50, 3 + 1);
   ae_vector_set_length(&q90, 3 + 1);
   err50 = false;
   err90 = false;
   errless = false;
   errspec = false;
// process
   for (n = 1; n <= maxn; n++) {
   // special test for zero matrix
      testrcondunit_cmatrixgenzero(&a, n);
      testrcondunit_cmatrixmakeacopy(&a, n, n, &lua);
      cmatrixlu(&lua, n, n, &p);
      errspec = errspec || cmatrixrcond1(&a, n) != 0.0;
      errspec = errspec || cmatrixrcondinf(&a, n) != 0.0;
      errspec = errspec || cmatrixlurcond1(&lua, n) != 0.0;
      errspec = errspec || cmatrixlurcondinf(&lua, n) != 0.0;
   // general test
      ae_matrix_set_length(&a, n - 1 + 1, n - 1 + 1);
      for (i = 0; i <= 3; i++) {
         q50.xR[i] = 0.0;
         q90.xR[i] = 0.0;
      }
      for (pass = 1; pass <= passcount; pass++) {
         cmatrixrndcond(n, exp(randomreal() * log(1000.0)), &a);
         testrcondunit_cmatrixmakeacopy(&a, n, n, &lua);
         cmatrixlu(&lua, n, n, &p);
         testrcondunit_cmatrixrefrcond(&a, n, &erc1, &ercinf);
      // 1-norm, normal
         v = 1 / cmatrixrcond1(&a, n);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[0] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[0] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // 1-norm, LU
         v = 1 / cmatrixlurcond1(&lua, n);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[1] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[1] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // Inf-norm, normal
         v = 1 / cmatrixrcondinf(&a, n);
         if (v >= testrcondunit_threshold50 * ercinf) {
            q50.xR[2] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * ercinf) {
            q90.xR[2] += 1.0 / passcount;
         }
         errless = errless || v > ercinf * 1.001;
      // Inf-norm, LU
         v = 1 / cmatrixlurcondinf(&lua, n);
         if (v >= testrcondunit_threshold50 * ercinf) {
            q50.xR[3] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * ercinf) {
            q90.xR[3] += 1.0 / passcount;
         }
         errless = errless || v > ercinf * 1.001;
      }
      for (i = 0; i <= 3; i++) {
         err50 = err50 || q50.xR[i] < 0.50;
         err90 = err90 || q90.xR[i] < 0.90;
      }
   // degenerate matrix test
      if (n >= 3) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyC[i][j] = complex_from_d(0.0);
            }
         }
         a.xyC[0][0] = complex_from_i(1);
         a.xyC[n - 1][n - 1] = complex_from_i(1);
         errspec = errspec || cmatrixrcond1(&a, n) != 0.0;
         errspec = errspec || cmatrixrcondinf(&a, n) != 0.0;
         errspec = errspec || cmatrixlurcond1(&a, n) != 0.0;
         errspec = errspec || cmatrixlurcondinf(&a, n) != 0.0;
      }
   // near-degenerate matrix test
      if (n >= 2) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyC[i][j] = complex_from_d(0.0);
            }
         }
         for (i = 0; i < n; i++) {
            a.xyC[i][i] = complex_from_i(1);
         }
         i = randominteger(n);
         a.xyC[i][i] = complex_from_d(0.1 * maxrealnumber);
         errspec = errspec || cmatrixrcond1(&a, n) != 0.0;
         errspec = errspec || cmatrixrcondinf(&a, n) != 0.0;
         errspec = errspec || cmatrixlurcond1(&a, n) != 0.0;
         errspec = errspec || cmatrixlurcondinf(&a, n) != 0.0;
      }
   }
// report
   result = !(((err50 || err90) || errless) || errspec);
   ae_frame_leave();
   return result;
}

// Returns True for successful test, False - for failed test
static bool testrcondunit_testspdmatrixrcond(ae_int_t maxn, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   bool err50;
   bool err90;
   bool errspec;
   bool errless;
   bool isupper;
   double erc1;
   double ercinf;
   double v;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(cha, 0, 0, DT_REAL);
   NewVector(p, 0, DT_INT);
   NewVector(q50, 0, DT_REAL);
   NewVector(q90, 0, DT_REAL);
   err50 = false;
   err90 = false;
   errless = false;
   errspec = false;
   ae_vector_set_length(&q50, 2);
   ae_vector_set_length(&q90, 2);
   for (n = 1; n <= maxn; n++) {
      isupper = randombool();
   // general test
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i <= 1; i++) {
         q50.xR[i] = 0.0;
         q90.xR[i] = 0.0;
      }
      for (pass = 1; pass <= passcount; pass++) {
         spdmatrixrndcond(n, exp(randomreal() * log(1000.0)), &a);
         testrcondunit_rmatrixrefrcond(&a, n, &erc1, &ercinf);
         testrcondunit_rmatrixdrophalf(&a, n, isupper);
         testrcondunit_rmatrixmakeacopy(&a, n, n, &cha);
         spdmatrixcholesky(&cha, n, isupper);
      // normal
         v = 1 / spdmatrixrcond(&a, n, isupper);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[0] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[0] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // Cholesky
         v = 1 / spdmatrixcholeskyrcond(&cha, n, isupper);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[1] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[1] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      }
      for (i = 0; i <= 1; i++) {
         err50 = err50 || q50.xR[i] < 0.50;
         err90 = err90 || q90.xR[i] < 0.90;
      }
   // degenerate matrix test
      if (n >= 3) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         a.xyR[0][0] = 1.0;
         a.xyR[n - 1][n - 1] = 1.0;
         errspec = errspec || spdmatrixrcond(&a, n, isupper) != -1.0;
         errspec = errspec || spdmatrixcholeskyrcond(&a, n, isupper) != 0.0;
      }
   // near-degenerate matrix test
      if (n >= 2) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 1.0;
         }
         i = randominteger(n);
         a.xyR[i][i] = 0.1 * maxrealnumber;
         errspec = errspec || spdmatrixrcond(&a, n, isupper) != 0.0;
         errspec = errspec || spdmatrixcholeskyrcond(&a, n, isupper) != 0.0;
      }
   }
// report
   result = !(((err50 || err90) || errless) || errspec);
   ae_frame_leave();
   return result;
}

// Returns True for successful test, False - for failed test
static bool testrcondunit_testhpdmatrixrcond(ae_int_t maxn, ae_int_t passcount) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   bool err50;
   bool err90;
   bool errspec;
   bool errless;
   bool isupper;
   double erc1;
   double ercinf;
   double v;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(cha, 0, 0, DT_COMPLEX);
   NewVector(p, 0, DT_INT);
   NewVector(q50, 0, DT_REAL);
   NewVector(q90, 0, DT_REAL);
   err50 = false;
   err90 = false;
   errless = false;
   errspec = false;
   ae_vector_set_length(&q50, 2);
   ae_vector_set_length(&q90, 2);
   for (n = 1; n <= maxn; n++) {
      isupper = randombool();
   // general test
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i <= 1; i++) {
         q50.xR[i] = 0.0;
         q90.xR[i] = 0.0;
      }
      for (pass = 1; pass <= passcount; pass++) {
         hpdmatrixrndcond(n, exp(randomreal() * log(1000.0)), &a);
         testrcondunit_cmatrixrefrcond(&a, n, &erc1, &ercinf);
         testrcondunit_cmatrixdrophalf(&a, n, isupper);
         testrcondunit_cmatrixmakeacopy(&a, n, n, &cha);
         hpdmatrixcholesky(&cha, n, isupper);
      // normal
         v = 1 / hpdmatrixrcond(&a, n, isupper);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[0] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[0] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      // Cholesky
         v = 1 / hpdmatrixcholeskyrcond(&cha, n, isupper);
         if (v >= testrcondunit_threshold50 * erc1) {
            q50.xR[1] += 1.0 / passcount;
         }
         if (v >= testrcondunit_threshold90 * erc1) {
            q90.xR[1] += 1.0 / passcount;
         }
         errless = errless || v > erc1 * 1.001;
      }
      for (i = 0; i <= 1; i++) {
         err50 = err50 || q50.xR[i] < 0.50;
         err90 = err90 || q90.xR[i] < 0.90;
      }
   // degenerate matrix test
      if (n >= 3) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyC[i][j] = complex_from_d(0.0);
            }
         }
         a.xyC[0][0] = complex_from_i(1);
         a.xyC[n - 1][n - 1] = complex_from_i(1);
         errspec = errspec || hpdmatrixrcond(&a, n, isupper) != -1.0;
         errspec = errspec || hpdmatrixcholeskyrcond(&a, n, isupper) != 0.0;
      }
   // near-degenerate matrix test
      if (n >= 2) {
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyC[i][j] = complex_from_d(0.0);
            }
         }
         for (i = 0; i < n; i++) {
            a.xyC[i][i] = complex_from_i(1);
         }
         i = randominteger(n);
         a.xyC[i][i] = complex_from_d(0.1 * maxrealnumber);
         errspec = errspec || hpdmatrixrcond(&a, n, isupper) != 0.0;
         errspec = errspec || hpdmatrixcholeskyrcond(&a, n, isupper) != 0.0;
      }
   }
// report
   result = !(((err50 || err90) || errless) || errspec);
   ae_frame_leave();
   return result;
}

bool testrcond(bool silent) {
   ae_int_t maxn;
   ae_int_t passcount;
   bool waserrors;
   bool rtrerr;
   bool ctrerr;
   bool rerr;
   bool cerr;
   bool spderr;
   bool hpderr;
   bool result;
   maxn = 10;
   passcount = 100;
// report
   rtrerr = !testrcondunit_testrmatrixtrrcond(maxn, passcount);
   ctrerr = !testrcondunit_testcmatrixtrrcond(maxn, passcount);
   rerr = !testrcondunit_testrmatrixrcond(maxn, passcount);
   cerr = !testrcondunit_testcmatrixrcond(maxn, passcount);
   spderr = !testrcondunit_testspdmatrixrcond(maxn, passcount);
   hpderr = !testrcondunit_testhpdmatrixrcond(maxn, passcount);
   waserrors = ((((rtrerr || ctrerr) || rerr) || cerr) || spderr) || hpderr;
   if (!silent) {
      printf("TESTING RCOND\n");
      printf("REAL TRIANGULAR:                         ");
      if (!rtrerr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("COMPLEX TRIANGULAR:                      ");
      if (!ctrerr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("REAL:                                    ");
      if (!rerr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("SPD:                                     ");
      if (!spderr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("HPD:                                     ");
      if (!hpderr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("COMPLEX:                                 ");
      if (!cerr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === xblas testing unit ===
bool testxblas(bool silent) {
   ae_frame _frame_block;
   bool approxerrors;
   bool exactnesserrors;
   bool waserrors;
   double approxthreshold;
   ae_int_t maxn;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t i;
   ae_int_t pass;
   double rv1;
   double rv2;
   double rv2err;
   complex cv1;
   complex cv2;
   double cv2err;
   double s;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(rx, 0, DT_REAL);
   NewVector(ry, 0, DT_REAL);
   NewVector(cx, 0, DT_COMPLEX);
   NewVector(cy, 0, DT_COMPLEX);
   NewVector(temp, 0, DT_REAL);
   approxerrors = false;
   exactnesserrors = false;
   waserrors = false;
   approxthreshold = 1000 * machineepsilon;
   maxn = 1000;
   passcount = 10;
// tests:
// 1. ability to calculate dot product
// 2. higher precision
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
      //  ability to approximately calculate real dot product
         ae_vector_set_length(&rx, n);
         ae_vector_set_length(&ry, n);
         ae_vector_set_length(&temp, n);
         for (i = 0; i < n; i++) {
            if (randombool(0.2)) {
               rx.xR[i] = 0.0;
            } else {
               rx.xR[i] = randommid();
            }
            if (randombool(0.2)) {
               ry.xR[i] = 0.0;
            } else {
               ry.xR[i] = randommid();
            }
         }
         rv1 = ae_v_dotproduct(rx.xR, 1, ry.xR, 1, n);
         xdot(&rx, &ry, n, &temp, &rv2, &rv2err);
         approxerrors = approxerrors || fabs(rv1 - rv2) > approxthreshold;
      //  ability to approximately calculate complex dot product
         ae_vector_set_length(&cx, n);
         ae_vector_set_length(&cy, n);
         ae_vector_set_length(&temp, 2 * n);
         for (i = 0; i < n; i++) {
            if (randombool(0.2)) {
               cx.xC[i] = complex_from_i(0);
            } else {
               cx.xC[i] = complex_from_d(randommid(), randommid());
            }
            if (randombool(0.2)) {
               cy.xC[i] = complex_from_i(0);
            } else {
               cy.xC[i] = complex_from_d(randommid(), randommid());
            }
         }
         cv1 = ae_v_cdotproduct(cx.xC, 1, "N", cy.xC, 1, "N", n);
         xcdot(&cx, &cy, n, &temp, &cv2, &cv2err);
         approxerrors = approxerrors || abscomplex(ae_c_sub(cv1, cv2)) > approxthreshold;
      }
   }
// test of precision: real
   n = 50000;
   ae_vector_set_length(&rx, n);
   ae_vector_set_length(&ry, n);
   ae_vector_set_length(&temp, n);
   for (pass = 0; pass < passcount; pass++) {
      ae_assert(n % 2 == 0, "Assertion failed");
   // First test: X + X + ... + X - X - X - ... - X = 1*X
      s = exp((double)imax2(pass, 50));
      if (pass == passcount - 1 && pass > 1) {
         s = maxrealnumber;
      }
      ry.xR[0] = randommid() * s * sqrt(2 * randomreal());
      for (i = 1; i < n; i++) {
         ry.xR[i] = ry.xR[0];
      }
      for (i = 0; i < n / 2; i++) {
         rx.xR[i] = 1.0;
      }
      for (i = n / 2; i < n - 1; i++) {
         rx.xR[i] = -1.0;
      }
      rx.xR[n - 1] = 0.0;
      xdot(&rx, &ry, n, &temp, &rv2, &rv2err);
      exactnesserrors = exactnesserrors || rv2err < 0.0;
      exactnesserrors = exactnesserrors || rv2err > 4 * machineepsilon * fabs(ry.xR[0]);
      exactnesserrors = exactnesserrors || fabs(rv2 - ry.xR[0]) > rv2err;
   // First test: X + X + ... + X = N*X
      s = exp((double)imax2(pass, 50));
      if (pass == passcount - 1 && pass > 1) {
         s = maxrealnumber;
      }
      ry.xR[0] = randommid() * s * sqrt(2 * randomreal());
      for (i = 1; i < n; i++) {
         ry.xR[i] = ry.xR[0];
      }
      for (i = 0; i < n; i++) {
         rx.xR[i] = 1.0;
      }
      xdot(&rx, &ry, n, &temp, &rv2, &rv2err);
      exactnesserrors = exactnesserrors || rv2err < 0.0;
      exactnesserrors = exactnesserrors || rv2err > 4 * machineepsilon * fabs(ry.xR[0]) * n;
      exactnesserrors = exactnesserrors || fabs(rv2 - n * ry.xR[0]) > rv2err;
   }
// test of precision: complex
   n = 50000;
   ae_vector_set_length(&cx, n);
   ae_vector_set_length(&cy, n);
   ae_vector_set_length(&temp, 2 * n);
   for (pass = 0; pass < passcount; pass++) {
      ae_assert(n % 2 == 0, "Assertion failed");
   // First test: X + X + ... + X - X - X - ... - X = 1*X
      s = exp((double)imax2(pass, 50));
      if (pass == passcount - 1 && pass > 1) {
         s = maxrealnumber;
      }
      cy.xC[0] = complex_from_d(randommid() * s * sqrt(2 * randomreal()), randommid() * s * sqrt(2 * randomreal()));
      for (i = 1; i < n; i++) {
         cy.xC[i] = cy.xC[0];
      }
      for (i = 0; i < n / 2; i++) {
         cx.xC[i] = complex_from_i(1);
      }
      for (i = n / 2; i < n - 1; i++) {
         cx.xC[i] = complex_from_i(-1);
      }
      cx.xC[n - 1] = complex_from_i(0);
      xcdot(&cx, &cy, n, &temp, &cv2, &cv2err);
      exactnesserrors = exactnesserrors || cv2err < 0.0;
      exactnesserrors = exactnesserrors || cv2err > 4 * machineepsilon * abscomplex(cy.xC[0]);
      exactnesserrors = exactnesserrors || abscomplex(ae_c_sub(cv2, cy.xC[0])) > cv2err;
   // First test: X + X + ... + X = N*X
      s = exp((double)imax2(pass, 50));
      if (pass == passcount - 1 && pass > 1) {
         s = maxrealnumber;
      }
      cy.xC[0] = complex_from_d(randommid() * s * sqrt(2 * randomreal()));
      for (i = 1; i < n; i++) {
         cy.xC[i] = cy.xC[0];
      }
      for (i = 0; i < n; i++) {
         cx.xC[i] = complex_from_i(1);
      }
      xcdot(&cx, &cy, n, &temp, &cv2, &cv2err);
      exactnesserrors = exactnesserrors || cv2err < 0.0;
      exactnesserrors = exactnesserrors || cv2err > 4 * machineepsilon * abscomplex(cy.xC[0]) * n;
      exactnesserrors = exactnesserrors || abscomplex(ae_c_sub(cv2, ae_c_mul_d(cy.xC[0], 1.0 * n))) > cv2err;
   }
// report
   waserrors = approxerrors || exactnesserrors;
   if (!silent) {
      printf("TESTING XBLAS\n");
      printf("APPROX.TESTS:                            ");
      if (approxerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("EXACT TESTS:                             ");
      if (exactnesserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
// end
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === directdensesolvers testing unit ===
// Checks whether solver results are correct solution.
// Returns True on success.
static bool testdirectdensesolversunit_rmatrixchecksolutionm(RMatrix *xe, ae_int_t n, ae_int_t m, double threshold, ae_int_t info, densesolverreport *rep, RMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool result;
   result = true;
   if (info <= 0) {
      result = false;
   } else {
      result = result && !(rep->r1 < 100 * machineepsilon || rep->r1 > 1 + 1000 * machineepsilon);
      result = result && !(rep->rinf < 100 * machineepsilon || rep->rinf > 1 + 1000 * machineepsilon);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            result = result && fabs(xe->xyR[i][j] - xs->xyR[i][j]) <= threshold;
         }
      }
   }
   return result;
}

// Checks whether solver results are correct solution.
// Returns True on success.
static bool testdirectdensesolversunit_cmatrixchecksolutionm(CMatrix *xe, ae_int_t n, ae_int_t m, double threshold, ae_int_t info, densesolverreport *rep, CMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool result;
   result = true;
   if (info <= 0) {
      result = false;
   } else {
      result = result && !(rep->r1 < 100 * machineepsilon || rep->r1 > 1 + 1000 * machineepsilon);
      result = result && !(rep->rinf < 100 * machineepsilon || rep->rinf > 1 + 1000 * machineepsilon);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            result = result && abscomplex(ae_c_sub(xe->xyC[i][j], xs->xyC[i][j])) <= threshold;
         }
      }
   }
   return result;
}

// Checks whether solver results are correct solution.
// Returns True on success.
static bool testdirectdensesolversunit_rmatrixchecksolutionmfast(RMatrix *xe, ae_int_t n, ae_int_t m, double threshold, ae_int_t info, RMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool result;
   result = true;
   if (info <= 0) {
      result = false;
   } else {
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            result = result && fabs(xe->xyR[i][j] - xs->xyR[i][j]) <= threshold;
         }
      }
   }
   return result;
}

// Checks whether solver results are correct solution.
// Returns True on success.
static bool testdirectdensesolversunit_cmatrixchecksolutionmfast(CMatrix *xe, ae_int_t n, ae_int_t m, double threshold, ae_int_t info, CMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool result;
   result = true;
   if (info <= 0) {
      result = false;
      return result;
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < m; j++) {
         result = result && abscomplex(ae_c_sub(xe->xyC[i][j], xs->xyC[i][j])) <= threshold;
      }
   }
   return result;
}

// Checks whether solver results are correct solution.
// Returns True on success.
static bool testdirectdensesolversunit_rmatrixchecksolution(RMatrix *xe, ae_int_t n, double threshold, ae_int_t info, densesolverreport *rep, RVector *xs) {
   ae_frame _frame_block;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(xsm, 0, 0, DT_REAL);
   ae_matrix_set_length(&xsm, n, 1);
   ae_v_move(xsm.xyR[0], xsm.stride, xs->xR, 1, n);
   result = testdirectdensesolversunit_rmatrixchecksolutionm(xe, n, 1, threshold, info, rep, &xsm);
   ae_frame_leave();
   return result;
}

// Checks whether solver results are correct solution.
// Returns True on success.
static bool testdirectdensesolversunit_cmatrixchecksolution(CMatrix *xe, ae_int_t n, double threshold, ae_int_t info, densesolverreport *rep, CVector *xs) {
   ae_frame _frame_block;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(xsm, 0, 0, DT_COMPLEX);
   ae_matrix_set_length(&xsm, n, 1);
   ae_v_cmove(xsm.xyC[0], xsm.stride, xs->xC, 1, "N", n);
   result = testdirectdensesolversunit_cmatrixchecksolutionm(xe, n, 1, threshold, info, rep, &xsm);
   ae_frame_leave();
   return result;
}

// Checks whether solver results are correct solution.
// Returns True on success.
static bool testdirectdensesolversunit_rmatrixchecksolutionfast(RMatrix *xe, ae_int_t n, double threshold, ae_int_t info, RVector *xs) {
   ae_int_t i;
   bool result;
   result = true;
   if (info <= 0) {
      result = false;
   } else {
      for (i = 0; i < n; i++) {
         result = result && fabs(xe->xyR[i][0] - xs->xR[i]) <= threshold;
      }
   }
   return result;
}

// Checks whether solver results are correct solution.
// Returns True on success.
static bool testdirectdensesolversunit_cmatrixchecksolutionfast(CMatrix *xe, ae_int_t n, double threshold, ae_int_t info, CVector *xs) {
   ae_frame _frame_block;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(xsm, 0, 0, DT_COMPLEX);
   ae_matrix_set_length(&xsm, n, 1);
   ae_v_cmove(xsm.xyC[0], xsm.stride, xs->xC, 1, "N", n);
   result = testdirectdensesolversunit_cmatrixchecksolutionmfast(xe, n, 1, threshold, info, &xsm);
   ae_frame_leave();
   return result;
}

// Checks whether solver results indicate singular matrix.
// Returns True on success.
static bool testdirectdensesolversunit_rmatrixchecksingularm(ae_int_t n, ae_int_t m, ae_int_t info, densesolverreport *rep, RMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool result;
   result = true;
   if (info != -3 && info != 1) {
      result = false;
   } else {
      result = result && !(rep->r1 < 0.0 || rep->r1 > 1000 * machineepsilon);
      result = result && !(rep->rinf < 0.0 || rep->rinf > 1000 * machineepsilon);
      if (info == -3) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
               result = result && xs->xyR[i][j] == 0.0;
            }
         }
      }
   }
   return result;
}

// Checks whether solver results indicate singular matrix.
// Returns True on success.
static bool testdirectdensesolversunit_cmatrixchecksingularm(ae_int_t n, ae_int_t m, ae_int_t info, densesolverreport *rep, CMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool result;
   result = true;
   if (info != -3 && info != 1) {
      result = false;
      return result;
   }
   result = result && !(rep->r1 < 0.0 || rep->r1 > 1000 * machineepsilon);
   result = result && !(rep->rinf < 0.0 || rep->rinf > 1000 * machineepsilon);
   if (info == -3) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            result = result && ae_c_eq_d(xs->xyC[i][j], 0.0);
         }
      }
   }
   return result;
}

// Checks whether solver results indicate singular matrix.
// Returns True on success.
static bool testdirectdensesolversunit_rmatrixchecksingularmfast(ae_int_t n, ae_int_t m, ae_int_t info, RMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool result;
   result = true;
   if (info != -3) {
      result = false;
   } else {
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            result = result && xs->xyR[i][j] == 0.0;
         }
      }
   }
   return result;
}

// Checks whether solver results indicate singular matrix.
// Returns True on success.
static bool testdirectdensesolversunit_cmatrixchecksingularmfast(ae_int_t n, ae_int_t m, ae_int_t info, CMatrix *xs) {
   ae_int_t i;
   ae_int_t j;
   bool result;
   result = true;
   if (info != -3) {
      result = false;
      return result;
   }
   if (info == -3) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            result = result && ae_c_eq_d(xs->xyC[i][j], 0.0);
         }
      }
   }
   return result;
}

// Checks whether solver results indicate singular matrix.
// Returns True on success.
static bool testdirectdensesolversunit_rmatrixchecksingular(ae_int_t n, ae_int_t info, densesolverreport *rep, RVector *xs) {
   ae_frame _frame_block;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(xsm, 0, 0, DT_REAL);
   ae_matrix_set_length(&xsm, n, 1);
   ae_v_move(xsm.xyR[0], xsm.stride, xs->xR, 1, n);
   result = testdirectdensesolversunit_rmatrixchecksingularm(n, 1, info, rep, &xsm);
   ae_frame_leave();
   return result;
}

// Checks whether solver results indicate singular matrix.
// Returns True on success.
static bool testdirectdensesolversunit_cmatrixchecksingular(ae_int_t n, ae_int_t info, densesolverreport *rep, CVector *xs) {
   ae_frame _frame_block;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(xsm, 0, 0, DT_COMPLEX);
   ae_matrix_set_length(&xsm, n, 1);
   ae_v_cmove(xsm.xyC[0], xsm.stride, xs->xC, 1, "N", n);
   result = testdirectdensesolversunit_cmatrixchecksingularm(n, 1, info, rep, &xsm);
   ae_frame_leave();
   return result;
}

// Checks whether solver results indicate singular matrix.
// Returns True on success.
static bool testdirectdensesolversunit_rmatrixchecksingularfast(ae_int_t n, ae_int_t info, RVector *xs) {
   ae_int_t i;
   bool result;
   result = true;
   if (info != -3) {
      result = false;
   } else {
      for (i = 0; i < n; i++) {
         result = result && xs->xR[i] == 0.0;
      }
   }
   return result;
}

// Checks whether solver results indicate singular matrix.
// Returns True on success.
static bool testdirectdensesolversunit_cmatrixchecksingularfast(ae_int_t n, ae_int_t info, CVector *xs) {
   ae_frame _frame_block;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(xsm, 0, 0, DT_COMPLEX);
   ae_matrix_set_length(&xsm, n, 1);
   ae_v_cmove(xsm.xyC[0], xsm.stride, xs->xC, 1, "N", n);
   result = testdirectdensesolversunit_cmatrixchecksingularmfast(n, 1, info, &xsm);
   ae_frame_leave();
   return result;
}

// Copy
static void testdirectdensesolversunit_rmatrixmakeacopy(RMatrix *a, ae_int_t m, ae_int_t n, RMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m - 1 + 1, n - 1 + 1);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyR[i][j] = a->xyR[i][j];
      }
   }
}

// Copy
static void testdirectdensesolversunit_cmatrixmakeacopy(CMatrix *a, ae_int_t m, ae_int_t n, CMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m - 1 + 1, n - 1 + 1);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyC[i][j] = a->xyC[i][j];
      }
   }
}

// Drops upper or lower half of the matrix - fills it by special pattern
// which may be used later to ensure that this part wasn't changed
static void testdirectdensesolversunit_rmatrixdrophalf(RMatrix *a, ae_int_t n, bool droplower) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (droplower ? i > j : i < j) {
            a->xyR[i][j] = (double)(1 + 2 * i + 3 * j);
         }
      }
   }
}

// Drops upper or lower half of the matrix - fills it by special pattern
// which may be used later to ensure that this part wasn't changed
static void testdirectdensesolversunit_cmatrixdrophalf(CMatrix *a, ae_int_t n, bool droplower) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (droplower ? i > j : i < j) {
            a->xyC[i][j] = complex_from_i(1 + 2 * i + 3 * j);
         }
      }
   }
}

// Unsets real vector
static void testdirectdensesolversunit_unset1d(RVector *x) {
   ae_vector_set_length(x, 1);
   x->xR[0] = randommid();
}

// Unsets real vector
static void testdirectdensesolversunit_cunset1d(CVector *x) {
   ae_vector_set_length(x, 1);
   x->xC[0] = complex_from_d(randommid());
}

// Unsets real matrix
static void testdirectdensesolversunit_unset2d(RMatrix *x) {
   ae_matrix_set_length(x, 1, 1);
   x->xyR[0][0] = randommid();
}

// Unsets real matrix
static void testdirectdensesolversunit_cunset2d(CMatrix *x) {
   ae_matrix_set_length(x, 1, 1);
   x->xyC[0][0] = complex_from_d(randommid());
}

// Unsets report
static void testdirectdensesolversunit_unsetrep(densesolverreport *r) {
   r->r1 = -1.0;
   r->rinf = -1.0;
}

// Unsets report
static void testdirectdensesolversunit_unsetlsrep(densesolverlsreport *r) {
   r->r2 = -1.0;
   r->n = -1;
   r->k = -1;
   testdirectdensesolversunit_unset2d(&r->cx);
}

// Real test
static void testdirectdensesolversunit_testrsolver(ae_int_t maxn, ae_int_t maxm, ae_int_t passcount, double threshold, bool *rerrors, bool *rfserrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t m;
   ae_int_t pass;
   ae_int_t taskkind;
   double v;
   double verr;
   ae_int_t info;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(lua, 0, 0, DT_REAL);
   NewMatrix(atmp, 0, 0, DT_REAL);
   NewVector(p, 0, DT_INT);
   NewMatrix(xe, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewVector(bv, 0, DT_REAL);
   NewObj(densesolverreport, rep);
   NewObj(densesolverlsreport, repls);
   NewMatrix(x, 0, 0, DT_REAL);
   NewVector(xv, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(tx, 0, DT_REAL);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (m = 1; m <= maxm; m++) {
         // ********************************************************
         // WELL CONDITIONED TASKS
         // ability to find correct solution is tested
         // ********************************************************
         //
         // 1. generate random well conditioned matrix A.
         // 2. generate random solution vector xe
         // 3. generate right part b=A*xe
         // 4. test different methods on original A
            rmatrixrndcond(n, 1000.0, &a);
            testdirectdensesolversunit_rmatrixmakeacopy(&a, n, n, &lua);
            rmatrixlu(&lua, n, n, &p);
            ae_matrix_set_length(&xe, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  xe.xyR[i][j] = randommid();
               }
            }
            ae_matrix_set_length(&b, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, &xe.xyR[0][j], xe.stride, n);
                  b.xyR[i][j] = v;
               }
            }
         // Test solvers
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset2d(&x);
            rmatrixsolvem(&a, n, &b, m, randombool(), &info, &rep, &x);
            *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyR[i][j] = b.xyR[i][j];
               }
            }
            rmatrixsolvemfast(&a, n, &x, m, &info);
            *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            rmatrixsolve(&a, n, &bv, &info, &rep, &xv);
            *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            rmatrixsolvefast(&a, n, &bv, &info);
            *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksolutionfast(&xe, n, threshold, info, &bv);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset2d(&x);
            rmatrixlusolvem(&lua, &p, n, &b, m, &info, &rep, &x);
            *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyR[i][j] = b.xyR[i][j];
               }
            }
            rmatrixlusolvemfast(&lua, &p, n, &x, m, &info);
            set_error_flag(rerrors, !testdirectdensesolversunit_rmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x), __FILE__, __LINE__, "testdirectdensesolversunit.ap:552");
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            rmatrixlusolve(&lua, &p, n, &bv, &info, &rep, &xv);
            *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_move(xv.xR, 1, b.xyR[0], b.stride, n);
            rmatrixlusolvefast(&lua, &p, n, &xv, &info);
            set_error_flag(rerrors, !testdirectdensesolversunit_rmatrixchecksolutionfast(&xe, n, threshold, info, &xv), __FILE__, __LINE__, "testdirectdensesolversunit.ap:566");
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset2d(&x);
            rmatrixmixedsolvem(&a, &lua, &p, n, &b, m, &info, &rep, &x);
            *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            rmatrixmixedsolve(&a, &lua, &p, n, &bv, &info, &rep, &xv);
            *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
         // Test DenseSolverRLS():
         // * test on original system A*x = b
         // * test on overdetermined system with the same solution: (A' A')'*x = (b' b')'
         // * test on underdetermined system with the same solution: (A 0 0 0 ) * z = b
            info = 0;
            testdirectdensesolversunit_unsetlsrep(&repls);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            rmatrixsolvels(&a, n, n, &bv, 0.0, &info, &repls, &xv);
            if (info <= 0) {
               *rerrors = true;
            } else {
               *rerrors = (*rerrors || repls.r2 < 100 * machineepsilon) || repls.r2 > 1 + 1000 * machineepsilon;
               *rerrors = (*rerrors || repls.n != n) || repls.k != 0;
               for (i = 0; i < n; i++) {
                  *rerrors = *rerrors || fabs(xe.xyR[i][0] - xv.xR[i]) > threshold;
               }
            }
            info = 0;
            testdirectdensesolversunit_unsetlsrep(&repls);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, 2 * n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            ae_v_move(&bv.xR[n], 1, b.xyR[0], b.stride, n);
            ae_matrix_set_length(&atmp, 2 * n, n);
            copymatrix(&a, 0, n - 1, 0, n - 1, &atmp, 0, n - 1, 0, n - 1);
            copymatrix(&a, 0, n - 1, 0, n - 1, &atmp, n, 2 * n - 1, 0, n - 1);
            rmatrixsolvels(&atmp, 2 * n, n, &bv, 0.0, &info, &repls, &xv);
            if (info <= 0) {
               *rerrors = true;
            } else {
               *rerrors = (*rerrors || repls.r2 < 100 * machineepsilon) || repls.r2 > 1 + 1000 * machineepsilon;
               *rerrors = (*rerrors || repls.n != n) || repls.k != 0;
               for (i = 0; i < n; i++) {
                  *rerrors = *rerrors || fabs(xe.xyR[i][0] - xv.xR[i]) > threshold;
               }
            }
            info = 0;
            testdirectdensesolversunit_unsetlsrep(&repls);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            ae_matrix_set_length(&atmp, n, 2 * n);
            copymatrix(&a, 0, n - 1, 0, n - 1, &atmp, 0, n - 1, 0, n - 1);
            for (i = 0; i < n; i++) {
               for (j = n; j < 2 * n; j++) {
                  atmp.xyR[i][j] = 0.0;
               }
            }
            rmatrixsolvels(&atmp, n, 2 * n, &bv, 0.0, &info, &repls, &xv);
            if (info <= 0) {
               *rerrors = true;
            } else {
               *rerrors = *rerrors || repls.r2 != 0.0;
               *rerrors = (*rerrors || repls.n != 2 * n) || repls.k != n;
               for (i = 0; i < n; i++) {
                  *rerrors = *rerrors || fabs(xe.xyR[i][0] - xv.xR[i]) > threshold;
               }
               for (i = n; i < 2 * n; i++) {
                  *rerrors = *rerrors || fabs(xv.xR[i]) > threshold;
               }
            }
         // ********************************************************
         // EXACTLY SINGULAR MATRICES
         // ability to detect singularity is tested
         // ********************************************************
         //
         // 1. generate different types of singular matrices:
         //    * zero (TaskKind=0)
         //    * with zero columns (TaskKind=1)
         //    * with zero rows (TaskKind=2)
         //    * with equal rows/columns (TaskKind=2 or 3)
         // 2. generate random solution vector xe
         // 3. generate right part b=A*xe
         // 4. test different methods
            for (taskkind = 0; taskkind <= 4; taskkind++) {
               testdirectdensesolversunit_unset2d(&a);
               if (taskkind == 0) {
               // all zeros
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = 0.0;
                     }
                  }
               }
               if (taskkind == 1) {
               // there is zero column
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = randommid();
                     }
                  }
                  k = randominteger(n);
                  ae_v_muld(&a.xyR[0][k], a.stride, n, 0);
               }
               if (taskkind == 2) {
               // there is zero row
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = randommid();
                     }
                  }
                  k = randominteger(n);
                  ae_v_muld(a.xyR[k], 1, n, 0);
               }
               if (taskkind == 3) {
               // equal columns
                  if (n < 2) {
                     continue;
                  }
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = randommid();
                     }
                  }
                  k = 1 + randominteger(n - 1);
                  ae_v_move(a.xyR[0], a.stride, &a.xyR[0][k], a.stride, n);
               }
               if (taskkind == 4) {
               // equal rows
                  if (n < 2) {
                     continue;
                  }
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = randommid();
                     }
                  }
                  k = 1 + randominteger(n - 1);
                  ae_v_move(a.xyR[0], 1, a.xyR[k], 1, n);
               }
               ae_matrix_set_length(&xe, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     xe.xyR[i][j] = randommid();
                  }
               }
               ae_matrix_set_length(&b, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     v = ae_v_dotproduct(a.xyR[i], 1, &xe.xyR[0][j], xe.stride, n);
                     b.xyR[i][j] = v;
                  }
               }
               testdirectdensesolversunit_rmatrixmakeacopy(&a, n, n, &lua);
               rmatrixlu(&lua, n, n, &p);
            // Test RMatrixSolveM()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               rmatrixsolvem(&a, n, &b, m, randombool(), &info, &rep, &x);
               *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksingularm(n, m, info, &rep, &x);
            // Test RMatrixSolveMFast(); performed only for matrices
            // with zero rows or columns
               if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                  info = 0;
                  ae_matrix_set_length(&x, n, m);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        x.xyR[i][j] = b.xyR[i][j];
                     }
                  }
                  rmatrixsolvemfast(&a, n, &x, m, &info);
                  *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksingularmfast(n, m, info, &x);
               }
            // Test RMatrixSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
               rmatrixsolve(&a, n, &bv, &info, &rep, &xv);
               *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksingular(n, info, &rep, &xv);
            // Test RMatrixSolveFast(); performed only for matrices
            // with zero rows or columns
               if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                  info = 0;
                  ae_vector_set_length(&bv, n);
                  ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
                  rmatrixsolvefast(&a, n, &bv, &info);
                  set_error_flag(rerrors, !testdirectdensesolversunit_rmatrixchecksingularfast(n, info, &bv), __FILE__, __LINE__, "testdirectdensesolversunit.ap:784");
               }
            // Test RMatrixLUSolveM()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               rmatrixlusolvem(&lua, &p, n, &b, m, &info, &rep, &x);
               *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksingularm(n, m, info, &rep, &x);
            // Test RMatrixLUSolveMFast(); performed only for matrices
            // with zero rows or columns
               if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                  info = 0;
                  ae_matrix_set_length(&x, n, m);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        x.xyR[i][j] = b.xyR[i][j];
                     }
                  }
                  rmatrixlusolvemfast(&lua, &p, n, &x, m, &info);
                  set_error_flag(rerrors, !testdirectdensesolversunit_rmatrixchecksingularmfast(n, m, info, &x), __FILE__, __LINE__, "testdirectdensesolversunit.ap:808");
               }
            // Test RMatrixLUSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
               rmatrixlusolve(&lua, &p, n, &bv, &info, &rep, &xv);
               *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksingular(n, info, &rep, &xv);
            // Test RMatrixLUSolveFast(); performed only for matrices
            // with zero rows or columns
               if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                  info = 0;
                  ae_vector_set_length(&bv, n);
                  ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
                  rmatrixlusolvefast(&lua, &p, n, &bv, &info);
                  set_error_flag(rerrors, !testdirectdensesolversunit_rmatrixchecksingularfast(n, info, &bv), __FILE__, __LINE__, "testdirectdensesolversunit.ap:832");
               }
            // Test RMatrixMixedSolveM()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               rmatrixmixedsolvem(&a, &lua, &p, n, &b, m, &info, &rep, &x);
               *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksingularm(n, m, info, &rep, &x);
            // Test RMatrixMixedSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
               rmatrixmixedsolve(&a, &lua, &p, n, &bv, &info, &rep, &xv);
               *rerrors = *rerrors || !testdirectdensesolversunit_rmatrixchecksingular(n, info, &rep, &xv);
            }
         }
      }
   }
// test iterative improvement
   for (pass = 1; pass <= passcount; pass++) {
   // Test iterative improvement matrices
   //
   // A matrix/right part are constructed such that both matrix
   // and solution components are within (-1,+1). Such matrix/right part
   // have nice properties - system can be solved using iterative
   // improvement with |A*x-b| about several ulps of max(1,|b|).
      n = 100;
      ae_matrix_set_length(&a, n, n);
      ae_matrix_set_length(&b, n, 1);
      ae_vector_set_length(&bv, n);
      ae_vector_set_length(&tx, n);
      ae_vector_set_length(&xv, n);
      ae_vector_set_length(&y, n);
      for (i = 0; i < n; i++) {
         xv.xR[i] = randommid();
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = randommid();
         }
         ae_v_move(y.xR, 1, a.xyR[i], 1, n);
         xdot(&y, &xv, n, &tx, &v, &verr);
         bv.xR[i] = v;
      }
      ae_v_move(b.xyR[0], b.stride, bv.xR, 1, n);
   // Test RMatrixSolveM()
      testdirectdensesolversunit_unset2d(&x);
      rmatrixsolvem(&a, n, &b, 1, true, &info, &rep, &x);
      if (info <= 0) {
         *rfserrors = true;
      } else {
         ae_vector_set_length(&xv, n);
         ae_v_move(xv.xR, 1, x.xyR[0], x.stride, n);
         for (i = 0; i < n; i++) {
            ae_v_move(y.xR, 1, a.xyR[i], 1, n);
            xdot(&y, &xv, n, &tx, &v, &verr);
            *rfserrors = *rfserrors || fabs(v - b.xyR[i][0]) > 8 * machineepsilon * rmax2(1.0, fabs(b.xyR[i][0]));
         }
      }
   // Test RMatrixSolve()
      testdirectdensesolversunit_unset1d(&xv);
      rmatrixsolve(&a, n, &bv, &info, &rep, &xv);
      if (info <= 0) {
         *rfserrors = true;
      } else {
         for (i = 0; i < n; i++) {
            ae_v_move(y.xR, 1, a.xyR[i], 1, n);
            xdot(&y, &xv, n, &tx, &v, &verr);
            *rfserrors = *rfserrors || fabs(v - bv.xR[i]) > 8 * machineepsilon * rmax2(1.0, fabs(bv.xR[i]));
         }
      }
   // Test LS-solver on the same matrix
      rmatrixsolvels(&a, n, n, &bv, 0.0, &info, &repls, &xv);
      if (info <= 0) {
         *rfserrors = true;
      } else {
         for (i = 0; i < n; i++) {
            ae_v_move(y.xR, 1, a.xyR[i], 1, n);
            xdot(&y, &xv, n, &tx, &v, &verr);
            *rfserrors = *rfserrors || fabs(v - bv.xR[i]) > 8 * machineepsilon * rmax2(1.0, fabs(bv.xR[i]));
         }
      }
   }
   ae_frame_leave();
}

// Real test
static void testdirectdensesolversunit_testcsolver(ae_int_t maxn, ae_int_t maxm, ae_int_t passcount, double threshold, bool *cerrors, bool *rfserrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t m;
   ae_int_t pass;
   ae_int_t taskkind;
   double verr;
   complex v;
   ae_int_t info;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(lua, 0, 0, DT_COMPLEX);
   NewMatrix(atmp, 0, 0, DT_COMPLEX);
   NewVector(p, 0, DT_INT);
   NewMatrix(xe, 0, 0, DT_COMPLEX);
   NewMatrix(b, 0, 0, DT_COMPLEX);
   NewVector(bv, 0, DT_COMPLEX);
   NewObj(densesolverreport, rep);
   NewObj(densesolverlsreport, repls);
   NewMatrix(x, 0, 0, DT_COMPLEX);
   NewVector(xv, 0, DT_COMPLEX);
   NewVector(y, 0, DT_COMPLEX);
   NewVector(tx, 0, DT_REAL);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (m = 1; m <= maxm; m++) {
         // ********************************************************
         // WELL CONDITIONED TASKS
         // ability to find correct solution is tested
         // ********************************************************
         //
         // 1. generate random well conditioned matrix A.
         // 2. generate random solution vector xe
         // 3. generate right part b=A*xe
         // 4. test different methods on original A
            cmatrixrndcond(n, 1000.0, &a);
            testdirectdensesolversunit_cmatrixmakeacopy(&a, n, n, &lua);
            cmatrixlu(&lua, n, n, &p);
            ae_matrix_set_length(&xe, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  xe.xyC[i][j] = complex_from_d(randommid(), randommid());
               }
            }
            ae_matrix_set_length(&b, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  v = ae_v_cdotproduct(a.xyC[i], 1, "N", &xe.xyC[0][j], xe.stride, "N", n);
                  b.xyC[i][j] = v;
               }
            }
         // Test solvers
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset2d(&x);
            cmatrixsolvem(&a, n, &b, m, randombool(), &info, &rep, &x);
            *cerrors = *cerrors || !testdirectdensesolversunit_cmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyC[i][j] = b.xyC[i][j];
               }
            }
            cmatrixsolvemfast(&a, n, &x, m, &info);
            *cerrors = *cerrors || !testdirectdensesolversunit_cmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            cmatrixsolve(&a, n, &bv, &info, &rep, &xv);
            *cerrors = *cerrors || !testdirectdensesolversunit_cmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            cmatrixsolvefast(&a, n, &bv, &info);
            *cerrors = *cerrors || !testdirectdensesolversunit_cmatrixchecksolutionfast(&xe, n, threshold, info, &bv);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset2d(&x);
            cmatrixlusolvem(&lua, &p, n, &b, m, &info, &rep, &x);
            *cerrors = *cerrors || !testdirectdensesolversunit_cmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyC[i][j] = b.xyC[i][j];
               }
            }
            cmatrixlusolvemfast(&lua, &p, n, &x, m, &info);
            set_error_flag(cerrors, !testdirectdensesolversunit_cmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1358");
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            cmatrixlusolve(&lua, &p, n, &bv, &info, &rep, &xv);
            *cerrors = *cerrors || !testdirectdensesolversunit_cmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            cmatrixlusolvefast(&lua, &p, n, &bv, &info);
            set_error_flag(cerrors, !testdirectdensesolversunit_cmatrixchecksolutionfast(&xe, n, threshold, info, &bv), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1372");
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset2d(&x);
            cmatrixmixedsolvem(&a, &lua, &p, n, &b, m, &info, &rep, &x);
            *cerrors = *cerrors || !testdirectdensesolversunit_cmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            cmatrixmixedsolve(&a, &lua, &p, n, &bv, &info, &rep, &xv);
            *cerrors = *cerrors || !testdirectdensesolversunit_cmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
         // ********************************************************
         // EXACTLY SINGULAR MATRICES
         // ability to detect singularity is tested
         // ********************************************************
         //
         // 1. generate different types of singular matrices:
         //    * zero
         //    * with zero columns
         //    * with zero rows
         //    * with equal rows/columns
         // 2. generate random solution vector xe
         // 3. generate right part b=A*xe
         // 4. test different methods
            for (taskkind = 0; taskkind <= 4; taskkind++) {
               testdirectdensesolversunit_cunset2d(&a);
               if (taskkind == 0) {
               // all zeros
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyC[i][j] = complex_from_i(0);
                     }
                  }
               }
               if (taskkind == 1) {
               // there is zero column
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyC[i][j] = complex_from_d(randommid(), randommid());
                     }
                  }
                  k = randominteger(n);
                  ae_v_cmuld(&a.xyC[0][k], a.stride, n, 0);
               }
               if (taskkind == 2) {
               // there is zero row
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyC[i][j] = complex_from_d(randommid(), randommid());
                     }
                  }
                  k = randominteger(n);
                  ae_v_cmuld(a.xyC[k], 1, n, 0);
               }
               if (taskkind == 3) {
               // equal columns
                  if (n < 2) {
                     continue;
                  }
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyC[i][j] = complex_from_d(randommid(), randommid());
                     }
                  }
                  k = 1 + randominteger(n - 1);
                  ae_v_cmove(a.xyC[0], a.stride, &a.xyC[0][k], a.stride, "N", n);
               }
               if (taskkind == 4) {
               // equal rows
                  if (n < 2) {
                     continue;
                  }
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyC[i][j] = complex_from_d(randommid(), randommid());
                     }
                  }
                  k = 1 + randominteger(n - 1);
                  ae_v_cmove(a.xyC[0], 1, a.xyC[k], 1, "N", n);
               }
               ae_matrix_set_length(&xe, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     xe.xyC[i][j] = complex_from_d(randommid());
                  }
               }
               ae_matrix_set_length(&b, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     v = ae_v_cdotproduct(a.xyC[i], 1, "N", &xe.xyC[0][j], xe.stride, "N", n);
                     b.xyC[i][j] = v;
                  }
               }
               testdirectdensesolversunit_cmatrixmakeacopy(&a, n, n, &lua);
               cmatrixlu(&lua, n, n, &p);
            // Test CMatrixSolveM()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               cmatrixsolvem(&a, n, &b, m, randombool(), &info, &rep, &x);
               *cerrors = *cerrors || !testdirectdensesolversunit_cmatrixchecksingularm(n, m, info, &rep, &x);
            // Test CMatrixSolveMFast(); performed only for matrices
            // with zero rows or columns
               if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                  info = 0;
                  ae_matrix_set_length(&x, n, m);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        x.xyC[i][j] = b.xyC[i][j];
                     }
                  }
                  cmatrixsolvemfast(&a, n, &x, m, &info);
                  set_error_flag(cerrors, !testdirectdensesolversunit_cmatrixchecksingularmfast(n, m, info, &x), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1515");
               }
            // Test CMatrixSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
               cmatrixsolve(&a, n, &bv, &info, &rep, &xv);
               *cerrors = *cerrors || !testdirectdensesolversunit_cmatrixchecksingular(n, info, &rep, &xv);
               if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                  info = 0;
                  ae_vector_set_length(&bv, n);
                  ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
                  cmatrixsolvefast(&a, n, &bv, &info);
                  set_error_flag(cerrors, !testdirectdensesolversunit_cmatrixchecksingularfast(n, info, &bv), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1535");
               }
            // Test CMatrixLUSolveM()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               cmatrixlusolvem(&lua, &p, n, &b, m, &info, &rep, &x);
               *cerrors = *cerrors || !testdirectdensesolversunit_cmatrixchecksingularm(n, m, info, &rep, &x);
            // Test CMatrixLUSolveMFast()
               if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                  info = 0;
                  ae_matrix_set_length(&x, n, m);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        x.xyC[i][j] = b.xyC[i][j];
                     }
                  }
                  cmatrixlusolvemfast(&lua, &p, n, &x, m, &info);
                  set_error_flag(cerrors, !testdirectdensesolversunit_cmatrixchecksingularmfast(n, m, info, &x), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1559");
               }
            // Test CMatrixLUSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
               cmatrixlusolve(&lua, &p, n, &bv, &info, &rep, &xv);
               *cerrors = *cerrors || !testdirectdensesolversunit_cmatrixchecksingular(n, info, &rep, &xv);
            // Test CMatrixLUSolveFast()
               if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                  info = 0;
                  ae_vector_set_length(&bv, n);
                  ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
                  cmatrixlusolvefast(&lua, &p, n, &bv, &info);
                  set_error_flag(cerrors, !testdirectdensesolversunit_cmatrixchecksingularfast(n, info, &bv), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1582");
               }
            // Test CMatrixMixedSolveM()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               cmatrixmixedsolvem(&a, &lua, &p, n, &b, m, &info, &rep, &x);
               *cerrors = *cerrors || !testdirectdensesolversunit_cmatrixchecksingularm(n, m, info, &rep, &x);
            // Test CMatrixMixedSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
               cmatrixmixedsolve(&a, &lua, &p, n, &bv, &info, &rep, &xv);
               *cerrors = *cerrors || !testdirectdensesolversunit_cmatrixchecksingular(n, info, &rep, &xv);
            }
         }
      }
   }
// test iterative improvement
   for (pass = 1; pass <= passcount; pass++) {
   // Test iterative improvement matrices
   //
   // A matrix/right part are constructed such that both matrix
   // and solution components magnitudes are within (-1,+1).
   // Such matrix/right part have nice properties - system can
   // be solved using iterative improvement with |A*x-b| about
   // several ulps of max(1,|b|).
      n = 100;
      ae_matrix_set_length(&a, n, n);
      ae_matrix_set_length(&b, n, 1);
      ae_vector_set_length(&bv, n);
      ae_vector_set_length(&tx, 2 * n);
      ae_vector_set_length(&xv, n);
      ae_vector_set_length(&y, n);
      for (i = 0; i < n; i++) {
         xv.xC[i] = complex_from_d(randommid(), randommid());
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyC[i][j] = complex_from_d(randommid(), randommid());
         }
         ae_v_cmove(y.xC, 1, a.xyC[i], 1, "N", n);
         xcdot(&y, &xv, n, &tx, &v, &verr);
         bv.xC[i] = v;
      }
      ae_v_cmove(b.xyC[0], b.stride, bv.xC, 1, "N", n);
   // Test CMatrixSolveM()
      testdirectdensesolversunit_cunset2d(&x);
      cmatrixsolvem(&a, n, &b, 1, true, &info, &rep, &x);
      if (info <= 0) {
         *rfserrors = true;
      } else {
         ae_vector_set_length(&xv, n);
         ae_v_cmove(xv.xC, 1, x.xyC[0], x.stride, "N", n);
         for (i = 0; i < n; i++) {
            ae_v_cmove(y.xC, 1, a.xyC[i], 1, "N", n);
            xcdot(&y, &xv, n, &tx, &v, &verr);
            *rfserrors = *rfserrors || abscomplex(ae_c_sub(v, b.xyC[i][0])) > 8 * machineepsilon * rmax2(1.0, abscomplex(b.xyC[i][0]));
         }
      }
   // Test CMatrixSolve()
      testdirectdensesolversunit_cunset1d(&xv);
      cmatrixsolve(&a, n, &bv, &info, &rep, &xv);
      if (info <= 0) {
         *rfserrors = true;
      } else {
         for (i = 0; i < n; i++) {
            ae_v_cmove(y.xC, 1, a.xyC[i], 1, "N", n);
            xcdot(&y, &xv, n, &tx, &v, &verr);
            *rfserrors = *rfserrors || abscomplex(ae_c_sub(v, bv.xC[i])) > 8 * machineepsilon * rmax2(1.0, abscomplex(bv.xC[i]));
         }
      }
   // TODO: Test LS-solver on the same matrix
   }
   ae_frame_leave();
}

// SPD test
static void testdirectdensesolversunit_testspdsolver(ae_int_t maxn, ae_int_t maxm, ae_int_t passcount, double threshold, bool *spderrors, bool *rfserrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t m;
   ae_int_t pass;
   ae_int_t taskkind;
   double v;
   bool isupper;
   ae_int_t info;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(cha, 0, 0, DT_REAL);
   NewMatrix(atmp, 0, 0, DT_REAL);
   NewVector(p, 0, DT_INT);
   NewMatrix(xe, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewVector(bv, 0, DT_REAL);
   NewObj(densesolverreport, rep);
   NewObj(densesolverlsreport, repls);
   NewMatrix(x, 0, 0, DT_REAL);
   NewVector(xv, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(tx, 0, DT_REAL);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (m = 1; m <= maxm; m++) {
         // ********************************************************
         // WELL CONDITIONED TASKS
         // ability to find correct solution is tested
         // ********************************************************
         //
         // 1. generate random well conditioned matrix A.
         // 2. generate random solution vector xe
         // 3. generate right part b=A*xe
         // 4. test different methods on original A
            isupper = randombool();
            spdmatrixrndcond(n, 1000.0, &a);
            testdirectdensesolversunit_rmatrixmakeacopy(&a, n, n, &cha);
            if (!spdmatrixcholesky(&cha, n, isupper)) {
               *spderrors = true;
               ae_frame_leave();
               return;
            }
            ae_matrix_set_length(&xe, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  xe.xyR[i][j] = randommid();
               }
            }
            ae_matrix_set_length(&b, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, &xe.xyR[0][j], xe.stride, n);
                  b.xyR[i][j] = v;
               }
            }
            testdirectdensesolversunit_rmatrixdrophalf(&a, n, isupper);
            testdirectdensesolversunit_rmatrixdrophalf(&cha, n, isupper);
         // Test solvers
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset2d(&x);
            spdmatrixsolvem(&a, n, isupper, &b, m, &info, &rep, &x);
            *spderrors = *spderrors || !testdirectdensesolversunit_rmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyR[i][j] = b.xyR[i][j];
               }
            }
            spdmatrixsolvemfast(&a, n, isupper, &x, m, &info);
            set_error_flag(spderrors, !testdirectdensesolversunit_rmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1023");
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            spdmatrixsolve(&a, n, isupper, &bv, &info, &rep, &xv);
            *spderrors = *spderrors || !testdirectdensesolversunit_rmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            spdmatrixsolvefast(&a, n, isupper, &bv, &info);
            set_error_flag(spderrors, !testdirectdensesolversunit_rmatrixchecksolutionfast(&xe, n, threshold, info, &bv), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1037");
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset2d(&x);
            spdmatrixcholeskysolvem(&cha, n, isupper, &b, m, &info, &rep, &x);
            *spderrors = *spderrors || !testdirectdensesolversunit_rmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyR[i][j] = b.xyR[i][j];
               }
            }
            spdmatrixcholeskysolvemfast(&cha, n, isupper, &x, m, &info);
            set_error_flag(spderrors, !testdirectdensesolversunit_rmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1051");
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_unset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            spdmatrixcholeskysolve(&cha, n, isupper, &bv, &info, &rep, &xv);
            *spderrors = *spderrors || !testdirectdensesolversunit_rmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
            spdmatrixcholeskysolvefast(&cha, n, isupper, &bv, &info);
            set_error_flag(spderrors, !testdirectdensesolversunit_rmatrixchecksolutionfast(&xe, n, threshold, info, &bv), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1065");
         // ********************************************************
         // EXACTLY SINGULAR MATRICES
         // ability to detect singularity is tested
         // ********************************************************
         //
         // 1. generate different types of singular matrices:
         //    * zero
         //    * with zero columns
         //    * with zero rows
         //    * with equal rows/columns
         // 2. generate random solution vector xe
         // 3. generate right part b=A*xe
         // 4. test different methods
            for (taskkind = 0; taskkind <= 3; taskkind++) {
               testdirectdensesolversunit_unset2d(&a);
               if (taskkind == 0) {
               // all zeros
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = 0.0;
                     }
                  }
               }
               if (taskkind == 1) {
               // there is zero column
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = i; j < n; j++) {
                        a.xyR[i][j] = randommid();
                        a.xyR[j][i] = a.xyR[i][j];
                     }
                  }
                  k = randominteger(n);
                  ae_v_muld(&a.xyR[0][k], a.stride, n, 0);
                  ae_v_muld(a.xyR[k], 1, n, 0);
               }
               if (taskkind == 2) {
               // there is zero row
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = i; j < n; j++) {
                        a.xyR[i][j] = randommid();
                        a.xyR[j][i] = a.xyR[i][j];
                     }
                  }
                  k = randominteger(n);
                  ae_v_muld(a.xyR[k], 1, n, 0);
                  ae_v_muld(&a.xyR[0][k], a.stride, n, 0);
               }
               if (taskkind == 3) {
               // equal columns/rows
                  if (n < 2) {
                     continue;
                  }
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = i; j < n; j++) {
                        a.xyR[i][j] = randommid();
                        a.xyR[j][i] = a.xyR[i][j];
                     }
                  }
                  k = 1 + randominteger(n - 1);
                  ae_v_move(a.xyR[0], a.stride, &a.xyR[0][k], a.stride, n);
                  ae_v_move(a.xyR[0], 1, a.xyR[k], 1, n);
               }
               ae_matrix_set_length(&xe, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     xe.xyR[i][j] = randommid();
                  }
               }
               ae_matrix_set_length(&b, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     v = ae_v_dotproduct(a.xyR[i], 1, &xe.xyR[0][j], xe.stride, n);
                     b.xyR[i][j] = v;
                  }
               }
               testdirectdensesolversunit_rmatrixmakeacopy(&a, n, n, &cha);
               testdirectdensesolversunit_rmatrixdrophalf(&a, n, isupper);
               testdirectdensesolversunit_rmatrixdrophalf(&cha, n, isupper);
            // Test SPDMatrixSolveM()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               spdmatrixsolvem(&a, n, isupper, &b, m, &info, &rep, &x);
               *spderrors = *spderrors || !testdirectdensesolversunit_rmatrixchecksingularm(n, m, info, &rep, &x);
            // Test SPDMatrixSolveMFast()
               if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                  info = 0;
                  ae_matrix_set_length(&x, n, m);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        x.xyR[i][j] = b.xyR[i][j];
                     }
                  }
                  spdmatrixsolvemfast(&a, n, isupper, &x, m, &info);
                  set_error_flag(spderrors, !testdirectdensesolversunit_rmatrixchecksingularmfast(n, m, info, &x), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1181");
               }
            // Test SPDMatrixSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_unset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
               spdmatrixsolve(&a, n, isupper, &bv, &info, &rep, &xv);
               *spderrors = *spderrors || !testdirectdensesolversunit_rmatrixchecksingular(n, info, &rep, &xv);
            // Test SPDMatrixSolveFast()
               info = 0;
               ae_vector_set_length(&bv, n);
               ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
               spdmatrixsolvefast(&a, n, isupper, &bv, &info);
               set_error_flag(spderrors, !testdirectdensesolversunit_rmatrixchecksingular(n, info, &rep, &bv), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1202");
            // 'equal columns/rows' are degenerate, but
            // Cholesky matrix with equal columns/rows IS NOT degenerate,
            // so it is not used for testing purposes.
               if (taskkind != 3) {
               // Test SPDMatrixLUSolveM() (and fast version)
                  info = 0;
                  testdirectdensesolversunit_unsetrep(&rep);
                  testdirectdensesolversunit_unset2d(&x);
                  spdmatrixcholeskysolvem(&cha, n, isupper, &b, m, &info, &rep, &x);
                  *spderrors = *spderrors || !testdirectdensesolversunit_rmatrixchecksingularm(n, m, info, &rep, &x);
                  if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                     info = 0;
                     ae_matrix_set_length(&x, n, m);
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < m; j++) {
                           x.xyR[i][j] = b.xyR[i][j];
                        }
                     }
                     spdmatrixcholeskysolvemfast(&a, n, isupper, &x, m, &info);
                     set_error_flag(spderrors, !testdirectdensesolversunit_rmatrixchecksingularmfast(n, m, info, &x), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1227");
                  }
               // Test SPDMatrixLUSolve()
                  info = 0;
                  testdirectdensesolversunit_unsetrep(&rep);
                  testdirectdensesolversunit_unset2d(&x);
                  ae_vector_set_length(&bv, n);
                  ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
                  spdmatrixcholeskysolve(&cha, n, isupper, &bv, &info, &rep, &xv);
                  *spderrors = *spderrors || !testdirectdensesolversunit_rmatrixchecksingular(n, info, &rep, &xv);
                  if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                     info = 0;
                     ae_vector_set_length(&bv, n);
                     ae_v_move(bv.xR, 1, b.xyR[0], b.stride, n);
                     spdmatrixcholeskysolvefast(&a, n, isupper, &bv, &info);
                     set_error_flag(spderrors, !testdirectdensesolversunit_rmatrixchecksingularfast(n, info, &bv), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1246");
                  }
               }
            }
         }
      }
   }
   ae_frame_leave();
}

// HPD test
static void testdirectdensesolversunit_testhpdsolver(ae_int_t maxn, ae_int_t maxm, ae_int_t passcount, double threshold, bool *hpderrors, bool *rfserrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t m;
   ae_int_t pass;
   ae_int_t taskkind;
   complex v;
   bool isupper;
   ae_int_t info;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(cha, 0, 0, DT_COMPLEX);
   NewMatrix(atmp, 0, 0, DT_COMPLEX);
   NewVector(p, 0, DT_INT);
   NewMatrix(xe, 0, 0, DT_COMPLEX);
   NewMatrix(b, 0, 0, DT_COMPLEX);
   NewVector(bv, 0, DT_COMPLEX);
   NewObj(densesolverreport, rep);
   NewObj(densesolverlsreport, repls);
   NewMatrix(x, 0, 0, DT_COMPLEX);
   NewVector(xv, 0, DT_COMPLEX);
   NewVector(y, 0, DT_COMPLEX);
   NewVector(tx, 0, DT_COMPLEX);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (m = 1; m <= maxm; m++) {
         // ********************************************************
         // WELL CONDITIONED TASKS
         // ability to find correct solution is tested
         // ********************************************************
         //
         // 1. generate random well conditioned matrix A.
         // 2. generate random solution vector xe
         // 3. generate right part b=A*xe
         // 4. test different methods on original A
            isupper = randombool();
            hpdmatrixrndcond(n, 1000.0, &a);
            testdirectdensesolversunit_cmatrixmakeacopy(&a, n, n, &cha);
            if (!hpdmatrixcholesky(&cha, n, isupper)) {
               *hpderrors = true;
               ae_frame_leave();
               return;
            }
            ae_matrix_set_length(&xe, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  xe.xyC[i][j] = complex_from_d(randommid(), randommid());
               }
            }
            ae_matrix_set_length(&b, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  v = ae_v_cdotproduct(a.xyC[i], 1, "N", &xe.xyC[0][j], xe.stride, "N", n);
                  b.xyC[i][j] = v;
               }
            }
            testdirectdensesolversunit_cmatrixdrophalf(&a, n, isupper);
            testdirectdensesolversunit_cmatrixdrophalf(&cha, n, isupper);
         // Test solvers
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset2d(&x);
            hpdmatrixsolvem(&a, n, isupper, &b, m, &info, &rep, &x);
            *hpderrors = *hpderrors || !testdirectdensesolversunit_cmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyC[i][j] = b.xyC[i][j];
               }
            }
            hpdmatrixsolvemfast(&a, n, isupper, &x, m, &info);
            set_error_flag(hpderrors, !testdirectdensesolversunit_cmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1771");
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            hpdmatrixsolve(&a, n, isupper, &bv, &info, &rep, &xv);
            *hpderrors = *hpderrors || !testdirectdensesolversunit_cmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            hpdmatrixsolvefast(&a, n, isupper, &bv, &info);
            *hpderrors = *hpderrors || !testdirectdensesolversunit_cmatrixchecksolution(&xe, n, threshold, info, &rep, &bv);
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset2d(&x);
            hpdmatrixcholeskysolvem(&cha, n, isupper, &b, m, &info, &rep, &x);
            *hpderrors = *hpderrors || !testdirectdensesolversunit_cmatrixchecksolutionm(&xe, n, m, threshold, info, &rep, &x);
            info = 0;
            ae_matrix_set_length(&x, n, m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  x.xyC[i][j] = b.xyC[i][j];
               }
            }
            hpdmatrixcholeskysolvemfast(&cha, n, isupper, &x, m, &info);
            set_error_flag(hpderrors, !testdirectdensesolversunit_cmatrixchecksolutionmfast(&xe, n, m, threshold, info, &x), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1799");
            info = 0;
            testdirectdensesolversunit_unsetrep(&rep);
            testdirectdensesolversunit_cunset1d(&xv);
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            hpdmatrixcholeskysolve(&cha, n, isupper, &bv, &info, &rep, &xv);
            *hpderrors = *hpderrors || !testdirectdensesolversunit_cmatrixchecksolution(&xe, n, threshold, info, &rep, &xv);
            info = 0;
            ae_vector_set_length(&bv, n);
            ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
            hpdmatrixcholeskysolvefast(&cha, n, isupper, &bv, &info);
            set_error_flag(hpderrors, !testdirectdensesolversunit_cmatrixchecksolutionfast(&xe, n, threshold, info, &bv), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1813");
         // ********************************************************
         // EXACTLY SINGULAR MATRICES
         // ability to detect singularity is tested
         // ********************************************************
         //
         // 1. generate different types of singular matrices:
         //    * zero
         //    * with zero columns
         //    * with zero rows
         //    * with equal rows/columns
         // 2. generate random solution vector xe
         // 3. generate right part b=A*xe
         // 4. test different methods
            for (taskkind = 0; taskkind <= 3; taskkind++) {
               testdirectdensesolversunit_cunset2d(&a);
               if (taskkind == 0) {
               // all zeros
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyC[i][j] = complex_from_i(0);
                     }
                  }
               }
               if (taskkind == 1) {
               // there is zero column
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = i; j < n; j++) {
                        a.xyC[i][j] = complex_from_d(randommid(), randommid());
                        if (i == j) {
                           a.xyC[i][j].y = 0.0;
                        }
                        a.xyC[j][i] = a.xyC[i][j];
                     }
                  }
                  k = randominteger(n);
                  ae_v_cmuld(&a.xyC[0][k], a.stride, n, 0);
                  ae_v_cmuld(a.xyC[k], 1, n, 0);
               }
               if (taskkind == 2) {
               // there is zero row
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = i; j < n; j++) {
                        a.xyC[i][j] = complex_from_d(randommid(), randommid());
                        if (i == j) {
                           a.xyC[i][j].y = 0.0;
                        }
                        a.xyC[j][i] = a.xyC[i][j];
                     }
                  }
                  k = randominteger(n);
                  ae_v_cmuld(a.xyC[k], 1, n, 0);
                  ae_v_cmuld(&a.xyC[0][k], a.stride, n, 0);
               }
               if (taskkind == 3) {
               // equal columns/rows
                  if (n < 2) {
                     continue;
                  }
                  ae_matrix_set_length(&a, n, n);
                  for (i = 0; i < n; i++) {
                     for (j = i; j < n; j++) {
                        a.xyC[i][j] = complex_from_d(randommid(), randommid());
                        if (i == j) {
                           a.xyC[i][j].y = 0.0;
                        }
                        a.xyC[j][i] = a.xyC[i][j];
                     }
                  }
                  k = 1 + randominteger(n - 1);
                  ae_v_cmove(a.xyC[0], a.stride, &a.xyC[0][k], a.stride, "N", n);
                  ae_v_cmove(a.xyC[0], 1, a.xyC[k], 1, "N", n);
               }
               ae_matrix_set_length(&xe, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     xe.xyC[i][j] = complex_from_d(randommid());
                  }
               }
               ae_matrix_set_length(&b, n, m);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < m; j++) {
                     v = ae_v_cdotproduct(a.xyC[i], 1, "N", &xe.xyC[0][j], xe.stride, "N", n);
                     b.xyC[i][j] = v;
                  }
               }
               testdirectdensesolversunit_cmatrixmakeacopy(&a, n, n, &cha);
               testdirectdensesolversunit_cmatrixdrophalf(&a, n, isupper);
               testdirectdensesolversunit_cmatrixdrophalf(&cha, n, isupper);
            // Test SPDMatrixSolveM() (and fast version)
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               hpdmatrixsolvem(&a, n, isupper, &b, m, &info, &rep, &x);
               *hpderrors = *hpderrors || !testdirectdensesolversunit_cmatrixchecksingularm(n, m, info, &rep, &x);
               if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                  info = 0;
                  ae_matrix_set_length(&x, n, m);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        x.xyC[i][j] = b.xyC[i][j];
                     }
                  }
                  hpdmatrixsolvemfast(&a, n, isupper, &x, m, &info);
                  set_error_flag(hpderrors, !testdirectdensesolversunit_cmatrixchecksingularmfast(n, m, info, &x), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1934");
               }
            // Test SPDMatrixSolve()
               info = 0;
               testdirectdensesolversunit_unsetrep(&rep);
               testdirectdensesolversunit_cunset2d(&x);
               ae_vector_set_length(&bv, n);
               ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
               hpdmatrixsolve(&a, n, isupper, &bv, &info, &rep, &xv);
               *hpderrors = *hpderrors || !testdirectdensesolversunit_cmatrixchecksingular(n, info, &rep, &xv);
               if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                  info = 0;
                  ae_vector_set_length(&bv, n);
                  ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
                  hpdmatrixsolvefast(&a, n, isupper, &bv, &info);
                  set_error_flag(hpderrors, !testdirectdensesolversunit_cmatrixchecksingularfast(n, info, &bv), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1953");
               }
            // 'equal columns/rows' are degenerate, but
            // Cholesky matrix with equal columns/rows IS NOT degenerate,
            // so it is not used for testing purposes.
               if (taskkind != 3) {
               // Test SPDMatrixCholeskySolveM()/fast
                  info = 0;
                  testdirectdensesolversunit_unsetrep(&rep);
                  testdirectdensesolversunit_cunset2d(&x);
                  hpdmatrixcholeskysolvem(&cha, n, isupper, &b, m, &info, &rep, &x);
                  *hpderrors = *hpderrors || !testdirectdensesolversunit_cmatrixchecksingularm(n, m, info, &rep, &x);
                  if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                     info = 0;
                     ae_matrix_set_length(&x, n, m);
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < m; j++) {
                           x.xyC[i][j] = b.xyC[i][j];
                        }
                     }
                     hpdmatrixcholeskysolvemfast(&cha, n, isupper, &x, m, &info);
                     set_error_flag(hpderrors, !testdirectdensesolversunit_cmatrixchecksingularmfast(n, m, info, &x), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1979");
                  }
               // Test HPDMatrixCholeskySolve() (fast)
                  info = 0;
                  testdirectdensesolversunit_unsetrep(&rep);
                  testdirectdensesolversunit_cunset2d(&x);
                  ae_vector_set_length(&bv, n);
                  ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
                  hpdmatrixcholeskysolve(&cha, n, isupper, &bv, &info, &rep, &xv);
                  *hpderrors = *hpderrors || !testdirectdensesolversunit_cmatrixchecksingular(n, info, &rep, &xv);
                  if ((taskkind == 0 || taskkind == 1) || taskkind == 2) {
                     ae_vector_set_length(&bv, n);
                     ae_v_cmove(bv.xC, 1, b.xyC[0], b.stride, "N", n);
                     hpdmatrixcholeskysolvefast(&cha, n, isupper, &bv, &info);
                     set_error_flag(hpderrors, !testdirectdensesolversunit_cmatrixchecksingularfast(n, info, &bv), __FILE__, __LINE__, "testdirectdensesolversunit.ap:1997");
                  }
               }
            }
         }
      }
   }
   ae_frame_leave();
}

// Test
bool testdirectdensesolvers(bool silent) {
   ae_int_t maxn;
   ae_int_t maxm;
   ae_int_t passcount;
   double threshold;
   bool rerrors;
   bool cerrors;
   bool spderrors;
   bool hpderrors;
   bool rfserrors;
   bool waserrors;
   bool result;
   maxn = 10;
   maxm = 5;
   passcount = 5;
   threshold = 10000 * machineepsilon;
   rfserrors = false;
   rerrors = false;
   cerrors = false;
   spderrors = false;
   hpderrors = false;
   testdirectdensesolversunit_testrsolver(maxn, maxm, passcount, threshold, &rerrors, &rfserrors);
   testdirectdensesolversunit_testspdsolver(maxn, maxm, passcount, threshold, &spderrors, &rfserrors);
   testdirectdensesolversunit_testcsolver(maxn, maxm, passcount, threshold, &cerrors, &rfserrors);
   testdirectdensesolversunit_testhpdsolver(maxn, maxm, passcount, threshold, &hpderrors, &rfserrors);
   waserrors = (((rerrors || cerrors) || spderrors) || hpderrors) || rfserrors;
   if (!silent) {
      printf("TESTING DENSE SOLVER\n");
      printf("* REAL:                                   ");
      if (rerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* COMPLEX:                                ");
      if (cerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* SPD:                                    ");
      if (spderrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* HPD:                                    ");
      if (hpderrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* ITERATIVE IMPROVEMENT:                  ");
      if (rfserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
   }
   result = !waserrors;
   return result;
}

// === directsparsesolvers testing unit ===
// SPD SKS test
static void testdirectsparsesolversunit_testsks(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t maxn;
   double threshold;
   ae_int_t bw;
   bool isupper;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewObj(sparsematrix, sa2);
   NewObj(sparsesolverreport, rep);
   NewObj(hqrndstate, rs);
   passcount = 10;
   maxn = 30;
   threshold = 1.0E-6;
   hqrndrandomize(&rs);
// Well conditioned SPD problems solved with SKS solver
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
      // 1. generate random well conditioned matrix A.
      // 2. generate random solution vector xe
      // 3. generate right part b=A*xe
         isupper = hqrndnormal(&rs) > 0.5;
         bw = hqrnduniformi(&rs, n + 1);
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         sparsecreate(n, n, 0, &sa);
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 1 + hqrnduniformr(&rs);
            sparseset(&sa, i, i, a.xyR[i][i]);
            for (j = i + 1; j <= i + bw && j < n; j++) {
               a.xyR[i][j] = (hqrnduniformr(&rs) - 0.5) / n;
               a.xyR[j][i] = a.xyR[i][j];
               if (isupper) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               } else {
                  sparseset(&sa, j, i, a.xyR[i][j]);
               }
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper ? j < i : j > i) {
                  if (hqrnduniformr(&rs) < 0.25) {
                     sparseset(&sa, i, j, hqrndnormal(&rs));
                  }
               }
            }
         }
         sparseconvertto(&sa, hqrnduniformi(&rs, 3));
         ae_vector_set_length(&xe, n);
         for (i = 0; i < n; i++) {
            xe.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&b, n);
         rmatrixgemv(n, n, 1.0, &a, 0, 0, 0, &xe, 0, 0.0, &b, 0);
      // Test SKS solver
         ae_vector_set_length(&xs, 0);
         sparsecopytosks(&sa, &sa2);
         sparsespdsolvesks(&sa2, isupper, &b, &xs, &rep);
         set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:88");
         set_error_flag(errorflag, xs.cnt != n, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:89");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, fabs(xe.xR[i] - xs.xR[i]) > threshold, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:93");
         }
      // Test solver #2
         sparsecopytosks(&sa, &sa2);
         if (!sparsecholeskyskyline(&sa2, n, isupper)) {
            set_error_flag(errorflag, true, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:102");
            ae_frame_leave();
            return;
         }
         ae_vector_set_length(&xs, 0);
         sparsespdcholeskysolve(&sa2, isupper, &b, &xs, &rep);
         set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:107");
         set_error_flag(errorflag, xs.cnt != n, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:108");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, fabs(xe.xR[i] - xs.xR[i]) > threshold, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:112");
         }
      }
   }
   ae_frame_leave();
}

// SPD SKS test
static void testdirectsparsesolversunit_testcholesky(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t maxn;
   double threshold;
   ae_int_t bw;
   bool isupper;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewObj(sparsematrix, sa2);
   NewObj(sparsesolverreport, rep);
   NewObj(hqrndstate, rs);
   passcount = 10;
   maxn = 30;
   threshold = 1.0E-6;
   hqrndrandomize(&rs);
// Well conditioned SPD problems solved with Cholesky solver
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
      // 1. generate random well conditioned matrix A.
      // 2. generate random solution vector xe
      // 3. generate right part b=A*xe
         isupper = hqrndnormal(&rs) > 0.5;
         bw = hqrnduniformi(&rs, n + 1);
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         sparsecreate(n, n, 0, &sa);
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 1 + hqrnduniformr(&rs);
            sparseset(&sa, i, i, a.xyR[i][i]);
            for (j = i + 1; j <= i + bw && j < n; j++) {
               a.xyR[i][j] = (hqrnduniformr(&rs) - 0.5) / n;
               a.xyR[j][i] = a.xyR[i][j];
               if (isupper) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               } else {
                  sparseset(&sa, j, i, a.xyR[i][j]);
               }
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper ? j < i : j > i) {
                  if (hqrnduniformr(&rs) < 0.25) {
                     sparseset(&sa, i, j, hqrndnormal(&rs));
                  }
               }
            }
         }
         sparseconvertto(&sa, hqrnduniformi(&rs, 3));
         ae_vector_set_length(&xe, n);
         for (i = 0; i < n; i++) {
            xe.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&b, n);
         rmatrixgemv(n, n, 1.0, &a, 0, 0, 0, &xe, 0, 0.0, &b, 0);
      // Test CRS/AMD solver
         ae_vector_set_length(&xs, 0);
         sparsecopy(&sa, &sa2);
         sparsespdsolve(&sa2, isupper, &b, &xs, &rep);
         set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:196");
         set_error_flag(errorflag, xs.cnt != n, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:197");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, fabs(xe.xR[i] - xs.xR[i]) > threshold, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:201");
         }
      }
   }
   ae_frame_leave();
}

// General linear test
static void testdirectsparsesolversunit_testgen(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t maxn;
   double threshold;
   ae_int_t n;
   ae_int_t noffdiag;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(xs2, 0, DT_REAL);
   NewVector(pivp, 0, DT_INT);
   NewVector(pivq, 0, DT_INT);
   NewObj(sparsematrix, sa);
   NewObj(sparsematrix, sa2);
   NewObj(sparsesolverreport, rep);
   NewObj(hqrndstate, rs);
   passcount = 10;
   maxn = 30;
   threshold = 1.0E-6;
   hqrndrandomize(&rs);
// Well conditioned general linear problems solved with LU solver
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
      // Select number of off-diagonal entries, we want to try matrices
      // from dense to sparse
         noffdiag = n * (n - 1);
         while (true) {
         // 1. generate random well conditioned matrix A.
         // 2. apply row/col permutation
         // 3. generate random solution vector xe
         // 4. generate right part b=A*xe
            ae_matrix_set_length(&a, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
            }
            for (k = 0; k < noffdiag; k++) {
               i = hqrnduniformi(&rs, n);
               j = hqrnduniformi(&rs, n);
               a.xyR[i][j] = 0.01 * hqrndnormal(&rs) / n;
            }
            for (i = 0; i < n; i++) {
               a.xyR[i][i] = 1.0 + pow(2.0, hqrndnormal(&rs));
            }
            for (i = 0; i < n; i++) {
               swaprows(&a, i, i + hqrnduniformi(&rs, n - i), n);
            }
            for (i = 0; i < n; i++) {
               swapcols(&a, i, i + hqrnduniformi(&rs, n - i), n);
            }
            sparsecreate(n, n, 0, &sa);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  sparseset(&sa, i, j, a.xyR[i][j]);
               }
            }
            sparseconvertto(&sa, hqrnduniformi(&rs, 3));
            ae_vector_set_length(&xe, n);
            for (i = 0; i < n; i++) {
               xe.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&b, n);
            rmatrixgemv(n, n, 1.0, &a, 0, 0, 0, &xe, 0, 0.0, &b, 0);
         // Test solver #1
            ae_vector_set_length(&xs, 0);
            sparsesolve(&sa, &b, &xs, &rep);
            set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:285");
            set_error_flag(errorflag, xs.cnt != n, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:286");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < n; i++) {
               set_error_flag(errorflag, fabs(xe.xR[i] - xs.xR[i]) > threshold, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:290");
            }
         // Test solver #2
            ae_vector_set_length(&xs, 0);
            sparsecopytocrs(&sa, &sa2);
            sparselu(&sa2, 0, &pivp, &pivq);
            sparselusolve(&sa2, &pivp, &pivq, &b, &xs2, &rep);
            set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:300");
            set_error_flag(errorflag, xs2.cnt != n, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:301");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < n; i++) {
               set_error_flag(errorflag, fabs(xe.xR[i] - xs2.xR[i]) > threshold, __FILE__, __LINE__, "testdirectsparsesolversunit.ap:305");
            }
         // Update fill factor
            if (noffdiag == 0) {
               break;
            }
            noffdiag /= 2;
         }
      }
   }
   ae_frame_leave();
}

// Test
bool testdirectsparsesolvers(bool silent) {
   bool rskserrors;
   bool rcholerrors;
   bool rgenerrors;
   bool wereerrors;
   bool result;
   rskserrors = false;
   rcholerrors = false;
   rgenerrors = false;
   testdirectsparsesolversunit_testsks(&rskserrors);
   testdirectsparsesolversunit_testcholesky(&rcholerrors);
   testdirectsparsesolversunit_testgen(&rgenerrors);
   wereerrors = (rskserrors || rcholerrors) || rgenerrors;
   if (!silent) {
      printf("TESTING DIRECT SPARSE SOLVERS:\n");
      printf("* SPD-SKS (real)                          ");
      if (rskserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* SPD-CRS (real)                          ");
      if (rcholerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* GENERAL (real)                          ");
      if (rgenerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (wereerrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
   }
   result = !wereerrors;
   return result;
}

// === fbls testing unit ===
// Testing GMRES. Sets error flag on failure, does not change it on success.
static void testfblsunit_testgmres(bool *err) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t rk;
   ae_int_t itscnt;
   double e;
   double eprev;
   double v;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(r, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   NewObj(fblsgmresstate, state);
   hqrndrandomize(&rs);
// Test following properties:
// * increasing iterations count results in decreased residual
// * residual with ItsCnt=N is nearly zero
// * State.Qi are orthonormal
   for (n = 1; n <= 5; n++) {
   // Create problem
      hqrndnormalv(&rs, n, &x0);
      hqrndnormalm(&rs, n, n, &a);
      ae_vector_set_length(&b, n);
      rmatrixmv(n, n, &a, 0, 0, 0, &x0, 0, &b, 0);
   // Test sequence of iteration counts
      eprev = maxrealnumber;
      for (itscnt = 1; itscnt <= n; itscnt++) {
      // Solve
         fblsgmrescreate(&b, n, itscnt, &state);
         while (fblsgmresiteration(&state)) {
            rmatrixmv(n, n, &a, 0, 0, 0, &state.x, 0, &state.ax, 0);
         }
      // Check orthonormality of Qi
         set_error_flag(err, state.qi.rows < itscnt, __FILE__, __LINE__, "testfblsunit.ap:379");
         set_error_flag(err, state.qi.cols < n, __FILE__, __LINE__, "testfblsunit.ap:380");
         if (*err) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < itscnt; i++) {
            for (j = 0; j < itscnt; j++) {
               v = rdotrr(n, &state.qi, i, &state.qi, j);
               if (i == j) {
                  v--;
               }
               set_error_flag(err, fabs(v) > 100 * machineepsilon, __FILE__, __LINE__, "testfblsunit.ap:389");
            }
         }
         if (*err) {
            ae_frame_leave();
            return;
         }
      // Compute residual
         rallocv(n, &r);
         rmatrixmv(n, n, &a, 0, 0, 0, &state.xs, 0, &r, 0);
         raddv(n, -1.0, &b, &r);
         e = sqrt(rdotv2(n, &r));
      // Test condition
         set_error_flag(err, e >= eprev, __FILE__, __LINE__, "testfblsunit.ap:405");
         if (itscnt == n) {
            set_error_flag(err, e > 10000 * machineepsilon, __FILE__, __LINE__, "testfblsunit.ap:407");
         }
         eprev = e;
      }
   }
// Test that solving A*x=b with rank-k A (k<N) returns exact solution for ItsCnt >= k
   for (n = 2; n <= 10; n++) {
      for (rk = 1; rk < n; rk++) {
      // Create problem
         hqrndnormalm(&rs, n, rk, &c);
         ae_matrix_set_length(&a, n, n);
         rmatrixgemm(n, n, rk, 1.0, &c, 0, 0, 0, &c, 0, 0, 1, 0.0, &a, 0, 0);
         hqrndnormalv(&rs, n, &xe);
         ae_vector_set_length(&b, n);
         rmatrixmv(n, n, &a, 0, 0, 0, &xe, 0, &b, 0);
      // Try various iteration counts
         for (itscnt = rk; itscnt <= n; itscnt++) {
         // Solve
            fblsgmrescreate(&b, n, itscnt, &state);
            while (fblsgmresiteration(&state)) {
               rmatrixmv(n, n, &a, 0, 0, 0, &state.x, 0, &state.ax, 0);
            }
         // Compute residual
            rallocv(n, &r);
            rmatrixmv(n, n, &a, 0, 0, 0, &state.xs, 0, &r, 0);
            raddv(n, -1.0, &b, &r);
            e = sqrt(rdotv2(n, &r));
         // Test condition
            set_error_flag(err, e > 1.0E6 * machineepsilon, __FILE__, __LINE__, "testfblsunit.ap:451");
         }
      }
   }
// Test with zero matrix
   for (n = 1; n <= 10; n++) {
      for (itscnt = 1; itscnt <= n; itscnt++) {
      // Create problem
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
         }
         hqrndnormalv(&rs, n, &b);
      // Try to solve
         fblsgmrescreate(&b, n, itscnt, &state);
         while (fblsgmresiteration(&state)) {
            rmatrixmv(n, n, &a, 0, 0, 0, &state.x, 0, &state.ax, 0);
         }
      // Test solution
         for (i = 0; i < n; i++) {
            set_error_flag(err, state.xs.xR[i] != 0.0, __FILE__, __LINE__, "testfblsunit.ap:481");
         }
      }
   }
   ae_frame_leave();
}

// Testing
bool testfbls(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t mx;
   ae_int_t i;
   ae_int_t j;
   bool waserrors;
   bool cgerrors;
   bool lserrors;
   bool cholerrors;
   bool gmreserrors;
   double eps;
   double v;
   double v1;
   double v2;
   double scalea;
   bool uppera;
   double alpha;
   double e1;
   double e2;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(tmp1, 0, DT_REAL);
   NewVector(tmp2, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ea, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(buf, 0, DT_REAL);
   NewObj(fblslincgstate, cgstate);
   mx = 10;
   waserrors = false;
   cgerrors = false;
   lserrors = false;
   cholerrors = false;
   gmreserrors = false;
//
   testfblsunit_testgmres(&gmreserrors);
// Test CG solver:
// * generate problem (A, B, Alpha, XE - exact solution) and initial approximation X
// * E1 = ||A'A*x-b||
// * solve
// * E2 = ||A'A*x-b||
// * test that E2<0.001*E1
   for (n = 1; n <= mx; n++) {
      for (m = 1; m <= mx; m++) {
         ae_matrix_set_length(&a, m, n);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xe, n);
         ae_vector_set_length(&tmp1, m);
         ae_vector_set_length(&tmp2, n);
      // init A, alpha, B, X (initial approximation), XE (exact solution)
      // X is initialized in such way that is has no chances to be equal to XE.
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = randommid();
            }
         }
         alpha = randomreal() + 0.1;
         for (i = 0; i < n; i++) {
            b.xR[i] = randommid();
            xe.xR[i] = randommid();
            x.xR[i] = (2 * randominteger(2) - 1) * (2 + randomreal());
         }
      // Test dense CG (which solves A'A*x=b and accepts dense A)
         for (i = 0; i < n; i++) {
            x.xR[i] = (2 * randominteger(2) - 1) * (2 + randomreal());
         }
         rmatrixmv(m, n, &a, 0, 0, 0, &x, 0, &tmp1, 0);
         rmatrixmv(n, m, &a, 0, 0, 1, &tmp1, 0, &tmp2, 0);
         ae_v_addd(tmp2.xR, 1, x.xR, 1, n, alpha);
         ae_v_sub(tmp2.xR, 1, b.xR, 1, n);
         v = ae_v_dotproduct(tmp2.xR, 1, tmp2.xR, 1, n);
         e1 = sqrt(v);
         fblssolvecgx(&a, m, n, alpha, &b, &x, &buf);
         rmatrixmv(m, n, &a, 0, 0, 0, &x, 0, &tmp1, 0);
         rmatrixmv(n, m, &a, 0, 0, 1, &tmp1, 0, &tmp2, 0);
         ae_v_addd(tmp2.xR, 1, x.xR, 1, n, alpha);
         ae_v_sub(tmp2.xR, 1, b.xR, 1, n);
         v = ae_v_dotproduct(tmp2.xR, 1, tmp2.xR, 1, n);
         e2 = sqrt(v);
         cgerrors = cgerrors || e2 > 0.001 * e1;
      // Test sparse CG (which relies on reverse communication)
         for (i = 0; i < n; i++) {
            x.xR[i] = (2 * randominteger(2) - 1) * (2 + randomreal());
         }
         rmatrixmv(m, n, &a, 0, 0, 0, &x, 0, &tmp1, 0);
         rmatrixmv(n, m, &a, 0, 0, 1, &tmp1, 0, &tmp2, 0);
         ae_v_addd(tmp2.xR, 1, x.xR, 1, n, alpha);
         ae_v_sub(tmp2.xR, 1, b.xR, 1, n);
         v = ae_v_dotproduct(tmp2.xR, 1, tmp2.xR, 1, n);
         e1 = sqrt(v);
         fblscgcreate(&x, &b, n, &cgstate);
         while (fblscgiteration(&cgstate)) {
            rmatrixmv(m, n, &a, 0, 0, 0, &cgstate.x, 0, &tmp1, 0);
            rmatrixmv(n, m, &a, 0, 0, 1, &tmp1, 0, &cgstate.ax, 0);
            ae_v_addd(cgstate.ax.xR, 1, cgstate.x.xR, 1, n, alpha);
            v1 = ae_v_dotproduct(tmp1.xR, 1, tmp1.xR, 1, m);
            v2 = ae_v_dotproduct(cgstate.x.xR, 1, cgstate.x.xR, 1, n);
            cgstate.xax = v1 + alpha * v2;
         }
         rmatrixmv(m, n, &a, 0, 0, 0, &cgstate.xk, 0, &tmp1, 0);
         rmatrixmv(n, m, &a, 0, 0, 1, &tmp1, 0, &tmp2, 0);
         ae_v_addd(tmp2.xR, 1, cgstate.xk.xR, 1, n, alpha);
         ae_v_sub(tmp2.xR, 1, b.xR, 1, n);
         v = ae_v_dotproduct(tmp2.xR, 1, tmp2.xR, 1, n);
         e2 = sqrt(v);
         cgerrors = cgerrors || fabs(e1 - cgstate.e1) > 100 * machineepsilon * e1;
         cgerrors = cgerrors || fabs(e2 - cgstate.e2) > 100 * machineepsilon * e1;
         cgerrors = cgerrors || e2 > 0.001 * e1;
      }
   }
// Test linear least squares:
// * try N=1..5, M=N..2*N
//                           [ B ]
// * generate MxN matrix A = [   ], where (M-N)xN submatrix B contains
//                           [ C ]
//   random values from [-1,+1], and NxN submatrix C is diagonally dominant
//   (diagonal of C is equal to 1.0, and magnitude of off-diagonal elements
//   is smaller than 0.01). Such matrix is guaranteed to be non-degenerate.
// * generate random known solution xe, set right part b=A*xe
// * check that results of FBLSSolveLS agree with xe
   eps = 1.0E-6;
   for (n = 1; n <= 5; n++) {
      for (m = n; m <= 2 * n; m++) {
         ae_matrix_set_length(&a, m, n);
         for (i = 0; i < m - n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = randommid();
            }
         }
         for (i = m - n; i < m; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.01 * randommid();
            }
            a.xyR[i][i - (m - n)] = 1.0;
         }
         ae_vector_set_length(&xe, n);
         for (i = 0; i < n; i++) {
            xe.xR[i] = randommid();
         }
         ae_vector_set_length(&b, m);
         for (i = 0; i < m; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, xe.xR, 1, n);
            b.xR[i] = v;
         }
         fblssolvels(&a, &b, m, n, &tmp0, &tmp1, &tmp2);
         for (i = 0; i < n; i++) {
            lserrors = lserrors || fabs(b.xR[i] - xe.xR[i]) > eps;
         }
      }
   }
// Test Cholesky solver:
// * generate trial A, ScaleA, XS and corresponding right part B
   for (n = 1; n <= 30; n++) {
   // Generate test problem
      ae_matrix_set_length(&a, n, n);
      ae_matrix_set_length(&ea, n, n);
      ae_vector_set_length(&xe, n);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&buf, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = 0.01 * (randomreal() - 0.5);
         }
         a.xyR[i][i] = 1 + randomreal();
         xe.xR[i] = randomreal() - 0.5;
      }
      scalea = pow(10.0, randomreal() * 4 - 2);
      uppera = randombool();
      for (i = 0; i < n; i++) {
         if (uppera) {
            for (j = 0; j < i; j++) {
               ea.xyR[i][j] = 0.0;
            }
            for (j = i; j < n; j++) {
               ea.xyR[i][j] = a.xyR[i][j];
            }
         } else {
            for (j = 0; j <= i; j++) {
               ea.xyR[i][j] = a.xyR[i][j];
            }
            for (j = i + 1; j < n; j++) {
               ea.xyR[i][j] = 0.0;
            }
         }
      }
      if (uppera) {
         rmatrixgemv(n, n, 1.0, &ea, 0, 0, 0, &xe, 0, 0.0, &buf, 0);
         rmatrixgemv(n, n, 1.0, &ea, 0, 0, 1, &buf, 0, 0.0, &b, 0);
      } else {
         rmatrixgemv(n, n, 1.0, &ea, 0, 0, 1, &xe, 0, 0.0, &buf, 0);
         rmatrixgemv(n, n, 1.0, &ea, 0, 0, 0, &buf, 0, 0.0, &b, 0);
      }
      ae_v_muld(b.xR, 1, n, scalea);
   // Test
      fblscholeskysolve(&a, sqrt(scalea), n, uppera, &b, &buf);
      for (i = 0; i < n; i++) {
         set_error_flag(&cholerrors, fabs(b.xR[i] - xe.xR[i]) > 1.0E3 * machineepsilon, __FILE__, __LINE__, "testfblsunit.ap:291");
      }
   }
// report
   waserrors = ((cgerrors || lserrors) || cholerrors) || gmreserrors;
   if (!silent) {
      printf("TESTING FBLS\n");
      printf("CG ERRORS:                               ");
      if (cgerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("LS ERRORS:                               ");
      if (lserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("CHOL ERRORS:                             ");
      if (cholerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("GMRES ERRORS:                            ");
      if (gmreserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === iterativesparse testing unit ===
// Test GMRES solver.
//
// on failure sets error flag, on success does not touch it
static void testiterativesparseunit_testgmres(ae_int_t maxn, bool *err) {
   ae_frame _frame_block;
   ae_int_t nnz;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t gmresk;
   double epsf;
   bool isupper;
   double v;
   double tol;
   double rprev;
   ae_int_t requesttype;
   ae_int_t nmv;
   ae_int_t nreports;
   ae_frame_make(&_frame_block);
   NewObj(sparsematrix, a);
   NewObj(sparsematrix, crsa);
   NewVector(xref, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(b2, 0, DT_REAL);
   NewVector(ax, 0, DT_REAL);
   NewVector(xr, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(repfirst, 0, DT_REAL);
   NewVector(replast, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewObj(sparsesolverstate, solver);
   NewObj(hqrndstate, rs);
   NewObj(sparsesolverreport, rep);
   hqrndrandomize(&rs);
   epsf = pow(10.0, (double)(-4 - hqrnduniformi(&rs, 3)));
// Test that GMRES is a Krylov subspace method, i.e. its iterate belongs to span(b,A*b,A*A*b,...)
   for (n = 1; n <= maxn; n++) {
   // Generate sparse matrix and RHS.
      sparsecreate(n, n, 0, &a);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            sparseset(&a, i, j, hqrndnormal(&rs));
         }
      }
      sparsecopytocrs(&a, &crsa);
      hqrndnormalv(&rs, n, &xref);
   // Test using nonsymmetric solve
      for (gmresk = 1; gmresk < imin2(6, n); gmresk++) {
         sparsemv(&crsa, &xref, &b);
         ae_vector_set_length(&x, 0);
         sparsesolvercreate(n, &solver);
         sparsesolversetalgogmres(&solver, gmresk);
         sparsesolversetcond(&solver, 0.0, gmresk);
         sparsesolversolve(&solver, &a, &b);
         sparsesolverresults(&solver, &x, &rep);
         set_error_flag(err, x.cnt != n, __FILE__, __LINE__, "testiterativesparseunit.ap:107");
         set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testiterativesparseunit.ap:108");
         if (*err) {
            ae_frame_leave();
            return;
         }
      // Test that the solution belongs to the Krylov subspace
         ae_matrix_set_length(&z, gmresk + 1, n);
         rcopyallocv(n, &b, &xr);
         for (k = 0; k < gmresk; k++) {
            rcopyvr(n, &xr, &z, k);
            sparsemv(&crsa, &xr, &ax);
            rcopyv(n, &ax, &xr);
         }
         rcopyvr(n, &x, &z, gmresk);
         rmatrixlq(&z, gmresk + 1, n, &tmp);
         set_error_flag(err, fabs(z.xyR[gmresk][gmresk]) > 1.0E-6, __FILE__, __LINE__, "testiterativesparseunit.ap:125");
      // Additional test - R2 field is correct
         sparsemv(&crsa, &x, &ax);
         raddv(n, -1.0, &b, &ax);
         set_error_flag(err, fabs(rep.r2 - rdotv2(n, &ax)) > 1.0E-6, __FILE__, __LINE__, "testiterativesparseunit.ap:132");
      }
   }
// Randomly generated sparse problem, possibly degenerate.
// Iterate until convergence.
// Try various sparsity patterns.
   for (n = 1; n <= maxn; n++) {
      nnz = n * n;
      while (true) {
      // Generate sparse matrix and RHS.
      // The matrix is regularized by placing large elements on its diagonal
         sparsecreate(n, n, 0, &a);
         for (k = 0; k < nnz; k++) {
            sparseset(&a, hqrnduniformi(&rs, n), hqrnduniformi(&rs, n), hqrndnormal(&rs));
         }
         for (i = 0; i < n; i++) {
            sparseset(&a, i, i, (2 * hqrnduniformi(&rs, 2) - 1) * (1 + 3 * ((double)nnz / n) + sqr(hqrndnormal(&rs))));
         }
         k = hqrnduniformi(&rs, 3);
         if (k == 1) {
            sparseconverttocrs(&a);
         }
         if (k == 2) {
            sparseconverttosks(&a);
         }
         sparsecopytocrs(&a, &crsa);
         hqrndnormalv(&rs, n, &xref);
      // Symmetric solve:
      // * solver object API
      // * easy access function
      //
      // We do not test out-of-core API because it is used internally by the
      // SparseSolve/SparseSolveSymmetric pair of functions.
         gmresk = 5 + hqrnduniformi(&rs, 2 * n + 1);
         isupper = hqrndnormal(&rs) > 0.0;
         sparsesmv(&crsa, isupper, &xref, &b);
         ae_vector_set_length(&x, 0);
         sparsesolvercreate(n, &solver);
         sparsesolversetalgogmres(&solver, gmresk);
         sparsesolversetcond(&solver, epsf, 0);
         sparsesolversolvesymmetric(&solver, &a, isupper, &b);
         sparsesolverresults(&solver, &x, &rep);
         set_error_flag(err, x.cnt != n, __FILE__, __LINE__, "testiterativesparseunit.ap:180");
         set_error_flag(err, rep.terminationtype != 1, __FILE__, __LINE__, "testiterativesparseunit.ap:181");
         if (*err) {
            ae_frame_leave();
            return;
         }
         sparsesmv(&crsa, isupper, &x, &b2);
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += sqr(b.xR[i] - b2.xR[i]);
         }
         v = sqrt(v) / coalesce(sqrt(rdotv2(n, &b)), 1.0);
         set_error_flag(err, v > 1.1 * epsf, __FILE__, __LINE__, "testiterativesparseunit.ap:189");
         ae_vector_set_length(&x, 0);
         sparsesolvesymmetricgmres(&a, isupper, &b, gmresk, epsf, 0, &x, &rep);
         set_error_flag(err, x.cnt != n, __FILE__, __LINE__, "testiterativesparseunit.ap:193");
         set_error_flag(err, rep.terminationtype != 1, __FILE__, __LINE__, "testiterativesparseunit.ap:194");
         if (*err) {
            ae_frame_leave();
            return;
         }
         sparsesmv(&crsa, isupper, &x, &b2);
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += sqr(b.xR[i] - b2.xR[i]);
         }
         v = sqrt(v) / coalesce(sqrt(rdotv2(n, &b)), 1.0);
         set_error_flag(err, v > 1.1 * epsf, __FILE__, __LINE__, "testiterativesparseunit.ap:202");
      // Nonsymmetric solve
         gmresk = 5 + hqrnduniformi(&rs, 2 * n + 1);
         sparsemv(&crsa, &xref, &b);
         ae_vector_set_length(&x, 0);
         sparsesolvercreate(n, &solver);
         sparsesolversetalgogmres(&solver, gmresk);
         sparsesolversetcond(&solver, epsf, 0);
         sparsesolversolve(&solver, &a, &b);
         sparsesolverresults(&solver, &x, &rep);
         set_error_flag(err, x.cnt != n, __FILE__, __LINE__, "testiterativesparseunit.ap:215");
         set_error_flag(err, rep.terminationtype != 1, __FILE__, __LINE__, "testiterativesparseunit.ap:216");
         if (*err) {
            ae_frame_leave();
            return;
         }
         sparsemv(&crsa, &x, &b2);
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += sqr(b.xR[i] - b2.xR[i]);
         }
         v = sqrt(v) / coalesce(sqrt(rdotv2(n, &b)), 1.0);
         set_error_flag(err, v > 1.1 * epsf, __FILE__, __LINE__, "testiterativesparseunit.ap:224");
         ae_vector_set_length(&x, 0);
         sparsesolvegmres(&a, &b, gmresk, epsf, 0, &x, &rep);
         set_error_flag(err, x.cnt != n, __FILE__, __LINE__, "testiterativesparseunit.ap:228");
         set_error_flag(err, rep.terminationtype != 1, __FILE__, __LINE__, "testiterativesparseunit.ap:229");
         if (*err) {
            ae_frame_leave();
            return;
         }
         sparsemv(&crsa, &x, &b2);
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += sqr(b.xR[i] - b2.xR[i]);
         }
         v = sqrt(v) / coalesce(sqrt(rdotv2(n, &b)), 1.0);
         set_error_flag(err, v > 1.1 * epsf, __FILE__, __LINE__, "testiterativesparseunit.ap:237");
      // Increase sparsity
         if (nnz == 0) {
            break;
         }
         nnz /= 2;
      }
   }
// Check that initial point is actually used and improves the situation:
// * generate big random problem
// * solve it with GMRES(1), EpsF=0.1
// * restart using previous solution as initial point
// Restarted solution must be achieved in 1 iteration
//
// To be exact, we perform three tests:
// * initial solution needs more than 1 iteration
// * attempt to solve second time without starting point again needs more than 1 iteration
// * solution with starting point needs 1 iteration
   n = 100;
   nnz = 10 * n;
   epsf = 0.001;
   gmresk = 10;
   sparsecreate(n, n, 0, &a);
   for (k = 0; k < nnz; k++) {
      sparseset(&a, hqrnduniformi(&rs, n), hqrnduniformi(&rs, n), 0.1 * hqrndnormal(&rs));
   }
   for (k = 0; k < n; k++) {
      sparseset(&a, k, k, (2 * hqrnduniformi(&rs, 2) - 1) * ((double)nnz / n + sqr(hqrndnormal(&rs))));
   }
   sparsecopytocrs(&a, &crsa);
   hqrndnormalv(&rs, n, &xref);
   sparsemv(&crsa, &xref, &b);
   sparsesolvercreate(n, &solver);
   sparsesolversetalgogmres(&solver, gmresk);
   sparsesolversetcond(&solver, epsf, 0);
   sparsesolversolve(&solver, &a, &b);
   sparsesolverresults(&solver, &x, &rep);
   set_error_flag(err, rep.terminationtype != 1, __FILE__, __LINE__, "testiterativesparseunit.ap:278");
   set_error_flag(err, rep.iterationscount <= 1, __FILE__, __LINE__, "testiterativesparseunit.ap:279");
   if (*err) {
      ae_frame_leave();
      return;
   }
   sparsesolversolve(&solver, &a, &b);
   sparsesolverresults(&solver, &x, &rep);
   set_error_flag(err, rep.terminationtype != 1, __FILE__, __LINE__, "testiterativesparseunit.ap:285");
   set_error_flag(err, rep.iterationscount <= 1, __FILE__, __LINE__, "testiterativesparseunit.ap:286");
   if (*err) {
      ae_frame_leave();
      return;
   }
   sparsesolversetstartingpoint(&solver, &x);
   sparsesolversolve(&solver, &a, &b);
   sparsesolverresults(&solver, &x, &rep);
   set_error_flag(err, rep.terminationtype != 1, __FILE__, __LINE__, "testiterativesparseunit.ap:293");
   set_error_flag(err, rep.iterationscount > 1, __FILE__, __LINE__, "testiterativesparseunit.ap:294");
   if (*err) {
      ae_frame_leave();
      return;
   }
// Check termination request handling by the out-of-core API.
//
// Solve long-running problem, at each OOC call randomly decide whether
// we want to terminate the process or not.
   n = 100;
   nnz = 10 * n;
   epsf = 1.0E-50;
   gmresk = 1;
   sparsecreate(n, n, 0, &a);
   for (k = 0; k < nnz; k++) {
      sparseset(&a, hqrnduniformi(&rs, n), hqrnduniformi(&rs, n), 0.1 * hqrndnormal(&rs));
   }
   for (k = 0; k < n; k++) {
      sparseset(&a, k, k, 1 + sqr(hqrndnormal(&rs)));
   }
   sparsecopytocrs(&a, &crsa);
   hqrndnormalv(&rs, n, &xref);
   sparsemv(&crsa, &xref, &b);
   sparsesolvercreate(n, &solver);
   sparsesolversetalgogmres(&solver, gmresk);
   sparsesolversetcond(&solver, epsf, 0);
   sparsesolveroocstart(&solver, &b);
   while (sparsesolverooccontinue(&solver)) {
      ae_assert(solver.requesttype == 0, "SparseSolverSolve: integrity check 7372 failed");
      sparsemv(&crsa, &solver.x, &solver.ax);
      if (hqrndnormal(&rs) < 0.0) {
         sparsesolverrequesttermination(&solver);
      }
   }
   sparsesolveroocstop(&solver, &x, &rep);
   set_error_flag(err, rep.terminationtype != 8, __FILE__, __LINE__, "testiterativesparseunit.ap:329");
// Check OOC API, check reports:
// * OOC API works correctly
// * solver reports a sequence of decreased residuals
// * first report is equal to the initial point, last report is equal to the final point
// * when XRep is activated, it does not crash SparseSolve() or SparseSolveSymmetric()
   n = 100;
   nnz = 10 * n;
   epsf = 1.0E-3;
   gmresk = 5;
   tol = sqrt(machineepsilon);
   sparsecreate(n, n, 0, &a);
   for (k = 0; k < nnz; k++) {
      sparseset(&a, hqrnduniformi(&rs, n), hqrnduniformi(&rs, n), 0.1 * hqrndnormal(&rs));
   }
   for (k = 0; k < n; k++) {
      sparseset(&a, k, k, (double)nnz / n + sqr(hqrndnormal(&rs)));
   }
   sparsecopytocrs(&a, &crsa);
   hqrndnormalv(&rs, n, &xref);
   hqrndnormalv(&rs, n, &x0);
   sparsemv(&crsa, &xref, &b);
   sparsesolvercreate(n, &solver);
   sparsesolversetalgogmres(&solver, gmresk);
   sparsesolversetcond(&solver, epsf, 0);
   sparsesolversetxrep(&solver, true);
   sparsesolversetstartingpoint(&solver, &x0);
   sparsesolveroocstart(&solver, &b);
   ae_vector_set_length(&repfirst, 0);
   ae_vector_set_length(&replast, 0);
   rprev = maxrealnumber;
   nmv = 0;
   nreports = 0;
   while (sparsesolverooccontinue(&solver)) {
      sparsesolveroocgetrequestinfo(&solver, &requesttype);
      if (requesttype == -1) {
         sparsesolveroocgetrequestdata(&solver, &xr);
         sparsesolveroocgetrequestdata1(&solver, &v);
         if (repfirst.cnt == 0) {
            rcopyallocv(n, &xr, &repfirst);
         }
         rcopyallocv(n, &xr, &replast);
         sparsemv(&crsa, &xr, &ax);
         raddv(n, -1.0, &b, &ax);
         set_error_flag(err, fabs(rdotv2(n, &ax) - v) > tol * (1 + rdotv2(n, &ax)), __FILE__, __LINE__, "testiterativesparseunit.ap:376");
         set_error_flag(err, v > rprev + tol, __FILE__, __LINE__, "testiterativesparseunit.ap:377");
         rprev = v;
         nreports++;
         continue;
      }
      ae_assert(requesttype == 0, "SparseSolverSolve: integrity check 5364 failed");
      sparsesolveroocgetrequestdata(&solver, &xr);
      sparsemv(&crsa, &xr, &ax);
      nmv++;
      sparsesolveroocsendresult(&solver, &ax);
   }
   sparsesolveroocstop(&solver, &x, &rep);
   set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testiterativesparseunit.ap:389");
   set_error_flag(err, rep.nmv != nmv, __FILE__, __LINE__, "testiterativesparseunit.ap:390");
   set_error_flag(err, rep.iterationscount < (nreports - 2) * gmresk, __FILE__, __LINE__, "testiterativesparseunit.ap:391");
   set_error_flag(err, repfirst.cnt != n, __FILE__, __LINE__, "testiterativesparseunit.ap:392");
   set_error_flag(err, replast.cnt != n, __FILE__, __LINE__, "testiterativesparseunit.ap:393");
   if (*err) {
      ae_frame_leave();
      return;
   }
   for (i = 0; i < n; i++) {
      set_error_flag(err, fabs(repfirst.xR[i] - x0.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testiterativesparseunit.ap:398");
      set_error_flag(err, fabs(replast.xR[i] - x.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testiterativesparseunit.ap:399");
   }
   sparsesolversolve(&solver, &a, &b);
   sparsesolverresults(&solver, &x, &rep);
   set_error_flag(err, rep.terminationtype != 1, __FILE__, __LINE__, "testiterativesparseunit.ap:403");
   sparsesolversolvesymmetric(&solver, &a, hqrndnormal(&rs) > 0.0, &b);
   sparsesolverresults(&solver, &x, &rep);
   set_error_flag(err, rep.terminationtype != 1, __FILE__, __LINE__, "testiterativesparseunit.ap:406");
   ae_frame_leave();
}

bool testiterativesparse(bool silent) {
   ae_int_t maxn;
   bool gmreserrors;
   bool wereerrors;
   bool result;
   maxn = 50;
// Prepare error flags
   gmreserrors = false;
// Run tests
   testiterativesparseunit_testgmres(maxn, &gmreserrors);
// report
   wereerrors = gmreserrors;
   if (!silent) {
      printf("TESTING ITERATIVE SPARSE SOLVERS:\n");
      printf("* GMRES:                                      ");
      if (gmreserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
   // Were errors?
      if (wereerrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !wereerrors;
   return result;
}

// === lincg testing unit ===
static const double testlincgunit_e0 = 1.0E-6;
static const double testlincgunit_maxcond = 30.0;

// Function for testing LinCGIteration function(custom option), which to solve
// Ax=b(here A is random positive definite matrix NxN, b is random vector). It
// uses  the  default  stopping criterion(RNorm<FEps=10^-6). If algorithm does
// more iterations than size  of  the problem, then  some errors are possible.
// The test verifies the following propirties:
//     1. (A*pk,pm)=0 for any m != k;
//     2. (rk,rm)=0 for any m != k;
//     3. (rk,pm)=0 for any m != k;
//
// INPUT:
//     Silent   -   if true then function output report
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_complextest(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   double c;
   double normofresidual;
   double sclr;
   double na;
   double nv0;
   double nv1;
   ae_int_t sz;
   double mx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   double tmp;
   double getrnorm;
   ae_int_t numofit;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, state);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(residual, 0, DT_REAL);
   NewMatrix(mtx, 0, 0, DT_REAL);
   NewMatrix(mtp, 0, 0, DT_REAL);
   NewMatrix(mtr, 0, 0, DT_REAL);
   mx = 100.0;
   n = 5;
   result = false;
   for (sz = 1; sz <= n; sz++) {
   // Generate:
   // * random A with norm NA (equal to 1.0),
   // * random right part B whose elements are uniformly distributed in [-MX,+MX]
   // * random starting point X0 whose elements are uniformly distributed in [-MX,+MX]
      c = 15 + 15 * randomreal();
      spdmatrixrndcond(sz, c, &a);
      na = 1.0;
      ae_vector_set_length(&b, sz);
      for (i = 0; i < sz; i++) {
         b.xR[i] = mx * randommid();
      }
      ae_vector_set_length(&x0, sz);
      for (i = 0; i < sz; i++) {
         x0.xR[i] = mx * randommid();
      }
      ae_matrix_set_length(&mtx, sz + 1, sz);
   // Start optimization, record its progress for further analysis
   // NOTE: we set update frequency of R to 2 in order to test that R is updated correctly
      lincgcreate(sz, &state);
      lincgsetxrep(&state, true);
      lincgsetb(&state, &b);
      lincgsetstartingpoint(&state, &x0);
      lincgsetcond(&state, 0.0, sz);
      lincgsetrupdatefreq(&state, 2);
      numofit = 0;
      getrnorm = maxrealnumber;
      while (lincgiteration(&state)) {
         if (state.needmv) {
            for (i = 0; i < sz; i++) {
               state.mv.xR[i] = 0.0;
               for (j = 0; j < sz; j++) {
                  state.mv.xR[i] += a.xyR[i][j] * state.x.xR[j];
               }
            }
         }
         if (state.needvmv) {
            state.vmv = 0.0;
            for (i = 0; i < sz; i++) {
               state.mv.xR[i] = 0.0;
               for (j = 0; j < sz; j++) {
                  state.mv.xR[i] += a.xyR[i][j] * state.x.xR[j];
               }
               state.vmv += state.mv.xR[i] * state.x.xR[i];
            }
         }
         if (state.needprec) {
            for (i = 0; i < sz; i++) {
               state.pv.xR[i] = state.x.xR[i];
            }
         }
         if (state.xupdated) {
         // Save current point to MtX, it will be used later for additional tests
            if (numofit >= mtx.rows) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testlincgunit.ap:208");
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < sz; i++) {
               mtx.xyR[numofit][i] = state.x.xR[i];
            }
            getrnorm = state.r2;
            numofit++;
         }
      }
      lincgresults(&state, &x0, &rep);
      if (getrnorm != rep.r2) {
         if (!silent) {
            printf("IterationsCount=%0d;\nNMV=%0d;\nTerminationType=%0d;\n", (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype);
            printf("Size=%0d;\nCond=%0.5f;\nComplexTest::Fail::GetRNorm!=Rep.R2!(%0.2e!=%0.2e)\n", (int)sz, c, getrnorm, rep.r2);
         }
         set_error_flag(&result, true, __FILE__, __LINE__, "testlincgunit.ap:227");
         ae_frame_leave();
         return result;
      }
   // Calculate residual, check result
      ae_vector_set_length(&residual, sz);
      for (i = 0; i < sz; i++) {
         tmp = 0.0;
         for (j = 0; j < sz; j++) {
            tmp += a.xyR[i][j] * x0.xR[j];
         }
         residual.xR[i] = b.xR[i] - tmp;
      }
      normofresidual = 0.0;
      for (i = 0; i < sz; i++) {
         if (fabs(residual.xR[i]) > testlincgunit_e0) {
            if (!silent) {
               printf("IterationsCount=%0d;\nNMV=%0d;\nTerminationType=%0d;\n", (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype);
               printf("Size=%0d;\nCond=%0.5f;\nComplexTest::Fail::Discripancy[%0d]>E0!(%0.2e>%0.2e)\n", (int)sz, c, (int)i, residual.xR[i], testlincgunit_e0);
            }
            set_error_flag(&result, true, __FILE__, __LINE__, "testlincgunit.ap:254");
            ae_frame_leave();
            return result;
         }
         normofresidual += residual.xR[i] * residual.xR[i];
      }
      if (fabs(normofresidual - rep.r2) > testlincgunit_e0) {
         if (!silent) {
            printf("IterationsCount=%0d;\nNMV=%0d;\nTerminationType=%0d;\n", (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype);
            printf("Size=%0d;\nCond=%0.5f;\nComplexTest::Fail::||NormOfResidual-Rep.R2||>E0!(%0.2e>%0.2e)\n", (int)sz, c, fabs(normofresidual - rep.r2), testlincgunit_e0);
            printf("NormOfResidual=%0.2e; Rep.R2=%0.2e\n", normofresidual, rep.r2);
         }
         set_error_flag(&result, true, __FILE__, __LINE__, "testlincgunit.ap:270");
         ae_frame_leave();
         return result;
      }
   // Check algorithm properties (conjugacy/orthogonality).
   // Here we use MtX which was filled during algorithm progress towards solution.
   //
   // NOTE: this test is skipped when algorithm converged in less than SZ iterations.
      if (sz > 1 && rep.iterationscount == sz) {
         ae_matrix_set_length(&mtp, sz, sz);
         ae_matrix_set_length(&mtr, sz, sz);
         for (i = 0; i < sz; i++) {
            for (j = 0; j < sz; j++) {
               mtp.xyR[i][j] = mtx.xyR[i + 1][j] - mtx.xyR[i][j];
               tmp = 0.0;
               for (k = 0; k < sz; k++) {
                  tmp += a.xyR[j][k] * mtx.xyR[i][k];
               }
               mtr.xyR[i][j] = b.xR[j] - tmp;
            }
         }
      // (Api,pj)=0?
         sclr = 0.0;
         nv0 = 0.0;
         nv1 = 0.0;
         for (i = 0; i < sz; i++) {
            for (j = 0; j < sz; j++) {
               if (i == j) {
                  continue;
               }
               for (k = 0; k < sz; k++) {
                  tmp = 0.0;
                  for (l = 0; l < sz; l++) {
                     tmp += a.xyR[k][l] * mtp.xyR[i][l];
                  }
                  sclr += tmp * mtp.xyR[j][k];
                  nv0 += mtp.xyR[i][k] * mtp.xyR[i][k];
                  nv1 += mtp.xyR[j][k] * mtp.xyR[j][k];
               }
               nv0 = sqrt(nv0);
               nv1 = sqrt(nv1);
               if (fabs(sclr) > testlincgunit_e0 * na * rmax2(nv0, 1.0) * rmax2(nv1, 1.0)) {
                  if (!silent) {
                     printf("IterationsCount=%0d;\nNMV=%0d;\nTerminationType=%0d;\n", (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype);
                     printf("Size=%0d;\nCond=%0.5f;\nComplexTest::Fail::(Ap%0d,p%0d) != 0\n{Sclr=%0.15f; NA=%0.15f NV0=%0.15f NV1=%0.15f;}\n", (int)sz, c, (int)i, (int)j, sclr, na, nv0, nv1);
                  }
                  set_error_flag(&result, true, __FILE__, __LINE__, "testlincgunit.ap:327");
                  ae_frame_leave();
                  return result;
               }
            }
         }
      // (ri,pj)=0?
         for (i = 1; i < sz; i++) {
            for (j = 0; j < i; j++) {
               sclr = 0.0;
               nv0 = 0.0;
               nv1 = 0.0;
               for (k = 0; k < sz; k++) {
                  sclr += mtr.xyR[i][k] * mtp.xyR[j][k];
                  nv0 += mtr.xyR[i][k] * mtr.xyR[i][k];
                  nv1 += mtp.xyR[j][k] * mtp.xyR[j][k];
               }
               nv0 = sqrt(nv0);
               nv1 = sqrt(nv1);
               if (fabs(sclr) > testlincgunit_e0 * rmax2(nv0, 1.0) * rmax2(nv1, 1.0)) {
                  if (!silent) {
                     printf("IterationsCount=%0d;\nNMV=%0d;\nTerminationType=%0d;\n", (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype);
                     printf("Size=%0d;\nCond=%0.5f;\nComplexTest::Fail::(r%0d,p%0d) != 0\n{Sclr=%0.15f; NV0=%0.15f NV1=%0.15f;}\n", (int)sz, c, (int)i, (int)j, sclr, nv0, nv1);
                  }
                  set_error_flag(&result, true, __FILE__, __LINE__, "testlincgunit.ap:360");
                  ae_frame_leave();
                  return result;
               }
            }
         }
      // (ri,rj)=0?
         for (i = 0; i < sz; i++) {
            for (j = i + 1; j < sz; j++) {
               sclr = 0.0;
               nv0 = 0.0;
               nv1 = 0.0;
               for (k = 0; k < sz; k++) {
                  sclr += mtr.xyR[i][k] * mtr.xyR[j][k];
                  nv0 += mtr.xyR[i][k] * mtr.xyR[i][k];
                  nv1 += mtr.xyR[j][k] * mtr.xyR[j][k];
               }
               nv0 = sqrt(nv0);
               nv1 = sqrt(nv1);
               if (fabs(sclr) > testlincgunit_e0 * rmax2(nv0, 1.0) * rmax2(nv1, 1.0)) {
                  if (!silent) {
                     printf("IterationsCount=%0d;\nNMV=%0d;\nTerminationType=%0d;\n", (int)rep.iterationscount, (int)rep.nmv, (int)rep.terminationtype);
                     printf("Size=%0d;\nCond=%0.5f;\nComplexTest::Fail::(rm,rk) != 0\n{Sclr=%0.15f; NV0=%0.15f NV1=%0.15f;}\n", (int)sz, c, sclr, nv0, nv1);
                  }
                  set_error_flag(&result, true, __FILE__, __LINE__, "testlincgunit.ap:392");
                  ae_frame_leave();
                  return result;
               }
            }
         }
      }
   }
   if (!silent) {
      printf("ComplexTest::Ok\n");
   }
   ae_frame_leave();
   return result;
}

// This function prepare problem with a known solution 'Xs'(A*Xs-b=0). There
// b is A*Xs. After, function check algorithm result and 'Xs'.
// There used two stopping criterions:
//     1. achieved the required precision(StCrit=0);
//     2. execution of the required number of iterations(StCrit=1).
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_complexres(bool silent) {
   ae_frame _frame_block;
   double err;
   ae_int_t n;
   ae_int_t sz;
   double c;
   ae_int_t i;
   ae_int_t j;
   ae_int_t stcrit;
   double mx;
   double tmp;
   double eps;
   ae_int_t xp;
   ae_int_t nxp;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, s);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   sz = 5;
   mx = 100.0;
   nxp = 100;
   for (xp = 0; xp < nxp; xp++) {
      for (n = 1; n <= sz; n++) {
         for (stcrit = 0; stcrit <= 1; stcrit++) {
         // Generate:
         // * random A with norm NA (equal to 1.0),
         // * random solution XS whose elements are uniformly distributed in [-MX,+MX]
         // * random starting point X0 whose elements are uniformly distributed in [-MX,+MX]
         // * B = A*Xs
            c = (testlincgunit_maxcond - 1) * randomreal() + 1;
            spdmatrixrndcond(n, c, &a);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&xs, n);
            for (i = 0; i < n; i++) {
               x0.xR[i] = mx * randommid();
               xs.xR[i] = mx * randommid();
            }
            eps = 0.0;
            for (i = 0; i < n; i++) {
               b.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  b.xR[i] += a.xyR[i][j] * xs.xR[j];
               }
               eps += b.xR[i] * b.xR[i];
            }
            eps = 1.0E-6 * sqrt(eps);
         // Solve with different stopping criteria
            lincgcreate(n, &s);
            lincgsetb(&s, &b);
            lincgsetstartingpoint(&s, &x0);
            lincgsetxrep(&s, true);
            if (stcrit == 0) {
               lincgsetcond(&s, 1.0E-6, 0);
            } else {
               lincgsetcond(&s, 0.0, n);
            }
            while (lincgiteration(&s)) {
               if (s.needmv) {
                  for (i = 0; i < n; i++) {
                     s.mv.xR[i] = 0.0;
                     for (j = 0; j < n; j++) {
                        s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                     }
                  }
               }
               if (s.needvmv) {
                  s.vmv = 0.0;
                  for (i = 0; i < n; i++) {
                     s.mv.xR[i] = 0.0;
                     for (j = 0; j < n; j++) {
                        s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                     }
                     s.vmv += s.mv.xR[i] * s.x.xR[i];
                  }
               }
               if (s.needprec) {
                  for (i = 0; i < n; i++) {
                     s.pv.xR[i] = s.x.xR[i];
                  }
               }
            }
            lincgresults(&s, &x0, &rep);
         // Check result
            err = 0.0;
            for (i = 0; i < n; i++) {
               tmp = 0.0;
               for (j = 0; j < n; j++) {
                  tmp += a.xyR[i][j] * x0.xR[j];
               }
               err += sqr(b.xR[i] - tmp);
            }
            err = sqrt(err);
            if (err > eps) {
               if (!silent) {
                  printf("ComplexRes::fail\n");
                  printf("IterationsCount=%0d\n", (int)rep.iterationscount);
                  printf("NMV=%0d\n", (int)rep.nmv);
                  printf("TerminationType=%0d\n", (int)rep.terminationtype);
                  printf("X and Xs...\n");
                  for (j = 0; j < n; j++) {
                     printf("x[%0d]=%0.10f; xs[%0d]=%0.10f\n", (int)j, x0.xR[j], (int)j, xs.xR[j]);
                  }
               }
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
// test has been passed
   if (!silent) {
      printf("ComplexRes::Ok\n");
   }
   result = false;
   ae_frame_leave();
   return result;
}

// This function check, that XUpdated return State.X=X0 at zero iteration and
// State.X=X(algorithm result) at last.
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_basictestx(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t sz;
   double c;
   ae_int_t i;
   ae_int_t j;
   double mx;
   ae_int_t iters;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, s);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x00, 0, DT_REAL);
   NewVector(x01, 0, DT_REAL);
   sz = 5;
   mx = 100.0;
   for (n = 1; n <= sz; n++) {
   // Generate:
   // * random A with norm NA (equal to 1.0),
   // * random right part B whose elements are uniformly distributed in [-MX,+MX]
   // * random starting point X0 whose elements are uniformly distributed in [-MX,+MX]
      c = (testlincgunit_maxcond - 1) * randomreal() + 1;
      spdmatrixrndcond(n, c, &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&x00, n);
      ae_vector_set_length(&x01, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = mx * randommid();
         b.xR[i] = mx * randommid();
      }
   // Solve, save first and last reported points to x00 and x01
      lincgcreate(n, &s);
      lincgsetb(&s, &b);
      lincgsetstartingpoint(&s, &x0);
      lincgsetxrep(&s, true);
      lincgsetcond(&s, 0.0, n);
      iters = 0;
      while (lincgiteration(&s)) {
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
         }
         if (s.needvmv) {
            s.vmv = 0.0;
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
               s.vmv += s.mv.xR[i] * s.x.xR[i];
            }
         }
         if (s.needprec) {
            for (i = 0; i < n; i++) {
               s.pv.xR[i] = s.x.xR[i];
            }
         }
         if (s.xupdated) {
            if (iters == 0) {
               for (i = 0; i < n; i++) {
                  x00.xR[i] = s.x.xR[i];
               }
            }
            if (iters == n) {
               for (i = 0; i < n; i++) {
                  x01.xR[i] = s.x.xR[i];
               }
            }
            iters++;
         }
      }
   // Check first and last points
      for (i = 0; i < n; i++) {
         if (x00.xR[i] != x0.xR[i]) {
            if (!silent) {
               printf("BasicTestX::fail\n");
               printf("IterationsCount=%0d\n", (int)rep.iterationscount);
               printf("NMV=%0d\n", (int)rep.nmv);
               printf("TerminationType=%0d\n", (int)rep.terminationtype);
               for (j = 0; j < n; j++) {
                  printf("x0=%0.5f; x00=%0.5f;\n", x0.xR[j], x00.xR[j]);
               }
            }
            result = true;
            ae_frame_leave();
            return result;
         }
      }
      lincgresults(&s, &x0, &rep);
      for (i = 0; i < n; i++) {
         if (x01.xR[i] != x0.xR[i]) {
            if (!silent) {
               printf("BasicTestX::fail\n");
               printf("IterationsCount=%0d\n", (int)rep.iterationscount);
               printf("NMV=%0d\n", (int)rep.nmv);
               printf("TerminationType=%0d\n", (int)rep.terminationtype);
               for (j = 0; j < n; j++) {
                  printf("x0=%0.5f; x01=%0.5f;\n", x0.xR[j], x01.xR[j]);
               }
            }
            result = true;
            ae_frame_leave();
            return result;
         }
      }
   }
// test has been passed
   if (!silent) {
      printf("BasicTestIters::Ok\n");
   }
   result = false;
   ae_frame_leave();
   return result;
}

// This function checks that XUpdated returns correct State.R2. It creates
// large badly conditioned problem (N=50), which should be large enough and
// ill-conditioned enough to cause periodic recalculation of R.
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_testrcorrectness(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   double c;
   ae_int_t i;
   ae_int_t j;
   double r2;
   double v;
   double rtol;
   ae_int_t maxits;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, s);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   rtol = 1.0E6 * machineepsilon;
   n = 50;
   maxits = n / 2;
   c = 10000.0;
   spdmatrixrndcond(n, c, &a);
   ae_vector_set_length(&b, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = randommid();
   }
   lincgcreate(n, &s);
   lincgsetb(&s, &b);
   lincgsetxrep(&s, true);
   lincgsetcond(&s, 0.0, maxits);
   while (lincgiteration(&s)) {
      if (s.needmv) {
         for (i = 0; i < n; i++) {
            s.mv.xR[i] = 0.0;
            for (j = 0; j < n; j++) {
               s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
            }
         }
      }
      if (s.needvmv) {
         s.vmv = 0.0;
         for (i = 0; i < n; i++) {
            s.mv.xR[i] = 0.0;
            for (j = 0; j < n; j++) {
               s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
            }
            s.vmv += s.mv.xR[i] * s.x.xR[i];
         }
      }
      if (s.needprec) {
         for (i = 0; i < n; i++) {
            s.pv.xR[i] = s.x.xR[i];
         }
      }
      if (s.xupdated) {
      // calculate R2, compare with value returned in state.R2
         r2 = 0.0;
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += a.xyR[i][j] * s.x.xR[j];
            }
            r2 += sqr(v - b.xR[i]);
         }
         if (fabs(r2 - s.r2) > rtol) {
            result = true;
            ae_frame_leave();
            return result;
         }
      }
   }
   lincgresults(&s, &b, &rep);
   if (rep.iterationscount != maxits) {
      result = true;
      ae_frame_leave();
      return result;
   }
   result = false;
   ae_frame_leave();
   return result;
}

// This function check, that number of iterations are't more than MaxIts.
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_basictestiters(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t sz;
   double c;
   ae_int_t i;
   ae_int_t j;
   double mx;
   ae_int_t iters;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, s);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   sz = 5;
   mx = 100.0;
   for (n = 1; n <= sz; n++) {
   // Generate:
   // * random A with norm NA (equal to 1.0),
   // * random right part B whose elements are uniformly distributed in [-MX,+MX]
   // * random starting point X0 whose elements are uniformly distributed in [-MX,+MX]
      c = (testlincgunit_maxcond - 1) * randomreal() + 1;
      spdmatrixrndcond(n, c, &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = mx * randommid();
         b.xR[i] = mx * randommid();
      }
   // Solve
      lincgcreate(n, &s);
      lincgsetb(&s, &b);
      lincgsetstartingpoint(&s, &x0);
      lincgsetxrep(&s, true);
      lincgsetcond(&s, 0.0, n);
      iters = 0;
      while (lincgiteration(&s)) {
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
         }
         if (s.needvmv) {
            s.vmv = 0.0;
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
               s.vmv += s.mv.xR[i] * s.x.xR[i];
            }
         }
         if (s.needprec) {
            for (i = 0; i < n; i++) {
               s.pv.xR[i] = s.x.xR[i];
            }
         }
         if (s.xupdated) {
            iters++;
         }
      }
      lincgresults(&s, &x0, &rep);
   // Check
      if (iters != rep.iterationscount + 1 || iters > n + 1) {
         if (!silent) {
            printf("BasicTestIters::fail\n");
            printf("IterationsCount=%0d\n", (int)rep.iterationscount);
            printf("NMV=%0d\n", (int)rep.nmv);
            printf("TerminationType=%0d\n", (int)rep.terminationtype);
            printf("Iters=%0d\n", (int)iters);
         }
         result = true;
         ae_frame_leave();
         return result;
      }
   // Restart problem
      c = (testlincgunit_maxcond - 1) * randomreal() + 1;
      spdmatrixrndcond(n, c, &a);
      for (i = 0; i < n; i++) {
         x0.xR[i] = mx * randommid();
         b.xR[i] = mx * randommid();
      }
      lincgsetstartingpoint(&s, &x0);
      lincgrestart(&s);
      lincgsetb(&s, &b);
      iters = 0;
      while (lincgiteration(&s)) {
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
         }
         if (s.needvmv) {
            s.vmv = 0.0;
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
               s.vmv += s.mv.xR[i] * s.x.xR[i];
            }
         }
         if (s.needprec) {
            for (i = 0; i < n; i++) {
               s.pv.xR[i] = s.x.xR[i];
            }
         }
         if (s.xupdated) {
            iters++;
         }
      }
      lincgresults(&s, &x0, &rep);
   // check
      if (iters != rep.iterationscount + 1 || iters > n + 1) {
         if (!silent) {
            printf("BasicTestIters::fail\n");
            printf("IterationsCount=%0d\n", (int)rep.iterationscount);
            printf("NMV=%0d\n", (int)rep.nmv);
            printf("TerminationType=%0d\n", (int)rep.terminationtype);
            printf("Iters=%0d\n", (int)iters);
         }
         result = true;
         ae_frame_leave();
         return result;
      }
   }
// test has been passed
   if (!silent) {
      printf("BasicTestIters::Ok\n");
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Orthogonalization by Gram-Shmidt method.
static void testlincgunit_gramshmidtortnorm(RMatrix *a, ae_int_t n, ae_int_t k, double eps, RMatrix *b, ae_int_t *k2) {
   double scaling;
   double tmp;
   double e;
   ae_int_t i;
   ae_int_t j;
   ae_int_t l;
   ae_int_t m;
   double sc;
   SetMatrix(b);
   *k2 = 0;
   *k2 = 0;
   scaling = 0.0;
   ae_matrix_set_length(b, k, n);
   for (i = 0; i < k; i++) {
      tmp = 0.0;
      for (j = 0; j < n; j++) {
         tmp += a->xyR[i][j] * a->xyR[i][j];
      }
      if (tmp > scaling) {
         scaling = tmp;
      }
   }
   scaling = sqrt(scaling);
   e = eps * scaling;
   for (i = 0; i < k; i++) {
      tmp = 0.0;
      for (j = 0; j < n; j++) {
         b->xyR[*k2][j] = a->xyR[i][j];
         tmp += a->xyR[i][j] * a->xyR[i][j];
      }
      tmp = sqrt(tmp);
      if (tmp <= e) {
         continue;
      }
      for (j = 0; j < *k2; j++) {
         sc = 0.0;
         for (m = 0; m < n; m++) {
            sc += b->xyR[*k2][m] * b->xyR[j][m];
         }
         for (l = 0; l < n; l++) {
            b->xyR[*k2][l] -= sc * b->xyR[j][l];
         }
      }
      tmp = 0.0;
      for (j = 0; j < n; j++) {
         tmp += b->xyR[*k2][j] * b->xyR[*k2][j];
      }
      tmp = sqrt(tmp);
      if (tmp <= e) {
         continue;
      } else {
         for (j = 0; j < n; j++) {
            b->xyR[*k2][j] /= tmp;
         }
      }
      ++*k2;
   }
}

// Checks that a vector belongs to the basis.
static bool testlincgunit_frombasis(RVector *x, RMatrix *basis, ae_int_t n, ae_int_t k, double eps) {
   ae_frame _frame_block;
   double normx;
   ae_int_t k2;
   ae_int_t i;
   ae_int_t j;
   double alpha;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(ortnormbasis, 0, 0, DT_REAL);
   NewVector(alphas, 0, DT_REAL);
   ae_vector_set_length(&alphas, k);
// calculating NORM for X
   normx = 0.0;
   for (i = 0; i < n; i++) {
      normx += x->xR[i] * x->xR[i];
   }
   normx = sqrt(normx);
// Gram-Shmidt method
   testlincgunit_gramshmidtortnorm(basis, n, k, pow(machineepsilon, 0.75), &ortnormbasis, &k2);
   for (i = 0; i < k2; i++) {
      alpha = 0.0;
      for (j = 0; j < n; j++) {
         alpha += x->xR[j] * ortnormbasis.xyR[i][j];
      }
      alphas.xR[i] = alpha;
   }
// check
   for (i = 0; i < n; i++) {
      alpha = 0.0;
      for (j = 0; j < k2; j++) {
         alpha += alphas.xR[j] * ortnormbasis.xyR[j][i];
      }
      if (fabs(x->xR[i] - alpha) > normx * eps) {
         result = false;
         ae_frame_leave();
         return result;
      }
   }
   result = true;
   ae_frame_leave();
   return result;
}

// This function check, that programmed method is Krylov subspace methed.
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_krylovsubspacetest(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t sz;
   double c;
   ae_int_t i;
   ae_int_t j;
   ae_int_t l;
   ae_int_t m;
   double mx;
   double tmp;
   double normr0;
   ae_int_t numofit;
   ae_int_t maxits;
   ae_int_t k2;
   double eps;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, s);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewMatrix(ksr, 0, 0, DT_REAL);
   NewVector(r0, 0, DT_REAL);
   NewVector(tarray, 0, DT_REAL);
   NewMatrix(mtx, 0, 0, DT_REAL);
   eps = 1.0E-6;
   maxits = 3;
   sz = 5;
   mx = 100.0;
   result = false;
   for (n = 1; n <= sz; n++) {
   // Generate:
   // * random A with unit norm
   // * cond(A) in [0.5*MaxCond, 1.0*MaxCond]
   // * random x0 and b such that |A*x0-b| is large enough for algorithm to make at least one iteration.
   //
   // IMPORTANT: it is very important to have cond(A) both (1) not very large and
   //            (2) not very small. Large cond(A) will make our problem ill-conditioned,
   //            thus analytic properties won't hold. Small cond(A), from the other side,
   //            will give us rapid convergence of the algorithm - in fact, too rapid.
   //            Krylov basis will be dominated by numerical noise and test may fail.
      c = testlincgunit_maxcond * (0.5 * randomreal() + 0.5);
      spdmatrixrndcond(n, c, &a);
      ae_matrix_set_length(&mtx, n + 1, n);
      ae_matrix_set_length(&ksr, n, n);
      ae_vector_set_length(&r0, n);
      ae_vector_set_length(&tarray, n);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      do {
         for (i = 0; i < n; i++) {
            x0.xR[i] = mx * randommid();
            b.xR[i] = mx * randommid();
         }
         normr0 = 0.0;
         for (i = 0; i < n; i++) {
            tmp = 0.0;
            for (j = 0; j < n; j++) {
               tmp += a.xyR[i][j] * x0.xR[j];
            }
            r0.xR[i] = b.xR[i] - tmp;
            normr0 += r0.xR[i] * r0.xR[i];
         }
      } while (sqrt(normr0) <= eps);
   // Fill KSR by {r0, A*r0, A^2*r0, ... }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            ksr.xyR[i][j] = r0.xR[j];
         }
         for (j = 0; j < i; j++) {
            for (l = 0; l < n; l++) {
               tarray.xR[l] = 0.0;
               for (m = 0; m < n; m++) {
                  tarray.xR[l] += a.xyR[l][m] * ksr.xyR[i][m];
               }
            }
            for (l = 0; l < n; l++) {
               ksr.xyR[i][l] = tarray.xR[l];
            }
         }
      }
   // Solve system, record intermediate points for futher analysis.
   // NOTE: we set update frequency of R to 2 in order to test that R is updated correctly
      lincgcreate(n, &s);
      lincgsetb(&s, &b);
      lincgsetstartingpoint(&s, &x0);
      lincgsetxrep(&s, true);
      lincgsetcond(&s, 0.0, n);
      lincgsetrupdatefreq(&s, 2);
      numofit = 0;
      while (lincgiteration(&s)) {
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
         }
         if (s.needvmv) {
            s.vmv = 0.0;
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
               s.vmv += s.mv.xR[i] * s.x.xR[i];
            }
         }
         if (s.needprec) {
            for (i = 0; i < n; i++) {
               s.pv.xR[i] = s.x.xR[i];
            }
         }
         if (s.xupdated) {
            for (i = 0; i < n; i++) {
               mtx.xyR[numofit][i] = s.x.xR[i];
            }
            numofit++;
         }
      }
   // Check that I-th step S_i=X[I+1]-X[i] belongs to I-th Krylov subspace.
   // Checks are done for first K2 steps, with K2 small enough to avoid
   // numerical errors.
      if (n <= maxits) {
         k2 = n;
      } else {
         k2 = maxits;
      }
      for (i = 0; i < k2; i++) {
         for (j = 0; j < n; j++) {
            tarray.xR[j] = mtx.xyR[i + 1][j] - mtx.xyR[i][j];
         }
         if (!testlincgunit_frombasis(&tarray, &ksr, n, i + 1, testlincgunit_e0)) {
            if (!silent) {
               printf("KrylovSubspaceTest::FAIL\n");
               printf("Size=%0d; Iters=%0d;\n", (int)n, (int)i);
            }
            set_error_flag(&result, true, __FILE__, __LINE__, "testlincgunit.ap:1129");
            ae_frame_leave();
            return result;
         }
      }
   }
   if (!silent) {
      printf("KrylovSubspaceTest::OK\n");
   }
   ae_frame_leave();
   return result;
}

// Function for testing  LinCgSolveSparse. This function  prepare problem with
// a known solution 'Xs'(A*Xs-b=0). There b is A*Xs. After, function calculate
// result by LinCGSolveSparse and compares it with 'Xs'.
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_sparsetest(bool silent) {
   ae_frame _frame_block;
   double err;
   ae_int_t n;
   ae_int_t sz;
   double c;
   ae_int_t i;
   ae_int_t j;
   double mx;
   double eps;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, s);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewObj(sparsematrix, uppera);
   NewObj(sparsematrix, lowera);
   sz = 5;
   mx = 100.0;
   for (n = 1; n <= sz; n++) {
   // Generate:
   // * random A with unit norm
   // * random X0 (starting point) and XS (known solution)
   // Copy dense A to sparse SA
      c = (testlincgunit_maxcond - 1) * randomreal() + 1;
      spdmatrixrndcond(n, c, &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&xs, n);
      for (i = 0; i < n; i++) {
         xs.xR[i] = mx * randommid();
      }
      eps = 0.0;
      for (i = 0; i < n; i++) {
         b.xR[i] = 0.0;
         for (j = 0; j < n; j++) {
            b.xR[i] += a.xyR[i][j] * xs.xR[j];
         }
         eps += b.xR[i] * b.xR[i];
      }
      eps = 1.0E-6 * sqrt(eps);
      sparsecreate(n, n, 0, &uppera);
      sparsecreate(n, n, 0, &lowera);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (j >= i) {
               sparseset(&uppera, i, j, a.xyR[i][j]);
            }
            if (j <= i) {
               sparseset(&lowera, i, j, a.xyR[i][j]);
            }
         }
      }
      sparseconverttocrs(&uppera);
      sparseconverttocrs(&lowera);
   // Test upper triangle
      lincgcreate(n, &s);
      lincgsetcond(&s, 0.0, n);
      lincgsolvesparse(&s, &uppera, true, &b);
      lincgresults(&s, &x0, &rep);
      err = 0.0;
      for (i = 0; i < n; i++) {
         err += sqr(x0.xR[i] - xs.xR[i]);
      }
      err = sqrt(err);
      if (err > eps) {
         result = true;
         ae_frame_leave();
         return result;
      }
   // Test lower triangle
      lincgcreate(n, &s);
      lincgsetcond(&s, 0.0, n);
      lincgsolvesparse(&s, &lowera, false, &b);
      lincgresults(&s, &x1, &rep);
      err = 0.0;
      for (i = 0; i < n; i++) {
         err += sqr(x1.xR[i] - xs.xR[i]);
      }
      err = sqrt(err);
      if (err > eps) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Function for testing  the preconditioned conjugate gradient method.
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlincgunit_precondtest(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t sz;
   ae_int_t numofit;
   double c;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double eps;
   bool bflag;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(lincgstate, s);
   NewObj(lincgreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ta, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewVector(m, 0, DT_REAL);
   NewMatrix(mtx, 0, 0, DT_REAL);
   NewMatrix(mtprex, 0, 0, DT_REAL);
   NewVector(de, 0, DT_REAL);
   NewVector(rde, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(tb, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(tx0, 0, DT_REAL);
   NewVector(err, 0, DT_REAL);
// Test 1.
//
// Preconditioned CG for A*x=b with preconditioner M=E*E' is algebraically
// equivalent to non-preconditioned CG for (inv(E)*A*inv(E'))*z = inv(E)*b
// with z=E'*x.
//
// We test it by generating random preconditioner, running algorithm twice -
// one  time  for  original  problem  with  preconditioner , another one  for
// modified problem without preconditioner.
   sz = 5;
   for (n = 1; n <= sz; n++) {
   // Generate:
   // * random A with unit norm
   // * random positive definite diagonal preconditioner M
   // * dE=sqrt(M)
   // * rdE=dE^(-1)
   // * tA = rdE*A*rdE
   // * random x0 and b - for original preconditioned problem
   // * tx0 and tb - for modified problem
      c = (testlincgunit_maxcond - 1) * randomreal() + 1;
      spdmatrixrndcond(n, c, &a);
      ae_matrix_set_length(&ta, n, n);
      ae_matrix_set_length(&mtx, n + 1, n);
      ae_matrix_set_length(&mtprex, n + 1, n);
      ae_vector_set_length(&m, n);
      ae_vector_set_length(&de, n);
      ae_vector_set_length(&rde, n);
      for (i = 0; i < n; i++) {
         m.xR[i] = randomreal() + 0.5;
         de.xR[i] = sqrt(m.xR[i]);
         rde.xR[i] = 1 / de.xR[i];
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            ta.xyR[i][j] = rde.xR[i] * a.xyR[i][j] * rde.xR[j];
         }
      }
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&tb, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&tx0, n);
      ae_vector_set_length(&err, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         b.xR[i] = randommid();
      }
      eps = 1.0E-5;
      for (i = 0; i < n; i++) {
         tx0.xR[i] = de.xR[i] * x0.xR[i];
         tb.xR[i] = rde.xR[i] * b.xR[i];
      }
   // Solve two problems, intermediate points are saved to MtX and MtPreX
      lincgcreate(n, &s);
      lincgsetb(&s, &b);
      lincgsetstartingpoint(&s, &x0);
      lincgsetxrep(&s, true);
      lincgsetcond(&s, 0.0, n);
      numofit = 0;
      while (lincgiteration(&s)) {
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
         }
         if (s.needvmv) {
            s.vmv = 0.0;
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
               s.vmv += s.mv.xR[i] * s.x.xR[i];
            }
         }
         if (s.needprec) {
            for (i = 0; i < n; i++) {
               s.pv.xR[i] = s.x.xR[i] / m.xR[i];
            }
         }
         if (s.xupdated) {
            if (numofit >= mtx.rows) {
               result = true;
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < n; i++) {
               mtx.xyR[numofit][i] = s.x.xR[i];
            }
            numofit++;
         }
      }
      lincgsetstartingpoint(&s, &tx0);
      lincgsetb(&s, &tb);
      lincgrestart(&s);
      numofit = 0;
      while (lincgiteration(&s)) {
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += ta.xyR[i][j] * s.x.xR[j];
               }
            }
         }
         if (s.needvmv) {
            s.vmv = 0.0;
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += ta.xyR[i][j] * s.x.xR[j];
               }
               s.vmv += s.mv.xR[i] * s.x.xR[i];
            }
         }
         if (s.needprec) {
            for (i = 0; i < n; i++) {
               s.pv.xR[i] = s.x.xR[i];
            }
         }
         if (s.xupdated) {
            if (numofit >= mtprex.rows) {
               result = true;
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < n; i++) {
               mtprex.xyR[numofit][i] = s.x.xR[i];
            }
            numofit++;
         }
      }
   // Compare results - sequence of points generated when solving original problem with
   // points generated by modified problem.
      for (i = 0; i < numofit; i++) {
         for (j = 0; j < n; j++) {
            if (fabs(mtx.xyR[i][j] - rde.xR[j] * mtprex.xyR[i][j]) > eps) {
               if (!silent) {
                  printf("PrecondTest::fail\n");
                  printf("Size=%0d\n", (int)n);
                  printf("IterationsCount=%0d\n", (int)rep.iterationscount);
                  printf("NMV=%0d\n", (int)rep.nmv);
                  printf("TerminationType=%0d\n", (int)rep.terminationtype);
                  printf("X and X^...\n");
                  for (k = 0; k < n; k++) {
                     printf("I=%0d; mtx[%0d]=%0.10f; mtx^[%0d]=%0.10f\n", (int)i, (int)k, mtx.xyR[i][k], (int)k, mtprex.xyR[i][k]);
                  }
               }
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
// Test 2.
//
// We test automatic diagonal preconditioning used by SolveSparse.
// In order to do so we:
// 1. generate 20*20 matrix A0 with condition number equal to 1.0E1
// 2. generate random "exact" solution xe and right part b=A0*xe
// 3. generate random ill-conditioned diagonal scaling matrix D with
//    condition number equal to 1.0E50:
// 4. transform A*x=b into badly scaled problem:
//    A0*x0=b0
//    A0*D*(inv(D)*x0)=b0
//    (D*A0*D)*(inv(D)*x0)=(D*b0)
//    finally we got new problem A*x=b with A=D*A0*D, b=D*b0, x=inv(D)*x0
//
// Then we solve A*x=b:
// 1. with default preconditioner
// 2. with explicitly activayed diagonal preconditioning
// 3. with unit preconditioner.
// 1st and 2nd solutions must be close to xe, 3rd solution must be very
// far from the true one.
   n = 20;
   spdmatrixrndcond(n, 1.0E1, &ta);
   ae_vector_set_length(&xe, n);
   for (i = 0; i < n; i++) {
      xe.xR[i] = randomnormal();
   }
   ae_vector_set_length(&b, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = 0.0;
      for (j = 0; j < n; j++) {
         b.xR[i] += ta.xyR[i][j] * xe.xR[j];
      }
   }
   ae_vector_set_length(&d, n);
   for (i = 0; i < n; i++) {
      d.xR[i] = pow(10.0, 50.0 * randommid());
   }
   ae_matrix_set_length(&a, n, n);
   sparsecreate(n, n, n * n, &sa);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a.xyR[i][j] = d.xR[i] * ta.xyR[i][j] * d.xR[j];
         sparseset(&sa, i, j, a.xyR[i][j]);
      }
      b.xR[i] *= d.xR[i];
      xe.xR[i] /= d.xR[i];
   }
   sparseconverttocrs(&sa);
   lincgcreate(n, &s);
   lincgsetcond(&s, 0.0, 2 * n);
   lincgsolvesparse(&s, &sa, true, &b);
   lincgresults(&s, &x0, &rep);
   if (rep.terminationtype <= 0) {
      result = true;
      ae_frame_leave();
      return result;
   }
   for (i = 0; i < n; i++) {
      if (fabs(xe.xR[i] - x0.xR[i]) > 5.0E-2 / d.xR[i]) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
   lincgsetprecunit(&s);
   lincgsolvesparse(&s, &sa, true, &b);
   lincgresults(&s, &x0, &rep);
   if (rep.terminationtype > 0) {
      bflag = false;
      for (i = 0; i < n; i++) {
         bflag = bflag || fabs(xe.xR[i] - x0.xR[i]) > 5.0E-2 / d.xR[i];
      }
      if (!bflag) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
   lincgsetprecdiag(&s);
   lincgsolvesparse(&s, &sa, true, &b);
   lincgresults(&s, &x0, &rep);
   if (rep.terminationtype <= 0) {
      result = true;
      ae_frame_leave();
      return result;
   }
   for (i = 0; i < n; i++) {
      if (fabs(xe.xR[i] - x0.xR[i]) > 5.0E-2 / d.xR[i]) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
// test has been passed
   if (!silent) {
      printf("PrecondTest::Ok\n");
   }
   result = false;
   ae_frame_leave();
   return result;
}

bool testlincg(bool silent) {
   bool basictestxerrors;
   bool basictestiterserr;
   bool complexreserrors;
   bool complexerrors;
   bool rcorrectness;
   bool krylovsubspaceerr;
   bool sparseerrors;
   bool preconderrors;
   bool waserrors;
   bool result;
   basictestxerrors = testlincgunit_basictestx(true);
   basictestiterserr = testlincgunit_basictestiters(true);
   complexreserrors = testlincgunit_complexres(true);
   complexerrors = testlincgunit_complextest(true);
   rcorrectness = testlincgunit_testrcorrectness(true);
   krylovsubspaceerr = testlincgunit_krylovsubspacetest(true);
   sparseerrors = testlincgunit_sparsetest(true);
   preconderrors = testlincgunit_precondtest(true);
// report
   waserrors = ((((((basictestxerrors || complexreserrors) || complexerrors) || rcorrectness) || basictestiterserr) || krylovsubspaceerr) || sparseerrors) || preconderrors;
   if (!silent) {
      printf("TESTING LinCG\n");
      printf("BasicTestX:                                   ");
      if (basictestxerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("BasicTestIters:                               ");
      if (basictestiterserr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("ComplexResTest:                               ");
      if (complexreserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("ComplexTest:                                  ");
      if (complexerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("R2 correctness:                               ");
      if (rcorrectness) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("KrylovSubSpaceTest:                           ");
      if (krylovsubspaceerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("SparseTest:                                   ");
      if (sparseerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("PrecondTest:                                  ");
      if (preconderrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
   // was errors?
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === normestimator testing unit ===
bool testnormestimator(bool silent) {
   ae_frame _frame_block;
   double tol;
   ae_int_t maxmn;
   ae_int_t m;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t passcount;
   double snorm;
   double enorm;
   double enorm2;
   ae_int_t nbetter;
   double sigma;
   ae_int_t i;
   ae_int_t j;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(rowsizes, 0, DT_INT);
   NewObj(sparsematrix, s);
   NewObj(normestimatorstate, e);
   NewObj(normestimatorstate, e2);
   tol = 0.01;
   maxmn = 5;
   waserrors = false;
// First test: algorithm must correctly determine matrix norm
   for (m = 1; m <= maxmn; m++) {
      for (n = 1; n <= maxmn; n++) {
      // Create estimator with quite large NStart and NIts.
      // It should guarantee that we converge to the correct solution.
         normestimatorcreate(m, n, 15, 15, &e);
      // Try with zero A first
         sparsecreate(m, n, 1, &s);
         sparseconverttocrs(&s);
         normestimatorestimatesparse(&e, &s);
         normestimatorresults(&e, &enorm);
         waserrors = waserrors || enorm != 0.0;
      // Choose random norm, try with non-zero matrix
      // with specified norm.
         snorm = exp(5.0 * randommid());
         sparsecreate(m, n, 1, &s);
         if (m >= n) {
         // Generate random orthogonal M*M matrix,
         // use N leading columns as columns of A
            rmatrixrndorthogonal(m, &a);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  sparseset(&s, i, j, snorm * a.xyR[i][j]);
               }
            }
         } else {
         // Generate random orthogonal N*N matrix,
         // use M leading rows as rows of A
            rmatrixrndorthogonal(n, &a);
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  sparseset(&s, i, j, snorm * a.xyR[i][j]);
               }
            }
         }
         sparseconverttocrs(&s);
         normestimatorestimatesparse(&e, &s);
         normestimatorresults(&e, &enorm);
         waserrors = (waserrors || enorm > snorm * (1 + tol)) || enorm < snorm * (1 - tol);
      }
   }
// NStart=10 should give statistically better results than NStart=1.
// In order to test it we perform PassCount attempts to solve random
// problem by means of two estimators: one with NStart=10 and another
// one with NStart=1. Every time we compare two estimates and choose
// better one.
//
// Random variable NBetter is a number of cases when NStart=10 was better.
// Under null hypothesis (no difference) it is binomially distributed
// with mean PassCount/2 and variance PassCount/4. However, we expect
// to have significant deviation to the right, in the area of larger
// values.
//
// NOTE: we use fixed N because this test is independent of problem size.
   n = 3;
   normestimatorcreate(n, n, 1, 1, &e);
   normestimatorcreate(n, n, 10, 1, &e2);
   normestimatorsetseed(&e, 0);
   normestimatorsetseed(&e2, 0);
   nbetter = 0;
   passcount = 2000;
   sigma = 5.0;
   for (pass = 1; pass <= passcount; pass++) {
      snorm = pow(10.0, randommid());
      sparsecreate(n, n, 1, &s);
      rmatrixrndcond(n, 2.0, &a);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            sparseset(&s, i, j, snorm * a.xyR[i][j]);
         }
      }
      sparseconverttocrs(&s);
      normestimatorestimatesparse(&e, &s);
      normestimatorresults(&e, &enorm);
      normestimatorestimatesparse(&e2, &s);
      normestimatorresults(&e2, &enorm2);
      if (fabs(enorm2 - snorm) < fabs(enorm - snorm)) {
         nbetter++;
      }
   }
   waserrors = waserrors || (double)nbetter < 0.5 * passcount + sigma * sqrt(0.25 * passcount);
// Same as previous one (for NStart), but tests dependence on NIts.
   n = 3;
   normestimatorcreate(n, n, 1, 1, &e);
   normestimatorcreate(n, n, 1, 10, &e2);
   normestimatorsetseed(&e, 0);
   normestimatorsetseed(&e2, 0);
   nbetter = 0;
   passcount = 2000;
   sigma = 5.0;
   for (pass = 1; pass <= passcount; pass++) {
      snorm = pow(10.0, randommid());
      sparsecreate(n, n, 1, &s);
      rmatrixrndcond(n, 2.0, &a);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            sparseset(&s, i, j, snorm * a.xyR[i][j]);
         }
      }
      sparseconverttocrs(&s);
      normestimatorestimatesparse(&e, &s);
      normestimatorresults(&e, &enorm);
      normestimatorestimatesparse(&e2, &s);
      normestimatorresults(&e2, &enorm2);
      if (fabs(enorm2 - snorm) < fabs(enorm - snorm)) {
         nbetter++;
      }
   }
   waserrors = waserrors || (double)nbetter < 0.5 * passcount + sigma * sqrt(0.25 * passcount);
// report
   if (!silent) {
      printf("TESTING NORM ESTIMATOR\n");
      printf("TEST:                                    ");
      if (!waserrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === linlsqr testing unit ===
static const double testlinlsqrunit_e0 = 1.0E-6;
static const double testlinlsqrunit_tolort = 1.0E-4;
static const double testlinlsqrunit_emergencye0 = 1.0E-12;

// This function compares solution calculated by LSQR with one calculated  by
// SVD solver. Following comparisons are performed:
// 1. either:
//    1.a) residual norm |Rk| for LSQR solution is at most epsErr*|B|
//    1.b) |A^T*Rk|/(|A|*|Rk|) <= EpsOrt
// 2. norm(LSQR_solution) is at most 1.2*norm(SVD_solution)
//
// Test (1) verifies that LSQR found good solution, test  (2)  verifies  that
// LSQR finds solution with close-to-minimum norm. We use factor as large  as
// 1.2 to test deviation from SVD solution because LSQR is not very  good  at
// solving degenerate problems.
//
// Inputs:
//     A       -   array[M,N], system matrix
//     B       -   right part
//     M, N    -   problem size
//     LambdaV -   regularization value for the problem, >= 0
//     X       -   array[N], solution found by LSQR
//     EpsErr  -   tolerance for |A*x-b|
//     EpsOrt  -   tolerance for |A^T*Rk|/(|A|*|Rk|)
//
// Result:
//     True, for solution which passess all the tests
static bool testlinlsqrunit_isitgoodsolution(RMatrix *a, RVector *b, ae_int_t m, ae_int_t n, double lambdav, RVector *x, double epserr, double epsort) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t minmn;
   bool svdresult;
   double v;
   double rnorm;
   double bnorm;
   double anorm;
   double atrnorm;
   double xnorm;
   double svdxnorm;
   bool clause1holds;
   bool clause2holds;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(svda, 0, 0, DT_REAL);
   NewMatrix(u, 0, 0, DT_REAL);
   NewMatrix(vt, 0, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(svdx, 0, DT_REAL);
   NewVector(tmparr, 0, DT_REAL);
   NewVector(r, 0, DT_REAL);
// Solve regularized problem with SVD solver
   ae_matrix_set_length(&svda, m + n, n);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         svda.xyR[i][j] = a->xyR[i][j];
      }
   }
   for (i = m; i < m + n; i++) {
      for (j = 0; j < n; j++) {
         if (i - m == j) {
            svda.xyR[i][j] = lambdav;
         } else {
            svda.xyR[i][j] = 0.0;
         }
      }
   }
   svdresult = rmatrixsvd(&svda, m + n, n, 1, 1, 0, &w, &u, &vt);
   ae_assert(svdresult, "LINLSQR: internal error in unit test (SVD failed)");
   minmn = imin2(m, n);
   ae_vector_set_length(&svdx, n);
   ae_vector_set_length(&tmparr, minmn);
   for (i = 0; i < minmn; i++) {
      tmparr.xR[i] = 0.0;
      for (j = 0; j < m; j++) {
         tmparr.xR[i] += u.xyR[j][i] * b->xR[j];
      }
      if (w.xR[i] <= sqrt(machineepsilon) * w.xR[0]) {
         tmparr.xR[i] = 0.0;
      } else {
         tmparr.xR[i] /= w.xR[i];
      }
   }
   for (i = 0; i < n; i++) {
      svdx.xR[i] = 0.0;
      for (j = 0; j < minmn; j++) {
         svdx.xR[i] += vt.xyR[j][i] * tmparr.xR[j];
      }
   }
// Calculate residual, perform checks 1.a and 1.b:
// * first, we check 1.a
// * in case 1.a fails we check 1.b
   ae_vector_set_length(&r, m + n);
   for (i = 0; i < m + n; i++) {
      v = ae_v_dotproduct(svda.xyR[i], 1, x->xR, 1, n);
      r.xR[i] = v;
      if (i < m) {
         r.xR[i] -= b->xR[i];
      }
   }
   v = ae_v_dotproduct(r.xR, 1, r.xR, 1, m + n);
   rnorm = sqrt(v);
   v = ae_v_dotproduct(b->xR, 1, b->xR, 1, m);
   bnorm = sqrt(v);
   if (rnorm <= epserr * bnorm) {
   // 1.a is true, no further checks is needed
      clause1holds = true;
   } else {
   // 1.a is false, we have to check 1.b
   //
   // In order to do so, we calculate ||A|| and ||A^T*Rk||. We do
   // not store product of A and Rk to some array, all we need is
   // just one component of product at time, stored in V.
   //
      anorm = 0.0;
      atrnorm = 0.0;
      for (i = 0; i < n; i++) {
         v = 0.0;
         for (j = 0; j < m + n; j++) {
            v += svda.xyR[j][i] * r.xR[j];
            anorm += sqr(svda.xyR[j][i]);
         }
         atrnorm += sqr(v);
      }
      anorm = sqrt(anorm);
      atrnorm = sqrt(atrnorm);
      clause1holds = anorm * rnorm == 0.0 || atrnorm / (anorm * rnorm) <= epsort;
   }
// Check (2).
// Here we assume that Result=True when we enter this block.
   v = ae_v_dotproduct(x->xR, 1, x->xR, 1, n);
   xnorm = sqrt(v);
   v = ae_v_dotproduct(svdx.xR, 1, svdx.xR, 1, n);
   svdxnorm = sqrt(v);
   clause2holds = xnorm <= 1.2 * svdxnorm;
// End
   result = clause1holds && clause2holds;
   ae_frame_leave();
   return result;
}

// This  function  generates  random  MxN  problem,  solves  it with LSQR and
// compares with results obtained from SVD solver. Matrix A is  generated  as
// MxN  matrix  with  uniformly  distributed  random  entries, i.e. it has no
// special properties (like conditioning or separation of singular values).
//
// We apply random amount regularization to our problem (from zero to  large)
// in  order  to  test  regularizer.  Default  stopping  criteria  are  used.
// Preconditioning is turned off because it skews results for  rank-deficient
// problems.
//
// INPUT:
//     Silent   -   if true then function output report
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_svdtest(bool silent) {
   ae_frame _frame_block;
   ae_int_t szn;
   ae_int_t szm;
   ae_int_t n;
   ae_int_t m;
   double lambdai;
   ae_int_t i;
   ae_int_t j;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewObj(sparsematrix, spa);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   szm = 5;
   szn = 5;
   for (m = 1; m <= szm; m++) {
      for (n = 1; n <= szn; n++) {
      // Prepare MxN matrix A, right part B, lambda
         lambdai = randomreal();
         ae_matrix_set_length(&a, m, n);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = randommid();
            }
         }
         sparsecreate(m, n, 1, &spa);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               sparseset(&spa, i, j, a.xyR[i][j]);
            }
         }
         sparseconverttocrs(&spa);
         ae_vector_set_length(&b, m);
         for (i = 0; i < m; i++) {
            b.xR[i] = randommid();
         }
      // Solve by calling LinLSQRIteration
         linlsqrcreate(m, n, &s);
         linlsqrsetb(&s, &b);
         linlsqrsetlambdai(&s, lambdai);
         linlsqrsetprecunit(&s);
         while (linlsqriteration(&s)) {
            if (s.needmv) {
               for (i = 0; i < m; i++) {
                  s.mv.xR[i] = 0.0;
                  for (j = 0; j < n; j++) {
                     s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                  }
               }
            }
            if (s.needmtv) {
               for (i = 0; i < n; i++) {
                  s.mtv.xR[i] = 0.0;
                  for (j = 0; j < m; j++) {
                     s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                  }
               }
            }
         }
         linlsqrresults(&s, &x0, &rep);
         if (!testlinlsqrunit_isitgoodsolution(&a, &b, m, n, lambdai, &x0, testlinlsqrunit_e0, testlinlsqrunit_tolort)) {
            result = true;
            ae_frame_leave();
            return result;
         }
      // test LinLSQRRestart and LinLSQRSolveSparse
         linlsqrrestart(&s);
         linlsqrsolvesparse(&s, &spa, &b);
         linlsqrresults(&s, &x0, &rep);
         if (!testlinlsqrunit_isitgoodsolution(&a, &b, m, n, lambdai, &x0, testlinlsqrunit_e0, testlinlsqrunit_tolort)) {
            result = true;
            ae_frame_leave();
            return result;
         }
      }
   }
   if (!silent) {
      printf("SVDTest::Ok\n");
   }
   result = false;
   ae_frame_leave();
   return result;
}

// The test checks that algorithm can solve MxN (with N <= M)  well-conditioned
// problems - and can do so within exactly  N  iterations.  We  use  moderate
// condition numbers, from 1.0 to 10.0, because larger condition  number  may
// require several additional iterations to converge.
//
// We try different scalings of the A and B.
//
// INPUT:
//     Silent   -   if true then function does not outputs results to console
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_mwcranksvdtest(bool silent) {
   ae_frame _frame_block;
   double bnorm;
   ae_int_t szm;
   ae_int_t n;
   ae_int_t m;
   ae_int_t ns0;
   ae_int_t ns1;
   ae_int_t nlambdai;
   double s0;
   double s1;
   double lambdai;
   double c;
   ae_int_t i;
   ae_int_t j;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   szm = 5;
   for (m = 1; m <= szm; m++) {
      for (n = 1; n <= m; n++) {
         for (nlambdai = 0; nlambdai <= 3; nlambdai++) {
            for (ns0 = -1; ns0 <= 1; ns0++) {
               for (ns1 = -1; ns1 <= 1; ns1++) {
               // Generate problem:
               // * scale factors s0, s1
               // * MxN well conditioned A (with condition number C in [1,10] and norm s0)
               // * regularization coefficient LambdaI
               // * right part b, with |b|=s1
                  s0 = pow(10.0, (double)(10 * ns0));
                  s1 = pow(10.0, (double)(10 * ns1));
                  lambdai = 0.0;
                  if (nlambdai == 0) {
                     lambdai = 0.0;
                  }
                  if (nlambdai == 1) {
                     lambdai = s0 / 1000;
                  }
                  if (nlambdai == 2) {
                     lambdai = s0;
                  }
                  if (nlambdai == 3) {
                     lambdai = s0 * 1000;
                  }
                  c = (10 - 1) * randomreal() + 1;
                  rmatrixrndcond(m, c, &a);
                  for (i = 0; i < m; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] *= s0;
                     }
                  }
                  ae_vector_set_length(&b, m);
                  do {
                     bnorm = 0.0;
                     for (i = 0; i < m; i++) {
                        b.xR[i] = randommid();
                        bnorm += b.xR[i] * b.xR[i];
                     }
                     bnorm = sqrt(bnorm);
                  } while (bnorm <= testlinlsqrunit_e0);
                  for (i = 0; i < m; i++) {
                     b.xR[i] = b.xR[i] * s1 / bnorm;
                  }
               // Solve by LSQR method
                  linlsqrcreate(m, n, &s);
                  linlsqrsetb(&s, &b);
                  linlsqrsetcond(&s, 0.0, 0.0, n);
                  linlsqrsetlambdai(&s, lambdai);
                  while (linlsqriteration(&s)) {
                     if (s.needmv) {
                        for (i = 0; i < m; i++) {
                           s.mv.xR[i] = 0.0;
                           for (j = 0; j < n; j++) {
                              s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                           }
                        }
                     }
                     if (s.needmtv) {
                        for (i = 0; i < n; i++) {
                           s.mtv.xR[i] = 0.0;
                           for (j = 0; j < m; j++) {
                              s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                           }
                        }
                     }
                  }
                  linlsqrresults(&s, &x0, &rep);
                  if (!testlinlsqrunit_isitgoodsolution(&a, &b, m, n, lambdai, &x0, testlinlsqrunit_e0, testlinlsqrunit_tolort)) {
                     result = true;
                     ae_frame_leave();
                     return result;
                  }
               }
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// The test checks that algorithm can find a solution with minimum norm for a
// singular rectangular problem. System matrix has special property - singular
// values are either zero or well separated from zero.
//
// INPUT:
//     Silent   -   if true then function output report
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_mwicranksvdtest(bool silent) {
   ae_frame _frame_block;
   double bnorm;
   ae_int_t szm;
   ae_int_t n;
   ae_int_t m;
   ae_int_t nz;
   ae_int_t ns0;
   ae_int_t ns1;
   ae_int_t nlambdai;
   double s0;
   double s1;
   double lambdai;
   ae_int_t i;
   ae_int_t j;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewObj(sparsematrix, spa);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   result = false;
   szm = 5;
   for (m = 1; m <= szm; m++) {
      for (n = 1; n <= m; n++) {
         for (nlambdai = 0; nlambdai <= 2; nlambdai++) {
            for (ns0 = -1; ns0 <= 1; ns0++) {
               for (ns1 = -1; ns1 <= 1; ns1++) {
                  for (nz = 0; nz < n; nz++) {
                  // Generate problem:
                  // * scale coefficients s0, s1
                  // * regularization coefficient LambdaI
                  // * MxN matrix A, norm(A)=s0, with NZ zero singular values and N-NZ nonzero ones
                  // * right part b with norm(b)=s1
                     s0 = pow(10.0, (double)(10 * ns0));
                     s1 = pow(10.0, (double)(10 * ns1));
                     lambdai = 0.0;
                     if (nlambdai == 0) {
                        lambdai = 0.0;
                     }
                     if (nlambdai == 1) {
                        lambdai = s0;
                     }
                     if (nlambdai == 2) {
                        lambdai = s0 * 1000;
                     }
                     ae_matrix_set_length(&a, m, n);
                     for (i = 0; i < m; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] = 0.0;
                        }
                     }
                     for (i = 0; i < n - nz; i++) {
                        a.xyR[i][i] = s0 * (0.1 + 0.9 * randomreal());
                     }
                     rmatrixrndorthogonalfromtheleft(&a, m, n);
                     rmatrixrndorthogonalfromtheright(&a, m, n);
                     ae_vector_set_length(&b, m);
                     do {
                        bnorm = 0.0;
                        for (i = 0; i < m; i++) {
                           b.xR[i] = randommid();
                           bnorm += b.xR[i] * b.xR[i];
                        }
                        bnorm = sqrt(bnorm);
                     } while (bnorm <= testlinlsqrunit_e0);
                     for (i = 0; i < m; i++) {
                        b.xR[i] = b.xR[i] * s1 / bnorm;
                     }
                  // Solve by LSQR method
                     linlsqrcreate(m, n, &s);
                     linlsqrsetb(&s, &b);
                     linlsqrsetcond(&s, testlinlsqrunit_emergencye0, testlinlsqrunit_emergencye0, n);
                     linlsqrsetlambdai(&s, lambdai);
                     while (linlsqriteration(&s)) {
                        if (s.needmv) {
                           for (i = 0; i < m; i++) {
                              s.mv.xR[i] = 0.0;
                              for (j = 0; j < n; j++) {
                                 s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                              }
                           }
                        }
                        if (s.needmtv) {
                           for (i = 0; i < n; i++) {
                              s.mtv.xR[i] = 0.0;
                              for (j = 0; j < m; j++) {
                                 s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                              }
                           }
                        }
                     }
                     linlsqrresults(&s, &x0, &rep);
                  // Check
                     if (!testlinlsqrunit_isitgoodsolution(&a, &b, m, n, lambdai, &x0, testlinlsqrunit_e0, testlinlsqrunit_tolort)) {
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  }
               }
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// The test does check, that algorithm can find a solution with minimum norm,
// if a problem has bidiagonal matrix on diagonals of a lot of zeros. This
// problem has to lead to case when State.Alpha and State.Beta are zero, and we
// we can be sure that the algorithm correctly handles it.
//
// We do not use iteration count as stopping condition, because problem can
// be degenerate and we may need more than N iterations to converge.
//
// INPUT:
//     Silent   -   if true then function output report
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_bidiagonaltest(bool silent) {
   ae_frame _frame_block;
   double bnorm;
   ae_int_t sz;
   ae_int_t n;
   ae_int_t m;
   ae_int_t minmn;
   ae_int_t ns0;
   ae_int_t ns1;
   double s0;
   double s1;
   ae_int_t i;
   ae_int_t j;
   ae_int_t p;
   ae_int_t diag;
   double pnz;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   sz = 5;
   for (m = 1; m <= sz; m++) {
      for (n = 1; n <= sz; n++) {
         minmn = imin2(m, n);
         for (p = 0; p <= 2; p++) {
            for (ns0 = -1; ns0 <= 1; ns0++) {
               for (ns1 = -1; ns1 <= 1; ns1++) {
                  for (diag = 0; diag <= 1; diag++) {
                  // Generate problem:
                  // * scaling coefficients s0, s1
                  // * bidiagonal A, with probability of having zero element at diagonal equal to PZ
                     s0 = pow(10.0, (double)(10 * ns0));
                     s1 = pow(10.0, (double)(10 * ns1));
                     pnz = 1.0;
                     if (p == 0) {
                        pnz = 0.75;
                     }
                     if (p == 1) {
                        pnz = 0.5;
                     }
                     if (p == 2) {
                        pnz = 0.25;
                     }
                     ae_matrix_set_length(&a, m, n);
                     for (i = 0; i < m; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] = 0.0;
                        }
                     }
                     for (i = 0; i < minmn; i++) {
                        if (randombool(pnz)) {
                           a.xyR[i][i] = randommid();
                        }
                     }
                     for (i = 1; i < minmn; i++) {
                        if (randombool(pnz)) {
                           if (diag == 0) {
                              a.xyR[i - 1][i] = randommid();
                           }
                           if (diag == 1) {
                              a.xyR[i][i - 1] = randommid();
                           }
                        }
                     }
                     for (i = 0; i < m; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] *= s0;
                        }
                     }
                     ae_vector_set_length(&b, m);
                     do {
                        bnorm = 0.0;
                        for (i = 0; i < m; i++) {
                           b.xR[i] = randommid();
                           bnorm += b.xR[i] * b.xR[i];
                        }
                        bnorm = sqrt(bnorm);
                     } while (bnorm <= testlinlsqrunit_e0);
                     for (i = 0; i < m; i++) {
                        b.xR[i] = b.xR[i] * s1 / bnorm;
                     }
                  // LSQR solution
                     linlsqrcreate(m, n, &s);
                     linlsqrsetb(&s, &b);
                     linlsqrsetcond(&s, testlinlsqrunit_e0, testlinlsqrunit_e0, 0);
                     while (linlsqriteration(&s)) {
                        if (s.needmv) {
                           for (i = 0; i < m; i++) {
                              s.mv.xR[i] = 0.0;
                              for (j = 0; j < n; j++) {
                                 s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                              }
                           }
                        }
                        if (s.needmtv) {
                           for (i = 0; i < n; i++) {
                              s.mtv.xR[i] = 0.0;
                              for (j = 0; j < m; j++) {
                                 s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                              }
                           }
                        }
                     }
                     linlsqrresults(&s, &x0, &rep);
                  // Check
                     if (!testlinlsqrunit_isitgoodsolution(&a, &b, m, n, 0.0, &x0, testlinlsqrunit_e0, testlinlsqrunit_tolort)) {
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  }
               }
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// The test does check, that algorithm correctly solves a problem in cases:
//     1. A=0, B != 0;
//     2. A != 0, B=0;
//     3. A=0, B=0.
// If some part is not zero then it filled with ones.
//
// INPUT:
//     Silent   -   if true then function output report
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_zeromatrixtest(bool silent) {
   ae_frame _frame_block;
   ae_int_t sz;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t nzeropart;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   sz = 5;
   result = false;
   for (m = 1; m <= sz; m++) {
      for (n = 1; n <= sz; n++) {
         for (nzeropart = 0; nzeropart <= 2; nzeropart++) {
         // Initialize A, b
            ae_matrix_set_length(&a, m, n);
            if (nzeropart == 0 || nzeropart == 2) {
               for (i = 0; i < m; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
            } else {
               for (i = 0; i < m; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 1.0;
                  }
               }
            }
            ae_vector_set_length(&b, m);
            if (nzeropart == 1 || nzeropart == 2) {
               for (i = 0; i < m; i++) {
                  b.xR[i] = 0.0;
               }
            } else {
               for (i = 0; i < m; i++) {
                  b.xR[i] = 1.0;
               }
            }
         // LSQR
            linlsqrcreate(m, n, &s);
            linlsqrsetb(&s, &b);
            linlsqrsetcond(&s, 0.0, 0.0, n);
            while (linlsqriteration(&s)) {
               if (s.needmv) {
                  for (i = 0; i < m; i++) {
                     s.mv.xR[i] = 0.0;
                     for (j = 0; j < n; j++) {
                        s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                     }
                  }
               }
               if (s.needmtv) {
                  for (i = 0; i < n; i++) {
                     s.mtv.xR[i] = 0.0;
                     for (j = 0; j < m; j++) {
                        s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                     }
                  }
               }
            }
            linlsqrresults(&s, &x0, &rep);
         // Check
            if (!testlinlsqrunit_isitgoodsolution(&a, &b, m, n, 0.0, &x0, testlinlsqrunit_e0, testlinlsqrunit_tolort)) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// The test does check, that algorithm correctly displays a progress report.
//
// INPUT:
//     Silent   -   if true then function output report
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_reportcorrectnesstest(bool silent) {
   ae_frame _frame_block;
   double rnorm;
   double tnorm;
   ae_int_t sz;
   ae_int_t n;
   ae_int_t m;
   ae_int_t lambdai;
   double mn;
   double mx;
   double c;
   ae_int_t i;
   ae_int_t j;
   ae_int_t its;
   double tmp;
   double eps;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(u, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(firstx, 0, DT_REAL);
   NewVector(lastx, 0, DT_REAL);
   eps = 0.001;
   sz = 5;
   mn = -100.0;
   mx = 100.0;
   c = 100.0;
   result = false;
   for (m = 1; m <= sz; m++) {
      for (n = 1; n <= m; n++) {
         for (lambdai = 0; lambdai <= 1; lambdai++) {
            its = -1;
         // initialize matrix A
            spdmatrixrndcond(m + n, c, &a);
            for (i = m; i < m + n; i++) {
               for (j = 0; j < n; j++) {
                  if (i - m == j) {
                     a.xyR[i][j] = (double)lambdai;
                  } else {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
         // initialize b
            ae_vector_set_length(&b, m + n);
            rnorm = 0.0;
            for (i = 0; i < m + n; i++) {
               if (i < m) {
                  b.xR[i] = (mx - mn) * randomreal() + mn;
                  rnorm += b.xR[i] * b.xR[i];
               } else {
                  b.xR[i] = 0.0;
               }
            }
         // initialize FirstX and LastX
            ae_vector_set_length(&firstx, n);
            ae_vector_set_length(&lastx, n);
         // calculating by LSQR method
            linlsqrcreate(m, n, &s);
            linlsqrsetb(&s, &b);
            linlsqrsetcond(&s, 0.0, 0.0, n);
            linlsqrsetlambdai(&s, (double)lambdai);
            linlsqrsetxrep(&s, true);
            set_error_flag(&result, linlsqrpeekiterationscount(&s) != 0, __FILE__, __LINE__, "testlinlsqrunit.ap:811");
            while (linlsqriteration(&s)) {
               if (s.needmv) {
                  for (i = 0; i < m; i++) {
                     s.mv.xR[i] = 0.0;
                     for (j = 0; j < n; j++) {
                        s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                     }
                  }
               }
               if (s.needmtv) {
                  for (i = 0; i < n; i++) {
                     s.mtv.xR[i] = 0.0;
                     for (j = 0; j < m; j++) {
                        s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                     }
                  }
               }
               if (s.xupdated) {
                  tnorm = 0.0;
                  for (i = 0; i < m + n; i++) {
                     tmp = 0.0;
                     for (j = 0; j < n; j++) {
                        tmp += a.xyR[i][j] * s.x.xR[j];
                     }
                     tnorm += (b.xR[i] - tmp) * (b.xR[i] - tmp);
                  }
               // check, that RNorm is't more than S.R2
               // and difference between S.R2 and TNorm
               // is't more than 'eps'(here S.R2=||rk||,
               // calculated by the algorithm for LSQR, and
               // TNorm=||A*S.x-b||, calculated by test function).
                  if (s.r2 > rnorm + 1000 * machineepsilon * rmax2(rnorm, 1.0)) {
                     set_error_flag(&result, true, __FILE__, __LINE__, "testlinlsqrunit.ap:853");
                     ae_frame_leave();
                     return result;
                  }
                  if (fabs(s.r2 - tnorm) > eps) {
                     set_error_flag(&result, true, __FILE__, __LINE__, "testlinlsqrunit.ap:858");
                     ae_frame_leave();
                     return result;
                  }
                  rnorm = s.r2;
                  its++;
               // get X value from first iteration
               // and from last iteration.
                  if (its == 0) {
                     for (i = 0; i < n; i++) {
                        firstx.xR[i] = s.x.xR[i];
                     }
                  }
                  if (its == n) {
                     for (i = 0; i < n; i++) {
                        lastx.xR[i] = s.x.xR[i];
                     }
                  }
               // check iterations counter
                  set_error_flag(&result, linlsqrpeekiterationscount(&s) != its, __FILE__, __LINE__, "testlinlsqrunit.ap:878");
               }
            }
            linlsqrresults(&s, &x0, &rep);
            set_error_flag(&result, linlsqrpeekiterationscount(&s) != n, __FILE__, __LINE__, "testlinlsqrunit.ap:882");
         // check, that FirstX is equal to zero and LastX
         // is equal to x0.
            for (i = 0; i < n; i++) {
               if (firstx.xR[i] != 0.0 || lastx.xR[i] != x0.xR[i]) {
                  if (!silent) {
                     printf("ReportCorrectnessTest::Fail\n");
                     printf("IterationsCount=%0d\n", (int)rep.iterationscount);
                     printf("NMV=%0d\n", (int)rep.nmv);
                     printf("TerminationType=%0d\n", (int)rep.terminationtype);
                     printf("X and LastX...\n");
                     for (j = 0; j < n; j++) {
                        printf("x[%0d]=%0.10e; LastX[%0d]=%0.10e\n", (int)j, x0.xR[j], (int)j, lastx.xR[j]);
                     }
                  }
                  set_error_flag(&result, true, __FILE__, __LINE__, "testlinlsqrunit.ap:902");
                  ae_frame_leave();
                  return result;
               }
            }
         }
      }
   }
   if (!silent) {
      printf("ReportCorrectnessTest::Ok\n");
   }
   ae_frame_leave();
   return result;
}

// The test does check, that correctly executed stop criteria by algorithm.
//
// INPUT:
//     Silent   -   if true then function output report
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_stoppingcriteriatest(bool silent) {
   ae_frame _frame_block;
   double bnorm;
   ae_int_t sz;
   ae_int_t n;
   ae_int_t k0;
   ae_int_t k1;
   double anorm;
   double arknorm;
   double rknorm;
   double mn;
   double mx;
   double c;
   ae_int_t maxits;
   ae_int_t i;
   ae_int_t j;
   double tmp;
   double eps;
   double epsmod;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(u, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(ark, 0, DT_REAL);
   NewVector(rk, 0, DT_REAL);
   sz = 5;
   mn = -100.0;
   mx = 100.0;
   c = 100.0;
   for (n = 1; n <= sz; n++) {
   // Initialize A, unit b
      spdmatrixrndcond(n, c, &a);
      ae_vector_set_length(&b, n);
      bnorm = 0.0;
      for (i = 0; i < n; i++) {
         b.xR[i] = (mx - mn) * randomreal() + mn;
         bnorm += b.xR[i] * b.xR[i];
      }
      bnorm = sqrt(bnorm);
   // Test MaxIts
   //
   // NOTE: we do not check TerminationType because algorithm may terminate for
   // several reasons. The only thing which is guaranteed is that stopping condition
   // MaxIts holds.
      maxits = 1 + randominteger(n);
      linlsqrcreate(n, n, &s);
      linlsqrsetb(&s, &b);
      linlsqrsetcond(&s, 0.0, 0.0, maxits);
      while (linlsqriteration(&s)) {
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
         }
         if (s.needmtv) {
            for (i = 0; i < n; i++) {
               s.mtv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
               }
            }
         }
      }
      linlsqrresults(&s, &x0, &rep);
      if (rep.iterationscount > maxits || rep.terminationtype <= 0) {
         if (!silent) {
            printf("StoppingCriteriaTest::Fail\n");
            printf("N=%0d\n", (int)n);
            printf("IterationsCount=%0d\n", (int)rep.iterationscount);
            printf("NMV=%0d\n", (int)rep.nmv);
            printf("TerminationType=%0d\n", (int)rep.terminationtype);
         }
         result = true;
         ae_frame_leave();
         return result;
      }
   // Test EpsB.
   // Set EpsB=eps, check that |r|<epsMod*|b|, where epsMod=1.1*eps.
   // This modified epsilon is used to avoid influence of the numerical errors.
   //
   // NOTE: we do not check TerminationType because algorithm may terminate for
   // several reasons. The only thing which is guaranteed is that stopping condition
   // EpsB holds.
      eps = pow(10.0, (double)-(2 + randominteger(3)));
      epsmod = 1.1 * eps;
      ae_vector_set_length(&rk, n);
      linlsqrcreate(n, n, &s);
      linlsqrsetb(&s, &b);
      linlsqrsetcond(&s, 0.0, eps, 0);
      while (linlsqriteration(&s)) {
         if (s.needmv) {
            for (i = 0; i < n; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
         }
         if (s.needmtv) {
            for (i = 0; i < n; i++) {
               s.mtv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
               }
            }
         }
      }
      linlsqrresults(&s, &x0, &rep);
      rknorm = 0.0;
      for (i = 0; i < n; i++) {
         tmp = 0.0;
         for (j = 0; j < n; j++) {
            tmp += a.xyR[i][j] * x0.xR[j];
         }
         rknorm += (tmp - b.xR[i]) * (tmp - b.xR[i]);
      }
      rknorm = sqrt(rknorm);
      if (rknorm > epsmod * bnorm || rep.terminationtype <= 0) {
         if (!silent) {
            printf("StoppingCriteriaTest::Fail\n");
            printf("rkNorm=%0.2e\n", rknorm);
            printf("IterationsCount=%0d\n", (int)rep.iterationscount);
            printf("NMV=%0d\n", (int)rep.nmv);
            printf("TerminationType=%0d\n", (int)rep.terminationtype);
         }
         result = true;
         ae_frame_leave();
         return result;
      }
   }
// Test EpsA.
//
// Generate well conditioned underdetermined system with nonzero residual
// at the solution. Such system can be generated by generating random
// orthogonal matrix (N >= 2) and using first N-1 columns as rectangular
// system matrix, and sum of all columns with random non-zero coefficients
// as right part.
   for (n = 2; n <= sz; n++) {
      for (k0 = -1; k0 <= 1; k0++) {
         for (k1 = -1; k1 <= 1; k1++) {
         // Initialize A with non-unit norm 10^(10*K0), b with non-unit norm 10^(10*K1)
            anorm = pow(10.0, (double)(10 * k0));
            rmatrixrndorthogonal(n, &a);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] *= anorm;
               }
            }
            ae_vector_set_length(&b, n);
            for (j = 0; j < n; j++) {
               b.xR[j] = 0.0;
            }
            for (i = 0; i < n; i++) {
               tmp = 1 + randomreal();
               ae_v_addd(b.xR, 1, &a.xyR[0][i], a.stride, n, tmp);
            }
            tmp = 0.0;
            for (i = 0; i < n; i++) {
               tmp += sqr(b.xR[i]);
            }
            tmp = pow(10.0, (double)(10 * k1)) / sqrt(tmp);
            ae_v_muld(b.xR, 1, n, tmp);
         // Test EpsA
         //
         // NOTE: it is guaranteed that algorithm will terminate with correct
         // TerminationType because other stopping criteria (EpsB) won't be satisfied
         // on such system.
            eps = pow(10.0, (double)-(2 + randominteger(3)));
            epsmod = 1.1 * eps;
            linlsqrcreate(n, n - 1, &s);
            linlsqrsetb(&s, &b);
            linlsqrsetcond(&s, eps, 0.0, 0);
            while (linlsqriteration(&s)) {
               if (s.needmv) {
                  for (i = 0; i < n; i++) {
                     s.mv.xR[i] = 0.0;
                     for (j = 0; j < n - 1; j++) {
                        s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                     }
                  }
               }
               if (s.needmtv) {
                  for (i = 0; i < n - 1; i++) {
                     s.mtv.xR[i] = 0.0;
                     for (j = 0; j < n; j++) {
                        s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                     }
                  }
               }
            }
            linlsqrresults(&s, &x0, &rep);
         // Check condition
            ae_vector_set_length(&rk, n);
            ae_vector_set_length(&ark, n - 1);
            rknorm = 0.0;
            for (i = 0; i < n; i++) {
               rk.xR[i] = b.xR[i];
               for (j = 0; j < n - 1; j++) {
                  rk.xR[i] -= a.xyR[i][j] * x0.xR[j];
               }
               rknorm += sqr(rk.xR[i]);
            }
            rknorm = sqrt(rknorm);
            arknorm = 0.0;
            for (i = 0; i < n - 1; i++) {
               ark.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  ark.xR[i] += a.xyR[j][i] * rk.xR[j];
               }
               arknorm += sqr(ark.xR[i]);
            }
            arknorm = sqrt(arknorm);
            if (arknorm / (anorm * rknorm) > epsmod || rep.terminationtype != 4) {
               if (!silent) {
                  printf("StoppingCriteriaTest::Fail\n");
                  printf("N=%0d\n", (int)n);
                  printf("IterationsCount=%0d\n", (int)rep.iterationscount);
                  printf("NMV=%0d\n", (int)rep.nmv);
                  printf("TerminationType=%0d\n", (int)rep.terminationtype);
               }
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
   if (!silent) {
      printf("StoppingCriteriaTest::Ok\n");
   }
   result = false;
   ae_frame_leave();
   return result;
}

// This test compares LSQR  for  original  system  A*x=b  against  CG  for  a
// modified system (A'*A)x = A*b. Both algorithms should give same  sequences
// of trial points (under exact arithmetics, or  for  very  good  conditioned
// systems).
//
// INPUT:
//     Silent   -   if true then function does not output report
// ALGLIB: Copyright 30.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_analytictest(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t smallk;
   ae_int_t pointsstored;
   double v;
   double tol;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(xk, 0, 0, DT_REAL);
   NewMatrix(ap, 0, 0, DT_REAL);
   NewMatrix(r, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
// Set:
// * SmallK - number of steps to check, must be small number in order
//   to reduce influence of the rounding errors
// * Tol - error tolerance for orthogonality/conjugacy criteria
   result = false;
   smallk = 4;
   tol = 1.0E-7;
   for (m = smallk; m <= smallk + 5; m++) {
      for (n = smallk; n <= m; n++) {
      // Prepare problem:
      // * MxN matrix A, Mx1 vector B
      // * A is filled with random values from [-1,+1]
      // * diagonal elements are filled with large positive values
      //   (should make system better conditioned)
         ae_matrix_set_length(&a, m, n);
         ae_vector_set_length(&b, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = randommid();
            }
            b.xR[i] = randommid();
         }
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 10 * (1 + randomreal());
         }
      // Solve with LSQR, save trial points into XK[] array
         ae_matrix_set_length(&xk, smallk + 1, n);
         linlsqrcreate(m, n, &s);
         linlsqrsetb(&s, &b);
         linlsqrsetcond(&s, 0.0, 0.0, smallk);
         linlsqrsetxrep(&s, true);
         pointsstored = 0;
         while (linlsqriteration(&s)) {
            if (s.needmv) {
               for (i = 0; i < m; i++) {
                  s.mv.xR[i] = 0.0;
                  for (j = 0; j < n; j++) {
                     s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
                  }
               }
            }
            if (s.needmtv) {
               for (i = 0; i < n; i++) {
                  s.mtv.xR[i] = 0.0;
                  for (j = 0; j < m; j++) {
                     s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
                  }
               }
            }
            if (s.xupdated) {
               ae_assert(pointsstored < xk.rows, "LinLSQR test: internal error");
               ae_v_move(xk.xyR[pointsstored], 1, s.x.xR, 1, n);
               pointsstored++;
            }
         }
         if (pointsstored < 3) {
         // At least two iterations should be performed
         // (our task is not that easy to solve)
            result = true;
            ae_frame_leave();
            return result;
         }
      // We have recorded sequence of points generated by LSQR,
      // and now we want to make a comparion against linear CG.
      //
      // Of course, we could just perform CG solution of (A'*A)*x = A'*b,
      // but it will need a CG solver, and we do not want to reference one
      // just to perform testing.
      //
      // However, we can do better - we can check that sequence of steps
      // satisfies orthogonality/conjugacy conditions, which are stated
      // as follows:
      // * (r[i]^T)*r[j]=0 for i != j
      // * (p[i]^T)*A'*A*p[j]=0 for i != j
      // where r[i]=(A'*A)*x[i]-A'*b is I-th residual , p[i] is I-th step.
      //
      // In order to test these criteria we generate two matrices:
      // * (PointsStored-1)*M matrix AP (matrix of A*p products)
      // * (PointsStored-1)*N matrix R  (matrix of residuals)
      // Then, we check that each matrix has orthogonal rows.
         ae_matrix_set_length(&ap, pointsstored - 1, m);
         ae_matrix_set_length(&r, pointsstored - 1, n);
         ae_vector_set_length(&tmp, m);
         for (k = 0; k < pointsstored - 1; k++) {
         // Calculate K-th row of AP
            for (i = 0; i < m; i++) {
               ap.xyR[k][i] = 0.0;
               for (j = 0; j < n; j++) {
                  ap.xyR[k][i] += a.xyR[i][j] * (xk.xyR[k + 1][j] - xk.xyR[k][j]);
               }
            }
         // Calculate K-th row of R
            for (i = 0; i < m; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xk.xyR[k], 1, n);
               tmp.xR[i] = v - b.xR[i];
            }
            for (j = 0; j < n; j++) {
               v = ae_v_dotproduct(&a.xyR[0][j], a.stride, tmp.xR, 1, m);
               r.xyR[k][j] = v;
            }
         }
         for (i = 0; i < pointsstored - 1; i++) {
            for (j = 0; j < pointsstored - 1; j++) {
               if (i != j) {
                  v = ae_v_dotproduct(ap.xyR[i], 1, ap.xyR[j], 1, m);
                  result = result || fabs(v) > tol;
                  v = ae_v_dotproduct(r.xyR[i], 1, r.xyR[j], 1, n);
                  result = result || fabs(v) > tol;
               }
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// This test checks behavior of the termination requests. Sets error flag  on
// failure, leaves it unchanged on success.
// ALGLIB: Copyright 16.11.2018 by Sergey Bochkanov
static void testlinlsqrunit_testterminationrequests(bool *err) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t m;
   ae_int_t callsleft;
   ae_int_t reportsafterrequest;
   bool firstpointreported;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewObj(hqrndstate, rs);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   hqrndrandomize(&rs);
   for (pass = 1; pass <= 50; pass++) {
   // Prepare problem
      callsleft = 1 + hqrnduniformi(&rs, 10);
      n = callsleft + 100 + hqrnduniformi(&rs, 50);
      m = n + hqrnduniformi(&rs, 50);
      ae_matrix_set_length(&a, m, n);
      ae_vector_set_length(&b, m);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
         b.xR[i] = hqrndnormal(&rs);
      }
   // Solve with LSQR, terminate after specified amount of A*x/A^T*x requests.
      linlsqrcreate(m, n, &s);
      linlsqrsetb(&s, &b);
      linlsqrsetcond(&s, 0.0, 0.0, n);
      linlsqrsetxrep(&s, true);
      firstpointreported = false;
      reportsafterrequest = 0;
      while (linlsqriteration(&s)) {
         if (s.needmv) {
            for (i = 0; i < m; i++) {
               s.mv.xR[i] = 0.0;
               for (j = 0; j < n; j++) {
                  s.mv.xR[i] += a.xyR[i][j] * s.x.xR[j];
               }
            }
            if (firstpointreported) {
               callsleft--;
            }
            if (callsleft == 0) {
               linlsqrrequesttermination(&s);
            }
         }
         if (s.needmtv) {
            for (i = 0; i < n; i++) {
               s.mtv.xR[i] = 0.0;
               for (j = 0; j < m; j++) {
                  s.mtv.xR[i] += a.xyR[j][i] * s.x.xR[j];
               }
            }
            if (firstpointreported) {
               callsleft--;
            }
            if (callsleft == 0) {
               linlsqrrequesttermination(&s);
            }
         }
         if (s.xupdated) {
            firstpointreported = true;
            if (callsleft <= 0) {
               reportsafterrequest++;
            }
         }
      }
      linlsqrresults(&s, &x1, &rep);
      set_error_flag(err, rep.terminationtype != 8, __FILE__, __LINE__, "testlinlsqrunit.ap:1460");
      set_error_flag(err, !isfinitevector(&x1, n), __FILE__, __LINE__, "testlinlsqrunit.ap:1461");
      set_error_flag(err, reportsafterrequest != 1, __FILE__, __LINE__, "testlinlsqrunit.ap:1462");
   }
   ae_frame_leave();
}

// Function for testing preconditioned LSQR method.
// ALGLIB: Copyright 14.11.2011 by Sergey Bochkanov
static bool testlinlsqrunit_preconditionertest() {
   ae_frame _frame_block;
   bool bflag;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(linlsqrstate, s);
   NewObj(linlsqrreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(ta, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewVector(b, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
// Test 1.
//
// We test automatic diagonal preconditioning used by SolveSparse.
// In order to do so we:
// 1. generate 20*20 matrix A0 with condition number equal to 1.0E1
// 2. generate random "exact" solution xe and right part b=A0*xe
// 3. generate random ill-conditioned diagonal scaling matrix D with
//    condition number equal to 1.0E50:
// 4. transform A*x=b into badly scaled problem:
//    A0*x0=b0
//    (A0*D)*(inv(D)*x0)=b0
//    finally we got new problem A*x=b with A=A0*D, b=b0, x=inv(D)*x0
//
// Then we solve A*x=b:
// 1. with default preconditioner
// 2. with explicitly activayed diagonal preconditioning
// 3. with unit preconditioner.
// 1st and 2nd solutions must be close to xe, 3rd solution must be very
// far from the true one.
   n = 20;
   rmatrixrndcond(n, 1.0E1, &ta);
   ae_vector_set_length(&xe, n);
   for (i = 0; i < n; i++) {
      xe.xR[i] = randomnormal();
   }
   ae_vector_set_length(&b, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = 0.0;
      for (j = 0; j < n; j++) {
         b.xR[i] += ta.xyR[i][j] * xe.xR[j];
      }
   }
   ae_vector_set_length(&d, n);
   for (i = 0; i < n; i++) {
      d.xR[i] = pow(10.0, 50.0 * randommid());
   }
   ae_matrix_set_length(&a, n, n);
   sparsecreate(n, n, n * n, &sa);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a.xyR[i][j] = ta.xyR[i][j] * d.xR[j];
         sparseset(&sa, i, j, a.xyR[i][j]);
      }
      xe.xR[i] /= d.xR[i];
   }
   sparseconverttocrs(&sa);
   linlsqrcreate(n, n, &s);
   linlsqrsetcond(&s, 0.0, 0.0, 2 * n);
   linlsqrsolvesparse(&s, &sa, &b);
   linlsqrresults(&s, &x0, &rep);
   if (rep.terminationtype <= 0) {
      result = true;
      ae_frame_leave();
      return result;
   }
   for (i = 0; i < n; i++) {
      if (fabs(xe.xR[i] - x0.xR[i]) > 5.0E-2 / d.xR[i]) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
   linlsqrsetprecunit(&s);
   linlsqrsolvesparse(&s, &sa, &b);
   linlsqrresults(&s, &x0, &rep);
   if (rep.terminationtype > 0) {
      bflag = false;
      for (i = 0; i < n; i++) {
         bflag = bflag || fabs(xe.xR[i] - x0.xR[i]) > 5.0E-2 / d.xR[i];
      }
      if (!bflag) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
   linlsqrsetprecdiag(&s);
   linlsqrsolvesparse(&s, &sa, &b);
   linlsqrresults(&s, &x0, &rep);
   if (rep.terminationtype <= 0) {
      result = true;
      ae_frame_leave();
      return result;
   }
   for (i = 0; i < n; i++) {
      if (fabs(xe.xR[i] - x0.xR[i]) > 5.0E-2 / d.xR[i]) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
// test has been passed
   result = false;
   ae_frame_leave();
   return result;
}

bool testlinlsqr(bool silent) {
   bool svdtesterrors;
   bool mwcranksvderr;
   bool mwicranksvderr;
   bool bidiagonalerr;
   bool zeromatrixerr;
   bool reportcorrectnesserr;
   bool stoppingcriteriaerr;
   bool analytictesterrors;
   bool prectesterrors;
   bool termreqerrors;
   bool waserrors;
   bool result;
   termreqerrors = false;
   svdtesterrors = testlinlsqrunit_svdtest(true);
   mwcranksvderr = testlinlsqrunit_mwcranksvdtest(true);
   mwicranksvderr = testlinlsqrunit_mwicranksvdtest(true);
   bidiagonalerr = testlinlsqrunit_bidiagonaltest(true);
   zeromatrixerr = testlinlsqrunit_zeromatrixtest(true);
   reportcorrectnesserr = testlinlsqrunit_reportcorrectnesstest(true);
   stoppingcriteriaerr = testlinlsqrunit_stoppingcriteriatest(true);
   analytictesterrors = testlinlsqrunit_analytictest(true);
   prectesterrors = testlinlsqrunit_preconditionertest();
   testlinlsqrunit_testterminationrequests(&termreqerrors);
// report
   waserrors = ((((((((svdtesterrors || mwcranksvderr) || mwicranksvderr) || bidiagonalerr) || zeromatrixerr) || reportcorrectnesserr) || stoppingcriteriaerr) || analytictesterrors) || prectesterrors) || termreqerrors;
   if (!silent) {
      printf("TESTING LinLSQR\n");
      printf("Different matrix types:\n");
      printf("* general M*N                                 ");
      if (svdtesterrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* well conditioned M*N                        ");
      if (mwcranksvderr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* rank deficient M*N                          ");
      if (mwicranksvderr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* sparse bidiagonal                           ");
      if (bidiagonalerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* zero                                        ");
      if (zeromatrixerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("Other properties:\n");
      printf("* report correctness                          ");
      if (reportcorrectnesserr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* stopping criteria                           ");
      if (stoppingcriteriaerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* analytic properties                         ");
      if (analytictesterrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* preconditioner test                         ");
      if (prectesterrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* termination requests                        ");
      if (termreqerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
   // was errors?
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === linmin testing unit ===
bool testlinmin(bool silent) {
   bool waserrors;
   bool result;
   waserrors = false;
   if (!silent) {
      printf("TESTING LINMIN\n");
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === nleq testing unit ===
// Himmelblau's function
//
//     F = (x^2+y-11)^2 + (x+y^2-7)^2
//
// posed as system of M functions:
//
//     f0 = x^2+y-11
//     f1 = x+y^2-7
//
static void testnlequnit_testfunchbm(nleqstate *state) {
   double x;
   double y;
   ae_assert(state->needf || state->needfij, "TestNLEQUnit: internal error!");
   x = state->x.xR[0];
   y = state->x.xR[1];
   if (state->needf) {
      state->f = sqr(x * x + y - 11) + sqr(x + y * y - 7);
      return;
   }
   if (state->needfij) {
      state->fi.xR[0] = x * x + y - 11;
      state->fi.xR[1] = x + y * y - 7;
      state->j.xyR[0][0] = 2 * x;
      state->j.xyR[0][1] = 1.0;
      state->j.xyR[1][0] = 1.0;
      state->j.xyR[1][1] = 2 * y;
      return;
   }
}

// Himmelblau's function
//
//     F = (x^2+y-11)^2 + (x+y^2-7)^2
//
// posed as system of 1 function
static void testnlequnit_testfunchb1(nleqstate *state) {
   double x;
   double y;
   ae_assert(state->needf || state->needfij, "TestNLEQUnit: internal error!");
   x = state->x.xR[0];
   y = state->x.xR[1];
   if (state->needf) {
      state->f = sqr(sqr(x * x + y - 11) + sqr(x + y * y - 7));
      return;
   }
   if (state->needfij) {
      state->fi.xR[0] = sqr(x * x + y - 11) + sqr(x + y * y - 7);
      state->j.xyR[0][0] = 2 * (x * x + y - 11) * 2 * x + 2 * (x + y * y - 7);
      state->j.xyR[0][1] = 2 * (x * x + y - 11) + 2 * (x + y * y - 7) * 2 * y;
      return;
   }
}

// Shifted Himmelblau's function
//
//     F = (x^2+y-11)^2 + (x+y^2-7)^2 + 1
//
// posed as system of M functions:
//
//     f0 = x^2+y-11
//     f1 = x+y^2-7
//     f2 = 1
//
// This function is used to test algorithm on problem which has no solution.
static void testnlequnit_testfuncshbm(nleqstate *state) {
   double x;
   double y;
   ae_assert(state->needf || state->needfij, "TestNLEQUnit: internal error!");
   x = state->x.xR[0];
   y = state->x.xR[1];
   if (state->needf) {
      state->f = sqr(x * x + y - 11) + sqr(x + y * y - 7) + 1;
      return;
   }
   if (state->needfij) {
      state->fi.xR[0] = x * x + y - 11;
      state->fi.xR[1] = x + y * y - 7;
      state->fi.xR[2] = 1.0;
      state->j.xyR[0][0] = 2 * x;
      state->j.xyR[0][1] = 1.0;
      state->j.xyR[1][0] = 1.0;
      state->j.xyR[1][1] = 2 * y;
      state->j.xyR[2][0] = 0.0;
      state->j.xyR[2][1] = 0.0;
      return;
   }
}

bool testnleq(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   bool basicserrors;
   bool converror;
   bool othererrors;
   ae_int_t n;
   ae_int_t i;
   ae_int_t k;
   double v;
   double flast;
   bool firstrep;
   ae_int_t nfunc;
   ae_int_t njac;
   ae_int_t itcnt;
   ae_int_t pass;
   ae_int_t passcount;
   double epsf;
   double stpmax;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewObj(nleqstate, state);
   NewObj(nleqreport, rep);
   waserrors = false;
   basicserrors = false;
   converror = false;
   othererrors = false;
// Basic tests
//
// Test with Himmelblau's function (M):
// * ability to find correct result
// * ability to work after soft restart (restart after finish)
// * ability to work after hard restart (restart in the middle of optimization)
   passcount = 100;
   for (pass = 0; pass < passcount; pass++) {
   // Ability to find correct result
      ae_vector_set_length(&x, 2);
      x.xR[0] = 10.0 * randommid();
      x.xR[1] = 10.0 * randommid();
      nleqcreatelm(2, 2, &x, &state);
      epsf = 1.0E-9;
      nleqsetcond(&state, epsf, 0);
      while (nleqiteration(&state)) {
         testnlequnit_testfunchbm(&state);
      }
      nleqresults(&state, &x, &rep);
      if (rep.terminationtype > 0) {
         basicserrors = basicserrors || sqr(x.xR[0] * x.xR[0] + x.xR[1] - 11) + sqr(x.xR[0] + x.xR[1] * x.xR[1] - 7) > sqr(epsf);
      } else {
         basicserrors = true;
      }
   // Ability to work after soft restart
      ae_vector_set_length(&x, 2);
      x.xR[0] = 10.0 * randommid();
      x.xR[1] = 10.0 * randommid();
      nleqcreatelm(2, 2, &x, &state);
      epsf = 1.0E-9;
      nleqsetcond(&state, epsf, 0);
      while (nleqiteration(&state)) {
         testnlequnit_testfunchbm(&state);
      }
      nleqresults(&state, &x, &rep);
      ae_vector_set_length(&x, 2);
      x.xR[0] = 10.0 * randommid();
      x.xR[1] = 10.0 * randommid();
      nleqrestartfrom(&state, &x);
      while (nleqiteration(&state)) {
         testnlequnit_testfunchbm(&state);
      }
      nleqresults(&state, &x, &rep);
      if (rep.terminationtype > 0) {
         basicserrors = basicserrors || sqr(x.xR[0] * x.xR[0] + x.xR[1] - 11) + sqr(x.xR[0] + x.xR[1] * x.xR[1] - 7) > sqr(epsf);
      } else {
         basicserrors = true;
      }
   // Ability to work after hard restart:
   // * stopping condition: small F
   // * StpMax is so small that we need about 10000 iterations to
   //   find solution (steps are small)
   // * choose random K significantly less that 9999
   // * iterate for some time, then break, restart optimization
      ae_vector_set_length(&x, 2);
      x.xR[0] = 100.0;
      x.xR[1] = 100.0;
      nleqcreatelm(2, 2, &x, &state);
      epsf = 1.0E-9;
      nleqsetcond(&state, epsf, 0);
      nleqsetstpmax(&state, 0.01);
      k = 1 + randominteger(100);
      for (i = 0; i < k; i++) {
         if (!nleqiteration(&state)) {
            break;
         }
         testnlequnit_testfunchbm(&state);
      }
      ae_vector_set_length(&x, 2);
      x.xR[0] = 10.0 * randommid();
      x.xR[1] = 10.0 * randommid();
      nleqrestartfrom(&state, &x);
      while (nleqiteration(&state)) {
         testnlequnit_testfunchbm(&state);
      }
      nleqresults(&state, &x, &rep);
      if (rep.terminationtype > 0) {
         basicserrors = basicserrors || sqr(x.xR[0] * x.xR[0] + x.xR[1] - 11) + sqr(x.xR[0] + x.xR[1] * x.xR[1] - 7) > sqr(epsf);
      } else {
         basicserrors = true;
      }
   }
// Basic tests
//
// Test with Himmelblau's function (1):
// * ability to find correct result
   passcount = 100;
   for (pass = 0; pass < passcount; pass++) {
   // Ability to find correct result
      ae_vector_set_length(&x, 2);
      x.xR[0] = 10.0 * randommid();
      x.xR[1] = 10.0 * randommid();
      nleqcreatelm(2, 1, &x, &state);
      epsf = 1.0E-9;
      nleqsetcond(&state, epsf, 0);
      while (nleqiteration(&state)) {
         testnlequnit_testfunchb1(&state);
      }
      nleqresults(&state, &x, &rep);
      if (rep.terminationtype > 0) {
         basicserrors = basicserrors || sqr(x.xR[0] * x.xR[0] + x.xR[1] - 11) + sqr(x.xR[0] + x.xR[1] * x.xR[1] - 7) > epsf;
      } else {
         basicserrors = true;
      }
   }
// Basic tests
//
// Ability to detect situation when we can't find minimum
   passcount = 100;
   for (pass = 0; pass < passcount; pass++) {
      ae_vector_set_length(&x, 2);
      x.xR[0] = 10.0 * randommid();
      x.xR[1] = 10.0 * randommid();
      nleqcreatelm(2, 3, &x, &state);
      epsf = 1.0E-9;
      nleqsetcond(&state, epsf, 0);
      while (nleqiteration(&state)) {
         testnlequnit_testfuncshbm(&state);
      }
      nleqresults(&state, &x, &rep);
      basicserrors = basicserrors || rep.terminationtype != -4;
   }
// Test correctness of intermediate reports and final report:
// * first report is starting point
// * function value decreases on subsequent reports
// * function value is correctly reported
// * last report is final point
// * NFunc and NJac are compared with values counted directly
// * IterationsCount is compared with value counter directly
   n = 2;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&xlast, n);
   x.xR[0] = 10.0 * randommid();
   x.xR[1] = 10.0 * randommid();
   xlast.xR[0] = maxrealnumber;
   xlast.xR[1] = maxrealnumber;
   nleqcreatelm(n, 2, &x, &state);
   nleqsetcond(&state, 1.0E-6, 0);
   nleqsetxrep(&state, true);
   firstrep = true;
   flast = maxrealnumber;
   nfunc = 0;
   njac = 0;
   itcnt = 0;
   while (nleqiteration(&state)) {
      if (state.xupdated) {
      // first report must be starting point
         if (firstrep) {
            for (i = 0; i < n; i++) {
               othererrors = othererrors || state.x.xR[i] != x.xR[i];
            }
            firstrep = false;
         }
      // function value must decrease
         othererrors = othererrors || state.f > flast;
      // check correctness of function value
         v = sqr(state.x.xR[0] * state.x.xR[0] + state.x.xR[1] - 11) + sqr(state.x.xR[0] + state.x.xR[1] * state.x.xR[1] - 7);
         othererrors = othererrors || fabs(v - state.f) / rmax2(v, 1.0) > 100 * machineepsilon;
      // update info and continue
         ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
         flast = state.f;
         itcnt++;
         continue;
      }
      if (state.needf) {
         nfunc++;
      }
      if (state.needfij) {
         nfunc++;
         njac++;
      }
      testnlequnit_testfunchbm(&state);
   }
   nleqresults(&state, &x, &rep);
   if (rep.terminationtype > 0) {
      othererrors = (othererrors || xlast.xR[0] != x.xR[0]) || xlast.xR[1] != x.xR[1];
      v = sqr(x.xR[0] * x.xR[0] + x.xR[1] - 11) + sqr(x.xR[0] + x.xR[1] * x.xR[1] - 7);
      othererrors = othererrors || fabs(flast - v) / rmax2(v, 1.0) > 100 * machineepsilon;
   } else {
      converror = true;
   }
   othererrors = othererrors || rep.nfunc != nfunc;
   othererrors = othererrors || rep.njac != njac;
   othererrors = othererrors || rep.iterationscount != itcnt - 1;
// Test ability to set limit on algorithm steps
   ae_vector_set_length(&x, 2);
   ae_vector_set_length(&xlast, 2);
   x.xR[0] = 20 * randomreal() + 20;
   x.xR[1] = 20 * randomreal() + 20;
   xlast.xR[0] = x.xR[0];
   xlast.xR[1] = x.xR[1];
   stpmax = 0.1 + 0.1 * randomreal();
   epsf = 1.0E-9;
   nleqcreatelm(2, 2, &x, &state);
   nleqsetstpmax(&state, stpmax);
   nleqsetcond(&state, epsf, 0);
   nleqsetxrep(&state, true);
   while (nleqiteration(&state)) {
      if (state.needf || state.needfij) {
         testnlequnit_testfunchbm(&state);
      }
      if ((state.needf || state.needfij) || state.xupdated) {
         othererrors = othererrors || sqrt(sqr(state.x.xR[0] - xlast.xR[0]) + sqr(state.x.xR[1] - xlast.xR[1])) > 1.00001 * stpmax;
      }
      if (state.xupdated) {
         xlast.xR[0] = state.x.xR[0];
         xlast.xR[1] = state.x.xR[1];
      }
   }
// end
   waserrors = (basicserrors || converror) || othererrors;
   if (!silent) {
      printf("TESTING NLEQ SOLVER\n");
      printf("BASIC FUNCTIONALITY:                      ");
      if (basicserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("CONVERGENCE:                              ");
      if (converror) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("OTHER PROPERTIES:                         ");
      if (othererrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === matinv testing unit ===
// Copy
static void testmatinvunit_rmatrixmakeacopy(RMatrix *a, ae_int_t m, ae_int_t n, RMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m - 1 + 1, n - 1 + 1);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyR[i][j] = a->xyR[i][j];
      }
   }
}

// Copy
static void testmatinvunit_cmatrixmakeacopy(CMatrix *a, ae_int_t m, ae_int_t n, CMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m - 1 + 1, n - 1 + 1);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyC[i][j] = a->xyC[i][j];
      }
   }
}

// Checks whether inverse is correct
// Returns True on success.
static bool testmatinvunit_rmatrixcheckinverse(RMatrix *a, RMatrix *inva, ae_int_t n, double threshold, ae_int_t info, matinvreport *rep) {
   ae_int_t i;
   ae_int_t j;
   double v;
   bool result;
   result = true;
   if (info <= 0) {
      result = false;
   } else {
      result = result && !(rep->r1 < 100 * machineepsilon || rep->r1 > 1 + 1000 * machineepsilon);
      result = result && !(rep->rinf < 100 * machineepsilon || rep->rinf > 1 + 1000 * machineepsilon);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            v = ae_v_dotproduct(a->xyR[i], 1, &inva->xyR[0][j], inva->stride, n);
            if (i == j) {
               v--;
            }
            result = result && fabs(v) <= threshold;
         }
      }
   }
   return result;
}

// Checks whether inverse is correct
// Returns True on success.
static bool testmatinvunit_cmatrixcheckinverse(CMatrix *a, CMatrix *inva, ae_int_t n, double threshold, ae_int_t info, matinvreport *rep) {
   ae_int_t i;
   ae_int_t j;
   complex v;
   bool result;
   result = true;
   if (info <= 0) {
      result = false;
   } else {
      result = result && !(rep->r1 < 100 * machineepsilon || rep->r1 > 1 + 1000 * machineepsilon);
      result = result && !(rep->rinf < 100 * machineepsilon || rep->rinf > 1 + 1000 * machineepsilon);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            v = ae_v_cdotproduct(a->xyC[i], 1, "N", &inva->xyC[0][j], inva->stride, "N", n);
            if (i == j) {
               v = ae_c_sub_d(v, 1);
            }
            result = result && abscomplex(v) <= threshold;
         }
      }
   }
   return result;
}

// Checks whether inverse is correct
// Returns True on success.
static bool testmatinvunit_spdmatrixcheckinverse(RMatrix *a, RMatrix *inva, bool isupper, ae_int_t n, double threshold, ae_int_t info, matinvreport *rep) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   bool result;
   ae_frame_make(&_frame_block);
   DupMatrix(a);
   DupMatrix(inva);
   for (i = 0; i < n - 1; i++) {
      if (isupper) {
         ae_v_move(&a->xyR[i + 1][i], a->stride, &a->xyR[i][i + 1], 1, n - i - 1);
         ae_v_move(&inva->xyR[i + 1][i], inva->stride, &inva->xyR[i][i + 1], 1, n - i - 1);
      } else {
         ae_v_move(&a->xyR[i][i + 1], 1, &a->xyR[i + 1][i], a->stride, n - i - 1);
         ae_v_move(&inva->xyR[i][i + 1], 1, &inva->xyR[i + 1][i], inva->stride, n - i - 1);
      }
   }
   result = true;
   if (info <= 0) {
      result = false;
   } else {
      result = result && !(rep->r1 < 100 * machineepsilon || rep->r1 > 1 + 1000 * machineepsilon);
      result = result && !(rep->rinf < 100 * machineepsilon || rep->rinf > 1 + 1000 * machineepsilon);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            v = ae_v_dotproduct(a->xyR[i], 1, &inva->xyR[0][j], inva->stride, n);
            if (i == j) {
               v--;
            }
            result = result && fabs(v) <= threshold;
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Checks whether inverse is correct
// Returns True on success.
static bool testmatinvunit_hpdmatrixcheckinverse(CMatrix *a, CMatrix *inva, bool isupper, ae_int_t n, double threshold, ae_int_t info, matinvreport *rep) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   complex v;
   bool result;
   ae_frame_make(&_frame_block);
   DupMatrix(a);
   DupMatrix(inva);
   for (i = 0; i < n - 1; i++) {
      if (isupper) {
         ae_v_cmove(&a->xyC[i + 1][i], a->stride, &a->xyC[i][i + 1], 1, "Conj", n - i - 1);
         ae_v_cmove(&inva->xyC[i + 1][i], inva->stride, &inva->xyC[i][i + 1], 1, "Conj", n - i - 1);
      } else {
         ae_v_cmove(&a->xyC[i][i + 1], 1, &a->xyC[i + 1][i], a->stride, "Conj", n - i - 1);
         ae_v_cmove(&inva->xyC[i][i + 1], 1, &inva->xyC[i + 1][i], inva->stride, "Conj", n - i - 1);
      }
   }
   result = true;
   if (info <= 0) {
      result = false;
   } else {
      result = result && !(rep->r1 < 100 * machineepsilon || rep->r1 > 1 + 1000 * machineepsilon);
      result = result && !(rep->rinf < 100 * machineepsilon || rep->rinf > 1 + 1000 * machineepsilon);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            v = ae_v_cdotproduct(a->xyC[i], 1, "N", &inva->xyC[0][j], inva->stride, "N", n);
            if (i == j) {
               v = ae_c_sub_d(v, 1);
            }
            result = result && abscomplex(v) <= threshold;
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Checks whether inversion result indicate singular matrix
// Returns True on success.
static bool testmatinvunit_rmatrixcheckinversesingular(RMatrix *inva, ae_int_t n, double threshold, ae_int_t info, matinvreport *rep) {
   ae_int_t i;
   ae_int_t j;
   bool result;
   result = true;
   if (info != -3 && info != 1) {
      result = false;
   } else {
      result = result && !(rep->r1 < 0.0 || rep->r1 > 1000 * machineepsilon);
      result = result && !(rep->rinf < 0.0 || rep->rinf > 1000 * machineepsilon);
      if (info == -3) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               result = result && inva->xyR[i][j] == 0.0;
            }
         }
      }
   }
   return result;
}

// Checks whether inversion result indicate singular matrix
// Returns True on success.
static bool testmatinvunit_cmatrixcheckinversesingular(CMatrix *inva, ae_int_t n, double threshold, ae_int_t info, matinvreport *rep) {
   ae_int_t i;
   ae_int_t j;
   bool result;
   result = true;
   if (info != -3 && info != 1) {
      result = false;
   } else {
      result = result && !(rep->r1 < 0.0 || rep->r1 > 1000 * machineepsilon);
      result = result && !(rep->rinf < 0.0 || rep->rinf > 1000 * machineepsilon);
      if (info == -3) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               result = result && ae_c_eq_d(inva->xyC[i][j], 0.0);
            }
         }
      }
   }
   return result;
}

// Drops upper or lower half of the matrix - fills it by special pattern
// which may be used later to ensure that this part wasn't changed
static void testmatinvunit_rmatrixdrophalf(RMatrix *a, ae_int_t n, bool droplower) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (droplower ? i > j : i < j) {
            a->xyR[i][j] = (double)(1 + 2 * i + 3 * j);
         }
      }
   }
}

// Drops upper or lower half of the matrix - fills it by special pattern
// which may be used later to ensure that this part wasn't changed
static void testmatinvunit_cmatrixdrophalf(CMatrix *a, ae_int_t n, bool droplower) {
   ae_int_t i;
   ae_int_t j;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (droplower ? i > j : i < j) {
            a->xyC[i][j] = complex_from_i(1 + 2 * i + 3 * j);
         }
      }
   }
}

// Real TR inverse
static void testmatinvunit_testrtrinv(ae_int_t minn, ae_int_t maxn, ae_int_t passcount, double threshold, bool *rtrerrors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t task;
   bool isupper;
   bool isunit;
   double v;
   ae_int_t info;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewObj(matinvreport, rep);
// Test
   for (n = minn; n <= maxn; n++) {
      ae_matrix_set_length(&a, n, n);
      ae_matrix_set_length(&b, n, n);
      for (task = 0; task <= 3; task++) {
         for (pass = 1; pass <= passcount; pass++) {
         // Determine task
            isupper = task % 2 == 0;
            isunit = task / 2 % 2 == 0;
         // Generate matrix
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (i == j) {
                     a.xyR[i][i] = 1 + randomreal();
                  } else {
                     a.xyR[i][j] = 0.1 * randommid();
                  }
                  b.xyR[i][j] = a.xyR[i][j];
               }
            }
         // Inverse
            rmatrixtrinverse(&b, n, isupper, isunit, &info, &rep);
            if (info <= 0) {
               *rtrerrors = true;
               ae_frame_leave();
               return;
            }
         // Structural test
            if (isunit) {
               for (i = 0; i < n; i++) {
                  *rtrerrors = *rtrerrors || a.xyR[i][i] != b.xyR[i][i];
               }
            }
            if (isupper) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < i; j++) {
                     *rtrerrors = *rtrerrors || a.xyR[i][j] != b.xyR[i][j];
                  }
               }
            } else {
               for (i = 0; i < n; i++) {
                  for (j = i + 1; j < n; j++) {
                     *rtrerrors = *rtrerrors || a.xyR[i][j] != b.xyR[i][j];
                  }
               }
            }
         // Inverse test
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper ? j < i : j > i) {
                     a.xyR[i][j] = 0.0;
                     b.xyR[i][j] = 0.0;
                  }
               }
            }
            if (isunit) {
               for (i = 0; i < n; i++) {
                  a.xyR[i][i] = 1.0;
                  b.xyR[i][i] = 1.0;
               }
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, &b.xyR[0][j], b.stride, n);
                  if (j != i) {
                     *rtrerrors = *rtrerrors || fabs(v) > threshold;
                  } else {
                     *rtrerrors = *rtrerrors || fabs(v - 1) > threshold;
                  }
               }
            }
         }
      }
   }
   ae_frame_leave();
}

// Complex TR inverse
static void testmatinvunit_testctrinv(ae_int_t minn, ae_int_t maxn, ae_int_t passcount, double threshold, bool *ctrerrors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t task;
   bool isupper;
   bool isunit;
   complex v;
   ae_int_t info;
   double emax;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(b, 0, 0, DT_COMPLEX);
   NewObj(matinvreport, rep);
// Test
   for (n = minn; n <= maxn; n++) {
      ae_matrix_set_length(&a, n, n);
      ae_matrix_set_length(&b, n, n);
      for (task = 0; task <= 3; task++) {
         for (pass = 1; pass <= passcount; pass++) {
         // Determine task
            isupper = task % 2 == 0;
            isunit = task / 2 % 2 == 0;
         // Generate matrix
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (i == j) {
                     a.xyC[i][i] = complex_from_d(1 + randomreal(), 1 + randomreal());
                  } else {
                     a.xyC[i][j] = complex_from_d(0.1 * randommid(), 0.1 * randommid());
                  }
                  b.xyC[i][j] = a.xyC[i][j];
               }
            }
         // Inverse
            cmatrixtrinverse(&b, n, isupper, isunit, &info, &rep);
            if (info <= 0) {
               *ctrerrors = true;
               ae_frame_leave();
               return;
            }
         // Structural test
            if (isunit) {
               for (i = 0; i < n; i++) {
                  *ctrerrors = *ctrerrors || ae_c_neq(a.xyC[i][i], b.xyC[i][i]);
               }
            }
            if (isupper) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < i; j++) {
                     *ctrerrors = *ctrerrors || ae_c_neq(a.xyC[i][j], b.xyC[i][j]);
                  }
               }
            } else {
               for (i = 0; i < n; i++) {
                  for (j = i + 1; j < n; j++) {
                     *ctrerrors = *ctrerrors || ae_c_neq(a.xyC[i][j], b.xyC[i][j]);
                  }
               }
            }
         // Inverse test
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (isupper ? j < i : j > i) {
                     a.xyC[i][j] = complex_from_i(0);
                     b.xyC[i][j] = complex_from_i(0);
                  }
               }
            }
            if (isunit) {
               for (i = 0; i < n; i++) {
                  a.xyC[i][i] = complex_from_i(1);
                  b.xyC[i][i] = complex_from_i(1);
               }
            }
            emax = 0.0;
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v = ae_v_cdotproduct(a.xyC[i], 1, "N", &b.xyC[0][j], b.stride, "N", n);
                  if (j == i) {
                     v = ae_c_sub_d(v, 1);
                  }
                  emax = rmax2(emax, abscomplex(v));
               }
            }
            *ctrerrors = *ctrerrors || emax > threshold;
         }
      }
   }
   ae_frame_leave();
}

// Unsets real matrix
static void testmatinvunit_unset2d(RMatrix *x) {
   ae_matrix_set_length(x, 1, 1);
   x->xyR[0][0] = randommid();
}

// Unsets real matrix
static void testmatinvunit_cunset2d(CMatrix *x) {
   ae_matrix_set_length(x, 1, 1);
   x->xyC[0][0] = complex_from_d(randommid());
}

// Unsets report
static void testmatinvunit_unsetrep(matinvreport *r) {
   r->r1 = -1.0;
   r->rinf = -1.0;
}

// Real test
static void testmatinvunit_testrinv(ae_int_t minn, ae_int_t maxn, ae_int_t passcount, double threshold, bool *rerrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t taskkind;
   ae_int_t info;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(lua, 0, 0, DT_REAL);
   NewMatrix(inva, 0, 0, DT_REAL);
   NewMatrix(invlua, 0, 0, DT_REAL);
   NewVector(p, 0, DT_INT);
   NewObj(matinvreport, rep);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = minn; n <= maxn; n++) {
      // ********************************************************
      // WELL CONDITIONED TASKS
      // ability to find correct solution is tested
      // ********************************************************
      //
      // 1. generate random well conditioned matrix A.
      // 2. generate random solution vector xe
      // 3. generate right part b=A*xe
      // 4. test different methods on original A
         rmatrixrndcond(n, 1000.0, &a);
         testmatinvunit_rmatrixmakeacopy(&a, n, n, &lua);
         rmatrixlu(&lua, n, n, &p);
         testmatinvunit_rmatrixmakeacopy(&a, n, n, &inva);
         testmatinvunit_rmatrixmakeacopy(&lua, n, n, &invlua);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         rmatrixinverse(&inva, n, &info, &rep);
         *rerrors = *rerrors || !testmatinvunit_rmatrixcheckinverse(&a, &inva, n, threshold, info, &rep);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         rmatrixluinverse(&invlua, &p, n, &info, &rep);
         *rerrors = *rerrors || !testmatinvunit_rmatrixcheckinverse(&a, &invlua, n, threshold, info, &rep);
      // ********************************************************
      // EXACTLY SINGULAR MATRICES
      // ability to detect singularity is tested
      // ********************************************************
      //
      // 1. generate different types of singular matrices:
      //    * zero
      //    * with zero columns
      //    * with zero rows
      //    * with equal rows/columns
      // 2. test different methods
         for (taskkind = 0; taskkind <= 4; taskkind++) {
            testmatinvunit_unset2d(&a);
            if (taskkind == 0) {
            // all zeros
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
            if (taskkind == 1) {
            // there is zero column
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = randommid();
                  }
               }
               k = randominteger(n);
               ae_v_muld(&a.xyR[0][k], a.stride, n, 0);
            }
            if (taskkind == 2) {
            // there is zero row
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = randommid();
                  }
               }
               k = randominteger(n);
               ae_v_muld(a.xyR[k], 1, n, 0);
            }
            if (taskkind == 3) {
            // equal columns
               if (n < 2) {
                  continue;
               }
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = randommid();
                  }
               }
               k = 1 + randominteger(n - 1);
               ae_v_move(a.xyR[0], a.stride, &a.xyR[0][k], a.stride, n);
            }
            if (taskkind == 4) {
            // equal rows
               if (n < 2) {
                  continue;
               }
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = randommid();
                  }
               }
               k = 1 + randominteger(n - 1);
               ae_v_move(a.xyR[0], 1, a.xyR[k], 1, n);
            }
            testmatinvunit_rmatrixmakeacopy(&a, n, n, &lua);
            rmatrixlu(&lua, n, n, &p);
            info = 0;
            testmatinvunit_unsetrep(&rep);
            rmatrixinverse(&a, n, &info, &rep);
            *rerrors = *rerrors || !testmatinvunit_rmatrixcheckinversesingular(&a, n, threshold, info, &rep);
            info = 0;
            testmatinvunit_unsetrep(&rep);
            rmatrixluinverse(&lua, &p, n, &info, &rep);
            *rerrors = *rerrors || !testmatinvunit_rmatrixcheckinversesingular(&lua, n, threshold, info, &rep);
         }
      }
   }
   ae_frame_leave();
}

// Complex test
static void testmatinvunit_testcinv(ae_int_t minn, ae_int_t maxn, ae_int_t passcount, double threshold, bool *cerrors) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t taskkind;
   ae_int_t info;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(lua, 0, 0, DT_COMPLEX);
   NewMatrix(inva, 0, 0, DT_COMPLEX);
   NewMatrix(invlua, 0, 0, DT_COMPLEX);
   NewVector(p, 0, DT_INT);
   NewObj(matinvreport, rep);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = minn; n <= maxn; n++) {
      // ********************************************************
      // WELL CONDITIONED TASKS
      // ability to find correct solution is tested
      // ********************************************************
      //
      // 1. generate random well conditioned matrix A.
      // 2. generate random solution vector xe
      // 3. generate right part b=A*xe
      // 4. test different methods on original A
         cmatrixrndcond(n, 1000.0, &a);
         testmatinvunit_cmatrixmakeacopy(&a, n, n, &lua);
         cmatrixlu(&lua, n, n, &p);
         testmatinvunit_cmatrixmakeacopy(&a, n, n, &inva);
         testmatinvunit_cmatrixmakeacopy(&lua, n, n, &invlua);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         cmatrixinverse(&inva, n, &info, &rep);
         *cerrors = *cerrors || !testmatinvunit_cmatrixcheckinverse(&a, &inva, n, threshold, info, &rep);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         cmatrixluinverse(&invlua, &p, n, &info, &rep);
         *cerrors = *cerrors || !testmatinvunit_cmatrixcheckinverse(&a, &invlua, n, threshold, info, &rep);
      // ********************************************************
      // EXACTLY SINGULAR MATRICES
      // ability to detect singularity is tested
      // ********************************************************
      //
      // 1. generate different types of singular matrices:
      //    * zero
      //    * with zero columns
      //    * with zero rows
      //    * with equal rows/columns
      // 2. test different methods
         for (taskkind = 0; taskkind <= 4; taskkind++) {
            testmatinvunit_cunset2d(&a);
            if (taskkind == 0) {
            // all zeros
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_i(0);
                  }
               }
            }
            if (taskkind == 1) {
            // there is zero column
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_d(randommid(), randommid());
                  }
               }
               k = randominteger(n);
               ae_v_cmuld(&a.xyC[0][k], a.stride, n, 0);
            }
            if (taskkind == 2) {
            // there is zero row
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_d(randommid(), randommid());
                  }
               }
               k = randominteger(n);
               ae_v_cmuld(a.xyC[k], 1, n, 0);
            }
            if (taskkind == 3) {
            // equal columns
               if (n < 2) {
                  continue;
               }
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_d(randommid(), randommid());
                  }
               }
               k = 1 + randominteger(n - 1);
               ae_v_cmove(a.xyC[0], a.stride, &a.xyC[0][k], a.stride, "N", n);
            }
            if (taskkind == 4) {
            // equal rows
               if (n < 2) {
                  continue;
               }
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_d(randommid(), randommid());
                  }
               }
               k = 1 + randominteger(n - 1);
               ae_v_cmove(a.xyC[0], 1, a.xyC[k], 1, "N", n);
            }
            testmatinvunit_cmatrixmakeacopy(&a, n, n, &lua);
            cmatrixlu(&lua, n, n, &p);
            info = 0;
            testmatinvunit_unsetrep(&rep);
            cmatrixinverse(&a, n, &info, &rep);
            *cerrors = *cerrors || !testmatinvunit_cmatrixcheckinversesingular(&a, n, threshold, info, &rep);
            info = 0;
            testmatinvunit_unsetrep(&rep);
            cmatrixluinverse(&lua, &p, n, &info, &rep);
            *cerrors = *cerrors || !testmatinvunit_cmatrixcheckinversesingular(&lua, n, threshold, info, &rep);
         }
      }
   }
   ae_frame_leave();
}

// SPD test
static void testmatinvunit_testspdinv(ae_int_t minn, ae_int_t maxn, ae_int_t passcount, double threshold, bool *spderrors) {
   ae_frame _frame_block;
   bool isupper;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t taskkind;
   ae_int_t info;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(cha, 0, 0, DT_REAL);
   NewMatrix(inva, 0, 0, DT_REAL);
   NewMatrix(invcha, 0, 0, DT_REAL);
   NewObj(matinvreport, rep);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = minn; n <= maxn; n++) {
         isupper = randombool();
      // ********************************************************
      // WELL CONDITIONED TASKS
      // ability to find correct solution is tested
      // ********************************************************
      //
      // 1. generate random well conditioned matrix A.
      // 2. generate random solution vector xe
      // 3. generate right part b=A*xe
      // 4. test different methods on original A
         spdmatrixrndcond(n, 1000.0, &a);
         testmatinvunit_rmatrixdrophalf(&a, n, isupper);
         testmatinvunit_rmatrixmakeacopy(&a, n, n, &cha);
         if (!spdmatrixcholesky(&cha, n, isupper)) {
            continue;
         }
         testmatinvunit_rmatrixmakeacopy(&a, n, n, &inva);
         testmatinvunit_rmatrixmakeacopy(&cha, n, n, &invcha);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         spdmatrixinverse(&inva, n, isupper, &info, &rep);
         *spderrors = *spderrors || !testmatinvunit_spdmatrixcheckinverse(&a, &inva, isupper, n, threshold, info, &rep);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         spdmatrixcholeskyinverse(&invcha, n, isupper, &info, &rep);
         *spderrors = *spderrors || !testmatinvunit_spdmatrixcheckinverse(&a, &invcha, isupper, n, threshold, info, &rep);
      // ********************************************************
      // EXACTLY SINGULAR MATRICES
      // ability to detect singularity is tested
      // ********************************************************
      //
      // 1. generate different types of singular matrices:
      //    * zero
      //    * with zero columns
      //    * with zero rows
      // 2. test different methods
         for (taskkind = 0; taskkind <= 2; taskkind++) {
            testmatinvunit_unset2d(&a);
            if (taskkind == 0) {
            // all zeros
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
            }
            if (taskkind == 1) {
            // there is zero column
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = randommid();
                  }
               }
               k = randominteger(n);
               ae_v_muld(&a.xyR[0][k], a.stride, n, 0);
            }
            if (taskkind == 2) {
            // there is zero row
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = randommid();
                  }
               }
               k = randominteger(n);
               ae_v_muld(a.xyR[k], 1, n, 0);
            }
            info = 0;
            testmatinvunit_unsetrep(&rep);
            spdmatrixcholeskyinverse(&a, n, isupper, &info, &rep);
            if (info != -3 && info != 1) {
               *spderrors = true;
            } else {
               *spderrors = (*spderrors || rep.r1 < 0.0) || rep.r1 > 1000 * machineepsilon;
               *spderrors = (*spderrors || rep.rinf < 0.0) || rep.rinf > 1000 * machineepsilon;
            }
         }
      }
   }
   ae_frame_leave();
}

// HPD test
static void testmatinvunit_testhpdinv(ae_int_t minn, ae_int_t maxn, ae_int_t passcount, double threshold, bool *hpderrors) {
   ae_frame _frame_block;
   bool isupper;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t taskkind;
   ae_int_t info;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_COMPLEX);
   NewMatrix(cha, 0, 0, DT_COMPLEX);
   NewMatrix(inva, 0, 0, DT_COMPLEX);
   NewMatrix(invcha, 0, 0, DT_COMPLEX);
   NewObj(matinvreport, rep);
// General square matrices:
// * test general solvers
// * test least squares solver
   for (pass = 1; pass <= passcount; pass++) {
      for (n = minn; n <= maxn; n++) {
         isupper = randombool();
      // ********************************************************
      // WELL CONDITIONED TASKS
      // ability to find correct solution is tested
      // ********************************************************
      //
      // 1. generate random well conditioned matrix A.
      // 2. generate random solution vector xe
      // 3. generate right part b=A*xe
      // 4. test different methods on original A
         hpdmatrixrndcond(n, 1000.0, &a);
         testmatinvunit_cmatrixdrophalf(&a, n, isupper);
         testmatinvunit_cmatrixmakeacopy(&a, n, n, &cha);
         if (!hpdmatrixcholesky(&cha, n, isupper)) {
            continue;
         }
         testmatinvunit_cmatrixmakeacopy(&a, n, n, &inva);
         testmatinvunit_cmatrixmakeacopy(&cha, n, n, &invcha);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         hpdmatrixinverse(&inva, n, isupper, &info, &rep);
         *hpderrors = *hpderrors || !testmatinvunit_hpdmatrixcheckinverse(&a, &inva, isupper, n, threshold, info, &rep);
         info = 0;
         testmatinvunit_unsetrep(&rep);
         hpdmatrixcholeskyinverse(&invcha, n, isupper, &info, &rep);
         *hpderrors = *hpderrors || !testmatinvunit_hpdmatrixcheckinverse(&a, &invcha, isupper, n, threshold, info, &rep);
      // ********************************************************
      // EXACTLY SINGULAR MATRICES
      // ability to detect singularity is tested
      // ********************************************************
      //
      // 1. generate different types of singular matrices:
      //    * zero
      //    * with zero columns
      //    * with zero rows
      // 2. test different methods
         for (taskkind = 0; taskkind <= 2; taskkind++) {
            testmatinvunit_cunset2d(&a);
            if (taskkind == 0) {
            // all zeros
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_i(0);
                  }
               }
            }
            if (taskkind == 1) {
            // there is zero column
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_d(randommid(), randommid());
                  }
               }
               k = randominteger(n);
               ae_v_cmuld(&a.xyC[0][k], a.stride, n, 0);
               ae_v_cmuld(a.xyC[k], 1, n, 0);
            }
            if (taskkind == 2) {
            // there is zero row
               ae_matrix_set_length(&a, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyC[i][j] = complex_from_d(randommid(), randommid());
                  }
               }
               k = randominteger(n);
               ae_v_cmuld(a.xyC[k], 1, n, 0);
               ae_v_cmuld(&a.xyC[0][k], a.stride, n, 0);
            }
            info = 0;
            testmatinvunit_unsetrep(&rep);
            hpdmatrixcholeskyinverse(&a, n, isupper, &info, &rep);
            if (info != -3 && info != 1) {
               *hpderrors = true;
            } else {
               *hpderrors = (*hpderrors || rep.r1 < 0.0) || rep.r1 > 1000 * machineepsilon;
               *hpderrors = (*hpderrors || rep.rinf < 0.0) || rep.rinf > 1000 * machineepsilon;
            }
         }
      }
   }
   ae_frame_leave();
}

// Test
bool testmatinv(bool silent) {
   ae_int_t maxrn;
   ae_int_t maxcn;
   ae_int_t largen;
   ae_int_t passcount;
   double threshold;
   bool rtrerrors;
   bool ctrerrors;
   bool rerrors;
   bool cerrors;
   bool spderrors;
   bool hpderrors;
   bool waserrors;
   bool result;
   maxrn = 3 * matrixtilesizea() + 1;
   maxcn = 3 * matrixtilesizea() + 1;
   largen = 4 * matrixtilesizeb() + 1;
   passcount = 1;
   threshold = 10000 * machineepsilon;
   rtrerrors = false;
   ctrerrors = false;
   rerrors = false;
   cerrors = false;
   spderrors = false;
   hpderrors = false;
   testmatinvunit_testrtrinv(1, maxrn, passcount, threshold, &rtrerrors);
   testmatinvunit_testctrinv(1, maxcn, passcount, threshold, &ctrerrors);
   testmatinvunit_testrinv(1, maxrn, passcount, threshold, &rerrors);
   testmatinvunit_testspdinv(1, maxrn, passcount, threshold, &spderrors);
   testmatinvunit_testcinv(1, maxcn, passcount, threshold, &cerrors);
   testmatinvunit_testhpdinv(1, maxcn, passcount, threshold, &hpderrors);
   testmatinvunit_testrtrinv(largen, largen, passcount, threshold, &rtrerrors);
   testmatinvunit_testctrinv(largen, largen, passcount, threshold, &ctrerrors);
   testmatinvunit_testrinv(largen, largen, passcount, threshold, &rerrors);
   testmatinvunit_testspdinv(largen, largen, passcount, threshold, &spderrors);
   testmatinvunit_testcinv(largen, largen, passcount, threshold, &cerrors);
   testmatinvunit_testhpdinv(largen, largen, passcount, threshold, &hpderrors);
   waserrors = ((((rtrerrors || ctrerrors) || rerrors) || cerrors) || spderrors) || hpderrors;
   if (!silent) {
      printf("TESTING MATINV\n");
      printf("* REAL TRIANGULAR:                        ");
      if (rtrerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* COMPLEX TRIANGULAR:                     ");
      if (ctrerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* REAL:                                   ");
      if (rerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* COMPLEX:                                ");
      if (cerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* SPD:                                    ");
      if (spderrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* HPD:                                    ");
      if (hpderrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
   }
   result = !waserrors;
   return result;
}

// === optserv testing unit ===
// This function checks preconditioning functions
//
// On failure sets error flag.
static void testoptservunit_testprec(bool *wereerrors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t k;
   ae_int_t i;
   ae_int_t j;
   ae_int_t i0;
   ae_int_t j0;
   ae_int_t j1;
   double v;
   double rho;
   double theta;
   double tolg;
   ae_frame_make(&_frame_block);
   NewMatrix(va, 0, 0, DT_REAL);
   NewVector(vc, 0, DT_REAL);
   NewVector(vd, 0, DT_REAL);
   NewVector(vb, 0, DT_REAL);
   NewVector(s0, 0, DT_REAL);
   NewVector(s1, 0, DT_REAL);
   NewVector(s2, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewObj(precbuflbfgs, buf);
   NewObj(precbuflowrank, lowrankbuf);
   NewVector(norms, 0, DT_REAL);
   NewMatrix(sk, 0, 0, DT_REAL);
   NewMatrix(yk, 0, 0, DT_REAL);
   NewMatrix(bk, 0, 0, DT_REAL);
   NewVector(bksk, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewObj(matinvreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Test for inexact L-BFGS preconditioner.
//
// We generate QP problem 0.5*x'*H*x, with random H=D+V'*C*V.
// Different K's, from 0 to N, are tried. We test preconditioner
// code which uses compact L-BFGS update against reference implementation
// which uses non-compact BFGS scheme.
//
// For each K we perform two tests: first for KxN non-zero matrix V,
// second one for NxN matrix V with last N-K rows set to zero. Last test
// checks algorithm's ability to handle zero updates.
   tolg = 1.0E-9;
   for (n = 1; n <= 10; n++) {
      for (k = 0; k <= n; k++) {
      // Prepare problem:
      // * VD, VC, VA, with VC/VA reordered by ascending of VC[i]*norm(VA[i,...])^2
      // * trial vector S (copies are stored to S0,S1,S2)
         ae_vector_set_length(&vd, n);
         ae_vector_set_length(&s0, n);
         ae_vector_set_length(&s1, n);
         ae_vector_set_length(&s2, n);
         for (i = 0; i < n; i++) {
            vd.xR[i] = exp(hqrndnormal(&rs));
            s0.xR[i] = hqrndnormal(&rs);
            s1.xR[i] = s0.xR[i];
            s2.xR[i] = s0.xR[i];
         }
         rmatrixrndcond(n, 1.0E2, &va);
         vectorsetlengthatleast(&vc, n);
         for (i = 0; i < k; i++) {
            vc.xR[i] = exp(hqrndnormal(&rs));
         }
         for (i = k; i < n; i++) {
            vc.xR[i] = 0.0;
            for (j = 0; j < n; j++) {
               va.xyR[i][j] = 0.0;
            }
         }
         ae_vector_set_length(&norms, k);
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(va.xyR[i], 1, va.xyR[i], 1, n);
            norms.xR[i] = v * vc.xR[i];
         }
         for (i = 0; i < k; i++) {
            for (j = 0; j < k - 1; j++) {
               if (norms.xR[j] > norms.xR[j + 1]) {
               // Swap elements J and J+1
                  v = norms.xR[j];
                  norms.xR[j] = norms.xR[j + 1];
                  norms.xR[j + 1] = v;
                  v = vc.xR[j];
                  vc.xR[j] = vc.xR[j + 1];
                  vc.xR[j + 1] = v;
                  for (j0 = 0; j0 < n; j0++) {
                     v = va.xyR[j][j0];
                     va.xyR[j][j0] = va.xyR[j + 1][j0];
                     va.xyR[j + 1][j0] = v;
                  }
               }
            }
         }
      // Generate reference model and apply it to S2:
      // * generate approximate Hessian Bk
      // * calculate inv(Bk)
      // * calculate inv(Bk)*S2, store to S2
         matrixsetlengthatleast(&sk, k, n);
         matrixsetlengthatleast(&yk, k, n);
         ae_matrix_set_length(&bk, n, n);
         ae_vector_set_length(&bksk, n);
         ae_vector_set_length(&tmp, n);
         for (i = 0; i < k; i++) {
            ae_v_move(sk.xyR[i], 1, va.xyR[i], 1, n);
            v = ae_v_dotproduct(va.xyR[i], 1, sk.xyR[i], 1, n);
            v *= vc.xR[i];
            for (j = 0; j < n; j++) {
               yk.xyR[i][j] = vd.xR[j] * sk.xyR[i][j] + va.xyR[i][j] * v;
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (i == j) {
                  bk.xyR[i][i] = vd.xR[i];
               } else {
                  bk.xyR[i][j] = 0.0;
               }
            }
         }
         for (i = 0; i < k; i++) {
            theta = 0.0;
            for (j0 = 0; j0 < n; j0++) {
               bksk.xR[j0] = 0.0;
               for (j1 = 0; j1 < n; j1++) {
                  theta += sk.xyR[i][j0] * bk.xyR[j0][j1] * sk.xyR[i][j1];
                  bksk.xR[j0] += bk.xyR[j0][j1] * sk.xyR[i][j1];
               }
            }
            theta = 1 / theta;
            rho = ae_v_dotproduct(sk.xyR[i], 1, yk.xyR[i], 1, n);
            rho = 1 / rho;
            for (j0 = 0; j0 < n; j0++) {
               for (j1 = 0; j1 < n; j1++) {
                  bk.xyR[j0][j1] += rho * yk.xyR[i][j0] * yk.xyR[i][j1];
               }
            }
            for (j0 = 0; j0 < n; j0++) {
               for (j1 = 0; j1 < n; j1++) {
                  bk.xyR[j0][j1] -= theta * bksk.xR[j0] * bksk.xR[j1];
               }
            }
         }
         rmatrixinverse(&bk, n, &j0, &rep);
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(bk.xyR[i], 1, s2.xR, 1, n);
            tmp.xR[i] = v;
         }
         for (i = 0; i < n; i++) {
            s2.xR[i] = tmp.xR[i];
         }
      // First test for non-zero V:
      // * apply preconditioner to X0
      // * compare reference model against implementation being tested
         inexactlbfgspreconditioner(&s0, n, &vd, &vc, &va, k, &buf);
         for (i = 0; i < n; i++) {
            set_error_flag(wereerrors, fabs(s2.xR[i] - s0.xR[i]) > tolg, __FILE__, __LINE__, "testoptservunit.ap:236");
         }
      // Second test - N-K zero rows appended to V and rows are
      // randomly reordered. Doing so should not change result,
      // algorithm must be able to order rows according to second derivative
      // and skip zero updates.
         for (i = 0; i < n; i++) {
            i0 = i + hqrnduniformi(&rs, n - i);
            v = vc.xR[i];
            vc.xR[i] = vc.xR[i0];
            vc.xR[i0] = v;
            for (j = 0; j < n; j++) {
               v = va.xyR[i][j];
               va.xyR[i][j] = va.xyR[i0][j];
               va.xyR[i0][j] = v;
            }
         }
         inexactlbfgspreconditioner(&s1, n, &vd, &vc, &va, n, &buf);
         for (i = 0; i < n; i++) {
            set_error_flag(wereerrors, fabs(s2.xR[i] - s1.xR[i]) > tolg, __FILE__, __LINE__, "testoptservunit.ap:259");
         }
      }
   }
// Test for exact low-rank preconditioner.
//
// We generate QP problem 0.5*x'*H*x, with random H=D+V'*C*V.
// Different K's, from 0 to N, are tried. We test preconditioner
// code which uses Woodbury update against reference implementation
// which performs straightforward matrix inversion.
//
// For each K we perform two tests: first for KxN non-zero matrix V,
// second one for NxN matrix V with randomly appended N-K zero rows.
// Last test checks algorithm's ability to handle zero updates.
   tolg = 1.0E-9;
   for (n = 1; n <= 10; n++) {
      for (k = 0; k <= n; k++) {
      // Prepare problem:
      // * VD, VC, VA
      // * trial vector S (copies are stored to S0,S1,S2)
         ae_vector_set_length(&vd, n);
         ae_vector_set_length(&s0, n);
         ae_vector_set_length(&s1, n);
         ae_vector_set_length(&s2, n);
         for (i = 0; i < n; i++) {
            vd.xR[i] = exp(hqrndnormal(&rs));
            s0.xR[i] = hqrndnormal(&rs);
            s1.xR[i] = s0.xR[i];
            s2.xR[i] = s0.xR[i];
         }
         rmatrixrndcond(n, 1.0E2, &va);
         vectorsetlengthatleast(&vc, n);
         for (i = 0; i < k; i++) {
            vc.xR[i] = exp(hqrndnormal(&rs));
         }
         for (i = k; i < n; i++) {
            vc.xR[i] = 0.0;
            for (j = 0; j < n; j++) {
               va.xyR[i][j] = 0.0;
            }
         }
      // Generate reference model and apply it to S2
         ae_matrix_set_length(&bk, n, n);
         ae_vector_set_length(&tmp, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (i == j) {
                  v = vd.xR[i];
               } else {
                  v = 0.0;
               }
               for (j1 = 0; j1 < k; j1++) {
                  v += va.xyR[j1][i] * vc.xR[j1] * va.xyR[j1][j];
               }
               bk.xyR[i][j] = v;
            }
         }
         rmatrixinverse(&bk, n, &j, &rep);
         ae_assert(j > 0, "Assertion failed");
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += bk.xyR[i][j] * s2.xR[j];
            }
            tmp.xR[i] = v;
         }
         for (i = 0; i < n; i++) {
            s2.xR[i] = tmp.xR[i];
         }
      // First test for non-zero V:
      // * apply preconditioner to X0
      // * compare reference model against implementation being tested
         preparelowrankpreconditioner(&vd, &vc, &va, n, k, &lowrankbuf);
         applylowrankpreconditioner(&s0, &lowrankbuf);
         for (i = 0; i < n; i++) {
            set_error_flag(wereerrors, fabs(s2.xR[i] - s0.xR[i]) > tolg, __FILE__, __LINE__, "testoptservunit.ap:341");
         }
      // Second test - N-K zero rows appended to V and rows are
      // randomly reordered. Doing so should not change result,
      // algorithm must be able to order rows according to second derivative
      // and skip zero updates.
         for (i = 0; i < n; i++) {
            i0 = i + hqrnduniformi(&rs, n - i);
            v = vc.xR[i];
            vc.xR[i] = vc.xR[i0];
            vc.xR[i0] = v;
            for (j = 0; j < n; j++) {
               v = va.xyR[i][j];
               va.xyR[i][j] = va.xyR[i0][j];
               va.xyR[i0][j] = v;
            }
         }
         preparelowrankpreconditioner(&vd, &vc, &va, n, n, &lowrankbuf);
         applylowrankpreconditioner(&s1, &lowrankbuf);
         for (i = 0; i < n; i++) {
            set_error_flag(wereerrors, fabs(s2.xR[i] - s1.xR[i]) > tolg, __FILE__, __LINE__, "testoptservunit.ap:365");
         }
      }
   }
   ae_frame_leave();
}

bool testoptserv(bool silent) {
   bool precerrors;
   bool wereerrors;
   bool result;
   precerrors = false;
   testoptservunit_testprec(&precerrors);
// report
   wereerrors = precerrors;
   if (!silent) {
      printf("TESTING OPTSERV\n");
      printf("TESTS:                                    \n");
      printf("* PRECONDITIONERS                         ");
      if (precerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (wereerrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !wereerrors;
   return result;
}

// === minlbfgs testing unit ===
static const ae_int_t testminlbfgsunit_maxoptguardlevel = 1;

// Calculate test function #2
//
// Simple variation of #1, much more nonlinear, which makes unlikely premature
// convergence of algorithm .
static void testminlbfgsunit_testfunc2(minlbfgsstate *state) {
   if (state->x.xR[0] < 100.0) {
      if (state->needf || state->needfg) {
         state->f = sqr(exp(state->x.xR[0]) - 2) + sqr(sqr(state->x.xR[1])) + sqr(state->x.xR[2] - state->x.xR[0]);
      }
      if (state->needfg) {
         state->g.xR[0] = 2 * (exp(state->x.xR[0]) - 2) * exp(state->x.xR[0]) + 2 * (state->x.xR[0] - state->x.xR[2]);
         state->g.xR[1] = 4 * state->x.xR[1] * sqr(state->x.xR[1]);
         state->g.xR[2] = 2 * (state->x.xR[2] - state->x.xR[0]);
      }
   } else {
      if (state->needf || state->needfg) {
         state->f = sqrt(maxrealnumber);
      }
      if (state->needfg) {
         state->g.xR[0] = sqrt(maxrealnumber);
         state->g.xR[1] = 0.0;
         state->g.xR[2] = 0.0;
      }
   }
}

// Calculate test function #3
//
// Simple variation of #1, much more nonlinear, with non-zero value at minimum.
// It achieve two goals:
// * makes unlikely premature convergence of algorithm .
// * solves some issues with EpsF stopping condition which arise when
//   F(minimum) is zero
//
static void testminlbfgsunit_testfunc3(minlbfgsstate *state) {
   double s;
   s = 0.001;
   if (state->x.xR[0] < 100.0) {
      if (state->needf || state->needfg) {
         state->f = sqr(exp(state->x.xR[0]) - 2) + sqr(sqr(state->x.xR[1]) + s) + sqr(state->x.xR[2] - state->x.xR[0]);
      }
      if (state->needfg) {
         state->g.xR[0] = 2 * (exp(state->x.xR[0]) - 2) * exp(state->x.xR[0]) + 2 * (state->x.xR[0] - state->x.xR[2]);
         state->g.xR[1] = 2 * (sqr(state->x.xR[1]) + s) * 2 * state->x.xR[1];
         state->g.xR[2] = 2 * (state->x.xR[2] - state->x.xR[0]);
      }
   } else {
      if (state->needf || state->needfg) {
         state->f = sqrt(maxrealnumber);
      }
      if (state->needfg) {
         state->g.xR[0] = sqrt(maxrealnumber);
         state->g.xR[1] = 0.0;
         state->g.xR[2] = 0.0;
      }
   }
}

// Calculate test function IIP2
//
// f(x) = sum( ((i*i+1)*x[i])^2, i=0..N-1)
//
// It has high condition number which makes fast convergence unlikely without
// good preconditioner.
//
static void testminlbfgsunit_calciip2(minlbfgsstate *state, ae_int_t n) {
   ae_int_t i;
   if (state->needf || state->needfg) {
      state->f = 0.0;
   }
   for (i = 0; i < n; i++) {
      if (state->needf || state->needfg) {
         state->f += sqr((double)(i * i + 1)) * sqr(state->x.xR[i]);
      }
      if (state->needfg) {
         state->g.xR[i] = sqr((double)(i * i + 1)) * 2 * state->x.xR[i];
      }
   }
}

// This function tests preconditioning
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testminlbfgsunit_testpreconditioning(bool *err) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t cntb1;
   ae_int_t cntb2;
   ae_int_t cntg1;
   ae_int_t cntg2;
   ae_int_t pkind;
   ae_frame_make(&_frame_block);
   NewObj(minlbfgsstate, state);
   NewObj(minlbfgsreport, rep);
   NewVector(x, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(diagh, 0, DT_REAL);
   m = 1;
   k = 50;
// Preconditioner test1.
//
// If
// * B1 is default preconditioner
// * B2 is Cholesky preconditioner with unit diagonal
// * G1 is Cholesky preconditioner based on exact Hessian with perturbations
// * G2 is diagonal precomditioner based on approximate diagonal of Hessian matrix
// then "bad" preconditioners (B1/B2/..) are worse than "good" ones (G1/G2/..).
// "Worse" means more iterations to converge.
//
// We test it using f(x) = sum( ((i*i+1)*x[i])^2, i=0..N-1) and L-BFGS
// optimizer with deliberately small M=1.
//
// N        - problem size
// PKind    - zero for upper triangular preconditioner, one for lower triangular.
// K        - number of repeated passes (should be large enough to average out random factors)
   for (n = 10; n <= 15; n++) {
      pkind = randominteger(2);
      ae_vector_set_length(&x, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 0.0;
      }
      minlbfgscreate(n, m, &x, &state);
   // Test it with default preconditioner
      minlbfgssetprecdefault(&state);
      cntb1 = 0;
      for (pass = 0; pass < k; pass++) {
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         minlbfgsrestartfrom(&state, &x);
         while (minlbfgsiteration(&state)) {
            testminlbfgsunit_calciip2(&state, n);
         }
         minlbfgsresults(&state, &x, &rep);
         cntb1 += rep.iterationscount;
         *err = *err || rep.terminationtype <= 0;
      }
   // Test it with unit preconditioner
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (i == j) {
               a.xyR[i][i] = 1.0;
            } else {
               a.xyR[i][j] = 0.0;
            }
         }
      }
      minlbfgssetpreccholesky(&state, &a, pkind == 0);
      cntb2 = 0;
      for (pass = 0; pass < k; pass++) {
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         minlbfgsrestartfrom(&state, &x);
         while (minlbfgsiteration(&state)) {
            testminlbfgsunit_calciip2(&state, n);
         }
         minlbfgsresults(&state, &x, &rep);
         cntb2 += rep.iterationscount;
         *err = *err || rep.terminationtype <= 0;
      }
   // Test it with perturbed Hessian preconditioner
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (i == j) {
               a.xyR[i][i] = (i * i + 1) * (0.8 + 0.4 * randomreal());
            } else {
               if ((pkind == 0 && j > i) || (pkind == 1 && j < i)) {
                  a.xyR[i][j] = 0.05 * randommid();
               } else {
                  a.xyR[i][j] = NAN;
               }
            }
         }
      }
      minlbfgssetpreccholesky(&state, &a, pkind == 0);
      cntg1 = 0;
      for (pass = 0; pass < k; pass++) {
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         minlbfgsrestartfrom(&state, &x);
         while (minlbfgsiteration(&state)) {
            testminlbfgsunit_calciip2(&state, n);
         }
         minlbfgsresults(&state, &x, &rep);
         cntg1 += rep.iterationscount;
         *err = *err || rep.terminationtype <= 0;
      }
   // Test it with perturbed diagonal preconditioner
      ae_vector_set_length(&diagh, n);
      for (i = 0; i < n; i++) {
         diagh.xR[i] = 2 * sqr((double)(i * i + 1)) * (0.8 + 0.4 * randomreal());
      }
      minlbfgssetprecdiag(&state, &diagh);
      cntg2 = 0;
      for (pass = 0; pass < k; pass++) {
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         minlbfgsrestartfrom(&state, &x);
         while (minlbfgsiteration(&state)) {
            testminlbfgsunit_calciip2(&state, n);
         }
         minlbfgsresults(&state, &x, &rep);
         cntg2 += rep.iterationscount;
         *err = *err || rep.terminationtype <= 0;
      }
   // Compare
      *err = *err || cntb1 < cntg1;
      *err = *err || cntb2 < cntg1;
      *err = *err || cntb1 < cntg2;
      *err = *err || cntb2 < cntg2;
   }
// Preconditioner test 2.
//
// If
// * B2 is default preconditioner with non-unit scale S[i]=1/sqrt(h[i])
// * G2 is scale-based preconditioner with non-unit scale S[i]=1/sqrt(h[i])
// then B2 is worse than G2.
// "Worse" means more iterations to converge.
   for (n = 10; n <= 15; n++) {
      ae_vector_set_length(&x, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 0.0;
      }
      minlbfgscreate(n, m, &x, &state);
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 1 / sqrt(2 * pow((double)(i * i + 1), 2.0) * (0.8 + 0.4 * randomreal()));
      }
      minlbfgssetprecdefault(&state);
      minlbfgssetscale(&state, &s);
      cntb2 = 0;
      for (pass = 0; pass < k; pass++) {
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         minlbfgsrestartfrom(&state, &x);
         while (minlbfgsiteration(&state)) {
            testminlbfgsunit_calciip2(&state, n);
         }
         minlbfgsresults(&state, &x, &rep);
         cntb2 += rep.iterationscount;
         *err = *err || rep.terminationtype <= 0;
      }
      minlbfgssetprecscale(&state);
      minlbfgssetscale(&state, &s);
      cntg2 = 0;
      for (pass = 0; pass < k; pass++) {
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         minlbfgsrestartfrom(&state, &x);
         while (minlbfgsiteration(&state)) {
            testminlbfgsunit_calciip2(&state, n);
         }
         minlbfgsresults(&state, &x, &rep);
         cntg2 += rep.iterationscount;
         *err = *err || rep.terminationtype <= 0;
      }
      *err = *err || cntb2 < cntg2;
   }
   ae_frame_leave();
}

// This function tests other properties
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testminlbfgsunit_testother(bool *err) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   bool hasxlast;
   double lastscaledstep;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double fprev;
   double xprev;
   double v;
   double stpmax;
   double tmpeps;
   double epsg;
   ae_int_t pkind;
   ae_int_t ckind;
   ae_int_t mkind;
   double vc;
   double vm;
   double diffstep;
   ae_int_t dkind;
   bool wasf;
   bool wasfg;
   double r;
   ae_int_t spoiliteration;
   ae_int_t stopiteration;
   ae_int_t spoilvar;
   double spoilval;
   double ss;
   bool terminationrequested;
   ae_int_t pass;
   ae_int_t stopcallidx;
   ae_int_t callidx;
   ae_int_t maxits;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(a, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(h, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewObj(minlbfgsstate, state);
   NewObj(minlbfgsreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Test reports (F should form monotone sequence)
   n = 50;
   m = 2;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&xlast, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = 1.0;
   }
   minlbfgscreate(n, m, &x, &state);
   minlbfgssetcond(&state, 0.0, 0.0, 0.0, 100);
   minlbfgssetxrep(&state, true);
   fprev = maxrealnumber;
   while (minlbfgsiteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += sqr((1 + i) * state.x.xR[i]);
            state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
         }
      }
      if (state.xupdated) {
         set_error_flag(err, state.f > fprev, __FILE__, __LINE__, "testminlbfgsunit.ap:758");
         if (fprev == maxrealnumber) {
            for (i = 0; i < n; i++) {
               set_error_flag(err, state.x.xR[i] != x.xR[i], __FILE__, __LINE__, "testminlbfgsunit.ap:761");
            }
         }
         fprev = state.f;
         ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
      }
   }
   minlbfgsresults(&state, &x, &rep);
   for (i = 0; i < n; i++) {
      set_error_flag(err, x.xR[i] != xlast.xR[i], __FILE__, __LINE__, "testminlbfgsunit.ap:768");
   }
// Test differentiation vs. analytic gradient
// (first one issues NeedF requests, second one issues NeedFG requests)
   n = 50;
   m = 5;
   diffstep = 1.0E-6;
   for (dkind = 0; dkind <= 1; dkind++) {
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 1.0;
      }
      if (dkind == 0) {
         minlbfgscreate(n, m, &x, &state);
      }
      if (dkind == 1) {
         minlbfgscreatef(n, m, &x, diffstep, &state);
      }
      minlbfgssetcond(&state, 0.0, 0.0, 0.0, n / 2);
      wasf = false;
      wasfg = false;
      while (minlbfgsiteration(&state)) {
         if (state.needf || state.needfg) {
            state.f = 0.0;
         }
         for (i = 0; i < n; i++) {
            if (state.needf || state.needfg) {
               state.f += sqr((1 + i) * state.x.xR[i]);
            }
            if (state.needfg) {
               state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
            }
         }
         wasf = wasf || state.needf;
         wasfg = wasfg || state.needfg;
      }
      minlbfgsresults(&state, &x, &rep);
      if (dkind == 0) {
         set_error_flag(err, wasf || !wasfg, __FILE__, __LINE__, "testminlbfgsunit.ap:806");
      }
      if (dkind == 1) {
         set_error_flag(err, !wasf || wasfg, __FILE__, __LINE__, "testminlbfgsunit.ap:808");
      }
   }
// Test that numerical differentiation uses scaling.
//
// In order to test that we solve simple optimization
// problem: min(x^2) with initial x equal to 0.0.
//
// We choose random DiffStep and S, then we check that
// optimizer evaluates function at +-DiffStep*S only.
   ae_vector_set_length(&x, 1);
   ae_vector_set_length(&s, 1);
   diffstep = randomreal() * 1.0E-6;
   s.xR[0] = exp(randomreal() * 4 - 2);
   x.xR[0] = 0.0;
   minlbfgscreatef(1, 1, &x, diffstep, &state);
   minlbfgssetcond(&state, 1.0E-6, 0.0, 0.0, 0);
   minlbfgssetscale(&state, &s);
   v = 0.0;
   while (minlbfgsiteration(&state)) {
      state.f = sqr(state.x.xR[0]);
      v = rmax2(v, fabs(state.x.xR[0]));
   }
   minlbfgsresults(&state, &x, &rep);
   r = v / (s.xR[0] * diffstep);
   set_error_flag(err, fabs(log(r)) > log(1 + 1000 * machineepsilon), __FILE__, __LINE__, "testminlbfgsunit.ap:836");
// test maximum step
   n = 1;
   m = 1;
   ae_vector_set_length(&x, n);
   x.xR[0] = 100.0;
   stpmax = 0.05 + 0.05 * randomreal();
   minlbfgscreate(n, m, &x, &state);
   minlbfgssetcond(&state, 1.0E-9, 0.0, 0.0, 0);
   minlbfgssetstpmax(&state, stpmax);
   minlbfgssetxrep(&state, true);
   xprev = x.xR[0];
   while (minlbfgsiteration(&state)) {
      if (state.needfg) {
         state.f = exp(state.x.xR[0]) + exp(-state.x.xR[0]);
         state.g.xR[0] = exp(state.x.xR[0]) - exp(-state.x.xR[0]);
         set_error_flag(err, fabs(state.x.xR[0] - xprev) > (1 + sqrt(machineepsilon)) * stpmax, __FILE__, __LINE__, "testminlbfgsunit.ap:858");
      }
      if (state.xupdated) {
         set_error_flag(err, fabs(state.x.xR[0] - xprev) > (1 + sqrt(machineepsilon)) * stpmax, __FILE__, __LINE__, "testminlbfgsunit.ap:862");
         xprev = state.x.xR[0];
      }
   }
// Test correctness of the scaling:
// * initial point is random point from [+1,+2]^N
// * f(x) = SUM(A[i]*x[i]^4), C[i] is random from [0.01,100]
// * we use random scaling matrix
// * we test different variants of the preconditioning:
//   0) unit preconditioner
//   1) random diagonal from [0.01,100]
//   2) scale preconditioner
// * we set stringent stopping conditions (we try EpsG and EpsX)
// * and we test that in the extremum stopping conditions are
//   satisfied subject to the current scaling coefficients.
   tmpeps = 1.0E-10;
   m = 1;
   for (n = 1; n <= 10; n++) {
      for (pkind = 0; pkind <= 2; pkind++) {
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xlast, n);
         ae_vector_set_length(&a, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&h, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = randomreal() + 1;
            a.xR[i] = exp(log(100.0) * randommid());
            s.xR[i] = exp(log(100.0) * randommid());
            h.xR[i] = exp(log(100.0) * randommid());
         }
         minlbfgscreate(n, m, &x, &state);
         minlbfgssetscale(&state, &s);
         minlbfgssetxrep(&state, true);
         if (pkind == 1) {
            minlbfgssetprecdiag(&state, &h);
         }
         if (pkind == 2) {
            minlbfgssetprecscale(&state);
         }
      // Test gradient-based stopping condition
         for (i = 0; i < n; i++) {
            x.xR[i] = randomreal() + 1;
         }
         minlbfgssetcond(&state, tmpeps, 0.0, 0.0, 0);
         minlbfgsrestartfrom(&state, &x);
         while (minlbfgsiteration(&state)) {
            if (state.needfg) {
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  state.f += a.xR[i] * pow(state.x.xR[i], 4.0);
                  state.g.xR[i] = 4 * a.xR[i] * pow(state.x.xR[i], 3.0);
               }
            }
         }
         minlbfgsresults(&state, &x, &rep);
         if (rep.terminationtype <= 0) {
            *err = true;
            ae_frame_leave();
            return;
         }
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += sqr(s.xR[i] * 4 * a.xR[i] * pow(x.xR[i], 3.0));
         }
         v = sqrt(v);
         *err = *err || v > tmpeps;
      // Test step-based stopping condition
         for (i = 0; i < n; i++) {
            x.xR[i] = randomreal() + 1;
         }
         hasxlast = false;
         lastscaledstep = maxrealnumber;
         minlbfgssetcond(&state, 0.0, 0.0, tmpeps, 0);
         minlbfgsrestartfrom(&state, &x);
         while (minlbfgsiteration(&state)) {
            if (state.needfg) {
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  state.f += a.xR[i] * pow(state.x.xR[i], 4.0);
                  state.g.xR[i] = 4 * a.xR[i] * pow(state.x.xR[i], 3.0);
               }
            }
            if (state.xupdated) {
               if (hasxlast) {
                  lastscaledstep = 0.0;
                  for (i = 0; i < n; i++) {
                     lastscaledstep += sqr(state.x.xR[i] - xlast.xR[i]) / sqr(s.xR[i]);
                  }
                  lastscaledstep = sqrt(lastscaledstep);
               } else {
                  lastscaledstep = 0.0;
               }
               ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
               hasxlast = true;
            }
         }
         minlbfgsresults(&state, &x, &rep);
         if (rep.terminationtype <= 0) {
            *err = true;
            ae_frame_leave();
            return;
         }
         *err = *err || lastscaledstep > tmpeps;
      }
   }
// Check correctness of the "trimming".
//
// Trimming is a technique which is used to help algorithm
// cope with unbounded functions. In order to check this
// technique we will try to solve following optimization
// problem:
//
//     min f(x) subject to no constraints on X
//            { 1/(1-x) + 1/(1+x) + c*x, if -0.999999<x<0.999999
//     f(x) = {
//            { M, if x <= -0.999999 or x >= 0.999999
//
// where c is either 1.0 or 1.0E+6, M is either 1.0E8, 1.0E20 or +INF
// (we try different combinations)
   for (ckind = 0; ckind <= 1; ckind++) {
      for (mkind = 0; mkind <= 2; mkind++) {
      // Choose c and M
         vc = 1.0;
         vm = 1.0;
         if (ckind == 0) {
            vc = 1.0;
         }
         if (ckind == 1) {
            vc = 1.0E+6;
         }
         if (mkind == 0) {
            vm = 1.0E+8;
         }
         if (mkind == 1) {
            vm = 1.0E+20;
         }
         if (mkind == 2) {
            vm = +INFINITY;
         }
      // Create optimizer, solve optimization problem
         epsg = 1.0E-6 * vc;
         ae_vector_set_length(&x, 1);
         x.xR[0] = 0.0;
         minlbfgscreate(1, 1, &x, &state);
         minlbfgssetcond(&state, epsg, 0.0, 0.0, 0);
         while (minlbfgsiteration(&state)) {
            if (state.needfg) {
               if (-0.999999 < state.x.xR[0] && state.x.xR[0] < 0.999999) {
                  state.f = 1 / (1 - state.x.xR[0]) + 1 / (1 + state.x.xR[0]) + vc * state.x.xR[0];
                  state.g.xR[0] = 1 / sqr(1 - state.x.xR[0]) - 1 / sqr(1 + state.x.xR[0]) + vc;
               } else {
                  state.f = vm;
               }
            }
         }
         minlbfgsresults(&state, &x, &rep);
         if (rep.terminationtype <= 0) {
            *err = true;
            ae_frame_leave();
            return;
         }
         *err = *err || fabs(1 / sqr(1 - x.xR[0]) - 1 / sqr(1 + x.xR[0]) + vc) > epsg;
      }
   }
// Test integrity checks for NAN/INF:
// * algorithm solves optimization problem, which is normal for some time (quadratic)
// * after 5-th step we choose random component of gradient and consistently spoil
//   it by NAN or INF.
// * we check that correct termination code is returned (-8)
   n = 100;
   for (pass = 1; pass <= 10; pass++) {
      spoiliteration = 5;
      stopiteration = 8;
      if (hqrndnormal(&rs) > 0.0) {
      // Gradient can be spoiled by +INF, -INF, NAN
         spoilvar = hqrnduniformi(&rs, n);
         i = hqrnduniformi(&rs, 3);
         spoilval = NAN;
         if (i == 0) {
            spoilval = -INFINITY;
         }
         if (i == 1) {
            spoilval = +INFINITY;
         }
      } else {
      // Function value can be spoiled only by NAN
      // (+INF can be recognized as legitimate value during optimization)
         spoilvar = -1;
         spoilval = NAN;
      }
      spdmatrixrndcond(n, 1.0E5, &fulla);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         b.xR[i] = hqrndnormal(&rs);
         x0.xR[i] = hqrndnormal(&rs);
      }
      minlbfgscreate(n, 1, &x0, &state);
      minlbfgssetcond(&state, 0.0, 0.0, 0.0, stopiteration);
      minlbfgssetxrep(&state, true);
      k = -1;
      while (minlbfgsiteration(&state)) {
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += b.xR[i] * state.x.xR[i];
               state.g.xR[i] = b.xR[i];
               for (j = 0; j < n; j++) {
                  state.f += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                  state.g.xR[i] += fulla.xyR[i][j] * state.x.xR[j];
               }
            }
            if (k >= spoiliteration) {
               if (spoilvar < 0) {
                  state.f = spoilval;
               } else {
                  state.g.xR[spoilvar] = spoilval;
               }
            }
            continue;
         }
         if (state.xupdated) {
            k++;
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minlbfgsresults(&state, &x1, &rep);
      set_error_flag(err, rep.terminationtype != -8, __FILE__, __LINE__, "testminlbfgsunit.ap:1123");
   }
// Check algorithm ability to handle request for termination:
// * to terminate with correct return code = 8
// * to return point which was "current" at the moment of termination
   for (pass = 1; pass <= 50; pass++) {
      n = 3;
      ss = 100.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 6 + randomreal();
      }
      stopcallidx = randominteger(20);
      maxits = 25;
      minlbfgscreate(n, 1, &x, &state);
      minlbfgssetcond(&state, 0.0, 0.0, 0.0, maxits);
      minlbfgssetxrep(&state, true);
      callidx = 0;
      terminationrequested = false;
      ae_v_move(xlast.xR, 1, x.xR, 1, n);
      while (minlbfgsiteration(&state)) {
         if (state.needfg) {
            state.f = ss * sqr(exp(state.x.xR[0]) - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
            state.g.xR[0] = 2 * ss * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[2] - state.x.xR[0]) * (-1);
            state.g.xR[1] = 2 * state.x.xR[1];
            state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
            if (callidx == stopcallidx) {
               minlbfgsrequesttermination(&state);
               terminationrequested = true;
            }
            callidx++;
            continue;
         }
         if (state.xupdated) {
            if (!terminationrequested) {
               ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minlbfgsresults(&state, &x, &rep);
      set_error_flag(err, rep.terminationtype != 8, __FILE__, __LINE__, "testminlbfgsunit.ap:1173");
      for (i = 0; i < n; i++) {
         set_error_flag(err, x.xR[i] != xlast.xR[i], __FILE__, __LINE__, "testminlbfgsunit.ap:1175");
      }
   }
   ae_frame_leave();
}

// This function tests report of "non-C1" test #0 for task #0
// given by matrix A.
//
// On failure sets error flag.
static void testminlbfgsunit_testoptguardc1test0reportfortask0(bool *err, optguardnonc1test0report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool hasc1discontinuities;
   if (rep->positive) {
   // Check positive report, first checks
      set_error_flag(err, rep->fidx != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1743");
      set_error_flag(err, rep->n != n, __FILE__, __LINE__, "testminlbfgsunit.ap:1744");
      set_error_flag(err, !(0 <= rep->stpidxa), __FILE__, __LINE__, "testminlbfgsunit.ap:1745");
      set_error_flag(err, !(rep->stpidxa < rep->stpidxb), __FILE__, __LINE__, "testminlbfgsunit.ap:1746");
      set_error_flag(err, !(rep->stpidxb < rep->cnt), __FILE__, __LINE__, "testminlbfgsunit.ap:1747");
      set_error_flag(err, rep->x0.cnt != rep->n, __FILE__, __LINE__, "testminlbfgsunit.ap:1748");
      set_error_flag(err, rep->d.cnt != rep->n, __FILE__, __LINE__, "testminlbfgsunit.ap:1749");
      set_error_flag(err, rep->stp.cnt != rep->cnt, __FILE__, __LINE__, "testminlbfgsunit.ap:1750");
      set_error_flag(err, rep->f.cnt != rep->cnt, __FILE__, __LINE__, "testminlbfgsunit.ap:1751");
      set_error_flag(err, !isfinitevector(&rep->x0, n), __FILE__, __LINE__, "testminlbfgsunit.ap:1752");
      set_error_flag(err, !isfinitevector(&rep->d, n), __FILE__, __LINE__, "testminlbfgsunit.ap:1753");
      set_error_flag(err, !isfinitevector(&rep->stp, rep->cnt), __FILE__, __LINE__, "testminlbfgsunit.ap:1754");
      set_error_flag(err, !isfinitevector(&rep->f, rep->cnt), __FILE__, __LINE__, "testminlbfgsunit.ap:1755");
      if (*err) {
         return;
      }
   // Check consistency of X0, D, Stp and F
      for (k = 0; k < rep->cnt - 1; k++) {
         set_error_flag(err, rep->stp.xR[k] >= rep->stp.xR[k + 1], __FILE__, __LINE__, "testminlbfgsunit.ap:1763");
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += fabs(vv);
         }
         set_error_flag(err, fabs(v - rep->f.xR[k]) > 1.0E-6 * rmax2(fabs(v), 1.0), __FILE__, __LINE__, "testminlbfgsunit.ap:1776");
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      set_error_flag(err, !hasc1discontinuities, __FILE__, __LINE__, "testminlbfgsunit.ap:1794");
   } else {
   // Check negative report: fields must be empty
      set_error_flag(err, rep->stpidxa != -1, __FILE__, __LINE__, "testminlbfgsunit.ap:1801");
      set_error_flag(err, rep->stpidxb != -1, __FILE__, __LINE__, "testminlbfgsunit.ap:1802");
      set_error_flag(err, rep->fidx != -1, __FILE__, __LINE__, "testminlbfgsunit.ap:1803");
      set_error_flag(err, rep->cnt != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1804");
      set_error_flag(err, rep->n != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1805");
      set_error_flag(err, rep->x0.cnt != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1806");
      set_error_flag(err, rep->d.cnt != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1807");
      set_error_flag(err, rep->stp.cnt != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1808");
      set_error_flag(err, rep->f.cnt != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1809");
   }
}

// This function tests report of "non-C1" test #1 for task #0
// given by matrix A.
//
// On failure sets error flag.
static void testminlbfgsunit_testoptguardc1test1reportfortask0(bool *err, optguardnonc1test1report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool tooclose;
   bool hasc1discontinuities;
   if (rep->positive) {
   // Check positive report, first checks
      set_error_flag(err, rep->fidx != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1837");
      set_error_flag(err, rep->vidx < 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1838");
      set_error_flag(err, rep->vidx > n, __FILE__, __LINE__, "testminlbfgsunit.ap:1839");
      set_error_flag(err, rep->n != n, __FILE__, __LINE__, "testminlbfgsunit.ap:1840");
      set_error_flag(err, !(0 <= rep->stpidxa), __FILE__, __LINE__, "testminlbfgsunit.ap:1841");
      set_error_flag(err, !(rep->stpidxa < rep->stpidxb), __FILE__, __LINE__, "testminlbfgsunit.ap:1842");
      set_error_flag(err, !(rep->stpidxb < rep->cnt), __FILE__, __LINE__, "testminlbfgsunit.ap:1843");
      set_error_flag(err, rep->x0.cnt != rep->n, __FILE__, __LINE__, "testminlbfgsunit.ap:1844");
      set_error_flag(err, rep->d.cnt != rep->n, __FILE__, __LINE__, "testminlbfgsunit.ap:1845");
      set_error_flag(err, rep->stp.cnt != rep->cnt, __FILE__, __LINE__, "testminlbfgsunit.ap:1846");
      set_error_flag(err, rep->g.cnt != rep->cnt, __FILE__, __LINE__, "testminlbfgsunit.ap:1847");
      set_error_flag(err, !isfinitevector(&rep->x0, n), __FILE__, __LINE__, "testminlbfgsunit.ap:1848");
      set_error_flag(err, !isfinitevector(&rep->d, n), __FILE__, __LINE__, "testminlbfgsunit.ap:1849");
      set_error_flag(err, !isfinitevector(&rep->stp, rep->cnt), __FILE__, __LINE__, "testminlbfgsunit.ap:1850");
      set_error_flag(err, !isfinitevector(&rep->g, rep->cnt), __FILE__, __LINE__, "testminlbfgsunit.ap:1851");
      if (*err) {
         return;
      }
   // Check consistency of X0, D, Stp and G
      for (k = 0; k < rep->cnt - 1; k++) {
         set_error_flag(err, rep->stp.xR[k] >= rep->stp.xR[k + 1], __FILE__, __LINE__, "testminlbfgsunit.ap:1859");
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         tooclose = false;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += sign(vv) * a->xyR[i][rep->vidx];
            tooclose = tooclose || fabs(vv) < 1.0E-4;
         }
         if (!tooclose) {
            set_error_flag(err, fabs(v - rep->g.xR[k]) > 1.0E-6 * rmax2(fabs(v), 1.0), __FILE__, __LINE__, "testminlbfgsunit.ap:1873");
         }
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      tooclose = false;
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         tooclose = (tooclose || fabs(va) < 1.0E-8) || fabs(vb) < 1.0E-8;
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      if (!tooclose) {
         set_error_flag(err, !hasc1discontinuities, __FILE__, __LINE__, "testminlbfgsunit.ap:1894");
      }
   } else {
   // Check negative report: fields must be empty
      set_error_flag(err, rep->stpidxa != -1, __FILE__, __LINE__, "testminlbfgsunit.ap:1901");
      set_error_flag(err, rep->stpidxb != -1, __FILE__, __LINE__, "testminlbfgsunit.ap:1902");
      set_error_flag(err, rep->fidx != -1, __FILE__, __LINE__, "testminlbfgsunit.ap:1903");
      set_error_flag(err, rep->vidx != -1, __FILE__, __LINE__, "testminlbfgsunit.ap:1904");
      set_error_flag(err, rep->cnt != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1905");
      set_error_flag(err, rep->n != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1906");
      set_error_flag(err, rep->x0.cnt != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1907");
      set_error_flag(err, rep->d.cnt != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1908");
      set_error_flag(err, rep->stp.cnt != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1909");
      set_error_flag(err, rep->g.cnt != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1910");
   }
}

// This function tests OptGuard
//
// On failure sets error flag.
static void testminlbfgsunit_testoptguard(bool *wereerrors) {
   ae_frame _frame_block;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t m;
   double diffstep;
   ae_int_t pass;
   ae_int_t defecttype;
   bool failed;
   ae_int_t passcount;
   ae_int_t maxfails;
   ae_int_t failurecounter;
   ae_int_t maxc1test0fails;
   ae_int_t maxc1test1fails;
   ae_int_t c1test0fails;
   ae_int_t c1test1fails;
   double avgstr0len;
   double avglng0len;
   double avgstr1len;
   double avglng1len;
   ae_int_t varidx;
   ae_int_t skind;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minlbfgsstate, state);
   NewObj(minlbfgsreport, rep);
   NewObj(optguardreport, ogrep);
   NewObj(optguardnonc1test0report, ognonc1test0strrep);
   NewObj(optguardnonc1test0report, ognonc1test0lngrep);
   NewObj(optguardnonc1test1report, ognonc1test1strrep);
   NewObj(optguardnonc1test1report, ognonc1test1lngrep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewMatrix(jactrue, 0, 0, DT_REAL);
   NewMatrix(jacdefect, 0, 0, DT_REAL);
   hqrndrandomize(&rs);
// Check that gradient verification is disabled by default:
// gradient checking for bad problem must return nothing
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = 1.0 + 0.1 * i;
   }
   spdmatrixrndcond(n, 1.0E3, &a);
   spdmatrixrndcond(n, 1.0E3, &a1);
   minlbfgscreate(n, 3, &x0, &state);
   minlbfgssetcond(&state, 0.0, 0.0, 1.0E-9, 10);
   while (minlbfgsiteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += 0.5 * state.x.xR[i] * v;
         }
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   minlbfgsresults(&state, &x1, &rep);
   minlbfgsoptguardresults(&state, &ogrep);
   set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1248");
   set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminlbfgsunit.ap:1249");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(wereerrors, ogrep.badgradxbase.cnt != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1252");
   set_error_flag(wereerrors, ogrep.badgraduser.rows != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1253");
   set_error_flag(wereerrors, ogrep.badgraduser.cols != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1254");
   set_error_flag(wereerrors, ogrep.badgradnum.rows != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1255");
   set_error_flag(wereerrors, ogrep.badgradnum.cols != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1256");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(wereerrors, ogrep.badgradsuspected, __FILE__, __LINE__, "testminlbfgsunit.ap:1259");
   set_error_flag(wereerrors, ogrep.badgradfidx != -1, __FILE__, __LINE__, "testminlbfgsunit.ap:1260");
   set_error_flag(wereerrors, ogrep.badgradvidx != -1, __FILE__, __LINE__, "testminlbfgsunit.ap:1261");
// Test that C0/C1 continuity monitoring is disabled by default;
// we solve nonsmooth problem and test that nothing is returned
// by OptGuard.
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = hqrndnormal(&rs);
   }
   ae_matrix_set_length(&a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a.xyR[i][j] = hqrndnormal(&rs);
      }
   }
   minlbfgscreate(n, 2, &x0, &state);
   minlbfgssetcond(&state, 0.0, 0.0, 1.0E-9, 50);
   while (minlbfgsiteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += fabs(v);
            v = (double)sign(v);
            for (j = 0; j < n; j++) {
               state.g.xR[j] += v * a.xyR[i][j];
            }
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   minlbfgsresults(&state, &x1, &rep);
   minlbfgsoptguardresults(&state, &ogrep);
   set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminlbfgsunit.ap:1301");
   set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1302");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testminlbfgsunit.ap:1305");
   set_error_flag(wereerrors, ogrep.nonc1suspected, __FILE__, __LINE__, "testminlbfgsunit.ap:1306");
   set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminlbfgsunit.ap:1307");
   set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1308");
   set_error_flag(wereerrors, ogrep.nonc1fidx >= 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1309");
   set_error_flag(wereerrors, ogrep.nonc1test0positive, __FILE__, __LINE__, "testminlbfgsunit.ap:1310");
   set_error_flag(wereerrors, ogrep.nonc1test1positive, __FILE__, __LINE__, "testminlbfgsunit.ap:1311");
// Test gradient checking functionality, try various
// defect types:
// * accidental zeroing of some gradient component
// * accidental addition of 1.0 to some component
// * accidental multiplication by 2.0
// Try distorting both target and constraints.
   diffstep = 0.001;
   n = 10;
   m = 2;
   for (skind = 0; skind <= 1; skind++) {
      for (defecttype = -1; defecttype <= 2; defecttype++) {
         varidx = hqrnduniformi(&rs, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, skind * (30 * hqrnduniformr(&rs) - 15));
            x0.xR[i] = (1.0 + 0.1 * i) * s.xR[i];
         }
         spdmatrixrndcond(n, 1.0E3, &a);
         spdmatrixrndcond(n, 1.0E3, &a1);
         minlbfgscreate(n, m, &x0, &state);
         minlbfgsoptguardgradient(&state, diffstep);
         minlbfgssetcond(&state, 0.0, 0.0, 1.0E-9, 10);
         minlbfgssetscale(&state, &s);
         while (minlbfgsiteration(&state)) {
            if (state.needfg) {
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += state.x.xR[j] / s.xR[j] * a.xyR[i][j];
                  }
                  state.f += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                  state.g.xR[i] = v;
               }
               if (defecttype == 0) {
                  state.g.xR[varidx] = 0.0;
               }
               if (defecttype == 1) {
                  state.g.xR[varidx]++;
               }
               if (defecttype == 2) {
                  state.g.xR[varidx] *= 2;
               }
               for (i = 0; i < n; i++) {
                  state.g.xR[i] /= s.xR[i];
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minlbfgsresults(&state, &x1, &rep);
         minlbfgsoptguardresults(&state, &ogrep);
      // Check that something is returned
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1377");
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminlbfgsunit.ap:1378");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Compute reference values for true and spoiled Jacobian at X0
         set_error_flag(wereerrors, !isfinitevector(&ogrep.badgradxbase, n), __FILE__, __LINE__, "testminlbfgsunit.ap:1385");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         ae_matrix_set_length(&jactrue, 1, n);
         ae_matrix_set_length(&jacdefect, 1, n);
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += ogrep.badgradxbase.xR[j] / s.xR[j] * a.xyR[i][j];
            }
            jactrue.xyR[0][i] = v;
            jacdefect.xyR[0][i] = v;
         }
         if (defecttype == 0) {
            jacdefect.xyR[0][varidx] = 0.0;
         }
         if (defecttype == 1) {
            jacdefect.xyR[0][varidx]++;
         }
         if (defecttype == 2) {
            jacdefect.xyR[0][varidx] *= 2;
         }
         for (i = 0; i < n; i++) {
            jactrue.xyR[0][i] /= s.xR[i];
            jacdefect.xyR[0][i] /= s.xR[i];
         }
      // Check OptGuard report
         set_error_flag(wereerrors, !apservisfinitematrix(&ogrep.badgraduser, 1, n), __FILE__, __LINE__, "testminlbfgsunit.ap:1413");
         set_error_flag(wereerrors, !apservisfinitematrix(&ogrep.badgradnum, 1, n), __FILE__, __LINE__, "testminlbfgsunit.ap:1414");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         if (defecttype >= 0) {
            set_error_flag(wereerrors, !ogrep.badgradsuspected, __FILE__, __LINE__, "testminlbfgsunit.ap:1419");
            set_error_flag(wereerrors, ogrep.badgradfidx != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1420");
            set_error_flag(wereerrors, ogrep.badgradvidx != varidx, __FILE__, __LINE__, "testminlbfgsunit.ap:1421");
         } else {
            set_error_flag(wereerrors, ogrep.badgradsuspected, __FILE__, __LINE__, "testminlbfgsunit.ap:1425");
            set_error_flag(wereerrors, ogrep.badgradfidx != -1, __FILE__, __LINE__, "testminlbfgsunit.ap:1426");
            set_error_flag(wereerrors, ogrep.badgradvidx != -1, __FILE__, __LINE__, "testminlbfgsunit.ap:1427");
         }
         for (j = 0; j < n; j++) {
            set_error_flag(wereerrors, fabs(jactrue.xyR[0][j] - ogrep.badgradnum.xyR[0][j]) > 0.01 / s.xR[j], __FILE__, __LINE__, "testminlbfgsunit.ap:1431");
            set_error_flag(wereerrors, fabs(jacdefect.xyR[0][j] - ogrep.badgraduser.xyR[0][j]) > 0.01 / s.xR[j], __FILE__, __LINE__, "testminlbfgsunit.ap:1432");
         }
      }
   }
// A test for detection of C1 continuity violations in the target.
//
// Target function is a sum of |(x,c_i)| for i=1..N.
// No constraints is present.
// Analytic gradient is provided.
//
// OptGuard should be able to detect violations in more than
// 85% of runs; it means that 100 runs should have no more than 15
// failures in all cases.
//
// We select some N and perform exhaustive search for this N.
   passcount = 100;
   maxfails = 15;
   maxc1test0fails = 15;
   maxc1test1fails = 15;
   n = 1 + hqrnduniformi(&rs, 10);
   m = 1 + hqrnduniformi(&rs, n);
   failurecounter = 0;
   c1test0fails = 0;
   c1test1fails = 0;
   avgstr0len = 0.0;
   avglng0len = 0.0;
   avgstr1len = 0.0;
   avglng1len = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = pow(2.0, hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      minlbfgscreate(n, m, &x0, &state);
      minlbfgssetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      minlbfgssetscale(&state, &s);
      minlbfgsoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminlbfgsunit_maxoptguardlevel));
      while (minlbfgsiteration(&state)) {
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.g.xR[i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
               v = (double)sign(v);
               for (j = 0; j < n; j++) {
                  state.g.xR[j] += v * a.xyR[i][j];
               }
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minlbfgsresults(&state, &x1, &rep);
      minlbfgsoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminlbfgsunit.ap:1513");
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1514");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
   // Check generic OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testminlbfgsunit.ap:1525");
      set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1526");
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   // Check C1 continuity test #0
      minlbfgsoptguardnonc1test0results(&state, &ognonc1test0strrep, &ognonc1test0lngrep);
      minlbfgsoptguardnonc1test1results(&state, &ognonc1test1strrep, &ognonc1test1lngrep);
      if (ogrep.nonc1test0positive) {
         set_error_flag(wereerrors, !ogrep.nonc1suspected, __FILE__, __LINE__, "testminlbfgsunit.ap:1541");
         set_error_flag(wereerrors, !ognonc1test0strrep.positive, __FILE__, __LINE__, "testminlbfgsunit.ap:1542");
         set_error_flag(wereerrors, !ognonc1test0lngrep.positive, __FILE__, __LINE__, "testminlbfgsunit.ap:1543");
         set_error_flag(wereerrors, ogrep.nonc1fidx != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1544");
         testminlbfgsunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0strrep, &a, n);
         testminlbfgsunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0lngrep, &a, n);
         avgstr0len += (double)ognonc1test0strrep.cnt / passcount;
         avglng0len += (double)ognonc1test0lngrep.cnt / passcount;
      } else {
         set_error_flag(wereerrors, ognonc1test0strrep.positive, __FILE__, __LINE__, "testminlbfgsunit.ap:1552");
         set_error_flag(wereerrors, ognonc1test0lngrep.positive, __FILE__, __LINE__, "testminlbfgsunit.ap:1553");
         testminlbfgsunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0strrep, &a, n);
         testminlbfgsunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0lngrep, &a, n);
         c1test0fails++;
      }
      if (ogrep.nonc1test1positive) {
         set_error_flag(wereerrors, !ogrep.nonc1suspected, __FILE__, __LINE__, "testminlbfgsunit.ap:1560");
         set_error_flag(wereerrors, !ognonc1test1strrep.positive, __FILE__, __LINE__, "testminlbfgsunit.ap:1561");
         set_error_flag(wereerrors, !ognonc1test1lngrep.positive, __FILE__, __LINE__, "testminlbfgsunit.ap:1562");
         set_error_flag(wereerrors, ogrep.nonc1fidx != 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1563");
         testminlbfgsunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1strrep, &a, n);
         testminlbfgsunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1lngrep, &a, n);
         avgstr1len += (double)ognonc1test1strrep.cnt / passcount;
         avglng1len += (double)ognonc1test1lngrep.cnt / passcount;
      } else {
         set_error_flag(wereerrors, ognonc1test1strrep.positive, __FILE__, __LINE__, "testminlbfgsunit.ap:1571");
         set_error_flag(wereerrors, ognonc1test1lngrep.positive, __FILE__, __LINE__, "testminlbfgsunit.ap:1572");
         testminlbfgsunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1strrep, &a, n);
         testminlbfgsunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1lngrep, &a, n);
         c1test1fails++;
      }
   }
   set_error_flag(wereerrors, failurecounter > maxfails, __FILE__, __LINE__, "testminlbfgsunit.ap:1579");
   set_error_flag(wereerrors, c1test0fails > maxc1test0fails, __FILE__, __LINE__, "testminlbfgsunit.ap:1580");
   set_error_flag(wereerrors, c1test1fails > maxc1test1fails, __FILE__, __LINE__, "testminlbfgsunit.ap:1581");
   set_error_flag(wereerrors, avglng0len <= avgstr0len, __FILE__, __LINE__, "testminlbfgsunit.ap:1582");
   set_error_flag(wereerrors, avglng1len <= avgstr1len, __FILE__, __LINE__, "testminlbfgsunit.ap:1583");
// Detection of C1 continuity violations in the target under numerical differentiation:
// * target function is a sum of |(x,c_i)| for i=1..N.
// * no constraints is present.
// * analytic gradient is provided.
//
// OptGuard should always be able to detect violations in more than
// 85% of runs.
//
// We select some N and perform exhaustive search for this N.
   diffstep = 0.0001;
   passcount = 100;
   maxfails = 15;
   n = 1 + hqrnduniformi(&rs, 10);
   m = 1 + hqrnduniformi(&rs, n);
   failurecounter = 0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 0.01 * pow(2.0, 0.33 * hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      minlbfgscreatef(n, m, &x0, diffstep, &state);
      minlbfgssetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      minlbfgsoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminlbfgsunit_maxoptguardlevel));
      while (minlbfgsiteration(&state)) {
         if (state.needf) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minlbfgsresults(&state, &x1, &rep);
      minlbfgsoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminlbfgsunit.ap:1646");
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1647");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
   // Check OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testminlbfgsunit.ap:1658");
      set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1659");
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   }
   set_error_flag(wereerrors, failurecounter > maxfails, __FILE__, __LINE__, "testminlbfgsunit.ap:1667");
// Make sure than no false positives are reported for larger
// problems where numerical noise can be an issue:
// * N=100 dimensions
// * positive-definite quadratic programming problem
// * upper limit on iterations count, MaxIts=25
// We simply test that OptGuard does not return error code.
   n = 100;
   m = 5;
   spdmatrixrndcond(n, 1.0E2, &a);
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = hqrndnormal(&rs);
      x0.xR[i] = pow(2.0, hqrndnormal(&rs));
   }
   minlbfgscreate(n, m, &x0, &state);
   minlbfgsoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminlbfgsunit_maxoptguardlevel));
   minlbfgssetcond(&state, 0.0, 0.0, 1.0E-9, 25);
   while (minlbfgsiteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += b.xR[i] * state.x.xR[i];
            state.g.xR[i] = b.xR[i];
            for (j = 0; j < n; j++) {
               state.f += 0.5 * state.x.xR[i] * a.xyR[i][j] * state.x.xR[j];
               state.g.xR[i] += a.xyR[i][j] * state.x.xR[j];
            }
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   minlbfgsresults(&state, &x1, &rep);
   set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminlbfgsunit.ap:1711");
   set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlbfgsunit.ap:1712");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   minlbfgsoptguardresults(&state, &ogrep);
   set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminlbfgsunit.ap:1716");
   ae_frame_leave();
}

bool testminlbfgs(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   bool referror;
   bool nonconverror;
   bool eqerror;
   bool converror;
   bool crashtest;
   bool othererrors;
   bool restartserror;
   bool precerror;
   bool optguarderr;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_int_t maxits;
   double diffstep;
   ae_int_t dkind;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(diagh, 0, DT_REAL);
   NewObj(minlbfgsstate, state);
   NewObj(minlbfgsreport, rep);
   waserrors = false;
   referror = false;
   precerror = false;
   nonconverror = false;
   restartserror = false;
   eqerror = false;
   converror = false;
   crashtest = false;
   othererrors = false;
   testminlbfgsunit_testpreconditioning(&precerror);
   testminlbfgsunit_testother(&othererrors);
// Reference problem
   diffstep = 1.0E-6;
   for (dkind = 0; dkind <= 1; dkind++) {
      ae_vector_set_length(&x, 3);
      n = 3;
      m = 2;
      x.xR[0] = 50.0 * randommid();
      x.xR[1] = 50.0 * randommid();
      x.xR[2] = 50.0 * randommid();
      if (dkind == 0) {
         minlbfgscreate(n, m, &x, &state);
      }
      if (dkind == 1) {
         minlbfgscreatef(n, m, &x, diffstep, &state);
      }
      minlbfgssetcond(&state, 0.0, 0.0, 0.0, 0);
      while (minlbfgsiteration(&state)) {
         if (state.needf || state.needfg) {
            state.f = sqr(state.x.xR[0] - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
         }
         if (state.needfg) {
            state.g.xR[0] = 2 * (state.x.xR[0] - 2) + 2 * (state.x.xR[0] - state.x.xR[2]);
            state.g.xR[1] = 2 * state.x.xR[1];
            state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
         }
      }
      minlbfgsresults(&state, &x, &rep);
      referror = (((referror || rep.terminationtype <= 0) || fabs(x.xR[0] - 2) > 0.001) || fabs(x.xR[1]) > 0.001) || fabs(x.xR[2] - 2) > 0.001;
   }
// nonconvex problems with complex surface: we start from point with very small
// gradient, but we need ever smaller gradient in the next step due to
// Wolfe conditions.
   diffstep = 1.0E-6;
   for (dkind = 0; dkind <= 1; dkind++) {
      ae_vector_set_length(&x, 1);
      n = 1;
      m = 1;
      v = -100.0;
      while (v < 0.1) {
         x.xR[0] = v;
         if (dkind == 0) {
            minlbfgscreate(n, m, &x, &state);
         }
         if (dkind == 1) {
            minlbfgscreatef(n, m, &x, diffstep, &state);
         }
         minlbfgssetcond(&state, 1.0E-9, 0.0, 0.0, 0);
         while (minlbfgsiteration(&state)) {
            if (state.needf || state.needfg) {
               state.f = sqr(state.x.xR[0]) / (1 + sqr(state.x.xR[0]));
            }
            if (state.needfg) {
               state.g.xR[0] = (2 * state.x.xR[0] * (1 + sqr(state.x.xR[0])) - sqr(state.x.xR[0]) * 2 * state.x.xR[0]) / sqr(1 + sqr(state.x.xR[0]));
            }
         }
         minlbfgsresults(&state, &x, &rep);
         nonconverror = (nonconverror || rep.terminationtype <= 0) || fabs(x.xR[0]) > 0.001;
         v += 0.1;
      }
   }
// F2 problem with restarts:
// * make several iterations and restart BEFORE termination
// * iterate and restart AFTER termination
//
// NOTE: step is bounded from above to avoid premature convergence
   diffstep = 1.0E-6;
   for (dkind = 0; dkind <= 1; dkind++) {
      ae_vector_set_length(&x, 3);
      n = 3;
      m = 2;
      x.xR[0] = 10 + 10 * randomreal();
      x.xR[1] = 10 + 10 * randomreal();
      x.xR[2] = 10 + 10 * randomreal();
      if (dkind == 0) {
         minlbfgscreate(n, m, &x, &state);
      }
      if (dkind == 1) {
         minlbfgscreatef(n, m, &x, diffstep, &state);
      }
      minlbfgssetstpmax(&state, 0.1);
      minlbfgssetcond(&state, 0.0000001, 0.0, 0.0, 0);
      for (i = 0; i <= 10; i++) {
         if (!minlbfgsiteration(&state)) {
            break;
         }
         testminlbfgsunit_testfunc2(&state);
      }
      x.xR[0] = 10 + 10 * randomreal();
      x.xR[1] = 10 + 10 * randomreal();
      x.xR[2] = 10 + 10 * randomreal();
      minlbfgsrestartfrom(&state, &x);
      while (minlbfgsiteration(&state)) {
         testminlbfgsunit_testfunc2(&state);
      }
      minlbfgsresults(&state, &x, &rep);
      restartserror = (((restartserror || rep.terminationtype <= 0) || fabs(x.xR[0] - log(2.0)) > 0.01) || fabs(x.xR[1]) > 0.01) || fabs(x.xR[2] - log(2.0)) > 0.01;
      x.xR[0] = 10 + 10 * randomreal();
      x.xR[1] = 10 + 10 * randomreal();
      x.xR[2] = 10 + 10 * randomreal();
      minlbfgsrestartfrom(&state, &x);
      while (minlbfgsiteration(&state)) {
         testminlbfgsunit_testfunc2(&state);
      }
      minlbfgsresults(&state, &x, &rep);
      restartserror = (((restartserror || rep.terminationtype <= 0) || fabs(x.xR[0] - log(2.0)) > 0.01) || fabs(x.xR[1]) > 0.01) || fabs(x.xR[2] - log(2.0)) > 0.01;
   }
// Linear equations
   diffstep = 1.0E-6;
   for (n = 1; n <= 10; n++) {
   // Prepare task
      ae_matrix_set_length(&a, n - 1 + 1, n - 1 + 1);
      ae_vector_set_length(&x, n - 1 + 1);
      ae_vector_set_length(&xe, n - 1 + 1);
      ae_vector_set_length(&b, n - 1 + 1);
      for (i = 0; i < n; i++) {
         xe.xR[i] = randommid();
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = randommid();
         }
         a.xyR[i][i] += 3 * sign(a.xyR[i][i]);
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(a.xyR[i], 1, xe.xR, 1, n);
         b.xR[i] = v;
      }
   // Test different M/DKind
      for (m = 1; m <= n; m++) {
         for (dkind = 0; dkind <= 1; dkind++) {
         // Solve task
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            if (dkind == 0) {
               minlbfgscreate(n, m, &x, &state);
            }
            if (dkind == 1) {
               minlbfgscreatef(n, m, &x, diffstep, &state);
            }
            minlbfgssetcond(&state, 0.0, 0.0, 0.0, 0);
            while (minlbfgsiteration(&state)) {
               if (state.needf || state.needfg) {
                  state.f = 0.0;
               }
               if (state.needfg) {
                  for (i = 0; i < n; i++) {
                     state.g.xR[i] = 0.0;
                  }
               }
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
                  if (state.needf || state.needfg) {
                     state.f += sqr(v - b.xR[i]);
                  }
                  if (state.needfg) {
                     for (j = 0; j < n; j++) {
                        state.g.xR[j] += 2 * (v - b.xR[i]) * a.xyR[i][j];
                     }
                  }
               }
            }
            minlbfgsresults(&state, &x, &rep);
            eqerror = eqerror || rep.terminationtype <= 0;
            for (i = 0; i < n; i++) {
               eqerror = eqerror || fabs(x.xR[i] - xe.xR[i]) > 0.001;
            }
         }
      }
   }
// Testing convergence properties
   diffstep = 1.0E-6;
   for (dkind = 0; dkind <= 1; dkind++) {
      ae_vector_set_length(&x, 3);
      n = 3;
      m = 2;
      for (i = 0; i <= 2; i++) {
         x.xR[i] = 3.0 * randommid();
      }
      if (dkind == 0) {
         minlbfgscreate(n, m, &x, &state);
      }
      if (dkind == 1) {
         minlbfgscreatef(n, m, &x, diffstep, &state);
      }
      minlbfgssetcond(&state, 0.001, 0.0, 0.0, 0);
      while (minlbfgsiteration(&state)) {
         testminlbfgsunit_testfunc3(&state);
      }
      minlbfgsresults(&state, &x, &rep);
      converror = converror || rep.terminationtype != 4;
      for (i = 0; i <= 2; i++) {
         x.xR[i] = 3.0 * randommid();
      }
      if (dkind == 0) {
         minlbfgscreate(n, m, &x, &state);
      }
      if (dkind == 1) {
         minlbfgscreatef(n, m, &x, diffstep, &state);
      }
      minlbfgssetcond(&state, 0.0, 0.001, 0.0, 0);
      while (minlbfgsiteration(&state)) {
         testminlbfgsunit_testfunc3(&state);
      }
      minlbfgsresults(&state, &x, &rep);
      converror = converror || rep.terminationtype != 1;
      for (i = 0; i <= 2; i++) {
         x.xR[i] = 3.0 * randommid();
      }
      if (dkind == 0) {
         minlbfgscreate(n, m, &x, &state);
      }
      if (dkind == 1) {
         minlbfgscreatef(n, m, &x, diffstep, &state);
      }
      minlbfgssetcond(&state, 0.0, 0.0, 0.001, 0);
      while (minlbfgsiteration(&state)) {
         testminlbfgsunit_testfunc3(&state);
      }
      minlbfgsresults(&state, &x, &rep);
      converror = converror || rep.terminationtype != 2;
      for (i = 0; i <= 2; i++) {
         x.xR[i] = randommid();
      }
      if (dkind == 0) {
         minlbfgscreate(n, m, &x, &state);
      }
      if (dkind == 1) {
         minlbfgscreatef(n, m, &x, diffstep, &state);
      }
      minlbfgssetcond(&state, 0.0, 0.0, 0.0, 10);
      while (minlbfgsiteration(&state)) {
         testminlbfgsunit_testfunc3(&state);
      }
      minlbfgsresults(&state, &x, &rep);
      converror = (converror || rep.terminationtype != 5) || rep.iterationscount != 10;
   }
// Crash test: too many iterations on a simple tasks
// May fail when encounter zero step, underflow or something like that
   ae_vector_set_length(&x, 2 + 1);
   n = 3;
   m = 2;
   maxits = 10000;
   for (i = 0; i <= 2; i++) {
      x.xR[i] = 3.0 * randommid();
   }
   minlbfgscreate(n, m, &x, &state);
   minlbfgssetcond(&state, 0.0, 0.0, 0.0, maxits);
   while (minlbfgsiteration(&state)) {
      state.f = sqr(exp(state.x.xR[0]) - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
      state.g.xR[0] = 2 * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[0] - state.x.xR[2]);
      state.g.xR[1] = 2 * state.x.xR[1];
      state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
   }
   minlbfgsresults(&state, &x, &rep);
   crashtest = crashtest || rep.terminationtype <= 0;
//  Test OptGuard
   optguarderr = false;
   testminlbfgsunit_testoptguard(&optguarderr);
// end
   waserrors = (((((((referror || nonconverror) || eqerror) || converror) || crashtest) || othererrors) || restartserror) || precerror) || optguarderr;
   if (!silent) {
      printf("TESTING L-BFGS OPTIMIZATION\n");
      printf("REFERENCE PROBLEM:                        ");
      if (referror) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("NON-CONVEX PROBLEM:                       ");
      if (nonconverror) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("LINEAR EQUATIONS:                         ");
      if (eqerror) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("RESTARTS:                                 ");
      if (restartserror) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("PRECONDITIONER:                           ");
      if (precerror) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("CONVERGENCE PROPERTIES:                   ");
      if (converror) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("CRASH TEST:                               ");
      if (crashtest) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("OTHER PROPERTIES:                         ");
      if (othererrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("OPTGUARD:                                 ");
      if (optguarderr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === cqmodels testing unit ===
bool testcqmodels(bool silent) {
   ae_frame _frame_block;
   bool eval0errors;
   bool eval1errors;
   bool eval2errors;
   bool newton0errors;
   bool newton1errors;
   bool newton2errors;
   bool waserrors;
   ae_int_t nkind;
   ae_int_t kmax;
   ae_int_t n;
   ae_int_t k;
   ae_int_t i;
   ae_int_t pass;
   ae_int_t j;
   double alpha;
   double theta;
   double tau;
   double v;
   double v2;
   double h;
   double f0;
   double mkind;
   double xtadx2;
   double noise;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(convexquadraticmodel, s);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(r, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(ge, 0, DT_REAL);
   NewVector(gt, 0, DT_REAL);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(adx, 0, DT_REAL);
   NewVector(adxe, 0, DT_REAL);
   NewVector(activeset, 0, DT_BOOL);
   waserrors = false;
// Eval0 test: unconstrained model evaluation
   eval0errors = false;
   for (n = 1; n <= 5; n++) {
      for (k = 0; k <= 2 * n; k++) {
      // Allocate place
         ae_matrix_set_length(&a, n, n);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&ge, n);
         ae_vector_set_length(&gt, n);
         ae_vector_set_length(&tmp0, n);
         if (k > 0) {
            ae_matrix_set_length(&q, k, n);
            ae_vector_set_length(&r, k);
         }
      // Generate problem
         alpha = randomreal() + 1.0;
         theta = randomreal() + 1.0;
         tau = randomreal() * randominteger(2);
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 10 * (1 + randomreal());
            b.xR[i] = randommid();
            d.xR[i] = randomreal() + 1;
            for (j = i + 1; j < n; j++) {
               v = 0.05 * randommid();
               a.xyR[i][j] = v;
               a.xyR[j][i] = v;
            }
            for (j = 0; j < k; j++) {
               q.xyR[j][i] = randommid();
            }
         }
         for (i = 0; i < k; i++) {
            r.xR[i] = randommid();
         }
      // Build model
         cqminit(n, &s);
         cqmseta(&s, &a, randombool(), alpha);
         cqmsetb(&s, &b);
         cqmsetq(&s, &q, &r, k, theta);
         cqmsetd(&s, &d, tau);
      // Evaluate and compare:
      // * X          -   random point
      // * GE         -   "exact" gradient
      // * XTADX2     -   x'*(alpha*A+tau*D)*x/2
      // * ADXE       -   (alpha*A+tau*D)*x
      // * V          -   model value at X
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
            ge.xR[i] = 0.0;
         }
         v = 0.0;
         xtadx2 = 0.0;
         ae_vector_set_length(&adxe, n);
         for (i = 0; i < n; i++) {
            adxe.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            v += x.xR[i] * b.xR[i];
            ge.xR[i] += b.xR[i];
            v += 0.5 * sqr(x.xR[i]) * tau * d.xR[i];
            ge.xR[i] += x.xR[i] * tau * d.xR[i];
            adxe.xR[i] += x.xR[i] * tau * d.xR[i];
            xtadx2 += 0.5 * sqr(x.xR[i]) * tau * d.xR[i];
            for (j = 0; j < n; j++) {
               v += 0.5 * alpha * x.xR[i] * a.xyR[i][j] * x.xR[j];
               ge.xR[i] += alpha * a.xyR[i][j] * x.xR[j];
               adxe.xR[i] += alpha * a.xyR[i][j] * x.xR[j];
               xtadx2 += 0.5 * alpha * x.xR[i] * a.xyR[i][j] * x.xR[j];
            }
         }
         for (i = 0; i < k; i++) {
            v2 = ae_v_dotproduct(q.xyR[i], 1, x.xR, 1, n);
            v += 0.5 * theta * sqr(v2 - r.xR[i]);
            for (j = 0; j < n; j++) {
               ge.xR[j] += theta * (v2 - r.xR[i]) * q.xyR[i][j];
            }
         }
         v2 = cqmeval(&s, &x);
         eval0errors = eval0errors || fabs(v - v2) > 10000 * machineepsilon;
         cqmevalx(&s, &x, &v2, &noise);
         eval0errors = eval0errors || fabs(v - v2) > 10000 * machineepsilon;
         eval0errors = (eval0errors || noise < 0.0) || noise > 10000 * machineepsilon;
         v2 = cqmxtadx2(&s, &x, &tmp0);
         eval0errors = eval0errors || fabs(xtadx2 - v2) > 10000 * machineepsilon;
         cqmgradunconstrained(&s, &x, &gt);
         for (i = 0; i < n; i++) {
            eval0errors = eval0errors || fabs(ge.xR[i] - gt.xR[i]) > 10000 * machineepsilon;
         }
         cqmadx(&s, &x, &adx);
         for (i = 0; i < n; i++) {
            eval0errors = eval0errors || fabs(adx.xR[i] - adxe.xR[i]) > 10000 * machineepsilon;
         }
      }
   }
   waserrors = waserrors || eval0errors;
// Eval1 test: constrained model evaluation
   eval1errors = false;
   for (n = 1; n <= 5; n++) {
      for (k = 0; k <= 2 * n; k++) {
      // Allocate place
         ae_matrix_set_length(&a, n, n);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&activeset, n);
         if (k > 0) {
            ae_matrix_set_length(&q, k, n);
            ae_vector_set_length(&r, k);
         }
      // Generate problem
         alpha = randomreal() + 1.0;
         theta = randomreal() + 1.0;
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 10 * (1 + randomreal());
            b.xR[i] = randommid();
            xc.xR[i] = randommid();
            activeset.xB[i] = randombool();
            for (j = i + 1; j < n; j++) {
               v = 0.05 * randommid();
               a.xyR[i][j] = v;
               a.xyR[j][i] = v;
            }
            for (j = 0; j < k; j++) {
               q.xyR[j][i] = randommid();
            }
         }
         for (i = 0; i < k; i++) {
            r.xR[i] = randommid();
         }
      // Build model, evaluate at random point X, compare
         cqminit(n, &s);
         cqmseta(&s, &a, randombool(), alpha);
         cqmsetb(&s, &b);
         cqmsetq(&s, &q, &r, k, theta);
         cqmsetactiveset(&s, &xc, &activeset);
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
            if (!activeset.xB[i]) {
               xc.xR[i] = x.xR[i];
            }
         }
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += xc.xR[i] * b.xR[i];
            for (j = 0; j < n; j++) {
               v += 0.5 * alpha * xc.xR[i] * a.xyR[i][j] * xc.xR[j];
            }
         }
         for (i = 0; i < k; i++) {
            v2 = ae_v_dotproduct(q.xyR[i], 1, xc.xR, 1, n);
            v += 0.5 * theta * sqr(v2 - r.xR[i]);
         }
         eval1errors = eval1errors || fabs(v - cqmeval(&s, &xc)) > 10000 * machineepsilon;
         eval1errors = eval1errors || fabs(v - cqmdebugconstrainedevalt(&s, &x)) > 10000 * machineepsilon;
         eval1errors = eval1errors || fabs(v - cqmdebugconstrainedevale(&s, &x)) > 10000 * machineepsilon;
      }
   }
   waserrors = waserrors || eval1errors;
// Eval2 test: we generate empty problem and apply sequence of random transformations,
// re-evaluating and re-checking model after each modification.
//
// The purpose of such test is to ensure that our caching strategy works correctly.
   eval2errors = false;
   for (n = 1; n <= 5; n++) {
      kmax = 2 * n;
      ae_matrix_set_length(&a, n, n);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&d, n);
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xc, n);
      ae_matrix_set_length(&q, kmax, n);
      ae_vector_set_length(&r, kmax);
      ae_vector_set_length(&activeset, n);
      ae_vector_set_length(&tmp0, n);
      alpha = 0.0;
      theta = 0.0;
      k = 0;
      tau = 1.0 + randomreal();
      for (i = 0; i < n; i++) {
         activeset.xB[i] = false;
         d.xR[i] = 1.0;
         b.xR[i] = 0.0;
         xc.xR[i] = randommid();
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = 0.0;
         }
      }
      cqminit(n, &s);
      cqmsetd(&s, &d, tau);
      for (pass = 1; pass <= 100; pass++) {
      // Select random modification type, apply modification.
      //
      // MKind is a random integer in [0,7] - number of specific
      // modification to apply.
         mkind = (double)randominteger(8);
         if (mkind == 0.0) {
         // Set non-zero D
            tau = 1.0 + randomreal();
            for (i = 0; i < n; i++) {
               d.xR[i] = 2 * randomreal() + 1;
            }
            cqmsetd(&s, &d, tau);
         } else {
            if (mkind == 1.0) {
            // Set zero D.
            // In case Alpha=0, set non-zero A.
               if (alpha == 0.0) {
                  alpha = 1.0 + randomreal();
                  for (i = 0; i < n; i++) {
                     for (j = i + 1; j < n; j++) {
                        a.xyR[i][j] = 0.1 * randommid();
                        a.xyR[j][i] = a.xyR[i][j];
                     }
                  }
                  for (i = 0; i < n; i++) {
                     a.xyR[i][i] = 4 + 2 * randomreal();
                  }
                  cqmseta(&s, &a, randombool(), alpha);
               }
               tau = 0.0;
               for (i = 0; i < n; i++) {
                  d.xR[i] = 0.0;
               }
               cqmsetd(&s, &d, 0.0);
            } else {
               if (mkind == 2.0) {
               // Set non-zero A
                  alpha = 1.0 + randomreal();
                  for (i = 0; i < n; i++) {
                     for (j = i + 1; j < n; j++) {
                        a.xyR[i][j] = 0.1 * randommid();
                        a.xyR[j][i] = a.xyR[i][j];
                     }
                  }
                  for (i = 0; i < n; i++) {
                     a.xyR[i][i] = 4 + 2 * randomreal();
                  }
                  cqmseta(&s, &a, randombool(), alpha);
               } else {
                  if (mkind == 3.0) {
                  // Set zero A.
                  // In case Tau=0, set non-zero D.
                     if (tau == 0.0) {
                        tau = 1.0 + randomreal();
                        for (i = 0; i < n; i++) {
                           d.xR[i] = 2 * randomreal() + 1;
                        }
                        cqmsetd(&s, &d, tau);
                     }
                     alpha = 0.0;
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] = 0.0;
                        }
                     }
                     cqmseta(&s, &a, randombool(), alpha);
                  } else {
                     if (mkind == 4.0) {
                     // Set B.
                        for (i = 0; i < n; i++) {
                           b.xR[i] = randommid();
                        }
                        cqmsetb(&s, &b);
                     } else {
                        if (mkind == 5.0) {
                        // Set Q.
                           k = randominteger(kmax + 1);
                           theta = 1.0 + randomreal();
                           for (i = 0; i < k; i++) {
                              r.xR[i] = randommid();
                              for (j = 0; j < n; j++) {
                                 q.xyR[i][j] = randommid();
                              }
                           }
                           cqmsetq(&s, &q, &r, k, theta);
                        } else {
                           if (mkind == 6.0) {
                           // Set active set
                              for (i = 0; i < n; i++) {
                                 activeset.xB[i] = randombool();
                                 xc.xR[i] = randommid();
                              }
                              cqmsetactiveset(&s, &xc, &activeset);
                           } else {
                              if (mkind == 7.0) {
                              // Rewrite main diagonal
                                 if (alpha == 0.0) {
                                    alpha = 1.0;
                                 }
                                 for (i = 0; i < n; i++) {
                                    tmp0.xR[i] = 1 + randomreal();
                                    a.xyR[i][i] = tmp0.xR[i] / alpha;
                                 }
                                 cqmrewritedensediagonal(&s, &tmp0);
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      // generate random point with respect to constraints,
      // test model at this point
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
            if (activeset.xB[i]) {
               x.xR[i] = xc.xR[i];
            }
         }
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += x.xR[i] * b.xR[i];
         }
         if (tau > 0.0) {
            for (i = 0; i < n; i++) {
               v += 0.5 * tau * d.xR[i] * sqr(x.xR[i]);
            }
         }
         if (alpha > 0.0) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  v += 0.5 * alpha * x.xR[i] * a.xyR[i][j] * x.xR[j];
               }
            }
         }
         if (theta > 0.0) {
            for (i = 0; i < k; i++) {
               v2 = ae_v_dotproduct(q.xyR[i], 1, x.xR, 1, n);
               v += 0.5 * theta * sqr(v2 - r.xR[i]);
            }
         }
         v2 = cqmeval(&s, &x);
         eval2errors = eval2errors || fabs(v - v2) > 10000 * machineepsilon;
         v2 = cqmdebugconstrainedevalt(&s, &x);
         eval2errors = eval2errors || fabs(v - v2) > 10000 * machineepsilon;
         v2 = cqmdebugconstrainedevale(&s, &x);
         eval2errors = eval2errors || fabs(v - v2) > 10000 * machineepsilon;
      }
   }
   waserrors = waserrors || eval2errors;
// Newton0 test: unconstrained optimization
   newton0errors = false;
   for (n = 1; n <= 5; n++) {
      for (k = 0; k <= 2 * n; k++) {
      // Allocate place
         ae_matrix_set_length(&a, n, n);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&x0, n);
         if (k > 0) {
            ae_matrix_set_length(&q, k, n);
            ae_vector_set_length(&r, k);
         }
      // Generate problem with known solution x0:
      //   min f(x),
      //   f(x) = 0.5*(x-x0)'*A*(x-x0)
      //        = 0.5*x'*A*x + (-x0'*A)*x + 0.5*x0'*A*x0'
         alpha = randomreal() + 1.0;
         for (i = 0; i < n; i++) {
            x0.xR[i] = randommid();
            a.xyR[i][i] = 10 * (1 + randomreal());
            for (j = i + 1; j < n; j++) {
               v = 0.05 * randommid();
               a.xyR[i][j] = v;
               a.xyR[j][i] = v;
            }
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, x0.xR, 1, n);
            b.xR[i] = -alpha * v;
         }
         theta = randomreal() + 1.0;
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               q.xyR[i][j] = randommid();
            }
            v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
            r.xR[i] = v;
         }
      // Build model, evaluate at random point X, compare
         cqminit(n, &s);
         cqmseta(&s, &a, randombool(), alpha);
         cqmsetb(&s, &b);
         cqmsetq(&s, &q, &r, k, theta);
         cqmconstrainedoptimum(&s, &x);
         for (i = 0; i < n; i++) {
            newton0errors = newton0errors || fabs(x.xR[i] - x0.xR[i]) > 1.0E6 * machineepsilon;
         }
      }
   }
   waserrors = waserrors || newton0errors;
// Newton1 test: constrained optimization
   newton1errors = false;
   h = 1.0E-3;
   for (n = 1; n <= 5; n++) {
      for (k = 0; k <= 2 * n; k++) {
      // Allocate place
         ae_matrix_set_length(&a, n, n);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&activeset, n);
         if (k > 0) {
            ae_matrix_set_length(&q, k, n);
            ae_vector_set_length(&r, k);
         }
      // Generate test problem with unknown solution.
         alpha = randomreal() + 1.0;
         for (i = 0; i < n; i++) {
            a.xyR[i][i] = 10 * (1 + randomreal());
            b.xR[i] = randommid();
            xc.xR[i] = randommid();
            activeset.xB[i] = randombool();
            for (j = i + 1; j < n; j++) {
               v = 0.05 * randommid();
               a.xyR[i][j] = v;
               a.xyR[j][i] = v;
            }
         }
         theta = randomreal() + 1.0;
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               q.xyR[i][j] = randommid();
            }
            r.xR[i] = randommid();
         }
      // Build model, find solution
         cqminit(n, &s);
         cqmseta(&s, &a, randombool(), alpha);
         cqmsetb(&s, &b);
         cqmsetq(&s, &q, &r, k, theta);
         cqmsetactiveset(&s, &xc, &activeset);
         if (cqmconstrainedoptimum(&s, &x)) {
         // Check that constraints are satisfied,
         // and that solution is true optimum
            f0 = cqmeval(&s, &x);
            for (i = 0; i < n; i++) {
               newton1errors = newton1errors || (activeset.xB[i] && x.xR[i] != xc.xR[i]);
               if (!activeset.xB[i]) {
                  v = x.xR[i];
                  x.xR[i] = v + h;
                  v2 = cqmeval(&s, &x);
                  newton1errors = newton1errors || v2 < f0;
                  x.xR[i] = v - h;
                  v2 = cqmeval(&s, &x);
                  newton1errors = newton1errors || v2 < f0;
                  x.xR[i] = v;
               }
            }
         } else {
            newton1errors = true;
         }
      }
   }
   waserrors = waserrors || newton1errors;
// Newton2 test: we test ability to work with diagonal matrices, including
// very large ones (up to 100.000 elements). This test checks that:
// a) we can work with Alpha=0, i.e. when we have strictly diagonal A
// b) diagonal problems are handled efficiently, i.e. algorithm will
//    successfully solve problem with N=100.000
//
// Test problem:
// * diagonal term D and rank-K term Q
// * known solution X0,
// * about 50% of constraints are active and equal to components of X0
   newton2errors = false;
   for (nkind = 0; nkind <= 5; nkind++) {
      for (k = 0; k <= 5; k++) {
         n = iround(pow((double)n, (double)nkind));
      // generate problem
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&activeset, n);
         if (k > 0) {
            ae_matrix_set_length(&q, k, n);
            ae_vector_set_length(&r, k);
         }
         tau = 1 + randomreal();
         theta = 1 + randomreal();
         for (i = 0; i < n; i++) {
            x0.xR[i] = randommid();
            d.xR[i] = 1 + randomreal();
            b.xR[i] = -x0.xR[i] * tau * d.xR[i];
            activeset.xB[i] = randombool();
         }
         for (i = 0; i < k; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               q.xyR[i][j] = randommid();
               v += q.xyR[i][j] * x0.xR[j];
            }
            r.xR[i] = v;
         }
      // Solve, test
         cqminit(n, &s);
         cqmsetb(&s, &b);
         cqmsetd(&s, &d, tau);
         cqmsetq(&s, &q, &r, k, theta);
         cqmsetactiveset(&s, &x0, &activeset);
         if (cqmconstrainedoptimum(&s, &x)) {
         // Check that constraints are satisfied,
         // and that solution is true optimum
            f0 = cqmeval(&s, &x);
            for (i = 0; i < n; i++) {
               newton2errors = newton2errors || (activeset.xB[i] && x.xR[i] != x0.xR[i]);
               newton2errors = newton2errors || (!activeset.xB[i] && fabs(x.xR[i] - x0.xR[i]) > 1000 * machineepsilon);
            }
         // Check that constrained evaluation at some point gives correct results
            for (i = 0; i < n; i++) {
               if (activeset.xB[i]) {
                  x.xR[i] = x0.xR[i];
               } else {
                  x.xR[i] = randommid();
               }
            }
            v = 0.0;
            for (i = 0; i < n; i++) {
               v += 0.5 * tau * d.xR[i] * sqr(x.xR[i]) + x.xR[i] * b.xR[i];
            }
            for (i = 0; i < k; i++) {
               v2 = ae_v_dotproduct(q.xyR[i], 1, x.xR, 1, n);
               v += 0.5 * theta * sqr(v2 - r.xR[i]);
            }
            v2 = cqmeval(&s, &x);
            newton2errors = (newton2errors || !isfinite(v2)) || fabs(v - v2) > 10000 * machineepsilon;
            v2 = cqmdebugconstrainedevalt(&s, &x);
            newton2errors = (newton2errors || !isfinite(v2)) || fabs(v - v2) > 10000 * machineepsilon;
            v2 = cqmdebugconstrainedevale(&s, &x);
            newton2errors = (newton2errors || !isfinite(v2)) || fabs(v - v2) > 10000 * machineepsilon;
         } else {
            newton2errors = true;
         }
      }
   }
   waserrors = waserrors || newton2errors;
// report
   if (!silent) {
      printf("TESTING CONVEX QUADRATIC MODELS\n");
      printf("Eval0 test:                               ");
      if (eval0errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("Eval1 test:                               ");
      if (eval1errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("Eval2 test:                               ");
      if (eval2errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("Newton0 test:                             ");
      if (newton0errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("Newton1 test:                             ");
      if (newton1errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("Newton2 test:                             ");
      if (newton2errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === snnls testing unit ===
bool testsnnls(bool silent) {
   ae_frame _frame_block;
   bool test0errors;
   bool test1errors;
   bool test2errors;
   bool testnewtonerrors;
   bool waserrors;
   double eps;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_int_t ns;
   ae_int_t nd;
   ae_int_t nr;
   double rho;
   double xtol;
   ae_int_t nmax;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(densea, 0, 0, DT_REAL);
   NewMatrix(effectivea, 0, 0, DT_REAL);
   NewVector(isconstrained, 0, DT_BOOL);
   NewVector(g, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewObj(snnlssolver, s);
   NewObj(hqrndstate, rs);
   test0errors = false;
   test1errors = false;
   test2errors = false;
   testnewtonerrors = false;
   waserrors = false;
   hqrndrandomize(&rs);
   nmax = 10;
// Test 2 (comes first because it is very basic):
// * NS=0
// * ND in [1,NMAX]
// * NR=ND
// * DenseA is diagonal with positive entries
// * B is random
// * random constraints
// Exact solution is known and can be tested
   eps = 1.0E-12;
   for (nd = 1; nd <= nmax; nd++) {
   // Generate problem
      ns = 0;
      nr = nd;
      ae_matrix_set_length(&densea, nd, nd);
      ae_vector_set_length(&b, nd);
      ae_vector_set_length(&isconstrained, nd);
      for (i = 0; i < nd; i++) {
         for (j = 0; j < nd; j++) {
            densea.xyR[i][j] = 0.0;
         }
         densea.xyR[i][i] = (double)(1 + hqrnduniformi(&rs, 2));
         b.xR[i] = (double)((1 + hqrnduniformi(&rs, 2)) * (2 * hqrnduniformi(&rs, 2) - 1));
         isconstrained.xB[i] = hqrnduniformr(&rs) > 0.5;
      }
   // Solve with SNNLS solver
      snnlsinit(0, 0, 0, &s);
      snnlssetproblem(&s, &densea, &b, 0, nd, nd);
      for (i = 0; i < nd; i++) {
         if (!isconstrained.xB[i]) {
            snnlsdropnnc(&s, i);
         }
      }
      snnlssolve(&s, &x);
   // Check
      for (i = 0; i < nd; i++) {
         if (isconstrained.xB[i]) {
            set_error_flag(&test2errors, fabs(x.xR[i] - rmax2(b.xR[i] / densea.xyR[i][i], 0.0)) > eps, __FILE__, __LINE__, "testsnnlsunit.ap:86");
            set_error_flag(&test2errors, x.xR[i] < 0.0, __FILE__, __LINE__, "testsnnlsunit.ap:87");
         } else {
            set_error_flag(&test2errors, fabs(x.xR[i] - b.xR[i] / densea.xyR[i][i]) > eps, __FILE__, __LINE__, "testsnnlsunit.ap:90");
         }
      }
   }
// Test 0:
// * NS in [0,NMAX]
// * ND in [0,NMAX]
// * NR in [NS,NS+ND+NMAX]
// * NS+ND>0, NR>0
// * about 50% of variables are constrained
// * we check that constrained gradient is small at the solution
   eps = 1.0E-5;
   for (ns = 0; ns <= nmax; ns++) {
      for (nd = 0; nd <= nmax; nd++) {
         for (nr = ns; nr <= ns + nd + nmax; nr++) {
         // Skip NS+ND=0, NR=0
            if (ns + nd == 0) {
               continue;
            }
            if (nr == 0) {
               continue;
            }
         // Generate problem:
         // * DenseA, array[NR,ND]
         // * EffectiveA, array[NR,NS+ND]
         // * B, array[NR]
         // * IsConstrained, array[NS+ND]
            if (nd > 0) {
               ae_matrix_set_length(&densea, nr, nd);
               for (i = 0; i < nr; i++) {
                  for (j = 0; j < nd; j++) {
                     densea.xyR[i][j] = randommid();
                  }
               }
            }
            ae_matrix_set_length(&effectivea, nr, ns + nd);
            for (i = 0; i < nr; i++) {
               for (j = 0; j < ns + nd; j++) {
                  effectivea.xyR[i][j] = 0.0;
               }
            }
            for (i = 0; i < ns; i++) {
               effectivea.xyR[i][i] = 1.0;
            }
            for (i = 0; i < nr; i++) {
               for (j = 0; j < nd; j++) {
                  effectivea.xyR[i][ns + j] = densea.xyR[i][j];
               }
            }
            ae_vector_set_length(&b, nr);
            for (i = 0; i < nr; i++) {
               b.xR[i] = randommid();
            }
            ae_vector_set_length(&isconstrained, ns + nd);
            for (i = 0; i < ns + nd; i++) {
               isconstrained.xB[i] = randombool();
            }
         // Solve with SNNLS solver
            snnlsinit(0, 0, 0, &s);
            snnlssetproblem(&s, &densea, &b, ns, nd, nr);
            for (i = 0; i < ns + nd; i++) {
               if (!isconstrained.xB[i]) {
                  snnlsdropnnc(&s, i);
               }
            }
            snnlssolve(&s, &x);
         // Check non-negativity
            for (i = 0; i < ns + nd; i++) {
               set_error_flag(&test0errors, isconstrained.xB[i] && x.xR[i] < 0.0, __FILE__, __LINE__, "testsnnlsunit.ap:160");
            }
         // Calculate gradient A'*A*x-b'*A.
         // Check projected gradient (each component must be less than Eps).
            ae_vector_set_length(&g, ns + nd);
            for (i = 0; i < ns + nd; i++) {
               v = ae_v_dotproduct(b.xR, 1, &effectivea.xyR[0][i], effectivea.stride, nr);
               g.xR[i] = -v;
            }
            for (i = 0; i < nr; i++) {
               v = ae_v_dotproduct(effectivea.xyR[i], 1, x.xR, 1, ns + nd);
               ae_v_addd(g.xR, 1, effectivea.xyR[i], 1, ns + nd, v);
            }
            for (i = 0; i < ns + nd; i++) {
               if (!isconstrained.xB[i] || x.xR[i] > 0.0) {
                  set_error_flag(&test0errors, fabs(g.xR[i]) > eps, __FILE__, __LINE__, "testsnnlsunit.ap:179");
               } else {
                  set_error_flag(&test0errors, g.xR[i] < -eps, __FILE__, __LINE__, "testsnnlsunit.ap:181");
               }
            }
         }
      }
   }
// Test 1: ability of the solver to take very short steps.
//
// We solve problem similar to one solver in test 0, but with
// progressively decreased magnitude of variables. We generate
// problem with already-known solution and compare results against it.
   xtol = 1.0E-7;
   for (ns = 0; ns <= nmax; ns++) {
      for (nd = 0; nd <= nmax; nd++) {
         for (nr = ns; nr <= ns + nd + nmax; nr++) {
            for (k = 0; k <= 20; k++) {
            // Skip NS+ND=0, NR=0
            //
            // Skip degenerate problems (NR<NS+ND) - important for this particular test.
               if (ns + nd == 0) {
                  continue;
               }
               if (nr == 0) {
                  continue;
               }
               if (nr < ns + nd) {
                  continue;
               }
            // Generate problem:
            // * DenseA, array[NR,ND]
            // * EffectiveA, array[NR,NS+ND]
            // * B, array[NR]
            // * IsConstrained, array[NS+ND]
               rho = pow(10.0, (double)-k);
               if (nd > 0) {
                  ae_matrix_set_length(&densea, nr, nd);
                  for (i = 0; i < nr; i++) {
                     for (j = 0; j < nd; j++) {
                        densea.xyR[i][j] = 2 * hqrnduniformr(&rs) - 1;
                     }
                  }
               }
               ae_matrix_set_length(&effectivea, nr, ns + nd);
               for (i = 0; i < nr; i++) {
                  for (j = 0; j < ns + nd; j++) {
                     effectivea.xyR[i][j] = 0.0;
                  }
               }
               for (i = 0; i < ns; i++) {
                  effectivea.xyR[i][i] = 1.0;
               }
               for (i = 0; i < nr; i++) {
                  for (j = 0; j < nd; j++) {
                     effectivea.xyR[i][ns + j] = densea.xyR[i][j];
                  }
               }
               ae_vector_set_length(&xs, ns + nd);
               ae_vector_set_length(&isconstrained, ns + nd);
               for (i = 0; i < ns + nd; i++) {
                  xs.xR[i] = rho * (hqrnduniformr(&rs) - 0.5);
                  isconstrained.xB[i] = xs.xR[i] > 0.0;
               }
               ae_vector_set_length(&b, nr);
               for (i = 0; i < nr; i++) {
                  v = 0.0;
                  for (j = 0; j < ns + nd; j++) {
                     v += effectivea.xyR[i][j] * xs.xR[j];
                  }
                  b.xR[i] = v;
               }
            // Solve with SNNLS solver
               snnlsinit(0, 0, 0, &s);
               snnlssetproblem(&s, &densea, &b, ns, nd, nr);
               for (i = 0; i < ns + nd; i++) {
                  if (!isconstrained.xB[i]) {
                     snnlsdropnnc(&s, i);
                  }
               }
               snnlssolve(&s, &x);
            // Check non-negativity
               for (i = 0; i < ns + nd; i++) {
                  set_error_flag(&test1errors, isconstrained.xB[i] && x.xR[i] < 0.0, __FILE__, __LINE__, "testsnnlsunit.ap:263");
               }
            // Compare with true solution
               for (i = 0; i < ns + nd; i++) {
                  set_error_flag(&test1errors, fabs(xs.xR[i] - x.xR[i]) > rho * xtol, __FILE__, __LINE__, "testsnnlsunit.ap:269");
               }
            }
         }
      }
   }
// Test for Newton phase:
// * NS in [0,NMAX]
// * ND in [0,NMAX]
// * NR in [NS,NS+ND+NMAX]
// * NS+ND>0, NR>0
// * all variables are unconstrained
// * S.DebugMaxNewton is set to 1, S.RefinementIts is set to 1,
//   i.e. algorithm is terminated after one Newton iteration, and no
//   iterative refinement is used.
// * we test that gradient is small at solution, i.e. one Newton iteration
//   on unconstrained problem is enough to find solution. In case of buggy
//   Newton solver one iteration won't move us to the solution - it may
//   decrease function value, but won't find exact solution.
//
// This test is intended to catch subtle bugs in the Newton solver which
// do NOT prevent algorithm from converging to the solution, but slow it
// down (convergence becomes linear or even slower).
   eps = 1.0E-4;
   for (ns = 0; ns <= nmax; ns++) {
      for (nd = 0; nd <= nmax; nd++) {
         for (nr = ns; nr <= ns + nd + nmax; nr++) {
         // Skip NS+ND=0, NR=0
            if (ns + nd == 0) {
               continue;
            }
            if (nr == 0) {
               continue;
            }
         // Generate problem:
         // * DenseA, array[NR,ND]
         // * EffectiveA, array[NR,NS+ND]
         // * B, array[NR]
         // * IsConstrained, array[NS+ND]
            if (nd > 0) {
               ae_matrix_set_length(&densea, nr, nd);
               for (i = 0; i < nr; i++) {
                  for (j = 0; j < nd; j++) {
                     densea.xyR[i][j] = hqrndnormal(&rs);
                  }
               }
            }
            ae_matrix_set_length(&effectivea, nr, ns + nd);
            for (i = 0; i < nr; i++) {
               for (j = 0; j < ns + nd; j++) {
                  effectivea.xyR[i][j] = 0.0;
               }
            }
            for (i = 0; i < ns; i++) {
               effectivea.xyR[i][i] = 1.0;
            }
            for (i = 0; i < nr; i++) {
               for (j = 0; j < nd; j++) {
                  effectivea.xyR[i][ns + j] = densea.xyR[i][j];
               }
            }
            ae_vector_set_length(&b, nr);
            for (i = 0; i < nr; i++) {
               b.xR[i] = hqrndnormal(&rs);
            }
         // Solve with SNNLS solver
            snnlsinit(0, 0, 0, &s);
            snnlssetproblem(&s, &densea, &b, ns, nd, nr);
            for (i = 0; i < ns + nd; i++) {
               snnlsdropnnc(&s, i);
            }
            s.debugmaxinnerits = 1;
            snnlssolve(&s, &x);
         // Calculate gradient A'*A*x-b'*A.
         // Check projected gradient (each component must be less than Eps).
            ae_vector_set_length(&g, ns + nd);
            for (i = 0; i < ns + nd; i++) {
               v = ae_v_dotproduct(b.xR, 1, &effectivea.xyR[0][i], effectivea.stride, nr);
               g.xR[i] = -v;
            }
            for (i = 0; i < nr; i++) {
               v = ae_v_dotproduct(effectivea.xyR[i], 1, x.xR, 1, ns + nd);
               ae_v_addd(g.xR, 1, effectivea.xyR[i], 1, ns + nd, v);
            }
            for (i = 0; i < ns + nd; i++) {
               set_error_flag(&testnewtonerrors, fabs(g.xR[i]) > eps, __FILE__, __LINE__, "testsnnlsunit.ap:358");
            }
         }
      }
   }
// report
   waserrors = ((test0errors || test1errors) || test2errors) || testnewtonerrors;
   if (!silent) {
      printf("TESTING SPECIAL NNLS SOLVER\n");
      printf("TEST 0:                                   ");
      if (test0errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("TEST 1:                                   ");
      if (test1errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("TEST 2:                                   ");
      if (test2errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("NEWTON PHASE:                             ");
      if (testnewtonerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === sactivesets testing unit ===
// This function tests special properties.
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testsactivesetsunit_testspecproperties(bool *err) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t nec;
   ae_int_t nic;
   double v;
   double vv;
   ae_int_t scaletype;
   ae_int_t pass;
   ae_int_t distortidx;
   double distortmag;
   ae_frame_make(&_frame_block);
   NewObj(sactiveset, state);
   NewObj(hqrndstate, rs);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   hqrndrandomize(&rs);
// N-dimensional problem with Ne equality and Ni inequality constraints.
//
// Check that SActiveSet object uses efficient algorithm
// to determine initial point: it avoids expensive (N+Ni)-dimensional
// QP subproblem when initial point is feasible w.r.t. constraints.
//
// In order to do so we try to find initial point for a problem with
// 2 equality constraints and 1000000 inequality constraints (+box
// constraints). Inefficient algorithm will simply fail to allocate
// enough memory, so we do not have to perform any checks here.
   n = 5;
   nec = 2;
   nic = 1000000;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&bl, n);
   ae_vector_set_length(&bu, n);
   for (scaletype = 0; scaletype <= 1; scaletype++) {
   // Generate problem
      for (i = 0; i < n; i++) {
         x.xR[i] = hqrnduniformr(&rs);
         bl.xR[i] = x.xR[i] - hqrnduniformr(&rs) * hqrnduniformi(&rs, 2);
         bu.xR[i] = x.xR[i] + hqrnduniformr(&rs) * hqrnduniformi(&rs, 2);
      }
      ae_matrix_set_length(&c, nec + nic, n + 1);
      ae_vector_set_length(&ct, nec + nic);
      for (i = 0; i < nec + nic; i++) {
         v = 0.0;
         for (j = 0; j < n; j++) {
            c.xyR[i][j] = hqrndnormal(&rs);
            v += c.xyR[i][j] * x.xR[j];
         }
         c.xyR[i][n] = v;
         if (i < nec) {
            ct.xZ[i] = 0;
         } else {
            c.xyR[i][n] += 0.1;
            ct.xZ[i] = -1;
         }
      }
   // Apply scaling (if needed), then randomly multiply C by
   // some large/small value in order to distort magnitude of
   // linear constraints.
   //
   // Correct SActiveSet implementation must be able to renormalize
   // constraints prior to checking feasibility of initial point.
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 1.0;
         if (scaletype != 0) {
            s.xR[i] = pow(10.0, 40 * hqrnduniformr(&rs) - 20);
         }
         x.xR[i] *= s.xR[i];
         bl.xR[i] *= s.xR[i];
         bu.xR[i] *= s.xR[i];
         for (j = 0; j < nec + nic; j++) {
            c.xyR[j][i] /= s.xR[i];
         }
      }
      for (i = 0; i < nec + nic; i++) {
         v = pow(10.0, 40 * hqrnduniformr(&rs) - 20);
         ae_v_muld(c.xyR[i], 1, n + 1, v);
      }
   // Solve.
   // Simply being able to survive SASStartOptimization() call is enough for this test
      sasinit(n, &state);
      sassetscale(&state, &s);
      sassetbc(&state, &bl, &bu);
      sassetlc(&state, &c, &ct, nec + nic);
      sasstartoptimization(&state, &x);
   }
// Test that algorithm can correctly distinguish between feasible
// and non-feasible initial points. In order to do so we try to
// call SASStartOptimization() for moderately sized problem and
// examine State.FeasInitPt flag after call is done.
//
// This test is performed for equality-only constraints
   for (pass = 1; pass <= 10; pass++) {
      n = 50 + hqrnduniformi(&rs, 10);
      nec = 10 + hqrnduniformi(&rs, 10);
      nic = 0;
      ae_vector_set_length(&x, n);
      for (scaletype = 0; scaletype <= 1; scaletype++) {
      // Generate problem, prepare distortion which introduces infeasibility
         for (i = 0; i < n; i++) {
            x.xR[i] = hqrnduniformr(&rs);
         }
         ae_matrix_set_length(&c, nec + nic, n + 1);
         ae_vector_set_length(&ct, nec + nic);
         for (i = 0; i < nec + nic; i++) {
            v = 0.0;
            vv = 0.0;
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
               vv += sqr(c.xyR[i][j]);
               v += c.xyR[i][j] * x.xR[j];
            }
            c.xyR[i][n] = v;
            vv = coalesce(vv, 1.0);
            vv = 1 / sqrt(vv);
            ae_v_muld(c.xyR[i], 1, n + 1, vv);
            ct.xZ[i] = 0;
         }
         distortidx = hqrnduniformi(&rs, n);
         distortmag = 0.0;
         for (i = 0; i < nec + nic; i++) {
            distortmag = rmax2(distortmag, fabs(c.xyR[i][distortidx]));
         }
         ae_assert(distortmag > 0.0, "Assertion failed");
         distortmag = 1.0E7 * machineepsilon / distortmag;
      // Apply scaling (if needed), then randomly multiply C by
      // some large/small value in order to distort magnitude of
      // linear constraints.
      //
      // Correct SActiveSet implementation must be able to renormalize
      // constraints prior to checking feasibility of initial point.
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = 1.0;
            if (scaletype != 0) {
               s.xR[i] = pow(10.0, 40 * hqrnduniformr(&rs) - 20);
            }
            x.xR[i] *= s.xR[i];
            for (j = 0; j < nec + nic; j++) {
               c.xyR[j][i] /= s.xR[i];
            }
         }
         for (i = 0; i < nec + nic; i++) {
            v = pow(10.0, 40 * hqrnduniformr(&rs) - 20);
            ae_v_muld(c.xyR[i], 1, n + 1, v);
         }
      // Solve for feasible initial X and check State.FeasInitPt flag
         sasinit(n, &state);
         sassetscale(&state, &s);
         sassetlc(&state, &c, &ct, nec + nic);
         sasstartoptimization(&state, &x);
         set_error_flag(err, !state.feasinitpt, __FILE__, __LINE__, "testsactivesetsunit.ap:225");
      // Solve for infeasible initial X and check State.FeasInitPt flag
         x.xR[distortidx] += s.xR[distortidx] * distortmag;
         sasinit(n, &state);
         sassetscale(&state, &s);
         sassetlc(&state, &c, &ct, nec + nic);
         sasstartoptimization(&state, &x);
         set_error_flag(err, state.feasinitpt, __FILE__, __LINE__, "testsactivesetsunit.ap:235");
      }
   }
   ae_frame_leave();
}

bool testsactivesets(bool silent) {
   bool waserrors;
   bool specerr;
   bool result;
   specerr = false;
   testsactivesetsunit_testspecproperties(&specerr);
// report
   waserrors = specerr;
   if (!silent) {
      printf("TESTING ACTIVE SETS\n");
      printf("* SPECIAL PROPERTIES                      ");
      if (specerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === minbleic testing unit ===
static const ae_int_t testminbleicunit_maxoptguardlevel = 1;

// Calculate test function IIP2
//
// f(x) = sum( ((i*i+1)^FK*x[i])^2, i=0..N-1)
//
// It has high condition number which makes fast convergence unlikely without
// good preconditioner.
//
static void testminbleicunit_calciip2(minbleicstate *state, ae_int_t n, ae_int_t fk) {
   ae_int_t i;
   if (state->needfg) {
      state->f = 0.0;
   }
   for (i = 0; i < n; i++) {
      if (state->needfg) {
         state->f += pow((double)(i * i + 1), (double)(2 * fk)) * sqr(state->x.xR[i]);
         state->g.xR[i] = pow((double)(i * i + 1), (double)(2 * fk)) * 2 * state->x.xR[i];
      }
   }
}

// This function sets random preconditioner:
// * unit one, for PrecKind=0
// * diagonal-based one, for PrecKind=1
// * scale-based one, for PrecKind=2
static void testminbleicunit_setrandompreconditioner(minbleicstate *state, ae_int_t n, ae_int_t preckind) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewVector(p, 0, DT_REAL);
   if (preckind == 1) {
      ae_vector_set_length(&p, n);
      for (i = 0; i < n; i++) {
         p.xR[i] = exp(3.0 * randommid());
      }
      minbleicsetprecdiag(state, &p);
   } else {
      minbleicsetprecdefault(state);
   }
   ae_frame_leave();
}

// This function test feasibility properties.
// It launches a sequence of problems and examines their solutions.
// Most of the attention is directed towards feasibility properties,
// although we make some quick checks to ensure that actual solution is found.
//
// On failure sets FeasErr (or ConvErr, depending on failure type) to True,
// or leaves it unchanged otherwise.
//
// IntErr is set to True on internal errors (errors in the control flow).
static void testminbleicunit_testfeasibility(bool *feaserr, bool *converr, bool *interr) {
   ae_frame _frame_block;
   ae_int_t pkind;
   ae_int_t preckind;
   ae_int_t passcount;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t nmax;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t p;
   double v;
   double v2;
   double v3;
   double vv;
   double epsx;
   double epsfeas;
   double weakepsg;
   ae_int_t dkind;
   double diffstep;
   ae_frame_make(&_frame_block);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(svdw, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(svdu, 0, 0, DT_REAL);
   NewMatrix(svdvt, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(minbleicstate, state);
   NewObj(minbleicreport, rep);
   nmax = 5;
   weakepsg = 1.0E-4;
   epsx = 1.0E-4;
   epsfeas = 1.0E-6;
   passcount = 10;
   for (pass = 1; pass <= passcount; pass++) {
   // Test problem 1:
   // * no boundary and inequality constraints
   // * randomly generated plane as equality constraint
   // * random point (not necessarily on the plane)
   // * f = |x|^P, P = {2, 4} is used as target function
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * either analytic gradient or numerical differentiation are used
   // * we check that after work is over we are on the plane and
   //   that we are in the stationary point of constrained F
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         for (preckind = 0; preckind <= 2; preckind++) {
            for (pkind = 1; pkind <= 2; pkind++) {
               for (n = 1; n <= nmax; n++) {
               // Generate X, BL, BU, CT and left part of C.
               //
               // Right part of C is generated using somewhat complex algo:
               // * we generate random vector and multiply it by C.
               // * result is used as the right part.
               // * calculations are done on the fly, vector itself is not stored
               // We use such algo to be sure that our system is consistent.
                  p = 2 * pkind;
                  ae_vector_set_length(&x, n);
                  ae_vector_set_length(&g, n);
                  ae_matrix_set_length(&c, 1, n + 1);
                  ae_vector_set_length(&ct, 1);
                  c.xyR[0][n] = 0.0;
                  for (i = 0; i < n; i++) {
                     x.xR[i] = randommid();
                     c.xyR[0][i] = randommid();
                     v = randommid();
                     c.xyR[0][n] += c.xyR[0][i] * v;
                  }
                  ct.xZ[0] = 0;
               // Create and optimize
                  if (dkind == 0) {
                     minbleiccreate(n, &x, &state);
                  }
                  if (dkind == 1) {
                     minbleiccreatef(n, &x, diffstep, &state);
                  }
                  minbleicsetlc(&state, &c, &ct, 1);
                  minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbleicunit_setrandompreconditioner(&state, n, preckind);
                  while (minbleiciteration(&state)) {
                     if (state.needf || state.needfg) {
                        state.f = 0.0;
                     }
                     for (i = 0; i < n; i++) {
                        if (state.needf || state.needfg) {
                           state.f += pow(state.x.xR[i], (double)p);
                        }
                        if (state.needfg) {
                           state.g.xR[i] = p * pow(state.x.xR[i], (double)(p - 1));
                        }
                     }
                  }
                  minbleicresults(&state, &x, &rep);
                  if (rep.terminationtype <= 0) {
                     set_error_flag(converr, true, __FILE__, __LINE__, "testminbleicunit.ap:250");
                     ae_frame_leave();
                     return;
                  }
               // Test feasibility of solution
                  v = ae_v_dotproduct(c.xyR[0], 1, x.xR, 1, n);
                  *feaserr = *feaserr || fabs(v - c.xyR[0][n]) > epsfeas;
               // if C is nonzero, test that result is
               // a stationary point of constrained F.
               //
               // NOTE: this check is done only if C is nonzero
                  vv = ae_v_dotproduct(c.xyR[0], 1, c.xyR[0], 1, n);
                  if (vv != 0.0) {
                  // Calculate gradient at the result
                  // Project gradient into C
                  // Check projected norm
                     for (i = 0; i < n; i++) {
                        g.xR[i] = p * pow(x.xR[i], (double)(p - 1));
                     }
                     v2 = ae_v_dotproduct(c.xyR[0], 1, c.xyR[0], 1, n);
                     v = ae_v_dotproduct(c.xyR[0], 1, g.xR, 1, n);
                     vv = v / v2;
                     ae_v_subd(g.xR, 1, c.xyR[0], 1, n, vv);
                     v3 = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
                     set_error_flag(converr, sqrt(v3) > weakepsg, __FILE__, __LINE__, "testminbleicunit.ap:281");
                  }
               }
            }
         }
      }
   // Test problem 2 (multiple equality constraints):
   // * 1 <= N <= NMax, 1 <= K <= N
   // * no boundary constraints
   // * N-dimensional space
   // * randomly generated point xs
   // * K randomly generated hyperplanes which all pass through xs
   //   define K equality constraints: (a[k],x)=b[k]
   // * equality constraints are checked for being well conditioned
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * f(x) = |x-x0|^2, x0 = xs+a[0]
   // * either analytic gradient or numerical differentiation are used
   // * extremum of f(x) is exactly xs because:
   //   * xs is the closest point in the plane defined by (a[0],x)=b[0]
   //   * xs is feasible by definition
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         for (preckind = 0; preckind <= 2; preckind++) {
            for (n = 2; n <= nmax; n++) {
               for (k = 1; k <= n; k++) {
               // Generate X, X0, XS, BL, BU, CT and left part of C.
               //
               // Right part of C is generated using somewhat complex algo:
               // * we generate random vector and multiply it by C.
               // * result is used as the right part.
               // * calculations are done on the fly, vector itself is not stored
               // We use such algo to be sure that our system is consistent.
                  ae_vector_set_length(&x, n);
                  ae_vector_set_length(&x0, n);
                  ae_vector_set_length(&xs, n);
                  ae_vector_set_length(&g, n);
                  ae_matrix_set_length(&c, k, n + 1);
                  ae_vector_set_length(&ct, k);
                  c.xyR[0][n] = 0.0;
                  for (i = 0; i < n; i++) {
                     x.xR[i] = randommid();
                     xs.xR[i] = randommid();
                  }
                  do {
                     for (i = 0; i < k; i++) {
                        for (j = 0; j < n; j++) {
                           c.xyR[i][j] = randommid();
                        }
                        v = ae_v_dotproduct(c.xyR[i], 1, xs.xR, 1, n);
                        c.xyR[i][n] = v;
                        ct.xZ[i] = 0;
                     }
                     set_error_flag(feaserr, !rmatrixsvd(&c, k, n, 0, 0, 0, &svdw, &svdu, &svdvt), __FILE__, __LINE__, "testminbleicunit.ap:342");
                  } while (!(svdw.xR[0] > 0.0 && svdw.xR[k - 1] > 0.001 * svdw.xR[0]));
                  ae_v_move(x0.xR, 1, xs.xR, 1, n);
                  ae_v_add(x0.xR, 1, c.xyR[0], 1, n);
               // Create and optimize
                  if (dkind == 0) {
                     minbleiccreate(n, &x, &state);
                  }
                  if (dkind == 1) {
                     minbleiccreatef(n, &x, diffstep, &state);
                  }
                  minbleicsetlc(&state, &c, &ct, k);
                  minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbleicunit_setrandompreconditioner(&state, n, preckind);
                  while (minbleiciteration(&state)) {
                     if (state.needf || state.needfg) {
                        state.f = 0.0;
                     }
                     for (i = 0; i < n; i++) {
                        if (state.needf || state.needfg) {
                           state.f += sqr(state.x.xR[i] - x0.xR[i]);
                        }
                        if (state.needfg) {
                           state.g.xR[i] = 2 * (state.x.xR[i] - x0.xR[i]);
                        }
                     }
                  }
                  minbleicresults(&state, &x, &rep);
                  if (rep.terminationtype <= 0) {
                     set_error_flag(converr, true, __FILE__, __LINE__, "testminbleicunit.ap:373");
                     ae_frame_leave();
                     return;
                  }
               // check feasiblity properties
                  for (i = 0; i < k; i++) {
                     v = ae_v_dotproduct(c.xyR[i], 1, x.xR, 1, n);
                     *feaserr = *feaserr || fabs(v - c.xyR[i][n]) > epsx;
                  }
               // Compare with XS
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     v += sqr(x.xR[i] - xs.xR[i]);
                  }
                  v = sqrt(v);
                  set_error_flag(converr, fabs(v) > 0.001, __FILE__, __LINE__, "testminbleicunit.ap:393");
               }
            }
         }
      }
   // Another simple problem:
   // * bound constraints 0 <= x[i] <= 1
   // * no linear constraints
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P={2,4} and x0 is randomly selected from [-1,+2]^N
   // * with such simple boundaries and function it is easy to find
   //   analytic form of solution: S[i] = bound(x0[i], 0, 1)
   // * we also check that both final solution and subsequent iterates
   //   are strictly feasible
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         for (preckind = 0; preckind <= 2; preckind++) {
            for (pkind = 1; pkind <= 2; pkind++) {
               for (n = 1; n <= nmax; n++) {
               // Generate X, BL, BU.
                  p = 2 * pkind;
                  ae_vector_set_length(&bl, n);
                  ae_vector_set_length(&bu, n);
                  ae_vector_set_length(&x, n);
                  ae_vector_set_length(&x0, n);
                  for (i = 0; i < n; i++) {
                     bl.xR[i] = 0.0;
                     bu.xR[i] = 1.0;
                     x.xR[i] = randomreal();
                     x0.xR[i] = 3.0 * randomreal() - 1.0;
                  }
               // Create and optimize
                  if (dkind == 0) {
                     minbleiccreate(n, &x, &state);
                  }
                  if (dkind == 1) {
                     minbleiccreatef(n, &x, diffstep, &state);
                  }
                  minbleicsetbc(&state, &bl, &bu);
                  minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbleicunit_setrandompreconditioner(&state, n, preckind);
                  while (minbleiciteration(&state)) {
                     if (state.needf || state.needfg) {
                        state.f = 0.0;
                     }
                     for (i = 0; i < n; i++) {
                        if (state.needf || state.needfg) {
                           state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                        }
                        if (state.needfg) {
                           state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                        }
                        *feaserr = *feaserr || state.x.xR[i] < 0.0;
                        *feaserr = *feaserr || state.x.xR[i] > 1.0;
                     }
                  }
                  minbleicresults(&state, &x, &rep);
                  if (rep.terminationtype <= 0) {
                     set_error_flag(converr, true, __FILE__, __LINE__, "testminbleicunit.ap:461");
                     ae_frame_leave();
                     return;
                  }
               // * compare solution with analytic one
               // * check feasibility
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     if (x.xR[i] > 0.0 && x.xR[i] < 1.0) {
                        v += sqr(p * pow(x.xR[i] - x0.xR[i], (double)(p - 1)));
                     }
                     *feaserr = *feaserr || x.xR[i] < 0.0;
                     *feaserr = *feaserr || x.xR[i] > 1.0;
                  }
                  set_error_flag(converr, sqrt(v) > weakepsg, __FILE__, __LINE__, "testminbleicunit.ap:477");
               }
            }
         }
      }
   // Same as previous problem, but with minor modifications:
   // * some bound constraints are 0 <= x[i] <= 1, some are Ci=x[i]=Ci
   // * no linear constraints
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P={2,4} and x0 is randomly selected from [-1,+2]^N
   // * with such simple boundaries and function it is easy to find
   //   analytic form of solution: S[i] = bound(x0[i], 0, 1)
   // * we also check that both final solution and subsequent iterates
   //   are strictly feasible
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         for (preckind = 0; preckind <= 2; preckind++) {
            for (pkind = 1; pkind <= 2; pkind++) {
               for (n = 1; n <= nmax; n++) {
               // Generate X, BL, BU.
                  p = 2 * pkind;
                  ae_vector_set_length(&bl, n);
                  ae_vector_set_length(&bu, n);
                  ae_vector_set_length(&x, n);
                  ae_vector_set_length(&x0, n);
                  for (i = 0; i < n; i++) {
                     if (randombool()) {
                        bl.xR[i] = 0.0;
                        bu.xR[i] = 1.0;
                     } else {
                        bl.xR[i] = randomreal();
                        bu.xR[i] = bl.xR[i];
                     }
                     x.xR[i] = randomreal();
                     x0.xR[i] = 3.0 * randomreal() - 1.0;
                  }
               // Create and optimize
                  if (dkind == 0) {
                     minbleiccreate(n, &x, &state);
                  }
                  if (dkind == 1) {
                     minbleiccreatef(n, &x, diffstep, &state);
                  }
                  minbleicsetbc(&state, &bl, &bu);
                  minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbleicunit_setrandompreconditioner(&state, n, preckind);
                  while (minbleiciteration(&state)) {
                     if (state.needf || state.needfg) {
                        state.f = 0.0;
                     }
                     for (i = 0; i < n; i++) {
                        if (state.needf || state.needfg) {
                           state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                        }
                        if (state.needfg) {
                           state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                        }
                        *feaserr = *feaserr || state.x.xR[i] < bl.xR[i];
                        *feaserr = *feaserr || state.x.xR[i] > bu.xR[i];
                     }
                  }
                  minbleicresults(&state, &x, &rep);
                  if (rep.terminationtype <= 0) {
                     set_error_flag(converr, true, __FILE__, __LINE__, "testminbleicunit.ap:553");
                     ae_frame_leave();
                     return;
                  }
               // * compare solution with analytic one
               // * check feasibility
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     if (x.xR[i] > bl.xR[i] && x.xR[i] < bu.xR[i]) {
                        v += sqr(p * pow(x.xR[i] - x0.xR[i], (double)(p - 1)));
                     }
                     *feaserr = *feaserr || x.xR[i] < bl.xR[i];
                     *feaserr = *feaserr || x.xR[i] > bu.xR[i];
                  }
                  set_error_flag(converr, sqrt(v) > weakepsg, __FILE__, __LINE__, "testminbleicunit.ap:569");
               }
            }
         }
      }
   // Same as previous one, but with bound constraints posed
   // as general linear ones:
   // * no bound constraints
   // * 2*N linear constraints 0 <= x[i] <= 1
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P={2,4} and x0 is randomly selected from [-1,+2]^N
   // * with such simple constraints and function it is easy to find
   //   analytic form of solution: S[i] = bound(x0[i], 0, 1).
   // * however, we can't guarantee that solution is strictly feasible
   //   with respect to nonlinearity constraint, so we check
   //   for approximate feasibility.
      for (preckind = 0; preckind <= 2; preckind++) {
         for (pkind = 1; pkind <= 2; pkind++) {
            for (n = 1; n <= nmax; n++) {
            // Generate X, BL, BU.
               p = 2 * pkind;
               ae_vector_set_length(&x, n);
               ae_vector_set_length(&x0, n);
               ae_matrix_set_length(&c, 2 * n, n + 1);
               ae_vector_set_length(&ct, 2 * n);
               for (i = 0; i < n; i++) {
                  x.xR[i] = randomreal();
                  x0.xR[i] = 3.0 * randomreal() - 1.0;
                  for (j = 0; j <= n; j++) {
                     c.xyR[2 * i + 0][j] = 0.0;
                     c.xyR[2 * i + 1][j] = 0.0;
                  }
                  c.xyR[2 * i + 0][i] = 1.0;
                  c.xyR[2 * i + 0][n] = 0.0;
                  ct.xZ[2 * i + 0] = 1;
                  c.xyR[2 * i + 1][i] = 1.0;
                  c.xyR[2 * i + 1][n] = 1.0;
                  ct.xZ[2 * i + 1] = -1;
               }
            // Create and optimize
               minbleiccreate(n, &x, &state);
               minbleicsetlc(&state, &c, &ct, 2 * n);
               minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
               testminbleicunit_setrandompreconditioner(&state, n, preckind);
               while (minbleiciteration(&state)) {
                  if (state.needfg) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                        state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                     }
                     continue;
                  }
               // Unknown protocol specified
                  *interr = true;
                  ae_frame_leave();
                  return;
               }
               minbleicresults(&state, &x, &rep);
               if (rep.terminationtype <= 0) {
                  set_error_flag(converr, true, __FILE__, __LINE__, "testminbleicunit.ap:648");
                  ae_frame_leave();
                  return;
               }
            // * compare solution with analytic one
            // * check feasibility
               v = 0.0;
               for (i = 0; i < n; i++) {
                  if (x.xR[i] > 0.02 && x.xR[i] < 0.98) {
                     v += sqr(p * pow(x.xR[i] - x0.xR[i], (double)(p - 1)));
                  }
                  *feaserr = *feaserr || x.xR[i] < 0.0 - epsfeas;
                  *feaserr = *feaserr || x.xR[i] > 1.0 + epsfeas;
               }
               set_error_flag(converr, sqrt(v) > weakepsg, __FILE__, __LINE__, "testminbleicunit.ap:664");
            }
         }
      }
   // Feasibility problem:
   // * bound constraints 0 <= x[i] <= 1
   // * starting point xs with xs[i] in [-1,+2]
   // * random point xc from [0,1] is used to generate K <= N
   //   random linear equality/inequality constraints of the form
   //   (c,x-xc)=0.0 (or, alternatively, >= or <= ), where
   //   c is a random vector.
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P={2,4} and x0 is randomly selected from [-1,+2]^N
   // * we do not know analytic form of the solution, and, if fact, we do not
   //   check for solution correctness. We just check that algorithm converges
   //   to the feasible points.
      for (preckind = 0; preckind <= 2; preckind++) {
         for (pkind = 1; pkind <= 2; pkind++) {
            for (n = 1; n <= nmax; n++) {
               for (k = 1; k <= n; k++) {
               // Generate X, BL, BU.
                  p = 2 * pkind;
                  ae_vector_set_length(&x0, n);
                  ae_vector_set_length(&xc, n);
                  ae_vector_set_length(&xs, n);
                  ae_matrix_set_length(&c, k, n + 1);
                  ae_vector_set_length(&ct, k);
                  ae_vector_set_length(&bl, n);
                  ae_vector_set_length(&bu, n);
                  for (i = 0; i < n; i++) {
                     x0.xR[i] = 3.0 * randomreal() - 1.0;
                     xs.xR[i] = 3.0 * randomreal() - 1.0;
                     xc.xR[i] = 0.1 + 0.8 * randomreal();
                     bl.xR[i] = 0.0;
                     bu.xR[i] = 1.0;
                  }
                  for (i = 0; i < k; i++) {
                     c.xyR[i][n] = 0.0;
                     for (j = 0; j < n; j++) {
                        c.xyR[i][j] = randommid();
                        c.xyR[i][n] += c.xyR[i][j] * xc.xR[j];
                     }
                     ct.xZ[i] = randominteger(3) - 1;
                  }
               // Create and optimize
                  minbleiccreate(n, &xs, &state);
                  minbleicsetbc(&state, &bl, &bu);
                  minbleicsetlc(&state, &c, &ct, k);
                  minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbleicunit_setrandompreconditioner(&state, n, preckind);
                  while (minbleiciteration(&state)) {
                     if (state.needfg) {
                        state.f = 0.0;
                        for (i = 0; i < n; i++) {
                           state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                           state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                        }
                        continue;
                     }
                  // Unknown protocol specified
                     *interr = true;
                     ae_frame_leave();
                     return;
                  }
                  minbleicresults(&state, &x, &rep);
                  if (rep.terminationtype <= 0) {
                     set_error_flag(converr, true, __FILE__, __LINE__, "testminbleicunit.ap:751");
                     ae_frame_leave();
                     return;
                  }
               // Check feasibility
                  for (i = 0; i < n; i++) {
                     *feaserr = *feaserr || x.xR[i] < 0.0;
                     *feaserr = *feaserr || x.xR[i] > 1.0;
                  }
                  for (i = 0; i < k; i++) {
                     v = ae_v_dotproduct(c.xyR[i], 1, x.xR, 1, n);
                     v -= c.xyR[i][n];
                     if (ct.xZ[i] == 0) {
                        *feaserr = *feaserr || fabs(v) > epsfeas;
                     }
                     if (ct.xZ[i] < 0) {
                        *feaserr = *feaserr || v > epsfeas;
                     }
                     if (ct.xZ[i] > 0) {
                        *feaserr = *feaserr || v < -epsfeas;
                     }
                  }
               }
            }
         }
      }
   // Infeasible problem:
   // * all bound constraints are 0 <= x[i] <= 1 except for one
   // * that one is 0 >= x[i] >= 1
   // * no linear constraints
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from detecting
   //   infeasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P={2,4} and x0 is randomly selected from [-1,+2]^N
   // * algorithm must return correct error code on such problem
      for (preckind = 0; preckind <= 2; preckind++) {
         for (pkind = 1; pkind <= 2; pkind++) {
            for (n = 1; n <= nmax; n++) {
            // Generate X, BL, BU.
               p = 2 * pkind;
               ae_vector_set_length(&bl, n);
               ae_vector_set_length(&bu, n);
               ae_vector_set_length(&x, n);
               ae_vector_set_length(&x0, n);
               for (i = 0; i < n; i++) {
                  bl.xR[i] = 0.0;
                  bu.xR[i] = 1.0;
                  x.xR[i] = randomreal();
                  x0.xR[i] = 3.0 * randomreal() - 1.0;
               }
               i = randominteger(n);
               bl.xR[i] = 1.0;
               bu.xR[i] = 0.0;
            // Create and optimize
               minbleiccreate(n, &x, &state);
               minbleicsetbc(&state, &bl, &bu);
               minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
               testminbleicunit_setrandompreconditioner(&state, n, preckind);
               while (minbleiciteration(&state)) {
                  if (state.needfg) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                        state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                     }
                     continue;
                  }
               // Unknown protocol specified
                  *interr = true;
                  ae_frame_leave();
                  return;
               }
               minbleicresults(&state, &x, &rep);
               *feaserr = *feaserr || rep.terminationtype != -3;
            }
         }
      }
   // Infeasible problem (2):
   // * no bound and inequality constraints
   // * 1 <= K <= N arbitrary equality constraints
   // * (K+1)th constraint which is equal to the first constraint a*x=c,
   //   but with c:=c+1. I.e. we have both a*x=c and a*x=c+1, which can't
   //   be true (other constraints may be inconsistent too, but we don't
   //   have to check it).
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from detecting
   //   infeasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x|^P, where P={2,4}
   // * algorithm must return correct error code on such problem
      for (preckind = 0; preckind <= 2; preckind++) {
         for (pkind = 1; pkind <= 2; pkind++) {
            for (n = 1; n <= nmax; n++) {
               for (k = 1; k <= n; k++) {
               // Generate X, BL, BU.
                  p = 2 * pkind;
                  ae_vector_set_length(&x, n);
                  ae_matrix_set_length(&c, k + 1, n + 1);
                  ae_vector_set_length(&ct, k + 1);
                  for (i = 0; i < n; i++) {
                     x.xR[i] = randomreal();
                  }
                  for (i = 0; i < k; i++) {
                     for (j = 0; j <= n; j++) {
                        c.xyR[i][j] = randommid();
                     }
                     ct.xZ[i] = 0;
                  }
                  ct.xZ[k] = 0;
                  ae_v_move(c.xyR[k], 1, c.xyR[0], 1, n);
                  c.xyR[k][n] = c.xyR[0][n] + 1;
               // Create and optimize
                  minbleiccreate(n, &x, &state);
                  minbleicsetlc(&state, &c, &ct, k + 1);
                  minbleicsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbleicunit_setrandompreconditioner(&state, n, preckind);
                  while (minbleiciteration(&state)) {
                     if (state.needfg) {
                        state.f = 0.0;
                        for (i = 0; i < n; i++) {
                           state.f += pow(state.x.xR[i], (double)p);
                           state.g.xR[i] = p * pow(state.x.xR[i], (double)(p - 1));
                        }
                        continue;
                     }
                  // Unknown protocol specified
                     *interr = true;
                     ae_frame_leave();
                     return;
                  }
                  minbleicresults(&state, &x, &rep);
                  *feaserr = *feaserr || rep.terminationtype != -3;
               }
            }
         }
      }
   }
   ae_frame_leave();
}

// This function additional properties.
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testminbleicunit_testother(bool *err) {
   ae_frame _frame_block;
   ae_int_t passcount;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double fprev;
   double xprev;
   double stpmax;
   double v;
   ae_int_t nec;
   ae_int_t nic;
   ae_int_t pkind;
   ae_int_t ckind;
   ae_int_t mkind;
   double vc;
   double vm;
   double epsx;
   double epsg;
   double eps;
   double tmpeps;
   double diffstep;
   ae_int_t dkind;
   bool wasf;
   bool wasfg;
   double r;
   ae_int_t spoiliteration;
   ae_int_t stopiteration;
   ae_int_t spoilvar;
   double spoilval;
   double ss;
   ae_int_t stopcallidx;
   ae_int_t callidx;
   ae_int_t maxits;
   bool terminationrequested;
   ae_int_t scaletype;
   ae_frame_make(&_frame_block);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(xf, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewVector(a, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(h, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(minbleicstate, state);
   NewObj(minbleicreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   epsx = 1.0E-4;
   epsg = 1.0E-8;
   passcount = 10;
// Try to reproduce bug 570 (optimizer hangs on problems where it is required
// to perform very small step - less than 1E-50 - in order to activate constraints).
//
// The problem being solved is:
//
//     min x[0]+x[1]+...+x[n-1]
//
// subject to
//
//     x[i] >= 0, for i=0..n-1
//
// with initial point
//
//     x[0] = 1.0E-100, x[1]=x[2]=...=0.5
//
// We try to reproduce this problem in different settings:
// * boundary-only constraints - we test that completion code is positive,
//   and all x[] are EXACTLY zero
// * boundary constraints posed as general linear ones - we test that
//   completion code is positive, and all x[] are APPROXIMATELY zero.
   n = 10;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&bl, n);
   ae_vector_set_length(&bu, n);
   ae_matrix_set_length(&c, n, n + 1);
   ae_vector_set_length(&ct, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = 0.5;
      bl.xR[i] = 0.0;
      bu.xR[i] = +INFINITY;
      ct.xZ[i] = 1;
      for (j = 0; j <= n; j++) {
         c.xyR[i][j] = 0.0;
      }
      c.xyR[i][i] = 1.0;
   }
   x.xR[0] = 1.0E-100;
   minbleiccreate(n, &x, &state);
   minbleicsetbc(&state, &bl, &bu);
   minbleicsetcond(&state, 0.0, 0.0, 0.0, 2 * n);
   while (minbleiciteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += state.x.xR[i];
            state.g.xR[i] = 1.0;
         }
      }
   }
   minbleicresults(&state, &xf, &rep);
   set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbleicunit.ap:1030");
   if (rep.terminationtype > 0) {
      for (i = 0; i < n; i++) {
         set_error_flag(err, xf.xR[i] != 0.0, __FILE__, __LINE__, "testminbleicunit.ap:1033");
      }
   }
   minbleiccreate(n, &x, &state);
   minbleicsetlc(&state, &c, &ct, n);
   minbleicsetcond(&state, 1.0E-64, 0.0, 0.0, 10);
   while (minbleiciteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += state.x.xR[i];
            state.g.xR[i] = 1.0;
         }
      }
   }
   minbleicresults(&state, &xf, &rep);
   set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbleicunit.ap:1051");
   if (rep.terminationtype > 0) {
      for (i = 0; i < n; i++) {
         set_error_flag(err, fabs(xf.xR[i]) > 1.0E-10, __FILE__, __LINE__, "testminbleicunit.ap:1054");
      }
   }
// Test reports:
// * first value must be starting point
// * last value must be last point
   for (pass = 1; pass <= passcount; pass++) {
      n = 50;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      ae_vector_set_length(&bl, n);
      ae_vector_set_length(&bu, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 10.0;
         bl.xR[i] = randommid();
         bu.xR[i] = +INFINITY;
      }
      minbleiccreate(n, &x, &state);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetcond(&state, 1.0E-64, 0.0, 0.0, 10);
      minbleicsetxrep(&state, true);
      fprev = maxrealnumber;
      while (minbleiciteration(&state)) {
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += sqr((1 + i) * state.x.xR[i]);
               state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
            }
         }
         if (state.xupdated) {
            if (fprev == maxrealnumber) {
               for (i = 0; i < n; i++) {
                  *err = *err || state.x.xR[i] != x.xR[i];
               }
            }
            fprev = state.f;
            ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
         }
      }
      minbleicresults(&state, &x, &rep);
      for (i = 0; i < n; i++) {
         *err = *err || x.xR[i] != xlast.xR[i];
      }
   }
// Test differentiation vs. analytic gradient
// (first one issues NeedF requests, second one issues NeedFG requests)
   for (pass = 1; pass <= passcount; pass++) {
      n = 10;
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xlast, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 1.0;
         }
         if (dkind == 0) {
            minbleiccreate(n, &x, &state);
         }
         if (dkind == 1) {
            minbleiccreatef(n, &x, diffstep, &state);
         }
         minbleicsetcond(&state, 1.0E-6, 0.0, epsx, 0);
         wasf = false;
         wasfg = false;
         while (minbleiciteration(&state)) {
            if (state.needf || state.needfg) {
               state.f = 0.0;
            }
            for (i = 0; i < n; i++) {
               if (state.needf || state.needfg) {
                  state.f += sqr((1 + i) * state.x.xR[i]);
               }
               if (state.needfg) {
                  state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
               }
            }
            wasf = wasf || state.needf;
            wasfg = wasfg || state.needfg;
         }
         minbleicresults(&state, &x, &rep);
         if (dkind == 0) {
            *err = (*err || wasf) || !wasfg;
         }
         if (dkind == 1) {
            *err = (*err || !wasf) || wasfg;
         }
      }
   }
// Test that numerical differentiation uses scaling.
//
// In order to test that we solve simple optimization
// problem: min(x^2) with initial x equal to 0.0.
//
// We choose random DiffStep and S, then we check that
// optimizer evaluates function at +-DiffStep*S only.
   for (pass = 1; pass <= passcount; pass++) {
      ae_vector_set_length(&x, 1);
      ae_vector_set_length(&s, 1);
      diffstep = randomreal() * 1.0E-6;
      s.xR[0] = exp(randomreal() * 4 - 2);
      x.xR[0] = 0.0;
      minbleiccreatef(1, &x, diffstep, &state);
      minbleicsetcond(&state, 1.0E-6, 0.0, epsx, 0);
      minbleicsetscale(&state, &s);
      v = 0.0;
      while (minbleiciteration(&state)) {
         state.f = sqr(state.x.xR[0]);
         v = rmax2(v, fabs(state.x.xR[0]));
      }
      minbleicresults(&state, &x, &rep);
      r = v / (s.xR[0] * diffstep);
      *err = *err || fabs(log(r)) > log(1 + 1000 * machineepsilon);
   }
// Test stpmax
   for (pass = 1; pass <= passcount; pass++) {
      n = 1;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&bl, n);
      ae_vector_set_length(&bu, n);
      x.xR[0] = 100.0;
      bl.xR[0] = randommid();
      bu.xR[0] = +INFINITY;
      stpmax = 0.05 + 0.05 * randomreal();
      minbleiccreate(n, &x, &state);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetcond(&state, epsg, 0.0, epsx, 0);
      minbleicsetxrep(&state, true);
      minbleicsetstpmax(&state, stpmax);
      xprev = x.xR[0];
      while (minbleiciteration(&state)) {
         if (state.needfg) {
            state.f = exp(state.x.xR[0]) + exp(-state.x.xR[0]);
            state.g.xR[0] = exp(state.x.xR[0]) - exp(-state.x.xR[0]);
            *err = *err || fabs(state.x.xR[0] - xprev) > (1 + sqrt(machineepsilon)) * stpmax;
         }
         if (state.xupdated) {
            *err = *err || fabs(state.x.xR[0] - xprev) > (1 + sqrt(machineepsilon)) * stpmax;
            xprev = state.x.xR[0];
         }
      }
   }
// Ability to solve problems with function which is unbounded from below
   for (pass = 1; pass <= passcount; pass++) {
      n = 1;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&bl, n);
      ae_vector_set_length(&bu, n);
      bl.xR[0] = 4 * randomreal() + 1;
      bu.xR[0] = bl.xR[0] + 1;
      x.xR[0] = 0.5 * (bl.xR[0] + bu.xR[0]);
      minbleiccreate(n, &x, &state);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetcond(&state, epsg, 0.0, epsx, 0);
      while (minbleiciteration(&state)) {
         if (state.needfg) {
            state.f = -1.0E8 * sqr(state.x.xR[0]);
            state.g.xR[0] = -2.0E8 * state.x.xR[0];
         }
      }
      minbleicresults(&state, &x, &rep);
      *err = *err || fabs(x.xR[0] - bu.xR[0]) > epsx;
   }
// Test correctness of the scaling:
// * initial point is random point from [+1,+2]^N
// * f(x) = SUM(A[i]*x[i]^4), C[i] is random from [0.01,100]
// * function is EFFECTIVELY unconstrained; it has formal constraints,
//   but they are inactive at the solution; we try different variants
//   in order to explore different control paths of the optimizer:
//   0) absense of constraints
//   1) bound constraints -100000 <= x[i] <= 100000
//   2) one linear constraint 0*x=0
//   3) combination of (1) and (2)
// * we use random scaling matrix
// * we test different variants of the preconditioning:
//   0) unit preconditioner
//   1) random diagonal from [0.01,100]
//   2) scale preconditioner
// * we set very stringent stopping conditions
// * and we test that in the extremum stopping conditions are
//   satisfied subject to the current scaling coefficients.
   for (pass = 1; pass <= passcount; pass++) {
      tmpeps = 1.0E-5;
      for (n = 1; n <= 10; n++) {
         for (ckind = 0; ckind <= 3; ckind++) {
            for (pkind = 0; pkind <= 2; pkind++) {
               ae_vector_set_length(&x, n);
               ae_vector_set_length(&a, n);
               ae_vector_set_length(&s, n);
               ae_vector_set_length(&h, n);
               ae_vector_set_length(&bl, n);
               ae_vector_set_length(&bu, n);
               ae_matrix_set_length(&c, 1, n + 1);
               ae_vector_set_length(&ct, 1);
               ct.xZ[0] = 0;
               c.xyR[0][n] = 0.0;
               for (i = 0; i < n; i++) {
                  x.xR[i] = randomreal() + 1;
                  bl.xR[i] = -100000.0;
                  bu.xR[i] = 100000.0;
                  c.xyR[0][i] = 0.0;
                  a.xR[i] = exp(log(10.0) * randommid());
                  s.xR[i] = exp(log(10.0) * randommid());
                  h.xR[i] = exp(log(10.0) * randommid());
               }
               minbleiccreate(n, &x, &state);
               if (ckind == 1 || ckind == 3) {
                  minbleicsetbc(&state, &bl, &bu);
               }
               if (ckind == 2 || ckind == 3) {
                  minbleicsetlc(&state, &c, &ct, 1);
               }
               if (pkind == 1) {
                  minbleicsetprecdiag(&state, &h);
               }
               if (pkind == 2) {
                  minbleicsetprecscale(&state);
               }
               minbleicsetcond(&state, tmpeps, 0.0, 0.0, 0);
               minbleicsetscale(&state, &s);
               while (minbleiciteration(&state)) {
                  if (state.needfg) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += a.xR[i] * sqr(state.x.xR[i]);
                        state.g.xR[i] = 2 * a.xR[i] * state.x.xR[i];
                     }
                  }
               }
               minbleicresults(&state, &x, &rep);
               if (rep.terminationtype <= 0) {
                  *err = true;
                  ae_frame_leave();
                  return;
               }
               v = 0.0;
               for (i = 0; i < n; i++) {
                  v += sqr(s.xR[i] * 2 * a.xR[i] * x.xR[i]);
               }
               v = sqrt(v);
               set_error_flag(err, v > tmpeps, __FILE__, __LINE__, "testminbleicunit.ap:1320");
            }
         }
      }
   }
// Check correctness of the "trimming".
//
// Trimming is a technique which is used to help algorithm
// cope with unbounded functions. In order to check this
// technique we will try to solve following optimization
// problem:
//
//     min f(x) subject to no constraints on X
//            { 1/(1-x) + 1/(1+x) + c*x, if -0.999999<x<0.999999
//     f(x) = {
//            { M, if x <= -0.999999 or x >= 0.999999
//
// where c is either 1.0 or 1.0E+4, M is either 1.0E8, 1.0E20 or +INF
// (we try different combinations)
   for (pass = 1; pass <= passcount; pass++) {
      for (ckind = 0; ckind <= 1; ckind++) {
         for (mkind = 0; mkind <= 2; mkind++) {
         // Choose c and M
            vc = 1.0;
            vm = 1.0;
            if (ckind == 0) {
               vc = 1.0;
            }
            if (ckind == 1) {
               vc = 1.0E+4;
            }
            if (mkind == 0) {
               vm = 1.0E+8;
            }
            if (mkind == 1) {
               vm = 1.0E+20;
            }
            if (mkind == 2) {
               vm = +INFINITY;
            }
         // Create optimizer, solve optimization problem
            epsg = 1.0E-6 * vc;
            ae_vector_set_length(&x, 1);
            x.xR[0] = 0.0;
            minbleiccreate(1, &x, &state);
            minbleicsetcond(&state, epsg, 0.0, 0.0, 0);
            while (minbleiciteration(&state)) {
               if (state.needfg) {
                  if (-0.999999 < state.x.xR[0] && state.x.xR[0] < 0.999999) {
                     state.f = 1 / (1 - state.x.xR[0]) + 1 / (1 + state.x.xR[0]) + vc * state.x.xR[0];
                     state.g.xR[0] = 1 / sqr(1 - state.x.xR[0]) - 1 / sqr(1 + state.x.xR[0]) + vc;
                  } else {
                     state.f = vm;
                     state.g.xR[0] = 0.0;
                  }
               }
            }
            minbleicresults(&state, &x, &rep);
            if (rep.terminationtype <= 0) {
               *err = true;
               ae_frame_leave();
               return;
            }
            *err = *err || fabs(1 / sqr(1 - x.xR[0]) - 1 / sqr(1 + x.xR[0]) + vc) > epsg;
         }
      }
   }
// Test behaviour on noisy functions.
//
// Consider following problem:
// * f(x,y) = (x+1)^2 + (y+1)^2 + 10000*MachineEpsilon*RandomReal()
// * boundary constraints x >= 0, y >= 0
// * starting point (x0,y0)=(10*MachineEpsilon,1.0)
//
// Such problem contains small numerical noise. Without noise its
// solution is (xs,ys)=(0,0), which is easy to find. However, presence
// of the noise makes it hard to solve:
// * noisy f(x,y) is monotonically decreasing only when we perform
//   steps orders of magnitude larger than 10000*MachineEpsilon
// * at small scales f(x,y) is non-monotonic and non-convex
// * however, our first step must be done towards
//   (x1,y1) = (0,1-some_small_value), and length of such step is
//   many times SMALLER than 10000*MachineEpsilon
// * second step, from (x1,y1) to (xs,ys), will be large enough to
//   ignore numerical noise, so the only problem is to perform
//   first step
//
// Naive implementation of BLEIC should fail sometimes (sometimes -
// due to non-deterministic nature of noise) on such problem. However,
// our improved implementation should solve it correctly. We test
// several variations of inner stopping criteria.
   for (pass = 1; pass <= passcount; pass++) {
      eps = 1.0E-9;
      ae_vector_set_length(&x, 2);
      ae_vector_set_length(&bl, 2);
      ae_vector_set_length(&bu, 2);
      x.xR[0] = 10 * machineepsilon;
      x.xR[1] = 1.0;
      bl.xR[0] = 0.0;
      bu.xR[0] = +INFINITY;
      bl.xR[1] = 0.0;
      bu.xR[1] = +INFINITY;
      for (ckind = 0; ckind <= 2; ckind++) {
         minbleiccreate(2, &x, &state);
         minbleicsetbc(&state, &bl, &bu);
         if (ckind == 0) {
            minbleicsetcond(&state, eps, 0.0, 0.0, 0);
         }
         if (ckind == 1) {
            minbleicsetcond(&state, 0.0, eps, 0.0, 0);
         }
         if (ckind == 2) {
            minbleicsetcond(&state, 0.0, 0.0, eps, 0);
         }
         while (minbleiciteration(&state)) {
            if (state.needfg) {
               state.f = sqr(state.x.xR[0] + 1) + sqr(state.x.xR[1] + 1) + 10000 * machineepsilon * randomreal();
               state.g.xR[0] = 2 * (state.x.xR[0] + 1);
               state.g.xR[1] = 2 * (state.x.xR[1] + 1);
            }
         }
         minbleicresults(&state, &xf, &rep);
         if ((rep.terminationtype <= 0 || xf.xR[0] != 0.0) || xf.xR[1] != 0.0) {
            *err = true;
            ae_frame_leave();
            return;
         }
      }
   }
// Deterministic variation of the previous problem.
//
// Consider following problem:
// * boundary constraints x >= 0, y >= 0
// * starting point (x0,y0)=(10*MachineEpsilon,1.0)
//            / (x+1)^2 + (y+1)^2,        for (x,y) != (x0,y0)
// * f(x,y) = |
//            \ (x+1)^2 + (y+1)^2 - 0.1,  for (x,y)=(x0,y0)
//
// Such problem contains deterministic numerical noise (-0.1 at
// starting point). Without noise its solution is easy to find.
// However, presence of the noise makes it hard to solve:
// * our first step must be done towards (x1,y1) = (0,1-some_small_value),
//   but such step will increase function valye by approximately 0.1  -
//   instead of decreasing it.
//
// Naive implementation of BLEIC should fail on such problem. However,
// our improved implementation should solve it correctly. We test
// several variations of inner stopping criteria.
   for (pass = 1; pass <= passcount; pass++) {
      eps = 1.0E-9;
      ae_vector_set_length(&x, 2);
      ae_vector_set_length(&bl, 2);
      ae_vector_set_length(&bu, 2);
      x.xR[0] = 10 * machineepsilon;
      x.xR[1] = 1.0;
      bl.xR[0] = 0.0;
      bu.xR[0] = +INFINITY;
      bl.xR[1] = 0.0;
      bu.xR[1] = +INFINITY;
      for (ckind = 0; ckind <= 2; ckind++) {
         minbleiccreate(2, &x, &state);
         minbleicsetbc(&state, &bl, &bu);
         if (ckind == 0) {
            minbleicsetcond(&state, eps, 0.0, 0.0, 0);
         }
         if (ckind == 1) {
            minbleicsetcond(&state, 0.0, eps, 0.0, 0);
         }
         if (ckind == 2) {
            minbleicsetcond(&state, 0.0, 0.0, eps, 0);
         }
         while (minbleiciteration(&state)) {
            if (state.needfg) {
               state.f = sqr(state.x.xR[0] + 1) + sqr(state.x.xR[1] + 1);
               if (state.x.xR[0] == x.xR[0] && state.x.xR[1] == x.xR[1]) {
                  state.f -= 0.1;
               }
               state.g.xR[0] = 2 * (state.x.xR[0] + 1);
               state.g.xR[1] = 2 * (state.x.xR[1] + 1);
            }
         }
         minbleicresults(&state, &xf, &rep);
         if ((rep.terminationtype <= 0 || xf.xR[0] != 0.0) || xf.xR[1] != 0.0) {
            *err = true;
            ae_frame_leave();
            return;
         }
      }
   }
// Test integrity checks for NAN/INF:
// * algorithm solves optimization problem, which is normal for some time (quadratic)
// * after 5-th step we choose random component of gradient and consistently spoil
//   it by NAN or INF.
// * we check that correct termination code is returned (-8)
   n = 100;
   for (pass = 1; pass <= 10; pass++) {
      spoiliteration = 5;
      stopiteration = 8;
      if (hqrndnormal(&rs) > 0.0) {
      // Gradient can be spoiled by +INF, -INF, NAN
         spoilvar = hqrnduniformi(&rs, n);
         i = hqrnduniformi(&rs, 3);
         spoilval = NAN;
         if (i == 0) {
            spoilval = -INFINITY;
         }
         if (i == 1) {
            spoilval = +INFINITY;
         }
      } else {
      // Function value can be spoiled only by NAN
      // (+INF can be recognized as legitimate value during optimization)
         spoilvar = -1;
         spoilval = NAN;
      }
      spdmatrixrndcond(n, 1.0E5, &fulla);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         b.xR[i] = hqrndnormal(&rs);
         x0.xR[i] = hqrndnormal(&rs);
      }
      minbleiccreate(n, &x0, &state);
      minbleicsetcond(&state, 0.0, 0.0, 0.0, stopiteration);
      minbleicsetxrep(&state, true);
      k = -1;
      while (minbleiciteration(&state)) {
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += b.xR[i] * state.x.xR[i];
               state.g.xR[i] = b.xR[i];
               for (j = 0; j < n; j++) {
                  state.f += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                  state.g.xR[i] += fulla.xyR[i][j] * state.x.xR[j];
               }
            }
            if (k >= spoiliteration) {
               if (spoilvar < 0) {
                  state.f = spoilval;
               } else {
                  state.g.xR[spoilvar] = spoilval;
               }
            }
            continue;
         }
         if (state.xupdated) {
            k++;
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minbleicresults(&state, &x1, &rep);
      set_error_flag(err, rep.terminationtype != -8, __FILE__, __LINE__, "testminbleicunit.ap:1603");
   }
// Check algorithm ability to handle request for termination:
// * to terminate with correct return code = 8
// * to return point which was "current" at the moment of termination
//
// NOTE: we solve problem with "corrupted" preconditioner which makes it hard
//       to converge in less than StopCallIdx iterations
   for (pass = 1; pass <= 50; pass++) {
      n = 3;
      ss = 100.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 6 + randomreal();
      }
      ae_vector_set_length(&s, 3);
      s.xR[0] = 0.00001;
      s.xR[1] = 0.00001;
      s.xR[2] = 10000.0;
      stopcallidx = randominteger(20);
      maxits = 25;
      minbleiccreate(n, &x, &state);
      minbleicsetcond(&state, 0.0, 0.0, 0.0, maxits);
      minbleicsetxrep(&state, true);
      minbleicsetprecdiag(&state, &s);
      callidx = 0;
      terminationrequested = false;
      ae_v_move(xlast.xR, 1, x.xR, 1, n);
      while (minbleiciteration(&state)) {
         if (state.needfg) {
            state.f = ss * sqr(exp(state.x.xR[0]) - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
            state.g.xR[0] = 2 * ss * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[2] - state.x.xR[0]) * (-1);
            state.g.xR[1] = 2 * state.x.xR[1];
            state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
            if (callidx == stopcallidx) {
               minbleicrequesttermination(&state);
               terminationrequested = true;
            }
            callidx++;
            continue;
         }
         if (state.xupdated) {
            if (!terminationrequested) {
               ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minbleicresults(&state, &x, &rep);
      set_error_flag(err, rep.terminationtype != 8, __FILE__, __LINE__, "testminbleicunit.ap:1661");
      for (i = 0; i < n; i++) {
         set_error_flag(err, x.xR[i] != xlast.xR[i], __FILE__, __LINE__, "testminbleicunit.ap:1663");
      }
   }
// N-dimensional problem with Ne equality and Ni inequality constraints.
//
// Check that internal SActiveSet object uses efficient algorithm
// to determine initial point: it avoids expensive (N+Ni)-dimensional
// QP subproblem when initial point is feasible w.r.t. constraints.
//
// In order to do so we try to solve 5-dimensional QP problem with
// 2 equality constraints and 1000000 inequality constraints (+box
// constraints). Inefficient algorithm will simply fail to allocate
// enough memory, so we do not have to perform any checks here.
   n = 5;
   nec = 2;
   nic = 1000000;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&bl, n);
   ae_vector_set_length(&bu, n);
   for (scaletype = 0; scaletype <= 1; scaletype++) {
   // Generate problem
      for (i = 0; i < n; i++) {
         x.xR[i] = hqrnduniformr(&rs);
         bl.xR[i] = x.xR[i] - hqrnduniformr(&rs) * hqrnduniformi(&rs, 2);
         bu.xR[i] = x.xR[i] + hqrnduniformr(&rs) * hqrnduniformi(&rs, 2);
      }
      ae_matrix_set_length(&c, nec + nic, n + 1);
      ae_vector_set_length(&ct, nec + nic);
      for (i = 0; i < nec + nic; i++) {
         v = 0.0;
         for (j = 0; j < n; j++) {
            c.xyR[i][j] = hqrndnormal(&rs);
            v += c.xyR[i][j] * x.xR[j];
         }
         c.xyR[i][n] = v;
         if (i < nec) {
            ct.xZ[i] = 0;
         } else {
            c.xyR[i][n] += 0.1;
            ct.xZ[i] = -1;
         }
      }
   // Apply scaling (if needed), then randomly multiply C by
   // some large/small value in order to distort magnitude of
   // linear constraints.
   //
   // Correct SActiveSet implementation must be able to renormalize
   // constraints prior to checking feasibility of initial point.
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 1.0;
         if (scaletype != 0) {
            s.xR[i] = pow(10.0, 40 * hqrnduniformr(&rs) - 20);
         }
         x.xR[i] *= s.xR[i];
         bl.xR[i] *= s.xR[i];
         bu.xR[i] *= s.xR[i];
         for (j = 0; j < nec + nic; j++) {
            c.xyR[j][i] /= s.xR[i];
         }
      }
      for (i = 0; i < nec + nic; i++) {
         v = pow(10.0, 40 * hqrnduniformr(&rs) - 20);
         ae_v_muld(c.xyR[i], 1, n + 1, v);
      }
   // Solve
      minbleiccreate(n, &x, &state);
      minbleicsetscale(&state, &s);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetlc(&state, &c, &ct, nec + nic);
      minbleicsetcond(&state, 0.0, 0.0, 0.0, 1);
      while (minbleiciteration(&state)) {
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += state.x.xR[i];
               state.g.xR[i] = 1.0;
            }
         }
      }
      minbleicresults(&state, &xf, &rep);
   }
// Test that SActiveSet object prevents steps which increase infeasibility.
// In order to do so we:
// * generate random SPD matrix A with moderate condition number ~1E3
//   and huge norm (about 1E9)
// * generate random initial point x0 with unit norm
// * generate single linear constraint c'*x >= c'*x0, with c=A*x0
// * run BLEIC algorithm from initial point x0 for target function f=0.5*x'*A*x
//   and check that it stops at x0 (less than 1E-12 away from it)
   n = 20;
   for (pass = 0; pass <= 20000; pass++) {
      spdmatrixrndcond(n, 1.0E3, &fulla);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            fulla.xyR[i][j] *= 1.0E9;
         }
      }
      ae_vector_set_length(&x0, n);
      v = 0.0;
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrnduniformr(&rs);
         v += sqr(x0.xR[i]);
      }
      ae_assert(v > 0.0, "MinBLEIC: integrity check failed in the unit test");
      for (i = 0; i < n; i++) {
         x0.xR[i] /= sqrt(v);
      }
      ae_matrix_set_length(&c, 1, n + 1);
      ae_vector_set_length(&ct, 1);
      ct.xZ[0] = 1;
      c.xyR[0][n] = 0.0;
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(fulla.xyR[i], 1, x0.xR, 1, n);
         c.xyR[0][i] = v;
         c.xyR[0][n] += v * x0.xR[i];
      }
      ae_assert(c.xyR[0][n] > 0.0, "MinBLEIC: integrity check failed in the unit test");
      minbleiccreate(n, &x0, &state);
      minbleicsetlc(&state, &c, &ct, 1);
      minbleicsetcond(&state, 0.0, 0.0, 1.0E-15, 0);
      while (minbleiciteration(&state)) {
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(fulla.xyR[i], 1, state.x.xR, 1, n);
               state.f += 0.5 * v * state.x.xR[i];
               state.g.xR[i] = v;
            }
         }
      }
      minbleicresults(&state, &xf, &rep);
      set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbleicunit.ap:1819");
      for (i = 0; i < n; i++) {
         set_error_flag(err, fabs(x0.xR[i] - xf.xR[i]) > 1.0E-12, __FILE__, __LINE__, "testminbleicunit.ap:1821");
      }
   }
   ae_frame_leave();
}

// This function tests convergence properties.
// We solve several simple problems with different combinations of constraints
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testminbleicunit_testconv(bool *err) {
   ae_frame _frame_block;
   ae_int_t passcount;
   ae_int_t pass;
   double epsg;
   double epsfeas;
   double tol;
   ae_int_t m;
   ae_int_t n;
   ae_int_t k;
   ae_int_t i;
   ae_int_t j;
   double v;
   double vv;
   ae_int_t preckind;
   ae_int_t akind;
   ae_int_t shiftkind;
   ae_int_t bscale;
   double tolconstr;
   double f0;
   double f1;
   ae_int_t ccnt;
   ae_frame_make(&_frame_block);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(xf, 0, DT_REAL);
   NewVector(xs0, 0, DT_REAL);
   NewVector(xs1, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(ce, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewVector(nonnegative, 0, DT_BOOL);
   NewObj(minbleicstate, state);
   NewObj(minbleicreport, rep);
   NewObj(snnlssolver, nnls);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   epsg = 1.0E-8;
   epsfeas = 1.0E-8;
   tol = 0.001;
   passcount = 10;
// Three closely connected problems:
// * 2-dimensional space
// * octagonal area bounded by:
//   * -1 <= x <= +1
//   * -1 <= y <= +1
//   * x+y <= 1.5
//   * x-y <= 1.5
//   * -x+y <= 1.5
//   * -x-y <= 1.5
// * several target functions:
//   * f0=x+0.001*y, minimum at x=-1, y=-0.5
//   * f1=(x+10)^2+y^2, minimum at x=-1, y=0
//   * f2=(x+10)^2+(y-0.6)^2, minimum at x=-1, y=0.5
   ae_vector_set_length(&x, 2);
   ae_vector_set_length(&bl, 2);
   ae_vector_set_length(&bu, 2);
   ae_matrix_set_length(&c, 4, 3);
   ae_vector_set_length(&ct, 4);
   bl.xR[0] = -1.0;
   bl.xR[1] = -1.0;
   bu.xR[0] = 1.0;
   bu.xR[1] = 1.0;
   c.xyR[0][0] = 1.0;
   c.xyR[0][1] = 1.0;
   c.xyR[0][2] = 1.5;
   ct.xZ[0] = -1;
   c.xyR[1][0] = 1.0;
   c.xyR[1][1] = -1.0;
   c.xyR[1][2] = 1.5;
   ct.xZ[1] = -1;
   c.xyR[2][0] = -1.0;
   c.xyR[2][1] = 1.0;
   c.xyR[2][2] = 1.5;
   ct.xZ[2] = -1;
   c.xyR[3][0] = -1.0;
   c.xyR[3][1] = -1.0;
   c.xyR[3][2] = 1.5;
   ct.xZ[3] = -1;
   for (pass = 1; pass <= passcount; pass++) {
   // f0
      x.xR[0] = 0.1 * randommid();
      x.xR[1] = 0.1 * randommid();
      minbleiccreate(2, &x, &state);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetlc(&state, &c, &ct, 4);
      minbleicsetcond(&state, epsg, 0.0, 0.0, 0);
      while (minbleiciteration(&state)) {
         if (state.needfg) {
            state.f = state.x.xR[0] + 0.001 * state.x.xR[1];
            state.g.xR[0] = 1.0;
            state.g.xR[1] = 0.001;
         }
      }
      minbleicresults(&state, &x, &rep);
      if (rep.terminationtype > 0) {
         set_error_flag(err, fabs(x.xR[0] + 1) > tol, __FILE__, __LINE__, "testminbleicunit.ap:1935");
         set_error_flag(err, fabs(x.xR[1] + 0.5) > tol, __FILE__, __LINE__, "testminbleicunit.ap:1936");
      } else {
         set_error_flag(err, true, __FILE__, __LINE__, "testminbleicunit.ap:1939");
      }
   // f1
      x.xR[0] = 0.1 * randommid();
      x.xR[1] = 0.1 * randommid();
      minbleiccreate(2, &x, &state);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetlc(&state, &c, &ct, 4);
      minbleicsetcond(&state, epsg, 0.0, 0.0, 0);
      while (minbleiciteration(&state)) {
         if (state.needfg) {
            state.f = sqr(state.x.xR[0] + 10) + sqr(state.x.xR[1]);
            state.g.xR[0] = 2 * (state.x.xR[0] + 10);
            state.g.xR[1] = 2 * state.x.xR[1];
         }
      }
      minbleicresults(&state, &x, &rep);
      if (rep.terminationtype > 0) {
         set_error_flag(err, fabs(x.xR[0] + 1) > tol, __FILE__, __LINE__, "testminbleicunit.ap:1962");
         set_error_flag(err, fabs(x.xR[1]) > tol, __FILE__, __LINE__, "testminbleicunit.ap:1963");
      } else {
         set_error_flag(err, true, __FILE__, __LINE__, "testminbleicunit.ap:1966");
      }
   // f2
      x.xR[0] = 0.1 * randommid();
      x.xR[1] = 0.1 * randommid();
      minbleiccreate(2, &x, &state);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetlc(&state, &c, &ct, 4);
      minbleicsetcond(&state, epsg, 0.0, 0.0, 0);
      while (minbleiciteration(&state)) {
         if (state.needfg) {
            state.f = sqr(state.x.xR[0] + 10) + sqr(state.x.xR[1] - 0.6);
            state.g.xR[0] = 2 * (state.x.xR[0] + 10);
            state.g.xR[1] = 2 * (state.x.xR[1] - 0.6);
         }
      }
      minbleicresults(&state, &x, &rep);
      if (rep.terminationtype > 0) {
         set_error_flag(err, fabs(x.xR[0] + 1) > tol, __FILE__, __LINE__, "testminbleicunit.ap:1989");
         set_error_flag(err, fabs(x.xR[1] - 0.5) > tol, __FILE__, __LINE__, "testminbleicunit.ap:1990");
      } else {
         set_error_flag(err, true, __FILE__, __LINE__, "testminbleicunit.ap:1993");
      }
   }
// Degenerate optimization problem with excessive constraints.
//
// * N=3..10, M=N div 3, K = 2*N
// * f(x) = 0.5*|A*x-b|^2, where A is MxN random matrix, b is Mx1 random vector
// * bound constraint:
//   a) Ci=x[i]=Ci  for i=0..M-1
//   b) 0 <= x[i] <= 1  for i=M..N-1
// * linear constraints (for fixed feasible xf and random ai):
//   a) ai*x  = ai*xf                   for i=0..M-1
//   b) ai*x <= ai*xf+random(0.1,1.0)   for i=M..K-1
// * preconditioner is chosen at random (we just want to be
//   sure that preconditioning won't prevent us from detecting
//   infeasible point):
//   a) unit preconditioner
//   b) random diagonal-based preconditioner
//   c) random scale-based preconditioner
// * we choose two random initial points from interior of the area
//   given by bound constraints.
//
// We do not know analytic solution of this problem, and we do not need
// to solve it :) we just perform two restarts from two different initial
// points and check that both solutions give approximately same function
// value.
   for (preckind = 0; preckind <= 2; preckind++) {
      for (n = 3; n <= 10; n++) {
      // Generate problem
         m = n / 3;
         k = 2 * n;
         ae_vector_set_length(&bl, n);
         ae_vector_set_length(&bu, n);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xs0, n);
         ae_vector_set_length(&xs1, n);
         ae_vector_set_length(&xf, n);
         for (i = 0; i < n; i++) {
            if (i < m) {
               v = randomreal();
               bl.xR[i] = v;
               bu.xR[i] = v;
               xf.xR[i] = v;
               xs0.xR[i] = v;
               xs1.xR[i] = v;
            } else {
               bl.xR[i] = 0.0;
               bu.xR[i] = 1.0;
               xf.xR[i] = randomreal();
               xs0.xR[i] = randomreal();
               xs1.xR[i] = randomreal();
            }
            x.xR[i] = randomreal();
         }
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < k; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = randomnormal();
               v += sqr(c.xyR[i][j]);
            }
            if (v > 0.0) {
               for (j = 0; j < n; j++) {
                  c.xyR[i][j] /= sqrt(v);
               }
            }
            v = ae_v_dotproduct(c.xyR[i], 1, xf.xR, 1, n);
            c.xyR[i][n] = v;
            if (i < m) {
               ct.xZ[i] = 0;
            } else {
               ct.xZ[i] = -1;
               c.xyR[i][n] += 0.1 + 0.9 * randomreal();
            }
         }
         ae_matrix_set_length(&a, m, n + 1);
         for (i = 0; i < m; i++) {
            for (j = 0; j <= n; j++) {
               a.xyR[i][j] = randomreal();
            }
         }
      // Create and optimize
         minbleiccreate(n, &x, &state);
         minbleicsetbc(&state, &bl, &bu);
         minbleicsetlc(&state, &c, &ct, k);
         minbleicsetcond(&state, epsg, 0.0, 0.0, 0);
         testminbleicunit_setrandompreconditioner(&state, n, preckind);
      // Solve problem 0:
      // * restart from XS0
      // * solve
      // * check convergence/feasibility
      // * calculate F0 - function value at solution
         minbleicrestartfrom(&state, &xs0);
         while (minbleiciteration(&state)) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.g.xR[i] = 0.0;
            }
            for (i = 0; i < m; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
               v -= a.xyR[i][n];
               state.f += 0.5 * sqr(v);
               ae_v_addd(state.g.xR, 1, a.xyR[i], 1, n, v);
            }
         }
         minbleicresults(&state, &x, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(err, true, __FILE__, __LINE__, "testminbleicunit.ap:2117");
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            if (x.xR[i] < bl.xR[i] || x.xR[i] > bu.xR[i]) {
               set_error_flag(err, true, __FILE__, __LINE__, "testminbleicunit.ap:2123");
               ae_frame_leave();
               return;
            }
         }
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(c.xyR[i], 1, x.xR, 1, n);
            v -= c.xyR[i][n];
            if (ct.xZ[i] == 0 && fabs(v) > epsfeas) {
               set_error_flag(err, true, __FILE__, __LINE__, "testminbleicunit.ap:2132");
               ae_frame_leave();
               return;
            }
            if (ct.xZ[i] < 0 && v > epsfeas) {
               set_error_flag(err, true, __FILE__, __LINE__, "testminbleicunit.ap:2137");
               ae_frame_leave();
               return;
            }
         }
         f0 = 0.0;
         for (i = 0; i < m; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
            v -= a.xyR[i][n];
            f0 += 0.5 * sqr(v);
         }
      // Solve problem 1:
      // * restart from XS1
      // * solve
      // * check convergence/feasibility
      // * calculate F1 - function value at solution
         minbleicrestartfrom(&state, &xs1);
         while (minbleiciteration(&state)) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.g.xR[i] = 0.0;
            }
            for (i = 0; i < m; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
               v -= a.xyR[i][n];
               state.f += 0.5 * sqr(v);
               ae_v_addd(state.g.xR, 1, a.xyR[i], 1, n, v);
            }
         }
         minbleicresults(&state, &x, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(err, true, __FILE__, __LINE__, "testminbleicunit.ap:2173");
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            if (x.xR[i] < bl.xR[i] || x.xR[i] > bu.xR[i]) {
               set_error_flag(err, true, __FILE__, __LINE__, "testminbleicunit.ap:2179");
               ae_frame_leave();
               return;
            }
         }
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(c.xyR[i], 1, x.xR, 1, n);
            v -= c.xyR[i][n];
            if (ct.xZ[i] == 0 && fabs(v) > epsfeas) {
               set_error_flag(err, true, __FILE__, __LINE__, "testminbleicunit.ap:2188");
               ae_frame_leave();
               return;
            }
            if (ct.xZ[i] < 0 && v > epsfeas) {
               set_error_flag(err, true, __FILE__, __LINE__, "testminbleicunit.ap:2193");
               ae_frame_leave();
               return;
            }
         }
         f1 = 0.0;
         for (i = 0; i < m; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
            v -= a.xyR[i][n];
            f1 += 0.5 * sqr(v);
         }
      // compare F0 and F1
         set_error_flag(err, fabs(f0 - f1) > 1.0E-4, __FILE__, __LINE__, "testminbleicunit.ap:2208");
      }
   }
// Convex/nonconvex optimization problem with excessive
// (degenerate constraints):
//
// * N=2..8
// * f = 0.5*x'*A*x+b'*x
// * b has normally distributed entries with scale 10^BScale
// * several kinds of A are tried: zero, well conditioned SPD, well conditioned indefinite, low rank
// * box constraints: x[i] in [-1,+1]
// * 2^N "excessive" general linear constraints (v_k,x) <= (v_k,v_k)+v_shift,
//   where v_k is one of 2^N vertices of feasible hypercube, v_shift is
//   a shift parameter:
//   * with zero v_shift such constraints are degenerate (each vertex has
//     N box constraints and one "redundant" linear constraint)
//   * with positive v_shift linear constraint is always inactive
//   * with small (about machine epsilon) but negative v_shift,
//     constraint is close to degenerate - but not exactly
//
// We check that constrained gradient is close to zero at solution.
// Box constraint is considered active if distance to boundary is less
// than TolConstr.
//
// NOTE: TolConstr must be large enough so it won't conflict with
//       perturbation introduced by v_shift
   tolconstr = 1.0E-8;
   for (n = 2; n <= 8; n++) {
      for (akind = 0; akind <= 3; akind++) {
         for (shiftkind = -5; shiftkind <= 1; shiftkind++) {
            for (bscale = 0; bscale >= -2; bscale--) {
            // Generate A, B and initial point
               ae_matrix_set_length(&a, n, n);
               ae_vector_set_length(&b, n);
               ae_vector_set_length(&x, n);
               for (i = 0; i < n; i++) {
                  b.xR[i] = pow(10.0, (double)bscale) * hqrndnormal(&rs);
                  x.xR[i] = hqrnduniformr(&rs) - 0.5;
               }
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               if (akind == 1) {
               // Dense well conditioned SPD
                  spdmatrixrndcond(n, 50.0, &a);
               }
               if (akind == 2) {
               // Dense well conditioned indefinite
                  smatrixrndcond(n, 50.0, &a);
               }
               if (akind == 3) {
               // Low rank
                  ae_vector_set_length(&tmp, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = 0.0;
                     }
                  }
                  for (k = 1; k < imin2(4, n); k++) {
                     for (i = 0; i < n; i++) {
                        tmp.xR[i] = hqrndnormal(&rs);
                     }
                     v = hqrndnormal(&rs);
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                        }
                     }
                  }
               }
            // Generate constraints
               ae_vector_set_length(&bl, n);
               ae_vector_set_length(&bu, n);
               for (i = 0; i < n; i++) {
                  bl.xR[i] = -1.0;
                  bu.xR[i] = 1.0;
               }
               ccnt = iround(pow(2.0, (double)n));
               ae_matrix_set_length(&c, ccnt, n + 1);
               ae_vector_set_length(&ct, ccnt);
               for (i = 0; i < ccnt; i++) {
                  ct.xZ[i] = -1;
                  k = i;
                  c.xyR[i][n] = sign((double)shiftkind) * pow(10.0, fabs((double)shiftkind)) * machineepsilon;
                  for (j = 0; j < n; j++) {
                     c.xyR[i][j] = (double)(2 * (k % 2) - 1);
                     c.xyR[i][n] += c.xyR[i][j] * c.xyR[i][j];
                     k /= 2;
                  }
               }
            // Create and optimize
               minbleiccreate(n, &x, &state);
               minbleicsetbc(&state, &bl, &bu);
               minbleicsetlc(&state, &c, &ct, ccnt);
               minbleicsetcond(&state, 1.0E-9, 0.0, 0.0, 0);
               while (minbleiciteration(&state)) {
                  ae_assert(state.needfg, "Assertion failed");
                  state.f = 0.0;
                  for (i = 0; i < n; i++) {
                     state.f += state.x.xR[i] * b.xR[i];
                     state.g.xR[i] = b.xR[i];
                  }
                  for (i = 0; i < n; i++) {
                     v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
                     state.f += 0.5 * state.x.xR[i] * v;
                     state.g.xR[i] += v;
                  }
               }
               minbleicresults(&state, &xs0, &rep);
               set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbleicunit.ap:2341");
               if (*err) {
                  ae_frame_leave();
                  return;
               }
            // Evaluate gradient at solution and test
               vv = 0.0;
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, xs0.xR, 1, n);
                  v += b.xR[i];
                  if (xs0.xR[i] <= bl.xR[i] + tolconstr && v > 0.0) {
                     v = 0.0;
                  }
                  if (xs0.xR[i] >= bu.xR[i] - tolconstr && v < 0.0) {
                     v = 0.0;
                  }
                  vv += sqr(v);
               }
               vv = sqrt(vv);
               set_error_flag(err, vv > 1.0E-5, __FILE__, __LINE__, "testminbleicunit.ap:2365");
            }
         }
      }
   }
// Convex/nonconvex optimization problem with combination of
// box and linear constraints:
//
// * N=2..8
// * f = 0.5*x'*A*x+b'*x
// * b has normally distributed entries with scale 10^BScale
// * several kinds of A are tried: zero, well conditioned SPD,
//   well conditioned indefinite, low rank
// * box constraints: x[i] in [-1,+1]
// * initial point x0 = [0 0 ... 0 0]
// * CCnt=min(3,N-1) general linear constraints of form (c,x)=0.
//   random mix of equality/inequality constraints is tried.
//   x0 is guaranteed to be feasible.
//
// We check that constrained gradient is close to zero at solution.
// Inequality constraint is considered active if distance to boundary
// is less than TolConstr. We use nonnegative least squares solver
// in order to compute constrained gradient.
   tolconstr = 1.0E-8;
   for (n = 2; n <= 8; n++) {
      for (akind = 0; akind <= 3; akind++) {
         for (bscale = 0; bscale >= -2; bscale--) {
         // Generate A, B and initial point
            ae_matrix_set_length(&a, n, n);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&x, n);
            for (i = 0; i < n; i++) {
               b.xR[i] = pow(10.0, (double)bscale) * hqrndnormal(&rs);
               x.xR[i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
            }
            if (akind == 1) {
            // Dense well conditioned SPD
               spdmatrixrndcond(n, 50.0, &a);
            }
            if (akind == 2) {
            // Dense well conditioned indefinite
               smatrixrndcond(n, 50.0, &a);
            }
            if (akind == 3) {
            // Low rank
               ae_vector_set_length(&tmp, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               for (k = 1; k < imin2(4, n); k++) {
                  for (i = 0; i < n; i++) {
                     tmp.xR[i] = hqrndnormal(&rs);
                  }
                  v = hqrndnormal(&rs);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                     }
                  }
               }
            }
         // Generate constraints
            ae_vector_set_length(&bl, n);
            ae_vector_set_length(&bu, n);
            for (i = 0; i < n; i++) {
               bl.xR[i] = -1.0;
               bu.xR[i] = 1.0;
            }
            ccnt = imin2(3, n - 1);
            ae_matrix_set_length(&c, ccnt, n + 1);
            ae_vector_set_length(&ct, ccnt);
            for (i = 0; i < ccnt; i++) {
               ct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
               c.xyR[i][n] = 0.0;
               for (j = 0; j < n; j++) {
                  c.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         // Create and optimize
            minbleiccreate(n, &x, &state);
            minbleicsetbc(&state, &bl, &bu);
            minbleicsetlc(&state, &c, &ct, ccnt);
            minbleicsetcond(&state, 1.0E-9, 0.0, 0.0, 0);
            while (minbleiciteration(&state)) {
               ae_assert(state.needfg, "Assertion failed");
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  state.f += state.x.xR[i] * b.xR[i];
                  state.g.xR[i] = b.xR[i];
               }
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
                  state.f += 0.5 * state.x.xR[i] * v;
                  state.g.xR[i] += v;
               }
            }
            minbleicresults(&state, &xs0, &rep);
            set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbleicunit.ap:2487");
            if (*err) {
               ae_frame_leave();
               return;
            }
         // 1. evaluate unconstrained gradient at solution
         //
         // 2. calculate constrained gradient (NNLS solver is used
         //    to evaluate gradient subject to active constraints).
         //    In order to do this we form CE matrix, matrix of active
         //    constraints (columns store constraint vectors). Then
         //    we try to approximate gradient vector by columns of CE,
         //    subject to non-negativity restriction placed on variables
         //    corresponding to inequality constraints.
         //
         //    Residual from such regression is a constrained gradient vector.
            ae_vector_set_length(&g, n);
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xs0.xR, 1, n);
               g.xR[i] = v + b.xR[i];
            }
            ae_matrix_set_length(&ce, n, n + ccnt);
            ae_vector_set_length(&nonnegative, n + ccnt);
            k = 0;
            for (i = 0; i < n; i++) {
               set_error_flag(err, xs0.xR[i] < bl.xR[i], __FILE__, __LINE__, "testminbleicunit.ap:2515");
               set_error_flag(err, xs0.xR[i] > bu.xR[i], __FILE__, __LINE__, "testminbleicunit.ap:2516");
               if (xs0.xR[i] <= bl.xR[i] + tolconstr) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = 0.0;
                  }
                  ce.xyR[i][k] = 1.0;
                  nonnegative.xB[k] = true;
                  k++;
                  continue;
               }
               if (xs0.xR[i] >= bu.xR[i] - tolconstr) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = 0.0;
                  }
                  ce.xyR[i][k] = -1.0;
                  nonnegative.xB[k] = true;
                  k++;
                  continue;
               }
            }
            for (i = 0; i < ccnt; i++) {
               v = ae_v_dotproduct(c.xyR[i], 1, xs0.xR, 1, n);
               v -= c.xyR[i][n];
               set_error_flag(err, ct.xZ[i] == 0 && fabs(v) > tolconstr, __FILE__, __LINE__, "testminbleicunit.ap:2540");
               set_error_flag(err, ct.xZ[i] > 0 && v < -tolconstr, __FILE__, __LINE__, "testminbleicunit.ap:2541");
               set_error_flag(err, ct.xZ[i] < 0 && v > tolconstr, __FILE__, __LINE__, "testminbleicunit.ap:2542");
               if (ct.xZ[i] == 0) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = c.xyR[i][j];
                  }
                  nonnegative.xB[k] = false;
                  k++;
                  continue;
               }
               if ((ct.xZ[i] > 0 && v <= tolconstr) || (ct.xZ[i] < 0 && v >= -tolconstr)) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = sign((double)ct.xZ[i]) * c.xyR[i][j];
                  }
                  nonnegative.xB[k] = true;
                  k++;
                  continue;
               }
            }
            snnlsinit(0, 0, 0, &nnls);
            snnlssetproblem(&nnls, &ce, &g, 0, k, n);
            for (i = 0; i < k; i++) {
               if (!nonnegative.xB[i]) {
                  snnlsdropnnc(&nnls, i);
               }
            }
            snnlssolve(&nnls, &tmp);
            for (i = 0; i < k; i++) {
               for (j = 0; j < n; j++) {
                  g.xR[j] -= tmp.xR[i] * ce.xyR[j][i];
               }
            }
            vv = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
            vv = sqrt(vv);
            set_error_flag(err, vv > 1.0E-5, __FILE__, __LINE__, "testminbleicunit.ap:2571");
         }
      }
   }
   ae_frame_leave();
}

// This function tests preconditioning
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testminbleicunit_testpreconditioning(bool *err) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t i;
   ae_int_t k;
   ae_int_t cntb1;
   ae_int_t cntb2;
   ae_int_t cntg1;
   ae_int_t cntg2;
   double epsg;
   ae_int_t ckind;
   ae_int_t fk;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(vd, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(units, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(diagh, 0, DT_REAL);
   NewObj(minbleicstate, state);
   NewObj(minbleicreport, rep);
// Preconditioner test 1.
//
// If
// * B1 is default preconditioner with unit scale
// * G1 is diagonal preconditioner based on approximate diagonal of Hessian matrix
// * B2 is default preconditioner with non-unit scale S[i]=1/sqrt(h[i])
// * G2 is scale-based preconditioner with non-unit scale S[i]=1/sqrt(h[i])
// then B1 is worse than G1, B2 is worse than G2.
// "Worse" means more iterations to converge.
//
// Test problem setup:
// * f(x) = sum( ((i*i+1)*x[i])^2, i=0..N-1)
// * constraints:
//   0) absent
//   1) boundary only
//   2) linear equality only
//   3) combination of boundary and linear equality constraints
//
// N        - problem size
// K        - number of repeated passes (should be large enough to average out random factors)
   k = 100;
   epsg = 1.0E-8;
   for (n = 10; n <= 10; n++) {
      for (ckind = 0; ckind <= 3; ckind++) {
         fk = 1;
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&units, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 0.0;
            units.xR[i] = 1.0;
         }
         minbleiccreate(n, &x, &state);
         minbleicsetcond(&state, epsg, 0.0, 0.0, 0);
         if (ckind == 1 || ckind == 3) {
            ae_vector_set_length(&bl, n);
            ae_vector_set_length(&bu, n);
            for (i = 0; i < n; i++) {
               bl.xR[i] = -1.0;
               bu.xR[i] = 1.0;
            }
            minbleicsetbc(&state, &bl, &bu);
         }
         if (ckind == 2 || ckind == 3) {
            ae_matrix_set_length(&c, 1, n + 1);
            ae_vector_set_length(&ct, 1);
            ct.xZ[0] = randominteger(3) - 1;
            for (i = 0; i < n; i++) {
               c.xyR[0][i] = randommid();
            }
            c.xyR[0][n] = 0.0;
            minbleicsetlc(&state, &c, &ct, 1);
         }
      // Test it with default preconditioner VS. perturbed diagonal preconditioner
         minbleicsetprecdefault(&state);
         minbleicsetscale(&state, &units);
         cntb1 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            minbleicrestartfrom(&state, &x);
            while (minbleiciteration(&state)) {
               testminbleicunit_calciip2(&state, n, fk);
            }
            minbleicresults(&state, &x, &rep);
            cntb1 += rep.inneriterationscount;
            *err = *err || rep.terminationtype <= 0;
         }
         ae_vector_set_length(&diagh, n);
         for (i = 0; i < n; i++) {
            diagh.xR[i] = 2 * pow((double)(i * i + 1), (double)(2 * fk)) * (0.8 + 0.4 * randomreal());
         }
         minbleicsetprecdiag(&state, &diagh);
         minbleicsetscale(&state, &units);
         cntg1 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            minbleicrestartfrom(&state, &x);
            while (minbleiciteration(&state)) {
               testminbleicunit_calciip2(&state, n, fk);
            }
            minbleicresults(&state, &x, &rep);
            cntg1 += rep.inneriterationscount;
            *err = *err || rep.terminationtype <= 0;
         }
         *err = *err || cntb1 < cntg1;
      // Test it with scale-based preconditioner
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = 1 / sqrt(2 * pow((double)(i * i + 1), (double)(2 * fk)) * (0.8 + 0.4 * randomreal()));
         }
         minbleicsetprecdefault(&state);
         minbleicsetscale(&state, &s);
         cntb2 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            minbleicrestartfrom(&state, &x);
            while (minbleiciteration(&state)) {
               testminbleicunit_calciip2(&state, n, fk);
            }
            minbleicresults(&state, &x, &rep);
            cntb2 += rep.inneriterationscount;
            *err = *err || rep.terminationtype <= 0;
         }
         minbleicsetprecscale(&state);
         minbleicsetscale(&state, &s);
         cntg2 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            minbleicrestartfrom(&state, &x);
            while (minbleiciteration(&state)) {
               testminbleicunit_calciip2(&state, n, fk);
            }
            minbleicresults(&state, &x, &rep);
            cntg2 += rep.inneriterationscount;
            *err = *err || rep.terminationtype <= 0;
         }
         *err = *err || cntb2 < cntg2;
      }
   }
   ae_frame_leave();
}

// This function tests problems which caused bugs in the past.
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testminbleicunit_testbugs(bool *err) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_int_t pass;
   double tolx;
   double regterm;
   ae_int_t n;
   ae_int_t ckind;
   ae_frame_make(&_frame_block);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(h, 0, DT_REAL);
   NewVector(prior, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(minbleicstate, state);
   NewObj(minbleicreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Reproduce situation: optimizer sometimes hangs when starts with
// gradient orthogonal to the only linear constraint. In most cases
// it is solved successfully, but sometimes leads to infinite loop
// in one of the early optimizer versions.
//
// The problem is:
// * f(x)= x'*x + c'*x
// * linear constraint c'*x=0
// * initial point is x=0
// * there are two ways to choose coefficient vector c:
//   * its components can be long binary fractions
//   * or they can be either 0 or 1
//   both ways test different scenarios for accumulation of rounding errors
//
// If test fails, it usually hangs
   tolx = 1.0E-10;
   for (pass = 1; pass <= 10; pass++) {
      for (ckind = 0; ckind <= 1; ckind++) {
         for (n = 2; n <= 10; n++) {
            ae_vector_set_length(&x, n);
            ae_matrix_set_length(&c, 1, n + 1);
            ae_vector_set_length(&ct, 1);
            for (i = 0; i < n; i++) {
               x.xR[i] = 0.0;
               if (ckind == 0) {
                  c.xyR[0][i] = sqrt(hqrnduniformr(&rs));
               } else {
                  c.xyR[0][i] = (double)hqrnduniformi(&rs, 2);
               }
            }
            c.xyR[0][n] = 0.0;
            ct.xZ[0] = 0;
            minbleiccreate(n, &x, &state);
            minbleicsetlc(&state, &c, &ct, 1);
            minbleicsetcond(&state, 0.0, 0.0, 0.0, 99);
            while (minbleiciteration(&state)) {
               ae_assert(state.needfg, "Assertion failed");
               if (state.needfg) {
                  state.f = 0.0;
                  for (i = 0; i < n; i++) {
                     state.f += sqr(state.x.xR[i]) + state.x.xR[i] * c.xyR[0][i];
                     state.g.xR[i] = 2 * state.x.xR[i] + c.xyR[0][i];
                  }
               }
            }
            minbleicresultsbuf(&state, &x1, &rep);
            set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbleicunit.ap:2854");
            for (i = 0; i < n; i++) {
               set_error_flag(err, fabs(x1.xR[i]) > tolx, __FILE__, __LINE__, "testminbleicunit.ap:2856");
            }
         }
      }
   }
// Reproduce optimization problem which caused bugs (optimizer hangs)
// when BLEIC was used from MCPD unit. We perform test on specific
// 9-dimensional problem, no need to try general-case methods.
//
// This test hangs if bug is present. Thus, we do not test completion
// code returned by optimizer - we just test that it was returned :)
   tolx = 1.0E-8;
   regterm = 1.0E-8;
   for (pass = 1; pass <= 1000; pass++) {
   // Prepare constraints:
   // * [0,1] box constraints on all variables
   // * 5 linear constraints, first one is random equality;
   //   second one is random inequality; other ones are "sum-to-one" constraints
   //   for x0-x2, x3-x5, x6-x8.
      ae_vector_set_length(&bl, 9);
      ae_vector_set_length(&bu, 9);
      for (i = 0; i < 9; i++) {
         bl.xR[i] = 0.0;
         bu.xR[i] = 1.0;
      }
      ae_matrix_set_length(&c, 5, 10);
      ae_vector_set_length(&ct, 5);
      for (i = 0; i <= 1; i++) {
         c.xyR[i][9] = 0.0;
         for (j = 0; j < 9; j++) {
            c.xyR[i][j] = randommid();
            c.xyR[i][9] += c.xyR[i][j] * (1.0 / 9.0);
         }
      }
      ct.xZ[0] = 0;
      ct.xZ[1] = 1;
      c.xyR[1][9] -= 0.1;
      for (i = 0; i < 3; i++) {
         for (k = 0; k < 9; k++) {
            c.xyR[2 + i][k] = 0.0;
         }
         for (k = 0; k < 3; k++) {
            c.xyR[2 + i][k * 3 + i] = 1.0;
         }
         c.xyR[2 + i][9] = 1.0;
         ct.xZ[2 + i] = 0;
      }
   // Prepare weights
      ae_vector_set_length(&w, 3);
      for (i = 0; i < w.cnt; i++) {
         w.xR[i] = 1.0;
      }
   // Prepare preconditioner H
      ae_vector_set_length(&h, 9);
      for (i = 0; i < h.cnt; i++) {
         h.xR[i] = 1.0;
      }
   // Prepare prior value for regularization
      ae_vector_set_length(&prior, 9);
      for (i = 0; i < prior.cnt; i++) {
         prior.xR[i] = 0.0;
      }
      prior.xR[0] = 1.0;
      prior.xR[4] = 1.0;
      prior.xR[8] = 1.0;
   // Prepare dataset XY
      ae_matrix_set_length(&xy, 6, 3);
      for (i = 0; i < xy.rows; i++) {
         for (j = 0; j < xy.cols; j++) {
            xy.xyR[i][j] = randomreal();
         }
      }
   // Optimize
      ae_vector_set_length(&x, 9);
      for (i = 0; i < 9; i++) {
         x.xR[i] = 1.0 / 9.0;
      }
      minbleiccreate(9, &x, &state);
      minbleicsetbc(&state, &bl, &bu);
      minbleicsetlc(&state, &c, &ct, 5);
      minbleicsetcond(&state, 0.0, 0.0, tolx, 0);
      minbleicsetprecdiag(&state, &h);
      while (minbleiciteration(&state)) {
         ae_assert(state.needfg, "Assertion failed");
         if (state.needfg) {
         // Calculate regularization term
            state.f = 0.0;
            for (i = 0; i < 9; i++) {
               state.f += regterm * sqr(state.x.xR[i] - prior.xR[i]);
               state.g.xR[i] = 2 * regterm * (state.x.xR[i] - prior.xR[i]);
            }
         // calculate prediction error/gradient for K-th pair
            for (k = 0; k < xy.rows - 1; k++) {
               for (i = 0; i < 3; i++) {
                  v = ae_v_dotproduct(&state.x.xR[i * 3], 1, xy.xyR[k], 1, 3);
                  state.f += sqr(w.xR[i] * (v - xy.xyR[k + 1][i]));
                  for (j = 0; j < 3; j++) {
                     state.g.xR[i * 3 + j] += 2 * w.xR[i] * w.xR[i] * (v - xy.xyR[k + 1][i]) * xy.xyR[k][j];
                  }
               }
            }
         }
      }
      minbleicresultsbuf(&state, &x, &rep);
   }
   ae_frame_leave();
}

// This function tests report of "non-C1" test #0 for task #0
// given by matrix A.
//
// On failure sets error flag.
static void testminbleicunit_testoptguardc1test0reportfortask0(bool *err, optguardnonc1test0report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool hasc1discontinuities;
   if (rep->positive) {
   // Check positive report, first checks
      set_error_flag(err, rep->fidx != 0, __FILE__, __LINE__, "testminbleicunit.ap:3568");
      set_error_flag(err, rep->n != n, __FILE__, __LINE__, "testminbleicunit.ap:3569");
      set_error_flag(err, !(0 <= rep->stpidxa), __FILE__, __LINE__, "testminbleicunit.ap:3570");
      set_error_flag(err, !(rep->stpidxa < rep->stpidxb), __FILE__, __LINE__, "testminbleicunit.ap:3571");
      set_error_flag(err, !(rep->stpidxb < rep->cnt), __FILE__, __LINE__, "testminbleicunit.ap:3572");
      set_error_flag(err, rep->x0.cnt != rep->n, __FILE__, __LINE__, "testminbleicunit.ap:3573");
      set_error_flag(err, rep->d.cnt != rep->n, __FILE__, __LINE__, "testminbleicunit.ap:3574");
      set_error_flag(err, rep->stp.cnt != rep->cnt, __FILE__, __LINE__, "testminbleicunit.ap:3575");
      set_error_flag(err, rep->f.cnt != rep->cnt, __FILE__, __LINE__, "testminbleicunit.ap:3576");
      set_error_flag(err, !isfinitevector(&rep->x0, n), __FILE__, __LINE__, "testminbleicunit.ap:3577");
      set_error_flag(err, !isfinitevector(&rep->d, n), __FILE__, __LINE__, "testminbleicunit.ap:3578");
      set_error_flag(err, !isfinitevector(&rep->stp, rep->cnt), __FILE__, __LINE__, "testminbleicunit.ap:3579");
      set_error_flag(err, !isfinitevector(&rep->f, rep->cnt), __FILE__, __LINE__, "testminbleicunit.ap:3580");
      if (*err) {
         return;
      }
   // Check consistency of X0, D, Stp and F
      for (k = 0; k < rep->cnt - 1; k++) {
         set_error_flag(err, rep->stp.xR[k] >= rep->stp.xR[k + 1], __FILE__, __LINE__, "testminbleicunit.ap:3588");
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += fabs(vv);
         }
         set_error_flag(err, fabs(v - rep->f.xR[k]) > 1.0E-6 * rmax2(fabs(v), 1.0), __FILE__, __LINE__, "testminbleicunit.ap:3601");
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      set_error_flag(err, !hasc1discontinuities, __FILE__, __LINE__, "testminbleicunit.ap:3619");
   } else {
   // Check negative report: fields must be empty
      set_error_flag(err, rep->stpidxa != -1, __FILE__, __LINE__, "testminbleicunit.ap:3626");
      set_error_flag(err, rep->stpidxb != -1, __FILE__, __LINE__, "testminbleicunit.ap:3627");
      set_error_flag(err, rep->fidx != -1, __FILE__, __LINE__, "testminbleicunit.ap:3628");
      set_error_flag(err, rep->cnt != 0, __FILE__, __LINE__, "testminbleicunit.ap:3629");
      set_error_flag(err, rep->n != 0, __FILE__, __LINE__, "testminbleicunit.ap:3630");
      set_error_flag(err, rep->x0.cnt != 0, __FILE__, __LINE__, "testminbleicunit.ap:3631");
      set_error_flag(err, rep->d.cnt != 0, __FILE__, __LINE__, "testminbleicunit.ap:3632");
      set_error_flag(err, rep->stp.cnt != 0, __FILE__, __LINE__, "testminbleicunit.ap:3633");
      set_error_flag(err, rep->f.cnt != 0, __FILE__, __LINE__, "testminbleicunit.ap:3634");
   }
}

// This function tests report of "non-C1" test #1 for task #0
// given by matrix A.
//
// On failure sets error flag.
static void testminbleicunit_testoptguardc1test1reportfortask0(bool *err, optguardnonc1test1report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool tooclose;
   bool hasc1discontinuities;
   if (rep->positive) {
   // Check positive report, first checks
      set_error_flag(err, rep->fidx != 0, __FILE__, __LINE__, "testminbleicunit.ap:3662");
      set_error_flag(err, rep->vidx < 0, __FILE__, __LINE__, "testminbleicunit.ap:3663");
      set_error_flag(err, rep->vidx > n, __FILE__, __LINE__, "testminbleicunit.ap:3664");
      set_error_flag(err, rep->n != n, __FILE__, __LINE__, "testminbleicunit.ap:3665");
      set_error_flag(err, !(0 <= rep->stpidxa), __FILE__, __LINE__, "testminbleicunit.ap:3666");
      set_error_flag(err, !(rep->stpidxa < rep->stpidxb), __FILE__, __LINE__, "testminbleicunit.ap:3667");
      set_error_flag(err, !(rep->stpidxb < rep->cnt), __FILE__, __LINE__, "testminbleicunit.ap:3668");
      set_error_flag(err, rep->x0.cnt != rep->n, __FILE__, __LINE__, "testminbleicunit.ap:3669");
      set_error_flag(err, rep->d.cnt != rep->n, __FILE__, __LINE__, "testminbleicunit.ap:3670");
      set_error_flag(err, rep->stp.cnt != rep->cnt, __FILE__, __LINE__, "testminbleicunit.ap:3671");
      set_error_flag(err, rep->g.cnt != rep->cnt, __FILE__, __LINE__, "testminbleicunit.ap:3672");
      set_error_flag(err, !isfinitevector(&rep->x0, n), __FILE__, __LINE__, "testminbleicunit.ap:3673");
      set_error_flag(err, !isfinitevector(&rep->d, n), __FILE__, __LINE__, "testminbleicunit.ap:3674");
      set_error_flag(err, !isfinitevector(&rep->stp, rep->cnt), __FILE__, __LINE__, "testminbleicunit.ap:3675");
      set_error_flag(err, !isfinitevector(&rep->g, rep->cnt), __FILE__, __LINE__, "testminbleicunit.ap:3676");
      if (*err) {
         return;
      }
   // Check consistency of X0, D, Stp and G
      for (k = 0; k < rep->cnt - 1; k++) {
         set_error_flag(err, rep->stp.xR[k] >= rep->stp.xR[k + 1], __FILE__, __LINE__, "testminbleicunit.ap:3684");
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         tooclose = false;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += sign(vv) * a->xyR[i][rep->vidx];
            tooclose = tooclose || fabs(vv) < 1.0E-4;
         }
         if (!tooclose) {
            set_error_flag(err, fabs(v - rep->g.xR[k]) > 1.0E-6 * rmax2(fabs(v), 1.0), __FILE__, __LINE__, "testminbleicunit.ap:3698");
         }
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      tooclose = false;
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         tooclose = (tooclose || fabs(va) < 1.0E-8) || fabs(vb) < 1.0E-8;
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      if (!tooclose) {
         set_error_flag(err, !hasc1discontinuities, __FILE__, __LINE__, "testminbleicunit.ap:3719");
      }
   } else {
   // Check negative report: fields must be empty
      set_error_flag(err, rep->stpidxa != -1, __FILE__, __LINE__, "testminbleicunit.ap:3726");
      set_error_flag(err, rep->stpidxb != -1, __FILE__, __LINE__, "testminbleicunit.ap:3727");
      set_error_flag(err, rep->fidx != -1, __FILE__, __LINE__, "testminbleicunit.ap:3728");
      set_error_flag(err, rep->vidx != -1, __FILE__, __LINE__, "testminbleicunit.ap:3729");
      set_error_flag(err, rep->cnt != 0, __FILE__, __LINE__, "testminbleicunit.ap:3730");
      set_error_flag(err, rep->n != 0, __FILE__, __LINE__, "testminbleicunit.ap:3731");
      set_error_flag(err, rep->x0.cnt != 0, __FILE__, __LINE__, "testminbleicunit.ap:3732");
      set_error_flag(err, rep->d.cnt != 0, __FILE__, __LINE__, "testminbleicunit.ap:3733");
      set_error_flag(err, rep->stp.cnt != 0, __FILE__, __LINE__, "testminbleicunit.ap:3734");
      set_error_flag(err, rep->g.cnt != 0, __FILE__, __LINE__, "testminbleicunit.ap:3735");
   }
}

// This function tests OptGuard
//
// On failure sets error flag.
static void testminbleicunit_testoptguard(bool *wereerrors) {
   ae_frame _frame_block;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   double diffstep;
   ae_int_t pass;
   ae_int_t defecttype;
   bool failed;
   ae_int_t passcount;
   ae_int_t maxfails;
   ae_int_t failurecounter;
   ae_int_t maxc1test0fails;
   ae_int_t maxc1test1fails;
   ae_int_t c1test0fails;
   ae_int_t c1test1fails;
   double avgstr0len;
   double avglng0len;
   double avgstr1len;
   double avglng1len;
   ae_int_t varidx;
   ae_int_t skind;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minbleicstate, state);
   NewObj(minbleicreport, rep);
   NewObj(optguardreport, ogrep);
   NewObj(optguardnonc1test0report, ognonc1test0strrep);
   NewObj(optguardnonc1test0report, ognonc1test0lngrep);
   NewObj(optguardnonc1test1report, ognonc1test1strrep);
   NewObj(optguardnonc1test1report, ognonc1test1lngrep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(jactrue, 0, 0, DT_REAL);
   NewMatrix(jacdefect, 0, 0, DT_REAL);
   hqrndrandomize(&rs);
// Check that gradient verification is disabled by default:
// gradient checking for bad problem must return nothing
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = 1.0 + 0.1 * i;
   }
   spdmatrixrndcond(n, 1.0E3, &a);
   spdmatrixrndcond(n, 1.0E3, &a1);
   minbleiccreate(n, &x0, &state);
   minbleicsetcond(&state, 0.0, 0.0, 1.0E-9, 10);
   while (minbleiciteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += 0.5 * state.x.xR[i] * v;
         }
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   minbleicresults(&state, &x1, &rep);
   minbleicoptguardresults(&state, &ogrep);
   set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbleicunit.ap:3057");
   set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminbleicunit.ap:3058");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(wereerrors, ogrep.badgradxbase.cnt != 0, __FILE__, __LINE__, "testminbleicunit.ap:3061");
   set_error_flag(wereerrors, ogrep.badgraduser.rows != 0, __FILE__, __LINE__, "testminbleicunit.ap:3062");
   set_error_flag(wereerrors, ogrep.badgraduser.cols != 0, __FILE__, __LINE__, "testminbleicunit.ap:3063");
   set_error_flag(wereerrors, ogrep.badgradnum.rows != 0, __FILE__, __LINE__, "testminbleicunit.ap:3064");
   set_error_flag(wereerrors, ogrep.badgradnum.cols != 0, __FILE__, __LINE__, "testminbleicunit.ap:3065");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(wereerrors, ogrep.badgradsuspected, __FILE__, __LINE__, "testminbleicunit.ap:3068");
   set_error_flag(wereerrors, ogrep.badgradfidx != -1, __FILE__, __LINE__, "testminbleicunit.ap:3069");
   set_error_flag(wereerrors, ogrep.badgradvidx != -1, __FILE__, __LINE__, "testminbleicunit.ap:3070");
// Test that C0/C1 continuity monitoring is disabled by default;
// we solve nonsmooth problem and test that nothing is returned
// by OptGuard.
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = hqrndnormal(&rs);
   }
   ae_matrix_set_length(&a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a.xyR[i][j] = hqrndnormal(&rs);
      }
   }
   minbleiccreate(n, &x0, &state);
   minbleicsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
   while (minbleiciteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += fabs(v);
            v = (double)sign(v);
            for (j = 0; j < n; j++) {
               state.g.xR[j] += v * a.xyR[i][j];
            }
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   minbleicresults(&state, &x1, &rep);
   minbleicoptguardresults(&state, &ogrep);
   set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminbleicunit.ap:3110");
   set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbleicunit.ap:3111");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testminbleicunit.ap:3114");
   set_error_flag(wereerrors, ogrep.nonc1suspected, __FILE__, __LINE__, "testminbleicunit.ap:3115");
   set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminbleicunit.ap:3116");
   set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testminbleicunit.ap:3117");
   set_error_flag(wereerrors, ogrep.nonc1fidx >= 0, __FILE__, __LINE__, "testminbleicunit.ap:3118");
   set_error_flag(wereerrors, ogrep.nonc1test0positive, __FILE__, __LINE__, "testminbleicunit.ap:3119");
   set_error_flag(wereerrors, ogrep.nonc1test1positive, __FILE__, __LINE__, "testminbleicunit.ap:3120");
// Test gradient checking functionality, try various
// defect types:
// * accidental zeroing of some gradient component
// * accidental addition of 1.0 to some component
// * accidental multiplication by 2.0
// Try distorting both target and constraints.
   diffstep = 0.001;
   n = 10;
   for (skind = 0; skind <= 1; skind++) {
      for (defecttype = -1; defecttype <= 2; defecttype++) {
         varidx = hqrnduniformi(&rs, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, skind * (30 * hqrnduniformr(&rs) - 15));
            x0.xR[i] = (1.0 + 0.1 * i) * s.xR[i];
            j = hqrnduniformi(&rs, 3);
            bndl.xR[i] = -100 * s.xR[i];
            bndu.xR[i] = 100 * s.xR[i];
            if (j == 1) {
               bndl.xR[i] = x0.xR[i];
            }
            if (j == 2) {
               bndu.xR[i] = x0.xR[i];
            }
         }
         spdmatrixrndcond(n, 1.0E3, &a);
         spdmatrixrndcond(n, 1.0E3, &a1);
         minbleiccreate(n, &x0, &state);
         minbleicoptguardgradient(&state, diffstep);
         minbleicsetcond(&state, 0.0, 0.0, 1.0E-9, 10);
         minbleicsetscale(&state, &s);
         minbleicsetbc(&state, &bndl, &bndu);
         while (minbleiciteration(&state)) {
            if (state.needfg) {
               for (i = 0; i < n; i++) {
                  set_error_flag(wereerrors, state.x.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminbleicunit.ap:3167");
                  set_error_flag(wereerrors, state.x.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminbleicunit.ap:3168");
               }
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += state.x.xR[j] / s.xR[j] * a.xyR[i][j];
                  }
                  state.f += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                  state.g.xR[i] = v;
               }
               if (defecttype == 0) {
                  state.g.xR[varidx] = 0.0;
               }
               if (defecttype == 1) {
                  state.g.xR[varidx]++;
               }
               if (defecttype == 2) {
                  state.g.xR[varidx] *= 2;
               }
               for (i = 0; i < n; i++) {
                  state.g.xR[i] /= s.xR[i];
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minbleicresults(&state, &x1, &rep);
         minbleicoptguardresults(&state, &ogrep);
      // Check that something is returned
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbleicunit.ap:3201");
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminbleicunit.ap:3202");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Compute reference values for true and spoiled Jacobian at X0
         set_error_flag(wereerrors, !isfinitevector(&ogrep.badgradxbase, n), __FILE__, __LINE__, "testminbleicunit.ap:3209");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         ae_matrix_set_length(&jactrue, 1, n);
         ae_matrix_set_length(&jacdefect, 1, n);
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += ogrep.badgradxbase.xR[j] / s.xR[j] * a.xyR[i][j];
            }
            jactrue.xyR[0][i] = v;
            jacdefect.xyR[0][i] = v;
         }
         if (defecttype == 0) {
            jacdefect.xyR[0][varidx] = 0.0;
         }
         if (defecttype == 1) {
            jacdefect.xyR[0][varidx]++;
         }
         if (defecttype == 2) {
            jacdefect.xyR[0][varidx] *= 2;
         }
         for (i = 0; i < n; i++) {
            jactrue.xyR[0][i] /= s.xR[i];
            jacdefect.xyR[0][i] /= s.xR[i];
         }
      // Check OptGuard report
         set_error_flag(wereerrors, !apservisfinitematrix(&ogrep.badgraduser, 1, n), __FILE__, __LINE__, "testminbleicunit.ap:3237");
         set_error_flag(wereerrors, !apservisfinitematrix(&ogrep.badgradnum, 1, n), __FILE__, __LINE__, "testminbleicunit.ap:3238");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         if (defecttype >= 0) {
            set_error_flag(wereerrors, !ogrep.badgradsuspected, __FILE__, __LINE__, "testminbleicunit.ap:3243");
            set_error_flag(wereerrors, ogrep.badgradfidx != 0, __FILE__, __LINE__, "testminbleicunit.ap:3244");
            set_error_flag(wereerrors, ogrep.badgradvidx != varidx, __FILE__, __LINE__, "testminbleicunit.ap:3245");
         } else {
            set_error_flag(wereerrors, ogrep.badgradsuspected, __FILE__, __LINE__, "testminbleicunit.ap:3249");
            set_error_flag(wereerrors, ogrep.badgradfidx != -1, __FILE__, __LINE__, "testminbleicunit.ap:3250");
            set_error_flag(wereerrors, ogrep.badgradvidx != -1, __FILE__, __LINE__, "testminbleicunit.ap:3251");
         }
         for (j = 0; j < n; j++) {
            set_error_flag(wereerrors, fabs(jactrue.xyR[0][j] - ogrep.badgradnum.xyR[0][j]) > 0.01 / s.xR[j], __FILE__, __LINE__, "testminbleicunit.ap:3255");
            set_error_flag(wereerrors, fabs(jacdefect.xyR[0][j] - ogrep.badgraduser.xyR[0][j]) > 0.01 / s.xR[j], __FILE__, __LINE__, "testminbleicunit.ap:3256");
         }
      }
   }
// A test for detection of C1 continuity violations in the target.
//
// Target function is a sum of |(x,c_i)| for i=1..N.
// No constraints is present.
// Analytic gradient is provided.
//
// OptGuard should be able to detect violations in more than
// 99.9% of runs; it means that 100 runs should have no more than 4
// failures in all cases (even after multiple repeated tests; according
// to the binomial distribution quantiles).
//
// We select some N and perform exhaustive search for this N.
   passcount = 100;
   maxfails = 4;
   maxc1test0fails = 10;
   maxc1test1fails = 10;
   n = 1 + hqrnduniformi(&rs, 10);
   failurecounter = 0;
   c1test0fails = 0;
   c1test1fails = 0;
   avgstr0len = 0.0;
   avglng0len = 0.0;
   avgstr1len = 0.0;
   avglng1len = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = pow(2.0, hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      minbleiccreate(n, &x0, &state);
      minbleicsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      minbleicsetscale(&state, &s);
      minbleicoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminbleicunit_maxoptguardlevel));
      while (minbleiciteration(&state)) {
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.g.xR[i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
               v = (double)sign(v);
               for (j = 0; j < n; j++) {
                  state.g.xR[j] += v * a.xyR[i][j];
               }
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minbleicresults(&state, &x1, &rep);
      minbleicoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminbleicunit.ap:3337");
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbleicunit.ap:3338");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
   // Check generic OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testminbleicunit.ap:3349");
      set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testminbleicunit.ap:3350");
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   // Check C1 continuity test #0
      minbleicoptguardnonc1test0results(&state, &ognonc1test0strrep, &ognonc1test0lngrep);
      minbleicoptguardnonc1test1results(&state, &ognonc1test1strrep, &ognonc1test1lngrep);
      if (ogrep.nonc1test0positive) {
         set_error_flag(wereerrors, !ogrep.nonc1suspected, __FILE__, __LINE__, "testminbleicunit.ap:3365");
         set_error_flag(wereerrors, !ognonc1test0strrep.positive, __FILE__, __LINE__, "testminbleicunit.ap:3366");
         set_error_flag(wereerrors, !ognonc1test0lngrep.positive, __FILE__, __LINE__, "testminbleicunit.ap:3367");
         set_error_flag(wereerrors, ogrep.nonc1fidx != 0, __FILE__, __LINE__, "testminbleicunit.ap:3368");
         testminbleicunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0strrep, &a, n);
         testminbleicunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0lngrep, &a, n);
         avgstr0len += (double)ognonc1test0strrep.cnt / passcount;
         avglng0len += (double)ognonc1test0lngrep.cnt / passcount;
      } else {
         set_error_flag(wereerrors, ognonc1test0strrep.positive, __FILE__, __LINE__, "testminbleicunit.ap:3376");
         set_error_flag(wereerrors, ognonc1test0lngrep.positive, __FILE__, __LINE__, "testminbleicunit.ap:3377");
         testminbleicunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0strrep, &a, n);
         testminbleicunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0lngrep, &a, n);
         c1test0fails++;
      }
      if (ogrep.nonc1test1positive) {
         set_error_flag(wereerrors, !ogrep.nonc1suspected, __FILE__, __LINE__, "testminbleicunit.ap:3384");
         set_error_flag(wereerrors, !ognonc1test1strrep.positive, __FILE__, __LINE__, "testminbleicunit.ap:3385");
         set_error_flag(wereerrors, !ognonc1test1lngrep.positive, __FILE__, __LINE__, "testminbleicunit.ap:3386");
         set_error_flag(wereerrors, ogrep.nonc1fidx != 0, __FILE__, __LINE__, "testminbleicunit.ap:3387");
         testminbleicunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1strrep, &a, n);
         testminbleicunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1lngrep, &a, n);
         avgstr1len += (double)ognonc1test1strrep.cnt / passcount;
         avglng1len += (double)ognonc1test1lngrep.cnt / passcount;
      } else {
         set_error_flag(wereerrors, ognonc1test1strrep.positive, __FILE__, __LINE__, "testminbleicunit.ap:3395");
         set_error_flag(wereerrors, ognonc1test1lngrep.positive, __FILE__, __LINE__, "testminbleicunit.ap:3396");
         testminbleicunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1strrep, &a, n);
         testminbleicunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1lngrep, &a, n);
         c1test1fails++;
      }
   }
   set_error_flag(wereerrors, failurecounter > maxfails, __FILE__, __LINE__, "testminbleicunit.ap:3403");
   set_error_flag(wereerrors, c1test0fails > maxc1test0fails, __FILE__, __LINE__, "testminbleicunit.ap:3404");
   set_error_flag(wereerrors, c1test1fails > maxc1test1fails, __FILE__, __LINE__, "testminbleicunit.ap:3405");
   set_error_flag(wereerrors, avglng0len <= avgstr0len, __FILE__, __LINE__, "testminbleicunit.ap:3406");
   set_error_flag(wereerrors, avglng1len <= avgstr1len, __FILE__, __LINE__, "testminbleicunit.ap:3407");
// Detection of C1 continuity violations in the target under numerical differentiation:
// * target function is a sum of |(x,c_i)| for i=1..N.
// * no constraints is present.
// * analytic gradient is provided.
//
// OptGuard should always be able to detect violations in more than
// 99% of runs (note: reduced strength when compared with analytic gradient);
// it means that 100 runs should have no more than 10 failures in all cases
// (even after multiple repeated tests; according to the binomial distribution
// quantiles).
//
// We select some N and perform exhaustive search for this N.
   diffstep = 0.0001;
   passcount = 100;
   maxfails = 10;
   n = 1 + hqrnduniformi(&rs, 10);
   failurecounter = 0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 0.01 * pow(2.0, 0.33 * hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      minbleiccreatef(n, &x0, diffstep, &state);
      minbleicsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      minbleicoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminbleicunit_maxoptguardlevel));
      while (minbleiciteration(&state)) {
         if (state.needf) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minbleicresults(&state, &x1, &rep);
      minbleicoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminbleicunit.ap:3472");
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbleicunit.ap:3473");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
   // Check OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testminbleicunit.ap:3484");
      set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testminbleicunit.ap:3485");
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   }
   set_error_flag(wereerrors, failurecounter > maxfails, __FILE__, __LINE__, "testminbleicunit.ap:3493");
// Make sure than no false positives are reported for larger
// problems where numerical noise can be an issue:
// * N=100 dimensions
// * positive-definite quadratic programming problem
// * upper limit on iterations count, MaxIts=25
// We simply test that OptGuard does not return error code.
   n = 100;
   spdmatrixrndcond(n, 1.0E2, &a);
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = hqrndnormal(&rs);
      x0.xR[i] = pow(2.0, hqrndnormal(&rs));
   }
   minbleiccreate(n, &x0, &state);
   minbleicoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminbleicunit_maxoptguardlevel));
   minbleicsetcond(&state, 0.0, 0.0, 1.0E-9, 25);
   while (minbleiciteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += b.xR[i] * state.x.xR[i];
            state.g.xR[i] = b.xR[i];
            for (j = 0; j < n; j++) {
               state.f += 0.5 * state.x.xR[i] * a.xyR[i][j] * state.x.xR[j];
               state.g.xR[i] += a.xyR[i][j] * state.x.xR[j];
            }
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   minbleicresults(&state, &x1, &rep);
   set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminbleicunit.ap:3536");
   set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbleicunit.ap:3537");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   minbleicoptguardresults(&state, &ogrep);
   set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminbleicunit.ap:3541");
   ae_frame_leave();
}

bool testminbleic(bool silent) {
   bool waserrors;
   bool feasibilityerrors;
   bool othererrors;
   bool precerrors;
   bool interrors;
   bool converrors;
   bool optguarderrors;
   bool bugs;
   bool result;
   waserrors = false;
   feasibilityerrors = false;
   othererrors = false;
   precerrors = false;
   interrors = false;
   converrors = false;
   optguarderrors = false;
   bugs = false;
   testminbleicunit_testfeasibility(&feasibilityerrors, &converrors, &interrors);
   testminbleicunit_testother(&othererrors);
   testminbleicunit_testconv(&converrors);
   testminbleicunit_testbugs(&bugs);
   testminbleicunit_testpreconditioning(&precerrors);
   testminbleicunit_testoptguard(&optguarderrors);
// end
   waserrors = (((((feasibilityerrors || othererrors) || converrors) || interrors) || precerrors) || optguarderrors) || bugs;
   if (!silent) {
      printf("TESTING BLEIC OPTIMIZATION\n");
      printf("FEASIBILITY PROPERTIES:                   ");
      if (feasibilityerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("PRECONDITIONING:                          ");
      if (precerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("OTHER PROPERTIES:                         ");
      if (othererrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("CONVERGENCE PROPERTIES:                   ");
      if (converrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("INTERNAL ERRORS:                          ");
      if (interrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("OPTGUARD:                                 ");
      if (optguarderrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("FIXED BUGS:                               ");
      if (bugs) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === minqp testing unit ===
// set random type of the QP solver, must support boundary constraints
static void testminqpunit_setrandomalgobc(minqpstate *s) {
   ae_int_t i;
   i = randominteger(2);
   if (i == 0) {
      minqpsetalgoquickqp(s, 0.0, 0.0, 1.0E-13, 0, true);
   }
   if (i == 1) {
      minqpsetalgobleic(s, 1.0E-12, 0.0, 0.0, 0);
   }
}

// Function to test: 'MinQPCreate', 'MinQPSetQuadraticTerm', 'MinQPSetBC',
// 'MinQPSetOrigin', 'MinQPSetStartingPoint', 'MinQPOptimize', 'MinQPResults'.
//
// Test problem:
//     A = diag(aii), aii>0 (random)
//     b = 0
//     random bounds (either no bounds, one bound, two bounds a<b, two bounds a=b)
//     random start point
//     dimension - from 1 to 5.
//
// Returns True on success, False on failure.
static bool simpletest() {
   ae_frame _frame_block;
   ae_int_t nexp;
   ae_int_t msn;
   ae_int_t sn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double maxstb;
   ae_int_t infd;
   double maxn;
   double maxnb;
   double minnb;
   double eps;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(minqpstate, state);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(ub, 0, DT_REAL);
   NewVector(db, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(tx, 0, DT_REAL);
   NewVector(stx, 0, DT_REAL);
   NewVector(xori, 0, DT_REAL);
   NewObj(minqpreport, rep);
   eps = 0.001;
   msn = 5;
   maxstb = 10.0;
   nexp = 1000;
   maxn = 10.0;
   maxnb = 1000.0;
   minnb = -1000.0;
   for (sn = 1; sn <= msn; sn++) {
      ae_vector_set_length(&tx, sn);
      ae_vector_set_length(&xori, sn);
      ae_vector_set_length(&stx, sn);
      ae_vector_set_length(&db, sn);
      ae_vector_set_length(&ub, sn);
      ae_matrix_set_length(&a, sn, sn);
      for (i = 0; i <= nexp; i++) {
      // create diagonal matrix
         for (k = 0; k < sn; k++) {
            for (j = 0; j <= k; j++) {
               if (j != k) {
                  a.xyR[k][j] = 0.0;
               } else {
                  a.xyR[k][j] = maxn * randomreal() + 1;
               }
            }
         }
         minqpcreate(sn, &state);
         testminqpunit_setrandomalgobc(&state);
         minqpsetquadraticterm(&state, &a, false);
         for (j = 0; j < sn; j++) {
            infd = randominteger(5);
            if (infd == 0) {
               db.xR[j] = -INFINITY;
               ub.xR[j] = +INFINITY;
            } else {
               if (infd == 1) {
                  db.xR[j] = -INFINITY;
                  ub.xR[j] = (maxnb - minnb) * randomreal() + minnb;
               } else {
                  if (infd == 2) {
                     db.xR[j] = (maxnb - minnb) * randomreal() + minnb;
                     ub.xR[j] = +INFINITY;
                  } else {
                     if (infd == 3) {
                        db.xR[j] = (maxnb - minnb) * randomreal() + minnb;
                        ub.xR[j] = db.xR[j] + maxstb * randomreal() + 0.01;
                     } else {
                        db.xR[j] = (maxnb - minnb) * randomreal() + minnb;
                        ub.xR[j] = db.xR[j];
                     }
                  }
               }
            }
         }
         minqpsetbc(&state, &db, &ub);
      // initialization for shifting
      // initial value for 'XORi'
      // and searching true results
         for (j = 0; j < sn; j++) {
            xori.xR[j] = (maxnb - minnb) * randomreal() + minnb;
            tx.xR[j] = rboundval(xori.xR[j], db.xR[j], ub.xR[j]);
         }
         minqpsetorigin(&state, &xori);
      // initialization for starting point
         for (j = 0; j < sn; j++) {
            stx.xR[j] = (maxnb - minnb) * randomreal() + minnb;
         }
         minqpsetstartingpoint(&state, &stx);
      // optimize and get result
         minqpoptimize(&state);
         minqpresults(&state, &x, &rep);
         for (j = 0; j < sn; j++) {
            if (fabs(tx.xR[j] - x.xR[j]) > eps || (x.xR[j] < db.xR[j] || x.xR[j] > ub.xR[j])) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Function to test: 'MinQPCreate', 'MinQPSetLinearTerm', 'MinQPSetQuadraticTerm',
// 'MinQPSetOrigin', 'MinQPSetStartingPoint', 'MinQPOptimize', 'MinQPResults'.
//
// Test problem:
//     A = positive-definite matrix, obtained by 'SPDMatrixRndCond' function
//     b != 0
//     without bounds
//     random start point
//     dimension - from 1 to 5.
static bool functest1() {
   ae_frame _frame_block;
   ae_int_t nexp;
   ae_int_t msn;
   ae_int_t sn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double eps;
   ae_int_t c2;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(minqpstate, state);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(ub, 0, DT_REAL);
   NewVector(db, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(tx, 0, DT_REAL);
   NewVector(stx, 0, DT_REAL);
   NewVector(xori, 0, DT_REAL);
   NewVector(xoric, 0, DT_REAL);
   NewObj(minqpreport, rep);
   NewVector(b, 0, DT_REAL);
   eps = 0.001;
   msn = 5;
   c2 = 1000;
   nexp = 1000;
   for (sn = 1; sn <= msn; sn++) {
      ae_vector_set_length(&b, sn);
      ae_vector_set_length(&tx, sn);
      ae_vector_set_length(&xori, sn);
      ae_vector_set_length(&xoric, sn);
      ae_vector_set_length(&stx, sn);
      for (i = 0; i <= nexp; i++) {
      // create simmetric matrix 'A'
         spdmatrixrndcond(sn, exp(randomreal() * log((double)c2)), &a);
         minqpcreate(sn, &state);
         testminqpunit_setrandomalgobc(&state);
         minqpsetquadraticterm(&state, &a, false);
         for (j = 0; j < sn; j++) {
            xoric.xR[j] = randommid();
         }
      // create linear part
         for (j = 0; j < sn; j++) {
            b.xR[j] = 0.0;
            for (k = 0; k < sn; k++) {
               b.xR[j] -= xoric.xR[k] * a.xyR[k][j];
            }
         }
         minqpsetlinearterm(&state, &b);
      // initialization for shifting
      // initial value for 'XORi'
      // and searching true results
         for (j = 0; j < sn; j++) {
            xori.xR[j] = randommid();
            tx.xR[j] = xori.xR[j] + xoric.xR[j];
         }
         minqpsetorigin(&state, &xori);
      // initialization for starting point
         for (j = 0; j < sn; j++) {
            stx.xR[j] = randommid();
         }
         minqpsetstartingpoint(&state, &stx);
      // optimize and get result
         minqpoptimize(&state);
         minqpresults(&state, &x, &rep);
         for (j = 0; j < sn; j++) {
            if (fabs(tx.xR[j] - x.xR[j]) > eps) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Function normal
static double testminqpunit_projectedantigradnorm(ae_int_t n, RVector *x, RVector *g, RVector *bndl, RVector *bndu) {
   ae_int_t i;
   double r;
   double result;
   r = 0.0;
   for (i = 0; i < n; i++) {
      ae_assert(x->xR[i] >= bndl->xR[i] && x->xR[i] <= bndu->xR[i], "ProjectedAntiGradNormal: boundary constraints violation");
      if (((x->xR[i] > bndl->xR[i] && x->xR[i] < bndu->xR[i]) || (x->xR[i] == bndl->xR[i] && -g->xR[i] > 0.0)) || (x->xR[i] == bndu->xR[i] && -g->xR[i] < 0.0)) {
         r += g->xR[i] * g->xR[i];
      }
   }
   result = sqrt(r);
   return result;
}

// Function to test: 'MinQPCreate', 'MinQPSetLinearTerm', 'MinQPSetQuadraticTerm',
// 'MinQPSetBC', 'MinQPSetOrigin', 'MinQPSetStartingPoint', 'MinQPOptimize',
// 'MinQPResults'.
//
// Test problem:
//     A = positive-definite matrix, obtained by 'SPDMatrixRndCond' function
//     b != 0
//     boundary constraints
//     random start point
//     dimension - from 1 to 5.
static bool functest2() {
   ae_frame _frame_block;
   ae_int_t nexp;
   ae_int_t msn;
   ae_int_t sn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double maxstb;
   ae_int_t infd;
   double maxnb;
   double minnb;
   double eps;
   ae_int_t c2;
   double anti;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(minqpstate, state);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(ub, 0, DT_REAL);
   NewVector(db, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(tmpx, 0, DT_REAL);
   NewVector(stx, 0, DT_REAL);
   NewVector(xori, 0, DT_REAL);
   NewVector(xoric, 0, DT_REAL);
   NewObj(minqpreport, rep);
   NewVector(b, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(c, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   eps = 0.001;
   msn = 5;
   c2 = 1000;
   maxstb = 10.0;
   nexp = 1000;
   maxnb = 1000.0;
   minnb = -1000.0;
   for (sn = 1; sn <= msn; sn++) {
      ae_vector_set_length(&tmpx, sn);
      ae_vector_set_length(&b, sn);
      ae_vector_set_length(&c, sn);
      ae_vector_set_length(&g, sn);
      ae_vector_set_length(&xori, sn);
      ae_vector_set_length(&xoric, sn);
      ae_vector_set_length(&stx, sn);
      ae_vector_set_length(&db, sn);
      ae_vector_set_length(&ub, sn);
      ae_vector_set_length(&y0, sn);
      ae_vector_set_length(&y1, sn);
      for (i = 0; i <= nexp; i++) {
      // create simmetric matrix 'A'
         spdmatrixrndcond(sn, exp(randomreal() * log((double)c2)), &a);
         minqpcreate(sn, &state);
         testminqpunit_setrandomalgobc(&state);
         minqpsetquadraticterm(&state, &a, false);
         for (j = 0; j < sn; j++) {
            xoric.xR[j] = (maxnb - minnb) * randomreal() + minnb;
         }
      // create linear part
         for (j = 0; j < sn; j++) {
            b.xR[j] = 0.0;
            for (k = 0; k < sn; k++) {
               b.xR[j] -= xoric.xR[k] * a.xyR[k][j];
            }
         }
         minqpsetlinearterm(&state, &b);
         for (j = 0; j < sn; j++) {
            infd = randominteger(4);
            if (infd == 0) {
               db.xR[j] = -INFINITY;
               ub.xR[j] = +INFINITY;
            } else {
               if (infd == 1) {
                  db.xR[j] = -INFINITY;
                  ub.xR[j] = (maxnb - minnb) * randomreal() + minnb;
               } else {
                  if (infd == 2) {
                     db.xR[j] = (maxnb - minnb) * randomreal() + minnb;
                     ub.xR[j] = +INFINITY;
                  } else {
                     db.xR[j] = (maxnb - minnb) * randomreal() + minnb;
                     ub.xR[j] = db.xR[j] + maxstb * randomreal() + 0.01;
                  }
               }
            }
         }
         minqpsetbc(&state, &db, &ub);
      // initialization for shifting
      // initial value for 'XORi'
      // and searching true results
         for (j = 0; j < sn; j++) {
            xori.xR[j] = (maxnb - minnb) * randomreal() + minnb;
         }
         minqpsetorigin(&state, &xori);
         for (j = 0; j < sn; j++) {
            c.xR[j] = 0.0;
            for (k = 0; k < sn; k++) {
               c.xR[j] -= xori.xR[k] * a.xyR[k][j];
            }
         }
      // initialization for starting point
         for (j = 0; j < sn; j++) {
            stx.xR[j] = (maxnb - minnb) * randomreal() + minnb;
         }
         minqpsetstartingpoint(&state, &stx);
      // optimize and get result
         minqpoptimize(&state);
         minqpresults(&state, &x, &rep);
         rmatrixmv(sn, sn, &a, 0, 0, 0, &x, 0, &y0, 0);
         for (j = 0; j < sn; j++) {
            g.xR[j] = y0.xR[j] + c.xR[j] + b.xR[j];
         }
         anti = testminqpunit_projectedantigradnorm(sn, &x, &g, &db, &ub);
         for (j = 0; j < sn; j++) {
            if (fabs(anti) > eps) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// ConsoleTest.
static bool consoletest() {
   ae_frame _frame_block;
   ae_int_t nexp;
   ae_int_t msn;
   ae_int_t sn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double eps;
   double c;
   double anti;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(minqpstate, state);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(ub, 0, DT_REAL);
   NewVector(db, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(stx, 0, DT_REAL);
   NewVector(xori, 0, DT_REAL);
   NewVector(xoric, 0, DT_REAL);
   NewObj(minqpreport, rep);
   NewVector(b, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   eps = 0.001;
   msn = 2;
   nexp = 0;
   for (sn = 2; sn <= msn; sn++) {
      ae_vector_set_length(&b, sn);
      ae_vector_set_length(&g, sn);
      ae_vector_set_length(&xori, sn);
      ae_vector_set_length(&xoric, sn);
      ae_vector_set_length(&stx, sn);
      ae_vector_set_length(&db, sn);
      ae_vector_set_length(&ub, sn);
      ae_vector_set_length(&y0, sn);
      ae_vector_set_length(&y1, sn);
      for (i = 0; i <= nexp; i++) {
      // create simmetric matrix 'A'
         ae_matrix_set_length(&a, sn, sn);
         for (j = 0; j < sn; j++) {
            for (k = 0; k < sn; k++) {
               if (j == k) {
                  a.xyR[j][k] = 1.0;
               } else {
                  a.xyR[j][k] = 0.0;
               }
               printf("%0.5f ", a.xyR[j][k]);
            }
            printf("\n");
         }
         minqpcreate(sn, &state);
         testminqpunit_setrandomalgobc(&state);
         minqpsetquadraticterm(&state, &a, false);
         for (j = 0; j < sn; j++) {
            xoric.xR[j] = 1.0;
            printf("XoriC=%0.5f \n", xoric.xR[j]);
         }
      // create linear part
         for (j = 0; j < sn; j++) {
            b.xR[j] = 0.0;
            for (k = 0; k < sn; k++) {
               b.xR[j] -= xoric.xR[k] * a.xyR[k][j];
            }
            printf("B[%0d]=%0.5f\n", (int)j, b.xR[j]);
         }
         minqpsetlinearterm(&state, &b);
         for (j = 0; j < sn; j++) {
            db.xR[j] = 10.0;
            ub.xR[j] = 20.0;
         }
         minqpsetbc(&state, &db, &ub);
      // initialization for shifting
      // initial value for 'XORi'
      // and searching true results
         for (j = 0; j < sn; j++) {
            xori.xR[j] = 1.0;
         }
         minqpsetorigin(&state, &xori);
      // optimize and get result
         minqpoptimize(&state);
         minqpresults(&state, &x, &rep);
         rmatrixmv(sn, sn, &a, 0, 0, 0, &x, 0, &y0, 0);
         rmatrixmv(sn, sn, &a, 0, 0, 0, &x, 0, &y1, 0);
         for (j = 0; j < sn; j++) {
            c = 0.0;
            for (k = 0; k < sn; k++) {
               c -= xori.xR[k] * a.xyR[k][j];
            }
            g.xR[j] = b.xR[j] + c + y0.xR[j] + y1.xR[j];
         }
         anti = testminqpunit_projectedantigradnorm(sn, &x, &b, &db, &ub);
         printf("SN=%0d\n", (int)sn);
         printf("NEXP=%0d\n", (int)i);
         printf("TermType=%0d\n", (int)rep.terminationtype);
         for (j = 0; j < sn; j++) {
            printf("X[%0d]=%0.5f;\n", (int)j, x.xR[j]);
            printf("DB[%0d]=%0.5f; UB[%0d]=%0.5f\n", (int)j, db.xR[j], (int)j, ub.xR[j]);
            printf("XORi[%0d]=%0.5f; XORiC[%0d]=%0.5f;\n", (int)j, xori.xR[j], (int)j, xoric.xR[j]);
            printf("Anti[%0d]=%0.5f;\n", (int)j, anti);
            if (fabs(anti) > eps) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Convert dense matrix to sparse matrix using random format
static void testminqpunit_densetosparse(RMatrix *a, ae_int_t n, sparsematrix *s) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(&_frame_block);
   SetObj(sparsematrix, s);
   NewObj(sparsematrix, s0);
   sparsecreate(n, n, n * n, &s0);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         sparseset(&s0, i, j, a->xyR[i][j]);
      }
   }
   sparsecopytobuf(&s0, randominteger(3), s);
   ae_frame_leave();
}

// This function tests that norm of bound-constrained gradient at point X is
// less than Eps:
// * unconstrained gradient is A*x+b
// * if I-th component is at the boundary, and antigradient points outside of
//   the feasible area, I-th component of constrained gradient is zero
//
// This function accepts QP terms A and B, bound constraints, current point,
// and performs test. Additionally, it checks that point is feasible w.r.t.
// boundary constraints.
//
// In case of failure, error flag is set. Otherwise, it is not modified.
//
// IMPORTANT: this function does NOT use SetErrorFlag() to modify flag.
//            If you want to use SetErrorFlag() for easier tracking of errors,
//            you should store flag returned by this function into separate
//            variable TmpFlag and call SetErrorFlag(ErrorFlag, TmpFlag) yourself.
static void testminqpunit_testbcgradandfeasibility(RMatrix *a, RVector *b, RVector *bndl, RVector *bndu, ae_int_t n, RVector *x, double eps, bool *errorflag) {
   ae_int_t i;
   ae_int_t j;
   double g;
   double gnorm;
   gnorm = 0.0;
   for (i = 0; i < n; i++) {
      g = b->xR[i];
      for (j = 0; j < n; j++) {
         g += a->xyR[i][j] * x->xR[j];
      }
      if (x->xR[i] == bndl->xR[i] && g > 0.0) {
         g = 0.0;
      }
      if (x->xR[i] == bndu->xR[i] && g < 0.0) {
         g = 0.0;
      }
      gnorm += sqr(g);
      if (x->xR[i] < bndl->xR[i]) {
         *errorflag = true;
      }
      if (x->xR[i] > bndu->xR[i]) {
         *errorflag = true;
      }
   }
   gnorm = sqrt(gnorm);
   if (gnorm > eps) {
      *errorflag = true;
   }
}

// This function performs tests specific for QuickQP solver
//
// Returns True on failure.
static bool quickqptests() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double g;
   double gnorm;
   bool flag;
   ae_int_t origintype;
   ae_int_t scaletype;
   bool isupper;
   bool issparse;
   ae_int_t itscnt;
   ae_int_t nidx;
   double eps;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   NewVector(nlist, 0, DT_INT);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(za, 0, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewMatrix(halfa, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewVector(ct, 0, DT_INT);
   NewVector(b, 0, DT_REAL);
   NewVector(zb, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(xend0, 0, DT_REAL);
   NewVector(xend1, 0, DT_REAL);
   NewVector(xori, 0, DT_REAL);
   NewVector(xz, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   result = false;
   hqrndrandomize(&rs);
// Convex unconstrained test:
// * N dimensions
// * positive-definite A
// * algorithm randomly choose dense or sparse A, and for
//   sparse matrix it randomly choose format.
// * random B with normal entries
// * initial point is random, feasible
// * random origin (zero or non-zero) and scale (unit or
//   non-unit) are generated
   eps = 1.0E-5;
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         origintype = hqrnduniformi(&rs, 2);
         scaletype = hqrnduniformi(&rs, 2);
         isupper = hqrnduniformr(&rs) < 0.5;
         issparse = hqrnduniformr(&rs) < 0.5;
         spdmatrixrndcond(n, 1.0E3, &fulla);
         ae_matrix_set_length(&halfa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper ? j >= i : j <= i) {
                  halfa.xyR[i][j] = fulla.xyR[i][j];
               } else {
                  halfa.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         }
         testminqpunit_densetosparse(&halfa, n, &sa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xori, n);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            x0.xR[i] = hqrndnormal(&rs);
            if (origintype == 0) {
               xori.xR[i] = 0.0;
            } else {
               xori.xR[i] = hqrndnormal(&rs);
            }
            if (scaletype == 0) {
               s.xR[i] = 1.0;
            } else {
               s.xR[i] = exp(0.5 * hqrndnormal(&rs));
            }
         }
      // Solve problem
         minqpcreate(n, &state);
         minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 0, hqrnduniformr(&rs) > 0.5);
         minqpsetlinearterm(&state, &b);
         if (issparse) {
            minqpsetquadratictermsparse(&state, &sa, isupper);
         } else {
            minqpsetquadraticterm(&state, &halfa, isupper);
         }
         if (origintype != 0) {
            minqpsetorigin(&state, &xori);
         }
         if (scaletype != 0) {
            minqpsetscale(&state, &s);
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:5703");
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return result;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            g = b.xR[i];
            for (j = 0; j < n; j++) {
               g += fulla.xyR[i][j] * (x1.xR[j] - xori.xR[j]);
            }
            gnorm += sqr(g);
         }
         gnorm = sqrt(gnorm);
         set_error_flag(&result, gnorm > eps, __FILE__, __LINE__, "testminqpunit.ap:5721");
      }
   }
// Convex test:
// * N dimensions
// * random number (0..N) of random boundary constraints
// * positive-definite A
// * algorithm randomly choose dense or sparse A, and for
//   sparse matrix it randomly choose format.
// * random B with normal entries
// * initial point is random, feasible
// * random origin (zero or non-zero) and scale (unit or
//   non-unit) are generated
   eps = 1.0E-5;
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         origintype = hqrnduniformi(&rs, 2);
         scaletype = hqrnduniformi(&rs, 2);
         isupper = hqrnduniformr(&rs) < 0.5;
         issparse = hqrnduniformr(&rs) < 0.5;
         spdmatrixrndcond(n, 1.0E3, &fulla);
         ae_matrix_set_length(&halfa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper ? j >= i : j <= i) {
                  halfa.xyR[i][j] = fulla.xyR[i][j];
               } else {
                  halfa.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         }
         testminqpunit_densetosparse(&halfa, n, &sa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xori, n);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = -INFINITY;
            bndu.xR[i] = +INFINITY;
            x0.xR[i] = hqrndnormal(&rs);
            if (origintype == 0) {
               xori.xR[i] = 0.0;
            } else {
               xori.xR[i] = hqrndnormal(&rs);
            }
            if (scaletype == 0) {
               s.xR[i] = 1.0;
            } else {
               s.xR[i] = exp(0.5 * hqrndnormal(&rs));
            }
            j = hqrnduniformi(&rs, 5);
            if (j == 0) {
               bndl.xR[i] = 0.0;
               x0.xR[i] = fabs(x0.xR[i]);
            }
            if (j == 1) {
               bndu.xR[i] = 0.0;
               x0.xR[i] = -fabs(x0.xR[i]);
            }
            if (j == 2) {
               bndl.xR[i] = hqrndnormal(&rs);
               bndu.xR[i] = bndl.xR[i];
               x0.xR[i] = bndl.xR[i];
            }
            if (j == 3) {
               bndl.xR[i] = -0.1;
               bndu.xR[i] = 0.1;
               x0.xR[i] = 0.2 * hqrnduniformr(&rs) - 0.1;
            }
         }
      // Solve problem
         minqpcreate(n, &state);
         minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 0, hqrnduniformr(&rs) > 0.5);
         minqpsetlinearterm(&state, &b);
         if (issparse) {
            minqpsetquadratictermsparse(&state, &sa, isupper);
         } else {
            minqpsetquadraticterm(&state, &halfa, isupper);
         }
         if (origintype != 0) {
            minqpsetorigin(&state, &xori);
         }
         if (scaletype != 0) {
            minqpsetscale(&state, &s);
         }
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:5818");
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return result;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            g = b.xR[i];
            for (j = 0; j < n; j++) {
               g += fulla.xyR[i][j] * (x1.xR[j] - xori.xR[j]);
            }
            if (x1.xR[i] == bndl.xR[i] && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] == bndu.xR[i] && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            set_error_flag(&result, x1.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminqpunit.ap:5838");
            set_error_flag(&result, x1.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminqpunit.ap:5839");
         }
         gnorm = sqrt(gnorm);
         set_error_flag(&result, gnorm > eps, __FILE__, __LINE__, "testminqpunit.ap:5842");
      }
   }
// Strongly non-convex test:
// * N dimensions, N >= 2
// * box constraints, x[i] in [-1,+1]
// * A = A0-0.5*I, where A0 is SPD with unit norm and smallest
//   singular value equal to 1.0E-3, I is identity matrix
// * random B with normal entries
// * initial point is random, feasible
//
// We perform two tests:
// * unconstrained problem must be recognized as unbounded
// * constrained problem can be successfully solved
//
// NOTE: it is important to have N >= 2, because formula for A
//       can be applied only to matrix with at least two
//       singular values
   eps = 1.0E-5;
   for (n = 2; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         spdmatrixrndcond(n, 1.0E3, &fulla);
         for (i = 0; i < n; i++) {
            fulla.xyR[i][i] -= 0.5;
         }
         isupper = hqrnduniformr(&rs) < 0.5;
         ae_matrix_set_length(&halfa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper ? j >= i : j <= i) {
                  halfa.xyR[i][j] = fulla.xyR[i][j];
               } else {
                  halfa.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         }
         testminqpunit_densetosparse(&halfa, n, &sa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = -1.0;
            bndu.xR[i] = 1.0;
            x0.xR[i] = 2 * hqrnduniformr(&rs) - 1;
         }
      // Solve problem:
      // * without constraints we expect failure
      // * with constraints algorithm must succeed
         minqpcreate(n, &state);
         minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 0, hqrnduniformr(&rs) > 0.5);
         minqpsetlinearterm(&state, &b);
         if (hqrndnormal(&rs) > 0.0) {
            minqpsetquadraticterm(&state, &halfa, isupper);
         } else {
            minqpsetquadratictermsparse(&state, &sa, isupper);
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(&result, rep.terminationtype != -4, __FILE__, __LINE__, "testminqpunit.ap:5907");
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:5911");
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return result;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(fulla.xyR[i], 1, x1.xR, 1, n);
            g = v + b.xR[i];
            if (x1.xR[i] == bndl.xR[i] && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] == bndu.xR[i] && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            set_error_flag(&result, x1.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminqpunit.ap:5930");
            set_error_flag(&result, x1.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminqpunit.ap:5931");
         }
         gnorm = sqrt(gnorm);
         set_error_flag(&result, gnorm > eps, __FILE__, __LINE__, "testminqpunit.ap:5934");
      }
   }
// Basic semi-definite test:
// * N dimensions, N >= 2
// * box constraints, x[i] in [-1,+1]
//       [ 1 1 ... 1 1 ]
// * A = [ ... ... ... ], with one (random) diagonal entry set to -1
//       [ 1 1 ... 1 1 ]
// * random B with normal entries
// * initial point is random, feasible
//
// We perform two tests:
// * unconstrained problem must be recognized as unbounded
// * constrained problem must be recognized as bounded and
//   successfully solved
//
// Both problems require subtle programming when we work
// with semidefinite QP.
//
// NOTE: unlike BLEIC-QP algorthm, QQP may detect unboundedness
//       of the problem when started from any x0, with any b.
//       BLEIC-based solver requires carefully chosen x0 and b
//       to find direction of zero curvature, but this solver
//       can find it from any point.
   ae_vector_set_length(&nlist, 12);
   nlist.xZ[0] = 2;
   nlist.xZ[1] = 3;
   nlist.xZ[2] = 4;
   nlist.xZ[3] = 5;
   nlist.xZ[4] = 6;
   nlist.xZ[5] = 7;
   nlist.xZ[6] = 8;
   nlist.xZ[7] = 9;
   nlist.xZ[8] = 10;
   nlist.xZ[9] = 20;
   nlist.xZ[10] = 40;
   nlist.xZ[11] = 80;
   eps = 1.0E-5;
   for (nidx = 0; nidx < nlist.cnt; nidx++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         n = nlist.xZ[nidx];
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            do {
               b.xR[i] = hqrndnormal(&rs);
            } while (b.xR[i] == 0.0);
            bndl.xR[i] = -1.0;
            bndu.xR[i] = 1.0;
            x0.xR[i] = 2 * hqrnduniformr(&rs) - 1;
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 1.0;
            }
         }
         j = hqrnduniformi(&rs, n);
         a.xyR[j][j] = -1.0;
         testminqpunit_densetosparse(&a, n, &sa);
      // Solve problem:
      // * without constraints we expect failure
      // * with constraints algorithm must succeed
         minqpcreate(n, &state);
         minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 0, hqrnduniformr(&rs) > 0.5);
         minqpsetlinearterm(&state, &b);
         if (hqrndnormal(&rs) > 0.0) {
            minqpsetquadraticterm(&state, &a, true);
         } else {
            minqpsetquadratictermsparse(&state, &sa, true);
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(&result, rep.terminationtype != -4, __FILE__, __LINE__, "testminqpunit.ap:6017");
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:6021");
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return result;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            g = b.xR[i];
            for (j = 0; j < n; j++) {
               g += a.xyR[i][j] * x1.xR[j];
            }
            if (x1.xR[i] == bndl.xR[i] && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] == bndu.xR[i] && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            set_error_flag(&result, x1.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminqpunit.ap:6042");
            set_error_flag(&result, x1.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminqpunit.ap:6043");
         }
         gnorm = sqrt(gnorm);
         set_error_flag(&result, gnorm > eps, __FILE__, __LINE__, "testminqpunit.ap:6046");
      }
   }
// Linear (zero-quadratic) test:
// * N dimensions, N >= 1
// * box constraints, x[i] in [-1,+1]
// * A = 0
// * random B with normal entries
// * initial point is random, feasible
//
// We perform two tests:
// * unconstrained problem must be recognized as unbounded
// * constrained problem can be successfully solved
//
// NOTE: we may explicitly set zero A, or assume that by
//       default it is zero. During test we will try both
//       ways.
   eps = 1.0E-5;
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            do {
               b.xR[i] = hqrndnormal(&rs);
            } while (b.xR[i] == 0.0);
            bndl.xR[i] = -1.0;
            bndu.xR[i] = 1.0;
            x0.xR[i] = 2 * hqrnduniformr(&rs) - 1;
         }
      // Solve problem:
      // * without constraints we expect failure
      // * with constraints algorithm must succeed
         minqpcreate(n, &state);
         minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 0, hqrnduniformr(&rs) > 0.5);
         minqpsetlinearterm(&state, &b);
         if (hqrndnormal(&rs) > 0.0) {
            ae_matrix_set_length(&a, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
            }
            minqpsetquadraticterm(&state, &a, true);
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(&result, rep.terminationtype != -4, __FILE__, __LINE__, "testminqpunit.ap:6104");
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:6108");
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return result;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         for (i = 0; i < n; i++) {
            set_error_flag(&result, b.xR[i] > 0.0 && x1.xR[i] > bndl.xR[i], __FILE__, __LINE__, "testminqpunit.ap:6118");
            set_error_flag(&result, b.xR[i] < 0.0 && x1.xR[i] < bndu.xR[i], __FILE__, __LINE__, "testminqpunit.ap:6119");
         }
      }
   }
// Test for Newton phase of QQP algorithm - we test that Newton
// phase can find good solution within one step. In order to do
// so we:
// * solve convex QP problem (dense or sparse)
// * with K <= N equality-only constraints ai=x=bi
// * with number of outer iterations limited to just 1
// * and with CG phase turned off (we modify internal structures
//   of the QQP solver in order to make it)
   eps = 1.0E-5;
   for (pass = 1; pass <= 10; pass++) {
   // Generate problem
      n = 50 + hqrnduniformi(&rs, 51);
      spdmatrixrndcond(n, 1.0E3, &a);
      testminqpunit_densetosparse(&a, n, &sa);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         b.xR[i] = hqrndnormal(&rs);
         x0.xR[i] = hqrndnormal(&rs);
         if (hqrndnormal(&rs) > 0.0) {
            bndl.xR[i] = -INFINITY;
            bndu.xR[i] = +INFINITY;
         } else {
            bndl.xR[i] = hqrndnormal(&rs);
            bndu.xR[i] = bndl.xR[i];
         }
      }
   // Solve problem
   //
   // NOTE: we modify internal structures of QQP solver in order
   //       to deactivate CG phase
      minqpcreate(n, &state);
      minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 1, true);
      state.qqpsettingsuser.cgphase = false;
      minqpsetlinearterm(&state, &b);
      if (hqrndnormal(&rs) > 0.0) {
         minqpsetquadraticterm(&state, &a, hqrndnormal(&rs) > 0.0);
      } else {
         minqpsetquadratictermsparse(&state, &sa, hqrndnormal(&rs) > 0.0);
      }
      minqpsetbc(&state, &bndl, &bndu);
      minqpoptimize(&state);
      minqpresults(&state, &x1, &rep);
      set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:6179");
      if (rep.terminationtype <= 0) {
         ae_frame_leave();
         return result;
      }
   // Test - calculate constrained gradient at solution,
   // check its norm.
      gnorm = 0.0;
      for (i = 0; i < n; i++) {
         g = b.xR[i];
         for (j = 0; j < n; j++) {
            g += a.xyR[i][j] * x1.xR[j];
         }
         if (x1.xR[i] == bndl.xR[i] && g > 0.0) {
            g = 0.0;
         }
         if (x1.xR[i] == bndu.xR[i] && g < 0.0) {
            g = 0.0;
         }
         gnorm += sqr(g);
         set_error_flag(&result, x1.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminqpunit.ap:6199");
         set_error_flag(&result, x1.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminqpunit.ap:6200");
      }
      gnorm = sqrt(gnorm);
      set_error_flag(&result, gnorm > eps, __FILE__, __LINE__, "testminqpunit.ap:6203");
   }
// Test for Newton phase of QQP algorithm - we test that Newton
// updates work correctly, i.e. that CNewtonUpdate() internal
// function correctly updates inverse Hessian matrix.
//
// To test it we:
// * solve ill conditioned convex QP problem
// * with unconstrained solution XZ whose components are within [-0.5,+0.5]
// * with one inequality constraint X[k] >= 5
// * with initial point such that:
//   * X0[i] = 100       for i != k
//   * X0[k] = 5+1.0E-5
// * with number of outer iterations limited to just 1
// * and with CG phase turned off (we modify internal structures
//   of the QQP solver in order to make it)
//
// The idea is that single Newton step is not enough to find solution,
// but with just one update we can move exactly to the solution.
//
// We perform two tests:
// * first one with State.QQP.NewtMaxIts set to 1, in order to
//   make sure that algorithm fails with just one iteration
// * second one with State.QQP.NewtMaxIts set to 2, in order to
//   make sure that algorithm converges when it can perform update
   eps = 1.0E-5;
   for (pass = 1; pass <= 10; pass++) {
   // Generate problem
      n = 20 + hqrnduniformi(&rs, 20);
      spdmatrixrndcond(n, 1.0E5, &a);
      testminqpunit_densetosparse(&a, n, &sa);
      sparseconverttocrs(&sa);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&xz, n);
      for (i = 0; i < n; i++) {
         xz.xR[i] = hqrnduniformr(&rs) - 0.5;
         x0.xR[i] = 100.0;
         bndl.xR[i] = -INFINITY;
         bndu.xR[i] = +INFINITY;
      }
      k = hqrnduniformi(&rs, n);
      x0.xR[k] = 5.00001;
      bndl.xR[k] = 5.0;
      sparsemv(&sa, &xz, &b);
      for (i = 0; i < n; i++) {
         b.xR[i] = -b.xR[i];
      }
   // Create solver
      minqpcreate(n, &state);
      minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 1, true);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, hqrndnormal(&rs) > 0.0);
      minqpsetbc(&state, &bndl, &bndu);
      minqpsetstartingpoint(&state, &x0);
   // Solve problem. First time, with no Newton updates.
   // It must fail.
   //
   // NOTE: we modify internal structures of QQP solver in order
   //       to deactivate CG phase and turn off Newton updates.
      state.qqpsettingsuser.cgphase = false;
      state.qqpsettingsuser.cnphase = true;
      state.qqpsettingsuser.cnmaxupdates = 0;
      minqpoptimize(&state);
      minqpresults(&state, &x1, &rep);
      set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:6282");
      if (result) {
         ae_frame_leave();
         return result;
      }
      flag = false;
      testminqpunit_testbcgradandfeasibility(&a, &b, &bndl, &bndu, n, &x1, eps, &flag);
      set_error_flag(&result, !flag, __FILE__, __LINE__, "testminqpunit.ap:6287");
   // Now with Newton updates - it must succeeed.
      state.qqpsettingsuser.cgphase = false;
      state.qqpsettingsuser.cnmaxupdates = n;
      minqpoptimize(&state);
      minqpresults(&state, &x1, &rep);
      set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:6296");
      if (result) {
         ae_frame_leave();
         return result;
      }
      flag = false;
      testminqpunit_testbcgradandfeasibility(&a, &b, &bndl, &bndu, n, &x1, eps, &flag);
      set_error_flag(&result, flag, __FILE__, __LINE__, "testminqpunit.ap:6301");
   }
// Check that problem with general constraints results in
// correct error code (-5 should be returned).
   ae_matrix_set_length(&c, 1, 3);
   ae_vector_set_length(&ct, 1);
   c.xyR[0][0] = 1.0;
   c.xyR[0][1] = 1.0;
   c.xyR[0][2] = 2.0;
   ct.xZ[0] = 0;
   minqpcreate(2, &state);
   minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 0, hqrnduniformr(&rs) > 0.5);
   minqpsetlc(&state, &c, &ct, 1);
   minqpoptimize(&state);
   minqpresults(&state, &x1, &rep);
   set_error_flag(&result, rep.terminationtype != -5, __FILE__, __LINE__, "testminqpunit.ap:6319");
// Test sparse functionality. QQP solver must perform
// same steps independently of matrix type (dense or sparse).
//
// We generate random unconstrained test problem and solve it
// twice - first time we solve dense version, second time -
// sparse version is solved.
//
// During this test we:
// * use stringent stopping criteria (one outer iteration)
// * turn off Newton phase of the algorithm to slow down
//   convergence
   eps = 1.0E-3;
   itscnt = 1;
   n = 20;
   isupper = randombool();
   spdmatrixrndcond(n, 1.0E3, &za);
   sparsecreate(n, n, 0, &sa);
   ae_matrix_set_length(&a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (j >= i && isupper) {
            sparseset(&sa, i, j, za.xyR[i][j]);
            a.xyR[i][j] = za.xyR[i][j];
         }
         if (j <= i && !isupper) {
            sparseset(&sa, i, j, za.xyR[i][j]);
            a.xyR[i][j] = za.xyR[i][j];
         }
      }
   }
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&s, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = randomnormal();
      s.xR[i] = pow(10.0, randomnormal() / 10);
   }
   minqpcreate(n, &state);
   minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, itscnt, false);
   minqpsetscale(&state, &s);
   minqpsetlinearterm(&state, &b);
   minqpsetquadraticterm(&state, &a, isupper);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   minqpcreate(n, &state);
   minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, itscnt, false);
   minqpsetscale(&state, &s);
   minqpsetlinearterm(&state, &b);
   minqpsetquadratictermsparse(&state, &sa, isupper);
   minqpoptimize(&state);
   minqpresults(&state, &xend1, &rep);
   for (i = 0; i < n; i++) {
      set_error_flag(&result, fabs(xend0.xR[i] - xend1.xR[i]) > eps, __FILE__, __LINE__, "testminqpunit.ap:6437");
   }
// Test scale-invariance. QQP performs same steps on scaled and
// unscaled problems (assuming that scale of the variables is known).
//
// We generate random scale matrix S and random well-conditioned and
// well scaled matrix A. Then we solve two problems:
//
//     (1) f = 0.5*x'*A*x+b'*x
//         (identity scale matrix is used)
//
// and
//
//     (2) f = 0.5*y'*(inv(S)*A*inv(S))*y + (inv(S)*b)'*y
//         (scale matrix S is used)
//
// Solution process is started from X=0, we perform ItsCnt=1 outer
// iterations with Newton phase turned off (to slow down convergence;
// we want to prevent algorithm from converging to exact solution which
// is exactly same for both problems; the idea is to test that same
// intermediate tests are taken).
//
// As result, we must get S*x=y
   eps = 1.0E-3;
   itscnt = 1;
   n = 100;
   ae_vector_set_length(&s, n);
   for (i = 0; i < n; i++) {
      s.xR[i] = pow(10.0, randomnormal() / 10);
   }
   spdmatrixrndcond(n, 1.0E3, &a);
   ae_matrix_set_length(&za, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         za.xyR[i][j] = a.xyR[i][j] / (s.xR[i] * s.xR[j]);
      }
   }
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&zb, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = randomnormal();
      zb.xR[i] = b.xR[i] / s.xR[i];
   }
   minqpcreate(n, &state);
   minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, itscnt, false);
   minqpsetlinearterm(&state, &b);
   minqpsetquadraticterm(&state, &a, true);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   minqpcreate(n, &state);
   minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, itscnt, false);
   minqpsetlinearterm(&state, &zb);
   minqpsetquadraticterm(&state, &za, true);
   minqpsetscale(&state, &s);
   minqpoptimize(&state);
   minqpresults(&state, &xend1, &rep);
   for (i = 0; i < n; i++) {
      set_error_flag(&result, fabs(s.xR[i] * xend0.xR[i] - xend1.xR[i]) > eps, __FILE__, __LINE__, "testminqpunit.ap:6494");
   }
// Test that QQP can efficiently use sparse matrices (i.e. it is
// not disguised version of some dense QP solver). In order to test
// it we create very large and very sparse problem (diagonal matrix
// with N=40.000) and perform 10 iterations of QQP solver.
//
// In case QP solver uses some form of dense linear algebra to solve
// this problem, it will take TOO much time to solve it. And we will
// notice it by EXTREME slowdown during testing.
   n = 40000;
   sparsecreate(n, n, 0, &sa);
   for (i = 0; i < n; i++) {
      sparseset(&sa, i, i, pow(10.0, -3 * randomreal()));
   }
   ae_vector_set_length(&b, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = randomnormal();
   }
   minqpcreate(n, &state);
   minqpsetalgoquickqp(&state, 0.0, 0.0, 0.0, 10, hqrnduniformr(&rs) > 0.5);
   minqpsetlinearterm(&state, &b);
   minqpsetquadratictermsparse(&state, &sa, true);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   ae_frame_leave();
   return result;
}

// This function performs tests specific for BLEIC solver
//
// Returns True on error, False on success.
static bool bleictests() {
   ae_frame _frame_block;
   ae_int_t nidx;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   double eps;
   double v;
   double g;
   double gnorm;
   ae_int_t itscnt;
   bool isupper;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   NewVector(nlist, 0, DT_INT);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(za, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(zb, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(sparsematrix, sa);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   NewVector(xend0, 0, DT_REAL);
   NewVector(xend1, 0, DT_REAL);
   result = false;
   hqrndrandomize(&rs);
// Test sparse functionality. BLEIC-based solver must perform
// same steps independently of matrix type (dense or sparse).
//
// We generate random unconstrained test problem and solve it
// twice - first time we solve dense version, second time -
// sparse version is solved.
   eps = 1.0E-3;
   itscnt = 5;
   n = 20;
   isupper = randombool();
   spdmatrixrndcond(n, 1.0E3, &za);
   sparsecreate(n, n, 0, &sa);
   ae_matrix_set_length(&a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         if (j >= i && isupper) {
            sparseset(&sa, i, j, za.xyR[i][j]);
            a.xyR[i][j] = za.xyR[i][j];
         }
         if (j <= i && !isupper) {
            sparseset(&sa, i, j, za.xyR[i][j]);
            a.xyR[i][j] = za.xyR[i][j];
         }
      }
   }
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&s, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = randomnormal();
      s.xR[i] = pow(10.0, randomnormal() / 10);
   }
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, 0.0, 0.0, 0.0, itscnt);
   minqpsetlinearterm(&state, &b);
   minqpsetquadraticterm(&state, &a, isupper);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, 0.0, 0.0, 0.0, itscnt);
   minqpsetlinearterm(&state, &b);
   minqpsetquadratictermsparse(&state, &sa, isupper);
   minqpoptimize(&state);
   minqpresults(&state, &xend1, &rep);
   for (i = 0; i < n; i++) {
      set_error_flag(&result, fabs(xend0.xR[i] - xend1.xR[i]) > eps, __FILE__, __LINE__, "testminqpunit.ap:6609");
   }
// Test scale-invariance. BLEIC performs same steps on scaled and
// unscaled problems (assuming that scale of the variables is known).
//
// We generate random scale matrix S and random well-conditioned and
// well scaled matrix A. Then we solve two problems:
//
//     (1) f = 0.5*x'*A*x+b'*x
//         (identity scale matrix is used)
//
// and
//
//     (2) f = 0.5*y'*(inv(S)*A*inv(S))*y + (inv(S)*b)'*y
//         (scale matrix S is used)
//
// Solution process is started from X=0, we perform ItsCnt=5 steps.
// As result, we must get S*x=y
   eps = 1.0E-3;
   itscnt = 5;
   n = 20;
   ae_vector_set_length(&s, n);
   for (i = 0; i < n; i++) {
      s.xR[i] = pow(10.0, randomnormal() / 10);
   }
   spdmatrixrndcond(n, 1.0E3, &a);
   ae_matrix_set_length(&za, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         za.xyR[i][j] = a.xyR[i][j] / (s.xR[i] * s.xR[j]);
      }
   }
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&zb, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = randomnormal();
      zb.xR[i] = b.xR[i] / s.xR[i];
   }
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, 0.0, 0.0, 0.0, itscnt);
   minqpsetlinearterm(&state, &b);
   minqpsetquadraticterm(&state, &a, true);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, 0.0, 0.0, 0.0, itscnt);
   minqpsetlinearterm(&state, &zb);
   minqpsetquadraticterm(&state, &za, true);
   minqpsetscale(&state, &s);
   minqpoptimize(&state);
   minqpresults(&state, &xend1, &rep);
   for (i = 0; i < n; i++) {
      set_error_flag(&result, fabs(s.xR[i] * xend0.xR[i] - xend1.xR[i]) > eps, __FILE__, __LINE__, "testminqpunit.ap:6662");
   }
// Test that BLEIC can efficiently use sparse matrices (i.e. it is
// not disguised version of some dense QP solver). In order to test
// it we create very large and very sparse problem (diagonal matrix
// with N=20.000) and perform 10 iterations of BLEIC-based QP solver.
//
// In case QP solver uses some form of dense linear algebra to solve
// this problem, it will take TOO much time to solve it. And we will
// notice it by EXTREME slowdown during testing.
   n = 20000;
   sparsecreate(n, n, 0, &sa);
   for (i = 0; i < n; i++) {
      sparseset(&sa, i, i, pow(10.0, -3 * randomreal()));
   }
   ae_vector_set_length(&b, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = randomnormal();
   }
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, 0.0, 0.0, 0.0, 10);
   minqpsetlinearterm(&state, &b);
   minqpsetquadratictermsparse(&state, &sa, true);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
// Special semi-definite test:
// * N dimensions, N >= 2 (important!)
// * box constraints, x[i] in [-1,+1]
//       [ 1 1 ... 1 1 ]
// * A = [ ... ... ... ]
//       [ 1 1 ... 1 1 ]
// * random B such that SUM(b[i])=0.0 (important!)
// * initial point x0 is chosen in such way that SUM(x[i])=0.0
//   (important!)
//
// We perform two tests:
// * unconstrained problem must be recognized as unbounded
//   (when starting from x0!)
// * constrained problem must be recognized as bounded
//   and successfully solved
//
// Both problems require subtle programming when we work
// with semidefinite QP.
//
// NOTE: it is very important to have N >= 2 (otherwise problem
//       will be bounded from below even without boundary
//       constraints) and to have x0/b0 such that sum of
//       components is zero (such x0 is exact minimum of x'*A*x,
//       which allows algorithm to find direction of zero curvature
//       at the very first step). If x0/b are chosen in other way,
//       algorithm may be unable to find direction of zero
//       curvature and will cycle forever, slowly decreasing
//       function value at each iteration.
//       This is major difference from similar test for QQP solver -
//       QQP can find direction of zero curvature from almost any
//       point due to internal CG solver which favors such directions.
//       BLEIC uses LBFGS, which is less able to find direction of
//       zero curvature.
   ae_vector_set_length(&nlist, 12);
   nlist.xZ[0] = 2;
   nlist.xZ[1] = 3;
   nlist.xZ[2] = 4;
   nlist.xZ[3] = 5;
   nlist.xZ[4] = 6;
   nlist.xZ[5] = 7;
   nlist.xZ[6] = 8;
   nlist.xZ[7] = 9;
   nlist.xZ[8] = 10;
   nlist.xZ[9] = 20;
   nlist.xZ[10] = 40;
   nlist.xZ[11] = 80;
   eps = 1.0E-5;
   for (nidx = 0; nidx < nlist.cnt; nidx++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         n = nlist.xZ[nidx];
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            do {
               b.xR[i] = hqrndnormal(&rs);
            } while (b.xR[i] == 0.0);
            bndl.xR[i] = -1.0;
            bndu.xR[i] = 1.0;
            x0.xR[i] = 2 * hqrnduniformr(&rs) - 1;
         }
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += x0.xR[i];
         }
         for (i = 0; i < n; i++) {
            x0.xR[i] -= v / n;
         }
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += b.xR[i];
         }
         for (i = 0; i < n; i++) {
            b.xR[i] -= v / n;
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 1.0;
            }
         }
         testminqpunit_densetosparse(&a, n, &sa);
      // Solve problem:
      // * without constraints we expect failure
      // * with constraints algorithm must succeed
         minqpcreate(n, &state);
         minqpsetalgobleic(&state, 0.0, 0.0, 0.0, 0);
         minqpsetlinearterm(&state, &b);
         minqpsetstartingpoint(&state, &x0);
         if (hqrndnormal(&rs) > 0.0) {
            minqpsetquadraticterm(&state, &a, true);
         } else {
            minqpsetquadratictermsparse(&state, &sa, true);
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(&result, rep.terminationtype != -4, __FILE__, __LINE__, "testminqpunit.ap:6790");
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:6794");
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return result;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            g = b.xR[i];
            for (j = 0; j < n; j++) {
               g += a.xyR[i][j] * x1.xR[j];
            }
            if (x1.xR[i] == bndl.xR[i] && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] == bndu.xR[i] && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            set_error_flag(&result, x1.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminqpunit.ap:6814");
            set_error_flag(&result, x1.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminqpunit.ap:6815");
         }
         gnorm = sqrt(gnorm);
         set_error_flag(&result, gnorm > eps, __FILE__, __LINE__, "testminqpunit.ap:6818");
      }
   }
// Test that BLEIC-based QP solver can solve non-convex problems
// which are bounded from below on the feasible set:
//
//     min -||x||^2 s.t. x[i] in [-1,+1]
//
// We also test ability of the solver to detect unbounded problems
// (we remove one of the constraints and repeat solution process).
   n = 20;
   eps = 1.0E-14;
   sparsecreate(n, n, 0, &sa);
   for (i = 0; i < n; i++) {
      sparseset(&sa, i, i, -1.0);
   }
   ae_vector_set_length(&bndl, n);
   ae_vector_set_length(&bndu, n);
   ae_vector_set_length(&x, n);
   for (i = 0; i < n; i++) {
      bndl.xR[i] = -1.0;
      bndu.xR[i] = 1.0;
      x.xR[i] = randomreal() - 0.5;
   }
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, eps, 0.0, 0.0, 0);
   minqpsetquadratictermsparse(&state, &sa, true);
   minqpsetbc(&state, &bndl, &bndu);
   minqpsetstartingpoint(&state, &x);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:6851");
   if (rep.terminationtype > 0) {
      for (i = 0; i < n; i++) {
         set_error_flag(&result, xend0.xR[i] != -1.0 && xend0.xR[i] != 1.0, __FILE__, __LINE__, "testminqpunit.ap:6854");
      }
   }
   i = randominteger(n);
   bndl.xR[i] = -INFINITY;
   bndu.xR[i] = +INFINITY;
   minqpsetbc(&state, &bndl, &bndu);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   set_error_flag(&result, rep.terminationtype != -4, __FILE__, __LINE__, "testminqpunit.ap:6861");
// Test that BLEIC-based QP solver can solve non-convex problems
// which are bounded from below on the feasible set:
//
//     min -||x||^2 s.t. x[i] in [-1,+1],
//     with inequality constraints handled as general linear ones
//
// We also test ability of the solver to detect unbounded problems
// (we remove last pair of constraints and try to solve modified
// problem).
   n = 20;
   eps = 1.0E-14;
   sparsecreate(n, n, 0, &sa);
   for (i = 0; i < n; i++) {
      sparseset(&sa, i, i, -1.0);
   }
   ae_matrix_set_length(&c, 2 * n, n + 1);
   ae_vector_set_length(&ct, 2 * n);
   for (i = 0; i < n; i++) {
      for (j = 0; j <= n; j++) {
         c.xyR[2 * i + 0][j] = 0.0;
         c.xyR[2 * i + 1][j] = 0.0;
      }
      c.xyR[2 * i + 0][i] = 1.0;
      c.xyR[2 * i + 0][n] = 1.0;
      ct.xZ[2 * i + 0] = -1;
      c.xyR[2 * i + 1][i] = 1.0;
      c.xyR[2 * i + 1][n] = -1.0;
      ct.xZ[2 * i + 1] = 1;
   }
   ae_vector_set_length(&x, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = randomreal() - 0.5;
   }
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, eps, 0.0, 0.0, 0);
   minqpsetquadratictermsparse(&state, &sa, true);
   minqpsetlc(&state, &c, &ct, 2 * n);
   minqpsetstartingpoint(&state, &x);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:6906");
   if (rep.terminationtype > 0) {
      for (i = 0; i < n; i++) {
         set_error_flag(&result, fabs(xend0.xR[i] + 1) > 100 * machineepsilon && fabs(xend0.xR[i] - 1) > 100 * machineepsilon, __FILE__, __LINE__, "testminqpunit.ap:6909");
      }
   }
   minqpsetlc(&state, &c, &ct, 2 * (n - 1));
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   set_error_flag(&result, rep.terminationtype != -4, __FILE__, __LINE__, "testminqpunit.ap:6913");
// Test that BLEIC-based QP solver can solve QP problems with
// zero quadratic term:
//
//     min b'*x  s.t. x[i] in [-1,+1]
//
// It means that QP solver can be used as linear programming solver
// (altough performance of such solver is worse than that of specialized
// LP solver).
//
// NOTE: we perform this test twice - first time without explicitly setting
//       quadratic term (we test that default quadratic term is zero), and
//       second time - with explicitly set quadratic term.
   n = 20;
   sparsecreate(n, n, 0, &sa);
   ae_vector_set_length(&bndl, n);
   ae_vector_set_length(&bndu, n);
   ae_vector_set_length(&b, n);
   for (i = 0; i < n; i++) {
      bndl.xR[i] = -1.0;
      bndu.xR[i] = 1.0;
      b.xR[i] = randomnormal();
   }
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, eps, 0.0, 0.0, 0);
   minqpsetlinearterm(&state, &b);
   minqpsetbc(&state, &bndl, &bndu);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:6947");
   if (rep.terminationtype > 0) {
      for (i = 0; i < n; i++) {
         set_error_flag(&result, b.xR[i] > 0.0 && xend0.xR[i] != bndl.xR[i], __FILE__, __LINE__, "testminqpunit.ap:6951");
         set_error_flag(&result, b.xR[i] < 0.0 && xend0.xR[i] != bndu.xR[i], __FILE__, __LINE__, "testminqpunit.ap:6952");
      }
   }
   minqpcreate(n, &state);
   minqpsetalgobleic(&state, eps, 0.0, 0.0, 0);
   minqpsetlinearterm(&state, &b);
   minqpsetbc(&state, &bndl, &bndu);
   minqpsetquadratictermsparse(&state, &sa, true);
   minqpoptimize(&state);
   minqpresults(&state, &xend0, &rep);
   set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:6961");
   if (rep.terminationtype > 0) {
      for (i = 0; i < n; i++) {
         set_error_flag(&result, b.xR[i] > 0.0 && xend0.xR[i] != bndl.xR[i], __FILE__, __LINE__, "testminqpunit.ap:6965");
         set_error_flag(&result, b.xR[i] < 0.0 && xend0.xR[i] != bndu.xR[i], __FILE__, __LINE__, "testminqpunit.ap:6966");
      }
   }
// Test specific problem sent by V.Semenenko, which resulted in
// the initinite loop in FindFeasiblePoint (before fix). We do
// not test results returned by solver - simply being able to
// stop is enough for this test.
//
// NOTE: it is important that modifications to problem are applied
//       sequentially. Test fails after 100-5000 such modifications.
//       One modification is not enough to cause failure.
   n = 3;
   ae_matrix_set_length(&a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a.xyR[i][j] = 0.0;
      }
   }
   a.xyR[0][0] = 1.222990;
   a.xyR[1][1] = 1.934900;
   a.xyR[2][2] = 0.603924;
   ae_vector_set_length(&b, n);
   b.xR[0] = -4.97245;
   b.xR[1] = -9.09039;
   b.xR[2] = -4.63856;
   ae_matrix_set_length(&c, 8, n + 1);
   for (i = 0; i < c.rows; i++) {
      for (j = 0; j < n; j++) {
         c.xyR[i][j] = 0.0;
      }
   }
   c.xyR[0][0] = 1.0;
   c.xyR[0][n] = 4.94298;
   c.xyR[1][0] = 1.0;
   c.xyR[1][n] = 4.79981;
   c.xyR[2][1] = 1.0;
   c.xyR[2][n] = -0.4848;
   c.xyR[3][1] = 1.0;
   c.xyR[3][n] = -0.73804;
   c.xyR[4][2] = 1.0;
   c.xyR[4][n] = 0.575729;
   c.xyR[5][2] = 1.0;
   c.xyR[5][n] = 0.458645;
   c.xyR[6][0] = 1.0;
   c.xyR[6][2] = -1.0;
   c.xyR[6][n] = -0.0546574;
   c.xyR[7][0] = 1.0;
   c.xyR[7][2] = -1.0;
   c.xyR[7][n] = -0.5900440;
   ae_vector_set_length(&ct, 8);
   ct.xZ[0] = -1;
   ct.xZ[1] = 1;
   ct.xZ[2] = -1;
   ct.xZ[3] = 1;
   ct.xZ[4] = -1;
   ct.xZ[5] = 1;
   ct.xZ[6] = -1;
   ct.xZ[7] = 1;
   ae_vector_set_length(&s, n);
   s.xR[0] = 0.143171;
   s.xR[1] = 0.253240;
   s.xR[2] = 0.117084;
   ae_vector_set_length(&x0, n);
   x0.xR[0] = 3.51126;
   x0.xR[1] = 4.05731;
   x0.xR[2] = 6.63307;
   for (pass = 1; pass <= 10000; pass++) {
   // Apply random distortion
      for (j = 0; j < n; j++) {
         b.xR[j] += (2 * hqrnduniformi(&rs, 2) - 1) * 0.1;
      }
      for (j = 0; j < 6; j++) {
         c.xyR[j][n] += (2 * hqrnduniformi(&rs, 2) - 1) * 0.1;
      }
   // Solve
      minqpcreate(3, &state);
      minqpsetquadraticterm(&state, &a, true);
      minqpsetlinearterm(&state, &b);
      minqpsetlc(&state, &c, &ct, 8);
      minqpsetalgobleic(&state, 0.0, 0.0, 0.0, 0);
      minqpsetstartingpoint(&state, &x0);
      minqpoptimize(&state);
      minqpresults(&state, &x1, &rep);
   }
   ae_frame_leave();
   return result;
}

// set random type of the QP solver.
// All "modern" solvers can be chosen.
//
// Outputs:
//     BCTol   -   expected precision of box  constraints  handling  assuming
//                 unit scale of variables.
//     LCTol   -   expected precinion of linear constraints handling assuming
//                 unit scale of variables.
//
// Result:
//     Solver type:
//     *-1 for QuickQP
//     * 0 for BLEIC-QP
//     * 1 for DENSE-AUL
//     * 2 for DENSE-IPM
//     * 3 for SPARSE-IPM
//
// BCTol and LCTol have following meaning - if some constraint is active,  it
// means that we should be at most TOL units away from boundary. It is possible
// that zero value is returned.
//
// From definition it follows that if we stopped at more than TOL  units away
// from the boundary, gradient in corresponding direction is nearly zero.
static ae_int_t testminqpunit_setrandomalgoallmodern(minqpstate *s, double *bctol, double *lctol) {
   ae_int_t result;
   *bctol = 0;
   *lctol = 0;
   result = randominteger(5) - 1;
   if (result == -1) {
      minqpsetalgoquickqp(s, 1.0E-12, 0.0, 0.0, 0, randombool());
      *bctol = 0.0;
      *lctol = 0.0;
   }
   if (result == 0) {
      minqpsetalgobleic(s, 1.0E-12, 0.0, 0.0, 0);
      *bctol = 0.0;
      *lctol = 1.0E-8;
   }
   if (result == 1) {
      minqpsetalgodenseaul(s, 1.0E-12, 1000.0, 10);
      *bctol = 1.0E-3;
      *lctol = 1.0E-3;
   }
   if (result == 2) {
      minqpsetalgodenseipm(s, 1.0E-12);
      *bctol = 1.0E-3;
      *lctol = 1.0E-3;
   }
   if (result == 3) {
      minqpsetalgosparseipm(s, 1.0E-12);
      *bctol = 1.0E-3;
      *lctol = 1.0E-3;
   }
   return result;
}

// set random type of theQP solver
static void testminqpunit_setrandomalgononconvex(minqpstate *s) {
   ae_int_t i;
   i = 1 + randominteger(2);
   if (i == 1) {
      minqpsetalgobleic(s, 1.0E-12, 0.0, 0.0, 0);
   }
   if (i == 2) {
      minqpsetalgoquickqp(s, 1.0E-12, 0.0, 0.0, 0, randombool());
   }
}

// set random type of theQP solver
static void testminqpunit_setrandomalgosemidefinite(minqpstate *s, double *bctol, double *lctol) {
   ae_int_t i;
   *bctol = 0;
   *lctol = 0;
   i = 1 + randominteger(4);
   if (i == 1) {
      minqpsetalgobleic(s, 1.0E-12, 0.0, 0.0, 0);
      *bctol = 0.0;
      *lctol = 1.0E-8;
   }
   if (i == 2) {
      minqpsetalgoquickqp(s, 1.0E-12, 0.0, 0.0, 0, randombool());
      *bctol = 0.0;
      *lctol = 0.0;
   }
   if (i == 3) {
      minqpsetalgodenseipm(s, 1.0E-12);
      *bctol = 1.0E-3;
      *lctol = 1.0E-3;
   }
   if (i == 4) {
      minqpsetalgosparseipm(s, 1.0E-12);
      *bctol = 1.0E-3;
      *lctol = 1.0E-3;
   }
}

// set random type of the QP solver,
// must support convex problems with boundary/linear constraints
static void testminqpunit_setrandomalgoconvexlc(minqpstate *s) {
   ae_int_t i;
   i = randominteger(4);
   if (i == 0) {
      minqpsetalgodenseaul(s, 1.0E-12, 10000.0, 15);
   }
   if (i == 1) {
      minqpsetalgobleic(s, 0.0, 0.0, 1.0E-12, 0);
   }
   if (i == 2) {
      minqpsetalgodenseipm(s, 1.0E-12);
   }
   if (i == 3) {
      minqpsetalgosparseipm(s, 1.0E-12);
   }
}

// set random type of the QP solver,
// must support nonconvex problems with boundary/linear constraints
static void testminqpunit_setrandomalgononconvexlc(minqpstate *s) {
   ae_int_t i;
   i = randominteger(1);
   if (i == 0) {
      minqpsetalgobleic(s, 1.0E-12, 0.0, 0.0, 0);
   }
}

// This function tests bound constrained quadratic programming algorithm.
//
// On failure sets error flag.
static void testminqpunit_bcqptest(bool *wereerrors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   double v;
   double g;
   double gnorm;
   ae_int_t origintype;
   ae_int_t scaletype;
   bool isupper;
   bool issparse;
   double bctol;
   double lctol;
   double vl;
   double vu;
   double eps;
   ae_int_t solvertype;
   ae_frame_make(&_frame_block);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewMatrix(halfa, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewVector(ct, 0, DT_INT);
   NewVector(b, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(gtrial, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(xori, 0, DT_REAL);
   NewVector(xz, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Convex test:
// * N dimensions
// * random number (0..N) of random boundary constraints
// * positive-definite A
// * algorithm randomly choose dense or sparse A, and for
//   sparse matrix it randomly choose format.
// * random B with normal entries
// * initial point is random, feasible
// * random origin (zero or non-zero) and scale (unit or
//   non-unit) are generated
   eps = 1.0E-3;
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         origintype = hqrnduniformi(&rs, 2);
         scaletype = hqrnduniformi(&rs, 2);
         isupper = hqrnduniformr(&rs) < 0.5;
         issparse = hqrnduniformr(&rs) < 0.5;
         spdmatrixrndcond(n, 1.0E3, &fulla);
         ae_matrix_set_length(&halfa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper ? j >= i : j <= i) {
                  halfa.xyR[i][j] = fulla.xyR[i][j];
               } else {
                  halfa.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         }
         testminqpunit_densetosparse(&halfa, n, &sa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xori, n);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = -INFINITY;
            bndu.xR[i] = +INFINITY;
            x0.xR[i] = hqrndnormal(&rs);
            if (origintype == 0) {
               xori.xR[i] = 0.0;
            } else {
               xori.xR[i] = hqrndnormal(&rs);
            }
            if (scaletype == 0) {
               s.xR[i] = 1.0;
            } else {
               s.xR[i] = exp(0.5 * hqrndnormal(&rs));
            }
            j = hqrnduniformi(&rs, 5);
            if (j == 0) {
               bndl.xR[i] = 0.0;
               x0.xR[i] = fabs(x0.xR[i]);
            }
            if (j == 1) {
               bndu.xR[i] = 0.0;
               x0.xR[i] = -fabs(x0.xR[i]);
            }
            if (j == 2) {
               bndl.xR[i] = hqrndnormal(&rs);
               bndu.xR[i] = bndl.xR[i];
               x0.xR[i] = bndl.xR[i];
            }
            if (j == 3) {
               bndl.xR[i] = -0.1;
               bndu.xR[i] = 0.1;
               x0.xR[i] = 0.2 * hqrnduniformr(&rs) - 0.1;
            }
         }
      // Solve problem
         minqpcreate(n, &state);
         solvertype = testminqpunit_setrandomalgoallmodern(&state, &bctol, &lctol);
         minqpsetlinearterm(&state, &b);
         minqpsetstartingpoint(&state, &x0);
         if (issparse) {
            minqpsetquadratictermsparse(&state, &sa, isupper);
         } else {
            minqpsetquadraticterm(&state, &halfa, isupper);
         }
         if (origintype != 0) {
            minqpsetorigin(&state, &xori);
         }
         if (scaletype != 0) {
            minqpsetscale(&state, &s);
         }
         if (hqrndnormal(&rs) > 0.0) {
            minqpsetbc(&state, &bndl, &bndu);
         } else {
            for (i = 0; i < n; i++) {
               minqpsetbci(&state, i, bndl.xR[i], bndu.xR[i]);
            }
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:882");
         set_error_flag(wereerrors, x1.cnt < n, __FILE__, __LINE__, "testminqpunit.ap:883");
         set_error_flag(wereerrors, rep.lagbc.cnt < n, __FILE__, __LINE__, "testminqpunit.ap:884");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            g = b.xR[i];
            for (j = 0; j < n; j++) {
               g += fulla.xyR[i][j] * (x1.xR[j] - xori.xR[j]);
            }
            if (x1.xR[i] <= bndl.xR[i] + bctol && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] >= bndu.xR[i] - bctol && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            set_error_flag(wereerrors, x1.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminqpunit.ap:904");
            set_error_flag(wereerrors, x1.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminqpunit.ap:905");
         }
         gnorm = sqrt(gnorm);
         set_error_flag(wereerrors, gnorm > eps, __FILE__, __LINE__, "testminqpunit.ap:908");
      // Test Lagrange multipliers returned by the solver (we skip
      // BLEIC solver because it does not return Lagrange vals).
         if (solvertype != -1 && solvertype != 0) {
            ae_vector_set_length(&gtrial, n);
            for (i = 0; i < n; i++) {
               v = b.xR[i];
               for (j = 0; j < n; j++) {
                  v += fulla.xyR[i][j] * (x1.xR[j] - xori.xR[j]);
               }
               gtrial.xR[i] = v;
            }
            for (i = 0; i < n; i++) {
               gtrial.xR[i] += rep.lagbc.xR[i];
            }
            for (i = 0; i < n; i++) {
               set_error_flag(wereerrors, fabs(gtrial.xR[i]) > 1.0E-3, __FILE__, __LINE__, "testminqpunit.ap:928");
            }
         }
      }
   }
// Convex test, same box constraints for all variables:
// * N dimensions
// * box constraints set with minqpsetbcall()
// * positive-definite A
// * algorithm randomly choose dense or sparse A, and for
//   sparse matrix it randomly choose format.
// * random B with normal entries
// * initial point is random, feasible
// * random origin (zero or non-zero) and scale (unit or
//   non-unit) are generated
   eps = 1.0E-3;
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         origintype = hqrnduniformi(&rs, 2);
         scaletype = hqrnduniformi(&rs, 2);
         isupper = hqrnduniformr(&rs) < 0.5;
         issparse = hqrnduniformr(&rs) < 0.5;
         spdmatrixrndcond(n, 1.0E3, &fulla);
         ae_matrix_set_length(&halfa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper ? j >= i : j <= i) {
                  halfa.xyR[i][j] = fulla.xyR[i][j];
               } else {
                  halfa.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         }
         testminqpunit_densetosparse(&halfa, n, &sa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xori, n);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            x0.xR[i] = hqrndnormal(&rs);
            if (origintype == 0) {
               xori.xR[i] = 0.0;
            } else {
               xori.xR[i] = hqrndnormal(&rs);
            }
            if (scaletype == 0) {
               s.xR[i] = 1.0;
            } else {
               s.xR[i] = exp(0.5 * hqrndnormal(&rs));
            }
         }
         vl = -INFINITY;
         vu = +INFINITY;
         j = hqrnduniformi(&rs, 5);
         if (j == 0) {
            vl = 0.0;
         }
         if (j == 1) {
            vu = 0.0;
         }
         if (j == 2) {
            vl = hqrndnormal(&rs);
            vu = vl;
         }
         if (j == 3) {
            vl = -0.1 - pow(2.0, hqrndnormal(&rs));
            vu = 0.1 + pow(2.0, hqrndnormal(&rs));
         }
      // Solve problem
         minqpcreate(n, &state);
         testminqpunit_setrandomalgoallmodern(&state, &bctol, &lctol);
         minqpsetlinearterm(&state, &b);
         minqpsetstartingpoint(&state, &x0);
         if (issparse) {
            minqpsetquadratictermsparse(&state, &sa, isupper);
         } else {
            minqpsetquadraticterm(&state, &halfa, isupper);
         }
         if (origintype != 0) {
            minqpsetorigin(&state, &xori);
         }
         if (scaletype != 0) {
            minqpsetscale(&state, &s);
         }
         minqpsetbcall(&state, vl, vu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:1017");
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            g = b.xR[i];
            for (j = 0; j < n; j++) {
               g += fulla.xyR[i][j] * (x1.xR[j] - xori.xR[j]);
            }
            if (x1.xR[i] <= vl + bctol && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] >= vu - bctol && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            set_error_flag(wereerrors, x1.xR[i] < vl, __FILE__, __LINE__, "testminqpunit.ap:1037");
            set_error_flag(wereerrors, x1.xR[i] > vu, __FILE__, __LINE__, "testminqpunit.ap:1038");
         }
         gnorm = sqrt(gnorm);
         set_error_flag(wereerrors, gnorm > eps, __FILE__, __LINE__, "testminqpunit.ap:1041");
      }
   }
// Semidefinite test:
// * N dimensions
// * nonnegativity constraints
// * A = [ 1 1 ... 1 1 ; 1 1 ... 1 1 ; .... ; 1 1 ... 1 1 ]
// * algorithm randomly choose dense or sparse A, and for
//   sparse matrix it randomly choose format.
// * random B with normal entries
// * initial point is random, feasible
   eps = 1.0E-4;
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         isupper = hqrnduniformr(&rs) < 0.5;
         issparse = hqrnduniformr(&rs) < 0.5;
         ae_matrix_set_length(&fulla, n, n);
         ae_matrix_set_length(&halfa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               fulla.xyR[i][j] = 1.0;
               if (isupper ? j >= i : j <= i) {
                  halfa.xyR[i][j] = fulla.xyR[i][j];
               } else {
                  halfa.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         }
         testminqpunit_densetosparse(&halfa, n, &sa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = 0.0;
            bndu.xR[i] = +INFINITY;
            x0.xR[i] = (double)hqrnduniformi(&rs, 2);
         }
      // Solve problem
         minqpcreate(n, &state);
         testminqpunit_setrandomalgosemidefinite(&state, &bctol, &lctol);
         minqpsetstartingpoint(&state, &x0);
         minqpsetlinearterm(&state, &b);
         if (issparse) {
            minqpsetquadratictermsparse(&state, &sa, isupper);
         } else {
            minqpsetquadraticterm(&state, &halfa, isupper);
         }
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:1101");
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            g = b.xR[i];
            for (j = 0; j < n; j++) {
               g += fulla.xyR[i][j] * x1.xR[j];
            }
            if (x1.xR[i] <= bndl.xR[i] + bctol && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] >= bndu.xR[i] - bctol && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            set_error_flag(wereerrors, x1.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminqpunit.ap:1121");
            set_error_flag(wereerrors, x1.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminqpunit.ap:1122");
         }
         gnorm = sqrt(gnorm);
         set_error_flag(wereerrors, gnorm > eps, __FILE__, __LINE__, "testminqpunit.ap:1125");
      }
   }
// Non-convex test:
// * N dimensions, N >= 2
// * box constraints, x[i] in [-1,+1]
// * A = A0-0.5*I, where A0 is SPD with unit norm and smallest
//   singular value equal to 1.0E-3, I is identity matrix
// * random B with normal entries
// * initial point is random, feasible
//
// We perform two tests:
// * unconstrained problem must be recognized as unbounded
// * constrained problem can be successfully solved
//
// NOTE: it is important to have N >= 2, because formula for A
//       can be applied only to matrix with at least two
//       singular values
   eps = 1.0E-4;
   for (n = 2; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         spdmatrixrndcond(n, 1.0E3, &fulla);
         for (i = 0; i < n; i++) {
            fulla.xyR[i][i] -= 0.5;
         }
         isupper = hqrnduniformr(&rs) < 0.5;
         ae_matrix_set_length(&halfa, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (isupper ? j >= i : j <= i) {
                  halfa.xyR[i][j] = fulla.xyR[i][j];
               } else {
                  halfa.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         }
         testminqpunit_densetosparse(&halfa, n, &sa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = -1.0;
            bndu.xR[i] = 1.0;
            x0.xR[i] = 2 * hqrnduniformr(&rs) - 1;
         }
      // Solve problem:
      // * without constraints we expect failure
      // * with constraints algorithm must succeed
         minqpcreate(n, &state);
         testminqpunit_setrandomalgononconvex(&state);
         minqpsetstartingpoint(&state, &x0);
         minqpsetlinearterm(&state, &b);
         if (hqrndnormal(&rs) > 0.0) {
            minqpsetquadraticterm(&state, &halfa, isupper);
         } else {
            minqpsetquadratictermsparse(&state, &sa, isupper);
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(wereerrors, rep.terminationtype != -4, __FILE__, __LINE__, "testminqpunit.ap:1192");
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:1196");
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         gnorm = 0.0;
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(fulla.xyR[i], 1, x1.xR, 1, n);
            g = v + b.xR[i];
            if (x1.xR[i] == bndl.xR[i] && g > 0.0) {
               g = 0.0;
            }
            if (x1.xR[i] == bndu.xR[i] && g < 0.0) {
               g = 0.0;
            }
            gnorm += sqr(g);
            set_error_flag(wereerrors, x1.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminqpunit.ap:1215");
            set_error_flag(wereerrors, x1.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminqpunit.ap:1216");
         }
         gnorm = sqrt(gnorm);
         set_error_flag(wereerrors, gnorm > eps, __FILE__, __LINE__, "testminqpunit.ap:1219");
      }
   }
// Linear (zero-quadratic) test:
// * N dimensions, N >= 1
// * box constraints, x[i] in [-1,+1]
// * A = 0
// * random B with normal entries
// * initial point is random, feasible
//
// We perform two tests:
// * unconstrained problem must be recognized as unbounded
// * constrained problem can be successfully solved
//
// NOTE: we may explicitly set zero A, or assume that by
//       default it is zero. During test we will try both
//       ways.
   eps = 1.0E-4;
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 10; pass++) {
      // Generate problem
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            do {
               b.xR[i] = hqrndnormal(&rs);
            } while (b.xR[i] == 0.0);
            bndl.xR[i] = -1.0;
            bndu.xR[i] = 1.0;
            x0.xR[i] = 2 * hqrnduniformr(&rs) - 1;
         }
      // Solve problem:
      // * without constraints we expect failure
      // * with constraints algorithm must succeed
         minqpcreate(n, &state);
         testminqpunit_setrandomalgosemidefinite(&state, &bctol, &lctol);
         minqpsetlinearterm(&state, &b);
         minqpsetstartingpoint(&state, &x0);
         if (hqrndnormal(&rs) > 0.0) {
            ae_matrix_set_length(&a, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
            }
            minqpsetquadraticterm(&state, &a, true);
         }
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(wereerrors, rep.terminationtype != -4 && rep.terminationtype != -2, __FILE__, __LINE__, "testminqpunit.ap:1278");
         minqpsetbc(&state, &bndl, &bndu);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:1283");
         if (rep.terminationtype <= 0) {
            ae_frame_leave();
            return;
         }
      // Test - calculate constrained gradient at solution,
      // check its norm.
         for (i = 0; i < n; i++) {
            set_error_flag(wereerrors, b.xR[i] > 0.0 && x1.xR[i] > bndl.xR[i] + bctol, __FILE__, __LINE__, "testminqpunit.ap:1293");
            set_error_flag(wereerrors, b.xR[i] < 0.0 && x1.xR[i] < bndu.xR[i] - bctol, __FILE__, __LINE__, "testminqpunit.ap:1294");
         }
      }
   }
   ae_frame_leave();
}

// This function tests equality constrained quadratic programming algorithm.
//
// Returns True on errors.
static bool testminqpunit_ecqptest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t k;
   double eps;
   double theta;
   double f0;
   double f1;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   ae_int_t rk;
   double v;
   ae_int_t aulits;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(b2, 0, DT_REAL);
   NewVector(xstart, 0, DT_REAL);
   NewVector(xstart2, 0, DT_REAL);
   NewVector(xend, 0, DT_REAL);
   NewVector(xend2, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(xd, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(xorigin, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(minqpstate, state);
   NewObj(minqpstate, state2);
   NewObj(minqpreport, rep);
   waserrors = false;
// First test:
// * N*N identity A
// * K<N equality constraints Q*x = Q*x0, where Q is random
//   orthogonal K*N matrix, x0 is some random vector
// * x1 is some random vector such that Q*x1=0. It is always possible
//   to find such x1, because K<N
// * optimization problem has form 0.5*x'*A*x-(x1*A)*x
// * exact solution must be equal to x0
   eps = 1.0E-4;
   for (n = 2; n <= 6; n++) {
      for (k = 1; k < n; k++) {
      // Generate problem: A, b, CMatrix, x0, XStart
         rmatrixrndorthogonal(n, &q);
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
            a.xyR[i][i] = 1.0;
         }
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = randommid();
            x1.xR[i] = x0.xR[i];
            xstart.xR[i] = randommid();
         }
         for (i = 0; i < k; i++) {
            ae_v_move(c.xyR[i], 1, q.xyR[i], 1, n);
            v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
            v = randommid();
            ae_v_addd(x1.xR, 1, q.xyR[i], 1, n, v);
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
            b.xR[i] = -v;
         }
      // Create optimizer, solve
         minqpcreate(n, &state);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state, &b);
         minqpsetquadraticterm(&state, &a, randombool());
         minqpsetstartingpoint(&state, &xstart);
         minqpsetlc(&state, &c, &ct, k);
         minqpoptimize(&state);
         minqpresults(&state, &xend, &rep);
      // Compare with analytic solution
         if (rep.terminationtype <= 0) {
            set_error_flag(&waserrors, true, __FILE__, __LINE__, "testminqpunit.ap:1400");
            continue;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(&waserrors, fabs(xend.xR[i] - x0.xR[i]) > eps, __FILE__, __LINE__, "testminqpunit.ap:1404");
         }
      }
   }
// Second test:
// * N*N SPD A
// * K<N equality constraints Q*x = Q*x0, where Q is random
//   orthogonal K*N matrix, x0 is some random vector
// * optimization problem has form 0.5*x'*A*x-(x1*A)*x,
//   where x1 is some random vector
// * we check feasibility properties of the solution
// * we do not know analytic form of the exact solution,
//   but we know that projection of gradient into equality constrained
//   subspace must be zero at the solution
   eps = 1.0E-4;
   for (n = 2; n <= 6; n++) {
      for (k = 1; k < n; k++) {
      // Generate problem: A, b, CMatrix, x0, XStart
         rmatrixrndorthogonal(n, &q);
         spdmatrixrndcond(n, pow(10.0, 3 * randomreal()), &a);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = randommid();
            x1.xR[i] = randommid();
            xstart.xR[i] = randommid();
         }
         for (i = 0; i < k; i++) {
            ae_v_move(c.xyR[i], 1, q.xyR[i], 1, n);
            v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
            b.xR[i] = -v;
         }
      // Create optimizer, solve
         minqpcreate(n, &state);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state, &b);
         minqpsetquadraticterm(&state, &a, randombool());
         minqpsetstartingpoint(&state, &xstart);
         minqpsetlc(&state, &c, &ct, k);
         minqpoptimize(&state);
         minqpresults(&state, &xend, &rep);
      // Calculate gradient, check projection
         if (rep.terminationtype <= 0) {
            set_error_flag(&waserrors, true, __FILE__, __LINE__, "testminqpunit.ap:1472");
            continue;
         }
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(xend.xR, 1, c.xyR[i], 1, n);
            set_error_flag(&waserrors, fabs(v - c.xyR[i][n]) > eps, __FILE__, __LINE__, "testminqpunit.ap:1478");
         }
         ae_vector_set_length(&g, n);
         ae_v_move(g.xR, 1, b.xR, 1, n);
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, xend.xR, 1, n);
            g.xR[i] += v;
         }
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(g.xR, 1, c.xyR[i], 1, n);
            ae_v_subd(g.xR, 1, c.xyR[i], 1, n, v);
         }
         v = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
         set_error_flag(&waserrors, sqrt(v) > eps, __FILE__, __LINE__, "testminqpunit.ap:1493");
      }
   }
// Boundary and linear equality constrained QP problem:
// * N*N SPD A with moderate condtion number (up to 100)
// * boundary constraints 0 <= x[i] <= 1
// * K<N equality constraints C*x = C*x0, where Q is random
//   K*N matrix, x0 is some random vector from the
//   feasible hypercube (0 <= x0[i] <= 1)
// * optimization problem has form 0.5*x'*A*x-(x1*A)*x,
//   where x1 is some random vector with -1 <= x1[i] <= +1.
//   (sometimes solution is in the inner area, sometimes at the boundary)
// * every component of the initial point XStart is either 0 or 1
//   (point is located at the vertices of the feasible hypercube)
//
// Solution of such problem is calculated using two methods:
// a) boundary and linearly constrained QP
// b) augmented Lagrangian boundary constrained QP: we add explicit quadratic
//    penalty to the problem; we also add Lagrangian terms and perform many
//    subsequent iterations to find good estimates of the Lagrange multipliers.
//
// Sometimes augmented Largangian converges to slightly different point
// (boundary constraints lead to extremely slow, non-smooth convergence of
// the Lagrange multipliers). In order to correctly handle such situations
// we compare function values instead of final points - and use relaxed criteria
// to test for convergence.
//
// NOTE: sometimes we need as much as 300 Augmented Lagrangian iterations for
//       method to converge.
   eps = 5.0E-2;
   theta = 1.0E+4;
   aulits = 300;
   for (n = 4; n <= 6; n++) {
      for (k = 1; k < n - 2; k++) {
      // Generate problem: A, b, BndL, BndU, CMatrix, x0, x1, XStart
         spdmatrixrndcond(n, pow(10.0, 2 * randomreal()), &a);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = randomreal();
            x1.xR[i] = randommid();
            bndl.xR[i] = 0.0;
            bndu.xR[i] = 1.0;
            xstart.xR[i] = (double)randominteger(2);
         }
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = randommid();
            }
            v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
            b.xR[i] = -v;
         }
      // Create exact optimizer, solve
         minqpcreate(n, &state);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state, &b);
         minqpsetquadraticterm(&state, &a, randombool());
         minqpsetstartingpoint(&state, &xstart);
         minqpsetbc(&state, &bndl, &bndu);
         minqpsetlc(&state, &c, &ct, k);
         minqpoptimize(&state);
         minqpresults(&state, &xend, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(&waserrors, true, __FILE__, __LINE__, "testminqpunit.ap:1580");
            continue;
         }
      // Solve problem using barrier functions (quadrative objective, boundary constraints,
      // explicit penalty term added to the main quadratic matrix. Lagrangian terms improve
      // solution quality):
      // * A2 := A+C'*C
      // * b2 := b-r'*C
      // * b2 is iteratively updated using augmented Lagrangian update
      //
      // NOTE: we may need many outer iterations to converge to the optimal values
      //       of Lagrange multipliers. Convergence is slowed down by the presense
      //       of boundary constraints, whose activation/deactivation slows down
      //       process.
         ae_matrix_set_length(&a2, n, n);
         rmatrixcopy(n, n, &a, 0, 0, &a2, 0, 0);
         rmatrixsyrk(n, k, theta, &c, 0, 0, 2, 1.0, &a2, 0, 0, true);
         for (i = 0; i < n; i++) {
            for (j = i + 1; j < n; j++) {
               a2.xyR[j][i] = a2.xyR[i][j];
            }
         }
         ae_vector_set_length(&b2, n);
         ae_v_move(b2.xR, 1, b.xR, 1, n);
         for (i = 0; i < k; i++) {
            v = c.xyR[i][n] * theta;
            ae_v_subd(b2.xR, 1, c.xyR[i], 1, n, v);
         }
         minqpcreate(n, &state2);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetquadraticterm(&state2, &a2, randombool());
         minqpsetstartingpoint(&state2, &xstart);
         minqpsetbc(&state2, &bndl, &bndu);
         for (i = 1; i <= aulits; i++) {
         // Solve, update B2 according to augmented Lagrangian algorithm
            minqpsetlinearterm(&state2, &b2);
            minqpoptimize(&state2);
            minqpresults(&state2, &xend2, &rep);
            if (rep.terminationtype <= 0) {
               set_error_flag(&waserrors, true, __FILE__, __LINE__, "testminqpunit.ap:1627");
               continue;
            }
            for (j = 0; j < k; j++) {
               v = ae_v_dotproduct(c.xyR[j], 1, xend2.xR, 1, n);
               v = theta * (v - c.xyR[j][n]);
               ae_v_addd(b2.xR, 1, c.xyR[j], 1, n, v);
            }
         }
      // Calculate function value and XEnd and XEnd2
         f0 = 0.0;
         f1 = 0.0;
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               f0 += 0.5 * xend.xR[i] * a.xyR[i][j] * xend.xR[j];
               f1 += 0.5 * xend2.xR[i] * a.xyR[i][j] * xend2.xR[j];
            }
            f0 += xend.xR[i] * b.xR[i];
            f1 += xend2.xR[i] * b.xR[i];
         }
      // Check feasibility properties and compare
         set_error_flag(&waserrors, fabs(f0 - f1) > eps, __FILE__, __LINE__, "testminqpunit.ap:1657");
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(xend.xR, 1, c.xyR[i], 1, n);
            set_error_flag(&waserrors, fabs(v - c.xyR[i][n]) > 1.0E6 * machineepsilon, __FILE__, __LINE__, "testminqpunit.ap:1661");
         }
         for (i = 0; i < n; i++) {
            set_error_flag(&waserrors, xend.xR[i] < 0.0, __FILE__, __LINE__, "testminqpunit.ap:1665");
            set_error_flag(&waserrors, xend.xR[i] > 1.0, __FILE__, __LINE__, "testminqpunit.ap:1666");
         }
      }
   }
// Boundary and linear equality constrained QP problem,
// test for correct handling of non-zero XOrigin:
// * N*N SPD A with moderate condtion number (up to 100)
// * boundary constraints 0 <= x[i] <= 1
// * K<N equality constraints Q*x = Q*x0, where Q is random
//   orthogonal K*N matrix, x0 is some random vector from the
//   inner area of the feasible hypercube (0.1 <= x0[i] <= 0.9)
// * optimization problem has form 0.5*(x-xorigin)'*A*(x-xorigin)+b*(x-xorigin),
//   where b is some random vector with -1 <= b[i] <= +1.
//   (sometimes solution is in the inner area, sometimes at the boundary)
// * every component of the initial point XStart is random from [-1,1]
//
// Solution of such problem is calculated using two methods:
// a) QP with SetOrigin() call
// b) QP with XOrigin explicitly added to the quadratic function,
//
// Both methods should give same results; any significant difference is
// evidence of some error in the QP implementation.
   eps = 1.0E-4;
   for (n = 2; n <= 6; n++) {
      for (k = 1; k < n; k++) {
      // Generate problem: A, b, BndL, BndU, CMatrix, x0, x1, XStart.
      // Additionally, we compute modified b: b2 = b-xorigin'*A
         rmatrixrndorthogonal(n, &q);
         spdmatrixrndcond(n, pow(10.0, 2 * randomreal()), &a);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&b2, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xorigin, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 0.1 + 0.8 * randomreal();
            b.xR[i] = randommid();
            bndl.xR[i] = 0.0;
            bndu.xR[i] = 1.0;
            xstart.xR[i] = (double)randominteger(2);
            xorigin.xR[i] = randommid();
         }
         for (i = 0; i < k; i++) {
            ae_v_move(c.xyR[i], 1, q.xyR[i], 1, n);
            v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, xorigin.xR, 1, n);
            b2.xR[i] = b.xR[i] - v;
         }
      // Solve with SetOrigin() call
         minqpcreate(n, &state);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state, &b);
         minqpsetquadraticterm(&state, &a, randombool());
         minqpsetstartingpoint(&state, &xstart);
         minqpsetorigin(&state, &xorigin);
         minqpsetbc(&state, &bndl, &bndu);
         minqpsetlc(&state, &c, &ct, k);
         minqpoptimize(&state);
         minqpresults(&state, &xend, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(&waserrors, true, __FILE__, __LINE__, "testminqpunit.ap:1750");
            continue;
         }
      // Solve problem using explicit origin
         minqpcreate(n, &state2);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state2, &b2);
         minqpsetquadraticterm(&state2, &a, randombool());
         minqpsetstartingpoint(&state2, &xstart);
         minqpsetbc(&state2, &bndl, &bndu);
         minqpsetlc(&state2, &c, &ct, k);
         minqpoptimize(&state2);
         minqpresults(&state2, &xend2, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(&waserrors, true, __FILE__, __LINE__, "testminqpunit.ap:1768");
            continue;
         }
      // Check feasibility properties and compare solutions
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(xend.xR, 1, c.xyR[i], 1, n);
            set_error_flag(&waserrors, fabs(v - c.xyR[i][n]) > eps, __FILE__, __LINE__, "testminqpunit.ap:1778");
         }
         for (i = 0; i < n; i++) {
            set_error_flag(&waserrors, fabs(xend.xR[i] - xend2.xR[i]) > eps, __FILE__, __LINE__, "testminqpunit.ap:1782");
            set_error_flag(&waserrors, xend.xR[i] < 0.0, __FILE__, __LINE__, "testminqpunit.ap:1783");
            set_error_flag(&waserrors, xend.xR[i] > 1.0, __FILE__, __LINE__, "testminqpunit.ap:1784");
         }
      }
   }
// Boundary and linear equality constrained QP problem with excessive
// equality constraints:
// * N*N SPD A with moderate condtion number (up to 100)
// * boundary constraints 0 <= x[i] <= 1
// * K=2*N equality constraints Q*x = Q*x0, where Q is random matrix,
//   x0 is some random vector from the feasible hypercube (0.1 <= x0[i] <= 0.9)
// * optimization problem has form 0.5*x'*A*x-b*x,
//   where b is some random vector
// * because constraints are excessive, the main problem is to find
//   feasible point; the only existing feasible point is solution,
//   so we have to check only feasibility
   eps = 1.0E-4;
   for (n = 1; n <= 6; n++) {
   // Generate problem: A, b, BndL, BndU, CMatrix, x0, x1, XStart
      k = 2 * n;
      spdmatrixrndcond(n, pow(10.0, 3 * randomreal()), &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&x1, n);
      ae_vector_set_length(&xstart, n);
      ae_matrix_set_length(&c, k, n + 1);
      ae_vector_set_length(&ct, k);
      for (i = 0; i < n; i++) {
         x0.xR[i] = 0.1 + 0.8 * randomreal();
         x1.xR[i] = randommid();
         bndl.xR[i] = 0.0;
         bndu.xR[i] = 1.0;
         xstart.xR[i] = (double)randominteger(2);
      }
      for (i = 0; i < k; i++) {
         for (j = 0; j < n; j++) {
            c.xyR[i][j] = randommid();
         }
         v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
         c.xyR[i][n] = v;
         ct.xZ[i] = 0;
      }
      for (i = 0; i < n; i++) {
         b.xR[i] = randommid();
      }
   // Create optimizer, solve
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, randombool());
      minqpsetstartingpoint(&state, &xstart);
      minqpsetbc(&state, &bndl, &bndu);
      minqpsetlc(&state, &c, &ct, k);
      minqpoptimize(&state);
      ae_vector_set_length(&xend, 0);
      minqpresults(&state, &xend, &rep);
   // Check feasibility properties of the solution
   //
   // NOTE: we do not check termination type because some solvers (IPM) may return feasible X even with negative code
      if (xend.cnt != n) {
         set_error_flag(&waserrors, true, __FILE__, __LINE__, "testminqpunit.ap:1858");
         continue;
      }
      for (i = 0; i < k; i++) {
         v = ae_v_dotproduct(xend.xR, 1, c.xyR[i], 1, n);
         set_error_flag(&waserrors, fabs(v - c.xyR[i][n]) > eps, __FILE__, __LINE__, "testminqpunit.ap:1864");
      }
   }
// Boundary and linear equality constrained QP problem,
// test checks that different starting points yield same final point:
// * random N from [1..6], random K from [1..2*N]
// * N*N SPD A with moderate condtion number (up to 100)
// * boundary constraints 0 <= x[i] <= 1
// * K<N random linear equality constraints C*x = C*x0,
//   where x0 is some random vector from the inner area of the
//   feasible hypercube (0.1 <= x0[i] <= 0.9)
// * optimization problem has form 0.5*x'*A*x+b*x,
//   where b is some random vector with -5 <= b[i] <= +5
// * every component of the initial point XStart is random from [-2,+2]
// * we perform two starts from random different XStart and compare values
//   of the target function (although final points may be slightly different,
//   function values should match each other)
//
// Both points should give same results; any significant difference is
// evidence of some error in the QP implementation.
   eps = 1.0E-4;
   for (pass = 1; pass <= 50; pass++) {
   // Generate problem: N, K, A, b, BndL, BndU, CMatrix, x0, x1, XStart.
      n = randominteger(5) + 2;
      k = randominteger(n - 1) + 1;
      spdmatrixrndcond(n, pow(10.0, 2 * randomreal()), &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&b2, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&xstart, n);
      ae_vector_set_length(&xstart2, n);
      ae_matrix_set_length(&c, k, n + 1);
      ae_vector_set_length(&ct, k);
      for (i = 0; i < n; i++) {
         x0.xR[i] = 0.1 + 0.8 * randomreal();
         b.xR[i] = randommid();
         bndl.xR[i] = 0.0;
         bndu.xR[i] = 1.0;
         xstart.xR[i] = 2.0 * randommid();
         xstart2.xR[i] = 2.0 * randommid();
      }
      for (i = 0; i < k; i++) {
         for (j = 0; j < n; j++) {
            c.xyR[i][j] = randommid();
         }
         v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
         c.xyR[i][n] = v;
         ct.xZ[i] = 0;
      }
   // Solve with XStart
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, randombool());
      minqpsetstartingpoint(&state, &xstart);
      minqpsetbc(&state, &bndl, &bndu);
      minqpsetlc(&state, &c, &ct, k);
      minqpoptimize(&state);
      minqpresults(&state, &xend, &rep);
      if (rep.terminationtype <= 0) {
         set_error_flag(&waserrors, true, __FILE__, __LINE__, "testminqpunit.ap:1938");
         continue;
      }
   // Solve with XStart2
      minqpsetstartingpoint(&state, &xstart2);
      minqpoptimize(&state);
      minqpresults(&state, &xend2, &rep);
      if (rep.terminationtype <= 0) {
         set_error_flag(&waserrors, true, __FILE__, __LINE__, "testminqpunit.ap:1950");
         continue;
      }
   // Calculate function value and XEnd and XEnd2, compare solutions
      f0 = 0.0;
      f1 = 0.0;
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            f0 += 0.5 * xend.xR[i] * a.xyR[i][j] * xend.xR[j];
            f1 += 0.5 * xend2.xR[i] * a.xyR[i][j] * xend2.xR[j];
         }
         f0 += xend.xR[i] * b.xR[i];
         f1 += xend2.xR[i] * b.xR[i];
      }
      set_error_flag(&waserrors, fabs(f0 - f1) > eps, __FILE__, __LINE__, "testminqpunit.ap:1969");
   }
// Test ability to correctly handle situation where algorithm
// either:
// (1) starts from point with gradient whose projection to
//     active set is almost zero (but not exactly zero)
// (2) performs step to such point
//
// In order to do this we solve problem
// * min 0.5*x'*x - (x0+c)'*x
// * subject to c'*x = c'*x0, with c and x0 random unit vectors
// * with initial point xs = x0+r*xd, where r is scalar,
//   xd is vector which is orthogonal to c.
// * we try different r=power(2,-rk) for rk=0...70. The idea
//   is that as we approach closer and closer to x0, which is
//   a solution of the constrained problem, constrained gradient
//   of the function rapidly vanishes.
   eps = 1.0E-6;
   for (rk = 0; rk <= 70; rk++) {
      n = 10;
   // Generate x0, c, xd, xs, generate unit A
      randomunit(n, &x0);
      randomunit(n, &xd);
      randomunit(n, &tmp);
      ae_matrix_set_length(&c, 1, n + 1);
      ae_vector_set_length(&ct, 1);
      ae_vector_set_length(&xs, n);
      ae_vector_set_length(&b, n);
      c.xyR[0][n] = 0.0;
      ct.xZ[0] = 0;
      v = 0.0;
      for (i = 0; i < n; i++) {
         c.xyR[0][i] = tmp.xR[i];
         c.xyR[0][n] += tmp.xR[i] * x0.xR[i];
         b.xR[i] = -(x0.xR[i] + tmp.xR[i]);
         v += tmp.xR[i] * xd.xR[i];
      }
      for (i = 0; i < n; i++) {
         xd.xR[i] -= v * tmp.xR[i];
         xs.xR[i] = x0.xR[i] + xd.xR[i] * pow(2.0, (double)-rk);
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = 0.0;
         }
         a.xyR[i][i] = 1.0;
      }
   // Create and solve optimization problem
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, true);
      minqpsetstartingpoint(&state, &xs);
      minqpsetlc(&state, &c, &ct, 1);
      minqpoptimize(&state);
      minqpresults(&state, &xend, &rep);
      if (rep.terminationtype <= 0) {
         set_error_flag(&waserrors, true, __FILE__, __LINE__, "testminqpunit.ap:2040");
         continue;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(&waserrors, fabs(xend.xR[i] - x0.xR[i]) > eps, __FILE__, __LINE__, "testminqpunit.ap:2044");
      }
      v = -c.xyR[0][n];
      for (i = 0; i < n; i++) {
         v += xend.xR[i] * c.xyR[0][i];
      }
      set_error_flag(&waserrors, fabs(v) > 1.0E5 * machineepsilon, __FILE__, __LINE__, "testminqpunit.ap:2048");
   }
   result = waserrors;
   ae_frame_leave();
   return result;
}

// This function tests inequality constrained quadratic programming algorithm.
//
// On failure sets Err to True; on success leaves it unchanged.
static void testminqpunit_icqptest(bool *err) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t k;
   double eps;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   double v;
   double vv;
   double f0;
   double f1;
   double tolconstr;
   ae_int_t bscale;
   ae_int_t akind;
   ae_int_t shiftkind;
   ae_int_t ccnt;
   bool isnonconvex;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewMatrix(t2, 0, 0, DT_REAL);
   NewMatrix(t3, 0, 0, DT_REAL);
   NewMatrix(ce, 0, 0, DT_REAL);
   NewVector(xs0, 0, DT_REAL);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(xstart, 0, DT_REAL);
   NewVector(xstart2, 0, DT_REAL);
   NewVector(xend, 0, DT_REAL);
   NewVector(xend2, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(b2, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(xorigin, 0, DT_REAL);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(tmp1, 0, DT_REAL);
   NewVector(da, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewVector(nonnegative, 0, DT_BOOL);
   NewObj(minqpstate, state);
   NewObj(minqpstate, state2);
   NewObj(minqpreport, rep);
   NewObj(minqpreport, rep2);
   NewObj(hqrndstate, rs);
   NewObj(snnlssolver, nnls);
   hqrndrandomize(&rs);
// Inequality constrained problem:
// * N*N diagonal A
// * one inequality constraint q'*x >= 0, where q is random unit vector
// * optimization problem has form 0.5*x'*A*x-(x1*A)*x,
//   where x1 is some random vector
// * either:
//   a) x1 is feasible => we must stop at x1
//   b) x1 is infeasible => we must stop at the boundary q'*x=0 and
//      projection of gradient onto q*x=0 must be zero
//
// NOTE: we make several passes because some specific kind of errors is rarely
//       caught by this test, so we need several repetitions.
   eps = 1.0E-4;
   for (n = 2; n <= 6; n++) {
      for (pass = 0; pass <= 4; pass++) {
      // Generate problem: A, b, CMatrix, x0, XStart
         spdmatrixrndcond(n, pow(10.0, 3 * randomreal()), &a);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, 1, n + 1);
         ae_vector_set_length(&ct, 1);
         for (i = 0; i < n; i++) {
            x1.xR[i] = randommid();
            xstart.xR[i] = randommid();
         }
         do {
            v = 0.0;
            for (i = 0; i < n; i++) {
               c.xyR[0][i] = randommid();
               v += sqr(c.xyR[0][i]);
            }
            v = sqrt(v);
         } while (v == 0.0);
         for (i = 0; i < n; i++) {
            c.xyR[0][i] /= v;
         }
         c.xyR[0][n] = 0.0;
         ct.xZ[0] = 1;
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
            b.xR[i] = -v;
         }
      // Create optimizer, solve
         minqpcreate(n, &state);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state, &b);
         minqpsetquadraticterm(&state, &a, randombool());
         minqpsetstartingpoint(&state, &xstart);
         minqpsetlc(&state, &c, &ct, 1);
         minqpoptimize(&state);
         minqpresults(&state, &xend, &rep);
      // Test
         if (rep.terminationtype <= 0) {
            set_error_flag(err, true, __FILE__, __LINE__, "testminqpunit.ap:2160");
            continue;
         }
         v = ae_v_dotproduct(x1.xR, 1, c.xyR[0], 1, n);
         if (v >= 0.0) {
         // X1 is feasible, compare target function values at XEnd and X1
            for (i = 0; i < n; i++) {
               set_error_flag(err, fabs(xend.xR[i] - x1.xR[i]) > eps, __FILE__, __LINE__, "testminqpunit.ap:2173");
            }
         } else {
         // X1 is infeasible:
         // * XEnd must be approximately feasible
         // * gradient projection onto c'*x=0 must be zero
            v = ae_v_dotproduct(xend.xR, 1, c.xyR[0], 1, n);
            set_error_flag(err, v < -eps, __FILE__, __LINE__, "testminqpunit.ap:2183");
            ae_vector_set_length(&g, n);
            ae_v_move(g.xR, 1, b.xR, 1, n);
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xend.xR, 1, n);
               g.xR[i] += v;
            }
            v = ae_v_dotproduct(g.xR, 1, c.xyR[0], 1, n);
            ae_v_subd(g.xR, 1, c.xyR[0], 1, n, v);
            v = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
            set_error_flag(err, sqrt(v) > eps, __FILE__, __LINE__, "testminqpunit.ap:2194");
         }
      }
   }
// Boundary and linear equality/inequality constrained QP problem,
// test for correct handling of non-zero XOrigin:
// * N*N SPD A with moderate condtion number (up to 100)
// * boundary constraints 0 <= x[i] <= 1
// * K<N linear equality/inequality constraints Q*x = Q*x0, where
//   Q is random orthogonal K*N matrix, x0 is some random vector from the
//   inner area of the feasible hypercube (0.1 <= x0[i] <= 0.9)
// * optimization problem has form 0.5*(x-xorigin)'*A*(x-xorigin)+b*(x-xorigin),
//   where b is some random vector with -1 <= b[i] <= +1.
//   (sometimes solution is in the inner area, sometimes at the boundary)
// * every component of the initial point XStart is random from [-1,1]
//
// Solution of such problem is calculated using two methods:
// a) QP with SetOrigin() call
// b) QP with XOrigin explicitly added to the quadratic function,
//
// Both methods should give same results; any significant difference is
// evidence of some error in the QP implementation.
   eps = 1.0E-4;
   for (n = 2; n <= 6; n++) {
      for (k = 1; k < n; k++) {
      // Generate problem: A, b, BndL, BndU, CMatrix, x0, x1, XStart.
      // Additionally, we compute modified b: b2 = b-xorigin'*A
         rmatrixrndorthogonal(n, &q);
         spdmatrixrndcond(n, pow(10.0, 2 * randomreal()), &a);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&b2, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xorigin, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 0.1 + 0.8 * randomreal();
            b.xR[i] = randommid();
            bndl.xR[i] = 0.0;
            bndu.xR[i] = 1.0;
            xstart.xR[i] = (double)randominteger(2);
            xorigin.xR[i] = randommid();
         }
         for (i = 0; i < k; i++) {
            ae_v_move(c.xyR[i], 1, q.xyR[i], 1, n);
            v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = randominteger(3) - 1;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, xorigin.xR, 1, n);
            b2.xR[i] = b.xR[i] - v;
         }
      // Solve with SetOrigin() call
         minqpcreate(n, &state);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state, &b);
         minqpsetquadraticterm(&state, &a, randombool());
         minqpsetstartingpoint(&state, &xstart);
         minqpsetorigin(&state, &xorigin);
         minqpsetbc(&state, &bndl, &bndu);
         minqpsetlc(&state, &c, &ct, k);
         minqpoptimize(&state);
         minqpresults(&state, &xend, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(err, true, __FILE__, __LINE__, "testminqpunit.ap:2278");
            continue;
         }
      // Solve problem using explicit origin
         minqpcreate(n, &state2);
         testminqpunit_setrandomalgoconvexlc(&state);
         minqpsetlinearterm(&state2, &b2);
         minqpsetquadraticterm(&state2, &a, randombool());
         minqpsetstartingpoint(&state2, &xstart);
         minqpsetbc(&state2, &bndl, &bndu);
         minqpsetlc(&state2, &c, &ct, k);
         minqpoptimize(&state2);
         minqpresults(&state2, &xend2, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(err, true, __FILE__, __LINE__, "testminqpunit.ap:2296");
            continue;
         }
      // Calculate function value and XEnd and XEnd2
         f0 = 0.0;
         f1 = 0.0;
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               f0 += 0.5 * (xend.xR[i] - xorigin.xR[i]) * a.xyR[i][j] * (xend.xR[j] - xorigin.xR[j]);
               f1 += 0.5 * (xend2.xR[i] - xorigin.xR[i]) * a.xyR[i][j] * (xend2.xR[j] - xorigin.xR[j]);
            }
            f0 += (xend.xR[i] - xorigin.xR[i]) * b.xR[i];
            f1 += (xend2.xR[i] - xorigin.xR[i]) * b.xR[i];
         }
      // Check feasibility properties and compare solutions
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(xend.xR, 1, c.xyR[i], 1, n);
            if (ct.xZ[i] == 0) {
               set_error_flag(err, fabs(v - c.xyR[i][n]) > eps, __FILE__, __LINE__, "testminqpunit.ap:2323");
            }
            if (ct.xZ[i] > 0) {
               set_error_flag(err, v < c.xyR[i][n] - eps, __FILE__, __LINE__, "testminqpunit.ap:2325");
            }
            if (ct.xZ[i] < 0) {
               set_error_flag(err, v > c.xyR[i][n] + eps, __FILE__, __LINE__, "testminqpunit.ap:2327");
            }
         }
         for (i = 0; i < n; i++) {
            set_error_flag(err, fabs(xend.xR[i] - xend2.xR[i]) > eps, __FILE__, __LINE__, "testminqpunit.ap:2331");
            set_error_flag(err, xend.xR[i] < 0.0, __FILE__, __LINE__, "testminqpunit.ap:2332");
            set_error_flag(err, xend.xR[i] > 1.0, __FILE__, __LINE__, "testminqpunit.ap:2333");
         }
      }
   }
// Boundary constraints vs linear ones:
// * N*N SPD A
// * optimization problem has form 0.5*x'*A*x-(x1*A)*x,
//   where x1 is some random vector from [-1,+1]
// * K=2*N constraints of the form ai <= x[i] or x[i] <= b[i],
//   with ai in [-1.0,-0.1], bi in [+0.1,+1.0]
// * initial point xstart is from [-1,+2]
// * we solve two related QP problems:
//   a) one with constraints posed as boundary ones
//   b) another one with same constraints posed as general linear ones
// both problems must have same solution.
// Here we test that boundary constrained and linear inequality constrained
// solvers give same results.
   eps = 1.0E-3;
   for (n = 1; n <= 6; n++) {
   // Generate problem: A, b, x0, XStart, C, CT
      spdmatrixrndcond(n, pow(10.0, 3 * randomreal()), &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x1, n);
      ae_vector_set_length(&xstart, n);
      ae_matrix_set_length(&c, 2 * n, n + 1);
      ae_vector_set_length(&ct, 2 * n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      for (i = 0; i < n; i++) {
         x1.xR[i] = randommid();
         xstart.xR[i] = 3.0 * randomreal() - 1.0;
         bndl.xR[i] = -(0.1 + 0.9 * randomreal());
         bndu.xR[i] = 0.1 + 0.9 * randomreal();
         for (j = 0; j < n; j++) {
            c.xyR[2 * i + 0][j] = 0.0;
            c.xyR[2 * i + 1][j] = 0.0;
         }
         c.xyR[2 * i + 0][i] = 1.0;
         c.xyR[2 * i + 0][n] = bndl.xR[i];
         ct.xZ[2 * i + 0] = 1;
         c.xyR[2 * i + 1][i] = 1.0;
         c.xyR[2 * i + 1][n] = bndu.xR[i];
         ct.xZ[2 * i + 1] = -1;
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
         b.xR[i] = -v;
      }
   // Solve linear inequality constrained problem
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, randombool());
      minqpsetstartingpoint(&state, &xstart);
      minqpsetlc(&state, &c, &ct, 2 * n);
      minqpoptimize(&state);
      minqpresults(&state, &xend, &rep);
   // Solve boundary constrained problem
      minqpcreate(n, &state2);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state2, &b);
      minqpsetquadraticterm(&state2, &a, randombool());
      minqpsetstartingpoint(&state2, &xstart);
      minqpsetbc(&state2, &bndl, &bndu);
      minqpoptimize(&state2);
      minqpresults(&state2, &xend2, &rep2);
   // Calculate gradient, check projection
      if (rep.terminationtype <= 0 || rep2.terminationtype <= 0) {
         set_error_flag(err, true, __FILE__, __LINE__, "testminqpunit.ap:2421");
         continue;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(err, xend.xR[i] < bndl.xR[i] - eps, __FILE__, __LINE__, "testminqpunit.ap:2426");
         set_error_flag(err, xend.xR[i] > bndu.xR[i] + eps, __FILE__, __LINE__, "testminqpunit.ap:2427");
         set_error_flag(err, fabs(xend.xR[i] - xend2.xR[i]) > eps, __FILE__, __LINE__, "testminqpunit.ap:2428");
      }
   }
// Boundary constraints posed as general linear ones:
// * no bound constraints
// * 2*N linear constraints 0 <= x[i] <= 1
// * preconditioner is chosen at random (we just want to be
//   sure that preconditioning won't prevent us from converging
//   to the feasible point):
//   * unit preconditioner
//   * random diagonal-based preconditioner
//   * random scale-based preconditioner
// * F(x) = |x-x0|^P, where P={2,4} and x0 is randomly selected from [-1,+2]^N
// * with such simple constraints and function it is easy to find
//   analytic form of solution: S[i] = bound(x0[i], 0, 1).
// * however, we can't guarantee that solution is strictly feasible
//   with respect to nonlinearity constraint, so we check
//   for approximate feasibility.
   for (n = 1; n <= 5; n++) {
   // Generate X, BL, BU.
      ae_matrix_set_length(&a, n, n);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&xstart, n);
      ae_vector_set_length(&x0, n);
      ae_matrix_set_length(&c, 2 * n, n + 1);
      ae_vector_set_length(&ct, 2 * n);
      for (i = 0; i < n; i++) {
         xstart.xR[i] = randomreal();
         x0.xR[i] = 3.0 * randomreal() - 1.0;
         b.xR[i] = -x0.xR[i];
         for (j = 0; j <= n; j++) {
            c.xyR[2 * i + 0][j] = 0.0;
            c.xyR[2 * i + 1][j] = 0.0;
         }
         c.xyR[2 * i + 0][i] = 1.0;
         c.xyR[2 * i + 0][n] = 0.0;
         ct.xZ[2 * i + 0] = 1;
         c.xyR[2 * i + 1][i] = 1.0;
         c.xyR[2 * i + 1][n] = 1.0;
         ct.xZ[2 * i + 1] = -1;
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            if (i == j) {
               a.xyR[i][j] = 1.0;
            } else {
               a.xyR[i][j] = 0.0;
            }
         }
      }
   // Create and optimize
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlc(&state, &c, &ct, 2 * n);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, randombool());
      minqpsetstartingpoint(&state, &xstart);
      minqpoptimize(&state);
      minqpresults(&state, &xend, &rep);
      if (rep.terminationtype <= 0) {
         set_error_flag(err, true, __FILE__, __LINE__, "testminqpunit.ap:2497");
         continue;
      }
   // * compare solution with analytic one
   // * check feasibility
      for (i = 0; i < n; i++) {
         set_error_flag(err, fabs(xend.xR[i] - rboundval(x0.xR[i], 0.0, 1.0)) > 0.05, __FILE__, __LINE__, "testminqpunit.ap:2507");
         set_error_flag(err, xend.xR[i] < 0.0 - 1.0E-6, __FILE__, __LINE__, "testminqpunit.ap:2508");
         set_error_flag(err, xend.xR[i] > 1.0 + 1.0E-6, __FILE__, __LINE__, "testminqpunit.ap:2509");
      }
   }
// Boundary and linear equality/inequality constrained QP problem with
// excessive constraints:
// * N*N SPD A with moderate condtion number (up to 100)
// * boundary constraints 0 <= x[i] <= 1
// * K=2*N equality/inequality constraints Q*x = Q*x0, where Q is random matrix,
//   x0 is some random vector from the feasible hypercube (0.1 <= x0[i] <= 0.9)
// * optimization problem has form 0.5*x'*A*x-b*x,
//   where b is some random vector
// * because constraints are excessive, the main problem is to find
//   feasible point; usually, the only existing feasible point is solution,
//   so we have to check only feasibility
   eps = 1.0E-4;
   for (n = 1; n <= 6; n++) {
   // Generate problem: A, b, BndL, BndU, CMatrix, x0, x1, XStart
      k = 2 * n;
      spdmatrixrndcond(n, pow(10.0, 3 * randomreal()), &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&x1, n);
      ae_vector_set_length(&xstart, n);
      ae_matrix_set_length(&c, k, n + 1);
      ae_vector_set_length(&ct, k);
      for (i = 0; i < n; i++) {
         x0.xR[i] = 0.1 + 0.8 * randomreal();
         x1.xR[i] = randommid();
         bndl.xR[i] = 0.0;
         bndu.xR[i] = 1.0;
         xstart.xR[i] = (double)randominteger(2);
      }
      for (i = 0; i < k; i++) {
         for (j = 0; j < n; j++) {
            c.xyR[i][j] = randommid();
         }
         v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
         ct.xZ[i] = randominteger(3) - 1;
         if (ct.xZ[i] == 0) {
            c.xyR[i][n] = v;
         }
         if (ct.xZ[i] > 0) {
            c.xyR[i][n] = v - 1.0E-3;
         }
         if (ct.xZ[i] < 0) {
            c.xyR[i][n] = v + 1.0E-3;
         }
      }
      for (i = 0; i < n; i++) {
         b.xR[i] = randommid();
      }
   // Create optimizer, solve
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, randombool());
      minqpsetstartingpoint(&state, &xstart);
      minqpsetbc(&state, &bndl, &bndu);
      minqpsetlc(&state, &c, &ct, k);
      minqpoptimize(&state);
      ae_vector_set_length(&xend, 0);
      minqpresults(&state, &xend, &rep);
   // Check feasibility properties of the solution
   //
   // NOTE: we do not check termination type because some solvers (IPM) may return feasible X even with negative code
      if (xend.cnt != n) {
         set_error_flag(err, true, __FILE__, __LINE__, "testminqpunit.ap:2588");
         continue;
      }
      for (i = 0; i < k; i++) {
         v = ae_v_dotproduct(xend.xR, 1, c.xyR[i], 1, n);
         if (ct.xZ[i] == 0) {
            set_error_flag(err, fabs(v - c.xyR[i][n]) > eps, __FILE__, __LINE__, "testminqpunit.ap:2595");
         }
         if (ct.xZ[i] > 0) {
            set_error_flag(err, v < c.xyR[i][n] - eps, __FILE__, __LINE__, "testminqpunit.ap:2597");
         }
         if (ct.xZ[i] < 0) {
            set_error_flag(err, v > c.xyR[i][n] + eps, __FILE__, __LINE__, "testminqpunit.ap:2599");
         }
      }
   }
// General inequality constrained problem:
// * N*N SPD diagonal A with moderate condtion number
// * no boundary constraints
// * K=N inequality constraints C*x >= C*x0, where C is N*N well conditioned
//   matrix, x0 is some random vector [-1,+1]
// * optimization problem has form 0.5*x'*A*x-b'*x,
//   where b is random vector from [-1,+1]
// * using duality, we can obtain solution of QP problem as follows:
//   a) intermediate problem min(0.5*y'*B*y + d'*y) s.t. y >= 0
//      is solved, where B = C*inv(A)*C', d = -(C*inv(A)*b + C*x0)
//   b) after we got dual solution ys, we calculate primal solution
//      xs = inv(A)*(C'*ys-b)
   eps = 1.0E-3;
   for (n = 1; n <= 6; n++) {
   // Generate problem
      ae_vector_set_length(&da, n);
      ae_matrix_set_length(&a, n, n);
      rmatrixrndcond(n, pow(10.0, 2 * randomreal()), &t2);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&xstart, n);
      ae_matrix_set_length(&c, n, n + 1);
      ae_vector_set_length(&ct, n);
      for (i = 0; i < n; i++) {
         da.xR[i] = exp(4.0 * randommid());
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = 0.0;
         }
         a.xyR[i][i] = da.xR[i];
      }
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         b.xR[i] = randommid();
         xstart.xR[i] = randommid();
      }
      for (i = 0; i < n; i++) {
         ae_v_move(c.xyR[i], 1, t2.xyR[i], 1, n);
         v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
         c.xyR[i][n] = v;
         ct.xZ[i] = 1;
      }
   // Solve primal problem, check feasibility
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, randombool());
      minqpsetstartingpoint(&state, &xstart);
      minqpsetlc(&state, &c, &ct, n);
      minqpoptimize(&state);
      minqpresults(&state, &xend, &rep);
      if (rep.terminationtype <= 0) {
         set_error_flag(err, true, __FILE__, __LINE__, "testminqpunit.ap:2665");
         continue;
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(xend.xR, 1, c.xyR[i], 1, n);
         set_error_flag(err, v < c.xyR[i][n] - eps, __FILE__, __LINE__, "testminqpunit.ap:2671");
      }
   // Generate dual problem:
   // * A2 stores new quadratic term
   // * B2 stores new linear term
   // * BndL/BndU store boundary constraints
      ae_matrix_set_length(&t3, n, n);
      ae_matrix_set_length(&a2, n, n);
      rmatrixtranspose(n, n, &c, 0, 0, &t3, 0, 0);
      for (i = 0; i < n; i++) {
         v = 1 / sqrt(da.xR[i]);
         ae_v_muld(t3.xyR[i], 1, n, v);
      }
      rmatrixsyrk(n, n, 1.0, &t3, 0, 0, 2, 0.0, &a2, 0, 0, true);
      ae_vector_set_length(&tmp0, n);
      ae_v_move(tmp0.xR, 1, b.xR, 1, n);
      for (i = 0; i < n; i++) {
         tmp0.xR[i] /= da.xR[i];
      }
      ae_vector_set_length(&b2, n);
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(c.xyR[i], 1, tmp0.xR, 1, n);
         b2.xR[i] = -(v + c.xyR[i][n]);
      }
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      for (i = 0; i < n; i++) {
         bndl.xR[i] = 0.0;
         bndu.xR[i] = +INFINITY;
      }
      minqpcreate(n, &state2);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state2, &b2);
      minqpsetquadraticterm(&state2, &a2, true);
      minqpsetbc(&state2, &bndl, &bndu);
      minqpoptimize(&state2);
      minqpresults(&state2, &xend2, &rep2);
      if (rep2.terminationtype <= 0) {
         set_error_flag(err, true, __FILE__, __LINE__, "testminqpunit.ap:2726");
         continue;
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(&c.xyR[0][i], c.stride, xend2.xR, 1, n);
         tmp0.xR[i] = v - b.xR[i];
      }
      for (i = 0; i < n; i++) {
         tmp0.xR[i] /= da.xR[i];
      }
      for (i = 0; i < n; i++) {
         set_error_flag(err, fabs(tmp0.xR[i] - xend.xR[i]) > eps * rmax2(fabs(tmp0.xR[i]), 1.0), __FILE__, __LINE__, "testminqpunit.ap:2739");
      }
   }
// Boundary and linear equality/inequality constrained QP problem,
// test checks that different starting points yield same final point:
// * random N from [1..6], random K from [1..2*N]
// * N*N SPD A with moderate condtion number (up to 100)
// * boundary constraints 0 <= x[i] <= 1
// * K<2*N linear inequality constraints Q*x <= Q*x0, where
//   Q is random K*N matrix, x0 is some random vector from the
//   inner area of the feasible hypercube (0.1 <= x0[i] <= 0.9)
// * optimization problem has form 0.5*x'*A*x+b*x,
//   where b is some random vector with -5 <= b[i] <= +5
// * every component of the initial point XStart is random from [-2,+2]
// * we perform two starts from random different XStart and compare values
//   of the target function (although final points may be slightly different,
//   function values should match each other)
   eps = 1.0E-4;
   for (pass = 1; pass <= 50; pass++) {
   // Generate problem: N, K, A, b, BndL, BndU, CMatrix, x0, x1, XStart.
      n = randominteger(5) + 2;
      k = randominteger(2 * n) + 1;
      spdmatrixrndcond(n, pow(10.0, 2 * randomreal()), &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&b2, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&xstart, n);
      ae_vector_set_length(&xstart2, n);
      ae_matrix_set_length(&c, k, n + 1);
      ae_vector_set_length(&ct, k);
      for (i = 0; i < n; i++) {
         x0.xR[i] = 0.1 + 0.8 * randomreal();
         b.xR[i] = randommid();
         bndl.xR[i] = 0.0;
         bndu.xR[i] = 1.0;
         xstart.xR[i] = 2.0 * randommid();
         xstart2.xR[i] = 2.0 * randommid();
      }
      for (i = 0; i < k; i++) {
      // Generate I-th row of C
      // Avoid excessive (more than N/2) equality constraints.
         for (j = 0; j < n; j++) {
            c.xyR[i][j] = randommid();
         }
         v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
         c.xyR[i][n] = v;
         ct.xZ[i] = randominteger(3) - 1;
         if ((double)i >= 0.5 * n && ct.xZ[i] == 0) {
            ct.xZ[i] = 1;
         }
         if (ct.xZ[i] < 0) {
            c.xyR[i][n] += 0.1;
         }
         if (ct.xZ[i] > 0) {
            c.xyR[i][n] -= 0.1;
         }
      }
   // Solve with XStart
   //
   // NOTE: we do not check termination type because some solvers (IPM) may return feasible X even with negative code
      minqpcreate(n, &state);
      testminqpunit_setrandomalgoconvexlc(&state);
      minqpsetlinearterm(&state, &b);
      minqpsetquadraticterm(&state, &a, randombool());
      minqpsetstartingpoint(&state, &xstart);
      minqpsetbc(&state, &bndl, &bndu);
      minqpsetlc(&state, &c, &ct, k);
      minqpoptimize(&state);
      ae_vector_set_length(&xend, 0);
      minqpresults(&state, &xend, &rep);
      if (xend.cnt != n || !isfinitevector(&xend, n)) {
         set_error_flag(err, true, __FILE__, __LINE__, "testminqpunit.ap:2821");
         continue;
      }
   // Solve with XStart2
      minqpsetstartingpoint(&state, &xstart2);
      minqpoptimize(&state);
      ae_vector_set_length(&xend2, 0);
      minqpresults(&state, &xend2, &rep);
      if (xend2.cnt != n || !isfinitevector(&xend2, n)) {
         set_error_flag(err, true, __FILE__, __LINE__, "testminqpunit.ap:2834");
         continue;
      }
   // Calculate function value and XEnd and XEnd2, compare solutions
      f0 = 0.0;
      f1 = 0.0;
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            f0 += 0.5 * xend.xR[i] * a.xyR[i][j] * xend.xR[j];
            f1 += 0.5 * xend2.xR[i] * a.xyR[i][j] * xend2.xR[j];
         }
         f0 += xend.xR[i] * b.xR[i];
         f1 += xend2.xR[i] * b.xR[i];
      }
      set_error_flag(err, fabs(f0 - f1) > eps, __FILE__, __LINE__, "testminqpunit.ap:2853");
   }
// Convex/nonconvex optimization problem with excessive constraints:
//
// * N=2..5
// * f = 0.5*x'*A*x+b'*x
// * b has normally distributed entries with scale 10^BScale
// * several kinds of A are tried: zero, well conditioned SPD, well conditioned indefinite, low rank SPD, low rank indefinite
// * box constraints: x[i] in [-1,+1]
// * 2^N "excessive" general linear constraints (v_k,x) <= (v_k,v_k)+v_shift,
//   where v_k is one of 2^N vertices of feasible hypercube, v_shift is
//   a shift parameter:
//   * with zero v_shift such constraints are degenerate (each vertex has
//     N box constraints and one "redundant" linear constraint)
//   * with positive v_shift linear constraint is always inactive
//   * with small (about machine epsilon) but negative v_shift,
//     constraint is close to degenerate - but not exactly
//
// We check that constrained gradient is close to zero at solution.
// Box constraint is considered active if distance to boundary is less
// than TolConstr.
//
// NOTE: TolConstr must be large enough so it won't conflict with
//       perturbation introduced by v_shift
   tolconstr = 1.0E-3;
   for (n = 2; n <= 5; n++) {
      for (akind = 0; akind <= 4; akind++) {
         for (shiftkind = -5; shiftkind <= 1; shiftkind++) {
            for (bscale = 0; bscale >= -2; bscale--) {
            // Generate A, B and initial point
               ae_matrix_set_length(&a, n, n);
               ae_vector_set_length(&b, n);
               ae_vector_set_length(&x, n);
               for (i = 0; i < n; i++) {
                  b.xR[i] = pow(10.0, (double)bscale) * hqrndnormal(&rs);
                  x.xR[i] = hqrnduniformr(&rs) - 0.5;
               }
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               isnonconvex = false;
               if (akind == 1) {
               // Dense well conditioned SPD
                  spdmatrixrndcond(n, 50.0, &a);
               }
               if (akind == 2) {
               // Dense well conditioned indefinite
                  smatrixrndcond(n, 50.0, &a);
                  isnonconvex = true;
               }
               if (akind == 3) {
               // Low rank semidefinite
                  ae_vector_set_length(&tmp, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = 0.0;
                     }
                  }
                  for (k = 1; k < imin2(4, n); k++) {
                     for (i = 0; i < n; i++) {
                        tmp.xR[i] = hqrndnormal(&rs);
                     }
                     v = pow(2.0, hqrndnormal(&rs));
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                        }
                     }
                  }
               }
               if (akind == 4) {
               // Low rank indefinite
                  ae_vector_set_length(&tmp, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = 0.0;
                     }
                  }
                  for (k = 1; k < imin2(4, n); k++) {
                     for (i = 0; i < n; i++) {
                        tmp.xR[i] = hqrndnormal(&rs);
                     }
                     v = hqrndnormal(&rs);
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                        }
                     }
                  }
                  isnonconvex = true;
               }
            // Generate constraints
               ae_vector_set_length(&bl, n);
               ae_vector_set_length(&bu, n);
               for (i = 0; i < n; i++) {
                  bl.xR[i] = -1.0;
                  bu.xR[i] = 1.0;
               }
               ccnt = iround(pow(2.0, (double)n));
               ae_matrix_set_length(&c, ccnt, n + 1);
               ae_vector_set_length(&ct, ccnt);
               for (i = 0; i < ccnt; i++) {
                  ct.xZ[i] = -1;
                  k = i;
                  c.xyR[i][n] = sign((double)shiftkind) * pow(10.0, fabs((double)shiftkind)) * machineepsilon;
                  for (j = 0; j < n; j++) {
                     c.xyR[i][j] = (double)(2 * (k % 2) - 1);
                     c.xyR[i][n] += c.xyR[i][j] * c.xyR[i][j];
                     k /= 2;
                  }
               }
            // Create and optimize
               minqpcreate(n, &state);
               minqpsetstartingpoint(&state, &x);
               if (isnonconvex) {
                  testminqpunit_setrandomalgononconvexlc(&state);
               } else {
                  testminqpunit_setrandomalgoconvexlc(&state);
               }
               minqpsetbc(&state, &bl, &bu);
               minqpsetlc(&state, &c, &ct, ccnt);
               minqpsetlinearterm(&state, &b);
               minqpsetquadraticterm(&state, &a, randombool());
               minqpoptimize(&state);
               minqpresults(&state, &xs0, &rep);
               set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:3000");
               if (*err) {
                  ae_frame_leave();
                  return;
               }
            // Evaluate gradient at solution and test
               vv = 0.0;
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, xs0.xR, 1, n);
                  v += b.xR[i];
                  if (xs0.xR[i] <= bl.xR[i] + tolconstr && v > 0.0) {
                     v = 0.0;
                  }
                  if (xs0.xR[i] >= bu.xR[i] - tolconstr && v < 0.0) {
                     v = 0.0;
                  }
                  vv += sqr(v);
               }
               vv = sqrt(vv);
               set_error_flag(err, vv > 1.0E-3, __FILE__, __LINE__, "testminqpunit.ap:3024");
            }
         }
      }
   }
// Convex/nonconvex optimization problem with combination of
// box and linear constraints:
//
// * N=2..8
// * f = 0.5*x'*A*x+b'*x
// * b has normally distributed entries with scale 10^BScale
// * several kinds of A are tried: zero, well conditioned SPD,
//   well conditioned indefinite, low rank semidefinite, low rank indefinite
// * box constraints: x[i] in [-1,+1]
// * initial point x0 = [0 0 ... 0 0]
// * CCnt=min(3,N-1) general linear constraints of form (c,x)=0.
//   random mix of equality/inequality constraints is tried.
//   x0 is guaranteed to be feasible.
//
// We check that constrained gradient is close to zero at solution.
// Inequality constraint is considered active if distance to boundary
// is less than TolConstr. We use nonnegative least squares solver
// in order to compute constrained gradient.
   tolconstr = 1.0E-3;
   for (n = 2; n <= 8; n++) {
      for (akind = 0; akind <= 4; akind++) {
         for (bscale = 0; bscale >= -2; bscale--) {
         // Generate A, B and initial point
            ae_matrix_set_length(&a, n, n);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&x, n);
            for (i = 0; i < n; i++) {
               b.xR[i] = pow(10.0, (double)bscale) * hqrndnormal(&rs);
               x.xR[i] = 0.0;
            }
            isnonconvex = false;
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
            }
            if (akind == 1) {
            // Dense well conditioned SPD
               spdmatrixrndcond(n, 50.0, &a);
            }
            if (akind == 2) {
            // Dense well conditioned indefinite
               smatrixrndcond(n, 50.0, &a);
               isnonconvex = true;
            }
            if (akind == 3) {
            // Low rank
               ae_vector_set_length(&tmp, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               for (k = 1; k < imin2(4, n); k++) {
                  for (i = 0; i < n; i++) {
                     tmp.xR[i] = hqrndnormal(&rs);
                  }
                  v = pow(2.0, hqrndnormal(&rs));
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                     }
                  }
               }
            }
            if (akind == 4) {
            // Low rank indefinite
               ae_vector_set_length(&tmp, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               for (k = 1; k < imin2(4, n); k++) {
                  for (i = 0; i < n; i++) {
                     tmp.xR[i] = hqrndnormal(&rs);
                  }
                  v = hqrndnormal(&rs);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                     }
                  }
               }
               isnonconvex = true;
            }
         // Generate constraints
            ae_vector_set_length(&bl, n);
            ae_vector_set_length(&bu, n);
            for (i = 0; i < n; i++) {
               bl.xR[i] = -1.0;
               bu.xR[i] = 1.0;
            }
            ccnt = imin2(3, n - 1);
            ae_matrix_set_length(&c, ccnt, n + 1);
            ae_vector_set_length(&ct, ccnt);
            for (i = 0; i < ccnt; i++) {
               ct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
               c.xyR[i][n] = 0.0;
               for (j = 0; j < n; j++) {
                  c.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
               }
            }
         // Create and optimize
            minqpcreate(n, &state);
            minqpsetstartingpoint(&state, &x);
            if (isnonconvex) {
               testminqpunit_setrandomalgononconvexlc(&state);
            } else {
               testminqpunit_setrandomalgoconvexlc(&state);
            }
            minqpsetbc(&state, &bl, &bu);
            minqpsetlc(&state, &c, &ct, ccnt);
            minqpsetlinearterm(&state, &b);
            minqpsetquadraticterm(&state, &a, randombool());
            minqpoptimize(&state);
            minqpresults(&state, &xs0, &rep);
            set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:3159");
            if (*err) {
               ae_frame_leave();
               return;
            }
         // 1. evaluate unconstrained gradient at solution
         //
         // 2. calculate constrained gradient (NNLS solver is used
         //    to evaluate gradient subject to active constraints).
         //    In order to do this we form CE matrix, matrix of active
         //    constraints (columns store constraint vectors). Then
         //    we try to approximate gradient vector by columns of CE,
         //    subject to non-negativity restriction placed on variables
         //    corresponding to inequality constraints.
         //
         //    Residual from such regression is a constrained gradient vector.
            ae_vector_set_length(&g, n);
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xs0.xR, 1, n);
               g.xR[i] = v + b.xR[i];
            }
            ae_matrix_set_length(&ce, n, n + ccnt);
            ae_vector_set_length(&nonnegative, n + ccnt);
            k = 0;
            for (i = 0; i < n; i++) {
               set_error_flag(err, xs0.xR[i] < bl.xR[i], __FILE__, __LINE__, "testminqpunit.ap:3187");
               set_error_flag(err, xs0.xR[i] > bu.xR[i], __FILE__, __LINE__, "testminqpunit.ap:3188");
               if (xs0.xR[i] <= bl.xR[i] + tolconstr) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = 0.0;
                  }
                  ce.xyR[i][k] = 1.0;
                  nonnegative.xB[k] = true;
                  k++;
                  continue;
               }
               if (xs0.xR[i] >= bu.xR[i] - tolconstr) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = 0.0;
                  }
                  ce.xyR[i][k] = -1.0;
                  nonnegative.xB[k] = true;
                  k++;
                  continue;
               }
            }
            for (i = 0; i < ccnt; i++) {
               v = ae_v_dotproduct(c.xyR[i], 1, xs0.xR, 1, n);
               v -= c.xyR[i][n];
               set_error_flag(err, ct.xZ[i] == 0 && fabs(v) > tolconstr, __FILE__, __LINE__, "testminqpunit.ap:3212");
               set_error_flag(err, ct.xZ[i] > 0 && v < -tolconstr, __FILE__, __LINE__, "testminqpunit.ap:3213");
               set_error_flag(err, ct.xZ[i] < 0 && v > tolconstr, __FILE__, __LINE__, "testminqpunit.ap:3214");
               if (ct.xZ[i] == 0) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = c.xyR[i][j];
                  }
                  nonnegative.xB[k] = false;
                  k++;
                  continue;
               }
               if ((ct.xZ[i] > 0 && v <= tolconstr) || (ct.xZ[i] < 0 && v >= -tolconstr)) {
                  for (j = 0; j < n; j++) {
                     ce.xyR[j][k] = sign((double)ct.xZ[i]) * c.xyR[i][j];
                  }
                  nonnegative.xB[k] = true;
                  k++;
                  continue;
               }
            }
            snnlsinit(0, 0, 0, &nnls);
            snnlssetproblem(&nnls, &ce, &g, 0, k, n);
            for (i = 0; i < k; i++) {
               if (!nonnegative.xB[i]) {
                  snnlsdropnnc(&nnls, i);
               }
            }
            snnlssolve(&nnls, &tmp);
            for (i = 0; i < k; i++) {
               for (j = 0; j < n; j++) {
                  g.xR[j] -= tmp.xR[i] * ce.xyR[j][i];
               }
            }
            vv = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
            vv = sqrt(vv);
            if (akind == 3 || akind == 4) {
               set_error_flag(err, vv > 1.0E-2, __FILE__, __LINE__, "testminqpunit.ap:3244");
            } else {
               set_error_flag(err, vv > 1.0E-3, __FILE__, __LINE__, "testminqpunit.ap:3246");
            }
         }
      }
   }
   ae_frame_leave();
}

// Randomly split constraints into dense and sparse parts
static void testminqpunit_randomlysplitlc(RMatrix *rawc, ZVector *rawct, ae_int_t rawccnt, ae_int_t n, sparsematrix *sparsec, ZVector *sparsect, ae_int_t *sparseccnt, RMatrix *densec, ZVector *densect, ae_int_t *denseccnt, hqrndstate *rs) {
   ae_int_t i;
   ae_int_t j;
   SetObj(sparsematrix, sparsec);
   SetVector(sparsect);
   *sparseccnt = 0;
   SetMatrix(densec);
   SetVector(densect);
   *denseccnt = 0;
// Split "raw" constraints into dense and sparse parts
   *sparseccnt = hqrnduniformi(rs, rawccnt + 1);
   *denseccnt = rawccnt - (*sparseccnt);
   if (*sparseccnt > 0) {
      sparsecreate(*sparseccnt, n + 1, 0, sparsec);
      ae_vector_set_length(sparsect, *sparseccnt);
      for (i = 0; i < *sparseccnt; i++) {
         for (j = 0; j <= n; j++) {
            sparseset(sparsec, i, j, rawc->xyR[i][j]);
         }
         sparsect->xZ[i] = rawct->xZ[i];
      }
   }
   if (*denseccnt > 0) {
      ae_matrix_set_length(densec, *denseccnt, n + 1);
      ae_vector_set_length(densect, *denseccnt);
      for (i = 0; i < *denseccnt; i++) {
         for (j = 0; j <= n; j++) {
            densec->xyR[i][j] = rawc->xyR[*sparseccnt + i][j];
         }
         densect->xZ[i] = rawct->xZ[*sparseccnt + i];
      }
   }
}

// Randomly split constraints into dense and sparse parts and set them;
// legacy API is used.
static void testminqpunit_randomlysplitandsetlclegacy(RMatrix *rawc, ZVector *rawct, ae_int_t rawccnt, ae_int_t n, minqpstate *state, hqrndstate *rs) {
   ae_frame _frame_block;
   ae_int_t denseccnt;
   ae_int_t sparseccnt;
   ae_frame_make(&_frame_block);
   NewMatrix(densec, 0, 0, DT_REAL);
   NewVector(densect, 0, DT_INT);
   NewObj(sparsematrix, sparsec);
   NewVector(sparsect, 0, DT_INT);
// reset constraints
   minqpsetlc(state, &densec, &densect, 0);
// split and set
   testminqpunit_randomlysplitlc(rawc, rawct, rawccnt, n, &sparsec, &sparsect, &sparseccnt, &densec, &densect, &denseccnt, rs);
   if (hqrnduniformr(rs) > 0.5 || denseccnt * sparseccnt > 0) {
      minqpsetlcmixed(state, &sparsec, &sparsect, sparseccnt, &densec, &densect, denseccnt);
   } else {
      if (denseccnt > 0) {
         minqpsetlc(state, &densec, &densect, denseccnt);
      }
      if (sparseccnt > 0) {
         minqpsetlcsparse(state, &sparsec, &sparsect, sparseccnt);
      }
   }
   ae_frame_leave();
}

// Randomly split 2-sided constraints into dense and sparse parts and set them;
static void testminqpunit_randomlysplitandsetlc2(RMatrix *rawc, RVector *rawcl, RVector *rawcu, ae_int_t rawccnt, ae_int_t n, minqpstate *state, hqrndstate *rs) {
   ae_frame _frame_block;
   ae_int_t denseccnt;
   ae_int_t sparseccnt;
   ae_int_t i;
   ae_int_t j;
   ae_int_t appenddense;
   ae_int_t appendsparse;
   ae_int_t nnz;
   ae_frame_make(&_frame_block);
   NewMatrix(densec, 0, 0, DT_REAL);
   NewVector(densecl, 0, DT_REAL);
   NewVector(densecu, 0, DT_REAL);
   NewObj(sparsematrix, sparsec);
   NewVector(sparsecl, 0, DT_REAL);
   NewVector(sparsecu, 0, DT_REAL);
   NewVector(wrkcl, 0, DT_REAL);
   NewVector(wrkcu, 0, DT_REAL);
   NewVector(cv, 0, DT_REAL);
   NewVector(ci, 0, DT_INT);
// reset constraints
   minqpsetlc2dense(state, &densec, &densecl, &densecu, 0);
// Split "raw" constraints into dense and sparse parts
   sparseccnt = hqrnduniformi(rs, rawccnt + 1);
   denseccnt = rawccnt - sparseccnt;
   appenddense = hqrnduniformi(rs, denseccnt + 1);
   denseccnt -= appenddense;
   appendsparse = hqrnduniformi(rs, sparseccnt + 1);
   sparseccnt -= appendsparse;
   ae_vector_set_length(&wrkcl, sparseccnt + denseccnt);
   ae_vector_set_length(&wrkcu, sparseccnt + denseccnt);
   if (sparseccnt > 0) {
      sparsecreate(sparseccnt, n, 0, &sparsec);
      ae_vector_set_length(&sparsecl, sparseccnt);
      ae_vector_set_length(&sparsecu, sparseccnt);
      for (i = 0; i < sparseccnt; i++) {
         for (j = 0; j < n; j++) {
            sparseset(&sparsec, i, j, rawc->xyR[i][j]);
         }
         sparsecl.xR[i] = rawcl->xR[i];
         sparsecu.xR[i] = rawcu->xR[i];
         wrkcl.xR[i] = sparsecl.xR[i];
         wrkcu.xR[i] = sparsecu.xR[i];
      }
   }
   if (denseccnt > 0) {
      ae_matrix_set_length(&densec, denseccnt, n);
      ae_vector_set_length(&densecl, denseccnt);
      ae_vector_set_length(&densecu, denseccnt);
      for (i = 0; i < denseccnt; i++) {
         for (j = 0; j < n; j++) {
            densec.xyR[i][j] = rawc->xyR[sparseccnt + appendsparse + i][j];
         }
         densecl.xR[i] = rawcl->xR[sparseccnt + appendsparse + i];
         densecu.xR[i] = rawcu->xR[sparseccnt + appendsparse + i];
         wrkcl.xR[sparseccnt + i] = densecl.xR[i];
         wrkcu.xR[sparseccnt + i] = densecu.xR[i];
      }
   }
// split and set
   if (hqrnduniformr(rs) > 0.5 || denseccnt * sparseccnt > 0) {
      minqpsetlc2mixed(state, &sparsec, sparseccnt, &densec, denseccnt, &wrkcl, &wrkcu);
   } else {
      if (denseccnt > 0) {
         minqpsetlc2dense(state, &densec, &densecl, &densecu, denseccnt);
      }
      if (sparseccnt > 0) {
         minqpsetlc2(state, &sparsec, &sparsecl, &sparsecu, sparseccnt);
      }
   }
   ae_vector_set_length(&cv, 2 * n);
   ae_vector_set_length(&ci, 2 * n);
   for (i = sparseccnt; i < sparseccnt + appendsparse; i++) {
      if (hqrndnormal(rs) > 0.0) {
      // Add sparse constraint using AddLC2()
      // First, generate sparse representation
         nnz = 0;
         for (j = 0; j < n; j++) {
            if (rawc->xyR[i][j] != 0.0) {
               cv.xR[nnz] = rawc->xyR[i][j];
               ci.xZ[nnz] = j;
               nnz++;
            }
         }
      // Add duplicates which do not change constraint (after simplification)
         while ((nnz > 0 && nnz < ci.cnt) && hqrnduniformr(rs) < 0.75) {
            j = hqrnduniformi(rs, nnz);
            ci.xZ[nnz] = ci.xZ[j];
            cv.xR[nnz] = hqrndnormal(rs);
            cv.xR[j] -= cv.xR[nnz];
            nnz++;
         }
      // Add constraint to the set
         minqpaddlc2(state, &ci, &cv, nnz, rawcl->xR[i], rawcu->xR[i]);
      } else {
      // Add sparse constraint using AddLC2SparseFromDense()
         for (j = 0; j < n; j++) {
            cv.xR[j] = rawc->xyR[i][j];
         }
         minqpaddlc2sparsefromdense(state, &cv, rawcl->xR[i], rawcu->xR[i]);
      }
   }
   for (i = rawccnt - appenddense; i < rawccnt; i++) {
      for (j = 0; j < n; j++) {
         cv.xR[j] = rawc->xyR[i][j];
      }
      minqpaddlc2dense(state, &cv, rawcl->xR[i], rawcu->xR[i]);
   }
   ae_frame_leave();
}

// Randomly selects triangle of full symmetric matrix, converts it to one of
// the matrix storage formats (dense or sparse) and sets.
static void testminqpunit_randomlyselectconvertandsetquadraticterm(RMatrix *a, ae_int_t n, minqpstate *state, hqrndstate *rs) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   bool isupper;
   bool isdense;
   ae_frame_make(&_frame_block);
   NewMatrix(densea, 0, 0, DT_REAL);
   NewObj(sparsematrix, sparsea);
   isupper = hqrnduniformr(rs) > 0.5;
   isdense = hqrnduniformr(rs) > 0.5;
   if (isupper && isdense) {
      ae_matrix_set_length(&densea, n, n);
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            densea.xyR[i][j] = a->xyR[i][j];
         }
      }
      minqpsetquadraticterm(state, &densea, isupper);
      ae_frame_leave();
      return;
   }
   if (!isupper && isdense) {
      ae_matrix_set_length(&densea, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j <= i; j++) {
            densea.xyR[i][j] = a->xyR[i][j];
         }
      }
      minqpsetquadraticterm(state, &densea, isupper);
      ae_frame_leave();
      return;
   }
   if (isupper && !isdense) {
      sparsecreate(n, n, 0, &sparsea);
      for (i = 0; i < n; i++) {
         for (j = i; j < n; j++) {
            sparseset(&sparsea, i, j, a->xyR[i][j]);
         }
      }
      minqpsetquadratictermsparse(state, &sparsea, isupper);
      ae_frame_leave();
      return;
   }
   if (!isupper && !isdense) {
      sparsecreate(n, n, 0, &sparsea);
      for (i = 0; i < n; i++) {
         for (j = 0; j <= i; j++) {
            sparseset(&sparsea, i, j, a->xyR[i][j]);
         }
      }
      minqpsetquadratictermsparse(state, &sparsea, isupper);
      ae_frame_leave();
      return;
   }
   ae_frame_leave();
}

// This function returns reciprocal of condition  number  of  general  linear
// constraints.
static double testminqpunit_getconstraintrcond(RMatrix *c, ae_int_t k, ae_int_t n) {
   ae_frame _frame_block;
   bool bflag;
   double result;
   ae_frame_make(&_frame_block);
   NewVector(svdw, 0, DT_REAL);
   NewMatrix(svdu, 0, 0, DT_REAL);
   NewMatrix(svdvt, 0, 0, DT_REAL);
   bflag = rmatrixsvd(c, k, n, 0, 0, 0, &svdw, &svdu, &svdvt);
   ae_assert(bflag, "MinQPTest: integrity failure");
   if (svdw.xR[0] > 0.0) {
      result = svdw.xR[imin2(k, n) - 1] / svdw.xR[0];
   } else {
      result = 1.0;
   }
   ae_frame_leave();
   return result;
}

// Computes target function 0.5*x'*H*x+c'*x
// ALGLIB: Copyright 01.11.2019 by Sergey Bochkanov
static double testminqpunit_quadratictarget(RMatrix *a, RVector *b, ae_int_t n, RVector *x) {
   ae_int_t i;
   ae_int_t j;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      result += b->xR[i] * x->xR[i];
      for (j = 0; j < n; j++) {
         result += 0.5 * x->xR[i] * a->xyR[i][j] * x->xR[j];
      }
   }
   return result;
}

// This function tests linearly constrained QP solvers.
//
// On failure sets Err to True; on success leaves it unchanged.
static void testminqpunit_generallcqptest(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t solvertype;
   double v;
   double vv;
   bool bflag;
   ae_int_t pass;
   ae_int_t rawccnt;
   ae_int_t denseccnt;
   ae_int_t sparseccnt;
   ae_int_t nactive;
   double constraintsrcond;
   double f0;
   double f1;
   double xtol;
   double ftol;
   double gtol;
   double tolconstr;
   ae_int_t bscale;
   ae_int_t akind;
   double mx;
   ae_int_t shiftkind;
   ae_int_t nnz;
   bool issemidefinite;
   bool skiptest;
   double bleicepsx;
   double aulepsx;
   double aulrho;
   ae_int_t aulits;
   double ipmeps;
   double minushuge;
   double plushuge;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(rawa, 0, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewVector(b, 0, DT_REAL);
   NewVector(b2, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(xf, 0, DT_REAL);
   NewVector(xorigin, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(da, 0, DT_REAL);
   NewVector(xstart, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(gtrial, 0, DT_REAL);
   NewVector(gs, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(tmp1, 0, DT_REAL);
   NewVector(tmp2, 0, DT_REAL);
   NewVector(lagrange, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(rawc, 0, 0, DT_REAL);
   NewVector(rawcl, 0, DT_REAL);
   NewVector(rawcu, 0, DT_REAL);
   NewVector(rawct, 0, DT_INT);
   NewMatrix(densec, 0, 0, DT_REAL);
   NewVector(densect, 0, DT_INT);
   NewObj(sparsematrix, sparsec);
   NewVector(sparsect, 0, DT_INT);
   NewMatrix(activeset, 0, 0, DT_REAL);
   NewVector(activeeq, 0, DT_BOOL);
   NewObj(snnlssolver, nnls);
   NewVector(svdw, 0, DT_REAL);
   NewMatrix(svdu, 0, 0, DT_REAL);
   NewMatrix(svdvt, 0, 0, DT_REAL);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   NewObj(minqpstate, state2);
   NewObj(minqpreport, rep2);
   NewMatrix(ce, 0, 0, DT_REAL);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(t2, 0, 0, DT_REAL);
   NewMatrix(t3, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewVector(lagbc, 0, DT_REAL);
   NewVector(laglc, 0, DT_REAL);
   NewVector(nonnegative, 0, DT_BOOL);
   NewMatrix(kkt, 0, 0, DT_REAL);
   NewVector(kktright, 0, DT_REAL);
   hqrndrandomize(&rs);
   bleicepsx = 1.0E-9;
   ipmeps = 1.0E-12;
   aulepsx = 1.0E-12;
   aulrho = 5.0E3;
   aulits = 15;
// SMALL-SCALE TESTS: many tests for small N's
   for (solvertype = 0; solvertype <= 3; solvertype++) {
   // Test random linearly constrained convex QP problem with known answer:
   // * generate random A and b
   // * generate random solution XS
   // * calculate unconstrained gradient GS at XS
   // * generate random box/linear constraints C, with some of them being
   //   active at XS, and some being inactive. Calculate residual gradient
   //   GP after projection of GS onto active set, add one more constraint
   //   equal to +-(GP-GS).
   //
   // We test here BLEIC and Dense-AUL solvers, with A being passed
   // in dense or sparse format, and linear constraints C being passed
   // as dense, sparse or mixed ones.
      for (n = 1; n <= 10; n++) {
      // Generate random A, b and xs
         spdmatrixrndcond(n, pow(10.0, 2 * randomreal()), &rawa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xs, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            xs.xR[i] = hqrndnormal(&rs);
         }
      // Generate well conditioned "raw" constraints:
      // * generate random box and CCnt-1 linear constraints
      // * determine active set, calculate its condition number
      // * repeat until condition number is good enough
      //   (better than 1E2; larger values sometimes result in
      //   spurious failures)
         ae_vector_set_length(&gs, n);
         ae_vector_set_length(&tmp, n);
         rmatrixmv(n, n, &rawa, 0, 0, 0, &xs, 0, &gs, 0);
         for (i = 0; i < n; i++) {
            gs.xR[i] += b.xR[i];
         }
         rawccnt = 1 + hqrnduniformi(&rs, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_matrix_set_length(&activeset, n, n + rawccnt);
         ae_vector_set_length(&activeeq, n + rawccnt);
         ae_matrix_set_length(&rawc, rawccnt, n + 1);
         ae_vector_set_length(&rawct, rawccnt);
         do {
            nactive = 0;
            for (i = 0; i < n; i++) {
               bndl.xR[i] = xs.xR[i] - 1 - hqrnduniformr(&rs);
               bndu.xR[i] = xs.xR[i] + 1 + hqrnduniformr(&rs);
               if (hqrnduniformr(&rs) < 0.66) {
               // I-th box constraint is inactive
                  continue;
               }
               if (hqrnduniformr(&rs) > 0.50) {
               // I-th box constraint is equality one
                  bndl.xR[i] = xs.xR[i];
                  bndu.xR[i] = xs.xR[i];
                  for (j = 0; j < n; j++) {
                     activeset.xyR[j][nactive] = 0.0;
                  }
                  activeset.xyR[i][nactive] = 1.0;
                  activeeq.xB[nactive] = true;
                  nactive++;
               } else {
               // I-th box constraint is inequality one
                  for (j = 0; j < n; j++) {
                     activeset.xyR[j][nactive] = 0.0;
                  }
                  if (gs.xR[i] > 0.0) {
                     bndl.xR[i] = xs.xR[i];
                     activeset.xyR[i][nactive] = -1.0;
                     if (hqrnduniformr(&rs) > 0.50) {
                        bndu.xR[i] = +INFINITY;
                     }
                  } else {
                     bndu.xR[i] = xs.xR[i];
                     activeset.xyR[i][nactive] = 1.0;
                     if (hqrnduniformr(&rs) > 0.50) {
                        bndl.xR[i] = -INFINITY;
                     }
                  }
                  activeeq.xB[nactive] = false;
                  nactive++;
               }
            }
            for (i = 0; i < rawccnt - 1; i++) {
               for (j = 0; j < n; j++) {
                  if (hqrnduniformr(&rs) < 0.50) {
                     rawc.xyR[i][j] = hqrndnormal(&rs);
                  } else {
                     rawc.xyR[i][j] = 0.0;
                  }
               }
               rawc.xyR[i][hqrnduniformi(&rs, n)] = hqrndnormal(&rs);
               rawc.xyR[i][n] = 0.0;
               for (j = 0; j < n; j++) {
                  rawc.xyR[i][n] += rawc.xyR[i][j] * xs.xR[j];
               }
               rawct.xZ[i] = -1;
               if (hqrnduniformr(&rs) < 0.66) {
               // I-th box constraint is inactive
                  rawc.xyR[i][n] += (1 + hqrnduniformr(&rs));
                  if (hqrnduniformr(&rs) > 0.50) {
                     ae_v_muld(rawc.xyR[i], 1, n + 1, -1);
                     rawct.xZ[i] = -rawct.xZ[i];
                  }
                  continue;
               }
               if (hqrnduniformr(&rs) > 0.50) {
               // I-th box constraint is equality one
                  rawct.xZ[i] = 0;
                  for (j = 0; j < n; j++) {
                     activeset.xyR[j][nactive] = rawc.xyR[i][j];
                  }
                  activeeq.xB[nactive] = true;
                  nactive++;
               } else {
               // I-th box constraint is inequality one
                  v = ae_v_dotproduct(rawc.xyR[i], 1, gs.xR, 1, n);
                  if (v > 0.0) {
                     rawct.xZ[i] = 1;
                     for (j = 0; j < n; j++) {
                        activeset.xyR[j][nactive] = -rawc.xyR[i][j];
                     }
                  } else {
                     rawct.xZ[i] = -1;
                     for (j = 0; j < n; j++) {
                        activeset.xyR[j][nactive] = rawc.xyR[i][j];
                     }
                  }
                  activeeq.xB[nactive] = false;
                  nactive++;
               }
            }
            ae_v_moveneg(tmp.xR, 1, gs.xR, 1, n);
            snnlsinit(0, 0, 0, &nnls);
            snnlssetproblem(&nnls, &activeset, &tmp, 0, nactive, n);
            for (i = 0; i < nactive; i++) {
               if (activeeq.xB[i]) {
                  snnlsdropnnc(&nnls, i);
               }
            }
            snnlssolve(&nnls, &lagrange);
            ae_v_moveneg(tmp.xR, 1, gs.xR, 1, n);
            for (i = 0; i < nactive; i++) {
               v = lagrange.xR[i];
               ae_v_subd(tmp.xR, 1, &activeset.xyR[0][i], activeset.stride, n, v);
            }
            ae_v_move(rawc.xyR[rawccnt - 1], 1, tmp.xR, 1, n);
            v = ae_v_dotproduct(tmp.xR, 1, xs.xR, 1, n);
            rawc.xyR[rawccnt - 1][n] = v;
            rawct.xZ[rawccnt - 1] = -1;
         // Calculate reciprocal condition number
            if (nactive > 0) {
               bflag = rmatrixsvd(&activeset, n, nactive, 0, 0, 0, &svdw, &svdu, &svdvt);
               ae_assert(bflag, "MinQPTest: integrity failure");
               constraintsrcond = svdw.xR[imin2(nactive, n) - 1] / svdw.xR[0];
            } else {
               constraintsrcond = 1.0;
            }
         // Check RCond
         } while (!(constraintsrcond >= 0.01 && nactive < n));
      // Create optimizer, solve
         minqpcreate(n, &state);
         if (solvertype == 0) {
            minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
         } else {
            if (solvertype == 1) {
               minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
            } else {
               if (solvertype == 2) {
                  minqpsetalgodenseipm(&state, ipmeps);
               } else {
                  if (solvertype == 3) {
                     minqpsetalgosparseipm(&state, ipmeps);
                  } else {
                     ae_assert(false, "unexpected solver type");
                  }
               }
            }
         }
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
         minqpsetbc(&state, &bndl, &bndu);
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
      // Test
      //
      // Because constrained problems are often ill-conditioned,
      // we do NOT compare X1 with XS directly. Instead, we:
      // a) compare function values at X1 and XS with good precision
      // b) check constraint violation with good precision
      // c) perform comparison for |X1-XS| with LOW precision
         if (rep.terminationtype <= 0) {
            set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:3569");
            ae_frame_leave();
            return;
         }
         f0 = 0.0;
         f1 = 0.0;
         for (i = 0; i < n; i++) {
            f0 += b.xR[i] * xs.xR[i];
            f1 += b.xR[i] * x1.xR[i];
            for (j = 0; j < n; j++) {
               f0 += 0.5 * xs.xR[i] * rawa.xyR[i][j] * xs.xR[j];
               f1 += 0.5 * x1.xR[i] * rawa.xyR[i][j] * x1.xR[j];
            }
         }
         set_error_flag(errorflag, fabs(f0 - f1) > 1.0E-3, __FILE__, __LINE__, "testminqpunit.ap:3584");
      }
   // Inequality constrained convex problem:
   // * N*N diagonal A
   // * one inequality constraint q'*x >= 0, where q is random unit vector
   // * optimization problem has form 0.5*x'*A*x-(xs*A)*x,
   //   where xs is some random vector
   // * either:
   //   a) xs is feasible => we must stop at xs
   //   b) xs is infeasible => we must stop at the boundary q'*x=0 and
   //      projection of gradient onto q*x=0 must be zero
   //
   // NOTE: we make several passes because some specific kind of errors is rarely
   //       caught by this test, so we need several repetitions.
      xtol = 1.0E-4;
      gtol = 1.0E-4;
      for (n = 2; n <= 6; n++) {
         for (pass = 0; pass <= 4; pass++) {
         // Generate problem: A, b, CMatrix, x0, XStart
            spdmatrixrndcond(n, pow(10.0, 3 * randomreal()), &a);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&xs, n);
            ae_vector_set_length(&xstart, n);
            ae_matrix_set_length(&rawc, 1, n + 1);
            ae_vector_set_length(&rawct, 1);
            for (i = 0; i < n; i++) {
               xs.xR[i] = randommid();
               xstart.xR[i] = randommid();
            }
            do {
               v = 0.0;
               for (i = 0; i < n; i++) {
                  rawc.xyR[0][i] = randommid();
                  v += sqr(rawc.xyR[0][i]);
               }
               v = sqrt(v);
            } while (v == 0.0);
            for (i = 0; i < n; i++) {
               rawc.xyR[0][i] /= v;
            }
            rawc.xyR[0][n] = 0.0;
            rawct.xZ[0] = 1;
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xs.xR, 1, n);
               b.xR[i] = -v;
            }
         // Create optimizer, solve
            minqpcreate(n, &state);
            if (solvertype == 0) {
               minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
            } else {
               if (solvertype == 1) {
                  minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
               } else {
                  if (solvertype == 2) {
                     minqpsetalgodenseipm(&state, ipmeps);
                  } else {
                     if (solvertype == 3) {
                        minqpsetalgosparseipm(&state, ipmeps);
                     } else {
                        ae_assert(false, "unexpected solver type");
                     }
                  }
               }
            }
            minqpsetlinearterm(&state, &b);
            testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
            minqpsetstartingpoint(&state, &xstart);
            testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, 1, n, &state, &rs);
            minqpoptimize(&state);
            minqpresults(&state, &x1, &rep);
         // Test
            if (rep.terminationtype <= 0) {
               set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:3667");
               ae_frame_leave();
               return;
            }
            v = ae_v_dotproduct(xs.xR, 1, rawc.xyR[0], 1, n);
            if (v >= 0.0) {
            // XS is feasible
               for (i = 0; i < n; i++) {
                  set_error_flag(errorflag, fabs(x1.xR[i] - xs.xR[i]) > xtol, __FILE__, __LINE__, "testminqpunit.ap:3677");
               }
            } else {
            // XS is infeasible:
            // * X1 must be approximately feasible
            // * gradient projection onto c'*x=0 must be zero
               v = ae_v_dotproduct(x1.xR, 1, rawc.xyR[0], 1, n);
               set_error_flag(errorflag, v < -xtol, __FILE__, __LINE__, "testminqpunit.ap:3687");
               ae_vector_set_length(&g, n);
               ae_v_move(g.xR, 1, b.xR, 1, n);
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
                  g.xR[i] += v;
               }
               v = ae_v_dotproduct(g.xR, 1, rawc.xyR[0], 1, n);
               ae_v_subd(g.xR, 1, rawc.xyR[0], 1, n, v);
               v = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
               set_error_flag(errorflag, sqrt(v) > gtol, __FILE__, __LINE__, "testminqpunit.ap:3698");
            }
         }
      }
   // Box constraints vs linear ones:
   // * N*N SPD A
   // * optimization problem has form 0.5*x'*A*x-(x1*A)*x,
   //   where x1 is some random vector from [-1,+1]
   // * K=2*N constraints of the form ai <= x[i] or x[i] <= b[i],
   //   with ai in [-1.0,-0.1], bi in [+0.1,+1.0]
   // * initial point xstart is from [-1,+2]
   // * we solve two related QP problems:
   //   a) one with constraints posed as boundary ones
   //   b) another one with same constraints posed as general linear ones
   // both problems must have same solution.
   // Here we test that boundary constrained and linear inequality constrained
   // solvers give same results.
      xtol = 1.0E-5;
      for (n = 1; n <= 6; n++) {
      // Generate problem: A, b, x0, XStart, C, CT
         spdmatrixrndcond(n, pow(10.0, 3 * randomreal()), &a);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&rawc, 2 * n, n + 1);
         ae_vector_set_length(&rawct, 2 * n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            x1.xR[i] = randommid();
            xstart.xR[i] = 3.0 * randomreal() - 1.0;
            bndl.xR[i] = -(0.1 + 0.9 * randomreal());
            bndu.xR[i] = 0.1 + 0.9 * randomreal();
            for (j = 0; j < n; j++) {
               rawc.xyR[2 * i + 0][j] = 0.0;
               rawc.xyR[2 * i + 1][j] = 0.0;
            }
            rawc.xyR[2 * i + 0][i] = 1.0;
            rawc.xyR[2 * i + 0][n] = bndl.xR[i];
            rawct.xZ[2 * i + 0] = 1;
            rawc.xyR[2 * i + 1][i] = 1.0;
            rawc.xyR[2 * i + 1][n] = bndu.xR[i];
            rawct.xZ[2 * i + 1] = -1;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
            b.xR[i] = -v;
         }
      // Solve linear inequality constrained problem
         minqpcreate(n, &state);
         if (solvertype == 0) {
            minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
         } else {
            if (solvertype == 1) {
               minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
            } else {
               if (solvertype == 2) {
                  minqpsetalgodenseipm(&state, ipmeps);
               } else {
                  if (solvertype == 3) {
                     minqpsetalgosparseipm(&state, ipmeps);
                  } else {
                     ae_assert(false, "unexpected solver type");
                  }
               }
            }
         }
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
         minqpsetstartingpoint(&state, &xstart);
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, 2 * n, n, &state, &rs);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
      // Solve boundary constrained problem
         minqpcreate(n, &state2);
         if (solvertype == 0) {
            minqpsetalgobleic(&state2, 0.0, 0.0, bleicepsx, 0);
         } else {
            if (solvertype == 1) {
               minqpsetalgodenseaul(&state2, aulepsx, aulrho, aulits);
            } else {
               if (solvertype == 2) {
                  minqpsetalgodenseipm(&state2, ipmeps);
               } else {
                  if (solvertype == 3) {
                     minqpsetalgosparseipm(&state2, ipmeps);
                  } else {
                     ae_assert(false, "unexpected solver type");
                  }
               }
            }
         }
         minqpsetlinearterm(&state2, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state2, &rs);
         minqpsetstartingpoint(&state2, &xstart);
         minqpsetbc(&state2, &bndl, &bndu);
         minqpoptimize(&state2);
         minqpresults(&state2, &x2, &rep2);
      // Calculate gradient, check projection
         if (rep.terminationtype <= 0 || rep2.terminationtype <= 0) {
            set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:3804");
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, x1.xR[i] < bndl.xR[i] - xtol, __FILE__, __LINE__, "testminqpunit.ap:3809");
            set_error_flag(errorflag, x1.xR[i] > bndu.xR[i] + xtol, __FILE__, __LINE__, "testminqpunit.ap:3810");
            set_error_flag(errorflag, fabs(x1.xR[i] - x2.xR[i]) > xtol, __FILE__, __LINE__, "testminqpunit.ap:3811");
         }
      }
   // Convex/nonconvex optimization problem with combination of
   // box and linear constraints:
   //
   // * N=2..8
   // * f = 0.5*x'*A*x+b'*x
   // * b has normally distributed entries with scale 10^BScale
   // * several kinds of A are tried: zero, well conditioned SPD,
   //   well conditioned definite, low rank semidefinity
   // * box constraints: x[i] in [-1,+1]
   // * initial point x0 = [0 0 ... 0 0]
   // * CCnt=min(3,N-1) general linear constraints of form (c,x)=0.
   //   random mix of equality/inequality constraints is tried, moderate
   //   condition number is guaranteed, x0 is guaranteed to be feasible.
   //
   // We check that constrained gradient is close to zero at solution.
   // Inequality constraint is considered active if distance to boundary
   // is less than TolConstr. We use nonnegative least squares solver
   // in order to compute constrained gradient.
      tolconstr = -99999.0;
      for (n = 2; n <= 8; n++) {
         for (akind = 0; akind <= 3; akind++) {
            for (bscale = 1; bscale >= -1; bscale--) {
            // Dense-AUL solver has lower precision on rank-deficient
            // problems, so we skip AKind=3.
            //
            // IPM solvers can not work with indefinite problems.
               if (solvertype == 1 && akind == 3) {
                  continue;
               }
               if ((solvertype == 2 || solvertype == 3) && (akind == 2 || akind == 4)) {
                  continue;
               }
            // Set up tolerances
               if (solvertype == 0) {
                  tolconstr = 1.0E-8;
               } else {
                  if ((solvertype == 1 || solvertype == 2) || solvertype == 3) {
                     tolconstr = 1.0E-3;
                     if (akind == 3) {
                        tolconstr *= 5;
                     }
                  } else {
                     ae_assert(false, "unexpected solver type");
                  }
               }
               gtol = 1.0E-4;
            // Generate A, B and initial point
               ae_matrix_set_length(&a, n, n);
               ae_vector_set_length(&b, n);
               ae_vector_set_length(&xstart, n);
               for (i = 0; i < n; i++) {
                  b.xR[i] = pow(10.0, (double)bscale) * hqrndnormal(&rs);
                  xstart.xR[i] = 0.0;
               }
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               if (akind == 1) {
               // Dense well conditioned SPD
                  spdmatrixrndcond(n, 50.0, &a);
               }
               if (akind == 2) {
               // Dense well conditioned indefinite
                  smatrixrndcond(n, 50.0, &a);
               }
               if (akind == 3) {
               // Low rank semidefinite
                  ae_vector_set_length(&tmp, n);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] = 0.0;
                     }
                  }
                  for (k = 1; k < imin2(4, n); k++) {
                     for (i = 0; i < n; i++) {
                        tmp.xR[i] = hqrndnormal(&rs);
                     }
                     v = pow(2.0, hqrndnormal(&rs));
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                        }
                     }
                  }
               }
            // Generate constraints
               ae_vector_set_length(&bndl, n);
               ae_vector_set_length(&bndu, n);
               for (i = 0; i < n; i++) {
                  bndl.xR[i] = -1.0;
                  bndu.xR[i] = 1.0;
               }
               rawccnt = imin2(3, n - 1);
               ae_matrix_set_length(&rawc, rawccnt, n + 1);
               ae_vector_set_length(&rawct, rawccnt);
               do {
                  for (i = 0; i < rawccnt; i++) {
                     rawct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
                     rawc.xyR[i][n] = 0.0;
                     for (j = 0; j < n; j++) {
                        rawc.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                     }
                  }
               } while (testminqpunit_getconstraintrcond(&rawc, rawccnt, n) <= 0.01);
            // Create and optimize
               minqpcreate(n, &state);
               minqpsetstartingpoint(&state, &xstart);
               if (solvertype == 0) {
                  minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
               } else {
                  if (solvertype == 1) {
                     minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
                  } else {
                     if (solvertype == 2) {
                        minqpsetalgodenseipm(&state, ipmeps);
                     } else {
                        if (solvertype == 3) {
                           minqpsetalgosparseipm(&state, ipmeps);
                        } else {
                           ae_assert(false, "unexpected solver type");
                        }
                     }
                  }
               }
               minqpsetbc(&state, &bndl, &bndu);
               testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
               minqpsetlinearterm(&state, &b);
               testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
               minqpoptimize(&state);
               minqpresults(&state, &x1, &rep);
               set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:3961");
               if (*errorflag) {
                  ae_frame_leave();
                  return;
               }
            // 1. evaluate unconstrained gradient at solution
            //
            // 2. calculate constrained gradient (NNLS solver is used
            //    to evaluate gradient subject to active constraints).
            //    In order to do this we form CE matrix, matrix of active
            //    constraints (columns store constraint vectors). Then
            //    we try to approximate gradient vector by columns of CE,
            //    subject to non-negativity restriction placed on variables
            //    corresponding to inequality constraints.
            //
            //    Residual from such regression is a constrained gradient vector.
               ae_vector_set_length(&g, n);
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
                  g.xR[i] = v + b.xR[i];
               }
               ae_matrix_set_length(&ce, n, n + rawccnt);
               ae_vector_set_length(&nonnegative, n + rawccnt);
               k = 0;
               for (i = 0; i < n; i++) {
                  set_error_flag(errorflag, x1.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminqpunit.ap:3989");
                  set_error_flag(errorflag, x1.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminqpunit.ap:3990");
                  if (x1.xR[i] <= bndl.xR[i] + tolconstr) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = 0.0;
                     }
                     ce.xyR[i][k] = 1.0;
                     nonnegative.xB[k] = true;
                     k++;
                     continue;
                  }
                  if (x1.xR[i] >= bndu.xR[i] - tolconstr) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = 0.0;
                     }
                     ce.xyR[i][k] = -1.0;
                     nonnegative.xB[k] = true;
                     k++;
                     continue;
                  }
               }
               for (i = 0; i < rawccnt; i++) {
                  v = ae_v_dotproduct(rawc.xyR[i], 1, x1.xR, 1, n);
                  v -= rawc.xyR[i][n];
                  set_error_flag(errorflag, rawct.xZ[i] == 0 && fabs(v) > tolconstr, __FILE__, __LINE__, "testminqpunit.ap:4014");
                  set_error_flag(errorflag, rawct.xZ[i] > 0 && v < -tolconstr, __FILE__, __LINE__, "testminqpunit.ap:4015");
                  set_error_flag(errorflag, rawct.xZ[i] < 0 && v > tolconstr, __FILE__, __LINE__, "testminqpunit.ap:4016");
                  if (rawct.xZ[i] == 0) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = rawc.xyR[i][j];
                     }
                     nonnegative.xB[k] = false;
                     k++;
                     continue;
                  }
                  if ((rawct.xZ[i] > 0 && v <= tolconstr) || (rawct.xZ[i] < 0 && v >= -tolconstr)) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = sign((double)rawct.xZ[i]) * rawc.xyR[i][j];
                     }
                     nonnegative.xB[k] = true;
                     k++;
                     continue;
                  }
               }
               snnlsinit(0, 0, 0, &nnls);
               snnlssetproblem(&nnls, &ce, &g, 0, k, n);
               for (i = 0; i < k; i++) {
                  if (!nonnegative.xB[i]) {
                     snnlsdropnnc(&nnls, i);
                  }
               }
               snnlssolve(&nnls, &tmp);
               for (i = 0; i < k; i++) {
                  for (j = 0; j < n; j++) {
                     g.xR[j] -= tmp.xR[i] * ce.xyR[j][i];
                  }
               }
               vv = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
               vv = sqrt(vv);
               set_error_flag(errorflag, vv > gtol, __FILE__, __LINE__, "testminqpunit.ap:4045");
            }
         }
      }
   // Boundary and linear equality/inequality constrained QP problem,
   // test for correct handling of non-zero XOrigin:
   // * N*N SPD A with moderate condtion number (up to 100)
   // * boundary constraints 0 <= x[i] <= 1
   // * K<N linear equality/inequality constraints Q*x = Q*x0, where
   //   Q is random orthogonal K*N matrix, x0 is some random vector from the
   //   inner area of the feasible hypercube (0.1 <= x0[i] <= 0.9)
   // * optimization problem has form 0.5*(x-xorigin)'*A*(x-xorigin)+b*(x-xorigin),
   //   where b is some random vector with -1 <= b[i] <= +1.
   //   (sometimes solution is in the inner area, sometimes at the boundary)
   // * every component of the initial point XStart is random from [-1,1]
   //
   // Solution of such problem is calculated using two methods:
   // a) QP with SetOrigin() call
   // b) QP with XOrigin explicitly added to the quadratic function,
   //
   // Both methods should give same results; any significant difference is
   // evidence of some error in the QP implementation.
      ftol = -99999.0;
      xtol = -99999.0;
      for (n = 2; n <= 6; n++) {
         for (k = 1; k < n; k++) {
         // Set up tolerances
            if (solvertype == 0) {
               ftol = 1.0E-5;
               xtol = 1.0E-5;
            } else {
               if ((solvertype == 1 || solvertype == 2) || solvertype == 3) {
                  ftol = 1.0E-3;
                  xtol = 1.0E-3;
               } else {
                  ae_assert(false, "unexpected solver type");
               }
            }
         // Generate problem: A, b, BndL, BndU, CMatrix, x0, x1, XStart.
         // Additionally, we compute modified b: b2 = b-xorigin'*A
            rmatrixrndorthogonal(n, &q);
            spdmatrixrndcond(n, pow(10.0, 2 * randomreal()), &a);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&b2, n);
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&x1, n);
            ae_vector_set_length(&xorigin, n);
            ae_vector_set_length(&xstart, n);
            ae_matrix_set_length(&rawc, k, n + 1);
            ae_vector_set_length(&rawct, k);
            for (i = 0; i < n; i++) {
               x0.xR[i] = 0.1 + 0.8 * randomreal();
               b.xR[i] = randommid();
               bndl.xR[i] = 0.0;
               bndu.xR[i] = 1.0;
               xstart.xR[i] = (double)randominteger(2);
               xorigin.xR[i] = randommid();
            }
            for (i = 0; i < k; i++) {
               ae_v_move(rawc.xyR[i], 1, q.xyR[i], 1, n);
               v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
               rawc.xyR[i][n] = v;
               rawct.xZ[i] = randominteger(3) - 1;
            }
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xorigin.xR, 1, n);
               b2.xR[i] = b.xR[i] - v;
            }
         // Solve with SetOrigin() call
            minqpcreate(n, &state);
            if (solvertype == 0) {
               minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
            } else {
               if (solvertype == 1) {
                  minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
               } else {
                  if (solvertype == 2) {
                     minqpsetalgodenseipm(&state, ipmeps);
                  } else {
                     if (solvertype == 3) {
                        minqpsetalgosparseipm(&state, ipmeps);
                     } else {
                        ae_assert(false, "unexpected solver type");
                     }
                  }
               }
            }
            minqpsetlinearterm(&state, &b);
            testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
            minqpsetstartingpoint(&state, &xstart);
            minqpsetorigin(&state, &xorigin);
            minqpsetbc(&state, &bndl, &bndu);
            testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, k, n, &state, &rs);
            minqpoptimize(&state);
            minqpresults(&state, &x1, &rep);
            if (rep.terminationtype <= 0) {
               set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:4153");
               continue;
            }
         // Solve problem using explicit origin
            minqpcreate(n, &state2);
            if (solvertype == 0) {
               minqpsetalgobleic(&state2, 0.0, 0.0, bleicepsx, 0);
            } else {
               if (solvertype == 1) {
                  minqpsetalgodenseaul(&state2, aulepsx, aulrho, aulits);
               } else {
                  if (solvertype == 2) {
                     minqpsetalgodenseipm(&state2, ipmeps);
                  } else {
                     if (solvertype == 3) {
                        minqpsetalgosparseipm(&state2, ipmeps);
                     } else {
                        ae_assert(false, "unexpected solver type");
                     }
                  }
               }
            }
            minqpsetlinearterm(&state2, &b2);
            testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state2, &rs);
            minqpsetstartingpoint(&state2, &xstart);
            minqpsetbc(&state2, &bndl, &bndu);
            testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, k, n, &state2, &rs);
            minqpoptimize(&state2);
            minqpresults(&state2, &x2, &rep);
            if (rep.terminationtype <= 0) {
               set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:4180");
               continue;
            }
         // Calculate function value at X1/X2.
         // Compare solutions.
            f0 = 0.0;
            f1 = 0.0;
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  f0 += 0.5 * (x1.xR[i] - xorigin.xR[i]) * a.xyR[i][j] * (x1.xR[j] - xorigin.xR[j]);
                  f1 += 0.5 * (x2.xR[i] - xorigin.xR[i]) * a.xyR[i][j] * (x2.xR[j] - xorigin.xR[j]);
               }
               f0 += (x1.xR[i] - xorigin.xR[i]) * b.xR[i];
               f1 += (x2.xR[i] - xorigin.xR[i]) * b.xR[i];
            }
            set_error_flag(errorflag, fabs(f0 - f1) > ftol, __FILE__, __LINE__, "testminqpunit.ap:4200");
            for (i = 0; i < n; i++) {
               set_error_flag(errorflag, fabs(x1.xR[i] - x2.xR[i]) > xtol, __FILE__, __LINE__, "testminqpunit.ap:4202");
            }
         }
      }
   // Test scale-invariance. Solver performs same steps on scaled and
   // unscaled problems (assuming that scale of the variables is known
   // and is 2^k for some integer k; latter guarantees that DENSE-AUL solver
   // performs EXACTLY same steps even under finite-precision arithmetics).
   //
   // We generate random scale matrix S and random well-conditioned and
   // well scaled matrix A. Then we solve two problems:
   //
   //     (1) f = 0.5*x'*A*x+b'*x
   //         (identity scale matrix is used)
   //
   // and
   //
   //     (2) f = 0.5*y'*(inv(S)*A*inv(S))*y + (inv(S)*b)'*y
   //         (scale matrix S is used)
   //
   // with correspondingly scaled constraints, origin and starting point.
   //
   // As result, we must get S*x=y
      for (n = 2; n <= 6; n++) {
         for (k = 1; k < imax2(n - 1, 2); k++) {
         // Set up tolerances:
         // * BLEIC or IPM do not guarantee that we perform steps exactly even
         //   when scale is 2^k, so we use non-zero XTol=1E-3
         // * DENSE-AUL provides such guarantee, so XTol=0
            if ((solvertype == 0 || solvertype == 2) || solvertype == 3) {
               xtol = 1.0E-3;
            } else {
               if (solvertype == 1) {
                  xtol = 0.0;
               } else {
                  ae_assert(false, "unexpected solver type");
               }
            }
         // Generate "raw" problem: A, b, BndL, BndU, C/CT, XOrigin, XStart.
         // Solve it immediately.
         //
         // NOTE: we make sure that there exists at least one feasible point X0.
            spdmatrixrndcond(n, pow(10.0, 2 * randomreal()), &a);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&xstart, n);
            ae_vector_set_length(&xorigin, n);
            ae_matrix_set_length(&rawc, k, n + 1);
            ae_vector_set_length(&rawct, k);
            for (i = 0; i < n; i++) {
               x0.xR[i] = hqrnduniformr(&rs) - 0.5;
               b.xR[i] = hqrndnormal(&rs);
               bndl.xR[i] = -1 - hqrnduniformr(&rs);
               bndu.xR[i] = 1 + hqrnduniformr(&rs);
               xstart.xR[i] = hqrndnormal(&rs);
               xorigin.xR[i] = hqrndnormal(&rs);
            }
            for (i = 0; i < k; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  rawc.xyR[i][j] = hqrndnormal(&rs);
                  v += rawc.xyR[i][j] * x0.xR[j];
               }
               rawc.xyR[i][n] = v;
               rawct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
               if (rawct.xZ[i] < 0) {
                  rawc.xyR[i][n] += 0.1;
               }
               if (rawct.xZ[i] > 0) {
                  rawc.xyR[i][n] -= 0.1;
               }
            }
            testminqpunit_randomlysplitlc(&rawc, &rawct, k, n, &sparsec, &sparsect, &sparseccnt, &densec, &densect, &denseccnt, &rs);
            minqpcreate(n, &state);
            state.dbgskipconstraintnormalization = true;
            if (solvertype == 0) {
               minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
            } else {
               if (solvertype == 1) {
                  minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
               } else {
                  if (solvertype == 2) {
                     minqpsetalgodenseipm(&state, ipmeps);
                  } else {
                     if (solvertype == 3) {
                        minqpsetalgosparseipm(&state, ipmeps);
                     } else {
                        ae_assert(false, "unexpected solver type");
                     }
                  }
               }
            }
            minqpsetlinearterm(&state, &b);
            testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
            minqpsetstartingpoint(&state, &xstart);
            minqpsetorigin(&state, &xorigin);
            minqpsetbc(&state, &bndl, &bndu);
            minqpsetlcmixed(&state, &sparsec, &sparsect, sparseccnt, &densec, &densect, denseccnt);
            minqpoptimize(&state);
            minqpresults(&state, &x1, &rep);
            if (rep.terminationtype <= 0) {
               set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:4306");
               continue;
            }
         // Scale problem and solve one more time.
         // Randomly choose between dense and sparse versions.
            ae_vector_set_length(&s, n);
            for (i = 0; i < n; i++) {
               s.xR[i] = pow(2.0, (double)(hqrnduniformi(&rs, 7) - 3));
            }
            akind = hqrnduniformi(&rs, 2);
            if (akind == 0) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] /= s.xR[i] * s.xR[j];
                  }
               }
            } else {
               sparsecreate(n, n, 0, &sa);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     sparseset(&sa, i, j, a.xyR[i][j] / (s.xR[i] * s.xR[j]));
                  }
               }
            }
            for (i = 0; i < n; i++) {
               b.xR[i] /= s.xR[i];
               xstart.xR[i] *= s.xR[i];
               xorigin.xR[i] *= s.xR[i];
               bndl.xR[i] *= s.xR[i];
               bndu.xR[i] *= s.xR[i];
            }
            for (i = 0; i < denseccnt; i++) {
               for (j = 0; j < n; j++) {
                  densec.xyR[i][j] /= s.xR[j];
               }
            }
            for (i = 0; i < sparseccnt; i++) {
               for (j = 0; j < n; j++) {
                  sparseset(&sparsec, i, j, sparseget(&sparsec, i, j) / s.xR[j]);
               }
            }
            minqpcreate(n, &state);
            state.dbgskipconstraintnormalization = true;
            if (solvertype == 0) {
               minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
            } else {
               if (solvertype == 1) {
                  minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
               } else {
                  if (solvertype == 2) {
                     minqpsetalgodenseipm(&state, ipmeps);
                  } else {
                     if (solvertype == 3) {
                        minqpsetalgosparseipm(&state, ipmeps);
                     } else {
                        ae_assert(false, "unexpected solver type");
                     }
                  }
               }
            }
            minqpsetlinearterm(&state, &b);
            if (akind == 0) {
               minqpsetquadraticterm(&state, &a, randombool());
            }
            if (akind == 1) {
               minqpsetquadratictermsparse(&state, &sa, randombool());
            }
            minqpsetstartingpoint(&state, &xstart);
            minqpsetorigin(&state, &xorigin);
            minqpsetbc(&state, &bndl, &bndu);
            minqpsetlcmixed(&state, &sparsec, &sparsect, sparseccnt, &densec, &densect, denseccnt);
            minqpsetscale(&state, &s);
            minqpoptimize(&state);
            minqpresults(&state, &x2, &rep);
            if (rep.terminationtype <= 0) {
               set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:4371");
               continue;
            }
         // Compare
            mx = 0.0;
            for (i = 0; i < n; i++) {
               mx = rmax2(mx, fabs(x1.xR[i]));
            }
            mx = rmax2(mx, 1.0);
            for (i = 0; i < n; i++) {
               set_error_flag(errorflag, fabs(x1.xR[i] - x2.xR[i] / s.xR[i]) > xtol * mx, __FILE__, __LINE__, "testminqpunit.ap:4383");
            }
         }
      }
   // General inequality constrained problem:
   // * N*N SPD diagonal A with moderate condtion number
   // * no boundary constraints
   // * K=N inequality constraints C*x >= C*x0, where C is N*N well conditioned
   //   matrix, x0 is some random vector [-1,+1]
   // * optimization problem has form 0.5*x'*A*x-b'*x,
   //   where b is random vector from [-1,+1]
   // * using duality, we can obtain solution of QP problem as follows:
   //   a) intermediate problem min(0.5*y'*B*y + d'*y) s.t. y >= 0
   //      is solved, where B = C*inv(A)*C', d = -(C*inv(A)*b + C*x0)
   //   b) after we got dual solution ys, we calculate primal solution
   //      xs = inv(A)*(C'*ys-b)
      for (n = 1; n <= 6; n++) {
      // Set up tolerances
         xtol = 1.0E-3;
      // Generate problem
         ae_vector_set_length(&da, n);
         ae_matrix_set_length(&a, n, n);
         rmatrixrndcond(n, pow(10.0, 2 * randomreal()), &t2);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&rawc, n, n + 1);
         ae_vector_set_length(&rawct, n);
         for (i = 0; i < n; i++) {
            da.xR[i] = exp(3.0 * randommid());
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = 0.0;
            }
            a.xyR[i][i] = da.xR[i];
         }
         for (i = 0; i < n; i++) {
            x0.xR[i] = randommid();
            b.xR[i] = randommid();
            xstart.xR[i] = randommid();
         }
         for (i = 0; i < n; i++) {
            ae_v_move(rawc.xyR[i], 1, t2.xyR[i], 1, n);
            v = ae_v_dotproduct(rawc.xyR[i], 1, x0.xR, 1, n);
            rawc.xyR[i][n] = v;
            rawct.xZ[i] = 1;
         }
      // Solve primal problem, check feasibility
         minqpcreate(n, &state);
         if (solvertype == 0) {
            minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
         } else {
            if (solvertype == 1) {
               minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
            } else {
               if (solvertype == 2) {
                  minqpsetalgodenseipm(&state, ipmeps);
               } else {
                  if (solvertype == 3) {
                     minqpsetalgosparseipm(&state, ipmeps);
                  } else {
                     ae_assert(false, "unexpected solver type");
                  }
               }
            }
         }
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
         minqpsetstartingpoint(&state, &xstart);
         minqpsetlc(&state, &rawc, &rawct, n);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:4462");
            continue;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(x1.xR, 1, rawc.xyR[i], 1, n);
            set_error_flag(errorflag, v < rawc.xyR[i][n] - xtol, __FILE__, __LINE__, "testminqpunit.ap:4468");
         }
      // Generate dual problem:
      // * A2 stores new quadratic term
      // * B2 stores new linear term
      // * BndL/BndU store boundary constraints
         ae_matrix_set_length(&t3, n, n);
         ae_matrix_set_length(&a2, n, n);
         rmatrixtranspose(n, n, &rawc, 0, 0, &t3, 0, 0);
         for (i = 0; i < n; i++) {
            v = 1 / sqrt(da.xR[i]);
            ae_v_muld(t3.xyR[i], 1, n, v);
         }
         rmatrixsyrk(n, n, 1.0, &t3, 0, 0, 2, 0.0, &a2, 0, 0, true);
         ae_vector_set_length(&tmp0, n);
         ae_v_move(tmp0.xR, 1, b.xR, 1, n);
         for (i = 0; i < n; i++) {
            tmp0.xR[i] /= da.xR[i];
         }
         ae_vector_set_length(&b2, n);
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(rawc.xyR[i], 1, tmp0.xR, 1, n);
            b2.xR[i] = -(v + rawc.xyR[i][n]);
         }
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            bndl.xR[i] = 0.0;
            bndu.xR[i] = +INFINITY;
         }
         minqpcreate(n, &state2);
         minqpsetalgoquickqp(&state2, 0.0, 0.0, 1.0E-9, 0, true);
         minqpsetlinearterm(&state2, &b2);
         minqpsetquadraticterm(&state2, &a2, true);
         minqpsetbc(&state2, &bndl, &bndu);
         minqpoptimize(&state2);
         minqpresults(&state2, &x2, &rep2);
         if (rep2.terminationtype <= 0) {
            set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:4523");
            continue;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(&rawc.xyR[0][i], rawc.stride, x2.xR, 1, n);
            tmp0.xR[i] = v - b.xR[i];
         }
         for (i = 0; i < n; i++) {
            tmp0.xR[i] /= da.xR[i];
         }
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, fabs(tmp0.xR[i] - x1.xR[i]) > xtol * rmax2(fabs(tmp0.xR[i]), 1.0), __FILE__, __LINE__, "testminqpunit.ap:4536");
         }
      }
   // Boundary and linear equality/inequality constrained QP problem with
   // excessive constraints:
   // * N*N SPD A with moderate condtion number (up to 100)
   // * boundary constraints 0 <= x[i] <= 1
   // * K=2*N equality/inequality constraints Q*x = Q*x0, where Q is random matrix,
   //   x0 is some random vector from the feasible hypercube (0.1 <= x0[i] <= 0.9)
   // * optimization problem has form 0.5*x'*A*x-b*x,
   //   where b is some random vector
   // * because constraints are excessive, the main problem is to find
   //   feasible point; usually, the only existing feasible point is solution,
   //   so we have to check only feasibility
      for (n = 1; n <= 6; n++) {
      // Set up tolerances
         if (solvertype == 0) {
            xtol = 1.0E-5;
         } else {
            if ((solvertype == 1 || solvertype == 2) || solvertype == 3) {
               xtol = 5.0E-3;
            } else {
               ae_assert(false, "unexpected solver type");
            }
         }
      // Generate problem: A, b, BndL, BndU, CMatrix, x0, x1, XStart
         k = 2 * n;
         spdmatrixrndcond(n, pow(10.0, 3 * randomreal()), &a);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&x1, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&rawc, k, n + 1);
         ae_vector_set_length(&rawct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 0.1 + 0.8 * randomreal();
            x1.xR[i] = randommid();
            bndl.xR[i] = 0.0;
            bndu.xR[i] = 1.0;
            xstart.xR[i] = (double)randominteger(2);
         }
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               rawc.xyR[i][j] = randommid();
            }
            v = ae_v_dotproduct(rawc.xyR[i], 1, x0.xR, 1, n);
            rawct.xZ[i] = randominteger(3) - 1;
            if (rawct.xZ[i] == 0) {
               rawc.xyR[i][n] = v;
            }
            if (rawct.xZ[i] > 0) {
               rawc.xyR[i][n] = v - 50 * xtol;
            }
            if (rawct.xZ[i] < 0) {
               rawc.xyR[i][n] = v + 50 * xtol;
            }
         }
         for (i = 0; i < n; i++) {
            b.xR[i] = randommid();
         }
      // Create optimizer, solve
         minqpcreate(n, &state);
         if (solvertype == 0) {
            minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
         } else {
            if (solvertype == 1) {
               minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
            } else {
               if (solvertype == 2) {
                  minqpsetalgodenseipm(&state, ipmeps);
               } else {
                  if (solvertype == 3) {
                     minqpsetalgosparseipm(&state, ipmeps);
                  } else {
                     ae_assert(false, "unexpected solver type");
                  }
               }
            }
         }
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
         minqpsetstartingpoint(&state, &xstart);
         minqpsetbc(&state, &bndl, &bndu);
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, k, n, &state, &rs);
         minqpoptimize(&state);
         ae_vector_set_length(&x1, 0);
         minqpresults(&state, &x1, &rep);
      // Check feasibility properties of the solution
      //
      // NOTE: we do not check termination type because some solvers (IPM) may return feasible X even with negative code
         if (x1.cnt != n) {
            set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:4637");
            continue;
         }
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(x1.xR, 1, rawc.xyR[i], 1, n);
            if (rawct.xZ[i] == 0) {
               set_error_flag(errorflag, fabs(v - rawc.xyR[i][n]) > xtol, __FILE__, __LINE__, "testminqpunit.ap:4644");
            }
            if (rawct.xZ[i] > 0) {
               set_error_flag(errorflag, v < rawc.xyR[i][n] - xtol, __FILE__, __LINE__, "testminqpunit.ap:4646");
            }
            if (rawct.xZ[i] < 0) {
               set_error_flag(errorflag, v > rawc.xyR[i][n] + xtol, __FILE__, __LINE__, "testminqpunit.ap:4648");
            }
         }
      }
   // Boundary constraints posed as general linear ones:
   // * no bound constraints
   // * 2*N linear constraints 0 <= x[i] <= 1
   // * F(x) = |x-x0|^P, where P={2,4} and x0 is randomly selected from [-1,+2]^N
   // * with such simple constraints and function it is easy to find
   //   analytic form of solution: S[i] = bound(x0[i], 0, 1).
   // * however, we can't guarantee that solution is strictly feasible
   //   with respect to nonlinearity constraint, so we check
   //   for approximate feasibility.
      for (n = 1; n <= 5; n++) {
      // Set up tolerances
         if (solvertype == 0) {
            xtol = 1.0E-3;
         } else {
            if ((solvertype == 1 || solvertype == 2) || solvertype == 3) {
               xtol = 1.0E-3;
            } else {
               ae_assert(false, "unexpected solver type");
            }
         }
      // Generate X, BL, BU.
         ae_matrix_set_length(&a, n, n);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xstart, n);
         ae_vector_set_length(&x0, n);
         ae_matrix_set_length(&rawc, 2 * n, n + 1);
         ae_vector_set_length(&rawct, 2 * n);
         k = 2 * n;
         for (i = 0; i < n; i++) {
            xstart.xR[i] = randomreal();
            x0.xR[i] = 3.0 * randomreal() - 1.0;
            b.xR[i] = -x0.xR[i];
            for (j = 0; j <= n; j++) {
               rawc.xyR[2 * i + 0][j] = 0.0;
               rawc.xyR[2 * i + 1][j] = 0.0;
            }
            rawc.xyR[2 * i + 0][i] = 1.0;
            rawc.xyR[2 * i + 0][n] = 0.0;
            rawct.xZ[2 * i + 0] = 1;
            rawc.xyR[2 * i + 1][i] = 1.0;
            rawc.xyR[2 * i + 1][n] = 1.0;
            rawct.xZ[2 * i + 1] = -1;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               if (i == j) {
                  a.xyR[i][j] = 1.0;
               } else {
                  a.xyR[i][j] = 0.0;
               }
            }
         }
      // Create and optimize
         minqpcreate(n, &state);
         if (solvertype == 0) {
            minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
         } else {
            if (solvertype == 1) {
               minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
            } else {
               if (solvertype == 2) {
                  minqpsetalgodenseipm(&state, ipmeps);
               } else {
                  if (solvertype == 3) {
                     minqpsetalgosparseipm(&state, ipmeps);
                  } else {
                     ae_assert(false, "unexpected solver type");
                  }
               }
            }
         }
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, k, n, &state, &rs);
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
         minqpsetstartingpoint(&state, &xstart);
         minqpoptimize(&state);
         minqpresults(&state, &x1, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:4735");
            continue;
         }
      // * compare solution with analytic one
      // * check feasibility
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, fabs(x1.xR[i] - rboundval(x0.xR[i], 0.0, 1.0)) > xtol, __FILE__, __LINE__, "testminqpunit.ap:4745");
            set_error_flag(errorflag, x1.xR[i] < 0.0 - xtol, __FILE__, __LINE__, "testminqpunit.ap:4746");
            set_error_flag(errorflag, x1.xR[i] > 1.0 + xtol, __FILE__, __LINE__, "testminqpunit.ap:4747");
         }
      }
   // Convex optimization problem with excessive constraints:
   //
   // * N=2..5
   // * f = 0.5*x'*A*x+b'*x
   // * b has normally distributed entries
   // * A is diagonal with log-normally distributed entries
   // * box constraints: x[i] in [-1,+1]
   // * 2^N "excessive" general linear constraints (v_k,x) <= (v_k,v_k)+v_shift,
   //   where v_k is one of 2^N vertices of feasible hypercube, v_shift is
   //   a shift parameter:
   //   * with zero v_shift such constraints are degenerate (each vertex has
   //     N box constraints and one "redundant" linear constraint)
   //   * with positive v_shift linear constraint is always inactive
   //   * with small (about machine epsilon) but negative v_shift,
   //     constraint is close to degenerate - but not exactly
   //
   // Because A is diagonal, we can easily find out solution analytically.
   //
   // NOTE: TolConstr must be large enough so it won't conflict with
   //       perturbation introduced by v_shift
      for (n = 2; n <= 5; n++) {
         for (shiftkind = -5; shiftkind <= 1; shiftkind++) {
         // Set up tolerances
            if (solvertype == 0) {
               tolconstr = 1.0E-6;
               gtol = 1.0E-6;
            } else {
               if ((solvertype == 1 || solvertype == 2) || solvertype == 3) {
                  tolconstr = 1.0E-4;
                  gtol = 1.0E-4;
               } else {
                  ae_assert(false, "unexpected solver type");
               }
            }
         // Generate A, B and initial point
            ae_matrix_set_length(&a, n, n);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&xstart, n);
            for (i = 0; i < n; i++) {
               b.xR[i] = hqrndnormal(&rs);
               xstart.xR[i] = hqrnduniformr(&rs) - 0.5;
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
               a.xyR[i][i] = pow(2.0, hqrndnormal(&rs));
            }
         // Generate constraints
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            for (i = 0; i < n; i++) {
               bndl.xR[i] = -1.0;
               bndu.xR[i] = 1.0;
            }
            rawccnt = iround(pow(2.0, (double)n));
            ae_matrix_set_length(&rawc, rawccnt, n + 1);
            ae_vector_set_length(&rawct, rawccnt);
            for (i = 0; i < rawccnt; i++) {
               rawct.xZ[i] = -1;
               k = i;
               rawc.xyR[i][n] = sign((double)shiftkind) * pow(10.0, fabs((double)shiftkind)) * machineepsilon;
               for (j = 0; j < n; j++) {
                  rawc.xyR[i][j] = (double)(2 * (k % 2) - 1);
                  rawc.xyR[i][n] += rawc.xyR[i][j] * rawc.xyR[i][j];
                  k /= 2;
               }
            }
         // Create and optimize
            minqpcreate(n, &state);
            minqpsetstartingpoint(&state, &xstart);
            if (solvertype == 0) {
               minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
            } else {
               if (solvertype == 1) {
                  minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
               } else {
                  if (solvertype == 2) {
                     minqpsetalgodenseipm(&state, ipmeps);
                  } else {
                     if (solvertype == 3) {
                        minqpsetalgosparseipm(&state, ipmeps);
                     } else {
                        ae_assert(false, "unexpected solver type");
                     }
                  }
               }
            }
            minqpsetbc(&state, &bndl, &bndu);
            testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
            minqpsetlinearterm(&state, &b);
            testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
            minqpoptimize(&state);
            minqpresults(&state, &x1, &rep);
            set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:4858");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
         // Evaluate gradient at solution and test
            vv = 0.0;
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, x1.xR, 1, n);
               v += b.xR[i];
               if (x1.xR[i] <= bndl.xR[i] + tolconstr && v > 0.0) {
                  v = 0.0;
               }
               if (x1.xR[i] >= bndu.xR[i] - tolconstr && v < 0.0) {
                  v = 0.0;
               }
               vv += sqr(v);
            }
            vv = sqrt(vv);
            set_error_flag(errorflag, vv > gtol, __FILE__, __LINE__, "testminqpunit.ap:4882");
         }
      }
   // Convex optimization problem with known answer (we generate constraints
   // and Lagrange coefficients, and then generate quadratic and linear term
   // which satisfy KKT conditions for given Lagrange coefficients):
   //
   // * N=2..8
   // * f = 0.5*x'*A*x+b'*x
   // * several kinds of A are tried: zero, well conditioned SPD, low rank
   // * initial point x0 = [0 0 ... 0 0]
   // * absent bounds can be set to +-INF or to some huge number (randomly)
   // * first, we generate set of linear constraints (without bounds),
   //   solution point X and Lagrange multipliers for linear and box constraints
   // * then we determine bounds on variables and linear constraints which
   //   align with values/signs of Lagrange multipliers
   // * then, having quadratic term A and known constraints and Lagrange
   //   multipliers we determine linear term B which makes KKT conditions true
      for (n = 1; n <= 8; n++) {
         for (akind = 0; akind <= 2; akind++) {
         // Select number used for absent bounds:
         // * +- INF
         // * 1e9
         // * 1e11
            i = hqrnduniformi(&rs, 3);
            minushuge = -INFINITY;
            plushuge = +INFINITY;
            if (i == 1) {
               minushuge = -1.0E9;
               plushuge = 1.0E9;
            }
            if (i == 2) {
               minushuge = -1.0E11;
               plushuge = 1.0E11;
            }
         // Generate quadratic term A, origin and scale
            ae_matrix_set_length(&a, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
            }
            issemidefinite = true;
            if (akind == 1) {
            // Dense well conditioned SPD
               spdmatrixrndcond(n, 50.0, &a);
               issemidefinite = false;
            }
            if (akind == 2) {
            // Low rank semidefinite
               ae_vector_set_length(&tmp, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               for (k = 1; k < imin2(4, n); k++) {
                  for (i = 0; i < n; i++) {
                     tmp.xR[i] = hqrndnormal(&rs);
                  }
                  v = pow(2.0, hqrndnormal(&rs));
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                     }
                  }
               }
               issemidefinite = true;
            }
            ae_vector_set_length(&s, n);
            ae_vector_set_length(&xorigin, n);
            for (j = 0; j < n; j++) {
               xorigin.xR[j] = hqrndnormal(&rs);
               s.xR[j] = pow(2.0, hqrndnormal(&rs));
            }
         // Generate linear constraints (left parts)
            rawccnt = hqrnduniformi(&rs, 2 * n + 1);
            ae_matrix_set_length(&rawc, rawccnt, n);
            for (i = 0; i < rawccnt; i++) {
               for (j = 0; j < n; j++) {
                  rawc.xyR[i][j] = 0.0;
               }
               nnz = hqrnduniformi(&rs, n + 1);
               for (k = 0; k < nnz; k++) {
                  j = hqrnduniformi(&rs, n);
                  v = hqrndnormal(&rs);
                  v += 0.1 * possign(v);
                  rawc.xyR[i][j] = v;
               }
            }
         // Generate Lagrange multipliers, with at most NActive<N being non-zero
            ae_vector_set_length(&lagbc, n);
            ae_vector_set_length(&laglc, rawccnt);
            for (i = 0; i < n; i++) {
               lagbc.xR[i] = 0.0;
            }
            for (i = 0; i < rawccnt; i++) {
               laglc.xR[i] = 0.0;
            }
            nactive = hqrnduniformi(&rs, n);
            k = hqrnduniformi(&rs, imin2(nactive, rawccnt) + 1);
            for (i = 0; i < k; i++) {
               laglc.xR[hqrnduniformi(&rs, rawccnt)] = hqrndnormal(&rs);
            }
            for (i = k; i < nactive; i++) {
               lagbc.xR[hqrnduniformi(&rs, n)] = hqrndnormal(&rs);
            }
         // Generate solution and gradient at the solution, set B to -G
            ae_vector_set_length(&xf, n);
            for (i = 0; i < n; i++) {
               xf.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&g, n);
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += a.xyR[i][j] * (xf.xR[j] - xorigin.xR[j]);
               }
               g.xR[i] = v;
            }
            for (i = 0; i < n; i++) {
               g.xR[i] += lagbc.xR[i];
            }
            for (i = 0; i < rawccnt; i++) {
               for (j = 0; j < n; j++) {
                  g.xR[j] += laglc.xR[i] * rawc.xyR[i][j];
               }
            }
            ae_vector_set_length(&b, n);
            for (j = 0; j < n; j++) {
               b.xR[j] = -g.xR[j];
            }
         // Set up bounds according to Lagrange multipliers
         //
         // NOTE: for semidefinite problems we set all variable bounds
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            for (j = 0; j < n; j++) {
               bndl.xR[j] = minushuge;
               bndu.xR[j] = plushuge;
               if (hqrndnormal(&rs) > 0.0 || issemidefinite) {
                  bndl.xR[j] = xf.xR[j] - pow(2.0, hqrndnormal(&rs));
               }
               if (hqrndnormal(&rs) > 0.0 || issemidefinite) {
                  bndu.xR[j] = xf.xR[j] + pow(2.0, hqrndnormal(&rs));
               }
               if (lagbc.xR[j] != 0.0) {
                  if (hqrnduniformr(&rs) < 0.15) {
                     bndl.xR[j] = xf.xR[j];
                     bndu.xR[j] = xf.xR[j];
                  } else {
                     if (lagbc.xR[j] < 0.0) {
                        bndl.xR[j] = xf.xR[j];
                     }
                     if (lagbc.xR[j] > 0.0) {
                        bndu.xR[j] = xf.xR[j];
                     }
                  }
               }
            }
            ae_vector_set_length(&rawcl, rawccnt);
            ae_vector_set_length(&rawcu, rawccnt);
            for (i = 0; i < rawccnt; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += rawc.xyR[i][j] * xf.xR[j];
               }
               rawcl.xR[i] = minushuge;
               rawcu.xR[i] = plushuge;
               if (hqrndnormal(&rs) > 0.0) {
                  rawcl.xR[i] = v - pow(2.0, hqrndnormal(&rs));
               }
               if (hqrndnormal(&rs) > 0.0) {
                  rawcu.xR[i] = v + pow(2.0, hqrndnormal(&rs));
               }
               if (laglc.xR[i] != 0.0) {
                  if (hqrnduniformr(&rs) < 0.15) {
                  // Active equality constraint
                     rawcl.xR[i] = v;
                     rawcu.xR[i] = v;
                  } else {
                  // Active inequality constraint
                     if (laglc.xR[i] < 0.0) {
                        rawcl.xR[i] = v;
                     }
                     if (laglc.xR[i] > 0.0) {
                        rawcu.xR[i] = v;
                     }
                  }
               }
               if ((!isfinite(rawcl.xR[i]) || rawcl.xR[i] == minushuge) && (!isfinite(rawcu.xR[i]) || rawcu.xR[i] == plushuge)) {
               // At least one bound must be present for linear constraint
                  if (hqrndnormal(&rs) > 0.0) {
                     rawcl.xR[i] = v - 10;
                  } else {
                     rawcu.xR[i] = v + 10;
                  }
               }
            }
         // Completely skip some solvers depending on their properties:
         // * Dense-AUL solver has lower precision on rank-deficient
         //   problems, so we skip AKind=0 and AKind=2.
         // * BLEIC solver is always skipped
            if (solvertype == 1 && akind != 1) {
               continue;
            }
            if (solvertype == 0) {
               continue;
            }
         // Solve
            minqpcreate(n, &state);
            if (solvertype == 0) {
               minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
            } else {
               if (solvertype == 1) {
                  minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
               } else {
                  if (solvertype == 2) {
                     minqpsetalgodenseipm(&state, ipmeps);
                  } else {
                     if (solvertype == 3) {
                        minqpsetalgosparseipm(&state, ipmeps);
                     } else {
                        ae_assert(false, "unexpected solver type");
                     }
                  }
               }
            }
            minqpsetbc(&state, &bndl, &bndu);
            testminqpunit_randomlysplitandsetlc2(&rawc, &rawcl, &rawcu, rawccnt, n, &state, &rs);
            minqpsetlinearterm(&state, &b);
            testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
            minqpsetscale(&state, &s);
            minqpsetorigin(&state, &xorigin);
            minqpoptimize(&state);
            minqpresults(&state, &x1, &rep);
            set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:5138");
            set_error_flag(errorflag, x1.cnt < n, __FILE__, __LINE__, "testminqpunit.ap:5139");
            set_error_flag(errorflag, rep.lagbc.cnt < n, __FILE__, __LINE__, "testminqpunit.ap:5140");
            set_error_flag(errorflag, rep.laglc.cnt < rawccnt, __FILE__, __LINE__, "testminqpunit.ap:5141");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
         // Test function value at the solution
            f0 = testminqpunit_quadratictarget(&a, &b, n, &x1);
            f1 = testminqpunit_quadratictarget(&a, &b, n, &xf);
            set_error_flag(errorflag, fabs(f0 - f1) > rmax3(fabs(f0), fabs(f1), 1.0) * 1.0E-3, __FILE__, __LINE__, "testminqpunit.ap:5150");
         // Test Lagrange multipliers returned by the solver; test is skipped:
         // * for BLEIC solver
         // * for overconstrained DENSE-AUL
            skiptest = false;
            skiptest = skiptest || solvertype == 0;
            skiptest = skiptest || (solvertype == 1 && (double)nactive > 0.5 * (n - 1));
            if (!skiptest) {
               ae_vector_set_length(&gtrial, n);
               for (i = 0; i < n; i++) {
                  v = b.xR[i];
                  for (j = 0; j < n; j++) {
                     v += a.xyR[i][j] * (x1.xR[j] - xorigin.xR[j]);
                  }
                  gtrial.xR[i] = v;
               }
               for (i = 0; i < n; i++) {
                  gtrial.xR[i] += rep.lagbc.xR[i];
               }
               for (i = 0; i < rawccnt; i++) {
                  for (j = 0; j < n; j++) {
                     gtrial.xR[j] += rep.laglc.xR[i] * rawc.xyR[i][j];
                  }
               }
               for (i = 0; i < n; i++) {
                  set_error_flag(errorflag, fabs(gtrial.xR[i]) > 1.0E-3, __FILE__, __LINE__, "testminqpunit.ap:5176");
               }
            }
         }
      }
   }
// Large-scale tests: a few selected tests for large N's
   for (solvertype = 0; solvertype <= 3; solvertype++) {
   // General equality constrained problem:
   // * N*N SPD (non-diagonal) A with moderate condition number
   // * no box constraints
   // * K<N equality constraints C*x = C*x0, where C is K*N well conditioned
   //   matrix, x0 is some random vector [-1,+1]
   // * optimization problem has form 0.5*x'*A*x-b'*x,
   //   where b is random vector from [-1,+1]
   // * true solution of QP problem is obtained with KKT matrix;
   //   we compare value returned by solver against one calculated
   //   via KKT conditions.
      n = 60;
      rawccnt = 40;
      if (solvertype == 0) {
         xtol = 1.0E-3;
      } else {
         if ((solvertype == 1 || solvertype == 2) || solvertype == 3) {
            xtol = 1.0E-3;
         } else {
            ae_assert(false, "unexpected solver type");
         }
      }
      spdmatrixrndcond(n, pow(10.0, 2 * randomreal()), &a);
      rmatrixrndcond(n, pow(10.0, 2 * randomreal()), &t2);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&xstart, n);
      ae_matrix_set_length(&rawc, rawccnt, n + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         b.xR[i] = randommid();
         xstart.xR[i] = randommid();
      }
      for (i = 0; i < rawccnt; i++) {
         ae_v_move(rawc.xyR[i], 1, t2.xyR[i], 1, n);
         v = ae_v_dotproduct(rawc.xyR[i], 1, x0.xR, 1, n);
         rawc.xyR[i][n] = v;
         rawct.xZ[i] = 0;
      }
      minqpcreate(n, &state);
      if (solvertype == 0) {
         minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
      } else {
         if (solvertype == 1) {
            minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
         } else {
            if (solvertype == 2) {
               minqpsetalgodenseipm(&state, ipmeps);
            } else {
               if (solvertype == 3) {
                  minqpsetalgosparseipm(&state, ipmeps);
               } else {
                  ae_assert(false, "unexpected solver type");
               }
            }
         }
      }
      minqpsetlinearterm(&state, &b);
      testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
      minqpsetstartingpoint(&state, &xstart);
      testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
      minqpoptimize(&state);
      minqpresults(&state, &x1, &rep);
      if (rep.terminationtype <= 0) {
         set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:5255");
         continue;
      }
      for (i = 0; i < rawccnt; i++) {
         v = ae_v_dotproduct(x1.xR, 1, rawc.xyR[i], 1, n);
         set_error_flag(errorflag, v < rawc.xyR[i][n] - xtol, __FILE__, __LINE__, "testminqpunit.ap:5261");
      }
      ae_matrix_set_length(&kkt, n + rawccnt, n + rawccnt);
      ae_vector_set_length(&kktright, n + rawccnt);
      for (i = 0; i < n + rawccnt; i++) {
         for (j = 0; j < n + rawccnt; j++) {
            kkt.xyR[i][j] = 0.0;
         }
      }
      rmatrixcopy(n, n, &a, 0, 0, &kkt, 0, 0);
      rmatrixcopy(rawccnt, n, &rawc, 0, 0, &kkt, n, 0);
      rmatrixtranspose(rawccnt, n, &rawc, 0, 0, &kkt, 0, n);
      for (i = 0; i < n; i++) {
         kktright.xR[i] = -b.xR[i];
      }
      for (i = 0; i < rawccnt; i++) {
         kktright.xR[n + i] = rawc.xyR[i][n];
      }
      fblssolvels(&kkt, &kktright, n + rawccnt, n + rawccnt, &tmp0, &tmp1, &tmp2);
      for (i = 0; i < n; i++) {
         set_error_flag(errorflag, fabs(kktright.xR[i] - x1.xR[i]) > xtol * rmax2(fabs(kktright.xR[i]), 1.0), __FILE__, __LINE__, "testminqpunit.ap:5280");
      }
   // General inequality constrained problem:
   // * N*N SPD diagonal A with moderate condtion number
   // * no box constraints
   // * K<N inequality constraints C*x >= C*x0, where C is N*N well conditioned
   //   matrix, x0 is some random vector [-1,+1]
   // * optimization problem has form 0.5*x'*A*x-b'*x,
   //   where b is random vector from [-1,+1]
   // * using duality, we can obtain solution of QP problem as follows:
   //   a) intermediate problem min(0.5*y'*B*y + d'*y) s.t. y >= 0
   //      is solved, where B = C*inv(A)*C', d = -(C*inv(A)*b + C*x0)
   //   b) after we got dual solution ys, we calculate primal solution
   //      xs = inv(A)*(C'*ys-b)
      n = 60;
      rawccnt = 40;
      if (solvertype == 0) {
         xtol = 1.0E-3;
      } else {
         if ((solvertype == 1 || solvertype == 2) || solvertype == 3) {
            xtol = 1.0E-3;
         } else {
            ae_assert(false, "unexpected solver type");
         }
      }
      ae_vector_set_length(&da, n);
      ae_matrix_set_length(&a, n, n);
      rmatrixrndcond(n, pow(10.0, 2 * randomreal()), &t2);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&xstart, n);
      ae_matrix_set_length(&rawc, rawccnt, n + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < n; i++) {
         da.xR[i] = exp(4.0 * randommid());
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = 0.0;
         }
         a.xyR[i][i] = da.xR[i];
      }
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         b.xR[i] = randommid();
         xstart.xR[i] = randommid();
      }
      for (i = 0; i < rawccnt; i++) {
         ae_v_move(rawc.xyR[i], 1, t2.xyR[i], 1, n);
         v = ae_v_dotproduct(rawc.xyR[i], 1, x0.xR, 1, n);
         rawc.xyR[i][n] = v;
         rawct.xZ[i] = 1;
      }
      minqpcreate(n, &state);
      if (solvertype == 0) {
         minqpsetalgobleic(&state, 0.0, 0.0, bleicepsx, 0);
      } else {
         if (solvertype == 1) {
            minqpsetalgodenseaul(&state, aulepsx, aulrho, aulits);
         } else {
            if (solvertype == 2) {
               minqpsetalgodenseipm(&state, ipmeps);
            } else {
               if (solvertype == 3) {
                  minqpsetalgosparseipm(&state, ipmeps);
               } else {
                  ae_assert(false, "unexpected solver type");
               }
            }
         }
      }
      minqpsetlinearterm(&state, &b);
      testminqpunit_randomlyselectconvertandsetquadraticterm(&a, n, &state, &rs);
      minqpsetstartingpoint(&state, &xstart);
      testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
      minqpoptimize(&state);
      minqpresults(&state, &x1, &rep);
      if (rep.terminationtype <= 0) {
         set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:5362");
         continue;
      }
      for (i = 0; i < rawccnt; i++) {
         v = ae_v_dotproduct(x1.xR, 1, rawc.xyR[i], 1, n);
         set_error_flag(errorflag, v < rawc.xyR[i][n] - xtol, __FILE__, __LINE__, "testminqpunit.ap:5368");
      }
      ae_matrix_set_length(&t3, n, rawccnt);
      ae_matrix_set_length(&a2, rawccnt, rawccnt);
      rmatrixtranspose(rawccnt, n, &rawc, 0, 0, &t3, 0, 0);
      for (i = 0; i < n; i++) {
         v = 1 / sqrt(da.xR[i]);
         ae_v_muld(t3.xyR[i], 1, rawccnt, v);
      }
      rmatrixsyrk(rawccnt, n, 1.0, &t3, 0, 0, 2, 0.0, &a2, 0, 0, true);
      ae_vector_set_length(&tmp0, n);
      ae_v_move(tmp0.xR, 1, b.xR, 1, n);
      for (i = 0; i < n; i++) {
         tmp0.xR[i] /= da.xR[i];
      }
      ae_vector_set_length(&b2, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         v = ae_v_dotproduct(rawc.xyR[i], 1, tmp0.xR, 1, n);
         b2.xR[i] = -(v + rawc.xyR[i][n]);
      }
      ae_vector_set_length(&bndl, rawccnt);
      ae_vector_set_length(&bndu, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         bndl.xR[i] = 0.0;
         bndu.xR[i] = +INFINITY;
      }
      minqpcreate(rawccnt, &state2);
      minqpsetalgoquickqp(&state2, 0.0, 0.0, 1.0E-9, 0, true);
      minqpsetlinearterm(&state2, &b2);
      minqpsetquadraticterm(&state2, &a2, true);
      minqpsetbc(&state2, &bndl, &bndu);
      minqpoptimize(&state2);
      minqpresults(&state2, &x2, &rep2);
      if (rep2.terminationtype <= 0) {
         set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:5421");
         continue;
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(&rawc.xyR[0][i], rawc.stride, x2.xR, 1, rawccnt);
         tmp0.xR[i] = v - b.xR[i];
      }
      for (i = 0; i < n; i++) {
         tmp0.xR[i] /= da.xR[i];
      }
      for (i = 0; i < n; i++) {
         set_error_flag(errorflag, fabs(tmp0.xR[i] - x1.xR[i]) > xtol * rmax2(fabs(tmp0.xR[i]), 1.0), __FILE__, __LINE__, "testminqpunit.ap:5434");
      }
   }
   ae_frame_leave();
}

// This function tests special inequality constrained QP problems.
//
// Returns True on errors.
static bool testminqpunit_specialicqptests() {
   ae_frame _frame_block;
   bool waserrors;
   ae_int_t i;
   ae_int_t j;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(xstart, 0, DT_REAL);
   NewVector(xend, 0, DT_REAL);
   NewVector(xexact, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   waserrors = false;
// Test 1: reported by Vanderlande Industries.
//         Tests algorithm ability to handle degenerate constraints.
   ae_matrix_set_length(&a, 3, 3);
   for (i = 0; i <= 2; i++) {
      for (j = 0; j <= 2; j++) {
         a.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i <= 2; i++) {
      a.xyR[i][i] = 1.0;
   }
   ae_vector_set_length(&b, 3);
   b.xR[0] = -50.0;
   b.xR[1] = -50.0;
   b.xR[2] = -75.0;
   ae_vector_set_length(&bndl, 3);
   bndl.xR[0] = 0.0;
   bndl.xR[1] = 0.0;
   bndl.xR[2] = 0.0;
   ae_vector_set_length(&bndu, 3);
   bndu.xR[0] = 100.0;
   bndu.xR[1] = 100.0;
   bndu.xR[2] = 150.0;
   ae_vector_set_length(&xstart, 3);
   xstart.xR[0] = 0.0;
   xstart.xR[1] = 100.0;
   xstart.xR[2] = 0.0;
   ae_vector_set_length(&xexact, 3);
   xexact.xR[0] = 0.0;
   xexact.xR[1] = 100.0;
   xexact.xR[2] = 50.0;
   ae_matrix_set_length(&c, 3, 4);
   c.xyR[0][0] = 1.0;
   c.xyR[0][1] = -1.0;
   c.xyR[0][2] = 0.0;
   c.xyR[0][3] = -100.0;
   c.xyR[1][0] = 1.0;
   c.xyR[1][1] = 0.0;
   c.xyR[1][2] = -1.0;
   c.xyR[1][3] = 0.0;
   c.xyR[2][0] = -1.0;
   c.xyR[2][1] = 0.0;
   c.xyR[2][2] = 1.0;
   c.xyR[2][3] = 50.0;
   ae_vector_set_length(&ct, 3);
   ct.xZ[0] = -1;
   ct.xZ[1] = -1;
   ct.xZ[2] = -1;
   minqpcreate(3, &state);
   testminqpunit_setrandomalgoconvexlc(&state);
   minqpsetlinearterm(&state, &b);
   minqpsetquadraticterm(&state, &a, true);
   minqpsetstartingpoint(&state, &xstart);
   minqpsetbc(&state, &bndl, &bndu);
   minqpsetlc(&state, &c, &ct, 3);
   minqpoptimize(&state);
   minqpresults(&state, &xend, &rep);
   if (rep.terminationtype > 0) {
      for (i = 0; i <= 2; i++) {
         waserrors = waserrors || fabs(xend.xR[i] - xexact.xR[i]) > 1.0E6 * machineepsilon;
      }
   } else {
      waserrors = true;
   }
// Test 2: reported by Vanderlande Industries.
//         Tests algorithm ability to handle degenerate constraints.
   ae_matrix_set_length(&a, 3, 3);
   for (i = 0; i <= 2; i++) {
      for (j = 0; j <= 2; j++) {
         a.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i <= 2; i++) {
      a.xyR[i][i] = 1.0;
   }
   ae_vector_set_length(&b, 3);
   b.xR[0] = -50.0;
   b.xR[1] = -50.0;
   b.xR[2] = -75.0;
   ae_vector_set_length(&bndl, 3);
   bndl.xR[0] = 0.0;
   bndl.xR[1] = 0.0;
   bndl.xR[2] = 0.0;
   ae_vector_set_length(&bndu, 3);
   bndu.xR[0] = 100.0;
   bndu.xR[1] = 100.0;
   bndu.xR[2] = 150.0;
   ae_vector_set_length(&xstart, 3);
   xstart.xR[0] = 0.0;
   xstart.xR[1] = 100.0;
   xstart.xR[2] = 150.0;
   ae_vector_set_length(&xexact, 3);
   xexact.xR[0] = 0.0;
   xexact.xR[1] = 100.0;
   xexact.xR[2] = 100.0;
   ae_matrix_set_length(&c, 3, 4);
   c.xyR[0][0] = 1.0;
   c.xyR[0][1] = -1.0;
   c.xyR[0][2] = 0.0;
   c.xyR[0][3] = -100.0;
   c.xyR[1][0] = 0.0;
   c.xyR[1][1] = 1.0;
   c.xyR[1][2] = -1.0;
   c.xyR[1][3] = 0.0;
   c.xyR[2][0] = 0.0;
   c.xyR[2][1] = -1.0;
   c.xyR[2][2] = 1.0;
   c.xyR[2][3] = 50.0;
   ae_vector_set_length(&ct, 3);
   ct.xZ[0] = -1;
   ct.xZ[1] = -1;
   ct.xZ[2] = -1;
   minqpcreate(3, &state);
   testminqpunit_setrandomalgoconvexlc(&state);
   minqpsetlinearterm(&state, &b);
   minqpsetquadraticterm(&state, &a, true);
   minqpsetstartingpoint(&state, &xstart);
   minqpsetbc(&state, &bndl, &bndu);
   minqpsetlc(&state, &c, &ct, 3);
   minqpoptimize(&state);
   minqpresults(&state, &xend, &rep);
   if (rep.terminationtype > 0) {
      for (i = 0; i <= 2; i++) {
         waserrors = waserrors || fabs(xend.xR[i] - xexact.xR[i]) > 1.0E6 * machineepsilon;
      }
   } else {
      waserrors = true;
   }
   result = waserrors;
   ae_frame_leave();
   return result;
}

// This function tests linearly constrained DENSE-AUL solver
//
// On failure sets Err to True; on success leaves it unchanged.
static void testminqpunit_denseaultests(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   ae_int_t scaletype;
   ae_int_t rawccnt;
   double epsx;
   double xtol;
   double rho;
   ae_int_t outerits;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(rawa, 0, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(rawc, 0, 0, DT_REAL);
   NewVector(rawct, 0, DT_INT);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(xf, 0, DT_REAL);
   NewVector(r, 0, DT_REAL);
   NewVector(xsol, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   NewObj(densesolverreport, svrep);
   hqrndrandomize(&rs);
// Test that unconstrained problem is solved with high precision,
// independently of Rho and/or outer iterations count.
//
// 50% of problems are rescaled wildly (with scale being passed to
// the solver).
   epsx = 1.0E-12;
   xtol = 1.0E-7;
   for (n = 1; n <= 10; n++) {
      for (scaletype = 0; scaletype <= 1; scaletype++) {
      // Generate random A, b, X0 and XSOL
         spdmatrixrndcond(n, pow(10.0, 3 * hqrnduniformr(&rs)), &rawa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xsol, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
            xsol.xR[i] = hqrndnormal(&rs);
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(rawa.xyR[i], 1, xsol.xR, 1, n);
            b.xR[i] = -v;
         }
      // Generate scale vector, apply it
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            if (scaletype > 0) {
               s.xR[i] = pow(10.0, hqrnduniformr(&rs) * 20 - 10);
            } else {
               s.xR[i] = 1.0;
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rawa.xyR[i][j] /= s.xR[i] * s.xR[j];
            }
            b.xR[i] /= s.xR[i];
            x0.xR[i] *= s.xR[i];
            xsol.xR[i] *= s.xR[i];
         }
      // Create optimizer, solve
         rho = pow(10.0, 2 * hqrnduniformr(&rs));
         outerits = hqrnduniformi(&rs, 5);
         minqpcreate(n, &state);
         minqpsetalgodenseaul(&state, epsx, rho, outerits);
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
         minqpsetscale(&state, &s);
         minqpsetstartingpoint(&state, &x0);
         minqpoptimize(&state);
         minqpresults(&state, &xf, &rep);
      // Compare against analytically known solution
         if (rep.terminationtype <= 0) {
            set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:7154");
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, fabs(xf.xR[i] - xsol.xR[i]) / s.xR[i] > xtol, __FILE__, __LINE__, "testminqpunit.ap:7158");
         }
      }
   }
// Test that problem with zero constraint matrix can be solved
// (with high precision). We do not perform any additional "tweaks"
// like scaling of variables, just want to test ability to handle
// zero matrices.
   epsx = 1.0E-12;
   xtol = 1.0E-7;
   for (n = 1; n <= 10; n++) {
   // Generate random A, b, X0 and XSOL
      spdmatrixrndcond(n, pow(10.0, 3 * hqrnduniformr(&rs)), &rawa);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&xsol, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
         xsol.xR[i] = hqrndnormal(&rs);
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(rawa.xyR[i], 1, xsol.xR, 1, n);
         b.xR[i] = -v;
      }
      rawccnt = hqrnduniformi(&rs, 2 * n);
      ae_matrix_set_length(&rawc, rawccnt, n + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         for (j = 0; j <= n; j++) {
            rawc.xyR[i][j] = 0.0;
         }
         rawct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
      }
   // Create optimizer, solve
      rho = pow(10.0, 2 * hqrnduniformr(&rs));
      outerits = hqrnduniformi(&rs, 5);
      minqpcreate(n, &state);
      minqpsetalgodenseaul(&state, epsx, rho, outerits);
      minqpsetlinearterm(&state, &b);
      testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
      minqpsetlc(&state, &rawc, &rawct, rawccnt);
      minqpsetstartingpoint(&state, &x0);
      minqpoptimize(&state);
      minqpresults(&state, &xf, &rep);
   // Compare against analytically known solution
      if (rep.terminationtype <= 0) {
         set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:7218");
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(errorflag, fabs(xf.xR[i] - xsol.xR[i]) > xtol, __FILE__, __LINE__, "testminqpunit.ap:7222");
      }
   }
// Test that box/linearly inequality constrained problem with ALL constraints
// being inactive at BOTH initial and final points is solved with high precision.
//
// 50% of problems are rescaled wildly (with scale being passed to
// the solver).
   epsx = 1.0E-12;
   xtol = 1.0E-7;
   for (n = 1; n <= 10; n++) {
      for (scaletype = 0; scaletype <= 1; scaletype++) {
      // Generate random A, b, X0 and XSOL
         spdmatrixrndcond(n, pow(10.0, 3 * hqrnduniformr(&rs)), &rawa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xsol, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
            xsol.xR[i] = hqrndnormal(&rs);
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(rawa.xyR[i], 1, xsol.xR, 1, n);
            b.xR[i] = -v;
         }
      // Generate such set of inequality constraints that ALL
      // constraints are inactive at both X0 and XSOL.
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            bndl.xR[i] = rmin2(x0.xR[i], xsol.xR[i]) - 1 - hqrnduniformr(&rs);
            bndu.xR[i] = rmax2(x0.xR[i], xsol.xR[i]) + 1 + hqrnduniformr(&rs);
         }
         rawccnt = hqrnduniformi(&rs, 2 * n);
         ae_matrix_set_length(&rawc, rawccnt, n + 1);
         ae_vector_set_length(&rawct, rawccnt);
         for (i = 0; i < rawccnt; i++) {
            v = 0.0;
            vv = 0.0;
            for (j = 0; j < n; j++) {
               rawc.xyR[i][j] = hqrndnormal(&rs);
               v += rawc.xyR[i][j] * x0.xR[j];
               vv += rawc.xyR[i][j] * xsol.xR[j];
            }
            if (hqrndnormal(&rs) > 0.0) {
               rawct.xZ[i] = 1;
               rawc.xyR[i][n] = rmin2(v, vv) - 1 - hqrnduniformr(&rs);
            } else {
               rawct.xZ[i] = -1;
               rawc.xyR[i][n] = rmax2(v, vv) + 1 + hqrnduniformr(&rs);
            }
         }
      // Generate scale vector, apply it
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            if (scaletype > 0) {
               s.xR[i] = pow(10.0, hqrnduniformr(&rs) * 20 - 10);
            } else {
               s.xR[i] = 1.0;
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rawa.xyR[i][j] /= s.xR[i] * s.xR[j];
            }
            b.xR[i] /= s.xR[i];
            x0.xR[i] *= s.xR[i];
            xsol.xR[i] *= s.xR[i];
            bndl.xR[i] *= s.xR[i];
            bndu.xR[i] *= s.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            for (j = 0; j < n; j++) {
               rawc.xyR[i][j] /= s.xR[j];
            }
         }
      // Create optimizer, solve
         rho = 100.0;
         outerits = 1;
         minqpcreate(n, &state);
         minqpsetstartingpoint(&state, &x0);
         minqpsetalgodenseaul(&state, epsx, rho, outerits);
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
         minqpsetbc(&state, &bndl, &bndu);
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
         minqpsetscale(&state, &s);
         minqpoptimize(&state);
         minqpresults(&state, &xf, &rep);
      // Compare against analytically known solution
         if (rep.terminationtype <= 0) {
            set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:7339");
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, fabs(xf.xR[i] - xsol.xR[i]) / s.xR[i] > xtol, __FILE__, __LINE__, "testminqpunit.ap:7343");
         }
      }
   }
// Test that linear equality constrained problem is solved with high precision.
//
// 50% of problems are rescaled wildly (variable scaling, with scale being
// passed to the solver).
   epsx = 1.0E-12;
   xtol = 1.0E-6;
   for (n = 1; n <= 10; n++) {
      for (scaletype = 0; scaletype <= 1; scaletype++) {
      // Generate random A, b, X0, constraints
         spdmatrixrndcond(n, pow(10.0, 3 * hqrnduniformr(&rs)), &rawa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xsol, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
            b.xR[i] = hqrndnormal(&rs);
         }
         rmatrixrndcond(n, 10.0, &z);
         rawccnt = imax2(n - 2, 0);
         if (rawccnt > 0) {
            ae_matrix_set_length(&rawc, rawccnt, n + 1);
            ae_vector_set_length(&rawct, rawccnt);
            for (i = 0; i < rawccnt; i++) {
               for (j = 0; j < n; j++) {
                  rawc.xyR[i][j] = z.xyR[i][j];
               }
               rawct.xZ[i] = 0;
               rawc.xyR[i][n] = hqrndnormal(&rs);
            }
         }
      // Generate scale vector, apply it
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            if (scaletype > 0) {
               s.xR[i] = pow(10.0, hqrnduniformr(&rs) * 20 - 10);
            } else {
               s.xR[i] = 1.0;
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rawa.xyR[i][j] /= s.xR[i] * s.xR[j];
            }
            b.xR[i] /= s.xR[i];
            x0.xR[i] *= s.xR[i];
            xsol.xR[i] *= s.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            for (j = 0; j < n; j++) {
               rawc.xyR[i][j] /= s.xR[j];
            }
         }
      // Create optimizer, solve
         rho = 100.0;
         outerits = 3;
         minqpcreate(n, &state);
         minqpsetalgodenseaul(&state, epsx, rho, outerits);
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
         minqpsetscale(&state, &s);
         minqpoptimize(&state);
         minqpresults(&state, &xf, &rep);
      // Solve problem analytically using Lagrangian approach
         ae_matrix_set_length(&z, n + rawccnt, n + rawccnt);
         ae_vector_set_length(&r, n + rawccnt);
         for (i = 0; i < n + rawccnt; i++) {
            for (j = 0; j < n + rawccnt; j++) {
               z.xyR[i][j] = 0.0;
            }
            r.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               z.xyR[i][j] = rawa.xyR[i][j];
            }
         }
         for (i = 0; i < n; i++) {
            r.xR[i] = -b.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            for (j = 0; j < n; j++) {
               z.xyR[n + i][j] = rawc.xyR[i][j];
               z.xyR[j][n + i] = rawc.xyR[i][j];
            }
            r.xR[n + i] = rawc.xyR[i][n];
         }
         rmatrixsolve(&z, n + rawccnt, &r, &k, &svrep, &xsol);
         ae_assert(k > 0, "MinQPTest: integrity check failed");
      // Compare against analytically known solution
         if (rep.terminationtype <= 0) {
            set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:7453");
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, fabs(xf.xR[i] - xsol.xR[i]) / s.xR[i] > xtol, __FILE__, __LINE__, "testminqpunit.ap:7457");
         }
      }
   }
// MEDIUM-SCALE VERSION OF PREVIOUS TEST.
//
// Test that linear equality constrained problem is solved with high precision.
//
// 50% of problems are rescaled wildly (variable scaling, with scale being
// passed to the solver).
   epsx = 1.0E-12;
   xtol = 1.0E-6;
   for (n = 99; n <= 101; n++) {
      for (scaletype = 0; scaletype <= 1; scaletype++) {
      // Generate random A, b, X0, constraints
         spdmatrixrndcond(n, pow(10.0, 3 * hqrnduniformr(&rs)), &rawa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xsol, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
            b.xR[i] = hqrndnormal(&rs);
         }
         rmatrixrndcond(n, 10.0, &z);
         rawccnt = imax2(n - 2, 0);
         if (rawccnt > 0) {
            ae_matrix_set_length(&rawc, rawccnt, n + 1);
            ae_vector_set_length(&rawct, rawccnt);
            for (i = 0; i < rawccnt; i++) {
               for (j = 0; j < n; j++) {
                  rawc.xyR[i][j] = z.xyR[i][j];
               }
               rawct.xZ[i] = 0;
               rawc.xyR[i][n] = hqrndnormal(&rs);
            }
         }
      // Generate scale vector, apply it
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            if (scaletype > 0) {
               s.xR[i] = pow(10.0, hqrnduniformr(&rs) * 20 - 10);
            } else {
               s.xR[i] = 1.0;
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rawa.xyR[i][j] /= s.xR[i] * s.xR[j];
            }
            b.xR[i] /= s.xR[i];
            x0.xR[i] *= s.xR[i];
            xsol.xR[i] *= s.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            for (j = 0; j < n; j++) {
               rawc.xyR[i][j] /= s.xR[j];
            }
         }
      // Create optimizer, solve
         rho = 100.0;
         outerits = 3;
         minqpcreate(n, &state);
         minqpsetalgodenseaul(&state, epsx, rho, outerits);
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
         minqpsetscale(&state, &s);
         minqpoptimize(&state);
         minqpresults(&state, &xf, &rep);
      // Solve problem analytically using Lagrangian approach
         ae_matrix_set_length(&z, n + rawccnt, n + rawccnt);
         ae_vector_set_length(&r, n + rawccnt);
         for (i = 0; i < n + rawccnt; i++) {
            for (j = 0; j < n + rawccnt; j++) {
               z.xyR[i][j] = 0.0;
            }
            r.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               z.xyR[i][j] = rawa.xyR[i][j];
            }
         }
         for (i = 0; i < n; i++) {
            r.xR[i] = -b.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            for (j = 0; j < n; j++) {
               z.xyR[n + i][j] = rawc.xyR[i][j];
               z.xyR[j][n + i] = rawc.xyR[i][j];
            }
            r.xR[n + i] = rawc.xyR[i][n];
         }
         rmatrixsolve(&z, n + rawccnt, &r, &k, &svrep, &xsol);
         ae_assert(k > 0, "MinQPTest: integrity check failed");
      // Compare against analytically known solution
         if (rep.terminationtype <= 0) {
            set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:7569");
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, fabs(xf.xR[i] - xsol.xR[i]) / s.xR[i] > xtol, __FILE__, __LINE__, "testminqpunit.ap:7573");
         }
      }
   }
// Test that constraints are automatically scaled to adapt to problem curvature
// (that multiplication of A and b by some large/small number does not affect
// solver).
//
// We generate random well-scaled problem, and multiply A/b by some large/small number,
// and test that problem is still solved with high precision.
//
// NOTE: just to make things worse, we rescale variables randomly, but primary
//       idea of this test is to check for multiplication of A/B
   epsx = 1.0E-12;
   xtol = 1.0E-6;
   for (n = 1; n <= 10; n++) {
      for (scaletype = -1; scaletype <= 1; scaletype++) {
      // Generate random A, b, X0, constraints
         spdmatrixrndcond(n, pow(10.0, 3 * hqrnduniformr(&rs)), &rawa);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xsol, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
            b.xR[i] = hqrndnormal(&rs);
         }
         rmatrixrndcond(n, 10.0, &z);
         rawccnt = imax2(n - 2, 0);
         if (rawccnt > 0) {
            ae_matrix_set_length(&rawc, rawccnt, n + 1);
            ae_vector_set_length(&rawct, rawccnt);
            for (i = 0; i < rawccnt; i++) {
               for (j = 0; j < n; j++) {
                  rawc.xyR[i][j] = z.xyR[i][j];
               }
               rawct.xZ[i] = 0;
               rawc.xyR[i][n] = hqrndnormal(&rs);
            }
         }
      // Solve problem analytically using Lagrangian approach
         ae_matrix_set_length(&z, n + rawccnt, n + rawccnt);
         ae_vector_set_length(&r, n + rawccnt);
         for (i = 0; i < n + rawccnt; i++) {
            for (j = 0; j < n + rawccnt; j++) {
               z.xyR[i][j] = 0.0;
            }
            r.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               z.xyR[i][j] = rawa.xyR[i][j];
            }
         }
         for (i = 0; i < n; i++) {
            r.xR[i] = -b.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            for (j = 0; j < n; j++) {
               z.xyR[n + i][j] = rawc.xyR[i][j];
               z.xyR[j][n + i] = rawc.xyR[i][j];
            }
            r.xR[n + i] = rawc.xyR[i][n];
         }
         rmatrixsolve(&z, n + rawccnt, &r, &k, &svrep, &xsol);
         ae_assert(k > 0, "MinQPTest: integrity check failed");
      // Generate scale vector, apply it
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, hqrnduniformr(&rs) * 20 - 10);
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rawa.xyR[i][j] /= s.xR[i] * s.xR[j];
            }
            b.xR[i] /= s.xR[i];
            x0.xR[i] *= s.xR[i];
            xsol.xR[i] *= s.xR[i];
         }
         for (i = 0; i < rawccnt; i++) {
            for (j = 0; j < n; j++) {
               rawc.xyR[i][j] /= s.xR[j];
            }
         }
      // Multiply A/B by some coefficient with wild magnitude
         v = pow(10.0, (double)(10 * scaletype));
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               rawa.xyR[i][j] *= v;
            }
            b.xR[i] *= v;
         }
      // Create optimizer, solve
         rho = 100.0;
         outerits = 3;
         minqpcreate(n, &state);
         minqpsetalgodenseaul(&state, epsx, rho, outerits);
         minqpsetlinearterm(&state, &b);
         testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
         testminqpunit_randomlysplitandsetlclegacy(&rawc, &rawct, rawccnt, n, &state, &rs);
         minqpsetscale(&state, &s);
         minqpoptimize(&state);
         minqpresults(&state, &xf, &rep);
      // Compare against analytically known solution
         if (rep.terminationtype <= 0) {
            set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:7696");
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, fabs(xf.xR[i] - xsol.xR[i]) / s.xR[i] > xtol, __FILE__, __LINE__, "testminqpunit.ap:7700");
         }
      }
   }
// Test that problem with slight negative curvature f = -0.001*|x|^2
// subject to general linear (!) constraints -1 <= x[i] <= +1 is
// correctly solved. Initial point is in [-0.001,+0.001] range.
//
// NOTE: this test is mostly intended for working set selection algorithm;
//       it must correctly detect non-SPD problems and select full working
//       set; starting with zero working set will result in recognition of
//       problem as unbounded one and premature termination of algorithm.
   epsx = 1.0E-12;
   xtol = 1.0E-6;
   for (n = 1; n <= 10; n++) {
   // Generate A, b, X0, constraints
      ae_matrix_set_length(&rawa, n, n);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            rawa.xyR[i][j] = 0.0;
         }
         rawa.xyR[i][i] = -0.001;
         b.xR[i] = 0.0;
         x0.xR[i] = 0.001 * hqrndnormal(&rs);
      }
      ae_matrix_set_length(&rawc, 2 * n, n + 1);
      ae_vector_set_length(&rawct, 2 * n);
      for (i = 0; i < n; i++) {
         for (j = 0; j <= n; j++) {
            rawc.xyR[2 * i + 0][j] = 0.0;
            rawc.xyR[2 * i + 1][j] = 0.0;
         }
         rawc.xyR[2 * i + 0][i] = 1.0;
         rawc.xyR[2 * i + 1][i] = 1.0;
         rawc.xyR[2 * i + 0][n] = -1.0;
         rawc.xyR[2 * i + 1][n] = 1.0;
         rawct.xZ[2 * i + 0] = 1;
         rawct.xZ[2 * i + 1] = -1;
      }
   // Create optimizer, solve
      rho = 100.0;
      outerits = 5;
      minqpcreate(n, &state);
      minqpsetalgodenseaul(&state, epsx, rho, outerits);
      minqpsetstartingpoint(&state, &x0);
      minqpsetquadraticterm(&state, &rawa, true);
      minqpsetlinearterm(&state, &b);
      minqpsetlc(&state, &rawc, &rawct, 2 * n);
      minqpoptimize(&state);
      minqpresults(&state, &xf, &rep);
   // Test
      set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:7765");
      if (*errorflag) {
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(errorflag, fabs(fabs(xf.xR[i]) - 1) > xtol, __FILE__, __LINE__, "testminqpunit.ap:7769");
      }
   }
   ae_frame_leave();
}

// This function tests IPM QP solver
//
// On failure sets Err to True; on success leaves it unchanged.
static void testminqpunit_ipmtests(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nmain;
   ae_int_t nslack;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_int_t nnz;
   ae_int_t nactive;
   double f0;
   double f1;
   ae_int_t akind;
   ae_int_t rawccnt;
   ae_int_t sparseccnt;
   ae_int_t denseccnt;
   bool issemidefinite;
   ae_int_t repterminationtype;
   double epsx;
   double xtol;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(maina, 0, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(xorigin, 0, DT_REAL);
   NewVector(xf, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(gtrial, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(rawc, 0, 0, DT_REAL);
   NewVector(rawcl, 0, DT_REAL);
   NewVector(rawcu, 0, DT_REAL);
   NewObj(sparsematrix, sparsec);
   NewMatrix(densec, 0, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewVector(lagbc, 0, DT_REAL);
   NewVector(laglc, 0, DT_REAL);
   NewObj(sparsematrix, dummysparse);
   NewObj(vipmstate, vsolver);
   NewVector(replagbc, 0, DT_REAL);
   NewVector(replaglc, 0, DT_REAL);
   NewVector(xsol, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(rawct, 0, DT_INT);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   hqrndrandomize(&rs);
// Test handling of slack variables by IPM solver. We use IPM directly,
// without wrapping it with MinQP interface layer.
//
// Convex optimization problem with known answer (we generate constraints
// and Lagrange coefficients, and then generate quadratic and linear term
// which satisfy KKT conditions for given Lagrange coefficients):
//
// * N=2..8
// * f = 0.5*x'*A*x+b'*x
// * several kinds of A are tried: zero, well conditioned SPD, low rank
// * initial point x0 = [0 0 ... 0 0]
// * first, we generate set of linear constraints (without bounds),
//   solution point X and Lagrange multipliers for linear and box constraints
// * then we determine bounds on variables and linear constraints which
//   align with values/signs of Lagrange multipliers
// * then, having quadratic term A and known constraints and Lagrange
//   multipliers we determine linear term B which makes KKT conditions true
   epsx = 1.0E-12;
   for (nmain = 1; nmain <= 8; nmain++) {
      for (nslack = 0; nslack <= 8; nslack++) {
         for (akind = 0; akind <= 2; akind++) {
            n = nmain + nslack;
         // Generate quadratic term A, origin and scale
            ae_matrix_set_length(&maina, nmain, nmain);
            for (i = 0; i < nmain; i++) {
               for (j = 0; j < nmain; j++) {
                  maina.xyR[i][j] = 0.0;
               }
            }
            issemidefinite = true;
            if (akind == 1) {
            // Dense well conditioned SPD
               spdmatrixrndcond(nmain, 50.0, &maina);
               issemidefinite = false;
            }
            if (akind == 2) {
            // Low rank semidefinite
               ae_vector_set_length(&tmp, nmain);
               for (i = 0; i < nmain; i++) {
                  for (j = 0; j < nmain; j++) {
                     maina.xyR[i][j] = 0.0;
                  }
               }
               for (k = 1; k < imin2(4, nmain); k++) {
                  for (i = 0; i < nmain; i++) {
                     tmp.xR[i] = hqrndnormal(&rs);
                  }
                  v = pow(2.0, hqrndnormal(&rs));
                  for (i = 0; i < nmain; i++) {
                     for (j = 0; j < nmain; j++) {
                        maina.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                     }
                  }
               }
               issemidefinite = true;
            }
            issemidefinite = issemidefinite || nslack > 0;
            ae_matrix_set_length(&fulla, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  fulla.xyR[i][j] = 0.0;
               }
            }
            for (i = 0; i < nmain; i++) {
               for (j = 0; j < nmain; j++) {
                  fulla.xyR[i][j] = maina.xyR[i][j];
               }
            }
            ae_vector_set_length(&s, n);
            ae_vector_set_length(&xorigin, n);
            for (j = 0; j < n; j++) {
               xorigin.xR[j] = hqrndnormal(&rs);
               s.xR[j] = pow(2.0, hqrndnormal(&rs));
            }
         // Generate linear constraints (left parts)
            rawccnt = hqrnduniformi(&rs, 2 * n + 1);
            if (rawccnt > 0) {
               ae_matrix_set_length(&rawc, rawccnt, n);
               for (i = 0; i < rawccnt; i++) {
                  for (j = 0; j < n; j++) {
                     rawc.xyR[i][j] = 0.0;
                  }
                  nnz = hqrnduniformi(&rs, nmain + 1);
                  for (k = 0; k < nnz; k++) {
                     j = hqrnduniformi(&rs, nmain);
                     v = hqrndnormal(&rs);
                     v += 0.1 * possign(v);
                     rawc.xyR[i][j] = v;
                  }
               }
               for (j = nmain; j < n; j++) {
                  if (hqrndnormal(&rs) > 0.0) {
                     v = hqrndnormal(&rs);
                     v += 0.1 * possign(v);
                     rawc.xyR[hqrnduniformi(&rs, rawccnt)][j] = v;
                  }
               }
            }
         // Generate Lagrange multipliers, with 0 <= NActive <= N-1 being non-zero
            ae_vector_set_length(&lagbc, n);
            ae_vector_set_length(&laglc, rawccnt);
            for (i = 0; i < n; i++) {
               lagbc.xR[i] = 0.0;
            }
            for (i = 0; i < rawccnt; i++) {
               laglc.xR[i] = 0.0;
            }
            nactive = hqrnduniformi(&rs, n);
            k = hqrnduniformi(&rs, imin2(nactive, rawccnt) + 1);
            for (i = 0; i < k; i++) {
               v = hqrndnormal(&rs);
               v += 0.01 * possign(v);
               laglc.xR[hqrnduniformi(&rs, rawccnt)] = v;
            }
            for (i = k; i < nactive; i++) {
               v = hqrndnormal(&rs);
               v += 0.01 * possign(v);
               lagbc.xR[hqrnduniformi(&rs, n)] = v;
            }
         // Generate solution and gradient at the solution, set B to -G
            ae_vector_set_length(&xf, n);
            for (i = 0; i < n; i++) {
               xf.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&g, n);
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += fulla.xyR[i][j] * (xf.xR[j] - xorigin.xR[j]);
               }
               g.xR[i] = v;
            }
            for (i = 0; i < n; i++) {
               g.xR[i] += lagbc.xR[i];
            }
            for (i = 0; i < rawccnt; i++) {
               for (j = 0; j < n; j++) {
                  g.xR[j] += laglc.xR[i] * rawc.xyR[i][j];
               }
            }
            ae_vector_set_length(&b, n);
            for (j = 0; j < n; j++) {
               b.xR[j] = -g.xR[j];
            }
         // Set up bounds according to Lagrange multipliers
         //
         // NOTE: for semidefinite problems we set all variable bounds
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            for (j = 0; j < n; j++) {
               bndl.xR[j] = -INFINITY;
               bndu.xR[j] = +INFINITY;
               if ((hqrndnormal(&rs) > 0.0 || issemidefinite) || j >= nmain) {
                  bndl.xR[j] = xf.xR[j] - pow(2.0, hqrndnormal(&rs));
               }
               if ((hqrndnormal(&rs) > 0.0 || issemidefinite) || j >= nmain) {
                  bndu.xR[j] = xf.xR[j] + pow(2.0, hqrndnormal(&rs));
               }
               if (lagbc.xR[j] != 0.0) {
                  if (hqrnduniformr(&rs) < 0.15) {
                     bndl.xR[j] = xf.xR[j];
                     bndu.xR[j] = xf.xR[j];
                  } else {
                     if (lagbc.xR[j] < 0.0) {
                        bndl.xR[j] = xf.xR[j];
                     }
                     if (lagbc.xR[j] > 0.0) {
                        bndu.xR[j] = xf.xR[j];
                     }
                  }
               }
            }
            ae_vector_set_length(&rawcl, rawccnt);
            ae_vector_set_length(&rawcu, rawccnt);
            for (i = 0; i < rawccnt; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += rawc.xyR[i][j] * xf.xR[j];
               }
               rawcl.xR[i] = -INFINITY;
               rawcu.xR[i] = +INFINITY;
               if (hqrndnormal(&rs) > 0.0) {
                  rawcl.xR[i] = v - pow(2.0, hqrndnormal(&rs));
               }
               if (hqrndnormal(&rs) > 0.0) {
                  rawcu.xR[i] = v + pow(2.0, hqrndnormal(&rs));
               }
               if (laglc.xR[i] != 0.0) {
                  if (hqrnduniformr(&rs) < 0.15) {
                  // Active equality constraint
                     rawcl.xR[i] = v;
                     rawcu.xR[i] = v;
                  } else {
                  // Active inequality constraint
                     if (laglc.xR[i] < 0.0) {
                        rawcl.xR[i] = v;
                     }
                     if (laglc.xR[i] > 0.0) {
                        rawcu.xR[i] = v;
                     }
                  }
               }
               if (!isfinite(rawcl.xR[i]) && !isfinite(rawcu.xR[i])) {
               // At least one bound must be present for linear constraint
                  if (hqrndnormal(&rs) > 0.0) {
                     rawcl.xR[i] = v - 10;
                  } else {
                     rawcu.xR[i] = v + 10;
                  }
               }
            }
         // Randomly split constraints into dense and sparse parts
            sparseccnt = hqrnduniformi(&rs, rawccnt + 1);
            denseccnt = rawccnt - sparseccnt;
            if (sparseccnt > 0) {
               sparsecreate(sparseccnt, n, 0, &sparsec);
               for (i = 0; i < sparseccnt; i++) {
                  for (j = 0; j < n; j++) {
                     sparseset(&sparsec, i, j, rawc.xyR[i][j]);
                  }
               }
               sparseconverttocrs(&sparsec);
            }
            if (denseccnt > 0) {
               ae_matrix_set_length(&densec, denseccnt, n);
               for (i = 0; i < denseccnt; i++) {
                  for (j = 0; j < n; j++) {
                     densec.xyR[i][j] = rawc.xyR[i + sparseccnt][j];
                  }
               }
            }
         // Solve
            vipminitdensewithslacks(&vsolver, &s, &xorigin, nmain, n);
            vipmsetquadraticlinear(&vsolver, &fulla, &dummysparse, 0, hqrndnormal(&rs) > 0.0, &b);
            vipmsetconstraints(&vsolver, &bndl, &bndu, &sparsec, sparseccnt, &densec, denseccnt, &rawcl, &rawcu);
            vipmsetcond(&vsolver, epsx, epsx, epsx);
            vipmoptimize(&vsolver, false, &x1, &replagbc, &replaglc, &repterminationtype);
            set_error_flag(errorflag, repterminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:8095");
            set_error_flag(errorflag, x1.cnt < n, __FILE__, __LINE__, "testminqpunit.ap:8096");
            set_error_flag(errorflag, replagbc.cnt < n, __FILE__, __LINE__, "testminqpunit.ap:8097");
            set_error_flag(errorflag, replaglc.cnt < rawccnt, __FILE__, __LINE__, "testminqpunit.ap:8098");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
         // Test function value at the solution
            f0 = testminqpunit_quadratictarget(&fulla, &b, n, &x1);
            f1 = testminqpunit_quadratictarget(&fulla, &b, n, &xf);
            set_error_flag(errorflag, fabs(f0 - f1) > rmax3(fabs(f0), fabs(f1), 1.0) * 1.0E-3, __FILE__, __LINE__, "testminqpunit.ap:8107");
         // Test Lagrange multipliers returned by the solver
            ae_vector_set_length(&gtrial, n);
            for (i = 0; i < n; i++) {
               v = b.xR[i];
               for (j = 0; j < n; j++) {
                  v += fulla.xyR[i][j] * (x1.xR[j] - xorigin.xR[j]);
               }
               gtrial.xR[i] = v;
            }
            for (i = 0; i < n; i++) {
               gtrial.xR[i] += replagbc.xR[i];
            }
            for (i = 0; i < rawccnt; i++) {
               for (j = 0; j < n; j++) {
                  gtrial.xR[j] += replaglc.xR[i] * rawc.xyR[i][j];
               }
            }
            for (i = 0; i < n; i++) {
               set_error_flag(errorflag, fabs(gtrial.xR[i]) > 1.0E-3, __FILE__, __LINE__, "testminqpunit.ap:8126");
            }
         }
      }
   }
// Test that problem with zero constraint matrix can be solved
// (with high precision). We do not perform any additional "tweaks"
// like scaling of variables, just want to test ability to handle
// zero matrices.
   epsx = 1.0E-8;
   xtol = 1.0E-5;
   for (n = 1; n <= 10; n++) {
   // Generate random A, b, X0 and XSOL
      spdmatrixrndcond(n, pow(10.0, 3 * hqrnduniformr(&rs)), &fulla);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&xsol, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
         xsol.xR[i] = hqrndnormal(&rs);
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(fulla.xyR[i], 1, xsol.xR, 1, n);
         b.xR[i] = -v;
      }
      rawccnt = hqrnduniformi(&rs, 2 * n);
      ae_matrix_set_length(&rawc, rawccnt, n + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         for (j = 0; j <= n; j++) {
            rawc.xyR[i][j] = 0.0;
         }
         rawct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
      }
   // Create optimizer, solve
      minqpcreate(n, &state);
      if (hqrndnormal(&rs) > 0.0) {
         minqpsetalgodenseipm(&state, epsx);
      } else {
         minqpsetalgosparseipm(&state, epsx);
      }
      minqpsetlinearterm(&state, &b);
      testminqpunit_randomlyselectconvertandsetquadraticterm(&fulla, n, &state, &rs);
      minqpsetlc(&state, &rawc, &rawct, rawccnt);
      minqpsetstartingpoint(&state, &x0);
      minqpoptimize(&state);
      minqpresults(&state, &xf, &rep);
   // Compare against analytically known solution
      if (rep.terminationtype <= 0) {
         set_error_flag(errorflag, true, __FILE__, __LINE__, "testminqpunit.ap:8187");
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(errorflag, fabs(xf.xR[i] - xsol.xR[i]) > xtol, __FILE__, __LINE__, "testminqpunit.ap:8191");
      }
   }
   ae_frame_leave();
}

// This function tests various special properties
//
// On failure sets Err to True; on success leaves it unchanged.
static void testminqpunit_spectests(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   double xtol;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minqpstate, state);
   NewObj(minqpreport, rep);
   NewMatrix(rawa, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(xs2, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   hqrndrandomize(&rs);
// Test correctness of MinQPSetScaleDiagAuto():
// * that it correctly handles matrices with positive diagonals
// * that it correctly handles non-positive elements
//
// First test is performed by comparing one step of automatically
// scaled QP-BLEIC with one step of manually scaled QP-BLEIC.
   xtol = 1.0E-6;
   for (n = 1; n <= 10; n++) {
   // Generate random box constrained QP problem with specially
   // crafted diagonal.
      ae_matrix_set_length(&rawa, n, n);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            rawa.xyR[i][j] = hqrndnormal(&rs);
         }
         rawa.xyR[i][i] = pow(2.0, (double)(hqrnduniformi(&rs, 9) - 4));
         b.xR[i] = hqrndnormal(&rs);
         bndl.xR[i] = -1.0;
         bndu.xR[i] = 1.0;
         x0.xR[i] = 0.0;
      }
   // Create solver
      minqpcreate(n, &state);
      minqpsetalgobleic(&state, 0.0, 0.0, 0.0, 1);
      minqpsetlinearterm(&state, &b);
      testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
      minqpsetbc(&state, &bndl, &bndu);
      minqpsetstartingpoint(&state, &x0);
   // Solve with automatic scaling
   // Solve with manual scaling
   // Compare
      ae_vector_set_length(&xs, 0);
      minqpsetscaleautodiag(&state);
      minqpoptimize(&state);
      minqpresults(&state, &xs, &rep);
      set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:8266");
      set_error_flag(errorflag, xs.cnt != n, __FILE__, __LINE__, "testminqpunit.ap:8267");
      if (*errorflag) {
         ae_frame_leave();
         return;
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 1 / sqrt(rawa.xyR[i][i]);
      }
      minqpsetscale(&state, &s);
      minqpoptimize(&state);
      minqpresults(&state, &xs2, &rep);
      set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminqpunit.ap:8276");
      set_error_flag(errorflag, xs2.cnt != n, __FILE__, __LINE__, "testminqpunit.ap:8277");
      if (*errorflag) {
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(errorflag, fabs(xs.xR[i] - xs2.xR[i]) > xtol, __FILE__, __LINE__, "testminqpunit.ap:8281");
      }
   // Check that automatic scaling fails for matrices with zero or negative elements
      i = hqrnduniformi(&rs, n);
      j = hqrnduniformi(&rs, 2) - 1;
      rawa.xyR[i][i] = (double)j;
      testminqpunit_randomlyselectconvertandsetquadraticterm(&rawa, n, &state, &rs);
      minqpsetscaleautodiag(&state);
      minqpoptimize(&state);
      minqpresults(&state, &xs, &rep);
      set_error_flag(errorflag, rep.terminationtype != -9, __FILE__, __LINE__, "testminqpunit.ap:8294");
   }
   ae_frame_leave();
}

bool testminqp(bool silent) {
   bool simpleerrors;
   bool func1errors;
   bool func2errors;
   bool bcqperrors;
   bool ecqperrors;
   bool icqperrors;
   bool lcqperrors;
   bool quickqperrors;
   bool bleicerrors;
   bool denseaulerrors;
   bool ipmerrors;
   bool specerrors;
   bool waserrors;
   bool result;
// The VERY basic tests for Cholesky and BLEIC
   simpleerrors = simpletest();
   func1errors = functest1();
   func2errors = functest2();
// Solver-specific tests
   denseaulerrors = false;
   ipmerrors = false;
   quickqperrors = quickqptests();
   bleicerrors = bleictests();
   testminqpunit_denseaultests(&denseaulerrors);
   testminqpunit_ipmtests(&ipmerrors);
//
   icqperrors = false;
   lcqperrors = false;
   bcqperrors = false;
   testminqpunit_bcqptest(&bcqperrors);
   ecqperrors = testminqpunit_ecqptest();
   testminqpunit_icqptest(&icqperrors);
   icqperrors = icqperrors || testminqpunit_specialicqptests();
   testminqpunit_generallcqptest(&lcqperrors);
   specerrors = false;
   testminqpunit_spectests(&specerrors);
// report
   waserrors = ((((((((((simpleerrors || func1errors) || func2errors) || bcqperrors) || ecqperrors) || icqperrors) || lcqperrors) || quickqperrors) || bleicerrors) || denseaulerrors) || ipmerrors) || specerrors;
   if (!silent) {
      printf("TESTING MinQP\n");
      printf("BASIC TESTS:\n");
      printf("* SimpleTest:                             ");
      if (simpleerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* Func1Test:                              ");
      if (func1errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* Func2Test:                              ");
      if (func2errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("GENERIC QP TESTS:\n");
      printf("* box constrained:                        ");
      if (bcqperrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* linearly constrained:                   ");
      if ((ecqperrors || icqperrors) || lcqperrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("SOLVER-SPECIFIC TESTS:\n");
      printf("* QuickQP solver tests:                   ");
      if (quickqperrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* BLEIC solver tests:                     ");
      if (bleicerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* DENSE-AUL solver tests:                 ");
      if (denseaulerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* IPM solver tests:                       ");
      if (ipmerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("SPECIAL PROPERTIES:                       ");
      if (specerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === minlm testing unit ===
// Asserts that State fields are consistent with RKind.
// Returns False otherwise.
//
// RKind is an algorithm selector:
// * -2 = V, AccType=1
// * -1 = V, AccType=0
// *  0 = FJ
// *  1 = FGJ
// *  2 = FGH
// *  3 = VJ, AccType=0
// *  4 = VJ, AccType=1
// *  5 = VJ, AccType=2
//
static bool testminlmunit_rkindvsstatecheck(ae_int_t rkind, minlmstate *state) {
   ae_int_t nset;
   bool result;
   nset = 0;
   if (state->needfi) {
      nset++;
   }
   if (state->needf) {
      nset++;
   }
   if (state->needfg) {
      nset++;
   }
   if (state->needfij) {
      nset++;
   }
   if (state->needfgh) {
      nset++;
   }
   if (state->xupdated) {
      nset++;
   }
   if (nset != 1) {
      result = false;
      return result;
   }
   if (rkind == -2) {
      result = state->needfi || state->xupdated;
      return result;
   }
   if (rkind == -1) {
      result = state->needfi || state->xupdated;
      return result;
   }
   if (rkind == 0) {
      result = (state->needf || state->needfij) || state->xupdated;
      return result;
   }
   if (rkind == 1) {
      result = ((state->needf || state->needfij) || state->needfg) || state->xupdated;
      return result;
   }
   if (rkind == 2) {
      result = ((state->needf || state->needfg) || state->needfgh) || state->xupdated;
      return result;
   }
   if (rkind == 3) {
      result = (state->needfi || state->needfij) || state->xupdated;
      return result;
   }
   if (rkind == 4) {
      result = (state->needfi || state->needfij) || state->xupdated;
      return result;
   }
   if (rkind == 5) {
      result = (state->needfi || state->needfij) || state->xupdated;
      return result;
   }
   result = false;
   return result;
}

// Calculates FI/F/G/H for problem min(||Ax-b||)
static void testminlmunit_axmb(minlmstate *state, RMatrix *a, RVector *b, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   if ((state->needf || state->needfg) || state->needfgh) {
      state->f = 0.0;
   }
   if (state->needfg || state->needfgh) {
      for (i = 0; i < n; i++) {
         state->g.xR[i] = 0.0;
      }
   }
   if (state->needfgh) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            state->h.xyR[i][j] = 0.0;
         }
      }
   }
   for (i = 0; i < n; i++) {
      v = ae_v_dotproduct(a->xyR[i], 1, state->x.xR, 1, n);
      if ((state->needf || state->needfg) || state->needfgh) {
         state->f += sqr(v - b->xR[i]);
      }
      if (state->needfg || state->needfgh) {
         for (j = 0; j < n; j++) {
            state->g.xR[j] += 2 * (v - b->xR[i]) * a->xyR[i][j];
         }
      }
      if (state->needfgh) {
         for (j = 0; j < n; j++) {
            for (k = 0; k < n; k++) {
               state->h.xyR[j][k] += 2 * a->xyR[i][j] * a->xyR[i][k];
            }
         }
      }
      if (state->needfi) {
         state->fi.xR[i] = v - b->xR[i];
      }
      if (state->needfij) {
         state->fi.xR[i] = v - b->xR[i];
         ae_v_move(state->j.xyR[i], 1, a->xyR[i], 1, n);
      }
   }
}

// Test for unconstrained problems.
// On failure sets error flag, leaves it unchanged on success.
static void testminlmunit_testu(bool *errorflag, bool *statefieldsconsistencyflag) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   double h;
   ae_int_t rkind;
   double v;
   double s;
   double eps;
   double epsx;
   ae_int_t maxits;
   ae_int_t ckind;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(minlmstate, state);
   NewObj(minlmreport, rep);
// Reference problem.
// See comments for RKindVsStateCheck() for more info about RKind.
//
// NOTES: we also test negative RKind's corresponding to "inexact" schemes
// which use approximate finite difference Jacobian.
   ae_vector_set_length(&x, 3);
   n = 3;
   m = 3;
   h = 0.0001;
   for (rkind = -2; rkind <= 5; rkind++) {
      x.xR[0] = 50.0 * randommid();
      x.xR[1] = 50.0 * randommid();
      x.xR[2] = 50.0 * randommid();
      if (rkind == -2) {
         minlmcreatev(n, m, &x, h, &state);
         minlmsetacctype(&state, 1);
      }
      if (rkind == -1) {
         minlmcreatev(n, m, &x, h, &state);
         minlmsetacctype(&state, 0);
      }
      if (rkind == 0) {
         minlmcreatefj(n, m, &x, &state);
      }
      if (rkind == 1) {
         minlmcreatefgj(n, m, &x, &state);
      }
      if (rkind == 2) {
         minlmcreatefgh(n, &x, &state);
      }
      if (rkind == 3) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 0);
      }
      if (rkind == 4) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 1);
      }
      if (rkind == 5) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 2);
      }
      while (minlmiteration(&state)) {
      // (x-2)^2 + y^2 + (z-x)^2
         if (state.needfi) {
            state.fi.xR[0] = state.x.xR[0] - 2;
            state.fi.xR[1] = state.x.xR[1];
            state.fi.xR[2] = state.x.xR[2] - state.x.xR[0];
         }
         if (state.needfij) {
            state.fi.xR[0] = state.x.xR[0] - 2;
            state.fi.xR[1] = state.x.xR[1];
            state.fi.xR[2] = state.x.xR[2] - state.x.xR[0];
            state.j.xyR[0][0] = 1.0;
            state.j.xyR[0][1] = 0.0;
            state.j.xyR[0][2] = 0.0;
            state.j.xyR[1][0] = 0.0;
            state.j.xyR[1][1] = 1.0;
            state.j.xyR[1][2] = 0.0;
            state.j.xyR[2][0] = -1.0;
            state.j.xyR[2][1] = 0.0;
            state.j.xyR[2][2] = 1.0;
         }
         if ((state.needf || state.needfg) || state.needfgh) {
            state.f = sqr(state.x.xR[0] - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
         }
         if (state.needfg || state.needfgh) {
            state.g.xR[0] = 2 * (state.x.xR[0] - 2) + 2 * (state.x.xR[0] - state.x.xR[2]);
            state.g.xR[1] = 2 * state.x.xR[1];
            state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
         }
         if (state.needfgh) {
            state.h.xyR[0][0] = 4.0;
            state.h.xyR[0][1] = 0.0;
            state.h.xyR[0][2] = -2.0;
            state.h.xyR[1][0] = 0.0;
            state.h.xyR[1][1] = 2.0;
            state.h.xyR[1][2] = 0.0;
            state.h.xyR[2][0] = -2.0;
            state.h.xyR[2][1] = 0.0;
            state.h.xyR[2][2] = 2.0;
         }
         set_error_flag(statefieldsconsistencyflag, !testminlmunit_rkindvsstatecheck(rkind, &state), __FILE__, __LINE__, "testminlmunit.ap:212");
      }
      minlmresults(&state, &x, &rep);
      set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlmunit.ap:215");
      set_error_flag(errorflag, fabs(x.xR[0] - 2) > 0.001, __FILE__, __LINE__, "testminlmunit.ap:216");
      set_error_flag(errorflag, fabs(x.xR[1]) > 0.001, __FILE__, __LINE__, "testminlmunit.ap:217");
      set_error_flag(errorflag, fabs(x.xR[2] - 2) > 0.001, __FILE__, __LINE__, "testminlmunit.ap:218");
   }
// 1D problem #1
//
// NOTES: we also test negative RKind's corresponding to "inexact" schemes
// which use approximate finite difference Jacobian.
   for (rkind = -2; rkind <= 5; rkind++) {
      ae_vector_set_length(&x, 1);
      n = 1;
      m = 1;
      h = 0.00001;
      x.xR[0] = 50.0 * randommid();
      if (rkind == -2) {
         minlmcreatev(n, m, &x, h, &state);
         minlmsetacctype(&state, 1);
      }
      if (rkind == -1) {
         minlmcreatev(n, m, &x, h, &state);
         minlmsetacctype(&state, 0);
      }
      if (rkind == 0) {
         minlmcreatefj(n, m, &x, &state);
      }
      if (rkind == 1) {
         minlmcreatefgj(n, m, &x, &state);
      }
      if (rkind == 2) {
         minlmcreatefgh(n, &x, &state);
      }
      if (rkind == 3) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 0);
      }
      if (rkind == 4) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 1);
      }
      if (rkind == 5) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 2);
      }
      while (minlmiteration(&state)) {
         if (state.needfi) {
            state.fi.xR[0] = sin(state.x.xR[0]);
         }
         if (state.needfij) {
            state.fi.xR[0] = sin(state.x.xR[0]);
            state.j.xyR[0][0] = cos(state.x.xR[0]);
         }
         if ((state.needf || state.needfg) || state.needfgh) {
            state.f = sqr(sin(state.x.xR[0]));
         }
         if (state.needfg || state.needfgh) {
            state.g.xR[0] = 2 * sin(state.x.xR[0]) * cos(state.x.xR[0]);
         }
         if (state.needfgh) {
            state.h.xyR[0][0] = 2 * (cos(state.x.xR[0]) * cos(state.x.xR[0]) - sin(state.x.xR[0]) * sin(state.x.xR[0]));
         }
         set_error_flag(statefieldsconsistencyflag, !testminlmunit_rkindvsstatecheck(rkind, &state), __FILE__, __LINE__, "testminlmunit.ap:281");
      }
      minlmresults(&state, &x, &rep);
      set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlmunit.ap:284");
      set_error_flag(errorflag, fabs(x.xR[0] / pi - round(x.xR[0] / pi)) > 0.001, __FILE__, __LINE__, "testminlmunit.ap:285");
   }
// Linear equations: test normal optimization and optimization with restarts
   for (n = 1; n <= 10; n++) {
   // Prepare task
      h = 0.00001;
      rmatrixrndcond(n, 100.0, &a);
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xe, n);
      ae_vector_set_length(&b, n);
      for (i = 0; i < n; i++) {
         xe.xR[i] = randommid();
      }
      for (i = 0; i < n; i++) {
         v = ae_v_dotproduct(a.xyR[i], 1, xe.xR, 1, n);
         b.xR[i] = v;
      }
   // Test different RKind
   //
   // NOTES: we also test negative RKind's corresponding to "inexact" schemes
   // which use approximate finite difference Jacobian.
      for (rkind = -2; rkind <= 5; rkind++) {
      // Solve task (first attempt)
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         if (rkind == -2) {
            minlmcreatev(n, n, &x, h, &state);
            minlmsetacctype(&state, 1);
         }
         if (rkind == -1) {
            minlmcreatev(n, n, &x, h, &state);
            minlmsetacctype(&state, 0);
         }
         if (rkind == 0) {
            minlmcreatefj(n, n, &x, &state);
         }
         if (rkind == 1) {
            minlmcreatefgj(n, n, &x, &state);
         }
         if (rkind == 2) {
            minlmcreatefgh(n, &x, &state);
         }
         if (rkind == 3) {
            minlmcreatevj(n, n, &x, &state);
            minlmsetacctype(&state, 0);
         }
         if (rkind == 4) {
            minlmcreatevj(n, n, &x, &state);
            minlmsetacctype(&state, 1);
         }
         if (rkind == 5) {
            minlmcreatevj(n, n, &x, &state);
            minlmsetacctype(&state, 2);
         }
         while (minlmiteration(&state)) {
            testminlmunit_axmb(&state, &a, &b, n);
            set_error_flag(statefieldsconsistencyflag, !testminlmunit_rkindvsstatecheck(rkind, &state), __FILE__, __LINE__, "testminlmunit.ap:357");
         }
         minlmresults(&state, &x, &rep);
         set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlmunit.ap:360");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, fabs(x.xR[i] - xe.xR[i]) > 0.001, __FILE__, __LINE__, "testminlmunit.ap:364");
         }
      // Now we try to restart algorithm from new point
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         minlmrestartfrom(&state, &x);
         while (minlmiteration(&state)) {
            testminlmunit_axmb(&state, &a, &b, n);
            set_error_flag(statefieldsconsistencyflag, !testminlmunit_rkindvsstatecheck(rkind, &state), __FILE__, __LINE__, "testminlmunit.ap:375");
         }
         minlmresults(&state, &x, &rep);
         set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlmunit.ap:378");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, fabs(x.xR[i] - xe.xR[i]) > 0.001, __FILE__, __LINE__, "testminlmunit.ap:382");
         }
      }
   }
// Testing convergence properties using
// different optimizer types and different conditions.
//
// Only limited subset of optimizers is tested because some
// optimizers converge too quickly.
   s = 100.0;
   for (rkind = 0; rkind <= 5; rkind++) {
   // Skip FGH optimizer - it converges too quickly
      if (rkind == 2) {
         continue;
      }
   // Test
      for (ckind = 0; ckind <= 1; ckind++) {
         eps = 0.0;
         epsx = 0.0;
         maxits = 0;
         if (ckind == 0) {
            epsx = 1.0E-6;
            eps = 1.0E-4;
         }
         if (ckind == 1) {
            maxits = 2;
            eps = 0.05;
         }
         ae_vector_set_length(&x, 3);
         n = 3;
         m = 3;
         for (i = 0; i <= 2; i++) {
            x.xR[i] = 6.0;
         }
         if (rkind == 0) {
            minlmcreatefj(n, m, &x, &state);
         }
         if (rkind == 1) {
            minlmcreatefgj(n, m, &x, &state);
         }
         ae_assert(rkind != 2, "Assertion failed");
         if (rkind == 3) {
            minlmcreatevj(n, m, &x, &state);
            minlmsetacctype(&state, 0);
         }
         if (rkind == 4) {
            minlmcreatevj(n, m, &x, &state);
            minlmsetacctype(&state, 1);
         }
         if (rkind == 5) {
            minlmcreatevj(n, m, &x, &state);
            minlmsetacctype(&state, 2);
         }
         minlmsetcond(&state, epsx, maxits);
         while (minlmiteration(&state)) {
            if (state.needfi || state.needfij) {
               state.fi.xR[0] = s * (exp(state.x.xR[0]) - 2);
               state.fi.xR[1] = sqr(state.x.xR[1]) + 1;
               state.fi.xR[2] = state.x.xR[2] - state.x.xR[0];
            }
            if (state.needfij) {
               state.j.xyR[0][0] = s * exp(state.x.xR[0]);
               state.j.xyR[0][1] = 0.0;
               state.j.xyR[0][2] = 0.0;
               state.j.xyR[1][0] = 0.0;
               state.j.xyR[1][1] = 2 * state.x.xR[1];
               state.j.xyR[1][2] = 0.0;
               state.j.xyR[2][0] = -1.0;
               state.j.xyR[2][1] = 0.0;
               state.j.xyR[2][2] = 1.0;
            }
            if ((state.needf || state.needfg) || state.needfgh) {
               state.f = s * sqr(exp(state.x.xR[0]) - 2) + sqr(sqr(state.x.xR[1]) + 1) + sqr(state.x.xR[2] - state.x.xR[0]);
            }
            if (state.needfg || state.needfgh) {
               state.g.xR[0] = s * 2 * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[0] - state.x.xR[2]);
               state.g.xR[1] = 2 * (sqr(state.x.xR[1]) + 1) * 2 * state.x.xR[1];
               state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
            }
            if (state.needfgh) {
               state.h.xyR[0][0] = s * (4 * sqr(exp(state.x.xR[0])) - 4 * exp(state.x.xR[0])) + 2;
               state.h.xyR[0][1] = 0.0;
               state.h.xyR[0][2] = -2.0;
               state.h.xyR[1][0] = 0.0;
               state.h.xyR[1][1] = 12 * sqr(state.x.xR[1]) + 4;
               state.h.xyR[1][2] = 0.0;
               state.h.xyR[2][0] = -2.0;
               state.h.xyR[2][1] = 0.0;
               state.h.xyR[2][2] = 2.0;
            }
            set_error_flag(statefieldsconsistencyflag, !testminlmunit_rkindvsstatecheck(rkind, &state), __FILE__, __LINE__, "testminlmunit.ap:486");
         }
         minlmresults(&state, &x, &rep);
         set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlmunit.ap:489");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         if (ckind == 0) {
            set_error_flag(errorflag, fabs(x.xR[0] - log(2.0)) > eps, __FILE__, __LINE__, "testminlmunit.ap:494");
            set_error_flag(errorflag, fabs(x.xR[1]) > eps, __FILE__, __LINE__, "testminlmunit.ap:495");
            set_error_flag(errorflag, fabs(x.xR[2] - log(2.0)) > eps, __FILE__, __LINE__, "testminlmunit.ap:496");
            set_error_flag(errorflag, rep.terminationtype != 2, __FILE__, __LINE__, "testminlmunit.ap:497");
         }
         if (ckind == 1) {
            set_error_flag(errorflag, rep.terminationtype != 5, __FILE__, __LINE__, "testminlmunit.ap:501");
            set_error_flag(errorflag, rep.iterationscount != maxits, __FILE__, __LINE__, "testminlmunit.ap:502");
         }
      }
   }
   ae_frame_leave();
}

// Test function 1:
//
//     F(N, M, C, X) = SUM( f_i^2 )
//     f_i = SUM( (power(x_j,3)+alpha*x_j)*c_ij )
static void testminlmunit_testfunc1(ae_int_t n, ae_int_t m, RMatrix *c, RVector *x, double *f, bool needf, RVector *fi, bool needfi, RMatrix *jac, bool needjac) {
   ae_int_t i;
   ae_int_t j;
   double v;
   double alpha;
   alpha = 0.01;
   if (needf) {
      *f = 0.0;
   }
   for (i = 0; i < m; i++) {
      v = c->xyR[i][n];
      for (j = 0; j < n; j++) {
         v += (alpha * x->xR[j] + pow(x->xR[j], 3.0)) * c->xyR[i][j];
         if (needjac) {
            jac->xyR[i][j] = (alpha + 3 * pow(x->xR[j], 2.0)) * c->xyR[i][j];
         }
      }
      if (needfi) {
         fi->xR[i] = v;
      }
      if (needf) {
         *f += v * v;
      }
   }
}

// Test for box constrained problems.
// On failure sets error flag, leaves it unchanged on success.
static void testminlmunit_testbc(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   double v;
   double h;
   ae_int_t tmpkind;
   double epsx;
   double tolf;
   double f0;
   double f1;
   ae_frame_make(&_frame_block);
   NewObj(minlmstate, state);
   NewObj(minlmreport, rep);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Reference box constrained problem:
//
//     min sum((x[i]-xe[i])^4) subject to 0 <= x[i] <= 1
//
// NOTES:
// 1. we test only two optimization modes - V and FGH,
//    because from algorithm internals we can assume that actual
//    mode being used doesn't matter for bound constrained optimization
//    process.
   for (tmpkind = 0; tmpkind <= 1; tmpkind++) {
      for (n = 1; n <= 5; n++) {
         ae_vector_set_length(&bl, n);
         ae_vector_set_length(&bu, n);
         ae_vector_set_length(&xe, n);
         ae_vector_set_length(&x, n);
         for (i = 0; i < n; i++) {
            bl.xR[i] = 0.0;
            bu.xR[i] = 1.0;
            xe.xR[i] = 3.0 * randomreal() - 1.0;
            x.xR[i] = randomreal();
         }
         if (tmpkind == 0) {
            minlmcreatefgh(n, &x, &state);
         }
         if (tmpkind == 1) {
            minlmcreatev(n, n, &x, 1.0E-5, &state);
         }
         minlmsetcond(&state, 1.0E-6, 0);
         minlmsetbc(&state, &bl, &bu);
         while (minlmiteration(&state)) {
            if (state.needfi) {
               for (i = 0; i < n; i++) {
                  state.fi.xR[i] = pow(state.x.xR[i] - xe.xR[i], 2.0);
               }
            }
            if ((state.needf || state.needfg) || state.needfgh) {
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  state.f += pow(state.x.xR[i] - xe.xR[i], 4.0);
               }
            }
            if (state.needfg || state.needfgh) {
               for (i = 0; i < n; i++) {
                  state.g.xR[i] = 4 * pow(state.x.xR[i] - xe.xR[i], 3.0);
               }
            }
            if (state.needfgh) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     state.h.xyR[i][j] = 0.0;
                  }
               }
               for (i = 0; i < n; i++) {
                  state.h.xyR[i][i] = 12 * pow(state.x.xR[i] - xe.xR[i], 2.0);
               }
            }
         }
         minlmresults(&state, &x, &rep);
         if (rep.terminationtype > 0) {
            for (i = 0; i < n; i++) {
               set_error_flag(errorflag, fabs(x.xR[i] - rboundval(xe.xR[i], bl.xR[i], bu.xR[i])) > 5.0E-2, __FILE__, __LINE__, "testminlmunit.ap:594");
            }
         } else {
            set_error_flag(errorflag, true, __FILE__, __LINE__, "testminlmunit.ap:597");
         }
      }
   }
// Minimize
//
//          [      [                   ]2  ]
//     SUM_i[ SUM_j[ power(x_j,3)*c_ij ]   ]
//          [      [                   ]   ]
//
// subject to non-negativity constraints on x_j
   epsx = 1.0E-9;
   tolf = 1.0E-10;
   for (tmpkind = 0; tmpkind <= 1; tmpkind++) {
      for (n = 1; n <= 20; n++) {
         m = n + hqrnduniformi(&rs, n);
         ae_vector_set_length(&bl, n);
         ae_vector_set_length(&bu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            bl.xR[i] = 0.0;
            bu.xR[i] = +INFINITY;
            x0.xR[i] = 1 + hqrnduniformr(&rs);
         }
         ae_matrix_set_length(&c, m, n + 1);
         for (i = 0; i < m; i++) {
            for (j = 0; j <= n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
            }
         }
         if (tmpkind == 0) {
            minlmcreatev(n, m, &x0, 10 * epsx, &state);
         }
         if (tmpkind == 1) {
            minlmcreatevj(n, m, &x0, &state);
         }
         minlmsetcond(&state, epsx, 0);
         minlmsetbc(&state, &bl, &bu);
         while (minlmiteration(&state)) {
            for (i = 0; i < n; i++) {
               set_error_flag(errorflag, state.x.xR[i] < bl.xR[i], __FILE__, __LINE__, "testminlmunit.ap:639");
               set_error_flag(errorflag, state.x.xR[i] > bu.xR[i], __FILE__, __LINE__, "testminlmunit.ap:640");
            }
            if (state.needfi) {
               testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, false);
               continue;
            }
            if (state.needfij) {
               testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, true);
               continue;
            }
            ae_assert(false, "minlm test: integrity check failed");
         }
         minlmresults(&state, &x, &rep);
         set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlmunit.ap:655");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         testminlmunit_testfunc1(n, m, &c, &x, &f0, true, &state.fi, false, &state.j, false);
         ae_vector_set_length(&x1, n);
         h = 0.001;
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, x.xR[i] < bl.xR[i], __FILE__, __LINE__, "testminlmunit.ap:664");
            set_error_flag(errorflag, x.xR[i] > bu.xR[i], __FILE__, __LINE__, "testminlmunit.ap:665");
            if (x.xR[i] + h >= bl.xR[i]) {
               for (j = 0; j < n; j++) {
                  x1.xR[j] = x.xR[j];
               }
               x1.xR[i] = x.xR[i] + h;
               testminlmunit_testfunc1(n, m, &c, &x1, &f1, true, &state.fi, false, &state.j, false);
               set_error_flag(errorflag, f1 < f0 * (1 - tolf), __FILE__, __LINE__, "testminlmunit.ap:674");
            }
            if (x.xR[i] - h >= bl.xR[i]) {
               for (j = 0; j < n; j++) {
                  x1.xR[j] = x.xR[j];
               }
               x1.xR[i] = x.xR[i] - h;
               testminlmunit_testfunc1(n, m, &c, &x1, &f1, true, &state.fi, false, &state.j, false);
               set_error_flag(errorflag, f1 < f0 * (1 - tolf), __FILE__, __LINE__, "testminlmunit.ap:684");
            }
         }
      }
   }
// Minimize
//
//          [      [                   ]2  ]
//     SUM_i[ SUM_j[ power(x_j,3)*c_ij ]   ]
//          [      [                   ]   ]
//
// subject to random box constraints on x_j
   epsx = 1.0E-9;
   tolf = 1.0E-10;
   for (tmpkind = 0; tmpkind <= 1; tmpkind++) {
      for (n = 1; n <= 20; n++) {
         m = n + hqrnduniformi(&rs, n);
         ae_vector_set_length(&bl, n);
         ae_vector_set_length(&bu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            bl.xR[i] = hqrndnormal(&rs);
            bu.xR[i] = bl.xR[i] + hqrnduniformr(&rs);
            x0.xR[i] = 1 + hqrnduniformr(&rs);
         }
         ae_matrix_set_length(&c, m, n + 1);
         for (i = 0; i < m; i++) {
            for (j = 0; j <= n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
            }
         }
         if (tmpkind == 0) {
            minlmcreatev(n, m, &x0, 10 * epsx, &state);
         }
         if (tmpkind == 1) {
            minlmcreatevj(n, m, &x0, &state);
         }
         minlmsetcond(&state, epsx, 0);
         minlmsetbc(&state, &bl, &bu);
         while (minlmiteration(&state)) {
            for (i = 0; i < n; i++) {
               set_error_flag(errorflag, state.x.xR[i] < bl.xR[i], __FILE__, __LINE__, "testminlmunit.ap:728");
               set_error_flag(errorflag, state.x.xR[i] > bu.xR[i], __FILE__, __LINE__, "testminlmunit.ap:729");
            }
            if (state.needfi) {
               testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, false);
               continue;
            }
            if (state.needfij) {
               testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, true);
               continue;
            }
            ae_assert(false, "minlm test: integrity check failed");
         }
         minlmresults(&state, &x, &rep);
         set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlmunit.ap:744");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         testminlmunit_testfunc1(n, m, &c, &x, &f0, true, &state.fi, false, &state.j, false);
         ae_vector_set_length(&x1, n);
         h = 0.001;
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, x.xR[i] < bl.xR[i], __FILE__, __LINE__, "testminlmunit.ap:753");
            set_error_flag(errorflag, x.xR[i] > bu.xR[i], __FILE__, __LINE__, "testminlmunit.ap:754");
            if (x.xR[i] + h >= bl.xR[i] && x.xR[i] + h <= bu.xR[i]) {
               for (j = 0; j < n; j++) {
                  x1.xR[j] = x.xR[j];
               }
               x1.xR[i] = x.xR[i] + h;
               testminlmunit_testfunc1(n, m, &c, &x1, &f1, true, &state.fi, false, &state.j, false);
               set_error_flag(errorflag, f1 < f0 * (1 - tolf), __FILE__, __LINE__, "testminlmunit.ap:763");
            }
            if (x.xR[i] - h >= bl.xR[i] && x.xR[i] - h <= bu.xR[i]) {
               for (j = 0; j < n; j++) {
                  x1.xR[j] = x.xR[j];
               }
               x1.xR[i] = x.xR[i] - h;
               testminlmunit_testfunc1(n, m, &c, &x1, &f1, true, &state.fi, false, &state.j, false);
               set_error_flag(errorflag, f1 < f0 * (1 - tolf), __FILE__, __LINE__, "testminlmunit.ap:773");
            }
         }
      }
   }
   ae_frame_leave();
}

// Test for linearly constrained problems.
// On failure sets error flag, leaves it unchanged on success.
static void testminlmunit_testlc(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t m1;
   ae_int_t m2;
   ae_int_t rawccnt;
   ae_int_t trialidx;
   ae_int_t i;
   ae_int_t j;
   double v;
   double h;
   ae_int_t optkind;
   double epsx;
   double xtol;
   double tolf;
   double f0;
   double f1;
   bool bflag;
   ae_frame_make(&_frame_block);
   NewObj(minlmstate, state);
   NewObj(minlmreport, rep);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x12, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewMatrix(rawc, 0, 0, DT_REAL);
   NewVector(rawct, 0, DT_INT);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(c12, 0, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Minimize
//
//          [      [                             ]2  ]
//     SUM_i[ SUM_j[ (0.1*x_j+power(x_j,3))*c_ij ]   ]
//          [      [                             ]   ]
//
// subject to mix of box and linear inequality constraints on x_j
//
// We check correctness of solution by sampling a few random points
// around one returned by optimizer, and comparing function value
// with target. Sampling is performed with respect to inequality
// constraints.
   epsx = 1.0E-12;
   xtol = 1.0E-8;
   tolf = 1.0E-10;
   for (optkind = 0; optkind <= 1; optkind++) {
      for (n = 5; n <= 20; n++) {
      // Generate problem
         m = n + hqrnduniformi(&rs, n);
         ae_vector_set_length(&bl, n);
         ae_vector_set_length(&bu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            bl.xR[i] = hqrndnormal(&rs);
            bu.xR[i] = bl.xR[i] + hqrnduniformr(&rs);
            x0.xR[i] = bl.xR[i] + (bu.xR[i] - bl.xR[i]) * hqrnduniformr(&rs);
         }
         ae_matrix_set_length(&c, m, n + 1);
         for (i = 0; i < m; i++) {
            for (j = 0; j <= n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
            }
         }
         ae_assert(n >= 5, "Assertion failed");
         rawccnt = 3;
         ae_matrix_set_length(&rawc, rawccnt, n + 1);
         ae_vector_set_length(&rawct, rawccnt);
         for (i = 0; i < rawccnt; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               rawc.xyR[i][j] = hqrndnormal(&rs);
               v += x0.xR[j] * rawc.xyR[i][j];
            }
            rawc.xyR[i][n] = v;
            rawct.xZ[i] = 2 * hqrnduniformi(&rs, 2) - 1;
         }
      // Solve
         if (optkind == 0) {
            minlmcreatev(n, m, &x0, 10 * epsx, &state);
         }
         if (optkind == 1) {
            minlmcreatevj(n, m, &x0, &state);
         }
         minlmsetcond(&state, epsx, 0);
         minlmsetbc(&state, &bl, &bu);
         minlmsetlc(&state, &rawc, &rawct, rawccnt);
         while (minlmiteration(&state)) {
            for (i = 0; i < n; i++) {
               set_error_flag(errorflag, state.x.xR[i] < bl.xR[i], __FILE__, __LINE__, "testminlmunit.ap:878");
               set_error_flag(errorflag, state.x.xR[i] > bu.xR[i], __FILE__, __LINE__, "testminlmunit.ap:879");
            }
            if (state.needfi) {
               testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, false);
               continue;
            }
            if (state.needfij) {
               testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, true);
               continue;
            }
            ae_assert(false, "minlm test: integrity check failed");
         }
         minlmresults(&state, &x, &rep);
         set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlmunit.ap:894");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
      // Test feasibility w.r.t. box and linear inequality constraints
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, x.xR[i] < bl.xR[i], __FILE__, __LINE__, "testminlmunit.ap:903");
            set_error_flag(errorflag, x.xR[i] > bu.xR[i], __FILE__, __LINE__, "testminlmunit.ap:904");
         }
         for (i = 0; i < rawccnt; i++) {
            v = ae_v_dotproduct(rawc.xyR[i], 1, x.xR, 1, n);
            v -= rawc.xyR[i][n];
            if (rawct.xZ[i] > 0) {
               set_error_flag(errorflag, v < -xtol, __FILE__, __LINE__, "testminlmunit.ap:911");
            }
            if (rawct.xZ[i] < 0) {
               set_error_flag(errorflag, v > xtol, __FILE__, __LINE__, "testminlmunit.ap:913");
            }
         }
      // Make several random trial steps and:
      // 0) generate small random trial step
      // 1) if step is infeasible, skip to next trial
      // 2) compare function value in the trial point against one in other points
         testminlmunit_testfunc1(n, m, &c, &x, &f0, true, &state.fi, false, &state.j, false);
         ae_vector_set_length(&x1, n);
         for (trialidx = 0; trialidx <= 10 * n; trialidx++) {
            h = 0.001;
            for (i = 0; i < n; i++) {
               do {
                  x1.xR[i] = x.xR[i] + (hqrnduniformr(&rs) * 2 - 1) * h;
               } while (!(x1.xR[i] >= bl.xR[i] && x1.xR[i] <= bu.xR[i]));
            }
            bflag = false;
            for (i = 0; i < rawccnt; i++) {
               ae_assert(rawct.xZ[i] != 0, "Assertion failed");
               v = ae_v_dotproduct(rawc.xyR[i], 1, x1.xR, 1, n);
               v -= rawc.xyR[i][n];
               bflag = bflag || (rawct.xZ[i] > 0 && v < 0.0);
               bflag = bflag || (rawct.xZ[i] < 0 && v > 0.0);
            }
            if (bflag) {
               continue;
            }
            testminlmunit_testfunc1(n, m, &c, &x1, &f1, true, &state.fi, false, &state.j, false);
            set_error_flag(errorflag, f1 < f0 * (1 - tolf), __FILE__, __LINE__, "testminlmunit.ap:950");
         }
      }
   }
// Minimize
//
//          [      [                             ]2  ]
//     SUM_i[ SUM_j[ (0.1*x_j+power(x_j,3))*c_ij ]   ]
//          [      [                             ]   ]
//
// subject to linear EQUALITY constraints on x_j.
//
// We check correctness of solution by sampling a few random points
// around one returned by optimizer, and comparing function value
// with target. Sampling is performed with respect to equality
// constraints. In order to simplify algorithm we use orthogonal
// equality constraints.
//
// NOTE: we solve problem using VJ mode (analytic Jacobian) because
//       roundoff errors from numerical differentiation sometimes
//       prevent us from converging with good precision.
   epsx = 1.0E-12;
   xtol = 1.0E-8;
   tolf = 1.0E-10;
   optkind = 1;
   for (n = 10; n <= 20; n++) {
   // Generate problem
      m = n + hqrnduniformi(&rs, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_matrix_set_length(&c, m, n + 1);
      for (i = 0; i < m; i++) {
         for (j = 0; j <= n; j++) {
            c.xyR[i][j] = hqrndnormal(&rs);
         }
      }
      ae_assert(n >= 5, "Assertion failed");
      rawccnt = 1 + hqrnduniformi(&rs, 5);
      rmatrixrndorthogonal(n, &z);
      ae_matrix_set_length(&rawc, rawccnt, n + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         v = 0.0;
         for (j = 0; j < n; j++) {
            rawc.xyR[i][j] = z.xyR[i][j];
            v += x0.xR[j] * rawc.xyR[i][j];
         }
         rawc.xyR[i][n] = v;
         rawct.xZ[i] = 0;
      }
   // Solve
      if (optkind == 0) {
         minlmcreatev(n, m, &x0, 1.0E-12, &state);
      }
      if (optkind == 1) {
         minlmcreatevj(n, m, &x0, &state);
      }
      minlmsetcond(&state, epsx, 0);
      minlmsetlc(&state, &rawc, &rawct, rawccnt);
      while (minlmiteration(&state)) {
         if (state.needfi) {
            testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, false);
            continue;
         }
         if (state.needfij) {
            testminlmunit_testfunc1(n, m, &c, &state.x, &v, false, &state.fi, true, &state.j, true);
            continue;
         }
         ae_assert(false, "minlm test: integrity check failed");
      }
      minlmresults(&state, &x, &rep);
      set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlmunit.ap:1031");
      if (*errorflag) {
         ae_frame_leave();
         return;
      }
   // Test feasibility w.r.t. linear equality constraints
      for (i = 0; i < rawccnt; i++) {
         v = ae_v_dotproduct(rawc.xyR[i], 1, x.xR, 1, n);
         v -= rawc.xyR[i][n];
         set_error_flag(errorflag, fabs(v) > xtol, __FILE__, __LINE__, "testminlmunit.ap:1042");
      }
   // Make several random trial steps and:
   // 0) generate small random trial step
   // 1) project it onto equality constrained subspace
   // 2) compare function value in the trial point against one in other points
      testminlmunit_testfunc1(n, m, &c, &x, &f0, true, &state.fi, false, &state.j, false);
      ae_vector_set_length(&x1, n);
      for (trialidx = 0; trialidx <= 10 * n; trialidx++) {
         h = 0.001;
         for (i = 0; i < n; i++) {
            x1.xR[i] = hqrndnormal(&rs);
         }
         for (i = 0; i < rawccnt; i++) {
            v = ae_v_dotproduct(rawc.xyR[i], 1, x1.xR, 1, n);
            ae_v_subd(x1.xR, 1, rawc.xyR[i], 1, n, v);
         }
         v = ae_v_dotproduct(x1.xR, 1, x1.xR, 1, n);
         ae_assert(v > 0.0, "Assertion failed");
         v = h / sqrt(v);
         ae_v_muld(x1.xR, 1, n, v);
         ae_v_add(x1.xR, 1, x.xR, 1, n);
         testminlmunit_testfunc1(n, m, &c, &x1, &f1, true, &state.fi, false, &state.j, false);
         set_error_flag(errorflag, f1 < f0 * (1 - tolf), __FILE__, __LINE__, "testminlmunit.ap:1072");
      }
   }
// Minimize
//
//          [      [                               ]2  ]        [      [                               ]2  ]
//     SUM_i[ SUM_j[ (0.1*x_j+power(x0_j,3))*c0_ij ]   ] + SUM_i[ SUM_j[ (0.1*x_j+power(x1_j,3))*c1_ij ]   ]
//          [      [                               ]   ]        [      [                               ]   ]
//
// for two sets of unknowns (x0_j and x1_j) and two sets of
// coefficients (c0_ij and c1_ij, M1*N and M2*N matrices) subject
// to equality constraint
//
//     x0_j=x1_j for all j
//
// Such optimization problem arises when we fit same model to
// two distinct datasets and want to share SOME of coefficients
// between fits. If we share ALL coefficients, it is equal to
// fitting one model to combination of two datasets.
//
// Our test checks that such "combined" 2N-dimensional problem
// solved with general linear constraints which "glue" two datasets
// together returns same answer as N-dimensional problem on (M1+M2)-point
// dataset.
//
// NOTE: we solve problem using VJ mode (analytic Jacobian) because
//       roundoff errors from numerical differentiation prevent us
//       from converging with good precision.
   epsx = 1.0E-12;
   for (n = 5; n <= 20; n++) {
   // Generate problems
      m1 = n + hqrnduniformi(&rs, n);
      m2 = n + hqrnduniformi(&rs, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&x12, 2 * n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
         x12.xR[2 * i + 0] = hqrndnormal(&rs);
         x12.xR[2 * i + 1] = hqrndnormal(&rs);
      }
      ae_matrix_set_length(&c, m1 + m2, n + 1);
      ae_matrix_set_length(&c12, m1 + m2, 2 * n + 1);
      for (i = 0; i < m1 + m2; i++) {
         for (j = 0; j <= 2 * n; j++) {
            c12.xyR[i][j] = 0.0;
         }
      }
      for (i = 0; i < m1 + m2; i++) {
         for (j = 0; j < n; j++) {
            c.xyR[i][j] = hqrndnormal(&rs);
            if (i < m1) {
               c12.xyR[i][j] = c.xyR[i][j];
            } else {
               c12.xyR[i][n + j] = c.xyR[i][j];
            }
         }
         c.xyR[i][n] = hqrndnormal(&rs);
         c12.xyR[i][2 * n] = c.xyR[i][n];
      }
      rawccnt = n;
      ae_matrix_set_length(&rawc, rawccnt, 2 * n + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         for (j = 0; j <= 2 * n; j++) {
            rawc.xyR[i][j] = 0.0;
         }
         rawc.xyR[i][i] = 1.0;
         rawc.xyR[i][n + i] = -1.0;
         rawct.xZ[i] = 0;
      }
   // Solve N-dimensional "combined" problem, store result to X1
      minlmcreatevj(n, m1 + m2, &x0, &state);
      minlmsetcond(&state, epsx, 0);
      while (minlmiteration(&state)) {
         if (state.needfi) {
            testminlmunit_testfunc1(n, m1 + m2, &c, &state.x, &v, false, &state.fi, true, &state.j, false);
            continue;
         }
         if (state.needfij) {
            testminlmunit_testfunc1(n, m1 + m2, &c, &state.x, &v, false, &state.fi, true, &state.j, true);
            continue;
         }
         ae_assert(false, "minlm test: integrity check failed");
      }
      minlmresults(&state, &x, &rep);
      set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlmunit.ap:1170");
      if (*errorflag) {
         ae_frame_leave();
         return;
      }
   // Solve N-dimensional "glued" problem, store result to X12
      minlmcreatevj(2 * n, m1 + m2, &x12, &state);
      minlmsetcond(&state, epsx, 0);
      minlmsetlc(&state, &rawc, &rawct, rawccnt);
      while (minlmiteration(&state)) {
         if (state.needfi) {
            testminlmunit_testfunc1(2 * n, m1 + m2, &c12, &state.x, &v, false, &state.fi, true, &state.j, false);
            continue;
         }
         if (state.needfij) {
            testminlmunit_testfunc1(2 * n, m1 + m2, &c12, &state.x, &v, false, &state.fi, true, &state.j, true);
            continue;
         }
         ae_assert(false, "minlm test: integrity check failed");
      }
      minlmresults(&state, &x12, &rep);
      set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlmunit.ap:1195");
      if (*errorflag) {
         ae_frame_leave();
         return;
      }
   // Compare solutions
      for (i = 0; i < n; i++) {
         set_error_flag(errorflag, fabs(x.xR[i] - x12.xR[i]) > 1.0E-3, __FILE__, __LINE__, "testminlmunit.ap:1204");
         set_error_flag(errorflag, fabs(x.xR[i] - x12.xR[n + i]) > 1.0E-3, __FILE__, __LINE__, "testminlmunit.ap:1205");
         set_error_flag(errorflag, fabs(x12.xR[i] - x12.xR[n + i]) > 1.0E-6, __FILE__, __LINE__, "testminlmunit.ap:1206");
      }
   }
   ae_frame_leave();
}

// Test other properties
// On failure sets error flag, leaves it unchanged on success.
static void testminlmunit_testother(bool *errorflag, bool *statefieldsconsistencyflag) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   double v;
   double s;
   ae_int_t i;
   ae_int_t j;
   ae_int_t rkind;
   double fprev;
   double xprev;
   double stpmax;
   ae_int_t stopcallidx;
   ae_int_t callidx;
   ae_int_t maxits;
   bool terminationrequested;
   ae_int_t pass;
   ae_int_t spoilcnt;
   double mx;
   ae_frame_make(&_frame_block);
   NewObj(minlmstate, state);
   NewObj(minlmreport, rep);
   NewVector(x, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
// Other properties:
// 1. test reports (F should form monotone sequence)
// 2. test maximum step
   for (rkind = 0; rkind <= 5; rkind++) {
   // reports:
   // * check that first report is initial point
   // * check that F is monotone decreasing
   // * check that last report is final result
      n = 3;
      m = 3;
      s = 100.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 6 + randomreal();
      }
      if (rkind == 0) {
         minlmcreatefj(n, m, &x, &state);
      }
      if (rkind == 1) {
         minlmcreatefgj(n, m, &x, &state);
      }
      if (rkind == 2) {
         minlmcreatefgh(n, &x, &state);
      }
      if (rkind == 3) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 0);
      }
      if (rkind == 4) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 1);
      }
      if (rkind == 5) {
         minlmcreatevj(n, m, &x, &state);
         minlmsetacctype(&state, 2);
      }
      minlmsetcond(&state, 0.0, 4);
      minlmsetxrep(&state, true);
      fprev = maxrealnumber;
      while (minlmiteration(&state)) {
         if (state.needfi || state.needfij) {
            state.fi.xR[0] = sqrt(s) * (exp(state.x.xR[0]) - 2);
            state.fi.xR[1] = state.x.xR[1];
            state.fi.xR[2] = state.x.xR[2] - state.x.xR[0];
         }
         if (state.needfij) {
            state.j.xyR[0][0] = sqrt(s) * exp(state.x.xR[0]);
            state.j.xyR[0][1] = 0.0;
            state.j.xyR[0][2] = 0.0;
            state.j.xyR[1][0] = 0.0;
            state.j.xyR[1][1] = 1.0;
            state.j.xyR[1][2] = 0.0;
            state.j.xyR[2][0] = -1.0;
            state.j.xyR[2][1] = 0.0;
            state.j.xyR[2][2] = 1.0;
         }
         if ((state.needf || state.needfg) || state.needfgh) {
            state.f = s * sqr(exp(state.x.xR[0]) - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
         }
         if (state.needfg || state.needfgh) {
            state.g.xR[0] = s * 2 * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[0] - state.x.xR[2]);
            state.g.xR[1] = 2 * state.x.xR[1];
            state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
         }
         if (state.needfgh) {
            state.h.xyR[0][0] = s * (4 * sqr(exp(state.x.xR[0])) - 4 * exp(state.x.xR[0])) + 2;
            state.h.xyR[0][1] = 0.0;
            state.h.xyR[0][2] = -2.0;
            state.h.xyR[1][0] = 0.0;
            state.h.xyR[1][1] = 2.0;
            state.h.xyR[1][2] = 0.0;
            state.h.xyR[2][0] = -2.0;
            state.h.xyR[2][1] = 0.0;
            state.h.xyR[2][2] = 2.0;
         }
         set_error_flag(statefieldsconsistencyflag, !testminlmunit_rkindvsstatecheck(rkind, &state), __FILE__, __LINE__, "testminlmunit.ap:1320");
         if (state.xupdated) {
            set_error_flag(errorflag, state.f > fprev, __FILE__, __LINE__, "testminlmunit.ap:1323");
            if (fprev == maxrealnumber) {
               for (i = 0; i < n; i++) {
                  set_error_flag(errorflag, state.x.xR[i] != x.xR[i], __FILE__, __LINE__, "testminlmunit.ap:1326");
               }
            }
            fprev = state.f;
            ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
         }
      }
      minlmresults(&state, &x, &rep);
      set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlmunit.ap:1332");
      if (*errorflag) {
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(errorflag, x.xR[i] != xlast.xR[i], __FILE__, __LINE__, "testminlmunit.ap:1336");
      }
   }
   n = 1;
   ae_vector_set_length(&x, n);
   x.xR[0] = 100.0;
   stpmax = 0.05 + 0.05 * randomreal();
   minlmcreatefgh(n, &x, &state);
   minlmsetcond(&state, 1.0E-12, 0);
   minlmsetstpmax(&state, stpmax);
   minlmsetxrep(&state, true);
   xprev = x.xR[0];
   while (minlmiteration(&state)) {
      if ((state.needf || state.needfg) || state.needfgh) {
         state.f = exp(state.x.xR[0]) + exp(-state.x.xR[0]);
      }
      if (state.needfg || state.needfgh) {
         state.g.xR[0] = exp(state.x.xR[0]) - exp(-state.x.xR[0]);
      }
      if (state.needfgh) {
         state.h.xyR[0][0] = exp(state.x.xR[0]) + exp(-state.x.xR[0]);
      }
      set_error_flag(errorflag, fabs(state.x.xR[0] - xprev) > (1 + sqrt(machineepsilon)) * stpmax, __FILE__, __LINE__, "testminlmunit.ap:1355");
      if (state.xupdated) {
         xprev = state.x.xR[0];
      }
   }
// Check algorithm ability to handle request for termination:
// * to terminate with correct return code = 8
// * to return point which was "current" at the moment of termination
   for (pass = 1; pass <= 50; pass++) {
      n = 3;
      m = 3;
      s = 100.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 6 + randomreal();
      }
      stopcallidx = randominteger(20);
      maxits = 25;
      minlmcreatevj(n, m, &x, &state);
      minlmsetcond(&state, 0.0, maxits);
      minlmsetxrep(&state, true);
      callidx = 0;
      terminationrequested = false;
      ae_v_move(xlast.xR, 1, x.xR, 1, n);
      while (minlmiteration(&state)) {
         if (state.needfi || state.needfij) {
            state.fi.xR[0] = sqrt(s) * (exp(state.x.xR[0]) - 2);
            state.fi.xR[1] = state.x.xR[1];
            state.fi.xR[2] = state.x.xR[2] - state.x.xR[0];
            if (state.needfij) {
               state.j.xyR[0][0] = sqrt(s) * exp(state.x.xR[0]);
               state.j.xyR[0][1] = 0.0;
               state.j.xyR[0][2] = 0.0;
               state.j.xyR[1][0] = 0.0;
               state.j.xyR[1][1] = 1.0;
               state.j.xyR[1][2] = 0.0;
               state.j.xyR[2][0] = -1.0;
               state.j.xyR[2][1] = 0.0;
               state.j.xyR[2][2] = 1.0;
            }
            if (callidx == stopcallidx) {
               minlmrequesttermination(&state);
               terminationrequested = true;
            }
            callidx++;
            continue;
         }
         if (state.xupdated) {
            if (!terminationrequested) {
               ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minlmresults(&state, &x, &rep);
      set_error_flag(errorflag, rep.terminationtype != 8, __FILE__, __LINE__, "testminlmunit.ap:1419");
      for (i = 0; i < n; i++) {
         set_error_flag(errorflag, x.xR[i] != xlast.xR[i], __FILE__, __LINE__, "testminlmunit.ap:1421");
      }
   }
// Test ability to detect NAN/INF values.
//
// We use Rosenbrock's function which is modified to return
// NAN/INF (randomly) when near solution. Algorithm should set
// appropriate error code (-8) on exit.
   n = 10;
   m = 2 * (n - 1);
   s = 10.0;
   ae_vector_set_length(&x, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = 0.0;
   }
   minlmcreatevj(n, m, &x, &state);
   minlmsetcond(&state, 1.0E-12, 0);
   spoilcnt = 0;
   while (minlmiteration(&state)) {
      if (state.needfij) {
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               state.j.xyR[i][j] = 0.0;
            }
         }
         for (i = 0; i < n - 1; i++) {
            state.fi.xR[2 * i + 0] = s * (state.x.xR[i + 1] - sqr(state.x.xR[i]));
            state.j.xyR[2 * i + 0][i] = -s * 2 * state.x.xR[i];
            state.j.xyR[2 * i + 0][i + 1] = s;
            state.fi.xR[2 * i + 1] = 1 - state.x.xR[i];
            state.j.xyR[2 * i + 1][i] = -1.0;
         }
         mx = 0.0;
         for (i = 0; i < n; i++) {
            mx = rmax2(mx, fabs(state.x.xR[i] - 1));
         }
         if (mx < 1.0E-2) {
            i = randominteger(3);
            v = NAN;
            if (i == 1) {
               v = +INFINITY;
            }
            if (i == 2) {
               v = -INFINITY;
            }
            if (randombool()) {
               state.fi.xR[randominteger(m)] = v;
            } else {
               state.j.xyR[randominteger(m)][randominteger(n)] = v;
            }
            spoilcnt++;
         }
         continue;
      }
      if (state.needfi) {
         for (i = 0; i < n - 1; i++) {
            state.fi.xR[2 * i + 0] = s * (state.x.xR[i + 1] - sqr(state.x.xR[i]));
            state.fi.xR[2 * i + 1] = 1 - state.x.xR[i];
         }
         mx = 0.0;
         for (i = 0; i < n; i++) {
            mx = rmax2(mx, fabs(state.x.xR[i] - 1));
         }
         if (mx < 1.0E-2) {
            i = randominteger(3);
            v = NAN;
            if (i == 1) {
               v = +INFINITY;
            }
            if (i == 2) {
               v = -INFINITY;
            }
            state.fi.xR[randominteger(m)] = v;
            spoilcnt++;
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   minlmresults(&state, &x, &rep);
   set_error_flag(errorflag, rep.terminationtype != -8, __FILE__, __LINE__, "testminlmunit.ap:1513");
   set_error_flag(errorflag, spoilcnt != 1, __FILE__, __LINE__, "testminlmunit.ap:1514");
   ae_frame_leave();
}

// This function tests OptGuard
//
// On failure sets error flag.
static void testminlmunit_testoptguard(bool *wereerrors) {
   ae_frame _frame_block;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   double diffstep;
   ae_int_t defecttype;
   ae_int_t funcidx;
   ae_int_t varidx;
   ae_int_t skind;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minlmstate, state);
   NewObj(minlmreport, rep);
   NewObj(optguardreport, ogrep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(jactrue, 0, 0, DT_REAL);
   NewMatrix(jacdefect, 0, 0, DT_REAL);
   hqrndrandomize(&rs);
// Check that gradient verification is disabled by default:
// gradient checking for bad problem must return nothing
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = 1.0 + 0.1 * i;
   }
   spdmatrixrndcond(n, 1.0E3, &a);
   spdmatrixrndcond(n, 1.0E3, &a1);
   minlmcreatevj(n, 1, &x0, &state);
   minlmsetcond(&state, 1.0E-9, 10);
   while (minlmiteration(&state)) {
      if (state.needfij) {
         state.fi.xR[0] = 0.0;
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.fi.xR[0] += 0.5 * state.x.xR[i] * v;
         }
         for (i = 0; i < n; i++) {
            state.j.xyR[0][i] = 0.0;
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   minlmresults(&state, &x1, &rep);
   minlmoptguardresults(&state, &ogrep);
   set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlmunit.ap:1575");
   set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminlmunit.ap:1576");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(wereerrors, ogrep.badgradxbase.cnt != 0, __FILE__, __LINE__, "testminlmunit.ap:1579");
   set_error_flag(wereerrors, ogrep.badgraduser.rows != 0, __FILE__, __LINE__, "testminlmunit.ap:1580");
   set_error_flag(wereerrors, ogrep.badgraduser.cols != 0, __FILE__, __LINE__, "testminlmunit.ap:1581");
   set_error_flag(wereerrors, ogrep.badgradnum.rows != 0, __FILE__, __LINE__, "testminlmunit.ap:1582");
   set_error_flag(wereerrors, ogrep.badgradnum.cols != 0, __FILE__, __LINE__, "testminlmunit.ap:1583");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(wereerrors, ogrep.badgradsuspected, __FILE__, __LINE__, "testminlmunit.ap:1586");
   set_error_flag(wereerrors, ogrep.badgradfidx != -1, __FILE__, __LINE__, "testminlmunit.ap:1587");
   set_error_flag(wereerrors, ogrep.badgradvidx != -1, __FILE__, __LINE__, "testminlmunit.ap:1588");
// Test gradient checking functionality, try various
// defect types:
// * accidental zeroing of some gradient component
// * accidental addition of 1.0 to some component
// * accidental multiplication by 2.0
// Try distorting both target and constraints.
   diffstep = 0.001;
   n = 10;
   for (skind = 0; skind <= 1; skind++) {
      for (funcidx = 0; funcidx <= 1; funcidx++) {
         for (defecttype = -1; defecttype <= 2; defecttype++) {
            varidx = hqrnduniformi(&rs, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&s, n);
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            for (i = 0; i < n; i++) {
               s.xR[i] = pow(10.0, skind * (30 * hqrnduniformr(&rs) - 15));
               x0.xR[i] = (1.0 + 0.1 * i) * s.xR[i];
               j = hqrnduniformi(&rs, 3);
               bndl.xR[i] = -100 * s.xR[i];
               bndu.xR[i] = 100 * s.xR[i];
               if (j == 1) {
                  bndl.xR[i] = x0.xR[i];
               }
               if (j == 2) {
                  bndu.xR[i] = x0.xR[i];
               }
            }
            spdmatrixrndcond(n, 1.0E3, &a);
            spdmatrixrndcond(n, 1.0E3, &a1);
            minlmcreatevj(n, 2, &x0, &state);
            minlmoptguardgradient(&state, diffstep);
            minlmsetcond(&state, 1.0E-9, 10);
            minlmsetscale(&state, &s);
            minlmsetbc(&state, &bndl, &bndu);
            while (minlmiteration(&state)) {
               if (state.needfi || state.needfij) {
                  for (i = 0; i < n; i++) {
                     set_error_flag(wereerrors, state.x.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminlmunit.ap:1637");
                     set_error_flag(wereerrors, state.x.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminlmunit.ap:1638");
                  }
                  state.fi.xR[0] = 0.0;
                  for (i = 0; i < n; i++) {
                     v = 0.0;
                     for (j = 0; j < n; j++) {
                        v += state.x.xR[j] / s.xR[j] * a.xyR[i][j];
                     }
                     state.fi.xR[0] += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                     if (state.needfij) {
                        state.j.xyR[0][i] = v;
                     }
                  }
                  state.fi.xR[1] = 0.0;
                  for (i = 0; i < n; i++) {
                     v = 0.0;
                     for (j = 0; j < n; j++) {
                        v += state.x.xR[j] / s.xR[j] * a1.xyR[i][j];
                     }
                     state.fi.xR[1] += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                     if (state.needfij) {
                        state.j.xyR[1][i] = v;
                     }
                  }
                  if (state.needfij) {
                     if (defecttype == 0) {
                        state.j.xyR[funcidx][varidx] = 0.0;
                     }
                     if (defecttype == 1) {
                        state.j.xyR[funcidx][varidx]++;
                     }
                     if (defecttype == 2) {
                        state.j.xyR[funcidx][varidx] *= 2;
                     }
                  }
                  if (state.needfij) {
                     for (i = 0; i < n; i++) {
                        state.j.xyR[0][i] /= s.xR[i];
                        state.j.xyR[1][i] /= s.xR[i];
                     }
                  }
                  continue;
               }
               ae_assert(false, "Assertion failed");
            }
            minlmresults(&state, &x1, &rep);
            minlmoptguardresults(&state, &ogrep);
         // Check that something is returned
            set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlmunit.ap:1695");
            set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminlmunit.ap:1696");
            if (*wereerrors) {
               ae_frame_leave();
               return;
            }
         // Compute reference values for true and spoiled Jacobian at X0
            set_error_flag(wereerrors, !isfinitevector(&ogrep.badgradxbase, n), __FILE__, __LINE__, "testminlmunit.ap:1703");
            if (*wereerrors) {
               ae_frame_leave();
               return;
            }
            ae_matrix_set_length(&jactrue, 2, n);
            ae_matrix_set_length(&jacdefect, 2, n);
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += ogrep.badgradxbase.xR[j] / s.xR[j] * a.xyR[i][j];
               }
               jactrue.xyR[0][i] = v;
               jacdefect.xyR[0][i] = v;
            }
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += ogrep.badgradxbase.xR[j] / s.xR[j] * a1.xyR[i][j];
               }
               jactrue.xyR[1][i] = v;
               jacdefect.xyR[1][i] = v;
            }
            if (defecttype == 0) {
               jacdefect.xyR[funcidx][varidx] = 0.0;
            }
            if (defecttype == 1) {
               jacdefect.xyR[funcidx][varidx]++;
            }
            if (defecttype == 2) {
               jacdefect.xyR[funcidx][varidx] *= 2;
            }
            for (i = 0; i < n; i++) {
               jactrue.xyR[0][i] /= s.xR[i];
               jactrue.xyR[1][i] /= s.xR[i];
               jacdefect.xyR[0][i] /= s.xR[i];
               jacdefect.xyR[1][i] /= s.xR[i];
            }
         // Check OptGuard report
            set_error_flag(wereerrors, !apservisfinitematrix(&ogrep.badgraduser, 2, n), __FILE__, __LINE__, "testminlmunit.ap:1741");
            set_error_flag(wereerrors, !apservisfinitematrix(&ogrep.badgradnum, 2, n), __FILE__, __LINE__, "testminlmunit.ap:1742");
            if (*wereerrors) {
               ae_frame_leave();
               return;
            }
            if (defecttype >= 0) {
               set_error_flag(wereerrors, !ogrep.badgradsuspected, __FILE__, __LINE__, "testminlmunit.ap:1747");
               set_error_flag(wereerrors, ogrep.badgradfidx != funcidx, __FILE__, __LINE__, "testminlmunit.ap:1748");
               set_error_flag(wereerrors, ogrep.badgradvidx != varidx, __FILE__, __LINE__, "testminlmunit.ap:1749");
            } else {
               set_error_flag(wereerrors, ogrep.badgradsuspected, __FILE__, __LINE__, "testminlmunit.ap:1753");
               set_error_flag(wereerrors, ogrep.badgradfidx != -1, __FILE__, __LINE__, "testminlmunit.ap:1754");
               set_error_flag(wereerrors, ogrep.badgradvidx != -1, __FILE__, __LINE__, "testminlmunit.ap:1755");
            }
            for (i = 0; i <= 1; i++) {
               for (j = 0; j < n; j++) {
                  set_error_flag(wereerrors, fabs(jactrue.xyR[i][j] - ogrep.badgradnum.xyR[i][j]) > 0.01 / s.xR[j], __FILE__, __LINE__, "testminlmunit.ap:1760");
                  set_error_flag(wereerrors, fabs(jacdefect.xyR[i][j] - ogrep.badgraduser.xyR[i][j]) > 0.01 / s.xR[j], __FILE__, __LINE__, "testminlmunit.ap:1761");
               }
            }
         }
      }
   }
   ae_frame_leave();
}

// This function tries to reproduce previously fixed bugs; in case of bug
// being present sets Err to True; leaves it unchanged otherwise.
static void testminlmunit_tryreproducefixedbugs(bool *err) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   NewObj(minlmstate, s);
   NewObj(minlmreport, rep);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
// Reproduce bug reported by ISS:
// when solving bound constrained problem with numerical differentiation
// and starting from infeasible point, we won't stop at the feasible point
   ae_vector_set_length(&x, 2);
   ae_vector_set_length(&bl, 2);
   ae_vector_set_length(&bu, 2);
   x.xR[0] = 2.0;
   bl.xR[0] = -1.0;
   bu.xR[0] = 1.0;
   x.xR[1] = 2.0;
   bl.xR[1] = -1.0;
   bu.xR[1] = 1.0;
   minlmcreatev(2, 2, &x, 0.001, &s);
   minlmsetbc(&s, &bl, &bu);
   while (minlmiteration(&s)) {
      if (s.needfi) {
         s.fi.xR[0] = sqr(s.x.xR[0]);
         s.fi.xR[1] = sqr(s.x.xR[1]);
      }
   }
   minlmresults(&s, &x, &rep);
   set_error_flag(err, ((x.xR[0] < bl.xR[0] || x.xR[0] > bu.xR[0]) || x.xR[1] < bl.xR[1]) || x.xR[1] > bu.xR[1], __FILE__, __LINE__, "testminlmunit.ap:1923");
   ae_frame_leave();
}

bool testminlm(bool silent) {
   bool waserrors;
   bool uerrors;
   bool bcerrors;
   bool lcerrors;
   bool scerror;
   bool othererrors;
   bool optguarderr;
   bool result;
   waserrors = false;
   scerror = false;
   othererrors = false;
   uerrors = false;
   bcerrors = false;
   lcerrors = false;
// Various tests
   testminlmunit_testother(&othererrors, &scerror);
// Tests sorted by constraint types
   testminlmunit_testu(&uerrors, &scerror);
   testminlmunit_testbc(&bcerrors);
   testminlmunit_testlc(&lcerrors);
// Try to reproduce previously fixed bugs
   testminlmunit_tryreproducefixedbugs(&othererrors);
//  Test for MinLMGradientCheck
   optguarderr = false;
   testminlmunit_testoptguard(&optguarderr);
// end
   waserrors = ((((uerrors || bcerrors) || lcerrors) || scerror) || othererrors) || optguarderr;
   if (!silent) {
      printf("TESTING LEVENBERG-MARQUARDT OPTIMIZATION\n");
      printf("PROBLEM TYPES:\n");
      printf("* UNCONSTRAINED                           ");
      if (uerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* BOX CONSTRAINED                         ");
      if (bcerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* LINEARLY CONSTRAINED                    ");
      if (lcerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("STATE FIELDS CONSISTENCY:                 ");
      if (scerror) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("OTHER PROPERTIES:                         ");
      if (othererrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("OPTGUARD:                                 ");
      if (optguarderr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === mincg testing unit ===
static const ae_int_t testmincgunit_maxoptguardlevel = 1;

// Other properties
static void testother(bool *err) {
   ae_frame _frame_block;
   ae_int_t n;
   double fprev;
   double xprev;
   double stpmax;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t cgtype;
   double tmpeps;
   double epsg;
   double v;
   double r;
   bool hasxlast;
   double lastscaledstep;
   ae_int_t pkind;
   ae_int_t ckind;
   ae_int_t mkind;
   ae_int_t dkind;
   double diffstep;
   double vc;
   double vm;
   bool wasf;
   bool wasfg;
   ae_int_t spoiliteration;
   ae_int_t stopiteration;
   ae_int_t spoilvar;
   double spoilval;
   ae_int_t pass;
   double ss;
   ae_int_t callidx;
   ae_int_t stopcallidx;
   ae_int_t maxits;
   bool terminationrequested;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(a, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(h, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewObj(mincgstate, state);
   NewObj(mincgreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   for (cgtype = -1; cgtype <= 1; cgtype++) {
   // Test reports (F should form monotone sequence)
      n = 50;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 1.0;
      }
      mincgcreate(n, &x, &state);
      mincgsetcond(&state, 0.0, 0.0, 0.0, 100);
      mincgsetxrep(&state, true);
      fprev = maxrealnumber;
      while (mincgiteration(&state)) {
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += sqr((1 + i) * state.x.xR[i]);
               state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
            }
         }
         if (state.xupdated) {
            *err = *err || state.f > fprev;
            if (fprev == maxrealnumber) {
               for (i = 0; i < n; i++) {
                  *err = *err || state.x.xR[i] != x.xR[i];
               }
            }
            fprev = state.f;
            ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
         }
      }
      mincgresults(&state, &x, &rep);
      for (i = 0; i < n; i++) {
         *err = *err || x.xR[i] != xlast.xR[i];
      }
   // Test differentiation vs. analytic gradient
   // (first one issues NeedF requests, second one issues NeedFG requests)
      n = 50;
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xlast, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 1.0;
         }
         if (dkind == 0) {
            mincgcreate(n, &x, &state);
         }
         if (dkind == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcond(&state, 0.0, 0.0, 0.0, n / 2);
         wasf = false;
         wasfg = false;
         while (mincgiteration(&state)) {
            if (state.needf || state.needfg) {
               state.f = 0.0;
            }
            for (i = 0; i < n; i++) {
               if (state.needf || state.needfg) {
                  state.f += sqr((1 + i) * state.x.xR[i]);
               }
               if (state.needfg) {
                  state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
               }
            }
            wasf = wasf || state.needf;
            wasfg = wasfg || state.needfg;
         }
         mincgresults(&state, &x, &rep);
         if (dkind == 0) {
            *err = (*err || wasf) || !wasfg;
         }
         if (dkind == 1) {
            *err = (*err || !wasf) || wasfg;
         }
      }
   // Test that numerical differentiation uses scaling.
   //
   // In order to test that we solve simple optimization
   // problem: min(x^2) with initial x equal to 0.0.
   //
   // We choose random DiffStep and S, then we check that
   // optimizer evaluates function at +-DiffStep*S only.
      ae_vector_set_length(&x, 1);
      ae_vector_set_length(&s, 1);
      diffstep = randomreal() * 1.0E-6;
      s.xR[0] = exp(randomreal() * 4 - 2);
      x.xR[0] = 0.0;
      mincgcreatef(1, &x, diffstep, &state);
      mincgsetcond(&state, 1.0E-6, 0.0, 0.0, 0);
      mincgsetscale(&state, &s);
      v = 0.0;
      while (mincgiteration(&state)) {
         state.f = sqr(state.x.xR[0]);
         v = rmax2(v, fabs(state.x.xR[0]));
      }
      mincgresults(&state, &x, &rep);
      r = v / (s.xR[0] * diffstep);
      *err = *err || fabs(log(r)) > log(1 + 1000 * machineepsilon);
   // Test maximum step
      n = 1;
      ae_vector_set_length(&x, n);
      x.xR[0] = 100.0;
      stpmax = 0.05 + 0.05 * randomreal();
      mincgcreate(n, &x, &state);
      mincgsetcond(&state, 1.0E-9, 0.0, 0.0, 0);
      mincgsetstpmax(&state, stpmax);
      mincgsetxrep(&state, true);
      xprev = x.xR[0];
      while (mincgiteration(&state)) {
         if (state.needfg) {
            state.f = exp(state.x.xR[0]) + exp(-state.x.xR[0]);
            state.g.xR[0] = exp(state.x.xR[0]) - exp(-state.x.xR[0]);
            *err = *err || fabs(state.x.xR[0] - xprev) > (1 + sqrt(machineepsilon)) * stpmax;
         }
         if (state.xupdated) {
            *err = *err || fabs(state.x.xR[0] - xprev) > (1 + sqrt(machineepsilon)) * stpmax;
            xprev = state.x.xR[0];
         }
      }
   // Test correctness of the scaling:
   // * initial point is random point from [+1,+2]^N
   // * f(x) = SUM(A[i]*x[i]^4), C[i] is random from [0.01,100]
   // * we use random scaling matrix
   // * we test different variants of the preconditioning:
   //   0) unit preconditioner
   //   1) random diagonal from [0.01,100]
   //   2) scale preconditioner
   // * we set stringent stopping conditions (we try EpsG and EpsX)
   // * and we test that in the extremum stopping conditions are
   //   satisfied subject to the current scaling coefficients.
      tmpeps = 1.0E-10;
      for (n = 1; n <= 10; n++) {
         for (pkind = 0; pkind <= 2; pkind++) {
            ae_vector_set_length(&x, n);
            ae_vector_set_length(&xlast, n);
            ae_vector_set_length(&a, n);
            ae_vector_set_length(&s, n);
            ae_vector_set_length(&h, n);
            for (i = 0; i < n; i++) {
               x.xR[i] = randomreal() + 1;
               a.xR[i] = exp(log(100.0) * randommid());
               s.xR[i] = exp(log(100.0) * randommid());
               h.xR[i] = exp(log(100.0) * randommid());
            }
            mincgcreate(n, &x, &state);
            mincgsetscale(&state, &s);
            mincgsetxrep(&state, true);
            if (pkind == 1) {
               mincgsetprecdiag(&state, &h);
            }
            if (pkind == 2) {
               mincgsetprecscale(&state);
            }
         // Test gradient-based stopping condition
            for (i = 0; i < n; i++) {
               x.xR[i] = randomreal() + 1;
            }
            mincgsetcond(&state, tmpeps, 0.0, 0.0, 0);
            mincgrestartfrom(&state, &x);
            while (mincgiteration(&state)) {
               if (state.needfg) {
                  state.f = 0.0;
                  for (i = 0; i < n; i++) {
                     state.f += a.xR[i] * pow(state.x.xR[i], 4.0);
                     state.g.xR[i] = 4 * a.xR[i] * pow(state.x.xR[i], 3.0);
                  }
               }
            }
            mincgresults(&state, &x, &rep);
            if (rep.terminationtype <= 0) {
               *err = true;
               ae_frame_leave();
               return;
            }
            v = 0.0;
            for (i = 0; i < n; i++) {
               v += sqr(s.xR[i] * 4 * a.xR[i] * pow(x.xR[i], 3.0));
            }
            v = sqrt(v);
            *err = *err || v > tmpeps;
         // Test step-based stopping condition
            for (i = 0; i < n; i++) {
               x.xR[i] = randomreal() + 1;
            }
            hasxlast = false;
            mincgsetcond(&state, 0.0, 0.0, tmpeps, 0);
            mincgrestartfrom(&state, &x);
            lastscaledstep = 0.0;
            while (mincgiteration(&state)) {
               if (state.needfg) {
                  state.f = 0.0;
                  for (i = 0; i < n; i++) {
                     state.f += a.xR[i] * pow(state.x.xR[i], 4.0);
                     state.g.xR[i] = 4 * a.xR[i] * pow(state.x.xR[i], 3.0);
                  }
               }
               if (state.xupdated) {
                  if (hasxlast) {
                     lastscaledstep = 0.0;
                     for (i = 0; i < n; i++) {
                        lastscaledstep += sqr(state.x.xR[i] - xlast.xR[i]) / sqr(s.xR[i]);
                     }
                     lastscaledstep = sqrt(lastscaledstep);
                  } else {
                     lastscaledstep = 0.0;
                  }
                  ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
                  hasxlast = true;
               }
            }
            mincgresults(&state, &x, &rep);
            if (rep.terminationtype <= 0) {
               *err = true;
               ae_frame_leave();
               return;
            }
            *err = *err || lastscaledstep > tmpeps;
         }
      }
   // Check correctness of the "trimming".
   //
   // Trimming is a technique which is used to help algorithm
   // cope with unbounded functions. In order to check this
   // technique we will try to solve following optimization
   // problem:
   //
   //     min f(x) subject to no constraints on X
   //            { 1/(1-x) + 1/(1+x) + c*x, if -0.999999<x<0.999999
   //     f(x) = {
   //            { M, if x <= -0.999999 or x >= 0.999999
   //
   // where c is either 1.0 or 1.0E+6, M is either 1.0E8, 1.0E20 or +INF
   // (we try different combinations)
      for (ckind = 0; ckind <= 1; ckind++) {
         for (mkind = 0; mkind <= 2; mkind++) {
         // Choose c and M
            vc = 1.0;
            vm = 1.0E+8;
            if (ckind == 1) {
               vc = 1.0E+6;
            }
            if (mkind == 1) {
               vm = 1.0E+20;
            }
            if (mkind == 2) {
               vm = +INFINITY;
            }
         // Create optimizer, solve optimization problem
            epsg = 1.0E-6 * vc;
            ae_vector_set_length(&x, 1);
            x.xR[0] = 0.0;
            mincgcreate(1, &x, &state);
            mincgsetcond(&state, epsg, 0.0, 0.0, 0);
            mincgsetcgtype(&state, cgtype);
            while (mincgiteration(&state)) {
               if (state.needfg) {
                  if (-0.999999 < state.x.xR[0] && state.x.xR[0] < 0.999999) {
                     state.f = 1 / (1 - state.x.xR[0]) + 1 / (1 + state.x.xR[0]) + vc * state.x.xR[0];
                     state.g.xR[0] = 1 / sqr(1 - state.x.xR[0]) - 1 / sqr(1 + state.x.xR[0]) + vc;
                  } else {
                     state.f = vm;
                  }
               }
            }
            mincgresults(&state, &x, &rep);
            if (rep.terminationtype <= 0) {
               *err = true;
               ae_frame_leave();
               return;
            }
            *err = *err || fabs(1 / sqr(1 - x.xR[0]) - 1 / sqr(1 + x.xR[0]) + vc) > epsg;
         }
      }
   }
// Test integrity checks for NAN/INF:
// * algorithm solves optimization problem, which is normal for some time (quadratic)
// * after 5-th step we choose random component of gradient and consistently spoil
//   it by NAN or INF.
// * we check that correct termination code is returned (-8)
   n = 100;
   for (pass = 1; pass <= 10; pass++) {
      spoiliteration = 5;
      stopiteration = 8;
      if (hqrndnormal(&rs) > 0.0) {
      // Gradient can be spoiled by +INF, -INF, NAN
         spoilvar = hqrnduniformi(&rs, n);
         i = hqrnduniformi(&rs, 3);
         spoilval = NAN;
         if (i == 0) {
            spoilval = -INFINITY;
         }
         if (i == 1) {
            spoilval = +INFINITY;
         }
      } else {
      // Function value can be spoiled only by NAN
      // (+INF can be recognized as legitimate value during optimization)
         spoilvar = -1;
         spoilval = NAN;
      }
      spdmatrixrndcond(n, 1.0E5, &fulla);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         b.xR[i] = hqrndnormal(&rs);
         x0.xR[i] = hqrndnormal(&rs);
      }
      mincgcreate(n, &x0, &state);
      mincgsetcond(&state, 0.0, 0.0, 0.0, stopiteration);
      mincgsetxrep(&state, true);
      k = -1;
      while (mincgiteration(&state)) {
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += b.xR[i] * state.x.xR[i];
               state.g.xR[i] = b.xR[i];
               for (j = 0; j < n; j++) {
                  state.f += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                  state.g.xR[i] += fulla.xyR[i][j] * state.x.xR[j];
               }
            }
            if (k >= spoiliteration) {
               if (spoilvar < 0) {
                  state.f = spoilval;
               } else {
                  state.g.xR[spoilvar] = spoilval;
               }
            }
            continue;
         }
         if (state.xupdated) {
            k++;
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      mincgresults(&state, &x1, &rep);
      set_error_flag(err, rep.terminationtype != -8, __FILE__, __LINE__, "testmincgunit.ap:1151");
   }
// Check algorithm ability to handle request for termination:
// * to terminate with correct return code = 8
// * to return point which was "current" at the moment of termination
   for (pass = 1; pass <= 50; pass++) {
      n = 3;
      ss = 100.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 6 + randomreal();
      }
      stopcallidx = randominteger(20);
      maxits = 25;
      mincgcreate(n, &x, &state);
      mincgsetcond(&state, 0.0, 0.0, 0.0, maxits);
      mincgsetxrep(&state, true);
      callidx = 0;
      terminationrequested = false;
      ae_v_move(xlast.xR, 1, x.xR, 1, n);
      while (mincgiteration(&state)) {
         if (state.needfg) {
            state.f = ss * sqr(exp(state.x.xR[0]) - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
            state.g.xR[0] = 2 * ss * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[2] - state.x.xR[0]) * (-1);
            state.g.xR[1] = 2 * state.x.xR[1];
            state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
            if (callidx == stopcallidx) {
               mincgrequesttermination(&state);
               terminationrequested = true;
            }
            callidx++;
            continue;
         }
         if (state.xupdated) {
            if (!terminationrequested) {
               ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      mincgresults(&state, &x, &rep);
      set_error_flag(err, rep.terminationtype != 8, __FILE__, __LINE__, "testmincgunit.ap:1201");
      for (i = 0; i < n; i++) {
         set_error_flag(err, x.xR[i] != xlast.xR[i], __FILE__, __LINE__, "testmincgunit.ap:1203");
      }
   }
   ae_frame_leave();
}

// Calculate test function #2
//
// Simple variation of #1, much more nonlinear, which makes unlikely premature
// convergence of algorithm .
static void testmincgunit_testfunc2(mincgstate *state) {
   if (state->x.xR[0] < 100.0) {
      if (state->needf || state->needfg) {
         state->f = sqr(exp(state->x.xR[0]) - 2) + sqr(sqr(state->x.xR[1])) + sqr(state->x.xR[2] - state->x.xR[0]);
      }
      if (state->needfg) {
         state->g.xR[0] = 2 * (exp(state->x.xR[0]) - 2) * exp(state->x.xR[0]) + 2 * (state->x.xR[0] - state->x.xR[2]);
         state->g.xR[1] = 4 * state->x.xR[1] * sqr(state->x.xR[1]);
         state->g.xR[2] = 2 * (state->x.xR[2] - state->x.xR[0]);
      }
   } else {
      if (state->needf || state->needfg) {
         state->f = sqrt(maxrealnumber);
      }
      if (state->needfg) {
         state->g.xR[0] = sqrt(maxrealnumber);
         state->g.xR[1] = 0.0;
         state->g.xR[2] = 0.0;
      }
   }
}

// Calculate test function #3
//
// Simple variation of #1, much more nonlinear, with non-zero value at minimum.
// It achieve two goals:
// * makes unlikely premature convergence of algorithm .
// * solves some issues with EpsF stopping condition which arise when
//   F(minimum) is zero
//
static void testmincgunit_testfunc3(mincgstate *state) {
   double s;
   s = 0.001;
   if (state->x.xR[0] < 100.0) {
      if (state->needf || state->needfg) {
         state->f = sqr(exp(state->x.xR[0]) - 2) + sqr(sqr(state->x.xR[1]) + s) + sqr(state->x.xR[2] - state->x.xR[0]);
      }
      if (state->needfg) {
         state->g.xR[0] = 2 * (exp(state->x.xR[0]) - 2) * exp(state->x.xR[0]) + 2 * (state->x.xR[0] - state->x.xR[2]);
         state->g.xR[1] = 2 * (sqr(state->x.xR[1]) + s) * 2 * state->x.xR[1];
         state->g.xR[2] = 2 * (state->x.xR[2] - state->x.xR[0]);
      }
   } else {
      if (state->needf || state->needfg) {
         state->f = sqrt(maxrealnumber);
      }
      if (state->needfg) {
         state->g.xR[0] = sqrt(maxrealnumber);
         state->g.xR[1] = 0.0;
         state->g.xR[2] = 0.0;
      }
   }
}

// Calculate test function IIP2
//
// f(x) = sum( ((i*i+1)*x[i])^2, i=0..N-1)
//
// It has high condition number which makes fast convergence unlikely without
// good preconditioner.
//
static void testmincgunit_calciip2(mincgstate *state, ae_int_t n) {
   ae_int_t i;
   if (state->needf || state->needfg) {
      state->f = 0.0;
   }
   for (i = 0; i < n; i++) {
      if (state->needf || state->needfg) {
         state->f += sqr((double)(i * i + 1)) * sqr(state->x.xR[i]);
      }
      if (state->needfg) {
         state->g.xR[i] = sqr((double)(i * i + 1)) * 2 * state->x.xR[i];
      }
   }
}

// Calculate test function f(x) = 0.5*(x-x0)'*A*(x-x0), A = D+V'*Vd*V
static void testmincgunit_calclowrank(mincgstate *state, ae_int_t n, ae_int_t vcnt, RVector *d, RMatrix *v, RVector *vd, RVector *x0) {
   ae_int_t i;
   ae_int_t j;
   double dx;
   double t;
   double t2;
   state->f = 0.0;
   for (i = 0; i < n; i++) {
      state->g.xR[i] = 0.0;
   }
   for (i = 0; i < n; i++) {
      dx = state->x.xR[i] - x0->xR[i];
      state->f += 0.5 * dx * d->xR[i] * dx;
      state->g.xR[i] += d->xR[i] * dx;
   }
   for (i = 0; i < vcnt; i++) {
      t = 0.0;
      for (j = 0; j < n; j++) {
         t += v->xyR[i][j] * (state->x.xR[j] - x0->xR[j]);
      }
      state->f += 0.5 * t * vd->xR[i] * t;
      t2 = t * vd->xR[i];
      ae_v_addd(state->g.xR, 1, v->xyR[i], 1, n, t2);
   }
}

// This function tests preconditioning
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testmincgunit_testpreconditioning(bool *err) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t vs;
   ae_int_t cntb1;
   ae_int_t cntg1;
   ae_int_t cntb2;
   ae_int_t cntg2;
   ae_int_t cgtype;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewVector(vd, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(diagh, 0, DT_REAL);
   NewObj(mincgstate, state);
   NewObj(mincgreport, rep);
   k = 50;
   for (cgtype = -1; cgtype <= 1; cgtype++) {
   // Preconditioner test 1.
   //
   // If
   // * B1 is default preconditioner
   // * G1 is diagonal precomditioner based on approximate diagonal of Hessian matrix
   // then "bad" preconditioner is worse than "good" one.
   // "Worse" means more iterations to converge.
   //
   //
   // We test it using f(x) = sum( ((i*i+1)*x[i])^2, i=0..N-1).
   //
   // N        - problem size
   // K        - number of repeated passes (should be large enough to average out random factors)
      for (n = 10; n <= 15; n++) {
         ae_vector_set_length(&x, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 0.0;
         }
         mincgcreate(n, &x, &state);
         mincgsetcgtype(&state, cgtype);
      // Test it with default preconditioner
         mincgsetprecdefault(&state);
         cntb1 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            mincgrestartfrom(&state, &x);
            while (mincgiteration(&state)) {
               testmincgunit_calciip2(&state, n);
            }
            mincgresults(&state, &x, &rep);
            cntb1 += rep.iterationscount;
            *err = *err || rep.terminationtype <= 0;
         }
      // Test it with perturbed diagonal preconditioner
         ae_vector_set_length(&diagh, n);
         for (i = 0; i < n; i++) {
            diagh.xR[i] = 2 * sqr((double)(i * i + 1)) * (0.8 + 0.4 * randomreal());
         }
         mincgsetprecdiag(&state, &diagh);
         cntg1 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            mincgrestartfrom(&state, &x);
            while (mincgiteration(&state)) {
               testmincgunit_calciip2(&state, n);
            }
            mincgresults(&state, &x, &rep);
            cntg1 += rep.iterationscount;
            *err = *err || rep.terminationtype <= 0;
         }
      // Compare
         *err = *err || cntb1 < cntg1;
      }
   // Preconditioner test 2.
   //
   // If
   // * B1 is default preconditioner
   // * G1 is low rank exact preconditioner
   // then "bad" preconditioner is worse than "good" one.
   // "Worse" means more iterations to converge.
   //
   // Target function is f(x) = 0.5*(x-x0)'*A*(x-x0), A = D+V'*Vd*V
   //
   // N        - problem size
   // K        - number of repeated passes (should be large enough to average out random factors)
      for (n = 10; n <= 15; n++) {
         for (vs = 0; vs <= 5; vs++) {
            ae_vector_set_length(&x, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&d, n);
            for (i = 0; i < n; i++) {
               x.xR[i] = 0.0;
               x0.xR[i] = randommid();
               d.xR[i] = exp(2 * randomreal());
            }
            if (vs > 0) {
               ae_matrix_set_length(&v, vs, n);
               ae_vector_set_length(&vd, vs);
               for (i = 0; i < vs; i++) {
                  for (j = 0; j < n; j++) {
                     v.xyR[i][j] = randommid();
                  }
                  vd.xR[i] = exp(2 * randomreal());
               }
            }
            mincgcreate(n, &x, &state);
            mincgsetcgtype(&state, cgtype);
         // Test it with default preconditioner
            mincgsetprecdefault(&state);
            cntb1 = 0;
            for (pass = 0; pass < k; pass++) {
               for (i = 0; i < n; i++) {
                  x.xR[i] = randommid();
               }
               mincgrestartfrom(&state, &x);
               while (mincgiteration(&state)) {
                  testmincgunit_calclowrank(&state, n, vs, &d, &v, &vd, &x0);
               }
               mincgresults(&state, &x, &rep);
               cntb1 += rep.iterationscount;
               *err = *err || rep.terminationtype <= 0;
            }
         // Test it with low rank preconditioner
            mincgsetpreclowrankfast(&state, &d, &vd, &v, vs);
            cntg1 = 0;
            for (pass = 0; pass < k; pass++) {
               for (i = 0; i < n; i++) {
                  x.xR[i] = randommid();
               }
               mincgrestartfrom(&state, &x);
               while (mincgiteration(&state)) {
                  testmincgunit_calclowrank(&state, n, vs, &d, &v, &vd, &x0);
               }
               mincgresults(&state, &x, &rep);
               cntg1 += rep.iterationscount;
               *err = *err || rep.terminationtype <= 0;
            }
         // Compare
            *err = *err || cntb1 < cntg1;
         }
      }
   // Preconditioner test 3.
   //
   // If
   // * B2 is default preconditioner with non-unit scale S[i]=1/sqrt(h[i])
   // * G2 is scale-based preconditioner with non-unit scale S[i]=1/sqrt(h[i])
   // then B2 is worse than G2.
   // "Worse" means more iterations to converge.
      for (n = 10; n <= 15; n++) {
         ae_vector_set_length(&x, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 0.0;
         }
         mincgcreate(n, &x, &state);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = 1 / sqrt(2 * pow((double)(i * i + 1), 2.0) * (0.8 + 0.4 * randomreal()));
         }
         mincgsetprecdefault(&state);
         mincgsetscale(&state, &s);
         cntb2 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            mincgrestartfrom(&state, &x);
            while (mincgiteration(&state)) {
               testmincgunit_calciip2(&state, n);
            }
            mincgresults(&state, &x, &rep);
            cntb2 += rep.iterationscount;
            *err = *err || rep.terminationtype <= 0;
         }
         mincgsetprecscale(&state);
         mincgsetscale(&state, &s);
         cntg2 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            mincgrestartfrom(&state, &x);
            while (mincgiteration(&state)) {
               testmincgunit_calciip2(&state, n);
            }
            mincgresults(&state, &x, &rep);
            cntg2 += rep.iterationscount;
            *err = *err || rep.terminationtype <= 0;
         }
         *err = *err || cntb2 < cntg2;
      }
   }
   ae_frame_leave();
}

// This function tests report of "non-C1" test #0 for task #0
// given by matrix A.
//
// On failure sets error flag.
static void testmincgunit_testoptguardc1test0reportfortask0(bool *err, optguardnonc1test0report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool hasc1discontinuities;
   if (rep->positive) {
   // Check positive report, first checks
      set_error_flag(err, rep->fidx != 0, __FILE__, __LINE__, "testmincgunit.ap:1770");
      set_error_flag(err, rep->n != n, __FILE__, __LINE__, "testmincgunit.ap:1771");
      set_error_flag(err, !(0 <= rep->stpidxa), __FILE__, __LINE__, "testmincgunit.ap:1772");
      set_error_flag(err, !(rep->stpidxa < rep->stpidxb), __FILE__, __LINE__, "testmincgunit.ap:1773");
      set_error_flag(err, !(rep->stpidxb < rep->cnt), __FILE__, __LINE__, "testmincgunit.ap:1774");
      set_error_flag(err, rep->x0.cnt != rep->n, __FILE__, __LINE__, "testmincgunit.ap:1775");
      set_error_flag(err, rep->d.cnt != rep->n, __FILE__, __LINE__, "testmincgunit.ap:1776");
      set_error_flag(err, rep->stp.cnt != rep->cnt, __FILE__, __LINE__, "testmincgunit.ap:1777");
      set_error_flag(err, rep->f.cnt != rep->cnt, __FILE__, __LINE__, "testmincgunit.ap:1778");
      set_error_flag(err, !isfinitevector(&rep->x0, n), __FILE__, __LINE__, "testmincgunit.ap:1779");
      set_error_flag(err, !isfinitevector(&rep->d, n), __FILE__, __LINE__, "testmincgunit.ap:1780");
      set_error_flag(err, !isfinitevector(&rep->stp, rep->cnt), __FILE__, __LINE__, "testmincgunit.ap:1781");
      set_error_flag(err, !isfinitevector(&rep->f, rep->cnt), __FILE__, __LINE__, "testmincgunit.ap:1782");
      if (*err) {
         return;
      }
   // Check consistency of X0, D, Stp and F
      for (k = 0; k < rep->cnt - 1; k++) {
         set_error_flag(err, rep->stp.xR[k] >= rep->stp.xR[k + 1], __FILE__, __LINE__, "testmincgunit.ap:1790");
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += fabs(vv);
         }
         set_error_flag(err, fabs(v - rep->f.xR[k]) > 1.0E-6 * rmax2(fabs(v), 1.0), __FILE__, __LINE__, "testmincgunit.ap:1803");
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      set_error_flag(err, !hasc1discontinuities, __FILE__, __LINE__, "testmincgunit.ap:1821");
   } else {
   // Check negative report: fields must be empty
      set_error_flag(err, rep->stpidxa != -1, __FILE__, __LINE__, "testmincgunit.ap:1828");
      set_error_flag(err, rep->stpidxb != -1, __FILE__, __LINE__, "testmincgunit.ap:1829");
      set_error_flag(err, rep->fidx != -1, __FILE__, __LINE__, "testmincgunit.ap:1830");
      set_error_flag(err, rep->cnt != 0, __FILE__, __LINE__, "testmincgunit.ap:1831");
      set_error_flag(err, rep->n != 0, __FILE__, __LINE__, "testmincgunit.ap:1832");
      set_error_flag(err, rep->x0.cnt != 0, __FILE__, __LINE__, "testmincgunit.ap:1833");
      set_error_flag(err, rep->d.cnt != 0, __FILE__, __LINE__, "testmincgunit.ap:1834");
      set_error_flag(err, rep->stp.cnt != 0, __FILE__, __LINE__, "testmincgunit.ap:1835");
      set_error_flag(err, rep->f.cnt != 0, __FILE__, __LINE__, "testmincgunit.ap:1836");
   }
}

// This function tests report of "non-C1" test #1 for task #0
// given by matrix A.
//
// On failure sets error flag.
static void testmincgunit_testoptguardc1test1reportfortask0(bool *err, optguardnonc1test1report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool tooclose;
   bool hasc1discontinuities;
   if (rep->positive) {
   // Check positive report, first checks
      set_error_flag(err, rep->fidx != 0, __FILE__, __LINE__, "testmincgunit.ap:1864");
      set_error_flag(err, rep->vidx < 0, __FILE__, __LINE__, "testmincgunit.ap:1865");
      set_error_flag(err, rep->vidx > n, __FILE__, __LINE__, "testmincgunit.ap:1866");
      set_error_flag(err, rep->n != n, __FILE__, __LINE__, "testmincgunit.ap:1867");
      set_error_flag(err, !(0 <= rep->stpidxa), __FILE__, __LINE__, "testmincgunit.ap:1868");
      set_error_flag(err, !(rep->stpidxa < rep->stpidxb), __FILE__, __LINE__, "testmincgunit.ap:1869");
      set_error_flag(err, !(rep->stpidxb < rep->cnt), __FILE__, __LINE__, "testmincgunit.ap:1870");
      set_error_flag(err, rep->x0.cnt != rep->n, __FILE__, __LINE__, "testmincgunit.ap:1871");
      set_error_flag(err, rep->d.cnt != rep->n, __FILE__, __LINE__, "testmincgunit.ap:1872");
      set_error_flag(err, rep->stp.cnt != rep->cnt, __FILE__, __LINE__, "testmincgunit.ap:1873");
      set_error_flag(err, rep->g.cnt != rep->cnt, __FILE__, __LINE__, "testmincgunit.ap:1874");
      set_error_flag(err, !isfinitevector(&rep->x0, n), __FILE__, __LINE__, "testmincgunit.ap:1875");
      set_error_flag(err, !isfinitevector(&rep->d, n), __FILE__, __LINE__, "testmincgunit.ap:1876");
      set_error_flag(err, !isfinitevector(&rep->stp, rep->cnt), __FILE__, __LINE__, "testmincgunit.ap:1877");
      set_error_flag(err, !isfinitevector(&rep->g, rep->cnt), __FILE__, __LINE__, "testmincgunit.ap:1878");
      if (*err) {
         return;
      }
   // Check consistency of X0, D, Stp and G
      for (k = 0; k < rep->cnt - 1; k++) {
         set_error_flag(err, rep->stp.xR[k] >= rep->stp.xR[k + 1], __FILE__, __LINE__, "testmincgunit.ap:1886");
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         tooclose = false;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += sign(vv) * a->xyR[i][rep->vidx];
            tooclose = tooclose || fabs(vv) < 1.0E-4;
         }
         if (!tooclose) {
            set_error_flag(err, fabs(v - rep->g.xR[k]) > 1.0E-6 * rmax2(fabs(v), 1.0), __FILE__, __LINE__, "testmincgunit.ap:1900");
         }
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      tooclose = false;
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         tooclose = (tooclose || fabs(va) < 1.0E-8) || fabs(vb) < 1.0E-8;
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      if (!tooclose) {
         set_error_flag(err, !hasc1discontinuities, __FILE__, __LINE__, "testmincgunit.ap:1921");
      }
   } else {
   // Check negative report: fields must be empty
      set_error_flag(err, rep->stpidxa != -1, __FILE__, __LINE__, "testmincgunit.ap:1928");
      set_error_flag(err, rep->stpidxb != -1, __FILE__, __LINE__, "testmincgunit.ap:1929");
      set_error_flag(err, rep->fidx != -1, __FILE__, __LINE__, "testmincgunit.ap:1930");
      set_error_flag(err, rep->vidx != -1, __FILE__, __LINE__, "testmincgunit.ap:1931");
      set_error_flag(err, rep->cnt != 0, __FILE__, __LINE__, "testmincgunit.ap:1932");
      set_error_flag(err, rep->n != 0, __FILE__, __LINE__, "testmincgunit.ap:1933");
      set_error_flag(err, rep->x0.cnt != 0, __FILE__, __LINE__, "testmincgunit.ap:1934");
      set_error_flag(err, rep->d.cnt != 0, __FILE__, __LINE__, "testmincgunit.ap:1935");
      set_error_flag(err, rep->stp.cnt != 0, __FILE__, __LINE__, "testmincgunit.ap:1936");
      set_error_flag(err, rep->g.cnt != 0, __FILE__, __LINE__, "testmincgunit.ap:1937");
   }
}

// This function tests OptGuard
//
// On failure sets error flag.
static void testmincgunit_testoptguard(bool *wereerrors) {
   ae_frame _frame_block;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   double diffstep;
   ae_int_t pass;
   ae_int_t defecttype;
   bool failed;
   ae_int_t passcount;
   ae_int_t maxfails;
   ae_int_t failurecounter;
   ae_int_t maxc1test0fails;
   ae_int_t maxc1test1fails;
   ae_int_t c1test0fails;
   ae_int_t c1test1fails;
   double avgstr0len;
   double avglng0len;
   double avgstr1len;
   double avglng1len;
   ae_int_t varidx;
   ae_int_t skind;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(mincgstate, state);
   NewObj(mincgreport, rep);
   NewObj(optguardreport, ogrep);
   NewObj(optguardnonc1test0report, ognonc1test0strrep);
   NewObj(optguardnonc1test0report, ognonc1test0lngrep);
   NewObj(optguardnonc1test1report, ognonc1test1strrep);
   NewObj(optguardnonc1test1report, ognonc1test1lngrep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewMatrix(jactrue, 0, 0, DT_REAL);
   NewMatrix(jacdefect, 0, 0, DT_REAL);
   hqrndrandomize(&rs);
// Check that gradient verification is disabled by default:
// gradient checking for bad problem must return nothing
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = 1.0 + 0.1 * i;
   }
   spdmatrixrndcond(n, 1.0E3, &a);
   spdmatrixrndcond(n, 1.0E3, &a1);
   mincgcreate(n, &x0, &state);
   mincgsetcond(&state, 0.0, 0.0, 1.0E-9, 10);
   while (mincgiteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += 0.5 * state.x.xR[i] * v;
         }
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   mincgresults(&state, &x1, &rep);
   mincgoptguardresults(&state, &ogrep);
   set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testmincgunit.ap:1276");
   set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testmincgunit.ap:1277");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(wereerrors, ogrep.badgradxbase.cnt != 0, __FILE__, __LINE__, "testmincgunit.ap:1280");
   set_error_flag(wereerrors, ogrep.badgraduser.rows != 0, __FILE__, __LINE__, "testmincgunit.ap:1281");
   set_error_flag(wereerrors, ogrep.badgraduser.cols != 0, __FILE__, __LINE__, "testmincgunit.ap:1282");
   set_error_flag(wereerrors, ogrep.badgradnum.rows != 0, __FILE__, __LINE__, "testmincgunit.ap:1283");
   set_error_flag(wereerrors, ogrep.badgradnum.cols != 0, __FILE__, __LINE__, "testmincgunit.ap:1284");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(wereerrors, ogrep.badgradsuspected, __FILE__, __LINE__, "testmincgunit.ap:1287");
   set_error_flag(wereerrors, ogrep.badgradfidx != -1, __FILE__, __LINE__, "testmincgunit.ap:1288");
   set_error_flag(wereerrors, ogrep.badgradvidx != -1, __FILE__, __LINE__, "testmincgunit.ap:1289");
// Test that C0/C1 continuity monitoring is disabled by default;
// we solve nonsmooth problem and test that nothing is returned
// by OptGuard.
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = hqrndnormal(&rs);
   }
   ae_matrix_set_length(&a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a.xyR[i][j] = hqrndnormal(&rs);
      }
   }
   mincgcreate(n, &x0, &state);
   mincgsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
   while (mincgiteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += fabs(v);
            v = (double)sign(v);
            for (j = 0; j < n; j++) {
               state.g.xR[j] += v * a.xyR[i][j];
            }
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   mincgresults(&state, &x1, &rep);
   mincgoptguardresults(&state, &ogrep);
   set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testmincgunit.ap:1329");
   set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testmincgunit.ap:1330");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testmincgunit.ap:1333");
   set_error_flag(wereerrors, ogrep.nonc1suspected, __FILE__, __LINE__, "testmincgunit.ap:1334");
   set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testmincgunit.ap:1335");
   set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testmincgunit.ap:1336");
   set_error_flag(wereerrors, ogrep.nonc1fidx >= 0, __FILE__, __LINE__, "testmincgunit.ap:1337");
   set_error_flag(wereerrors, ogrep.nonc1test0positive, __FILE__, __LINE__, "testmincgunit.ap:1338");
   set_error_flag(wereerrors, ogrep.nonc1test1positive, __FILE__, __LINE__, "testmincgunit.ap:1339");
// Test gradient checking functionality, try various
// defect types:
// * accidental zeroing of some gradient component
// * accidental addition of 1.0 to some component
// * accidental multiplication by 2.0
// Try distorting both target and constraints.
   diffstep = 0.001;
   n = 10;
   for (skind = 0; skind <= 1; skind++) {
      for (defecttype = -1; defecttype <= 2; defecttype++) {
         varidx = hqrnduniformi(&rs, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, skind * (30 * hqrnduniformr(&rs) - 15));
            x0.xR[i] = (1.0 + 0.1 * i) * s.xR[i];
         }
         spdmatrixrndcond(n, 1.0E3, &a);
         spdmatrixrndcond(n, 1.0E3, &a1);
         mincgcreate(n, &x0, &state);
         mincgoptguardgradient(&state, diffstep);
         mincgsetcond(&state, 0.0, 0.0, 1.0E-9, 10);
         mincgsetscale(&state, &s);
         while (mincgiteration(&state)) {
            if (state.needfg) {
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += state.x.xR[j] / s.xR[j] * a.xyR[i][j];
                  }
                  state.f += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                  state.g.xR[i] = v;
               }
               if (defecttype == 0) {
                  state.g.xR[varidx] = 0.0;
               }
               if (defecttype == 1) {
                  state.g.xR[varidx]++;
               }
               if (defecttype == 2) {
                  state.g.xR[varidx] *= 2;
               }
               for (i = 0; i < n; i++) {
                  state.g.xR[i] /= s.xR[i];
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         mincgresults(&state, &x1, &rep);
         mincgoptguardresults(&state, &ogrep);
      // Check that something is returned
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testmincgunit.ap:1403");
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testmincgunit.ap:1404");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Compute reference values for true and spoiled Jacobian at X0
         set_error_flag(wereerrors, !isfinitevector(&ogrep.badgradxbase, n), __FILE__, __LINE__, "testmincgunit.ap:1411");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         ae_matrix_set_length(&jactrue, 1, n);
         ae_matrix_set_length(&jacdefect, 1, n);
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += ogrep.badgradxbase.xR[j] / s.xR[j] * a.xyR[i][j];
            }
            jactrue.xyR[0][i] = v;
            jacdefect.xyR[0][i] = v;
         }
         if (defecttype == 0) {
            jacdefect.xyR[0][varidx] = 0.0;
         }
         if (defecttype == 1) {
            jacdefect.xyR[0][varidx]++;
         }
         if (defecttype == 2) {
            jacdefect.xyR[0][varidx] *= 2;
         }
         for (i = 0; i < n; i++) {
            jactrue.xyR[0][i] /= s.xR[i];
            jacdefect.xyR[0][i] /= s.xR[i];
         }
      // Check OptGuard report
         set_error_flag(wereerrors, !apservisfinitematrix(&ogrep.badgraduser, 1, n), __FILE__, __LINE__, "testmincgunit.ap:1439");
         set_error_flag(wereerrors, !apservisfinitematrix(&ogrep.badgradnum, 1, n), __FILE__, __LINE__, "testmincgunit.ap:1440");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         if (defecttype >= 0) {
            set_error_flag(wereerrors, !ogrep.badgradsuspected, __FILE__, __LINE__, "testmincgunit.ap:1445");
            set_error_flag(wereerrors, ogrep.badgradfidx != 0, __FILE__, __LINE__, "testmincgunit.ap:1446");
            set_error_flag(wereerrors, ogrep.badgradvidx != varidx, __FILE__, __LINE__, "testmincgunit.ap:1447");
         } else {
            set_error_flag(wereerrors, ogrep.badgradsuspected, __FILE__, __LINE__, "testmincgunit.ap:1451");
            set_error_flag(wereerrors, ogrep.badgradfidx != -1, __FILE__, __LINE__, "testmincgunit.ap:1452");
            set_error_flag(wereerrors, ogrep.badgradvidx != -1, __FILE__, __LINE__, "testmincgunit.ap:1453");
         }
         for (j = 0; j < n; j++) {
            set_error_flag(wereerrors, fabs(jactrue.xyR[0][j] - ogrep.badgradnum.xyR[0][j]) > 0.01 / s.xR[j], __FILE__, __LINE__, "testmincgunit.ap:1457");
            set_error_flag(wereerrors, fabs(jacdefect.xyR[0][j] - ogrep.badgraduser.xyR[0][j]) > 0.01 / s.xR[j], __FILE__, __LINE__, "testmincgunit.ap:1458");
         }
      }
   }
// A test for detection of C1 continuity violations in the target.
//
// Target function is a sum of |(x,c_i)| for i=1..N.
// No constraints is present.
// Analytic gradient is provided.
//
// OptGuard should be able to detect violations in more than
// 99.9% of runs; it means that 100 runs should have no more than 4
// failures in all cases (even after multiple repeated tests; according
// to the binomial distribution quantiles).
//
// We select some N and perform exhaustive search for this N.
   passcount = 100;
   maxfails = 4;
   maxc1test0fails = 10;
   maxc1test1fails = 10;
   n = 1 + hqrnduniformi(&rs, 10);
   failurecounter = 0;
   c1test0fails = 0;
   c1test1fails = 0;
   avgstr0len = 0.0;
   avglng0len = 0.0;
   avgstr1len = 0.0;
   avglng1len = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = pow(2.0, hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      mincgcreate(n, &x0, &state);
      mincgsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      mincgsetscale(&state, &s);
      mincgoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testmincgunit_maxoptguardlevel));
      while (mincgiteration(&state)) {
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.g.xR[i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
               v = (double)sign(v);
               for (j = 0; j < n; j++) {
                  state.g.xR[j] += v * a.xyR[i][j];
               }
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      mincgresults(&state, &x1, &rep);
      mincgoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testmincgunit.ap:1539");
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testmincgunit.ap:1540");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
   // Check generic OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testmincgunit.ap:1551");
      set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testmincgunit.ap:1552");
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   // Check C1 continuity test #0
      mincgoptguardnonc1test0results(&state, &ognonc1test0strrep, &ognonc1test0lngrep);
      mincgoptguardnonc1test1results(&state, &ognonc1test1strrep, &ognonc1test1lngrep);
      if (ogrep.nonc1test0positive) {
         set_error_flag(wereerrors, !ogrep.nonc1suspected, __FILE__, __LINE__, "testmincgunit.ap:1567");
         set_error_flag(wereerrors, !ognonc1test0strrep.positive, __FILE__, __LINE__, "testmincgunit.ap:1568");
         set_error_flag(wereerrors, !ognonc1test0lngrep.positive, __FILE__, __LINE__, "testmincgunit.ap:1569");
         set_error_flag(wereerrors, ogrep.nonc1fidx != 0, __FILE__, __LINE__, "testmincgunit.ap:1570");
         testmincgunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0strrep, &a, n);
         testmincgunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0lngrep, &a, n);
         avgstr0len += (double)ognonc1test0strrep.cnt / passcount;
         avglng0len += (double)ognonc1test0lngrep.cnt / passcount;
      } else {
         set_error_flag(wereerrors, ognonc1test0strrep.positive, __FILE__, __LINE__, "testmincgunit.ap:1578");
         set_error_flag(wereerrors, ognonc1test0lngrep.positive, __FILE__, __LINE__, "testmincgunit.ap:1579");
         testmincgunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0strrep, &a, n);
         testmincgunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0lngrep, &a, n);
         c1test0fails++;
      }
      if (ogrep.nonc1test1positive) {
         set_error_flag(wereerrors, !ogrep.nonc1suspected, __FILE__, __LINE__, "testmincgunit.ap:1586");
         set_error_flag(wereerrors, !ognonc1test1strrep.positive, __FILE__, __LINE__, "testmincgunit.ap:1587");
         set_error_flag(wereerrors, !ognonc1test1lngrep.positive, __FILE__, __LINE__, "testmincgunit.ap:1588");
         set_error_flag(wereerrors, ogrep.nonc1fidx != 0, __FILE__, __LINE__, "testmincgunit.ap:1589");
         testmincgunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1strrep, &a, n);
         testmincgunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1lngrep, &a, n);
         avgstr1len += (double)ognonc1test1strrep.cnt / passcount;
         avglng1len += (double)ognonc1test1lngrep.cnt / passcount;
      } else {
         set_error_flag(wereerrors, ognonc1test1strrep.positive, __FILE__, __LINE__, "testmincgunit.ap:1597");
         set_error_flag(wereerrors, ognonc1test1lngrep.positive, __FILE__, __LINE__, "testmincgunit.ap:1598");
         testmincgunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1strrep, &a, n);
         testmincgunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1lngrep, &a, n);
         c1test1fails++;
      }
   }
   set_error_flag(wereerrors, failurecounter > maxfails, __FILE__, __LINE__, "testmincgunit.ap:1605");
   set_error_flag(wereerrors, c1test0fails > maxc1test0fails, __FILE__, __LINE__, "testmincgunit.ap:1606");
   set_error_flag(wereerrors, c1test1fails > maxc1test1fails, __FILE__, __LINE__, "testmincgunit.ap:1607");
   set_error_flag(wereerrors, avglng0len <= avgstr0len, __FILE__, __LINE__, "testmincgunit.ap:1608");
   set_error_flag(wereerrors, avglng1len <= avgstr1len, __FILE__, __LINE__, "testmincgunit.ap:1609");
// Detection of C1 continuity violations in the target under numerical differentiation:
// * target function is a sum of |(x,c_i)| for i=1..N.
// * no constraints is present.
// * analytic gradient is provided.
//
// OptGuard should always be able to detect violations in more than
// 99% of runs (note: reduced strength when compared with analytic gradient);
// it means that 100 runs should have no more than 10 failures in all cases
// (even after multiple repeated tests; according to the binomial distribution
// quantiles).
//
// We select some N and perform exhaustive search for this N.
   diffstep = 0.0001;
   passcount = 100;
   maxfails = 10;
   n = 1 + hqrnduniformi(&rs, 10);
   failurecounter = 0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 0.01 * pow(2.0, 0.33 * hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      mincgcreatef(n, &x0, diffstep, &state);
      mincgsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      mincgoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testmincgunit_maxoptguardlevel));
      while (mincgiteration(&state)) {
         if (state.needf) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      mincgresults(&state, &x1, &rep);
      mincgoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testmincgunit.ap:1674");
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testmincgunit.ap:1675");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
   // Check OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testmincgunit.ap:1686");
      set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testmincgunit.ap:1687");
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   }
   set_error_flag(wereerrors, failurecounter > maxfails, __FILE__, __LINE__, "testmincgunit.ap:1695");
// Make sure than no false positives are reported for larger
// problems where numerical noise can be an issue:
// * N=100 dimensions
// * positive-definite quadratic programming problem
// * upper limit on iterations count, MaxIts=25
// We simply test that OptGuard does not return error code.
   n = 100;
   spdmatrixrndcond(n, 1.0E2, &a);
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = hqrndnormal(&rs);
      x0.xR[i] = pow(2.0, hqrndnormal(&rs));
   }
   mincgcreate(n, &x0, &state);
   mincgoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testmincgunit_maxoptguardlevel));
   mincgsetcond(&state, 0.0, 0.0, 1.0E-9, 25);
   while (mincgiteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += b.xR[i] * state.x.xR[i];
            state.g.xR[i] = b.xR[i];
            for (j = 0; j < n; j++) {
               state.f += 0.5 * state.x.xR[i] * a.xyR[i][j] * state.x.xR[j];
               state.g.xR[i] += a.xyR[i][j] * state.x.xR[j];
            }
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   mincgresults(&state, &x1, &rep);
   set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testmincgunit.ap:1738");
   set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testmincgunit.ap:1739");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   mincgoptguardresults(&state, &ogrep);
   set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testmincgunit.ap:1743");
   ae_frame_leave();
}

bool testmincg(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   bool referror;
   bool eqerror;
   bool linerror1;
   bool linerror2;
   bool restartserror;
   bool precerror;
   bool converror;
   bool othererrors;
   bool optguarderr;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_int_t cgtype;
   ae_int_t difftype;
   double diffstep;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(xe, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(diagh, 0, DT_REAL);
   NewObj(mincgstate, state);
   NewObj(mincgreport, rep);
   waserrors = false;
   referror = false;
   linerror1 = false;
   linerror2 = false;
   eqerror = false;
   converror = false;
   restartserror = false;
   othererrors = false;
   precerror = false;
   testmincgunit_testpreconditioning(&precerror);
   testother(&othererrors);
   for (difftype = 0; difftype <= 1; difftype++) {
      for (cgtype = -1; cgtype <= 1; cgtype++) {
      // Reference problem
         ae_vector_set_length(&x, 2 + 1);
         n = 3;
         diffstep = 1.0E-6;
         x.xR[0] = 50.0 * randommid();
         x.xR[1] = 50.0 * randommid();
         x.xR[2] = 50.0 * randommid();
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcgtype(&state, cgtype);
         while (mincgiteration(&state)) {
            if (state.needf || state.needfg) {
               state.f = sqr(state.x.xR[0] - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
            }
            if (state.needfg) {
               state.g.xR[0] = 2 * (state.x.xR[0] - 2) + 2 * (state.x.xR[0] - state.x.xR[2]);
               state.g.xR[1] = 2 * state.x.xR[1];
               state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
            }
         }
         mincgresults(&state, &x, &rep);
         referror = (((referror || rep.terminationtype <= 0) || fabs(x.xR[0] - 2) > 0.001) || fabs(x.xR[1]) > 0.001) || fabs(x.xR[2] - 2) > 0.001;
      // F2 problem with restarts:
      // * make several iterations and restart BEFORE termination
      // * iterate and restart AFTER termination
      //
      // NOTE: step is bounded from above to avoid premature convergence
         ae_vector_set_length(&x, 3);
         n = 3;
         diffstep = 1.0E-6;
         x.xR[0] = 10 + 10 * randomreal();
         x.xR[1] = 10 + 10 * randomreal();
         x.xR[2] = 10 + 10 * randomreal();
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcgtype(&state, cgtype);
         mincgsetstpmax(&state, 0.1);
         mincgsetcond(&state, 0.0000001, 0.0, 0.0, 0);
         for (i = 0; i <= 10; i++) {
            if (!mincgiteration(&state)) {
               break;
            }
            testmincgunit_testfunc2(&state);
         }
         x.xR[0] = 10 + 10 * randomreal();
         x.xR[1] = 10 + 10 * randomreal();
         x.xR[2] = 10 + 10 * randomreal();
         mincgrestartfrom(&state, &x);
         while (mincgiteration(&state)) {
            testmincgunit_testfunc2(&state);
         }
         mincgresults(&state, &x, &rep);
         restartserror = (((restartserror || rep.terminationtype <= 0) || fabs(x.xR[0] - log(2.0)) > 0.01) || fabs(x.xR[1]) > 0.01) || fabs(x.xR[2] - log(2.0)) > 0.01;
         x.xR[0] = 10 + 10 * randomreal();
         x.xR[1] = 10 + 10 * randomreal();
         x.xR[2] = 10 + 10 * randomreal();
         mincgrestartfrom(&state, &x);
         while (mincgiteration(&state)) {
            testmincgunit_testfunc2(&state);
         }
         mincgresults(&state, &x, &rep);
         restartserror = (((restartserror || rep.terminationtype <= 0) || fabs(x.xR[0] - log(2.0)) > 0.01) || fabs(x.xR[1]) > 0.01) || fabs(x.xR[2] - log(2.0)) > 0.01;
      // 1D problem #1
         ae_vector_set_length(&x, 0 + 1);
         n = 1;
         diffstep = 1.0E-6;
         x.xR[0] = 50.0 * randommid();
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcgtype(&state, cgtype);
         while (mincgiteration(&state)) {
            if (state.needf || state.needfg) {
               state.f = -cos(state.x.xR[0]);
            }
            if (state.needfg) {
               state.g.xR[0] = sin(state.x.xR[0]);
            }
         }
         mincgresults(&state, &x, &rep);
         linerror1 = (linerror1 || rep.terminationtype <= 0) || fabs(x.xR[0] / pi - round(x.xR[0] / pi)) > 0.001;
      // 1D problem #2
         ae_vector_set_length(&x, 0 + 1);
         n = 1;
         diffstep = 1.0E-6;
         x.xR[0] = 50.0 * randommid();
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcgtype(&state, cgtype);
         while (mincgiteration(&state)) {
            if (state.needf || state.needfg) {
               state.f = sqr(state.x.xR[0]) / (1 + sqr(state.x.xR[0]));
            }
            if (state.needfg) {
               state.g.xR[0] = (2 * state.x.xR[0] * (1 + sqr(state.x.xR[0])) - sqr(state.x.xR[0]) * 2 * state.x.xR[0]) / sqr(1 + sqr(state.x.xR[0]));
            }
         }
         mincgresults(&state, &x, &rep);
         linerror2 = (linerror2 || rep.terminationtype <= 0) || fabs(x.xR[0]) > 0.001;
      // Linear equations
         diffstep = 1.0E-6;
         for (n = 1; n <= 10; n++) {
         // Prepare task
            ae_matrix_set_length(&a, n - 1 + 1, n - 1 + 1);
            ae_vector_set_length(&x, n - 1 + 1);
            ae_vector_set_length(&xe, n - 1 + 1);
            ae_vector_set_length(&b, n - 1 + 1);
            for (i = 0; i < n; i++) {
               xe.xR[i] = randommid();
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = randommid();
               }
               a.xyR[i][i] += 3 * sign(a.xyR[i][i]);
            }
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xe.xR, 1, n);
               b.xR[i] = v;
            }
         // Solve task
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            if (difftype == 0) {
               mincgcreate(n, &x, &state);
            }
            if (difftype == 1) {
               mincgcreatef(n, &x, diffstep, &state);
            }
            mincgsetcgtype(&state, cgtype);
            while (mincgiteration(&state)) {
               if (state.needf || state.needfg) {
                  state.f = 0.0;
               }
               if (state.needfg) {
                  for (i = 0; i < n; i++) {
                     state.g.xR[i] = 0.0;
                  }
               }
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
                  if (state.needf || state.needfg) {
                     state.f += sqr(v - b.xR[i]);
                  }
                  if (state.needfg) {
                     for (j = 0; j < n; j++) {
                        state.g.xR[j] += 2 * (v - b.xR[i]) * a.xyR[i][j];
                     }
                  }
               }
            }
            mincgresults(&state, &x, &rep);
            eqerror = eqerror || rep.terminationtype <= 0;
            for (i = 0; i < n; i++) {
               eqerror = eqerror || fabs(x.xR[i] - xe.xR[i]) > 0.001;
            }
         }
      // Testing convergence properties
         diffstep = 1.0E-6;
         n = 3;
         ae_vector_set_length(&x, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 3.0 * randommid();
         }
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcond(&state, 0.001, 0.0, 0.0, 0);
         mincgsetcgtype(&state, cgtype);
         while (mincgiteration(&state)) {
            testmincgunit_testfunc3(&state);
         }
         mincgresults(&state, &x, &rep);
         converror = converror || rep.terminationtype != 4;
         for (i = 0; i < n; i++) {
            x.xR[i] = 3.0 * randommid();
         }
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcond(&state, 0.0, 0.001, 0.0, 0);
         mincgsetcgtype(&state, cgtype);
         while (mincgiteration(&state)) {
            testmincgunit_testfunc3(&state);
         }
         mincgresults(&state, &x, &rep);
         converror = converror || rep.terminationtype != 1;
         for (i = 0; i < n; i++) {
            x.xR[i] = 3.0 * randommid();
         }
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcond(&state, 0.0, 0.0, 0.001, 0);
         mincgsetcgtype(&state, cgtype);
         while (mincgiteration(&state)) {
            testmincgunit_testfunc3(&state);
         }
         mincgresults(&state, &x, &rep);
         converror = converror || rep.terminationtype != 2;
         for (i = 0; i < n; i++) {
            x.xR[i] = randommid();
         }
         if (difftype == 0) {
            mincgcreate(n, &x, &state);
         }
         if (difftype == 1) {
            mincgcreatef(n, &x, diffstep, &state);
         }
         mincgsetcond(&state, 0.0, 0.0, 0.0, 10);
         mincgsetcgtype(&state, cgtype);
         while (mincgiteration(&state)) {
            testmincgunit_testfunc3(&state);
         }
         mincgresults(&state, &x, &rep);
         converror = converror || !((rep.terminationtype == 5 && rep.iterationscount == 10) || rep.terminationtype == 7);
      }
   }
//  Test for MinCGGradientCheck
   optguarderr = false;
   testmincgunit_testoptguard(&optguarderr);
// end
   waserrors = (((((((referror || eqerror) || linerror1) || linerror2) || converror) || othererrors) || restartserror) || precerror) || optguarderr;
   if (!silent) {
      printf("TESTING CG OPTIMIZATION\n");
      printf("REFERENCE PROBLEM:                        ");
      if (referror) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("LIN-1 PROBLEM:                            ");
      if (linerror1) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("LIN-2 PROBLEM:                            ");
      if (linerror2) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("LINEAR EQUATIONS:                         ");
      if (eqerror) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("RESTARTS:                                 ");
      if (restartserror) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("PRECONDITIONING:                          ");
      if (precerror) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("CONVERGENCE PROPERTIES:                   ");
      if (converror) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("OTHER PROPERTIES:                         ");
      if (othererrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("OPTGUARD:                                 ");
      if (optguarderr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === minlp testing unit ===
static const ae_int_t testminlpunit_solverscount = 2;

// This function validates solution returned by LP solver. It returns  primal
// and dual feasibility errors for this solution.
//
// SolverType:
// * 0 for dual simplex solver; additional test relying on explicit information
//   about constraint statuses is performed
// * 1 for interior point method; only straightforward dual  feasibility is
//   tested
//
static void testminlpunit_validatesolution(RVector *c, RVector *bndl, RVector *bndu, ae_int_t n, RMatrix *a, RVector *al, RVector *au, ae_int_t m, RVector *xcand, minlpreport *rep, ae_int_t solvertype, double *errprim, double *errdual, double *errslack) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   bool checkstats;
   ae_frame_make(&_frame_block);
   *errprim = 0;
   *errdual = 0;
   *errslack = 0;
   NewVector(d, 0, DT_REAL);
   checkstats = solvertype == 0;
   *errprim = 0.0;
   *errdual = 0.0;
   *errslack = 0.0;
// Test primal feasibility
   for (i = 0; i < n; i++) {
      if (isfinite(bndl->xR[i])) {
         *errprim = rmax2(*errprim, bndl->xR[i] - xcand->xR[i]);
      }
      if (isfinite(bndu->xR[i])) {
         *errprim = rmax2(*errprim, xcand->xR[i] - bndu->xR[i]);
      }
   }
   for (i = 0; i < m; i++) {
      v = rdotvr(n, xcand, a, i);
      if (isfinite(al->xR[i])) {
         *errprim = rmax2(*errprim, al->xR[i] - v);
      }
      if (isfinite(au->xR[i])) {
         *errprim = rmax2(*errprim, v - au->xR[i]);
      }
   }
// Test dual feasibility using Lagrange multipliers
   ae_vector_set_length(&d, n);
   for (i = 0; i < n; i++) {
      d.xR[i] = c->xR[i];
   }
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         d.xR[j] += rep->laglc.xR[i] * a->xyR[i][j];
      }
   }
   for (i = 0; i < n; i++) {
      d.xR[i] += rep->lagbc.xR[i];
   }
   *errdual = rmax2(*errdual, rmaxabsv(n, &d));
// Test complementary slackness
   for (i = 0; i < n; i++) {
      if (isfinite(bndl->xR[i])) {
         *errslack = rmax2(*errslack, rmax2(xcand->xR[i] - bndl->xR[i], 0.0) * rmax2(-rep->lagbc.xR[i], 0.0));
      }
      if (isfinite(bndu->xR[i])) {
         *errslack = rmax2(*errslack, rmax2(bndu->xR[i] - xcand->xR[i], 0.0) * rmax2(rep->lagbc.xR[i], 0.0));
      }
   }
   for (i = 0; i < m; i++) {
      v = rdotvr(n, xcand, a, i);
      if (isfinite(al->xR[i])) {
         *errslack = rmax2(*errslack, rmax2(v - al->xR[i], 0.0) * rmax2(-rep->laglc.xR[i], 0.0));
      }
      if (isfinite(au->xR[i])) {
         *errslack = rmax2(*errslack, rmax2(au->xR[i] - v, 0.0) * rmax2(rep->laglc.xR[i], 0.0));
      }
   }
// Test dual feasibility using Stats[] array
   if (checkstats) {
   }
   ae_frame_leave();
}

// This function selects random LP solver
static void testminlpunit_selectrandomsolver(minlpstate *state) {
   ae_int_t k;
   k = randominteger(2);
   if (k == 0) {
      minlpsetalgodss(state, 0.0);
   }
   if (k == 1) {
      minlpsetalgoipm(state, 0.0);
   }
}

// This function selects specific LP solver.
//
// Reg parameter is used to regularize IPM algo, ignore for DSS
static void testminlpunit_selectsolver(minlpstate *state, ae_int_t st) {
   if (st == 0) {
      minlpsetalgodss(state, 0.0);
      return;
   }
   if (st == 1) {
      minlpsetalgoipm(state, 0.0);
      return;
   }
   ae_assert(false, "SelectSolver: unexpected solver");
}

// Shifts nonzero elements of C[] away from zero
static void testminlpunit_shiftfromzero(RVector *c, ae_int_t n, double s) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      c->xR[i] += sign(c->xR[i]) * s;
   }
}

// Basic tests; sets error flag on failure, does not touch it on success.
static void testminlpunit_basictests(bool *err) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t ccnt;
   ae_int_t pass;
   double v0;
   double v1;
   double errslack;
   double primtol;
   double dualtol;
   double slacktol;
   ae_int_t solvertype;
   ae_frame_make(&_frame_block);
   NewObj(minlpstate, state);
   NewObj(minlpreport, rep);
   NewVector(c, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(al, 0, DT_REAL);
   NewVector(au, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   primtol = 1.0E-4;
   dualtol = 1.0E-4;
   slacktol = 1.0E-4;
   hqrndrandomize(&rs);
// Test default state of the solver
   for (pass = 1; pass <= 5; pass++) {
      n = 1 + hqrnduniformi(&rs, 10);
      minlpcreate(n, &state);
      testminlpunit_selectrandomsolver(&state);
      minlpoptimize(&state);
      minlpresults(&state, &x, &rep);
      set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:100");
      set_error_flag(err, x.cnt < n, __FILE__, __LINE__, "testminlpunit.ap:101");
      if (*err) {
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(err, x.xR[i] != 0.0, __FILE__, __LINE__, "testminlpunit.ap:105");
      }
   }
// Test box constrained problems without linear constraints
   for (n = 1; n <= 10; n++) {
      for (pass = 1; pass <= 20; pass++) {
         solvertype = hqrnduniformi(&rs, testminlpunit_solverscount);
         ae_vector_set_length(&c, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
      // Feasible bounded problems
         for (i = 0; i < n; i++) {
            c.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = hqrndnormal(&rs);
            bndu.xR[i] = bndl.xR[i] + hqrnduniformi(&rs, 3);
         }
         testminlpunit_shiftfromzero(&c, n, 0.01);
         minlpcreate(n, &state);
         testminlpunit_selectsolver(&state, solvertype);
         minlpsetcost(&state, &c);
         minlpsetbc(&state, &bndl, &bndu);
         minlpoptimize(&state);
         minlpresults(&state, &x, &rep);
         set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:135");
         set_error_flag(err, x.cnt < n, __FILE__, __LINE__, "testminlpunit.ap:136");
         if (*err) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(err, c.xR[i] > 0.0 && (x.xR[i] < bndl.xR[i] || x.xR[i] > bndl.xR[i] + primtol), __FILE__, __LINE__, "testminlpunit.ap:141");
            set_error_flag(err, c.xR[i] < 0.0 && (x.xR[i] > bndu.xR[i] || x.xR[i] < bndu.xR[i] - primtol), __FILE__, __LINE__, "testminlpunit.ap:142");
            set_error_flag(err, (c.xR[i] > 0.0 && solvertype == 0) && x.xR[i] != bndl.xR[i], __FILE__, __LINE__, "testminlpunit.ap:143");
            set_error_flag(err, (c.xR[i] < 0.0 && solvertype == 0) && x.xR[i] != bndu.xR[i], __FILE__, __LINE__, "testminlpunit.ap:144");
         }
         for (i = 0; i < n; i++) {
            c.xR[i] = hqrndnormal(&rs);
            v0 = hqrndnormal(&rs);
            v1 = hqrndnormal(&rs);
            bndl.xR[i] = rmin2(v0, v1);
            bndu.xR[i] = rmax2(v0, v1);
            if (c.xR[i] > 0.0) {
               bndu.xR[i] = +INFINITY;
            }
            if (c.xR[i] < 0.0) {
               bndl.xR[i] = -INFINITY;
            }
         }
         testminlpunit_shiftfromzero(&c, n, 0.01);
         minlpcreate(n, &state);
         testminlpunit_selectsolver(&state, solvertype);
         minlpsetcost(&state, &c);
         minlpsetbc(&state, &bndl, &bndu);
         minlpoptimize(&state);
         minlpresults(&state, &x, &rep);
         set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:166");
         set_error_flag(err, x.cnt < n, __FILE__, __LINE__, "testminlpunit.ap:167");
         if (*err) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(err, c.xR[i] > 0.0 && (x.xR[i] < bndl.xR[i] || x.xR[i] > bndl.xR[i] + primtol), __FILE__, __LINE__, "testminlpunit.ap:172");
            set_error_flag(err, c.xR[i] < 0.0 && (x.xR[i] > bndu.xR[i] || x.xR[i] < bndu.xR[i] - primtol), __FILE__, __LINE__, "testminlpunit.ap:173");
            set_error_flag(err, (c.xR[i] > 0.0 && solvertype == 0) && x.xR[i] != bndl.xR[i], __FILE__, __LINE__, "testminlpunit.ap:174");
            set_error_flag(err, (c.xR[i] < 0.0 && solvertype == 0) && x.xR[i] != bndu.xR[i], __FILE__, __LINE__, "testminlpunit.ap:175");
         }
      // Feasible bounded problems with zeros in cost vector
         for (i = 0; i < n; i++) {
            c.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = hqrndnormal(&rs);
            bndu.xR[i] = bndl.xR[i] + hqrnduniformi(&rs, 3);
         }
         testminlpunit_shiftfromzero(&c, n, 0.01);
         k = hqrnduniformi(&rs, n);
         c.xR[k] = 0.0;
         bndl.xR[k] = -INFINITY;
         bndu.xR[k] = +INFINITY;
         minlpcreate(n, &state);
         testminlpunit_selectsolver(&state, solvertype);
         minlpsetcost(&state, &c);
         minlpsetbc(&state, &bndl, &bndu);
         minlpoptimize(&state);
         minlpresults(&state, &x, &rep);
         set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:199");
         set_error_flag(err, x.cnt < n, __FILE__, __LINE__, "testminlpunit.ap:200");
         if (*err) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(err, c.xR[i] > 0.0 && (x.xR[i] < bndl.xR[i] || x.xR[i] > bndl.xR[i] + primtol), __FILE__, __LINE__, "testminlpunit.ap:205");
            set_error_flag(err, c.xR[i] < 0.0 && (x.xR[i] > bndu.xR[i] || x.xR[i] < bndu.xR[i] - primtol), __FILE__, __LINE__, "testminlpunit.ap:206");
            set_error_flag(err, (c.xR[i] > 0.0 && solvertype == 0) && x.xR[i] != bndl.xR[i], __FILE__, __LINE__, "testminlpunit.ap:207");
            set_error_flag(err, (c.xR[i] < 0.0 && solvertype == 0) && x.xR[i] != bndu.xR[i], __FILE__, __LINE__, "testminlpunit.ap:208");
         }
         set_error_flag(err, x.xR[k] != 0.0, __FILE__, __LINE__, "testminlpunit.ap:210");
         bndl.xR[k] = hqrndnormal(&rs);
         bndu.xR[k] = +INFINITY;
         minlpsetbc(&state, &bndl, &bndu);
         minlpoptimize(&state);
         minlpresults(&state, &x, &rep);
         set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:217");
         set_error_flag(err, x.cnt < n, __FILE__, __LINE__, "testminlpunit.ap:218");
         if (*err) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(err, c.xR[i] > 0.0 && (x.xR[i] < bndl.xR[i] || x.xR[i] > bndl.xR[i] + primtol), __FILE__, __LINE__, "testminlpunit.ap:223");
            set_error_flag(err, c.xR[i] < 0.0 && (x.xR[i] > bndu.xR[i] || x.xR[i] < bndu.xR[i] - primtol), __FILE__, __LINE__, "testminlpunit.ap:224");
            set_error_flag(err, (c.xR[i] > 0.0 && solvertype == 0) && x.xR[i] != bndl.xR[i], __FILE__, __LINE__, "testminlpunit.ap:225");
            set_error_flag(err, (c.xR[i] < 0.0 && solvertype == 0) && x.xR[i] != bndu.xR[i], __FILE__, __LINE__, "testminlpunit.ap:226");
         }
         set_error_flag(err, x.xR[k] < bndl.xR[k], __FILE__, __LINE__, "testminlpunit.ap:228");
         set_error_flag(err, solvertype == 0 && x.xR[k] != bndl.xR[k], __FILE__, __LINE__, "testminlpunit.ap:229");
         bndl.xR[k] = -INFINITY;
         bndu.xR[k] = hqrndnormal(&rs);
         minlpsetbc(&state, &bndl, &bndu);
         minlpoptimize(&state);
         minlpresults(&state, &x, &rep);
         set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:236");
         set_error_flag(err, x.cnt < n, __FILE__, __LINE__, "testminlpunit.ap:237");
         if (*err) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(err, c.xR[i] > 0.0 && (x.xR[i] < bndl.xR[i] || x.xR[i] > bndl.xR[i] + primtol), __FILE__, __LINE__, "testminlpunit.ap:242");
            set_error_flag(err, c.xR[i] < 0.0 && (x.xR[i] > bndu.xR[i] || x.xR[i] < bndu.xR[i] - primtol), __FILE__, __LINE__, "testminlpunit.ap:243");
            set_error_flag(err, (c.xR[i] > 0.0 && solvertype == 0) && x.xR[i] != bndl.xR[i], __FILE__, __LINE__, "testminlpunit.ap:244");
            set_error_flag(err, (c.xR[i] < 0.0 && solvertype == 0) && x.xR[i] != bndu.xR[i], __FILE__, __LINE__, "testminlpunit.ap:245");
         }
         set_error_flag(err, x.xR[k] > bndu.xR[k], __FILE__, __LINE__, "testminlpunit.ap:247");
         set_error_flag(err, solvertype == 0 && x.xR[k] != bndu.xR[k], __FILE__, __LINE__, "testminlpunit.ap:248");
      // Infeasible problems
         ae_vector_set_length(&x, 0);
         for (i = 0; i < n; i++) {
            c.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = hqrndnormal(&rs);
            bndu.xR[i] = bndl.xR[i] + hqrnduniformi(&rs, 3);
         }
         k = hqrnduniformi(&rs, n);
         bndu.xR[k] = bndl.xR[k] - 1;
         minlpcreate(n, &state);
         testminlpunit_selectsolver(&state, solvertype);
         minlpsetcost(&state, &c);
         minlpsetbc(&state, &bndl, &bndu);
         minlpoptimize(&state);
         minlpresults(&state, &x, &rep);
         set_error_flag(err, rep.terminationtype != -3, __FILE__, __LINE__, "testminlpunit.ap:268");
         set_error_flag(err, x.cnt < n, __FILE__, __LINE__, "testminlpunit.ap:269");
         if (*err) {
            ae_frame_leave();
            return;
         }
      // Unbounded problems
      //
      // NOTE: we solve it without regularization, because with regularizer any LP problem is bounded
         if (solvertype != 1) {
            ae_vector_set_length(&x, 0);
            for (i = 0; i < n; i++) {
               do {
                  c.xR[i] = hqrndnormal(&rs);
               } while (c.xR[i] == 0.0);
               bndl.xR[i] = hqrndnormal(&rs);
               bndu.xR[i] = bndl.xR[i] + hqrnduniformi(&rs, 3);
            }
            k = hqrnduniformi(&rs, n);
            if (c.xR[k] > 0.0) {
               bndl.xR[k] = -INFINITY;
            } else {
               bndu.xR[k] = +INFINITY;
            }
            minlpcreate(n, &state);
            testminlpunit_selectsolver(&state, solvertype);
            minlpsetcost(&state, &c);
            minlpsetbc(&state, &bndl, &bndu);
            minlpoptimize(&state);
            minlpresults(&state, &x, &rep);
            set_error_flag(err, rep.terminationtype != -4, __FILE__, __LINE__, "testminlpunit.ap:300");
            set_error_flag(err, x.cnt < n, __FILE__, __LINE__, "testminlpunit.ap:301");
            if (*err) {
               ae_frame_leave();
               return;
            }
         }
      }
   }
// Test linearly constrained problems with all variables being boxed ones
// and with all linear constraints being inequality ones satisfied in the
// box internals.
   for (n = 1; n <= 10; n++) {
      solvertype = hqrnduniformi(&rs, testminlpunit_solverscount);
      ccnt = 1 + hqrnduniformi(&rs, 10);
      ae_vector_set_length(&c, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_matrix_set_length(&a, ccnt, n);
      ae_vector_set_length(&al, ccnt);
      ae_vector_set_length(&au, ccnt);
      for (i = 0; i < n; i++) {
         c.xR[i] = hqrndnormal(&rs);
         bndl.xR[i] = -0.5 - 0.5 * hqrnduniformr(&rs);
         bndu.xR[i] = 0.5 + 0.5 * hqrnduniformr(&rs);
      }
      testminlpunit_shiftfromzero(&c, n, 0.01);
      for (i = 0; i < ccnt; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = 2 * hqrnduniformr(&rs) - 1;
         }
         al.xR[i] = (double)(-2 * n);
         au.xR[i] = (double)(2 * n);
      }
      minlpcreate(n, &state);
      testminlpunit_selectsolver(&state, solvertype);
      minlpsetcost(&state, &c);
      minlpsetbc(&state, &bndl, &bndu);
      minlpsetlc2dense(&state, &a, &al, &au, ccnt);
      minlpoptimize(&state);
      minlpresults(&state, &x, &rep);
      set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:343");
      set_error_flag(err, x.cnt < n, __FILE__, __LINE__, "testminlpunit.ap:344");
      if (*err) {
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(err, c.xR[i] > 0.0 && (x.xR[i] < bndl.xR[i] || x.xR[i] > bndl.xR[i] + primtol), __FILE__, __LINE__, "testminlpunit.ap:349");
         set_error_flag(err, c.xR[i] < 0.0 && (x.xR[i] > bndu.xR[i] || x.xR[i] < bndu.xR[i] - primtol), __FILE__, __LINE__, "testminlpunit.ap:350");
         set_error_flag(err, (c.xR[i] > 0.0 && solvertype == 0) && x.xR[i] != bndl.xR[i], __FILE__, __LINE__, "testminlpunit.ap:351");
         set_error_flag(err, (c.xR[i] < 0.0 && solvertype == 0) && x.xR[i] != bndu.xR[i], __FILE__, __LINE__, "testminlpunit.ap:352");
      }
   }
// Test linearly constrained problems with all variables being boxed ones
// and with random linear constraints, with at least one feasible point
// in the box internals.
   for (n = 1; n <= 10; n++) {
      solvertype = hqrnduniformi(&rs, testminlpunit_solverscount);
      ccnt = 1 + hqrnduniformi(&rs, 10);
      ae_vector_set_length(&c, n);
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_matrix_set_length(&a, ccnt, n);
      ae_vector_set_length(&al, ccnt);
      ae_vector_set_length(&au, ccnt);
      for (i = 0; i < n; i++) {
         c.xR[i] = hqrndnormal(&rs);
         bndl.xR[i] = -0.5 - 0.5 * hqrnduniformr(&rs);
         bndu.xR[i] = 0.5 + 0.5 * hqrnduniformr(&rs);
         x0.xR[i] = 0.5 * (bndl.xR[i] + bndu.xR[i]);
      }
      for (i = 0; i < ccnt; i++) {
         v0 = 0.0;
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
            v0 += a.xyR[i][j] * x0.xR[j];
         }
         al.xR[i] = v0 - 0.25 * hqrnduniformr(&rs);
         au.xR[i] = v0 + 0.25 * hqrnduniformr(&rs);
      }
      minlpcreate(n, &state);
      testminlpunit_selectsolver(&state, solvertype);
      minlpsetcost(&state, &c);
      minlpsetbc(&state, &bndl, &bndu);
      minlpsetlc2dense(&state, &a, &al, &au, ccnt);
      minlpoptimize(&state);
      minlpresults(&state, &x, &rep);
      set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:397");
      set_error_flag(err, x.cnt != n, __FILE__, __LINE__, "testminlpunit.ap:398");
      set_error_flag(err, rep.y.cnt != ccnt, __FILE__, __LINE__, "testminlpunit.ap:399");
      set_error_flag(err, rep.stats.cnt != n + ccnt, __FILE__, __LINE__, "testminlpunit.ap:400");
      if (*err) {
         ae_frame_leave();
         return;
      }
      testminlpunit_validatesolution(&c, &bndl, &bndu, n, &a, &al, &au, ccnt, &x, &rep, solvertype, &v0, &v1, &errslack);
      set_error_flag(err, fabs(v0) > primtol, __FILE__, __LINE__, "testminlpunit.ap:404");
      set_error_flag(err, fabs(v1) > dualtol, __FILE__, __LINE__, "testminlpunit.ap:405");
      set_error_flag(err, fabs(errslack) > slacktol, __FILE__, __LINE__, "testminlpunit.ap:406");
   }
   ae_frame_leave();
}

// This function generates random C[] and A[] as well as feasible point XX[N+M],
// with XX[0..N-1] being structural variables and XX[N..N+M-1] being values
// of logical variables.
//
// It also splits structural/logical variables into basic/nonbasic  ones  and
// generates BasicNonbasic[] array, with indexes of basic variables being stored in
// first M positions, and indexes of non-basic variables being stored in the
// next N positions.
static void testminlpunit_generatecabxd(hqrndstate *rs, ae_int_t n, ae_int_t m, RVector *c, RMatrix *a, RVector *xx, RVector *d, ZVector *basicnonbasic) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t kk;
   double v;
   double mincoeff;
   ae_frame_make(&_frame_block);
   SetVector(c);
   SetMatrix(a);
   SetVector(xx);
   SetVector(d);
   SetVector(basicnonbasic);
   NewVector(y, 0, DT_REAL);
   NewVector(cx, 0, DT_REAL);
   NewMatrix(ax, 0, 0, DT_REAL);
   NewVector(pivots, 0, DT_INT);
   mincoeff = 0.001;
// Randomly partition columns into basic and nonbasic ones
   ae_vector_set_length(basicnonbasic, n + m);
   for (i = 0; i < n + m; i++) {
      basicnonbasic->xZ[i] = i;
   }
   for (i = 0; i < m; i++) {
      k = i + hqrnduniformi(rs, n + m - i);
      kk = basicnonbasic->xZ[i];
      basicnonbasic->xZ[i] = basicnonbasic->xZ[k];
      basicnonbasic->xZ[k] = kk;
   }
// Generate constraint matrix A
   ae_matrix_set_length(a, m, n);
   ae_matrix_set_length(&ax, m, n + m);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         ax.xyR[i][j] = hqrndnormal(rs);
         ax.xyR[i][j] += sign(ax.xyR[i][j]) * mincoeff;
         a->xyR[i][j] = ax.xyR[i][j];
      }
      for (j = 0; j < m; j++) {
         ax.xyR[i][n + j] = 0.0;
      }
      ax.xyR[i][n + i] = -1.0;
   }
// Generate feasible point
   ae_vector_set_length(xx, n + m);
   for (i = 0; i < n; i++) {
      xx->xR[i] = hqrndnormal(rs);
   }
   for (i = n; i < n + m; i++) {
      xx->xR[i] = 0.0;
   }
   for (i = 0; i < m; i++) {
      v = 0.0;
      for (j = 0; j < n; j++) {
         v += xx->xR[j] * ax.xyR[i][j];
      }
      xx->xR[n + i] = v;
   }
// Generate random Y.
// Entries corresponding to basic constraints must be zero.
   ae_vector_set_length(&y, m);
   for (i = 0; i < m; i++) {
      y.xR[i] = hqrndnormal(rs);
   }
   for (i = 0; i < m; i++) {
      if (basicnonbasic->xZ[i] >= n) {
         y.xR[basicnonbasic->xZ[i] - n] = 0.0;
      }
   }
// Generate D and C
   ae_vector_set_length(d, n + m);
   rmatrixgemv(n + m, m, -1.0, &ax, 0, 0, 1, &y, 0, 0.0, d, 0);
   ae_vector_set_length(&cx, n + m);
   for (i = 0; i < n; i++) {
      cx.xR[i] = hqrndnormal(rs);
   }
   for (i = n; i < n + m; i++) {
      cx.xR[i] = 0.0;
   }
   for (i = 0; i < m; i++) {
      cx.xR[basicnonbasic->xZ[i]] = -d->xR[basicnonbasic->xZ[i]];
   }
   raddv(n + m, 1.0, &cx, d);
   ae_vector_set_length(c, n);
   rcopyv(n, &cx, c);
   ae_frame_leave();
}

// This function generates random non-degenerate bounds for given XX and D.
static void testminlpunit_generatebounds(hqrndstate *rs, ae_int_t n, ae_int_t m, RVector *xx, RVector *d, ZVector *basicnonbasic, RVector *bndl, RVector *bndu, RVector *al, RVector *au) {
   double v0;
   double v1;
   double q;
   ae_int_t i;
   ae_int_t kk;
   SetVector(bndl);
   SetVector(bndu);
   SetVector(al);
   SetVector(au);
   ae_vector_set_length(bndl, n);
   ae_vector_set_length(bndu, n);
   ae_vector_set_length(al, m);
   ae_vector_set_length(au, m);
// Choose bounds in such a way that non-basic variables are
// strictly at the bounds and dual feasible, and all basic
// variables are strictly within bounds.
   q = 5.0;
   for (kk = 0; kk < n + m; kk++) {
      i = basicnonbasic->xZ[kk];
      v0 = xx->xR[i] - pow(q, hqrndnormal(rs));
      v1 = xx->xR[i] + pow(q, hqrndnormal(rs));
      if (hqrndnormal(rs) > 0.0) {
         v0 = -INFINITY;
      }
      if (hqrndnormal(rs) > 0.0) {
         v1 = +INFINITY;
      }
      if (kk >= m) {
         if (d->xR[i] >= 0.0) {
            v0 = xx->xR[i];
            if (hqrnduniformr(rs) < 0.05) {
               v1 = v0;
            }
         } else {
            v1 = xx->xR[i];
            if (hqrnduniformr(rs) < 0.05) {
               v0 = v1;
            }
         }
      }
      if (i < n) {
         bndl->xR[i] = v0;
         bndu->xR[i] = v1;
      } else {
         al->xR[i - n] = v0;
         au->xR[i - n] = v1;
      }
   }
}

// This function generates random LP problem with  user-specified  number  of
// variables, with several problem types being randomly chosen internally.
//
// Constraint counts and types are generated randomly; it  is  possible  that
// zero amount of constraints is generated.
static void testminlpunit_generatelpproblem(hqrndstate *rs, ae_int_t n, RVector *c, RVector *bndl, RVector *bndu, RMatrix *a, RVector *al, RVector *au, ae_int_t *m) {
   ae_frame _frame_block;
   ae_int_t ptype;
   ae_int_t pcount;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t kk;
   ae_int_t kt;
   double v;
   double q;
   double big;
   double mincoeff;
   ae_int_t nprimal;
   ae_int_t ndual;
   ae_frame_make(&_frame_block);
   SetVector(c);
   SetVector(bndl);
   SetVector(bndu);
   SetMatrix(a);
   SetVector(al);
   SetVector(au);
   *m = 0;
   NewVector(x0, 0, DT_REAL);
   NewVector(xx, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(basicnonbasic, 0, DT_INT);
   ae_vector_set_length(&x0, n);
   ae_vector_set_length(c, n);
   ae_vector_set_length(bndl, n);
   ae_vector_set_length(bndu, n);
// Choose problem type
   pcount = 4;
   ptype = hqrnduniformi(rs, pcount);
   mincoeff = 0.001;
// A linearly constrained LP problem with all variables/linear constraints
// being boxed (easy start).
   if (ptype == 0) {
      q = 5.0;
      *m = 1 + hqrnduniformi(rs, 2 * n);
      ae_matrix_set_length(a, *m, n);
      ae_vector_set_length(al, *m);
      ae_vector_set_length(au, *m);
      for (i = 0; i < n; i++) {
         c->xR[i] = hqrndnormal(rs);
         bndl->xR[i] = pow(q, hqrndnormal(rs)) - pow(q, hqrndnormal(rs));
         bndu->xR[i] = bndl->xR[i] + pow(q, hqrndnormal(rs));
         v = 0.01 + 0.98 * hqrnduniformr(rs);
         x0.xR[i] = (1 - v) * bndl->xR[i] + v * bndu->xR[i];
      }
      for (i = 0; i < *m; i++) {
         v = 0.0;
         for (j = 0; j < n; j++) {
            a->xyR[i][j] = hqrndnormal(rs) * hqrnduniformi(rs, 2);
            a->xyR[i][j] += sign(a->xyR[i][j]) * mincoeff;
            v += a->xyR[i][j] * x0.xR[j];
         }
         al->xR[i] = v - pow(q, hqrndnormal(rs));
         au->xR[i] = v + pow(q, hqrndnormal(rs));
      }
      ae_frame_leave();
      return;
   }
// A linearly constrained LP problem with up to M variables (linear
// constraints) being non-boxed (free or having just one constraint).
// A bit harder than all-boxed version.
//
// NOTE: components of C[] corresponding to these non-boxed variables
//       are chosen in a way which guarantees dual feasibility of the
//       problem.
   if (ptype == 1) {
      q = 2.0;
      big = 100.00;
      *m = 1 + hqrnduniformi(rs, 2 * n);
      ae_matrix_set_length(a, *m, n);
      ae_vector_set_length(al, *m);
      ae_vector_set_length(au, *m);
      for (i = 0; i < n; i++) {
         c->xR[i] = hqrndnormal(rs);
         bndl->xR[i] = pow(q, hqrndnormal(rs)) - pow(q, hqrndnormal(rs));
         bndu->xR[i] = bndl->xR[i] + pow(q, hqrndnormal(rs));
         v = 0.01 + 0.98 * hqrnduniformr(rs);
         x0.xR[i] = (1 - v) * bndl->xR[i] + v * bndu->xR[i];
      }
      for (i = 0; i < *m; i++) {
         v = 0.0;
         for (j = 0; j < n; j++) {
            a->xyR[i][j] = hqrndnormal(rs);
            a->xyR[i][j] += sign(a->xyR[i][j]) * mincoeff;
            v += a->xyR[i][j] * x0.xR[j];
         }
         al->xR[i] = v - pow(q, hqrndnormal(rs));
         au->xR[i] = v + pow(q, hqrndnormal(rs));
      }
      kk = 1 + hqrnduniformi(rs, *m);
      for (k = 0; k < kk; k++) {
         i = hqrnduniformi(rs, n + (*m));
         if (i < n) {
            kt = hqrnduniformi(rs, 3);
            if (kt == 0) {
               bndl->xR[i] = -INFINITY;
               c->xR[i] = -big * (1 + hqrnduniformr(rs));
            }
            if (kt == 1) {
               bndu->xR[i] = +INFINITY;
               c->xR[i] = big * (1 + hqrnduniformr(rs));
            }
            if (kt == 2) {
               bndl->xR[i] = -INFINITY;
               bndu->xR[i] = +INFINITY;
            }
         } else {
            kt = hqrnduniformi(rs, 3);
            if (kt == 0) {
               au->xR[i - n] = +INFINITY;
            }
            if (kt == 1) {
               al->xR[i - n] = -INFINITY;
            }
            if (kt == 2) {
               al->xR[i - n] = -INFINITY;
               au->xR[i - n] = +INFINITY;
            }
         }
      }
      ae_frame_leave();
      return;
   }
// A randomly generated non-degenerate LP problem. A mix of fixed,
// range, upper/lower bounds and free variables.
   if (ptype == 2) {
      *m = 1 + hqrnduniformi(rs, 2 * n);
      testminlpunit_generatecabxd(rs, n, *m, c, a, &xx, &d, &basicnonbasic);
      testminlpunit_generatebounds(rs, n, *m, &xx, &d, &basicnonbasic, bndl, bndu, al, au);
      ae_frame_leave();
      return;
   }
// A randomly generated primal/dual degenerate LP problem. A mix of
// fixed, range, upper/lower bounds and free variables.
   if (ptype == 3) {
      *m = 1 + hqrnduniformi(rs, 2 * n);
      testminlpunit_generatecabxd(rs, n, *m, c, a, &xx, &d, &basicnonbasic);
      testminlpunit_generatebounds(rs, n, *m, &xx, &d, &basicnonbasic, bndl, bndu, al, au);
      ndual = 1 + hqrnduniformi(rs, *m);
      for (i = 0; i < ndual; i++) {
         j = basicnonbasic.xZ[*m + hqrnduniformi(rs, n)];
         if (j < n) {
            c->xR[j] -= d.xR[j];
            d.xR[j] = 0.0;
         }
      }
      nprimal = 1 + hqrnduniformi(rs, *m);
      for (i = 0; i < nprimal; i++) {
         j = basicnonbasic.xZ[hqrnduniformi(rs, *m)];
         if (j < n) {
            if (hqrndnormal(rs) > 0.0) {
               bndl->xR[j] = xx.xR[j];
            } else {
               bndu->xR[j] = xx.xR[j];
            }
         } else {
            if (hqrndnormal(rs) > 0.0) {
               al->xR[j - n] = xx.xR[j];
            } else {
               au->xR[j - n] = xx.xR[j];
            }
         }
      }
      ae_frame_leave();
      return;
   }
   ae_assert(false, "GenerateLPProblem failed");
   ae_frame_leave();
}

// This function generates random primal unbounded LP problem.
static void testminlpunit_generateunboundedlpproblem(hqrndstate *rs, ae_int_t n, RVector *c, RVector *bndl, RVector *bndu, RMatrix *a, RVector *al, RVector *au, ae_int_t *m) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ptype;
   ae_int_t pcount;
   double v;
   double vv;
   double q;
   ae_frame_make(&_frame_block);
   SetVector(c);
   SetVector(bndl);
   SetVector(bndu);
   SetMatrix(a);
   SetVector(al);
   SetVector(au);
   *m = 0;
   NewVector(x0, 0, DT_REAL);
   ae_vector_set_length(c, n);
   ae_vector_set_length(bndl, n);
   ae_vector_set_length(bndu, n);
// Choose problem type
   pcount = 2;
   ptype = hqrnduniformi(rs, pcount);
// Boundary-only constraints, can be easily made primal unbounded
   if (ptype == 0) {
      q = 5.0;
      *m = 0;
      ae_matrix_set_length(a, 0, 0);
      ae_vector_set_length(al, 0);
      ae_vector_set_length(au, 0);
      for (i = 0; i < n; i++) {
         c->xR[i] = hqrndnormal(rs);
         v = pow(q, hqrndnormal(rs)) - pow(q, hqrndnormal(rs));
         if (c->xR[i] > 0.0) {
            bndl->xR[i] = v;
            bndu->xR[i] = +INFINITY;
         } else {
            bndl->xR[i] = -INFINITY;
            bndu->xR[i] = v;
         }
      }
      i = hqrnduniformi(rs, n);
      do {
         c->xR[i] = hqrndnormal(rs);
      } while (c->xR[i] == 0.0);
      c->xR[i] += 0.1 * sign(c->xR[i]);
      v = pow(q, hqrndnormal(rs)) - pow(q, hqrndnormal(rs));
      if (c->xR[i] < 0.0) {
         bndl->xR[i] = v;
         bndu->xR[i] = +INFINITY;
      } else {
         bndl->xR[i] = -INFINITY;
         bndu->xR[i] = v;
      }
      ae_frame_leave();
      return;
   }
// Boundary and single-sided linear constraints; a bit more tricky to make it primal unbounded
   if (ptype == 1) {
      q = 5.0;
      *m = 1 + hqrnduniformi(rs, 2 * n);
      ae_matrix_set_length(a, *m, n);
      ae_vector_set_length(al, *m);
      ae_vector_set_length(au, *m);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         c->xR[i] = hqrndnormal(rs);
         x0.xR[i] = hqrndnormal(rs);
         if (c->xR[i] >= 0.0) {
            bndl->xR[i] = -INFINITY;
            bndu->xR[i] = x0.xR[i];
         } else {
            bndl->xR[i] = x0.xR[i];
            bndu->xR[i] = +INFINITY;
         }
      }
      for (i = 0; i < *m; i++) {
         v = 0.0;
         vv = 0.0;
         for (j = 0; j < n; j++) {
            a->xyR[i][j] = hqrndnormal(rs);
            v += a->xyR[i][j] * x0.xR[j];
            vv += a->xyR[i][j] * c->xR[j];
         }
         if (vv >= 0.0) {
            al->xR[i] = -INFINITY;
            au->xR[i] = v;
         } else {
            al->xR[i] = v;
            au->xR[i] = +INFINITY;
         }
      }
      ae_frame_leave();
      return;
   }
   ae_assert(false, "GenerateUnboundedLPProblem failed");
   ae_frame_leave();
}

// This function generates random primal infeasible LP problem
static void testminlpunit_generateinfeasiblelpproblem(hqrndstate *rs, ae_int_t n, RVector *c, RVector *bndl, RVector *bndu, RMatrix *a, RVector *al, RVector *au, ae_int_t *m) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t ptype;
   ae_int_t pcount;
   double v;
   double q;
   double minerr;
   ae_frame_make(&_frame_block);
   SetVector(c);
   SetVector(bndl);
   SetVector(bndu);
   SetMatrix(a);
   SetVector(al);
   SetVector(au);
   *m = 0;
   NewVector(xx, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(tmpi, 0, DT_INT);
   ae_vector_set_length(c, n);
   ae_vector_set_length(bndl, n);
   ae_vector_set_length(bndu, n);
// Choose problem type
   pcount = 3;
   ptype = hqrnduniformi(rs, pcount);
// Boundary-only constraints, can be easily made primal infeasible
   if (ptype == 0) {
      q = 5.0;
      *m = 0;
      ae_matrix_set_length(a, 0, 0);
      ae_vector_set_length(al, 0);
      ae_vector_set_length(au, 0);
      for (i = 0; i < n; i++) {
         c->xR[i] = hqrndnormal(rs);
         v = pow(q, hqrndnormal(rs)) - pow(q, hqrndnormal(rs));
         bndl->xR[i] = v - pow(q, hqrndnormal(rs));
         bndu->xR[i] = v + pow(q, hqrndnormal(rs));
      }
      i = hqrnduniformi(rs, n);
      v = bndl->xR[i];
      bndl->xR[i] = bndu->xR[i];
      bndu->xR[i] = v;
      ae_frame_leave();
      return;
   }
// Linearly constrained problem with infeasible box constraints
   if (ptype == 1) {
      q = 5.0;
      *m = 1 + hqrnduniformi(rs, 2 * n);
      testminlpunit_generatecabxd(rs, n, *m, c, a, &xx, &d, &tmpi);
      testminlpunit_generatebounds(rs, n, *m, &xx, &d, &tmpi, bndl, bndu, al, au);
      i = hqrnduniformi(rs, n);
      v = pow(q, hqrndnormal(rs)) - pow(q, hqrndnormal(rs));
      bndl->xR[i] = v + pow(q, hqrndnormal(rs));
      bndu->xR[i] = v - pow(q, hqrndnormal(rs));
      ae_frame_leave();
      return;
   }
// Linearly constrained problem with infeasible linear constraints
   if (ptype == 2) {
      q = 5.0;
      minerr = 0.01;
      *m = 1 + hqrnduniformi(rs, 2 * n);
      testminlpunit_generatecabxd(rs, n, *m, c, a, &xx, &d, &tmpi);
      testminlpunit_generatebounds(rs, n, *m, &xx, &d, &tmpi, bndl, bndu, al, au);
      rmatrixresize(a, a->rows + 1, a->cols);
      rvectorresize(al, al->cnt + 1);
      rvectorresize(au, au->cnt + 1);
      for (i = 0; i < n; i++) {
         a->xyR[*m][i] = a->xyR[*m - 1][i];
      }
      v = minerr + pow(q, hqrndnormal(rs));
      v *= rmax2(1.0, sqrt(rdotrr(n, a, *m, a, *m)));
      if (isfinite(al->xR[*m - 1]) && isfinite(au->xR[*m - 1])) {
         al->xR[*m] = au->xR[*m - 1] + v;
         au->xR[*m] = al->xR[*m] + pow(q, hqrndnormal(rs));
      }
      if (isfinite(al->xR[*m - 1]) && !isfinite(au->xR[*m - 1])) {
         au->xR[*m] = al->xR[*m - 1] - v;
         al->xR[*m] = au->xR[*m] - pow(q, hqrndnormal(rs));
      }
      if (!isfinite(al->xR[*m - 1]) && isfinite(au->xR[*m - 1])) {
         al->xR[*m] = au->xR[*m - 1] + v;
         au->xR[*m] = al->xR[*m] + pow(q, hqrndnormal(rs));
      }
      if (!isfinite(al->xR[*m - 1]) && !isfinite(au->xR[*m - 1])) {
         al->xR[*m] = v;
         au->xR[*m] = v - pow(q, hqrndnormal(rs));
      }
      ++*m;
      ae_frame_leave();
      return;
   }
   ae_assert(false, "GenerateUnboundedLPProblem failed");
   ae_frame_leave();
}

// This function sets linear constraints using randomly  chosen  sequence  of
// SetLC/AddLC calls.
//
// It may also modify constraints:
// * split two-sided constraint into two one-sided constraints
// * create duplicates
// * insert zero dummies
//
// Thus, you should not use this function when you want to test  things  like
// correctness of Lagrange multipliers and so on.
static void testminlpunit_modifyandsendconstraintsto(ae_int_t n, RMatrix *a, RVector *al, RVector *au, ae_int_t m, hqrndstate *rs, minlpstate *state) {
   ae_frame _frame_block;
   ae_int_t stype;
   ae_int_t nz;
   ae_int_t nzmod;
   ae_int_t ccnt;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t t;
   ae_int_t minit;
   ae_int_t nadd;
   ae_int_t ndup;
   double v;
   ae_frame_make(&_frame_block);
   NewVector(ai, 0, DT_REAL);
   NewVector(idxi, 0, DT_INT);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewVector(ct, 0, DT_INT);
// Choose sequence type
   stype = hqrnduniformi(rs, 4);
// Straightforward SetLC2() call
   if (stype == 0) {
      minlpsetlc2dense(state, a, al, au, m);
      ae_frame_leave();
      return;
   }
// SetLC1() call (conversion to other format)
   if (stype == 1) {
      ae_matrix_set_length(&a1, 2 * m, n + 1);
      ae_vector_set_length(&ct, 2 * m);
      ccnt = 0;
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            a1.xyR[ccnt + 0][j] = a->xyR[i][j];
            a1.xyR[ccnt + 1][j] = a->xyR[i][j];
         }
         if ((isfinite(al->xR[i]) && isfinite(au->xR[i])) && al->xR[i] == au->xR[i]) {
            a1.xyR[ccnt][n] = al->xR[i];
            ct.xZ[ccnt] = 0;
            ccnt++;
         } else {
            if (isfinite(al->xR[i])) {
               a1.xyR[ccnt][n] = al->xR[i];
               ct.xZ[ccnt] = 1;
               ccnt++;
            }
            if (isfinite(au->xR[i])) {
               a1.xyR[ccnt][n] = au->xR[i];
               ct.xZ[ccnt] = -1;
               ccnt++;
            }
         }
      }
      minlpsetlc(state, &a1, &ct, ccnt);
      ae_frame_leave();
      return;
   }
// Straightforward SetLC2Sparse() call
   if (stype == 2) {
      if (m == 0) {
         minlpsetlc2(state, &sa, al, au, 0);
         ae_frame_leave();
         return;
      }
      sparsecreate(m, n, 0, &sa);
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            if (a->xyR[i][j] != 0.0) {
               sparseset(&sa, i, j, a->xyR[i][j]);
            }
         }
      }
      if (hqrndnormal(rs) > 0.0) {
         sparseconverttocrs(&sa);
      }
      minlpsetlc2(state, &sa, al, au, m);
      ae_frame_leave();
      return;
   }
// A few rows are added with SetLC2Dense() call, the rest
// is processed with random mix of AddLC2Dense()/AddLC2()
   if (stype == 3) {
      if (m == 0) {
         minlpsetlc2(state, &sa, al, au, 0);
         ae_frame_leave();
         return;
      }
      minit = hqrnduniformi(rs, m);
      minlpsetlc2dense(state, a, al, au, minit);
      for (i = minit; i < m; i++) {
         if (hqrnduniformi(rs, 2) == 0) {
         // Add as dense row
            ae_vector_set_length(&ai, n);
            for (j = 0; j < n; j++) {
               ai.xR[j] = a->xyR[i][j];
            }
            minlpaddlc2dense(state, &ai, al->xR[i], au->xR[i]);
         } else {
         // Add as sparse row with shuffle and possible duplicates
            ae_vector_set_length(&ai, n);
            ae_vector_set_length(&idxi, n);
            nz = 0;
            for (j = 0; j < n; j++) {
               if (a->xyR[i][j] != 0.0) {
                  ai.xR[nz] = a->xyR[i][j];
                  idxi.xZ[nz] = j;
                  nz++;
               }
            }
            rvectorresize(&ai, nz);
            ivectorresize(&idxi, nz);
         // Already existing elements are split in two
            nadd = 0;
            if (nz != 0) {
               nadd = hqrnduniformi(rs, 2) * hqrnduniformi(rs, 4);
               rvectorresize(&ai, nz + nadd);
               ivectorresize(&idxi, nz + nadd);
               for (j = 0; j < nadd; j++) {
                  k = hqrnduniformi(rs, nz);
                  v = hqrndnormal(rs);
                  idxi.xZ[nz + j] = idxi.xZ[k];
                  ai.xR[nz + j] = v;
                  ai.xR[k] -= v;
               }
            }
         // Possibly nonexistent elements are added as +V and -V
         // Do not performed for NZ=0 rows because it may introduce slightly nonzero coefficients
         // to exactly zero row (constraint normalization goes crazy).
            ndup = hqrnduniformi(rs, 2) * hqrnduniformi(rs, 4);
            if (nz == 0) {
               ndup = 0;
            }
            rvectorresize(&ai, nz + nadd + 2 * ndup);
            ivectorresize(&idxi, nz + nadd + 2 * ndup);
            for (j = 0; j < ndup; j++) {
               k = hqrnduniformi(rs, n);
               v = hqrndnormal(rs);
               idxi.xZ[nz + nadd + 2 * j + 0] = k;
               idxi.xZ[nz + nadd + 2 * j + 1] = k;
               ai.xR[nz + nadd + 2 * j + 0] = v;
               ai.xR[nz + nadd + 2 * j + 1] = -v;
            }
            nzmod = nz + nadd + 2 * ndup;
            for (j = 0; j < nzmod; j++) {
               k = j + hqrnduniformi(rs, nzmod - j);
               t = idxi.xZ[j];
               idxi.xZ[j] = idxi.xZ[k];
               idxi.xZ[k] = t;
               v = ai.xR[j];
               ai.xR[j] = ai.xR[k];
               ai.xR[k] = v;
            }
            minlpaddlc2(state, &idxi, &ai, nzmod, al->xR[i], au->xR[i]);
         }
      }
      ae_frame_leave();
      return;
   }
   ae_assert(false, "MINLPTest: integrity check failed");
   ae_frame_leave();
}

// Single-call tests; sets error flag on failure, does not touch it on success.
static void testminlpunit_singlecalltests(bool *err) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t m;
   ae_int_t n0;
   double v0;
   double v1;
   double primtol;
   double dualtol;
   double slacktol;
   double etol;
   double ftol;
   double f;
   double f1;
   double errp;
   double errd;
   double errs;
   double alpha;
   ae_int_t solvertype;
   ae_frame_make(&_frame_block);
   NewObj(minlpstate, state0);
   NewObj(minlpreport, rep0);
   NewObj(minlpstate, state1);
   NewObj(minlpreport, rep1);
   NewVector(c, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(al, 0, DT_REAL);
   NewVector(au, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(bndls, 0, DT_REAL);
   NewVector(bndus, 0, DT_REAL);
   NewVector(cs, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   primtol = 1.0E-3;
   dualtol = 1.0E-3;
   slacktol = 1.0E-3;
   etol = 1.0E-8;
   ftol = 1.0E-3;
   hqrndrandomize(&rs);
// Try different feasible problems
   for (n = 1; n <= 50; n++) {
      for (pass = 1; pass <= 30; pass++) {
         solvertype = hqrnduniformi(&rs, testminlpunit_solverscount);
      // Generate random feasible problem and solve it using basic MinLPSetLC2Dense() API
         testminlpunit_generatelpproblem(&rs, n, &c, &bndl, &bndu, &a, &al, &au, &m);
         minlpcreate(n, &state0);
         testminlpunit_selectsolver(&state0, solvertype);
         minlpsetcost(&state0, &c);
         minlpsetbc(&state0, &bndl, &bndu);
         minlpsetlc2dense(&state0, &a, &al, &au, m);
         minlpoptimize(&state0);
         minlpresults(&state0, &x0, &rep0);
         set_error_flag(err, rep0.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:470");
         set_error_flag(err, x0.cnt != n || !isfinitevector(&x0, n), __FILE__, __LINE__, "testminlpunit.ap:471");
         if (*err) {
            ae_frame_leave();
            return;
         }
         testminlpunit_validatesolution(&c, &bndl, &bndu, n, &a, &al, &au, m, &x0, &rep0, solvertype, &errp, &errd, &errs);
         set_error_flag(err, fabs(errp) > primtol, __FILE__, __LINE__, "testminlpunit.ap:475");
         set_error_flag(err, fabs(errd) > dualtol, __FILE__, __LINE__, "testminlpunit.ap:476");
         set_error_flag(err, fabs(errs) > slacktol, __FILE__, __LINE__, "testminlpunit.ap:477");
         set_error_flag(err, fabs(errp - rep0.primalerror) > etol * rmax2(errp, 1.0), __FILE__, __LINE__, "testminlpunit.ap:478");
         set_error_flag(err, fabs(errd - rep0.dualerror) > etol * rmax2(errd, 1.0), __FILE__, __LINE__, "testminlpunit.ap:479");
         set_error_flag(err, fabs(errs - rep0.slackerror) > etol * rmax2(errs, 1.0), __FILE__, __LINE__, "testminlpunit.ap:480");
      // Apply random modification to the problem (and to the way
      // we pass constraints to the solver), try solving one more time
      // and compare with the original solution.
      //
      // NOTE: because our test suite has degenerate problems, we do
      //       not compare points returned - only target values are
      //       compared.
         ae_vector_set_length(&x1, 0);
         minlpcreate(n, &state1);
         testminlpunit_selectsolver(&state1, solvertype);
         minlpsetcost(&state1, &c);
         minlpsetbc(&state1, &bndl, &bndu);
         testminlpunit_modifyandsendconstraintsto(n, &a, &al, &au, m, &rs, &state1);
         minlpoptimize(&state1);
         minlpresults(&state1, &x1, &rep1);
         set_error_flag(err, rep1.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:500");
         set_error_flag(err, x1.cnt != n, __FILE__, __LINE__, "testminlpunit.ap:501");
         if (*err) {
            ae_frame_leave();
            return;
         }
         f = 0.0;
         f1 = 0.0;
         for (i = 0; i < n; i++) {
            f += x0.xR[i] * c.xR[i];
            f1 += x1.xR[i] * c.xR[i];
         }
         set_error_flag(err, fabs(f1 - f) > ftol, __FILE__, __LINE__, "testminlpunit.ap:511");
      // Test scaling (random scale is applied, target values for
      // original and scaled problems are compared).
      //
      // NOTE: because our test suite has degenerate problems, we do
      //       not compare points returned - only target values.
         ae_vector_set_length(&x1, 0);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&cs, n);
         ae_vector_set_length(&bndls, n);
         ae_vector_set_length(&bndus, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(2.0, (double)(hqrnduniformi(&rs, 21) - 10));
            cs.xR[i] = c.xR[i] / s.xR[i];
            bndls.xR[i] = bndl.xR[i] * s.xR[i];
            bndus.xR[i] = bndu.xR[i] * s.xR[i];
         }
         ae_matrix_set_length(&a1, m, n);
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               a1.xyR[i][j] = a.xyR[i][j] / s.xR[j];
            }
         }
         minlpcreate(n, &state1);
         testminlpunit_selectsolver(&state1, solvertype);
         minlpsetscale(&state1, &s);
         minlpsetcost(&state1, &cs);
         minlpsetbc(&state1, &bndls, &bndus);
         minlpsetlc2dense(&state1, &a1, &al, &au, m);
         minlpoptimize(&state1);
         minlpresults(&state1, &x1, &rep1);
         set_error_flag(err, rep1.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:544");
         set_error_flag(err, x1.cnt != n, __FILE__, __LINE__, "testminlpunit.ap:545");
         if (*err) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(err, fabs(x0.xR[i] - x1.xR[i] / s.xR[i]) > 1000 * machineepsilon, __FILE__, __LINE__, "testminlpunit.ap:557");
         }
      }
   }
// Test infeasible/unbounded problems
   for (n = 1; n <= 50; n++) {
      for (pass = 1; pass <= 30; pass++) {
         solvertype = hqrnduniformi(&rs, testminlpunit_solverscount);
      // Generate random primal unbounded
      //
      // NOTE: because we use constraint validation code, we can not
      //       use ModifyAndSendConstraintsTo() function - it permutes
      //       constraints order and prevents correct validation.
         ae_vector_set_length(&x0, 0);
         testminlpunit_generateunboundedlpproblem(&rs, n, &c, &bndl, &bndu, &a, &al, &au, &m);
         minlpcreate(n, &state0);
         testminlpunit_selectsolver(&state0, solvertype);
         minlpsetcost(&state0, &c);
         minlpsetbc(&state0, &bndl, &bndu);
         minlpsetlc2dense(&state0, &a, &al, &au, m);
         minlpoptimize(&state0);
         minlpresults(&state0, &x0, &rep0);
         set_error_flag(err, rep0.terminationtype != -4 && rep0.terminationtype != -2, __FILE__, __LINE__, "testminlpunit.ap:584");
         set_error_flag(err, x0.cnt != n || !isfinitevector(&x0, n), __FILE__, __LINE__, "testminlpunit.ap:585");
         if (*err) {
            ae_frame_leave();
            return;
         }
         testminlpunit_validatesolution(&c, &bndl, &bndu, n, &a, &al, &au, m, &x0, &rep0, solvertype, &errp, &errd, &errs);
         set_error_flag(err, fabs(errp - rep0.primalerror) > etol * rmax3(errp, rmaxabsv(n, &x0), 1.0), __FILE__, __LINE__, "testminlpunit.ap:589");
         set_error_flag(err, fabs(errd - rep0.dualerror) > etol * rmax3(errd, rmaxabsv(n, &x0), 1.0), __FILE__, __LINE__, "testminlpunit.ap:590");
         set_error_flag(err, fabs(errs - rep0.slackerror) > etol * rmax3(errs, rmaxabsv(n, &x0), 1.0), __FILE__, __LINE__, "testminlpunit.ap:591");
      // Generate random primal infeasible
      //
      // NOTE: because we use constraint validation code, we can not
      //       use ModifyAndSendConstraintsTo() function - it permutes
      //       constraints order and prevents correct validation.
         ae_vector_set_length(&x0, 0);
         testminlpunit_generateinfeasiblelpproblem(&rs, n, &c, &bndl, &bndu, &a, &al, &au, &m);
         minlpcreate(n, &state0);
         testminlpunit_selectsolver(&state0, solvertype);
         minlpsetcost(&state0, &c);
         minlpsetbc(&state0, &bndl, &bndu);
         minlpsetlc2dense(&state0, &a, &al, &au, m);
         minlpoptimize(&state0);
         minlpresults(&state0, &x0, &rep0);
         set_error_flag(err, rep0.terminationtype != -3 && rep0.terminationtype != -2, __FILE__, __LINE__, "testminlpunit.ap:610");
         set_error_flag(err, x0.cnt != n || !isfinitevector(&x0, n), __FILE__, __LINE__, "testminlpunit.ap:611");
         if (*err) {
            ae_frame_leave();
            return;
         }
         testminlpunit_validatesolution(&c, &bndl, &bndu, n, &a, &al, &au, m, &x0, &rep0, solvertype, &errp, &errd, &errs);
         set_error_flag(err, fabs(errp - rep0.primalerror) > etol * rmax3(errp, rmaxabsv(n, &x0), 1.0), __FILE__, __LINE__, "testminlpunit.ap:615");
         set_error_flag(err, fabs(errd - rep0.dualerror) > etol * rmax3(errd, rmaxabsv(n, &x0), 1.0), __FILE__, __LINE__, "testminlpunit.ap:616");
         set_error_flag(err, fabs(errs - rep0.slackerror) > etol * rmax3(errs, rmaxabsv(n, &x0), 1.0), __FILE__, __LINE__, "testminlpunit.ap:617");
      }
   }
   for (n = 2; n <= 50; n++) {
      for (pass = 1; pass <= 30; pass++) {
      // Special test for simplex solver.
      //
      // Generate carefully crafted primal infeasible - the problem is ALMOST feasible.
      // So, we expect simplex solver to stop at the best point possible. We also test
      // that X and Y are correctly unscaled on return.
         ae_assert(n >= 2, "LPTEST: integrity check failed");
         n0 = n / 2;
         ae_assert(n0 < n, "LPTEST: integrity check failed");
         alpha = 0.0001;
         ae_vector_set_length(&x0, 0);
         ae_vector_set_length(&c, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            if (i < n0) {
               c.xR[i] = -pow(2.0, 4 * hqrnduniformr(&rs) - 2);
            } else {
               c.xR[i] = hqrnduniformr(&rs) - 0.5;
            }
            bndl.xR[i] = -pow(2.0, hqrndnormal(&rs));
            bndu.xR[i] = 1.0;
            s.xR[i] = pow(2.0, 2 * hqrnduniformr(&rs) - 1);
         }
         m = 1 + hqrnduniformi(&rs, n);
         ae_matrix_set_length(&a, m, n);
         ae_vector_set_length(&al, m);
         ae_vector_set_length(&au, m);
         for (i = 0; i < m - 1; i++) {
            for (j = 0; j < n0; j++) {
               a.xyR[i][j] = 0.0;
            }
            v0 = 0.0;
            for (j = n0; j < n; j++) {
               a.xyR[i][j] = hqrndnormal(&rs);
               v0 += 0.5 * a.xyR[i][j];
            }
            al.xR[i] = v0 - pow(2.0, hqrndnormal(&rs));
            au.xR[i] = v0 + pow(2.0, hqrndnormal(&rs));
         }
         v0 = 0.0;
         for (i = 0; i < n; i++) {
            if (i < n0) {
               a.xyR[m - 1][i] = pow(2.0, hqrndnormal(&rs));
            } else {
               a.xyR[m - 1][i] = 0.0;
            }
            v0 += a.xyR[m - 1][i];
         }
         al.xR[m - 1] = v0 + alpha;
         au.xR[m - 1] = al.xR[m - 1];
         minlpcreate(n, &state0);
         minlpsetalgodss(&state0, 0.0);
         minlpsetcost(&state0, &c);
         if (hqrndnormal(&rs) > 0.0) {
            minlpsetscale(&state0, &s);
         }
         minlpsetbc(&state0, &bndl, &bndu);
         minlpsetlc2dense(&state0, &a, &al, &au, m);
         minlpoptimize(&state0);
         minlpresults(&state0, &x0, &rep0);
         set_error_flag(err, rep0.terminationtype != -3 && rep0.terminationtype != -2, __FILE__, __LINE__, "testminlpunit.ap:686");
         set_error_flag(err, x0.cnt != n || !isfinitevector(&x0, n), __FILE__, __LINE__, "testminlpunit.ap:687");
         if (*err) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n0; i++) {
            set_error_flag(err, x0.xR[i] < 1.0, __FILE__, __LINE__, "testminlpunit.ap:691");
         }
         testminlpunit_validatesolution(&c, &bndl, &bndu, n, &a, &al, &au, m, &x0, &rep0, solvertype, &errp, &errd, &errs);
         set_error_flag(err, fabs(errd) > 0.001, __FILE__, __LINE__, "testminlpunit.ap:693");
         set_error_flag(err, fabs(errp - rep0.primalerror) > etol * rmax2(errp, 1.0), __FILE__, __LINE__, "testminlpunit.ap:694");
         set_error_flag(err, fabs(errd - rep0.dualerror) > etol * rmax2(errd, 1.0), __FILE__, __LINE__, "testminlpunit.ap:695");
         set_error_flag(err, fabs(errs - rep0.slackerror) > etol * rmax2(errs, 1.0), __FILE__, __LINE__, "testminlpunit.ap:696");
      }
   }
// Check SetBCAll() and SetBCi()
//
// We generate random problem with box constraints
// L <= x[i] <= U, with L<0<U, and random linear constraints
// feasible at x=0.
//
// In order to test SetBCAll() we solve it two times,
// first one with box constraints specified via setbc(),
// second one with setbcall(). Both solutions are compared.
//
// After that we rewrite box constraints to be different
// for each variable, and send them to the first solver
// via setbc() and to the second one via sequential setbci().
// Both solutions are compared.
   for (n = 1; n <= 30; n++) {
      solvertype = hqrnduniformi(&rs, testminlpunit_solverscount);
      v0 = -pow(2.0, hqrndnormal(&rs));
      v1 = pow(2.0, hqrndnormal(&rs));
      m = hqrnduniformi(&rs, 2 * n);
      ae_vector_set_length(&c, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_matrix_set_length(&a, m, n);
      ae_vector_set_length(&al, m);
      ae_vector_set_length(&au, m);
      for (i = 0; i < n; i++) {
         c.xR[i] = hqrndnormal(&rs);
         bndl.xR[i] = v0;
         bndu.xR[i] = v1;
      }
      for (i = 0; i < m; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrnduniformi(&rs, 2) * hqrndnormal(&rs);
         }
         al.xR[i] = -pow(2.0, hqrndnormal(&rs));
         au.xR[i] = pow(2.0, hqrndnormal(&rs));
      }
   // SetBCAll() vs SetBC()
      ae_vector_set_length(&x0, hqrnduniformi(&rs, 2 * n));
      ae_vector_set_length(&x1, hqrnduniformi(&rs, 2 * n));
      minlpcreate(n, &state0);
      testminlpunit_selectsolver(&state0, solvertype);
      minlpsetcost(&state0, &c);
      minlpsetbc(&state0, &bndl, &bndu);
      minlpsetlc2dense(&state0, &a, &al, &au, m);
      minlpoptimize(&state0);
      minlpresults(&state0, &x0, &rep0);
      set_error_flag(err, rep0.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:754");
      set_error_flag(err, x0.cnt != n, __FILE__, __LINE__, "testminlpunit.ap:755");
      if (*err) {
         ae_frame_leave();
         return;
      }
      minlpcreate(n, &state1);
      testminlpunit_selectsolver(&state1, solvertype);
      minlpsetcost(&state1, &c);
      minlpsetbcall(&state1, v0, v1);
      minlpsetlc2dense(&state1, &a, &al, &au, m);
      minlpoptimize(&state1);
      minlpresults(&state1, &x1, &rep1);
      set_error_flag(err, rep1.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:765");
      set_error_flag(err, x1.cnt != n, __FILE__, __LINE__, "testminlpunit.ap:766");
      if (*err) {
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(err, x0.xR[i] != x1.xR[i], __FILE__, __LINE__, "testminlpunit.ap:770");
      }
   // SetBCi() vs SetBC()
      ae_vector_set_length(&x0, hqrnduniformi(&rs, 2 * n));
      ae_vector_set_length(&x1, hqrnduniformi(&rs, 2 * n));
      for (i = 0; i < n; i++) {
         bndl.xR[i] = -pow(2.0, hqrndnormal(&rs));
         bndu.xR[i] = pow(2.0, hqrndnormal(&rs));
         minlpsetbci(&state1, i, bndl.xR[i], bndu.xR[i]);
      }
      minlpsetbc(&state0, &bndl, &bndu);
      minlpoptimize(&state0);
      minlpresults(&state0, &x0, &rep0);
      set_error_flag(err, rep0.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:786");
      set_error_flag(err, x0.cnt != n, __FILE__, __LINE__, "testminlpunit.ap:787");
      if (*err) {
         ae_frame_leave();
         return;
      }
      minlpoptimize(&state1);
      minlpresults(&state1, &x1, &rep1);
      set_error_flag(err, rep1.terminationtype <= 0, __FILE__, __LINE__, "testminlpunit.ap:792");
      set_error_flag(err, x1.cnt != n, __FILE__, __LINE__, "testminlpunit.ap:793");
      if (*err) {
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(err, x0.xR[i] != x1.xR[i], __FILE__, __LINE__, "testminlpunit.ap:797");
      }
   }
   ae_frame_leave();
}

bool testminlp(bool silent) {
   bool basicerrors;
   bool singlecall;
   bool wereerrors;
   bool result;
   basicerrors = false;
   singlecall = false;
   result = true;
   testminlpunit_basictests(&basicerrors);
   testminlpunit_singlecalltests(&singlecall);
// report
   wereerrors = basicerrors || singlecall;
   if (!silent) {
      printf("TESTING MinLP\n");
      printf("BASIC TESTS                               ");
      if (basicerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("COMMON TESTS:\n");
      printf("* single call usage                       ");
      if (singlecall) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (wereerrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !wereerrors;
   return result;
}

// === minnlc testing unit ===
static const ae_int_t testminnlcunit_maxsolvertype = 2;
static const ae_int_t testminnlcunit_maxoptguardlevel = 1;

// This function tests bound constrained quadratic programming algorithm.
//
// On failure sets error flag.
static void testminnlcunit_testbc(bool *wereerrors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t aulits;
   double tolx;
   double tolg;
   ae_int_t scaletype;
   double rho;
   ae_int_t solvertype;
   double gnorm;
   double g;
   ae_int_t prectype;
   ae_frame_make(&_frame_block);
   NewObj(minnlcstate, state);
   NewObj(minnlcreport, rep);
   NewObj(optguardreport, ogrep);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   for (solvertype = 0; solvertype <= testminnlcunit_maxsolvertype; solvertype++) {
   // Convex test:
   // * N dimensions
   // * random number (0..N) of random boundary constraints
   // * positive-definite quadratic programming problem
   // * initial point is random (maybe infeasible!)
   // * random scale (unit or non-unit)
      aulits = 10;
      rho = 200.0;
      tolx = 0.0005;
      tolg = 0.01;
      for (n = 1; n <= 10; n++) {
         for (pass = 1; pass <= 10; pass++) {
            for (prectype = 0; prectype <= 2; prectype++) {
            // Generate well-conditioned problem with unit scale
               spdmatrixrndcond(n, 1.0E2, &fulla);
               ae_vector_set_length(&b, n);
               ae_vector_set_length(&bndl, n);
               ae_vector_set_length(&bndu, n);
               ae_vector_set_length(&x0, n);
               for (i = 0; i < n; i++) {
                  b.xR[i] = hqrndnormal(&rs);
                  bndl.xR[i] = -INFINITY;
                  bndu.xR[i] = +INFINITY;
                  x0.xR[i] = hqrndnormal(&rs);
                  j = hqrnduniformi(&rs, 5);
                  if (j == 0) {
                     bndl.xR[i] = 0.0;
                  }
                  if (j == 1) {
                     bndu.xR[i] = 0.0;
                  }
                  if (j == 2) {
                     bndl.xR[i] = hqrndnormal(&rs);
                     bndu.xR[i] = bndl.xR[i];
                  }
                  if (j == 3) {
                     bndl.xR[i] = -0.1;
                     bndu.xR[i] = 0.1;
                  }
               }
            // Apply scaling to quadratic/linear term, so problem becomes
            // well-conditioned in the scaled coordinates.
               scaletype = hqrnduniformi(&rs, 2);
               ae_vector_set_length(&s, n);
               for (i = 0; i < n; i++) {
                  if (scaletype == 0) {
                     s.xR[i] = 1.0;
                  } else {
                     s.xR[i] = exp(5 * hqrndnormal(&rs));
                  }
               }
               for (i = 0; i < n; i++) {
                  x0.xR[i] *= s.xR[i];
                  bndl.xR[i] *= s.xR[i];
                  bndu.xR[i] *= s.xR[i];
                  b.xR[i] /= s.xR[i];
                  for (j = 0; j < n; j++) {
                     fulla.xyR[i][j] /= s.xR[i] * s.xR[j];
                  }
               }
            // Solve problem
               minnlccreate(n, &x0, &state);
               if (solvertype == 0) {
                  minnlcsetalgoaul(&state, rho, aulits);
                  if (prectype == 1) {
                     minnlcsetprecexactlowrank(&state, 0);
                  }
                  if (prectype == 2) {
                     minnlcsetprecexactrobust(&state, 0);
                  }
               } else {
                  if (solvertype == 1) {
                     minnlcsetalgoslp(&state);
                  } else {
                     if (solvertype == 2) {
                        minnlcsetalgosqp(&state);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
               }
               if (scaletype != 0) {
                  minnlcsetscale(&state, &s);
               }
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
               }
               minnlcsetbc(&state, &bndl, &bndu);
               minnlcsetcond(&state, 1.0E-7, 0);
               while (minnlciteration(&state)) {
                  if (state.needfij) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                        state.j.xyR[0][i] = b.xR[i];
                        for (j = 0; j < n; j++) {
                           state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                           state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                        }
                     }
                     continue;
                  }
                  ae_assert(false, "Assertion failed");
               }
               minnlcresults(&state, &x1, &rep);
               set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:240");
               set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:241");
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardresults(&state, &ogrep);
                  set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:245");
               }
               if (*wereerrors) {
                  ae_frame_leave();
                  return;
               }
            // Check constraint violation reports
               set_error_flag(wereerrors, rep.bcerr > tolx, __FILE__, __LINE__, "testminnlcunit.ap:253");
               set_error_flag(wereerrors, rep.bcidx >= n, __FILE__, __LINE__, "testminnlcunit.ap:254");
               set_error_flag(wereerrors, rep.lcerr > 0.0, __FILE__, __LINE__, "testminnlcunit.ap:255");
               set_error_flag(wereerrors, rep.lcidx >= 0, __FILE__, __LINE__, "testminnlcunit.ap:256");
            // Check feasibility properties
               for (i = 0; i < n; i++) {
                  set_error_flag(wereerrors, isfinite(bndl.xR[i]) && x1.xR[i] <= bndl.xR[i] - tolx * s.xR[i], __FILE__, __LINE__, "testminnlcunit.ap:263");
                  set_error_flag(wereerrors, isfinite(bndu.xR[i]) && x1.xR[i] >= bndu.xR[i] + tolx * s.xR[i], __FILE__, __LINE__, "testminnlcunit.ap:264");
               }
            // Test - calculate scaled constrained gradient at solution,
            // check its norm.
               gnorm = 0.0;
               for (i = 0; i < n; i++) {
                  g = b.xR[i];
                  for (j = 0; j < n; j++) {
                     g += fulla.xyR[i][j] * x1.xR[j];
                  }
                  g *= s.xR[i];
                  if ((isfinite(bndl.xR[i]) && fabs(x1.xR[i] - bndl.xR[i]) < tolx * s.xR[i]) && g > 0.0) {
                     g = 0.0;
                  }
                  if ((isfinite(bndu.xR[i]) && fabs(x1.xR[i] - bndu.xR[i]) < tolx * s.xR[i]) && g < 0.0) {
                     g = 0.0;
                  }
                  gnorm += sqr(g);
               }
               gnorm = sqrt(gnorm);
               set_error_flag(wereerrors, gnorm > tolg, __FILE__, __LINE__, "testminnlcunit.ap:286");
            }
         }
      }
   // Non-convex test:
   // * N dimensions, N >= 2
   // * box constraints, x[i] in [-1,+1]
   // * A is symmetric indefinite with condition number 50.0
   // * random B with normal entries
   // * initial point is random, feasible
   // * scale is always unit
   //
   // We check that constrained problem can be successfully solved.
   // We do not check ability to detect unboundedness of unconstrained
   // problem because there is such functionality in MinNLC.
      aulits = 50;
      rho = 200.0;
      tolx = 0.0005;
      tolg = 0.01;
      for (n = 2; n <= 10; n++) {
         for (pass = 1; pass <= 10; pass++) {
            for (prectype = 0; prectype <= 2; prectype++) {
            // Generate problem
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     fulla.xyR[i][j] = 0.0;
                  }
               }
               for (i = 0; i < n; i++) {
                  fulla.xyR[i][i] = -1 - hqrnduniformr(&rs);
               }
               ae_vector_set_length(&b, n);
               ae_vector_set_length(&bndl, n);
               ae_vector_set_length(&bndu, n);
               ae_vector_set_length(&x0, n);
               for (i = 0; i < n; i++) {
                  b.xR[i] = 0.05 * hqrndnormal(&rs);
                  bndl.xR[i] = -1.0;
                  bndu.xR[i] = 1.0;
                  x0.xR[i] = 2 * hqrnduniformr(&rs) - 1;
               }
            // Solve problem:
            // * without constraints we expect failure
            // * with constraints algorithm must succeed
               minnlccreate(n, &x0, &state);
               if (solvertype == 0) {
                  minnlcsetalgoaul(&state, rho, aulits);
                  if (prectype == 0) {
                     minnlcsetprecinexact(&state);
                  }
                  if (prectype == 1) {
                     minnlcsetprecexactlowrank(&state, 0);
                  }
                  if (prectype == 2) {
                     minnlcsetprecexactrobust(&state, 0);
                  }
               } else {
                  if (solvertype == 1) {
                     minnlcsetalgoslp(&state);
                  } else {
                     if (solvertype == 2) {
                        minnlcsetalgosqp(&state);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
               }
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
               }
               minnlcsetbc(&state, &bndl, &bndu);
               minnlcsetcond(&state, 1.0E-7, 0);
               while (minnlciteration(&state)) {
                  if (state.needfij) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                        state.j.xyR[0][i] = b.xR[i];
                        for (j = 0; j < n; j++) {
                           state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                           state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                        }
                     }
                     continue;
                  }
                  ae_assert(false, "Assertion failed");
               }
               minnlcresults(&state, &x1, &rep);
               set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:378");
               set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:379");
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardresults(&state, &ogrep);
                  set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:383");
               }
               if (*wereerrors) {
                  ae_frame_leave();
                  return;
               }
            // Check feasibility properties
               for (i = 0; i < n; i++) {
                  set_error_flag(wereerrors, isfinite(bndl.xR[i]) && x1.xR[i] <= bndl.xR[i] - tolx, __FILE__, __LINE__, "testminnlcunit.ap:393");
                  set_error_flag(wereerrors, isfinite(bndu.xR[i]) && x1.xR[i] >= bndu.xR[i] + tolx, __FILE__, __LINE__, "testminnlcunit.ap:394");
               }
            // Test - calculate scaled constrained gradient at solution,
            // check its norm.
               gnorm = 0.0;
               for (i = 0; i < n; i++) {
                  g = b.xR[i];
                  for (j = 0; j < n; j++) {
                     g += fulla.xyR[i][j] * x1.xR[j];
                  }
                  if ((isfinite(bndl.xR[i]) && fabs(x1.xR[i] - bndl.xR[i]) < tolx) && g > 0.0) {
                     g = 0.0;
                  }
                  if ((isfinite(bndu.xR[i]) && fabs(x1.xR[i] - bndu.xR[i]) < tolx) && g < 0.0) {
                     g = 0.0;
                  }
                  gnorm += sqr(g);
               }
               gnorm = sqrt(gnorm);
               set_error_flag(wereerrors, gnorm > tolg, __FILE__, __LINE__, "testminnlcunit.ap:415");
            }
         }
      }
   }
   ae_frame_leave();
}

// This function tests linearly constrained quadratic programming algorithm.
//
// Sets error flag on failure.
static void testminnlcunit_testlc(bool *wereerrors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t k;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   double v;
   double vv;
   double tolx;
   double tolg;
   double tolf;
   ae_int_t aulits;
   double rho;
   ae_int_t scaletype;
   double f0;
   double f1;
   double tolconstr;
   ae_int_t bscale;
   ae_int_t akind;
   ae_int_t ccnt;
   ae_int_t shiftkind;
   ae_int_t prectype;
   ae_int_t solvertype;
   double gnrm2;
   ae_frame_make(&_frame_block);
   NewMatrix(q, 0, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xs0, 0, DT_REAL);
   NewVector(xstart, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(xm, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(ce, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewVector(nonnegative, 0, DT_BOOL);
   NewObj(minnlcstate, state);
   NewObj(minnlcreport, rep);
   NewObj(optguardreport, ogrep);
   NewObj(hqrndstate, rs);
   NewObj(snnlssolver, nnls);
   hqrndrandomize(&rs);
   for (solvertype = 0; solvertype <= testminnlcunit_maxsolvertype; solvertype++) {
   // First test:
   // * K<N equality constraints Q*x = Q*x0, where Q is random
   //   orthogonal K*N matrix, x0 is some random vector
   // * quadratic programming problem with identity quadratic term A and
   //   linear term equal to xm*A, where xm is some random vector such
   //   that Q*xm=0. It is always possible to find such xm, because K<N
   //   Thus, optimization problem has form 0.5*x'*I*x-xm'*x.
   // * exact solution must be equal to x0
   //
   // NOTE: this test is important because it is the only linearly constrained one
   //       which uses non-unit scaling!
      rho = 200.0;
      tolx = 0.0005;
      tolf = 0.0001;
      aulits = 50;
      for (n = 2; n <= 6; n++) {
         for (k = 1; k < n; k++) {
            for (prectype = -1; prectype <= 2; prectype++) {
            // Generate problem: A, b, CMatrix, x0, XStart
               rmatrixrndorthogonal(n, &q);
               ae_vector_set_length(&b, n);
               ae_vector_set_length(&x0, n);
               ae_vector_set_length(&xm, n);
               ae_vector_set_length(&xstart, n);
               ae_matrix_set_length(&c, k, n + 1);
               ae_vector_set_length(&ct, k);
               for (i = 0; i < n; i++) {
                  x0.xR[i] = randommid();
                  xm.xR[i] = x0.xR[i];
                  xstart.xR[i] = randommid();
               }
               for (i = 0; i < k; i++) {
                  ae_v_move(c.xyR[i], 1, q.xyR[i], 1, n);
                  v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
                  c.xyR[i][n] = v;
                  ct.xZ[i] = 0;
                  v = randommid();
                  ae_v_addd(xm.xR, 1, q.xyR[i], 1, n, v);
               }
               for (i = 0; i < n; i++) {
                  b.xR[i] = -xm.xR[i];
               }
            // Apply scaling to linear term and known solution,
            // so problem becomes well-conditioned in the scaled coordinates.
               scaletype = hqrnduniformi(&rs, 2);
               ae_vector_set_length(&s, n);
               for (i = 0; i < n; i++) {
                  if (scaletype == 0) {
                     s.xR[i] = 1.0;
                  } else {
                     s.xR[i] = exp(5 * hqrndnormal(&rs));
                  }
               }
               for (i = 0; i < n; i++) {
                  x0.xR[i] *= s.xR[i];
                  xstart.xR[i] *= s.xR[i];
                  b.xR[i] /= s.xR[i];
               }
               for (i = 0; i < k; i++) {
                  for (j = 0; j < n; j++) {
                     c.xyR[i][j] /= s.xR[j];
                  }
               }
            // Create optimizer, solve
               minnlccreate(n, &xstart, &state);
               minnlcsetscale(&state, &s);
               minnlcsetcond(&state, 1.0E-7, 0);
               minnlcsetlc(&state, &c, &ct, k);
               if (solvertype == 0) {
                  minnlcsetalgoaul(&state, rho, aulits);
                  if (prectype == 0) {
                     minnlcsetprecinexact(&state);
                  }
                  if (prectype == 1) {
                     minnlcsetprecexactlowrank(&state, 0);
                  }
                  if (prectype == 2) {
                     minnlcsetprecexactrobust(&state, 0);
                  }
               } else {
                  if (solvertype == 1) {
                     minnlcsetalgoslp(&state);
                  } else {
                     if (solvertype == 2) {
                        minnlcsetalgosqp(&state);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
               }
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
               }
               while (minnlciteration(&state)) {
                  if (state.needfij) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += b.xR[i] * state.x.xR[i] + 0.5 * sqr(state.x.xR[i]) / sqr(s.xR[i]);
                        state.j.xyR[0][i] = b.xR[i] + state.x.xR[i] / sqr(s.xR[i]);
                     }
                     continue;
                  }
                  ae_assert(false, "Assertion failed");
               }
               minnlcresults(&state, &x1, &rep);
               set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:580");
               set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:581");
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardresults(&state, &ogrep);
                  set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:585");
               }
               if (*wereerrors) {
                  ae_frame_leave();
                  return;
               }
            // Check constraint violation reports
               set_error_flag(wereerrors, rep.bcerr > 0.0, __FILE__, __LINE__, "testminnlcunit.ap:593");
               set_error_flag(wereerrors, rep.bcidx >= 0, __FILE__, __LINE__, "testminnlcunit.ap:594");
               set_error_flag(wereerrors, rep.lcerr > tolx, __FILE__, __LINE__, "testminnlcunit.ap:595");
               set_error_flag(wereerrors, rep.lcidx >= n, __FILE__, __LINE__, "testminnlcunit.ap:596");
            // Compare with analytic solution
               f0 = 0.0;
               f1 = 0.0;
               for (i = 0; i < n; i++) {
                  f0 += b.xR[i] * x0.xR[i] + 0.5 * sqr(x0.xR[i] / s.xR[i]);
                  f1 += b.xR[i] * x1.xR[i] + 0.5 * sqr(x1.xR[i] / s.xR[i]);
               }
               set_error_flag(wereerrors, fabs(f1 - f0) > tolf, __FILE__, __LINE__, "testminnlcunit.ap:608");
            }
         }
      }
   // Inequality constrained problem:
   // * N*N diagonal A
   // * one inequality constraint q'*x >= 0, where q is random unit vector
   // * optimization problem has form 0.5*x'*A*x-(x1*A)*x,
   //   where x1 is some random vector
   // * either:
   //   a) x1 is feasible => we must stop at x1
   //   b) x1 is infeasible => we must stop at the boundary q'*x=0 and
   //      projection of gradient onto q*x=0 must be zero
   //
   // NOTE: we make several passes because some specific kind of errors is rarely
   //       caught by this test, so we need several repetitions.
      rho = 200.0;
      tolx = 0.0005;
      tolg = 0.01;
      aulits = 50;
      for (n = 2; n <= 6; n++) {
         for (pass = 0; pass <= 4; pass++) {
         // Generate problem: A, b, CMatrix, x0, XStart
            spdmatrixrndcond(n, 1.0E2, &fulla);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&xm, n);
            ae_vector_set_length(&xstart, n);
            ae_matrix_set_length(&c, 1, n + 1);
            ae_vector_set_length(&ct, 1);
            for (i = 0; i < n; i++) {
               xm.xR[i] = randommid();
               xstart.xR[i] = randommid();
            }
            do {
               v = 0.0;
               for (i = 0; i < n; i++) {
                  c.xyR[0][i] = randommid();
                  v += sqr(c.xyR[0][i]);
               }
               v = sqrt(v);
            } while (v == 0.0);
            for (i = 0; i < n; i++) {
               c.xyR[0][i] /= v;
            }
            c.xyR[0][n] = 0.0;
            ct.xZ[0] = 1;
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(fulla.xyR[i], 1, xm.xR, 1, n);
               b.xR[i] = -v;
            }
         // Apply scaling to linear term and known solution,
         // so problem becomes well-conditioned in the scaled coordinates.
            scaletype = hqrnduniformi(&rs, 2);
            ae_vector_set_length(&s, n);
            for (i = 0; i < n; i++) {
               if (scaletype == 0) {
                  s.xR[i] = 1.0;
               } else {
                  s.xR[i] = exp(hqrndnormal(&rs));
               }
            }
            for (i = 0; i < n; i++) {
               xm.xR[i] *= s.xR[i];
               xstart.xR[i] *= s.xR[i];
               b.xR[i] /= s.xR[i];
               for (j = 0; j < n; j++) {
                  fulla.xyR[i][j] /= s.xR[i] * s.xR[j];
               }
            }
            for (j = 0; j < n; j++) {
               c.xyR[0][j] /= s.xR[j];
            }
         // Create optimizer, solve
            minnlccreate(n, &xstart, &state);
            if (solvertype == 0) {
               minnlcsetalgoaul(&state, rho, aulits);
            } else {
               if (solvertype == 1) {
                  minnlcsetalgoslp(&state);
               } else {
                  if (solvertype == 2) {
                     minnlcsetalgosqp(&state);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            }
            minnlcsetlc(&state, &c, &ct, 1);
            minnlcsetscale(&state, &s);
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
            }
            while (minnlciteration(&state)) {
               if (state.needfij) {
                  state.fi.xR[0] = 0.0;
                  for (i = 0; i < n; i++) {
                     state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                     state.j.xyR[0][i] = b.xR[i];
                     for (j = 0; j < n; j++) {
                        state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                        state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                     }
                  }
                  continue;
               }
               ae_assert(false, "Assertion failed");
            }
            minnlcresults(&state, &x1, &rep);
            set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:730");
            set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:731");
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardresults(&state, &ogrep);
               set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:735");
            }
            if (*wereerrors) {
               ae_frame_leave();
               return;
            }
         // Check constraint violation reports
            set_error_flag(wereerrors, rep.bcerr > 0.0, __FILE__, __LINE__, "testminnlcunit.ap:743");
            set_error_flag(wereerrors, rep.bcidx >= 0, __FILE__, __LINE__, "testminnlcunit.ap:744");
            set_error_flag(wereerrors, rep.lcerr > tolx, __FILE__, __LINE__, "testminnlcunit.ap:745");
            set_error_flag(wereerrors, rep.lcidx >= n, __FILE__, __LINE__, "testminnlcunit.ap:746");
         // Test solution
            ae_vector_set_length(&g, n);
            ae_v_move(g.xR, 1, b.xR, 1, n);
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(fulla.xyR[i], 1, x1.xR, 1, n);
               g.xR[i] += v;
            }
            v = ae_v_dotproduct(x1.xR, 1, c.xyR[0], 1, n);
            set_error_flag(wereerrors, v < -tolx, __FILE__, __LINE__, "testminnlcunit.ap:759");
            if (v < tolx) {
            // Point at the boundary, project gradient into
            // equality-constrained subspace.
               v = 0.0;
               vv = 0.0;
               for (i = 0; i < n; i++) {
                  v += g.xR[i] * c.xyR[0][i];
                  vv += c.xyR[0][i] * c.xyR[0][i];
               }
               v /= vv;
               ae_v_subd(g.xR, 1, c.xyR[0], 1, n, v);
            }
            v = 0.0;
            for (i = 0; i < n; i++) {
               v += sqr(g.xR[i] * s.xR[i]);
            }
            set_error_flag(wereerrors, sqrt(v) > tolg, __FILE__, __LINE__, "testminnlcunit.ap:779");
         }
      }
   // Equality-constrained test:
   // * N*N SPD A
   // * K<N equality constraints Q*x = Q*x0, where Q is random
   //   orthogonal K*N matrix, x0 is some random vector
   // * optimization problem has form 0.5*x'*A*x-(xm*A)*x,
   //   where xm is some random vector
   // * we check feasibility properties of the solution
   // * we do not know analytic form of the exact solution,
   //   but we know that projection of gradient into equality constrained
   //   subspace must be zero at the solution
      rho = 200.0;
      tolx = 0.0005;
      tolg = 0.01;
      aulits = 50;
      for (n = 2; n <= 6; n++) {
         for (k = 1; k < n; k++) {
         // Generate problem: A, b, CMatrix, x0, XStart
            rmatrixrndorthogonal(n, &q);
            spdmatrixrndcond(n, 1.0E2, &fulla);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&xm, n);
            ae_vector_set_length(&xstart, n);
            ae_matrix_set_length(&c, k, n + 1);
            ae_vector_set_length(&ct, k);
            for (i = 0; i < n; i++) {
               x0.xR[i] = randommid();
               xm.xR[i] = randommid();
               xstart.xR[i] = randommid();
            }
            for (i = 0; i < k; i++) {
               ae_v_move(c.xyR[i], 1, q.xyR[i], 1, n);
               v = ae_v_dotproduct(q.xyR[i], 1, x0.xR, 1, n);
               c.xyR[i][n] = v;
               ct.xZ[i] = 0;
            }
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(fulla.xyR[i], 1, xm.xR, 1, n);
               b.xR[i] = -v;
            }
         // Create optimizer, solve
            minnlccreate(n, &xstart, &state);
            if (solvertype == 0) {
               minnlcsetalgoaul(&state, rho, aulits);
            } else {
               if (solvertype == 1) {
                  minnlcsetalgoslp(&state);
               } else {
                  if (solvertype == 2) {
                     minnlcsetalgosqp(&state);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            }
            minnlcsetcond(&state, 1.0E-7, 0);
            minnlcsetlc(&state, &c, &ct, k);
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
            }
            while (minnlciteration(&state)) {
               if (state.needfij) {
                  state.fi.xR[0] = 0.0;
                  for (i = 0; i < n; i++) {
                     state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                     state.j.xyR[0][i] = b.xR[i];
                     for (j = 0; j < n; j++) {
                        state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                        state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                     }
                  }
                  continue;
               }
               ae_assert(false, "Assertion failed");
            }
            minnlcresults(&state, &x1, &rep);
            set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:874");
            set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:875");
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardresults(&state, &ogrep);
               set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:879");
            }
            if (*wereerrors) {
               ae_frame_leave();
               return;
            }
         // Check constraint violation reports
            set_error_flag(wereerrors, rep.bcerr > 0.0, __FILE__, __LINE__, "testminnlcunit.ap:887");
            set_error_flag(wereerrors, rep.bcidx >= 0, __FILE__, __LINE__, "testminnlcunit.ap:888");
            set_error_flag(wereerrors, rep.lcerr > tolx, __FILE__, __LINE__, "testminnlcunit.ap:889");
            set_error_flag(wereerrors, rep.lcidx >= n, __FILE__, __LINE__, "testminnlcunit.ap:890");
         // Check feasibility properties and gradient projection
            for (i = 0; i < k; i++) {
               v = ae_v_dotproduct(x1.xR, 1, c.xyR[i], 1, n);
               set_error_flag(wereerrors, fabs(v - c.xyR[i][n]) > tolx, __FILE__, __LINE__, "testminnlcunit.ap:898");
            }
            ae_vector_set_length(&g, n);
            ae_v_move(g.xR, 1, b.xR, 1, n);
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(fulla.xyR[i], 1, x1.xR, 1, n);
               g.xR[i] += v;
            }
            for (i = 0; i < k; i++) {
               v = ae_v_dotproduct(g.xR, 1, c.xyR[i], 1, n);
               ae_v_subd(g.xR, 1, c.xyR[i], 1, n, v);
            }
            v = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
            set_error_flag(wereerrors, sqrt(v) > tolg, __FILE__, __LINE__, "testminnlcunit.ap:913");
         }
      }
   // Boundary constraints vs linear ones:
   // * N*N SPD A
   // * optimization problem has form 0.5*x'*A*x-(xm*A)*x,
   //   where xm is some random vector from [-1,+1]
   // * K=2*N constraints of the form ai <= x[i] or x[i] <= b[i],
   //   with ai in [-1.0,-0.1], bi in [+0.1,+1.0]
   // * initial point xstart is from [-1,+2]
   // * we solve two related QP problems:
   //   a) one with constraints posed as boundary ones
   //   b) another one with same constraints posed as general linear ones
   // both problems must have same solution.
   // Here we test that boundary constrained and linear inequality constrained
   // solvers give same results.
      rho = 200.0;
      tolx = 0.0005;
      tolf = 0.00001;
      aulits = 50;
      for (n = 1; n <= 6; n++) {
      // Generate problem: A, b, x0, XStart, C, CT
         spdmatrixrndcond(n, 1.0E2, &fulla);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&xm, n);
         ae_vector_set_length(&x0, n);
         ae_matrix_set_length(&c, 2 * n, n + 1);
         ae_vector_set_length(&ct, 2 * n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            xm.xR[i] = randommid();
            x0.xR[i] = 3.0 * randomreal() - 1.0;
            bndl.xR[i] = -(0.1 + 0.9 * randomreal());
            bndu.xR[i] = 0.1 + 0.9 * randomreal();
            for (j = 0; j < n; j++) {
               c.xyR[2 * i + 0][j] = 0.0;
               c.xyR[2 * i + 1][j] = 0.0;
            }
            c.xyR[2 * i + 0][i] = 1.0;
            c.xyR[2 * i + 0][n] = bndl.xR[i];
            ct.xZ[2 * i + 0] = 1;
            c.xyR[2 * i + 1][i] = 1.0;
            c.xyR[2 * i + 1][n] = bndu.xR[i];
            ct.xZ[2 * i + 1] = -1;
         }
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(fulla.xyR[i], 1, xm.xR, 1, n);
            b.xR[i] = -v;
         }
      // Solve linear inequality constrained problem
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, rho, aulits);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetlc(&state, &c, &ct, 2 * n);
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
         }
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:1013");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:1014");
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardresults(&state, &ogrep);
            set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:1018");
         }
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Solve boundary constrained problem
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, rho, aulits);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetbc(&state, &bndl, &bndu);
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x2, &rep);
         set_error_flag(wereerrors, !isfinitevector(&x2, n), __FILE__, __LINE__, "testminnlcunit.ap:1060");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:1061");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Compare solutions
         f0 = 0.0;
         f1 = 0.0;
         for (i = 0; i < n; i++) {
            f0 += b.xR[i] * x1.xR[i];
            f1 += b.xR[i] * x2.xR[i];
            for (j = 0; j < n; j++) {
               f0 += 0.5 * x1.xR[i] * fulla.xyR[i][j] * x1.xR[j];
               f1 += 0.5 * x2.xR[i] * fulla.xyR[i][j] * x2.xR[j];
            }
         }
         set_error_flag(wereerrors, fabs(f0 - f1) > tolf, __FILE__, __LINE__, "testminnlcunit.ap:1080");
      }
   // Boundary and linear equality constrained QP problem with excessive
   // equality constraints:
   // * N*N SPD A with moderate condtion number (up to 100)
   // * boundary constraints 0 <= x[i] <= 1
   // * K=2*N equality constraints Q*x = Q*x0, where Q is random matrix,
   //   x0 is some random vector from the feasible hypercube (0.1 <= x0[i] <= 0.9)
   // * optimization problem has form 0.5*x'*A*x-b*x,
   //   where b is some random vector
   // * because constraints are excessive, the main problem is to find
   //   feasible point; the only existing feasible point is solution,
   //   so we have to check only feasibility
      rho = 1000.0;
      tolx = 0.0005;
      aulits = 10;
      for (n = 1; n <= 6; n++) {
      // Generate problem: A, b, BndL, BndU, CMatrix, x0, xm, XStart
         k = 2 * n;
         spdmatrixrndcond(n, 1.0E2, &fulla);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xm, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 0.1 + 0.8 * randomreal();
            xm.xR[i] = randommid();
            bndl.xR[i] = 0.0;
            bndu.xR[i] = 1.0;
            xstart.xR[i] = (double)randominteger(2);
         }
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = randommid();
            }
            v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
         }
         for (i = 0; i < n; i++) {
            b.xR[i] = randommid();
         }
      // Create optimizer, solve
         minnlccreate(n, &xstart, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, rho, aulits);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 1.0E-7, 0);
         minnlcsetlc(&state, &c, &ct, k);
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
         }
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:1177");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:1178");
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardresults(&state, &ogrep);
            set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:1182");
         }
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(x1.xR, 1, c.xyR[i], 1, n);
            set_error_flag(wereerrors, fabs(v - c.xyR[i][n]) > tolx, __FILE__, __LINE__, "testminnlcunit.ap:1189");
         }
      }
   // Boundary and linear equality/inequality constrained QP problem with
   // excessive constraints:
   // * N*N SPD A with moderate condtion number (up to 100)
   // * boundary constraints 0 <= x[i] <= 1
   // * K=2*N equality/inequality constraints:
   //   * N/2 equality ones q'*x = q'*xm for random vector q
   //   * the rest are inequality ones, feasible at xm (xm is an inner point for these constraints)
   //   where xm is some random vector from the feasible hypercube (0.1 <= xm[i] <= 0.9)
   // * optimization problem has form 0.5*x'*A*x-b*x,
   //   where b is some random vector
   // * because constraints are excessive, the main problem is to find
   //   feasible point; we do not check that algorithm found a solution,
   //   we just check that it found feasible point.
   //
   // NOTE: this problem is difficult one (estimates of Lagrange multipliers converge
   //       slowly), so we use relaxed tolerances - 0.010 for AUL solver
      rho = 1000.0;
      aulits = 30;
      for (n = 1; n <= 6; n++) {
      // Generate problem: A, b, BndL, BndU, CMatrix, xm, x1, XStart
         k = 2 * n;
         spdmatrixrndcond(n, 1.0E2, &fulla);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&xm, n);
         ae_vector_set_length(&x0, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            xm.xR[i] = 0.1 + 0.8 * randomreal();
            bndl.xR[i] = 0.0;
            bndu.xR[i] = 1.0;
            x0.xR[i] = (double)randominteger(2);
            b.xR[i] = randommid();
         }
         for (i = 0; i < n / 2; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
               v += c.xyR[i][j] * xm.xR[j];
            }
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
         }
         for (i = n / 2; i < k; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs) / sqrt((double)n);
               v += c.xyR[i][j] * xm.xR[j];
            }
            c.xyR[i][n] = v;
            ct.xZ[i] = 2 * hqrnduniformi(&rs, 2) - 1;
            if (ct.xZ[i] > 0) {
               c.xyR[i][n] -= 0.1;
            } else {
               c.xyR[i][n] += 0.1;
            }
         }
      // Create optimizer, solve
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, rho, aulits);
            tolx = 0.0050;
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
               tolx = 0.0010;
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
                  tolx = 0.0010;
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetbc(&state, &bndl, &bndu);
         minnlcsetlc(&state, &c, &ct, k);
         minnlcsetcond(&state, 1.0E-7, 0);
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
         }
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:1309");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:1310");
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardresults(&state, &ogrep);
            set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:1314");
         }
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < k; i++) {
            v = ae_v_dotproduct(x1.xR, 1, c.xyR[i], 1, n);
            if (ct.xZ[i] == 0) {
               set_error_flag(wereerrors, fabs(v - c.xyR[i][n]) > tolx, __FILE__, __LINE__, "testminnlcunit.ap:1322");
            }
            if (ct.xZ[i] > 0) {
               set_error_flag(wereerrors, v < c.xyR[i][n] - tolx, __FILE__, __LINE__, "testminnlcunit.ap:1324");
            }
            if (ct.xZ[i] < 0) {
               set_error_flag(wereerrors, v > c.xyR[i][n] + tolx, __FILE__, __LINE__, "testminnlcunit.ap:1326");
            }
         }
      }
   // Boundary and linear equality constrained QP problem,
   // test checks that different starting points yield same final point:
   // * random N from [1..6], random K from [1..N-1]
   // * N*N SPD A with moderate condtion number (important!)
   // * boundary constraints 0 <= x[i] <= 1
   // * K<N random linear equality constraints C*x = C*x0,
   //   where x0 is some random vector from the inner area of the
   //   feasible hypercube (0.1 <= x0[i] <= 0.9)
   // * optimization problem has form 0.5*x'*A*x+b*x,
   //   where b is some random vector with -5 <= b[i] <= +5
   //
   // We solve this problem two times:
   // * each time from different initial point XStart in [-2,+2]
   // * we compare values of the target function (although final points
   //   may be slightly different, function values should match each other)
   //
   // Both points should give same results; any significant difference is
   // evidence of some error in the QP implementation.
      rho = 1000.0;
      tolf = 0.0001;
      aulits = 10;
      for (pass = 1; pass <= 50; pass++) {
      // Generate problem: N, K, A, b, BndL, BndU, CMatrix, x0, xm, XStart.
         n = randominteger(5) + 2;
         k = 1 + randominteger(n - 1);
         spdmatrixrndcond(n, 1.0E2, &fulla);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xstart, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 0.1 + 0.8 * randomreal();
            b.xR[i] = randommid();
            bndl.xR[i] = 0.0;
            bndu.xR[i] = 1.0;
         }
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = randommid();
            }
            c.xyR[i][i] += 4;
            v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = 0;
         }
      // Start from first point
         for (i = 0; i < n; i++) {
            xstart.xR[i] = 2.0 * randommid();
         }
         minnlccreate(n, &xstart, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, rho, aulits);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 1.0E-7, 0);
         minnlcsetbc(&state, &bndl, &bndu);
         minnlcsetlc(&state, &c, &ct, k);
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
         }
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x0, &rep);
         set_error_flag(wereerrors, !isfinitevector(&x0, n), __FILE__, __LINE__, "testminnlcunit.ap:1430");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:1431");
         if (hqrndnormal(&rs) > 0.0) {
            minnlcoptguardresults(&state, &ogrep);
            set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:1435");
         }
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Start from another point
         for (i = 0; i < n; i++) {
            xstart.xR[i] = 2.0 * randommid();
         }
         minnlcrestartfrom(&state, &xstart);
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:1466");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:1467");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Calculate function value at X0 and X1, compare solutions
         f0 = 0.0;
         f1 = 0.0;
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               f0 += 0.5 * x0.xR[i] * fulla.xyR[i][j] * x0.xR[j];
               f1 += 0.5 * x1.xR[i] * fulla.xyR[i][j] * x1.xR[j];
            }
            f0 += x0.xR[i] * b.xR[i];
            f1 += x1.xR[i] * b.xR[i];
         }
         set_error_flag(wereerrors, fabs(f0 - f1) > tolf, __FILE__, __LINE__, "testminnlcunit.ap:1486");
      }
   // Convex/nonconvex optimization problem with excessive
   // (degenerate constraints):
   //
   // * N=2..7
   // * f = 0.5*x'*A*x+b'*x
   // * b has normally distributed entries with scale 10^BScale
   // * several kinds of A are tried: zero, well conditioned SPD, well conditioned indefinite, low rank
   // * box constraints: x[i] in [-1,+1]
   // * 2^N "excessive" general linear constraints (v_k,x) <= (v_k,v_k)+v_shift,
   //   where v_k is one of 2^N vertices of feasible hypercube, v_shift is
   //   a shift parameter:
   //   * with zero v_shift such constraints are degenerate (each vertex has
   //     N box constraints and one "redundant" linear constraint)
   //   * with positive v_shift linear constraint is always inactive
   //   * with small (about machine epsilon) but negative v_shift,
   //     constraint is close to degenerate - but not exactly
   //
   // We check that constrained gradient is close to zero at solution.
   // Box constraint is considered active if distance to boundary is less
   // than TolConstr.
   //
   // NOTE: because AUL algorithm is less exact than its active set counterparts,
   //       VERY loose tolerances are used for this test.
      tolconstr = 1.0E-2;
      for (n = 2; n <= 6; n++) {
         for (akind = 0; akind <= 3; akind++) {
         // Choose random parameters
            shiftkind = hqrnduniformi(&rs, 7) - 5;
            bscale = hqrnduniformi(&rs, 3) - 2;
         // Generate A, B and initial point
            ae_matrix_set_length(&a, n, n);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&x, n);
            for (i = 0; i < n; i++) {
               b.xR[i] = pow(10.0, (double)bscale) * hqrndnormal(&rs);
               x.xR[i] = hqrnduniformr(&rs) - 0.5;
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = 0.0;
               }
            }
            if (akind == 1) {
            // Dense well conditioned SPD
               spdmatrixrndcond(n, 50.0, &a);
            }
            if (akind == 2) {
            // Dense well conditioned indefinite
               smatrixrndcond(n, 50.0, &a);
            }
            if (akind == 3) {
            // Low rank
               ae_vector_set_length(&tmp, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
                  a.xyR[i][i] = 1.0E-9;
               }
               for (k = 1; k < imin2(4, n); k++) {
                  for (i = 0; i < n; i++) {
                     tmp.xR[i] = hqrndnormal(&rs);
                  }
                  v = hqrndnormal(&rs);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                     }
                  }
               }
            }
         // Generate constraints
            ae_vector_set_length(&bl, n);
            ae_vector_set_length(&bu, n);
            for (i = 0; i < n; i++) {
               bl.xR[i] = -1.0;
               bu.xR[i] = 1.0;
            }
            ccnt = iround(pow(2.0, (double)n));
            ae_matrix_set_length(&c, ccnt, n + 1);
            ae_vector_set_length(&ct, ccnt);
            for (i = 0; i < ccnt; i++) {
               ct.xZ[i] = -1;
               k = i;
               c.xyR[i][n] = sign((double)shiftkind) * pow(10.0, fabs((double)shiftkind)) * machineepsilon;
               for (j = 0; j < n; j++) {
                  c.xyR[i][j] = (double)(2 * (k % 2) - 1);
                  c.xyR[i][n] += c.xyR[i][j] * c.xyR[i][j];
                  k /= 2;
               }
            }
         // Create and optimize
            minnlccreate(n, &x, &state);
            minnlcsetbc(&state, &bl, &bu);
            minnlcsetlc(&state, &c, &ct, ccnt);
            minnlcsetcond(&state, 1.0E-12, 0);
            if (solvertype == 0) {
               minnlcsetalgoaul(&state, rho, aulits);
            } else {
               if (solvertype == 1) {
                  minnlcsetalgoslp(&state);
               } else {
                  if (solvertype == 2) {
                     minnlcsetalgosqp(&state);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            }
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
            }
            while (minnlciteration(&state)) {
               ae_assert(state.needfij, "Assertion failed");
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += state.x.xR[i] * b.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
               }
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
                  state.fi.xR[0] += 0.5 * state.x.xR[i] * v;
                  state.j.xyR[0][i] += v;
               }
            }
            minnlcresults(&state, &xs0, &rep);
            set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:1641");
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardresults(&state, &ogrep);
               set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:1645");
            }
            if (*wereerrors) {
               ae_frame_leave();
               return;
            }
         // Evaluate gradient at solution and test
            vv = 0.0;
            gnrm2 = 0.0;
            for (i = 0; i < n; i++) {
               v = ae_v_dotproduct(a.xyR[i], 1, xs0.xR, 1, n);
               v += b.xR[i];
               gnrm2 += v * v;
               if (xs0.xR[i] <= bl.xR[i] + tolconstr && v > 0.0) {
                  v = 0.0;
               }
               if (xs0.xR[i] >= bu.xR[i] - tolconstr && v < 0.0) {
                  v = 0.0;
               }
               vv += sqr(v);
            }
            vv = sqrt(vv / (gnrm2 + 1.0));
            set_error_flag(wereerrors, vv > 1.0E-2, __FILE__, __LINE__, "testminnlcunit.ap:1672");
         }
      }
   // Linear/convex optimization problem with combination of
   // box and linear constraints:
   //
   // * N=2..8
   // * f = 0.5*x'*A*x+b'*x
   // * b has normally distributed entries with scale 10^BScale
   // * several kinds of A are tried: zero, well conditioned SPD
   // * box constraints: x[i] in [-1,+1]
   // * initial point x0 = [0 0 ... 0 0]
   // * CCnt=min(3,N-1) general linear constraints of form (c,x)=0.
   //   random mix of equality/inequality constraints is tried.
   //   x0 is guaranteed to be feasible.
   //
   // We check that constrained gradient is close to zero at solution.
   // Inequality constraint is considered active if distance to boundary
   // is less than TolConstr. We use nonnegative least squares solver
   // in order to compute constrained gradient.
      tolconstr = 1.0E-2;
      for (n = 2; n <= 8; n++) {
         for (akind = 0; akind <= 1; akind++) {
            for (bscale = 0; bscale >= -2; bscale--) {
            // Generate A, B and initial point
               ae_matrix_set_length(&a, n, n);
               ae_vector_set_length(&b, n);
               ae_vector_set_length(&x, n);
               for (i = 0; i < n; i++) {
                  b.xR[i] = pow(10.0, (double)bscale) * hqrndnormal(&rs);
                  x.xR[i] = 0.0;
               }
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = 0.0;
                  }
               }
               if (akind == 1) {
               // Dense well conditioned SPD
                  spdmatrixrndcond(n, 50.0, &a);
               }
               if (solvertype != 0) {
               // AUL performs poorly on such problems,
               // but SLP works goo.
                  if (akind == 2) {
                  // Dense well conditioned indefinite
                     smatrixrndcond(n, 50.0, &a);
                  }
                  if (akind == 3) {
                  // Low rank
                     ae_vector_set_length(&tmp, n);
                     for (i = 0; i < n; i++) {
                        for (j = 0; j < n; j++) {
                           a.xyR[i][j] = 0.0;
                        }
                        a.xyR[i][i] = 1.0E-9;
                     }
                     for (k = 1; k < imin2(4, n); k++) {
                        for (i = 0; i < n; i++) {
                           tmp.xR[i] = hqrndnormal(&rs);
                        }
                        v = hqrndnormal(&rs);
                        for (i = 0; i < n; i++) {
                           for (j = 0; j < n; j++) {
                              a.xyR[i][j] += v * tmp.xR[i] * tmp.xR[j];
                           }
                        }
                     }
                  }
               }
            // Generate constraints
               ae_vector_set_length(&bl, n);
               ae_vector_set_length(&bu, n);
               for (i = 0; i < n; i++) {
                  bl.xR[i] = -1.0;
                  bu.xR[i] = 1.0;
               }
               ccnt = imin2(3, n - 1);
               ae_matrix_set_length(&c, ccnt, n + 1);
               ae_vector_set_length(&ct, ccnt);
               for (i = 0; i < ccnt; i++) {
                  ct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
                  c.xyR[i][n] = 0.0;
                  for (j = 0; j < n; j++) {
                     c.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
                  }
                  c.xyR[i][i] += 4;
               }
            // Create and optimize
               minnlccreate(n, &x, &state);
               minnlcsetbc(&state, &bl, &bu);
               minnlcsetlc(&state, &c, &ct, ccnt);
               minnlcsetcond(&state, 1.0E-7, 0);
               if (solvertype == 0) {
                  minnlcsetalgoaul(&state, 1000.0, 10);
               } else {
                  if (solvertype == 1) {
                     minnlcsetalgoslp(&state);
                  } else {
                     if (solvertype == 2) {
                        minnlcsetalgosqp(&state);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
               }
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
               }
               while (minnlciteration(&state)) {
                  ae_assert(state.needfij, "Assertion failed");
                  state.fi.xR[0] = 0.0;
                  for (i = 0; i < n; i++) {
                     state.fi.xR[0] += state.x.xR[i] * b.xR[i];
                     state.j.xyR[0][i] = b.xR[i];
                  }
                  for (i = 0; i < n; i++) {
                     v = ae_v_dotproduct(a.xyR[i], 1, state.x.xR, 1, n);
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * v;
                     state.j.xyR[0][i] += v;
                  }
               }
               minnlcresults(&state, &xs0, &rep);
               set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:1817");
               if (hqrndnormal(&rs) > 0.0) {
                  minnlcoptguardresults(&state, &ogrep);
                  set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:1821");
               }
               if (*wereerrors) {
                  ae_frame_leave();
                  return;
               }
            // 1. evaluate unconstrained gradient at solution
            //
            // 2. calculate constrained gradient (NNLS solver is used
            //    to evaluate gradient subject to active constraints).
            //    In order to do this we form CE matrix, matrix of active
            //    constraints (columns store constraint vectors). Then
            //    we try to approximate gradient vector by columns of CE,
            //    subject to non-negativity restriction placed on variables
            //    corresponding to inequality constraints.
            //
            //    Residual from such regression is a constrained gradient vector.
               ae_vector_set_length(&g, n);
               for (i = 0; i < n; i++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, xs0.xR, 1, n);
                  g.xR[i] = v + b.xR[i];
               }
               ae_matrix_set_length(&ce, n, n + ccnt);
               ae_vector_set_length(&nonnegative, n + ccnt);
               k = 0;
               for (i = 0; i < n; i++) {
                  set_error_flag(wereerrors, xs0.xR[i] < bl.xR[i] - tolconstr, __FILE__, __LINE__, "testminnlcunit.ap:1850");
                  set_error_flag(wereerrors, xs0.xR[i] > bu.xR[i] + tolconstr, __FILE__, __LINE__, "testminnlcunit.ap:1851");
                  if (xs0.xR[i] <= bl.xR[i] + tolconstr) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = 0.0;
                     }
                     ce.xyR[i][k] = 1.0;
                     nonnegative.xB[k] = true;
                     k++;
                     continue;
                  }
                  if (xs0.xR[i] >= bu.xR[i] - tolconstr) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = 0.0;
                     }
                     ce.xyR[i][k] = -1.0;
                     nonnegative.xB[k] = true;
                     k++;
                     continue;
                  }
               }
               for (i = 0; i < ccnt; i++) {
                  v = ae_v_dotproduct(c.xyR[i], 1, xs0.xR, 1, n);
                  v -= c.xyR[i][n];
                  set_error_flag(wereerrors, ct.xZ[i] == 0 && fabs(v) > tolconstr, __FILE__, __LINE__, "testminnlcunit.ap:1875");
                  set_error_flag(wereerrors, ct.xZ[i] > 0 && v < -tolconstr, __FILE__, __LINE__, "testminnlcunit.ap:1876");
                  set_error_flag(wereerrors, ct.xZ[i] < 0 && v > tolconstr, __FILE__, __LINE__, "testminnlcunit.ap:1877");
                  if (ct.xZ[i] == 0) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = c.xyR[i][j];
                     }
                     nonnegative.xB[k] = false;
                     k++;
                     continue;
                  }
                  if ((ct.xZ[i] > 0 && v <= tolconstr) || (ct.xZ[i] < 0 && v >= -tolconstr)) {
                     for (j = 0; j < n; j++) {
                        ce.xyR[j][k] = sign((double)ct.xZ[i]) * c.xyR[i][j];
                     }
                     nonnegative.xB[k] = true;
                     k++;
                     continue;
                  }
               }
               snnlsinit(0, 0, 0, &nnls);
               snnlssetproblem(&nnls, &ce, &g, 0, k, n);
               for (i = 0; i < k; i++) {
                  if (!nonnegative.xB[i]) {
                     snnlsdropnnc(&nnls, i);
                  }
               }
               snnlssolve(&nnls, &tmp);
               for (i = 0; i < k; i++) {
                  for (j = 0; j < n; j++) {
                     g.xR[j] -= tmp.xR[i] * ce.xyR[j][i];
                  }
               }
               vv = ae_v_dotproduct(g.xR, 1, g.xR, 1, n);
               vv = sqrt(vv);
               set_error_flag(wereerrors, vv > 1.0E-3, __FILE__, __LINE__, "testminnlcunit.ap:1906");
            }
         }
      }
   }
   ae_frame_leave();
}

// This function tests nonlinearly constrained quadratic programming algorithm.
//
// Sets error flag on failure.
static void testminnlcunit_testnlc(bool *wereerrors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t n2;
   double tolx;
   double tolg;
   ae_int_t aulits;
   double rho;
   ae_int_t scaletype;
   ae_int_t cntbc;
   ae_int_t cntlc;
   ae_int_t cntnlec;
   ae_int_t cntnlic;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t pass;
   ae_int_t klc;
   ae_int_t knlec;
   ae_int_t knlic;
   double v;
   double vv;
   double vx;
   double vy;
   double gnorm2;
   double rawgnorm2;
   ae_int_t prectype;
   ae_int_t solvertype;
   ae_frame_make(&_frame_block);
   NewObj(minnlcstate, state);
   NewObj(minnlcreport, rep);
   NewObj(optguardreport, ogrep);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(rnlc, 0, DT_REAL);
   NewVector(ckind, 0, DT_INT);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   for (solvertype = 0; solvertype <= testminnlcunit_maxsolvertype; solvertype++) {
   // Basic test:
   // * 2-dimensional problem
   // * target function F(x0,x1) = (x0-1)^2 + (x1-1)^2
   // * one nonlinear constraint Z(x0,x1) = x0^2+x1^2-1,
   //   which is tried as equality and inequality one
      rho = 200.0;
      tolx = 0.0005;
      aulits = 50;
      n = 2;
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
      }
      minnlccreate(n, &x0, &state);
      if (solvertype == 0) {
         minnlcsetalgoaul(&state, rho, aulits);
      } else {
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
      }
      minnlcsetcond(&state, 1.0E-7, 0);
      minnlcsetnlc(&state, 0, 1);
      while (minnlciteration(&state)) {
         if (state.needfij) {
            state.fi.xR[0] = sqr(state.x.xR[0] - 1) + sqr(state.x.xR[1] - 1);
            state.j.xyR[0][0] = 2 * (state.x.xR[0] - 1);
            state.j.xyR[0][1] = 2 * (state.x.xR[1] - 1);
            state.fi.xR[1] = sqr(state.x.xR[0]) + sqr(state.x.xR[1]) - 1;
            state.j.xyR[1][0] = 2 * state.x.xR[0];
            state.j.xyR[1][1] = 2 * state.x.xR[1];
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnlcresults(&state, &x1, &rep);
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:1992");
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:1993");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
      set_error_flag(wereerrors, fabs(x1.xR[0] - sqrt(2.0) / 2) > tolx, __FILE__, __LINE__, "testminnlcunit.ap:1996");
      set_error_flag(wereerrors, fabs(x1.xR[1] - sqrt(2.0) / 2) > tolx, __FILE__, __LINE__, "testminnlcunit.ap:1997");
      minnlcsetnlc(&state, 1, 0);
      minnlcrestartfrom(&state, &x0);
      if (hqrndnormal(&rs) > 0.0) {
         minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
      }
      while (minnlciteration(&state)) {
         if (state.needfij) {
            state.fi.xR[0] = sqr(state.x.xR[0] - 1) + sqr(state.x.xR[1] - 1);
            state.j.xyR[0][0] = 2 * (state.x.xR[0] - 1);
            state.j.xyR[0][1] = 2 * (state.x.xR[1] - 1);
            state.fi.xR[1] = sqr(state.x.xR[0]) + sqr(state.x.xR[1]) - 1;
            state.j.xyR[1][0] = 2 * state.x.xR[0];
            state.j.xyR[1][1] = 2 * state.x.xR[1];
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnlcresults(&state, &x1, &rep);
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:2017");
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:2018");
      if (hqrndnormal(&rs) > 0.0) {
         minnlcoptguardresults(&state, &ogrep);
         set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:2022");
      }
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
      set_error_flag(wereerrors, fabs(x1.xR[0] - sqrt(2.0) / 2) > tolx, __FILE__, __LINE__, "testminnlcunit.ap:2026");
      set_error_flag(wereerrors, fabs(x1.xR[1] - sqrt(2.0) / 2) > tolx, __FILE__, __LINE__, "testminnlcunit.ap:2027");
   // This test checks correctness of scaling being applied to nonlinear
   // constraints. We solve bound constrained scaled problem and check
   // that solution is correct.
      aulits = 50;
      rho = 200.0;
      tolx = 0.0005;
      tolg = 0.01;
      for (n = 1; n <= 10; n++) {
         for (pass = 1; pass <= 10; pass++) {
         // Generate well-conditioned problem with unit scale
            spdmatrixrndcond(n, 1.0E2, &fulla);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            ae_vector_set_length(&x0, n);
            for (i = 0; i < n; i++) {
               b.xR[i] = hqrndnormal(&rs);
               x0.xR[i] = hqrndnormal(&rs);
            }
            cntnlec = hqrnduniformi(&rs, n);
            cntnlic = n - cntnlec;
            for (i = 0; i < cntnlec; i++) {
               bndl.xR[i] = hqrndnormal(&rs);
               bndu.xR[i] = bndl.xR[i];
            }
            for (i = cntnlec; i < n; i++) {
               bndl.xR[i] = hqrndnormal(&rs);
               bndu.xR[i] = bndl.xR[i] + 0.5;
            }
         // Apply scaling to quadratic/linear term, so problem becomes
         // well-conditioned in the scaled coordinates.
            scaletype = hqrnduniformi(&rs, 2);
            ae_vector_set_length(&s, n);
            for (i = 0; i < n; i++) {
               if (scaletype == 0) {
                  s.xR[i] = 1.0;
               } else {
                  s.xR[i] = exp(5 * hqrndnormal(&rs));
               }
            }
            for (i = 0; i < n; i++) {
               x0.xR[i] *= s.xR[i];
               bndl.xR[i] *= s.xR[i];
               bndu.xR[i] *= s.xR[i];
               b.xR[i] /= s.xR[i];
               for (j = 0; j < n; j++) {
                  fulla.xyR[i][j] /= s.xR[i] * s.xR[j];
               }
            }
         // Solve problem with boundary constraints posed as nonlinear ones
            minnlccreate(n, &x0, &state);
            if (solvertype == 0) {
               minnlcsetalgoaul(&state, rho, aulits);
            } else {
               if (solvertype == 1) {
                  minnlcsetalgoslp(&state);
               } else {
                  if (solvertype == 2) {
                     minnlcsetalgosqp(&state);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            }
            minnlcsetscale(&state, &s);
            minnlcsetnlc(&state, cntnlec, 2 * cntnlic);
            minnlcsetcond(&state, 1.0E-7, 0);
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
            }
            while (minnlciteration(&state)) {
               if (state.needfij) {
                  for (i = 0; i <= cntnlec + 2 * cntnlic; i++) {
                     state.fi.xR[i] = 0.0;
                     for (j = 0; j < n; j++) {
                        state.j.xyR[i][j] = 0.0;
                     }
                  }
               // Function itself
                  for (i = 0; i < n; i++) {
                     state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                     state.j.xyR[0][i] = b.xR[i];
                     for (j = 0; j < n; j++) {
                        state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                        state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                     }
                  }
               // Equality constraints
                  for (i = 0; i < cntnlec; i++) {
                     state.fi.xR[1 + i] = (state.x.xR[i] - bndl.xR[i]) / s.xR[i];
                     state.j.xyR[1 + i][i] = 1 / s.xR[i];
                  }
               // Inequality constraints
                  for (i = 0; i < cntnlic; i++) {
                     k = cntnlec + i;
                     state.fi.xR[1 + cntnlec + 2 * i + 0] = (bndl.xR[k] - state.x.xR[k]) / s.xR[k];
                     state.j.xyR[1 + cntnlec + 2 * i + 0][k] = -1 / s.xR[k];
                     state.fi.xR[1 + cntnlec + 2 * i + 1] = (state.x.xR[k] - bndu.xR[k]) / s.xR[k];
                     state.j.xyR[1 + cntnlec + 2 * i + 1][k] = 1 / s.xR[k];
                  }
                  continue;
               }
               ae_assert(false, "Assertion failed");
            }
            minnlcresults(&state, &x1, &rep);
            set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:2161");
            set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:2162");
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardresults(&state, &ogrep);
               set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:2166");
            }
            if (*wereerrors) {
               ae_frame_leave();
               return;
            }
         // Check feasibility properties
            for (i = 0; i < n; i++) {
               set_error_flag(wereerrors, isfinite(bndl.xR[i]) && x1.xR[i] <= bndl.xR[i] - tolx * s.xR[i], __FILE__, __LINE__, "testminnlcunit.ap:2176");
               set_error_flag(wereerrors, isfinite(bndu.xR[i]) && x1.xR[i] >= bndu.xR[i] + tolx * s.xR[i], __FILE__, __LINE__, "testminnlcunit.ap:2177");
            }
         // Test - calculate scaled constrained gradient at solution,
         // check its norm.
            ae_vector_set_length(&g, n);
            gnorm2 = 0.0;
            for (i = 0; i < n; i++) {
               g.xR[i] = b.xR[i];
               for (j = 0; j < n; j++) {
                  g.xR[i] += fulla.xyR[i][j] * x1.xR[j];
               }
               g.xR[i] *= s.xR[i];
               if ((isfinite(bndl.xR[i]) && fabs(x1.xR[i] - bndl.xR[i]) < tolx * s.xR[i]) && g.xR[i] > 0.0) {
                  g.xR[i] = 0.0;
               }
               if ((isfinite(bndu.xR[i]) && fabs(x1.xR[i] - bndu.xR[i]) < tolx * s.xR[i]) && g.xR[i] < 0.0) {
                  g.xR[i] = 0.0;
               }
               gnorm2 += sqr(g.xR[i]);
            }
            set_error_flag(wereerrors, gnorm2 > sqr(tolg), __FILE__, __LINE__, "testminnlcunit.ap:2199");
         }
      }
   // Complex problem with mix of boundary, linear and nonlinear constraints:
   // * quadratic target function f(x) = 0.5*x'*A*x + b'*x
   // * unit scaling is used
   // * problem size N is even
   // * all variables are divided into pairs: x[0] and x[1], x[2] and x[3], ...
   // * constraints are set for pairs of variables, i.e. each constraint involves
   //   only pair of adjacent variables (x0/x1, x2/x3, x4/x5 and so on), and each
   //   pair of variables has at most one constraint which binds them
   // * for variables u and v following kinds of constraints can be randomly set:
   //   * CKind=0      no constraint
   //   * CKind=1      boundary equality constraint:    u=a, v=b
   //   * CKind=2      boundary inequality constraint:  a0 <= u <= b0, a1 <= v <= b1
   //   * CKind=3      linear equality constraint:      a*u+b*v  = c
   //   * CKind=4      linear inequality constraint:    a*u+b*v <= c
   //   * CKind=5      nonlinear equality constraint:   u^2+v^2  = 1
   //   * CKind=6      nonlinear inequality constraint: u^2+v^2 <= 1
   // * it is relatively easy to calculated projected gradient for such problem
      aulits = 50;
      rho = 200.0;
      tolx = 0.0005;
      tolg = 0.005;
      n = 20;
      n2 = n / 2;
      for (pass = 1; pass <= 5; pass++) {
         for (prectype = 1; prectype <= 2; prectype++) {
         // Generate well-conditioned problem with unit scale
            spdmatrixrndcond(n, 1.0E2, &fulla);
            ae_vector_set_length(&b, n);
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            ae_matrix_set_length(&c, n, n + 1);
            ae_vector_set_length(&ct, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&ckind, n2);
            ae_vector_set_length(&rnlc, n2);
            cntbc = 0;
            cntlc = 0;
            cntnlec = 0;
            cntnlic = 0;
            for (i = 0; i < n; i++) {
               bndl.xR[i] = -INFINITY;
               bndu.xR[i] = +INFINITY;
               x0.xR[i] = hqrndnormal(&rs);
               b.xR[i] = 10 * hqrndnormal(&rs);
            }
            for (i = 0; i < n2; i++) {
               ckind.xZ[i] = hqrnduniformi(&rs, 7);
               rnlc.xR[i] = 0.0;
               if (ckind.xZ[i] == 0) {
               // Unconstrained
                  continue;
               }
               if (ckind.xZ[i] == 1) {
               // Bound equality constrained
                  bndl.xR[2 * i + 0] = hqrnduniformr(&rs) - 0.5;
                  bndu.xR[2 * i + 0] = bndl.xR[2 * i + 0];
                  bndl.xR[2 * i + 1] = hqrnduniformr(&rs) - 0.5;
                  bndu.xR[2 * i + 1] = bndl.xR[2 * i + 1];
                  cntbc++;
                  continue;
               }
               if (ckind.xZ[i] == 2) {
               // Bound inequality constrained
                  bndl.xR[2 * i + 0] = hqrnduniformr(&rs) - 0.5;
                  bndu.xR[2 * i + 0] = bndl.xR[2 * i + 0] + 0.5;
                  bndl.xR[2 * i + 1] = hqrnduniformr(&rs) - 0.5;
                  bndu.xR[2 * i + 1] = bndl.xR[2 * i + 1] + 0.5;
                  cntbc++;
                  continue;
               }
               if (ckind.xZ[i] == 3) {
               // Linear equality constrained
                  for (j = 0; j <= n; j++) {
                     c.xyR[cntlc][j] = 0.0;
                  }
                  vx = hqrnduniformr(&rs) - 0.5;
                  vy = hqrnduniformr(&rs) - 0.5;
                  c.xyR[cntlc][2 * i + 0] = vx;
                  c.xyR[cntlc][2 * i + 1] = vy;
                  c.xyR[cntlc][n] = hqrnduniformr(&rs) - 0.5;
                  ct.xZ[cntlc] = 0;
                  cntlc++;
                  continue;
               }
               if (ckind.xZ[i] == 4) {
               // Linear inequality constrained
                  for (j = 0; j <= n; j++) {
                     c.xyR[cntlc][j] = 0.0;
                  }
                  vx = hqrnduniformr(&rs) - 0.5;
                  vy = hqrnduniformr(&rs) - 0.5;
                  c.xyR[cntlc][2 * i + 0] = vx;
                  c.xyR[cntlc][2 * i + 1] = vy;
                  c.xyR[cntlc][n] = hqrnduniformr(&rs) - 0.5;
                  ct.xZ[cntlc] = -1;
                  cntlc++;
                  continue;
               }
               if (ckind.xZ[i] == 5) {
               // Nonlinear equality constrained
                  rnlc.xR[i] = 0.5 + hqrnduniformr(&rs);
                  cntnlec++;
                  continue;
               }
               if (ckind.xZ[i] == 6) {
               // Nonlinear inequality constrained
                  rnlc.xR[i] = 0.5 + hqrnduniformr(&rs);
                  cntnlic++;
                  continue;
               }
               ae_assert(false, "Assertion failed");
            }
         // Solve problem
            minnlccreate(n, &x0, &state);
            if (solvertype == 0) {
               minnlcsetalgoaul(&state, rho, aulits);
               minnlcsetcond(&state, 1.0E-7, 0);
               if (prectype == 0) {
                  minnlcsetprecinexact(&state);
               }
               if (prectype == 1) {
                  minnlcsetprecexactlowrank(&state, 0);
               }
               if (prectype == 2) {
                  minnlcsetprecexactrobust(&state, 0);
               }
            } else {
               if (solvertype == 1) {
                  minnlcsetalgoslp(&state);
                  minnlcsetcond(&state, 1.0E-6, 0);
               } else {
                  if (solvertype == 2) {
                     minnlcsetalgosqp(&state);
                     minnlcsetcond(&state, 1.0E-6, 0);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            }
            minnlcsetbc(&state, &bndl, &bndu);
            minnlcsetlc(&state, &c, &ct, cntlc);
            minnlcsetnlc(&state, cntnlec, cntnlic);
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardsmoothness(&state, hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel + 1));
            }
            while (minnlciteration(&state)) {
               if (state.needfij) {
               // Evaluate target function
                  state.fi.xR[0] = 0.0;
                  for (i = 0; i < n; i++) {
                     state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                     state.j.xyR[0][i] = b.xR[i];
                     for (j = 0; j < n; j++) {
                        state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                        state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                     }
                  }
               // Evaluate constraint functions
                  knlec = 1;
                  knlic = 1 + cntnlec;
                  for (i = 0; i < n2; i++) {
                     if (ckind.xZ[i] == 5) {
                        state.fi.xR[knlec] = 0.0;
                        for (j = 0; j < n; j++) {
                           state.j.xyR[knlec][j] = 0.0;
                        }
                        state.fi.xR[knlec] = sqr(state.x.xR[2 * i + 0]) + sqr(state.x.xR[2 * i + 1]) - rnlc.xR[i];
                        state.j.xyR[knlec][2 * i + 0] = 2 * state.x.xR[2 * i + 0];
                        state.j.xyR[knlec][2 * i + 1] = 2 * state.x.xR[2 * i + 1];
                        knlec++;
                        continue;
                     }
                     if (ckind.xZ[i] == 6) {
                        state.fi.xR[knlic] = 0.0;
                        for (j = 0; j < n; j++) {
                           state.j.xyR[knlic][j] = 0.0;
                        }
                        state.fi.xR[knlic] = sqr(state.x.xR[2 * i + 0]) + sqr(state.x.xR[2 * i + 1]) - rnlc.xR[i];
                        state.j.xyR[knlic][2 * i + 0] = 2 * state.x.xR[2 * i + 0];
                        state.j.xyR[knlic][2 * i + 1] = 2 * state.x.xR[2 * i + 1];
                        knlic++;
                        continue;
                     }
                  }
                  ae_assert(knlec == 1 + cntnlec, "Assertion failed");
                  ae_assert(knlic == 1 + cntnlec + cntnlic, "Assertion failed");
                  continue;
               }
               ae_assert(false, "Assertion failed");
            }
            minnlcresults(&state, &x1, &rep);
            set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:2430");
            set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:2431");
            if (hqrndnormal(&rs) > 0.0) {
               minnlcoptguardresults(&state, &ogrep);
               set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:2435");
            }
            if (*wereerrors) {
               ae_frame_leave();
               return;
            }
         // Check feasibility properties
            klc = 0;
            for (i = 0; i < n2; i++) {
               if (ckind.xZ[i] == 0) {
               // Unconstrained
                  continue;
               }
               if (ckind.xZ[i] == 1) {
               // Bound equality constrained
                  set_error_flag(wereerrors, fabs(x1.xR[2 * i + 0] - bndl.xR[2 * i + 0]) > tolx, __FILE__, __LINE__, "testminnlcunit.ap:2458");
                  set_error_flag(wereerrors, fabs(x1.xR[2 * i + 1] - bndl.xR[2 * i + 1]) > tolx, __FILE__, __LINE__, "testminnlcunit.ap:2459");
                  continue;
               }
               if (ckind.xZ[i] == 2) {
               // Bound inequality constrained
                  set_error_flag(wereerrors, x1.xR[2 * i + 0] < bndl.xR[2 * i + 0] - tolx, __FILE__, __LINE__, "testminnlcunit.ap:2467");
                  set_error_flag(wereerrors, x1.xR[2 * i + 0] > bndu.xR[2 * i + 0] + tolx, __FILE__, __LINE__, "testminnlcunit.ap:2468");
                  set_error_flag(wereerrors, x1.xR[2 * i + 1] < bndl.xR[2 * i + 1] - tolx, __FILE__, __LINE__, "testminnlcunit.ap:2469");
                  set_error_flag(wereerrors, x1.xR[2 * i + 1] > bndu.xR[2 * i + 1] + tolx, __FILE__, __LINE__, "testminnlcunit.ap:2470");
                  continue;
               }
               if (ckind.xZ[i] == 3) {
               // Linear equality constrained
                  v = x1.xR[2 * i + 0] * c.xyR[klc][2 * i + 0] + x1.xR[2 * i + 1] * c.xyR[klc][2 * i + 1] - c.xyR[klc][n];
                  set_error_flag(wereerrors, fabs(v) > tolx, __FILE__, __LINE__, "testminnlcunit.ap:2479");
                  klc++;
                  continue;
               }
               if (ckind.xZ[i] == 4) {
               // Linear inequality constrained
                  v = x1.xR[2 * i + 0] * c.xyR[klc][2 * i + 0] + x1.xR[2 * i + 1] * c.xyR[klc][2 * i + 1] - c.xyR[klc][n];
                  set_error_flag(wereerrors, v > tolx, __FILE__, __LINE__, "testminnlcunit.ap:2489");
                  klc++;
                  continue;
               }
               if (ckind.xZ[i] == 5) {
               // Nonlinear equality constrained
                  v = sqr(x1.xR[2 * i + 0]) + sqr(x1.xR[2 * i + 1]) - rnlc.xR[i];
                  set_error_flag(wereerrors, fabs(v) > tolx, __FILE__, __LINE__, "testminnlcunit.ap:2499");
                  continue;
               }
               if (ckind.xZ[i] == 6) {
               // Nonlinear inequality constrained
                  v = sqr(x1.xR[2 * i + 0]) + sqr(x1.xR[2 * i + 1]) - rnlc.xR[i];
                  set_error_flag(wereerrors, v > tolx, __FILE__, __LINE__, "testminnlcunit.ap:2508");
                  continue;
               }
               ae_assert(false, "Assertion failed");
            }
         // Test - calculate scaled constrained gradient at solution,
         // check its norm.
            gnorm2 = 0.0;
            rawgnorm2 = 0.0;
            ae_vector_set_length(&g, n);
            for (i = 0; i < n; i++) {
               v = b.xR[i];
               for (j = 0; j < n; j++) {
                  v += fulla.xyR[i][j] * x1.xR[j];
               }
               g.xR[i] = v;
               rawgnorm2 += v * v;
            }
            klc = 0;
            for (i = 0; i < n2; i++) {
               if (ckind.xZ[i] == 0) {
               // Unconstrained
                  gnorm2 += sqr(g.xR[2 * i + 0]) + sqr(g.xR[2 * i + 1]);
                  set_error_flag(wereerrors, gnorm2 > sqr(tolg) * rmax2(rawgnorm2, 1.0), __FILE__, __LINE__, "testminnlcunit.ap:2538");
                  continue;
               }
               if (ckind.xZ[i] == 1) {
               // Bound equality constrained, unconditionally set gradient to zero
                  g.xR[2 * i + 0] = 0.0;
                  g.xR[2 * i + 1] = 0.0;
                  gnorm2 += sqr(g.xR[2 * i + 0]) + sqr(g.xR[2 * i + 1]);
                  set_error_flag(wereerrors, gnorm2 > sqr(tolg) * rmax2(rawgnorm2, 1.0), __FILE__, __LINE__, "testminnlcunit.ap:2549");
                  continue;
               }
               if (ckind.xZ[i] == 2) {
               // Bound inequality constrained, conditionally set gradient to zero
               // (when constraint is active)
                  if (x1.xR[2 * i + 0] < bndl.xR[2 * i + 0] + tolx || x1.xR[2 * i + 0] > bndu.xR[2 * i + 0] - tolx) {
                     g.xR[2 * i + 0] = 0.0;
                  }
                  if (x1.xR[2 * i + 1] < bndl.xR[2 * i + 1] + tolx || x1.xR[2 * i + 1] > bndu.xR[2 * i + 1] - tolx) {
                     g.xR[2 * i + 1] = 0.0;
                  }
                  gnorm2 += sqr(g.xR[2 * i + 0]) + sqr(g.xR[2 * i + 1]);
                  set_error_flag(wereerrors, gnorm2 > sqr(tolg) * rmax2(rawgnorm2, 1.0), __FILE__, __LINE__, "testminnlcunit.ap:2563");
                  continue;
               }
               if (ckind.xZ[i] == 3) {
               // Linear equality constrained, unconditionally project gradient into
               // equality constrained subspace
                  v = g.xR[2 * i + 0] * c.xyR[klc][2 * i + 0] + g.xR[2 * i + 1] * c.xyR[klc][2 * i + 1];
                  vv = sqr(c.xyR[klc][2 * i + 0]) + sqr(c.xyR[klc][2 * i + 1]);
                  g.xR[2 * i + 0] -= c.xyR[klc][2 * i + 0] * (v / vv);
                  g.xR[2 * i + 1] -= c.xyR[klc][2 * i + 1] * (v / vv);
                  klc++;
                  gnorm2 += sqr(g.xR[2 * i + 0]) + sqr(g.xR[2 * i + 1]);
                  set_error_flag(wereerrors, gnorm2 > sqr(tolg) * rmax2(rawgnorm2, 1.0), __FILE__, __LINE__, "testminnlcunit.ap:2578");
                  continue;
               }
               if (ckind.xZ[i] == 4) {
               // Linear inequality constrained, conditionally project gradient
               // (when constraint is active)
                  v = x1.xR[2 * i + 0] * c.xyR[klc][2 * i + 0] + x1.xR[2 * i + 1] * c.xyR[klc][2 * i + 1] - c.xyR[klc][n];
                  if (v > -tolx) {
                     v = g.xR[2 * i + 0] * c.xyR[klc][2 * i + 0] + g.xR[2 * i + 1] * c.xyR[klc][2 * i + 1];
                     vv = sqr(c.xyR[klc][2 * i + 0]) + sqr(c.xyR[klc][2 * i + 1]);
                     g.xR[2 * i + 0] -= c.xyR[klc][2 * i + 0] * (v / vv);
                     g.xR[2 * i + 1] -= c.xyR[klc][2 * i + 1] * (v / vv);
                  }
                  klc++;
                  gnorm2 += sqr(g.xR[2 * i + 0]) + sqr(g.xR[2 * i + 1]);
                  set_error_flag(wereerrors, gnorm2 > sqr(tolg) * rmax2(rawgnorm2, 1.0), __FILE__, __LINE__, "testminnlcunit.ap:2597");
                  continue;
               }
               if (ckind.xZ[i] == 5) {
               // Nonlinear equality constrained, unconditionally project gradient
               //
               // NOTE: here we rely on the fact that corresponding components of X
               //       sum to one.
                  v = coalesce(sqrt(sqr(x1.xR[2 * i + 0]) + sqr(x1.xR[2 * i + 1])), 1.0);
                  vx = x1.xR[2 * i + 0] / v;
                  vy = x1.xR[2 * i + 1] / v;
                  v = g.xR[2 * i + 0] * vx + g.xR[2 * i + 1] * vy;
                  g.xR[2 * i + 0] -= vx * v;
                  g.xR[2 * i + 1] -= vy * v;
                  gnorm2 += sqr(g.xR[2 * i + 0]) + sqr(g.xR[2 * i + 1]);
                  set_error_flag(wereerrors, gnorm2 > sqr(tolg) * rmax2(rawgnorm2, 1.0), __FILE__, __LINE__, "testminnlcunit.ap:2615");
                  continue;
               }
               if (ckind.xZ[i] == 6) {
               // Nonlinear inequality constrained, conditionally project gradient
               // (when constraint is active)
               //
               // NOTE: here we rely on the fact that corresponding components of X
               //       sum to one.
                  v = sqr(x1.xR[2 * i + 0]) + sqr(x1.xR[2 * i + 1]) - rnlc.xR[i];
                  if (v > -tolx) {
                     v = coalesce(sqrt(sqr(x1.xR[2 * i + 0]) + sqr(x1.xR[2 * i + 1])), 1.0);
                     vx = x1.xR[2 * i + 0] / v;
                     vy = x1.xR[2 * i + 1] / v;
                     v = g.xR[2 * i + 0] * vx + g.xR[2 * i + 1] * vy;
                     g.xR[2 * i + 0] -= vx * v;
                     g.xR[2 * i + 1] -= vy * v;
                  }
                  gnorm2 += sqr(g.xR[2 * i + 0]) + sqr(g.xR[2 * i + 1]);
                  set_error_flag(wereerrors, gnorm2 > sqr(tolg) * rmax2(rawgnorm2, 1.0), __FILE__, __LINE__, "testminnlcunit.ap:2638");
                  continue;
               }
               ae_assert(false, "Assertion failed");
            }
         }
      }
   }
   ae_frame_leave();
}

// This function performs additional tests
//
// On failure sets error flag.
static void testminnlcunit_testother(bool *wereerrors) {
   ae_frame _frame_block;
   double v;
   double h;
   double fl;
   double fr;
   double fl2;
   double fr2;
   double dfl;
   double dfr;
   double dfl2;
   double dfr2;
   double d2fl;
   double d2fr;
   double d2fl2;
   double d2fr2;
   double f0;
   double df;
   double d2f;
   double ndf;
   double nd2f;
   double dtol;
   double diffstep;
   double rho;
   ae_int_t aulits;
   double tolx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   double condv;
   ae_int_t nlbfgs;
   ae_int_t nexactlowrank;
   ae_int_t nexactrobust;
   ae_int_t nnone;
   ae_int_t ctype;
   ae_int_t trialidx;
   ae_int_t blocksize;
   ae_int_t blockcnt;
   ae_int_t maxits;
   ae_int_t spoiliteration;
   ae_int_t stopiteration;
   ae_int_t spoilvar;
   double spoilval;
   ae_int_t pass;
   ae_int_t solvertype;
   ae_int_t badidx0;
   ae_int_t badidx1;
   ae_int_t nlec;
   ae_int_t nlic;
   double ss;
   ae_int_t stopcallidx;
   ae_int_t callidx;
   bool terminationrequested;
   bool firstrep;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minnlcstate, state);
   NewObj(minnlcreport, rep);
   NewObj(optguardreport, ogrep);
   NewVector(s, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(x3, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(xu, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   hqrndrandomize(&rs);
// Test equality penalty function (correctly calculated and smooth)
   h = 1.0E-4;
   v = -0.98;
   dtol = 1.0E-3;
   while (v <= 0.98) {
   // Test numerical derivative; this test also checks continuity of the
   // function
      minnlcequalitypenaltyfunction(v - 2 * h, &fl2, &dfl2, &d2fl2);
      minnlcequalitypenaltyfunction(v - h, &fl, &dfl, &d2fl);
      minnlcequalitypenaltyfunction(v + h, &fr, &dfr, &d2fr);
      minnlcequalitypenaltyfunction(v + 2 * h, &fr2, &dfr2, &d2fr2);
      minnlcequalitypenaltyfunction(v, &f0, &df, &d2f);
      ndf = (-fr2 + 8 * fr - 8 * fl + fl2) / (12 * h);
      set_error_flag(wereerrors, fabs(ndf - df) > dtol * rmax2(fabs(ndf), 1.0), __FILE__, __LINE__, "testminnlcunit.ap:2727");
      nd2f = (-dfr2 + 8 * dfr - 8 * dfl + dfl2) / (12 * h);
      set_error_flag(wereerrors, fabs(nd2f - d2f) > dtol * rmax2(fabs(nd2f), 1.0), __FILE__, __LINE__, "testminnlcunit.ap:2729");
   // Next point
      v += h;
   }
   minnlcequalitypenaltyfunction(0.0, &f0, &df, &d2f);
   set_error_flag(wereerrors, f0 != 0.0, __FILE__, __LINE__, "testminnlcunit.ap:2737");
   set_error_flag(wereerrors, df != 0.0, __FILE__, __LINE__, "testminnlcunit.ap:2738");
// Test inequality penalty function (correctly calculated and smooth)
   h = 1.0E-4;
   v = 0.02;
   dtol = 1.0E-3;
   while (v <= 2.00) {
   // Test numerical derivative; this test also checks continuity of the
   // function
      minnlcinequalityshiftfunction(v - 2 * h, &fl2, &dfl2, &d2fl2);
      minnlcinequalityshiftfunction(v - h, &fl, &dfl, &d2fl);
      minnlcinequalityshiftfunction(v + h, &fr, &dfr, &d2fr);
      minnlcinequalityshiftfunction(v + 2 * h, &fr2, &dfr2, &d2fr2);
      minnlcinequalityshiftfunction(v, &f0, &df, &d2f);
      ndf = (-fr2 + 8 * fr - 8 * fl + fl2) / (12 * h);
      set_error_flag(wereerrors, fabs(ndf - df) > dtol * rmax2(fabs(ndf), 1.0), __FILE__, __LINE__, "testminnlcunit.ap:2762");
      nd2f = (-dfr2 + 8 * dfr - 8 * dfl + dfl2) / (12 * h);
      set_error_flag(wereerrors, fabs(nd2f - d2f) > dtol * rmax2(fabs(nd2f), 1.0), __FILE__, __LINE__, "testminnlcunit.ap:2764");
   // Next point
      v += h;
   }
   minnlcinequalityshiftfunction(1.0, &f0, &df, &d2f);
   set_error_flag(wereerrors, fabs(f0) > 1.0E-6, __FILE__, __LINE__, "testminnlcunit.ap:2772");
   set_error_flag(wereerrors, fabs(df + 1) > 1.0E-6, __FILE__, __LINE__, "testminnlcunit.ap:2773");
// Test different properties shared by all solvers
   for (solvertype = 0; solvertype <= testminnlcunit_maxsolvertype; solvertype++) {
   // Test location reports
      aulits = 50;
      rho = 200.0;
      n = 2;
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&xlast, n);
      x0.xR[0] = 0.1 + 0.1 * hqrnduniformr(&rs);
      x0.xR[1] = 0.2 + 0.1 * hqrnduniformr(&rs);
      xlast.xR[0] = 0.0;
      xlast.xR[1] = 0.0;
      firstrep = true;
      minnlccreate(n, &x0, &state);
      if (solvertype == 0) {
         minnlcsetalgoaul(&state, rho, aulits);
      } else {
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
      }
      minnlcsetcond(&state, 1.0E-7, 0);
      minnlcsetnlc(&state, 0, 1);
      minnlcsetxrep(&state, true);
      while (minnlciteration(&state)) {
         if (state.needfij) {
            state.fi.xR[0] = sqr(state.x.xR[0] - 1) + sqr(state.x.xR[1] - 1);
            state.j.xyR[0][0] = 2 * (state.x.xR[0] - 1);
            state.j.xyR[0][1] = 2 * (state.x.xR[1] - 1);
            state.fi.xR[1] = sqr(state.x.xR[0]) + sqr(state.x.xR[1]) - 1;
            state.j.xyR[1][0] = 2 * state.x.xR[0];
            state.j.xyR[1][1] = 2 * state.x.xR[1];
            continue;
         }
         if (state.xupdated) {
         // If first point reported, compare with initial one
            if (firstrep) {
               set_error_flag(wereerrors, fabs(state.x.xR[0] - x0.xR[0]) > 1.0E4 * machineepsilon, __FILE__, __LINE__, "testminnlcunit.ap:2826");
               set_error_flag(wereerrors, fabs(state.x.xR[1] - x0.xR[1]) > 1.0E4 * machineepsilon, __FILE__, __LINE__, "testminnlcunit.ap:2827");
            }
            firstrep = false;
         // Save last point
            xlast.xR[0] = state.x.xR[0];
            xlast.xR[1] = state.x.xR[1];
         // Done
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnlcresults(&state, &x1, &rep);
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:2845");
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:2846");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
      set_error_flag(wereerrors, fabs(x1.xR[0] - xlast.xR[0]) > 1.0E4 * machineepsilon, __FILE__, __LINE__, "testminnlcunit.ap:2849");
      set_error_flag(wereerrors, fabs(x1.xR[1] - xlast.xR[1]) > 1.0E4 * machineepsilon, __FILE__, __LINE__, "testminnlcunit.ap:2850");
   // Test numerical differentiation
      aulits = 50;
      rho = 200.0;
      tolx = 0.001;
      diffstep = 0.0001;
      n = 2;
      ae_vector_set_length(&x0, n);
      x0.xR[0] = 0.1;
      x0.xR[1] = 0.2;
      minnlccreatef(n, &x0, diffstep, &state);
      if (solvertype == 0) {
         minnlcsetalgoaul(&state, rho, aulits);
      } else {
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
      }
      minnlcsetcond(&state, 1.0E-7, 0);
      minnlcsetnlc(&state, 0, 1);
      while (minnlciteration(&state)) {
         if (state.needfi) {
            state.fi.xR[0] = sqr(state.x.xR[0] - 1) + sqr(state.x.xR[1] - 1);
            state.fi.xR[1] = sqr(state.x.xR[0]) + sqr(state.x.xR[1]) - 1;
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnlcresults(&state, &x1, &rep);
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:2886");
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:2887");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
      set_error_flag(wereerrors, fabs(x1.xR[0] - sqrt(2.0) / 2) > tolx, __FILE__, __LINE__, "testminnlcunit.ap:2890");
      set_error_flag(wereerrors, fabs(x1.xR[1] - sqrt(2.0) / 2) > tolx, __FILE__, __LINE__, "testminnlcunit.ap:2891");
   // Test integrity checks for NAN/INF:
   // * algorithm solves optimization problem, which is normal for some time (quadratic)
   // * after 5-th step we choose random component of gradient and consistently spoil
   //   it by NAN or INF.
   // * we check that correct termination code is returned (-8)
      n = 100;
      for (pass = 1; pass <= 10; pass++) {
         spoiliteration = 5;
         stopiteration = 8;
         if (hqrndnormal(&rs) > 0.0) {
         // Gradient can be spoiled by +INF, -INF, NAN
            spoilvar = hqrnduniformi(&rs, n);
            i = hqrnduniformi(&rs, 3);
            spoilval = NAN;
            if (i == 0) {
               spoilval = -INFINITY;
            }
            if (i == 1) {
               spoilval = +INFINITY;
            }
         } else {
         // Function value can be spoiled only by NAN
         // (+INF can be recognized as legitimate value during optimization)
            spoilvar = -1;
            spoilval = NAN;
         }
         spdmatrixrndcond(n, 1.0E5, &fulla);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            x0.xR[i] = hqrndnormal(&rs);
         }
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            aulits = 5;
            rho = 1.0E3;
            minnlcsetalgoaul(&state, rho, aulits);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 0.0, stopiteration);
         minnlcsetxrep(&state, true);
         k = -1;
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
               if (k >= spoiliteration) {
                  if (spoilvar < 0) {
                     state.fi.xR[0] = spoilval;
                  } else {
                     state.j.xyR[0][spoilvar] = spoilval;
                  }
               }
               continue;
            }
            if (state.xupdated) {
               k++;
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         set_error_flag(wereerrors, rep.terminationtype != -8, __FILE__, __LINE__, "testminnlcunit.ap:2984");
      }
   // Test that optimizer respects box constraints in all
   // intermediate points:
   // * test that analytic Jacobian respects them
   // * test that numerical Jacobian respects them
   //
   // NOTE: we skip SolverType=0 (AUL) because AUL optimizer
   //       does not provide such guarantee
      if (solvertype != 0) {
         n = 10;
         spdmatrixrndcond(n, 1.0E3, &fulla);
         ae_vector_set_length(&b, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            b.xR[i] = hqrndnormal(&rs);
            x0.xR[i] = hqrndnormal(&rs);
            if (hqrndnormal(&rs) > 0.0) {
               bndl.xR[i] = 0.0;
               bndu.xR[i] = +INFINITY;
            } else {
               bndl.xR[i] = -INFINITY;
               bndu.xR[i] = 0.0;
            }
         }
      // Check analytic Jacobian
         minnlccreate(n, &x0, &state);
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
         minnlcsetbc(&state, &bndl, &bndu);
         minnlcsetcond(&state, 1.0E-8, 0);
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  set_error_flag(wereerrors, state.x.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminnlcunit.ap:3039");
                  set_error_flag(wereerrors, state.x.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminnlcunit.ap:3040");
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[0][i] += fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:3054");
      // Check numerical Jacobian
         minnlccreatef(n, &x0, 1.0E-4, &state);
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
         minnlcsetbc(&state, &bndl, &bndu);
         minnlcsetcond(&state, 1.0E-8, 0);
         while (minnlciteration(&state)) {
            if (state.needfi) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  set_error_flag(wereerrors, state.x.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminnlcunit.ap:3075");
                  set_error_flag(wereerrors, state.x.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminnlcunit.ap:3076");
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[0] += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:3086");
      }
   // Test constraint violation reports for completely unconstrained
   // problems and problems with all constraints being satisfied exactly
      tolx = 0.01;
      for (pass = 1; pass <= 10; pass++) {
         n = 1 + hqrnduniformi(&rs, 5);
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
         }
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 10);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 1.0E-7, 200);
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += pow(state.x.xR[i], 4.0);
                  state.j.xyR[0][i] = 4 * pow(state.x.xR[i], 3.0);
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
      // Check solution itself
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:3129");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:3130");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(wereerrors, fabs(x1.xR[i]) > tolx, __FILE__, __LINE__, "testminnlcunit.ap:3134");
         }
      // Check constraint violation reports
         set_error_flag(wereerrors, rep.bcerr != 0.0, __FILE__, __LINE__, "testminnlcunit.ap:3139");
         set_error_flag(wereerrors, rep.bcidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:3140");
         set_error_flag(wereerrors, rep.lcerr != 0.0, __FILE__, __LINE__, "testminnlcunit.ap:3141");
         set_error_flag(wereerrors, rep.lcidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:3142");
         set_error_flag(wereerrors, rep.nlcerr != 0.0, __FILE__, __LINE__, "testminnlcunit.ap:3143");
         set_error_flag(wereerrors, rep.nlcidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:3144");
      }
      for (pass = 1; pass <= 10; pass++) {
         n = 1 + hqrnduniformi(&rs, 5);
         k = 1 + hqrnduniformi(&rs, 5);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xu, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
            xu.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = -1000.0;
            bndu.xR[i] = 1000.0;
         }
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
            }
            if (hqrndnormal(&rs) > 0.0) {
               c.xyR[i][n] = 1000.0;
               ct.xZ[i] = -1;
            } else {
               c.xyR[i][n] = -1000.0;
               ct.xZ[i] = 1;
            }
         }
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 20);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetbc(&state, &bndl, &bndu);
         minnlcsetlc(&state, &c, &ct, k);
         minnlcsetcond(&state, 1.0E-7, 0);
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += pow(state.x.xR[i] - xu.xR[i], 2.0);
                  state.j.xyR[0][i] = 2 * (state.x.xR[i] - xu.xR[i]);
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
      // Check solution itself, calculate reference violation values
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:3209");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:3210");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Check constraint violation reports
         set_error_flag(wereerrors, rep.bcerr != 0.0, __FILE__, __LINE__, "testminnlcunit.ap:3217");
         set_error_flag(wereerrors, rep.bcidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:3218");
         set_error_flag(wereerrors, rep.lcerr != 0.0, __FILE__, __LINE__, "testminnlcunit.ap:3219");
         set_error_flag(wereerrors, rep.lcidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:3220");
         set_error_flag(wereerrors, rep.nlcerr != 0.0, __FILE__, __LINE__, "testminnlcunit.ap:3221");
         set_error_flag(wereerrors, rep.nlcidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:3222");
      }
   // Test constraint violation reports for box/linearly constrained
   // problems. We generate a problem which can not satisfy one (and
   // just one) general linear constraint.
      tolx = 0.001;
      for (pass = 1; pass <= 10; pass++) {
      // Formulate problem with inconsistent constraints
         n = 2 + hqrnduniformi(&rs, 5);
         k = 1 + hqrnduniformi(&rs, 5);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xu, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_matrix_set_length(&c, k, n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(2.0, hqrndnormal(&rs));
            x0.xR[i] = hqrndnormal(&rs);
            xu.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = -0.5 * hqrnduniformr(&rs) - 0.1;
            bndu.xR[i] = 0.5 * hqrnduniformr(&rs) + 0.1;
         }
         for (i = 0; i < k; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
            }
            if (hqrndnormal(&rs) > 0.0) {
               c.xyR[i][n] = 1000.0;
               ct.xZ[i] = -1;
            } else {
               c.xyR[i][n] = -1000.0;
               ct.xZ[i] = 1;
            }
         }
         ae_assert(n >= 2, "NLCTest: integrity check failed");
         badidx0 = hqrnduniformi(&rs, k);
         badidx1 = hqrnduniformi(&rs, n);
         for (j = 0; j < n; j++) {
            c.xyR[badidx0][j] = 0.0;
         }
         for (j = 0; j < k; j++) {
            c.xyR[j][badidx1] = 0.0;
         }
         c.xyR[badidx0][badidx1] = 1.0;
         c.xyR[badidx0][n] = (double)(10 * (2 * hqrnduniformi(&rs, 2) - 1));
         if (hqrndnormal(&rs) > 0.0) {
            ct.xZ[badidx0] = 0;
         } else {
            ct.xZ[badidx0] = sign(c.xyR[badidx0][n]);
         }
      // Create and try to solve
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 20);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetbc(&state, &bndl, &bndu);
         minnlcsetlc(&state, &c, &ct, k);
         minnlcsetscale(&state, &s);
         minnlcsetcond(&state, 1.0E-7, 0);
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += pow(state.x.xR[i] - xu.xR[i], 2.0);
                  state.j.xyR[0][i] = 2 * (state.x.xR[i] - xu.xR[i]);
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
      // Check solution itself, calculate reference violation values
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:3317");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:3318");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Check constraint violation reports
         if (rep.bcerr > 0.0) {
            v = rmax2(bndl.xR[badidx1] - x1.xR[badidx1], x1.xR[badidx1] - bndu.xR[badidx1]);
            v /= s.xR[badidx1];
            set_error_flag(wereerrors, rep.bcidx != badidx1, __FILE__, __LINE__, "testminnlcunit.ap:3329");
            set_error_flag(wereerrors, fabs(rep.bcerr - v) > 1.0E3 * machineepsilon, __FILE__, __LINE__, "testminnlcunit.ap:3331");
         } else {
            set_error_flag(wereerrors, rep.bcerr != 0.0, __FILE__, __LINE__, "testminnlcunit.ap:3336");
            set_error_flag(wereerrors, rep.bcidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:3337");
            set_error_flag(wereerrors, x1.xR[badidx1] < bndl.xR[badidx1] || x1.xR[badidx1] > bndu.xR[badidx1], __FILE__, __LINE__, "testminnlcunit.ap:3338");
         }
         set_error_flag(wereerrors, rep.lcidx != badidx0, __FILE__, __LINE__, "testminnlcunit.ap:3340");
         set_error_flag(wereerrors, fabs(rep.lcerr - fabs(x1.xR[badidx1] - c.xyR[badidx0][n]) / s.xR[badidx1]) > 1.0E3 * machineepsilon, __FILE__, __LINE__, "testminnlcunit.ap:3341");
         set_error_flag(wereerrors, rep.nlcerr != 0.0, __FILE__, __LINE__, "testminnlcunit.ap:3342");
         set_error_flag(wereerrors, rep.nlcidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:3343");
      }
   // Test constraint violation reports for box/nonlinearly constrained
   // problems. We generate a problem which can not satisfy one (and
   // just one) general linear constraint.
   //
   // NOTE: it is important to have N >= NLEC+NLIC
      tolx = 0.001;
      for (pass = 1; pass <= 10; pass++) {
      // Formulate problem with inconsistent constraints
         nlec = 1 + hqrnduniformi(&rs, 5);
         nlic = 1 + hqrnduniformi(&rs, 5);
         k = nlec + nlic;
         n = k + hqrnduniformi(&rs, 5);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xu, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_matrix_set_length(&c, k, n + 1);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(2.0, hqrndnormal(&rs));
            x0.xR[i] = hqrndnormal(&rs);
            xu.xR[i] = hqrndnormal(&rs);
            bndl.xR[i] = -0.5 * hqrnduniformr(&rs) - 0.1;
            bndu.xR[i] = 0.5 * hqrnduniformr(&rs) + 0.1;
         }
         for (i = 0; i < nlec; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = 0.0;
            }
            c.xyR[i][i] = 1.0;
            c.xyR[i][n] = bndl.xR[i] + hqrnduniformr(&rs) * (bndu.xR[i] - bndl.xR[i]);
         }
         for (i = nlec; i < k; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = 0.0;
            }
            c.xyR[i][i] = 1.0;
            c.xyR[i][n] = 1000.0;
         }
         badidx0 = hqrnduniformi(&rs, k);
         if (badidx0 < nlec) {
            if (hqrndnormal(&rs) > 0.0) {
               c.xyR[badidx0][n] = bndu.xR[badidx0] + 10;
            } else {
               c.xyR[badidx0][n] = bndl.xR[badidx0] - 10;
            }
         } else {
            c.xyR[badidx0][n] = -1000.0;
         }
      // Create and try to solve
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 20);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetbc(&state, &bndl, &bndu);
         minnlcsetnlc(&state, nlec, nlic);
         minnlcsetscale(&state, &s);
         minnlcsetcond(&state, 1.0E-7, 0);
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += pow(state.x.xR[i] - xu.xR[i], 2.0);
                  state.j.xyR[0][i] = 2 * (state.x.xR[i] - xu.xR[i]);
               }
               for (i = 0; i < k; i++) {
                  state.fi.xR[i + 1] = -c.xyR[i][n];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[i + 1] += c.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[i + 1][j] = c.xyR[i][j];
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
      // Check solution itself, calculate reference violation values
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:3446");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:3447");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Check constraint violation reports
         if (badidx0 < nlec) {
            if (rep.bcerr > 0.0) {
               v = rmax2(bndl.xR[badidx0] - x1.xR[badidx0], x1.xR[badidx0] - bndu.xR[badidx0]);
               v /= s.xR[badidx0];
               set_error_flag(wereerrors, rep.bcidx != badidx0, __FILE__, __LINE__, "testminnlcunit.ap:3460");
               set_error_flag(wereerrors, fabs(rep.bcerr - v) > 1.0E3 * machineepsilon, __FILE__, __LINE__, "testminnlcunit.ap:3462");
            } else {
               set_error_flag(wereerrors, rep.bcerr != 0.0, __FILE__, __LINE__, "testminnlcunit.ap:3467");
               set_error_flag(wereerrors, rep.bcidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:3468");
               set_error_flag(wereerrors, x1.xR[badidx0] < bndl.xR[badidx0] || x1.xR[badidx0] > bndu.xR[badidx0], __FILE__, __LINE__, "testminnlcunit.ap:3469");
            }
         }
         set_error_flag(wereerrors, rep.lcidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:3472");
         set_error_flag(wereerrors, rep.lcerr != 0.0, __FILE__, __LINE__, "testminnlcunit.ap:3473");
         set_error_flag(wereerrors, rep.nlcidx != badidx0, __FILE__, __LINE__, "testminnlcunit.ap:3474");
         set_error_flag(wereerrors, fabs(rep.nlcerr - fabs(x1.xR[badidx0] - c.xyR[badidx0][n])) > 1.0E4 * machineepsilon, __FILE__, __LINE__, "testminnlcunit.ap:3475");
      }
   // Test support for termination requests:
   // * to terminate with correct return code = 8
   // * to return point which was "current" at the moment of termination
      for (pass = 1; pass <= 50; pass++) {
         n = 3;
         ss = 100.0;
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xlast, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 6 + hqrnduniformr(&rs);
         }
         stopcallidx = hqrnduniformi(&rs, 20);
         maxits = 25;
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 20);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 0.0, maxits);
         minnlcsetxrep(&state, true);
         callidx = 0;
         terminationrequested = false;
         ae_v_move(xlast.xR, 1, x0.xR, 1, n);
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = ss * sqr(exp(state.x.xR[0]) - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
               state.j.xyR[0][0] = 2 * ss * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[2] - state.x.xR[0]) * (-1);
               state.j.xyR[0][1] = 2 * state.x.xR[1];
               state.j.xyR[0][2] = 2 * (state.x.xR[2] - state.x.xR[0]);
               if (callidx == stopcallidx) {
                  minnlcrequesttermination(&state);
                  terminationrequested = true;
               }
               callidx++;
               continue;
            }
            if (state.xupdated) {
               if (!terminationrequested) {
                  ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         set_error_flag(wereerrors, rep.terminationtype != 8, __FILE__, __LINE__, "testminnlcunit.ap:3532");
         for (i = 0; i < n; i++) {
            set_error_flag(wereerrors, x1.xR[i] != xlast.xR[i], __FILE__, __LINE__, "testminnlcunit.ap:3534");
         }
      }
   }
// AUL-specific test.
//
// Test preconditioning:
// * compare number of iterations required to solve problem with
//   different preconditioners (LBFGS, exact, none)
// * a set of trials is performed (100 trials)
// * each trial is a solution of boundary/linearly constrained problem
//   (linear constraints may be posed as nonlinear ones) with normalized
//   constraint matrix. Normalization is essential for reproducibility
//   of results .
//
// Outer loop checks handling of different types of constraints
// (posed as linear or nonlinear ones)
   n = 30;
   blocksize = 3;
   blockcnt = 3;
   rho = 1.0E3;
   aulits = 5;
   condv = 1.0E2;
   ae_vector_set_length(&x0, n);
   ae_vector_set_length(&bndl, n);
   ae_vector_set_length(&bndu, n);
   ae_matrix_set_length(&c, blocksize * blockcnt, n + 1);
   ae_vector_set_length(&ct, blocksize * blockcnt);
   for (ctype = 0; ctype <= 1; ctype++) {
   // First, initialize iteration counters
      nlbfgs = 0;
      nexactlowrank = 0;
      nexactrobust = 0;
      nnone = 0;
   // Perform trials
      for (trialidx = 0; trialidx <= 99; trialidx++) {
      // Generate:
      // * boundary constraints BndL/BndU and initial point X0
      // * block-diagonal matrix of linear constraints C such
      //   that X0 is feasible w.r.t. constraints given by C
         for (i = 0; i < n; i++) {
            if (hqrndnormal(&rs) > 0.0) {
               bndl.xR[i] = 0.0;
               bndu.xR[i] = +INFINITY;
               x0.xR[i] = hqrnduniformr(&rs);
            } else {
               bndl.xR[i] = 0.0;
               bndu.xR[i] = 0.0;
               x0.xR[i] = 0.0;
            }
         }
         for (i = 0; i < blocksize * blockcnt; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = 0.0;
            }
         }
         for (k = 0; k < blockcnt; k++) {
            rmatrixrndcond(blocksize, condv, &a);
            for (i = 0; i < blocksize; i++) {
               for (j = 0; j < blocksize; j++) {
                  c.xyR[k * blocksize + i][k * blocksize + j] = a.xyR[i][j];
               }
            }
         }
         for (i = 0; i < blocksize * blockcnt; i++) {
            v = ae_v_dotproduct(c.xyR[i], 1, c.xyR[i], 1, n);
            v = 1 / sqrt(v);
            ae_v_muld(c.xyR[i], 1, n, v);
            v = ae_v_dotproduct(c.xyR[i], 1, x0.xR, 1, n);
            c.xyR[i][n] = v;
            ct.xZ[i] = hqrnduniformi(&rs, 3) - 1;
         }
      // Test unpreconditioned iteration
         minnlccreate(n, &x0, &state);
         minnlcsetalgoaul(&state, rho, aulits);
         minnlcsetcond(&state, 1.0E-7, 0);
         if (ctype == 0) {
            minnlcsetlc(&state, &c, &ct, blocksize * blockcnt);
         } else {
            minnlcsetnlc(&state, blocksize * blockcnt, 0);
         }
         minnlcsetprecnone(&state);
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += sqr(state.x.xR[i]);
                  state.j.xyR[0][i] = 2 * state.x.xR[i];
               }
               if (ctype == 1) {
                  for (i = 0; i < blocksize * blockcnt; i++) {
                     v = ae_v_dotproduct(c.xyR[i], 1, state.x.xR, 1, n);
                     state.fi.xR[1 + i] = v - c.xyR[i][n];
                     ae_v_move(state.j.xyR[1 + i], 1, c.xyR[i], 1, n);
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:3658");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:3659");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         nnone += rep.iterationscount;
      // Test LBFGS preconditioned iteration
         minnlccreate(n, &x0, &state);
         minnlcsetalgoaul(&state, rho, aulits);
         minnlcsetcond(&state, 1.0E-7, 0);
         if (ctype == 0) {
            minnlcsetlc(&state, &c, &ct, blocksize * blockcnt);
         } else {
            minnlcsetnlc(&state, blocksize * blockcnt, 0);
         }
         minnlcsetprecinexact(&state);
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += sqr(state.x.xR[i]);
                  state.j.xyR[0][i] = 2 * state.x.xR[i];
               }
               if (ctype == 1) {
                  for (i = 0; i < blocksize * blockcnt; i++) {
                     v = ae_v_dotproduct(c.xyR[i], 1, state.x.xR, 1, n);
                     state.fi.xR[1 + i] = v - c.xyR[i][n];
                     ae_v_move(state.j.xyR[1 + i], 1, c.xyR[i], 1, n);
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:3699");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:3700");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         nlbfgs += rep.iterationscount;
      // Test exact low rank preconditioner
         minnlccreate(n, &x0, &state);
         minnlcsetalgoaul(&state, rho, aulits);
         minnlcsetcond(&state, 1.0E-7, 0);
         if (ctype == 0) {
            minnlcsetlc(&state, &c, &ct, blocksize * blockcnt);
         } else {
            minnlcsetnlc(&state, blocksize * blockcnt, 0);
         }
         minnlcsetprecexactlowrank(&state, 3);
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += sqr(state.x.xR[i]);
                  state.j.xyR[0][i] = 2 * state.x.xR[i];
               }
               if (ctype == 1) {
                  for (i = 0; i < blocksize * blockcnt; i++) {
                     v = ae_v_dotproduct(c.xyR[i], 1, state.x.xR, 1, n);
                     state.fi.xR[1 + i] = v - c.xyR[i][n];
                     ae_v_move(state.j.xyR[1 + i], 1, c.xyR[i], 1, n);
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:3740");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:3741");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         nexactlowrank += rep.iterationscount;
      // Test exact robust preconditioner
         minnlccreate(n, &x0, &state);
         minnlcsetalgoaul(&state, rho, aulits);
         minnlcsetcond(&state, 1.0E-7, 0);
         if (ctype == 0) {
            minnlcsetlc(&state, &c, &ct, blocksize * blockcnt);
         } else {
            minnlcsetnlc(&state, blocksize * blockcnt, 0);
         }
         minnlcsetprecexactrobust(&state, 3);
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += sqr(state.x.xR[i]);
                  state.j.xyR[0][i] = 2 * state.x.xR[i];
               }
               if (ctype == 1) {
                  for (i = 0; i < blocksize * blockcnt; i++) {
                     v = ae_v_dotproduct(c.xyR[i], 1, state.x.xR, 1, n);
                     state.fi.xR[1 + i] = v - c.xyR[i][n];
                     ae_v_move(state.j.xyR[1 + i], 1, c.xyR[i], 1, n);
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:3781");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:3782");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         nexactrobust += rep.iterationscount;
      }
   // Compare.
   //
   // Preconditioners must be significantly different,
   // with exact being best one, inexact being second,
   // "none" being worst option.
      set_error_flag(wereerrors, !((double)nexactlowrank < 0.9 * nlbfgs), __FILE__, __LINE__, "testminnlcunit.ap:3795");
      set_error_flag(wereerrors, !((double)nexactrobust < 0.9 * nlbfgs), __FILE__, __LINE__, "testminnlcunit.ap:3796");
      set_error_flag(wereerrors, !((double)nlbfgs < 0.9 * nnone), __FILE__, __LINE__, "testminnlcunit.ap:3797");
   }
   ae_frame_leave();
}

// This function performs tests for fixed bugs
//
// On failure sets error flag.
static void testminnlcunit_testbugs(bool *wereerrors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t aulits;
   ae_int_t maxits;
   double rho;
   ae_int_t ckind;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t solvertype;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minnlcstate, state);
   NewObj(minnlcreport, rep);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewMatrix(c, 0, 0, DT_REAL);
   hqrndrandomize(&rs);
// Bug description (fixed): sometimes on non-convex problems, when
// Lagrange coefficient for inequality constraint becomes small,
// algorithm performs VERY deep step into infeasible area (step is 1E50),
// which de-stabilizes it and prevents from converging back to feasible area.
//
// Very rare situation, but must be fixed with additional "convexifying" term.
// This test reproduces situation with convexified term turned off, then
// checks that introduction of term solves issue.
//
// We perform three kinds of tests:
// * with box inequality constraint
// * with linear inequality constraint
// * with nonlinear inequality constraint
//
// In all three cases we:
// * first time solve non-convex problem with artificially moved stabilizing
//   point and decreased initial value of Lagrange multiplier.
// * second time we solve problem with good stabilizing point, but zero Lagrange multiplier
// * last time solve same problem, but with default settings
   aulits = 1;
   maxits = 1;
   rho = 100.0;
   n = 1;
   ae_vector_set_length(&x0, n);
   x0.xR[0] = 0.0;
   ae_vector_set_length(&bndl, n);
   ae_vector_set_length(&bndu, n);
   bndl.xR[0] = 0.0;
   bndu.xR[0] = +INFINITY;
   ae_matrix_set_length(&c, 1, 2);
   ae_vector_set_length(&ct, 1);
   c.xyR[0][0] = 1.0;
   c.xyR[0][1] = 0.0;
   ct.xZ[0] = 1;
   for (ckind = 0; ckind <= 2; ckind++) {
      minnlccreate(n, &x0, &state);
      state.stabilizingpoint = -1.0E300;
      state.initialinequalitymultiplier = 1.0E-12;
      minnlcsetalgoaul(&state, rho, aulits);
      minnlcsetcond(&state, 0.0, maxits);
      if (ckind == 0) {
         minnlcsetbc(&state, &bndl, &bndu);
      }
      if (ckind == 1) {
         minnlcsetlc(&state, &c, &ct, 1);
      }
      if (ckind == 2) {
         minnlcsetnlc(&state, 0, 1);
      }
      while (minnlciteration(&state)) {
         if (state.needfij) {
            state.fi.xR[0] = state.x.xR[0] - sqr(state.x.xR[0]);
            state.j.xyR[0][0] = 1 - 2 * state.x.xR[0];
            if (ckind == 2) {
               state.fi.xR[1] = -state.x.xR[0];
               state.j.xyR[1][0] = -1.0;
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnlcresults(&state, &x1, &rep);
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:4949");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
      set_error_flag(wereerrors, x1.xR[0] > -1.0E6, __FILE__, __LINE__, "testminnlcunit.ap:4952");
      minnlccreate(n, &x0, &state);
      state.stabilizingpoint = -1.0E2;
      state.initialinequalitymultiplier = 1.0E-12;
      minnlcsetalgoaul(&state, rho, aulits);
      minnlcsetcond(&state, 0.0, maxits);
      if (ckind == 0) {
         minnlcsetbc(&state, &bndl, &bndu);
      }
      if (ckind == 1) {
         minnlcsetlc(&state, &c, &ct, 1);
      }
      if (ckind == 2) {
         minnlcsetnlc(&state, 0, 1);
      }
      while (minnlciteration(&state)) {
         if (state.needfij) {
            state.fi.xR[0] = state.x.xR[0] - sqr(state.x.xR[0]);
            state.j.xyR[0][0] = 1 - 2 * state.x.xR[0];
            if (ckind == 2) {
               state.fi.xR[1] = -state.x.xR[0];
               state.j.xyR[1][0] = -1.0;
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnlcresults(&state, &x1, &rep);
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:4981");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
      set_error_flag(wereerrors, x1.xR[0] < 3 * state.stabilizingpoint, __FILE__, __LINE__, "testminnlcunit.ap:4984");
      minnlccreate(n, &x0, &state);
      minnlcsetalgoaul(&state, rho, aulits);
      minnlcsetcond(&state, 0.0, maxits);
      if (ckind == 0) {
         minnlcsetbc(&state, &bndl, &bndu);
      }
      if (ckind == 1) {
         minnlcsetlc(&state, &c, &ct, 1);
      }
      if (ckind == 2) {
         minnlcsetnlc(&state, 0, 1);
      }
      while (minnlciteration(&state)) {
         if (state.needfij) {
            state.fi.xR[0] = state.x.xR[0] - sqr(state.x.xR[0]);
            state.j.xyR[0][0] = 1 - 2 * state.x.xR[0];
            if (ckind == 2) {
               state.fi.xR[1] = -state.x.xR[0];
               state.j.xyR[1][0] = -1.0;
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnlcresults(&state, &x1, &rep);
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:5011");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
      set_error_flag(wereerrors, x1.xR[0] < 3 * state.stabilizingpoint, __FILE__, __LINE__, "testminnlcunit.ap:5014");
   }
// This test checks report by E. Pozamantir. Relevant for SLP
// and related methods, but we test it for all algorithms.
//
// Description:
//
// The sequential linear programming solver performs warm-start
// at each iteration, i.e. it reuses previously found LP basis.
// However, when some initially non-zero Jacobian entries become
// exactly zero (possible with constraints which are nonsmooth
// at some distance from the boundary), our warm-start strategy
// may fail because warm-start basis becomes exactly degenerate.
//
// In order to test that this bug was fixed we solve carefully
// designed noisy test problem with Jacobian entries being randomly
// turned on and off. Simply being able to return from the solver
// without triggering critical exception is enough.
   for (solvertype = 0; solvertype <= testminnlcunit_maxsolvertype; solvertype++) {
      for (n = 6; n <= 15; n++) {
      // Setup problem
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&d, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
            d.xR[i] = sqr(hqrndnormal(&rs));
         }
         k = 1 + hqrnduniformi(&rs, n / 3);
         ae_matrix_set_length(&c, 2 * k, n + 1);
         for (i = 0; i < 2 * k; i++) {
            for (j = 0; j < n; j++) {
               c.xyR[i][j] = hqrndnormal(&rs);
            }
         }
         for (i = 0; i < k; i++) {
            c.xyR[i][n] = 0.0;
         }
         for (i = k; i < 2 * k; i++) {
            c.xyR[i][n] = 0.1 + hqrnduniformr(&rs);
         }
      // Create solver and solve problem
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 200.0, 20);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 1.0E-7, 20);
         minnlcsetnlc(&state, k, k);
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (j = 0; j < n; j++) {
                  state.fi.xR[0] += 0.5 * d.xR[j] * sqr(state.x.xR[j]);
                  state.j.xyR[0][j] = d.xR[j] * state.x.xR[j];
               }
               for (i = 0; i < 2 * k; i++) {
                  state.fi.xR[1 + i] = -c.xyR[i][n];
                  for (j = 0; j < n; j++) {
                     state.fi.xR[1 + i] += c.xyR[i][j] * state.x.xR[j];
                     state.j.xyR[1 + i][j] = hqrnduniformi(&rs, 2) * c.xyR[i][j];
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:5101");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:5102");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      }
   }
   ae_frame_leave();
}

// This function tests report of "non-C1" test #0 for task #0
// given by matrix A.
//
// On failure sets error flag.
static void testminnlcunit_testoptguardc1test0reportfortask0(bool *err, optguardnonc1test0report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double va;
   double vb;
   bool hasc1discontinuities;
   if (rep->positive) {
   // Check positive report, first checks
      set_error_flag(err, rep->fidx != 0, __FILE__, __LINE__, "testminnlcunit.ap:5131");
      set_error_flag(err, rep->n != n, __FILE__, __LINE__, "testminnlcunit.ap:5132");
      set_error_flag(err, !(0 <= rep->stpidxa), __FILE__, __LINE__, "testminnlcunit.ap:5133");
      set_error_flag(err, !(rep->stpidxa < rep->stpidxb), __FILE__, __LINE__, "testminnlcunit.ap:5134");
      set_error_flag(err, !(rep->stpidxb < rep->cnt), __FILE__, __LINE__, "testminnlcunit.ap:5135");
      set_error_flag(err, rep->x0.cnt != rep->n, __FILE__, __LINE__, "testminnlcunit.ap:5136");
      set_error_flag(err, rep->d.cnt != rep->n, __FILE__, __LINE__, "testminnlcunit.ap:5137");
      set_error_flag(err, rep->stp.cnt != rep->cnt, __FILE__, __LINE__, "testminnlcunit.ap:5138");
      set_error_flag(err, rep->f.cnt != rep->cnt, __FILE__, __LINE__, "testminnlcunit.ap:5139");
      set_error_flag(err, !isfinitevector(&rep->x0, n), __FILE__, __LINE__, "testminnlcunit.ap:5140");
      set_error_flag(err, !isfinitevector(&rep->d, n), __FILE__, __LINE__, "testminnlcunit.ap:5141");
      set_error_flag(err, !isfinitevector(&rep->stp, rep->cnt), __FILE__, __LINE__, "testminnlcunit.ap:5142");
      set_error_flag(err, !isfinitevector(&rep->f, rep->cnt), __FILE__, __LINE__, "testminnlcunit.ap:5143");
      if (*err) {
         return;
      }
   // Check consistency of Stp.
      for (k = 0; k < rep->cnt - 1; k++) {
         set_error_flag(err, rep->stp.xR[k] >= rep->stp.xR[k + 1], __FILE__, __LINE__, "testminnlcunit.ap:5151");
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      set_error_flag(err, !hasc1discontinuities, __FILE__, __LINE__, "testminnlcunit.ap:5168");
   } else {
   // Check negative report: fields must be empty
      set_error_flag(err, rep->stpidxa != -1, __FILE__, __LINE__, "testminnlcunit.ap:5175");
      set_error_flag(err, rep->stpidxb != -1, __FILE__, __LINE__, "testminnlcunit.ap:5176");
      set_error_flag(err, rep->fidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:5177");
      set_error_flag(err, rep->cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5178");
      set_error_flag(err, rep->n != 0, __FILE__, __LINE__, "testminnlcunit.ap:5179");
      set_error_flag(err, rep->x0.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5180");
      set_error_flag(err, rep->d.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5181");
      set_error_flag(err, rep->stp.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5182");
      set_error_flag(err, rep->f.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5183");
   }
}

// This function tests report of "non-C1" test #1 for task #0
// given by matrix A.
//
// On failure sets error flag.
static void testminnlcunit_testoptguardc1test1reportfortask0(bool *err, optguardnonc1test1report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double va;
   double vb;
   bool tooclose;
   bool hasc1discontinuities;
   if (rep->positive) {
   // Check positive report, first checks
      set_error_flag(err, rep->fidx != 0, __FILE__, __LINE__, "testminnlcunit.ap:5211");
      set_error_flag(err, rep->vidx < 0, __FILE__, __LINE__, "testminnlcunit.ap:5212");
      set_error_flag(err, rep->vidx > n, __FILE__, __LINE__, "testminnlcunit.ap:5213");
      set_error_flag(err, rep->n != n, __FILE__, __LINE__, "testminnlcunit.ap:5214");
      set_error_flag(err, !(0 <= rep->stpidxa), __FILE__, __LINE__, "testminnlcunit.ap:5215");
      set_error_flag(err, !(rep->stpidxa < rep->stpidxb), __FILE__, __LINE__, "testminnlcunit.ap:5216");
      set_error_flag(err, !(rep->stpidxb < rep->cnt), __FILE__, __LINE__, "testminnlcunit.ap:5217");
      set_error_flag(err, rep->x0.cnt != rep->n, __FILE__, __LINE__, "testminnlcunit.ap:5218");
      set_error_flag(err, rep->d.cnt != rep->n, __FILE__, __LINE__, "testminnlcunit.ap:5219");
      set_error_flag(err, rep->stp.cnt != rep->cnt, __FILE__, __LINE__, "testminnlcunit.ap:5220");
      set_error_flag(err, rep->g.cnt != rep->cnt, __FILE__, __LINE__, "testminnlcunit.ap:5221");
      set_error_flag(err, !isfinitevector(&rep->x0, n), __FILE__, __LINE__, "testminnlcunit.ap:5222");
      set_error_flag(err, !isfinitevector(&rep->d, n), __FILE__, __LINE__, "testminnlcunit.ap:5223");
      set_error_flag(err, !isfinitevector(&rep->stp, rep->cnt), __FILE__, __LINE__, "testminnlcunit.ap:5224");
      set_error_flag(err, !isfinitevector(&rep->g, rep->cnt), __FILE__, __LINE__, "testminnlcunit.ap:5225");
      if (*err) {
         return;
      }
   // Check consistency of Stp
      for (k = 0; k < rep->cnt - 1; k++) {
         set_error_flag(err, rep->stp.xR[k] >= rep->stp.xR[k + 1], __FILE__, __LINE__, "testminnlcunit.ap:5233");
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      tooclose = false;
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         tooclose = (tooclose || fabs(va) < 1.0E-8) || fabs(vb) < 1.0E-8;
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      if (!tooclose) {
         set_error_flag(err, !hasc1discontinuities, __FILE__, __LINE__, "testminnlcunit.ap:5253");
      }
   } else {
   // Check negative report: fields must be empty
      set_error_flag(err, rep->stpidxa != -1, __FILE__, __LINE__, "testminnlcunit.ap:5260");
      set_error_flag(err, rep->stpidxb != -1, __FILE__, __LINE__, "testminnlcunit.ap:5261");
      set_error_flag(err, rep->fidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:5262");
      set_error_flag(err, rep->vidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:5263");
      set_error_flag(err, rep->cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5264");
      set_error_flag(err, rep->n != 0, __FILE__, __LINE__, "testminnlcunit.ap:5265");
      set_error_flag(err, rep->x0.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5266");
      set_error_flag(err, rep->d.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5267");
      set_error_flag(err, rep->stp.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5268");
      set_error_flag(err, rep->g.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5269");
   }
}

// This function tests report of "non-C1" test #0 for task #1
// given by matrix A.
//
// On failure sets error flag.
static void testminnlcunit_testoptguardc1test0reportfortask1(bool *err, optguardnonc1test0report *rep, RMatrix *a, ae_int_t n, ae_int_t goodidx) {
   if (rep->positive) {
   // Check positive report, first checks
      set_error_flag(err, rep->fidx == goodidx + 1, __FILE__, __LINE__, "testminnlcunit.ap:5293");
      set_error_flag(err, rep->n != n, __FILE__, __LINE__, "testminnlcunit.ap:5294");
      set_error_flag(err, !(0 <= rep->stpidxa), __FILE__, __LINE__, "testminnlcunit.ap:5295");
      set_error_flag(err, !(rep->stpidxa < rep->stpidxb), __FILE__, __LINE__, "testminnlcunit.ap:5296");
      set_error_flag(err, !(rep->stpidxb < rep->cnt), __FILE__, __LINE__, "testminnlcunit.ap:5297");
      set_error_flag(err, rep->x0.cnt != rep->n, __FILE__, __LINE__, "testminnlcunit.ap:5298");
      set_error_flag(err, rep->d.cnt != rep->n, __FILE__, __LINE__, "testminnlcunit.ap:5299");
      set_error_flag(err, rep->stp.cnt != rep->cnt, __FILE__, __LINE__, "testminnlcunit.ap:5300");
      set_error_flag(err, rep->f.cnt != rep->cnt, __FILE__, __LINE__, "testminnlcunit.ap:5301");
      set_error_flag(err, !isfinitevector(&rep->x0, n), __FILE__, __LINE__, "testminnlcunit.ap:5302");
      set_error_flag(err, !isfinitevector(&rep->d, n), __FILE__, __LINE__, "testminnlcunit.ap:5303");
      set_error_flag(err, !isfinitevector(&rep->stp, rep->cnt), __FILE__, __LINE__, "testminnlcunit.ap:5304");
      set_error_flag(err, !isfinitevector(&rep->f, rep->cnt), __FILE__, __LINE__, "testminnlcunit.ap:5305");
      if (*err) {
         return;
      }
   } else {
   // Check negative report: fields must be empty
      set_error_flag(err, rep->stpidxa != -1, __FILE__, __LINE__, "testminnlcunit.ap:5314");
      set_error_flag(err, rep->stpidxb != -1, __FILE__, __LINE__, "testminnlcunit.ap:5315");
      set_error_flag(err, rep->fidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:5316");
      set_error_flag(err, rep->cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5317");
      set_error_flag(err, rep->n != 0, __FILE__, __LINE__, "testminnlcunit.ap:5318");
      set_error_flag(err, rep->x0.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5319");
      set_error_flag(err, rep->d.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5320");
      set_error_flag(err, rep->stp.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5321");
      set_error_flag(err, rep->f.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5322");
   }
}

// This function tests report of "non-C1" test #1 for task #1 given by matrix A.
//
// On failure sets error flag.
static void testminnlcunit_testoptguardc1test1reportfortask1(bool *err, optguardnonc1test1report *rep, RMatrix *a, ae_int_t n, ae_int_t goodidx) {
   if (rep->positive) {
   // Check positive report, first checks
      set_error_flag(err, rep->fidx == goodidx + 1, __FILE__, __LINE__, "testminnlcunit.ap:5345");
      set_error_flag(err, rep->vidx < 0, __FILE__, __LINE__, "testminnlcunit.ap:5346");
      set_error_flag(err, rep->vidx > n, __FILE__, __LINE__, "testminnlcunit.ap:5347");
      set_error_flag(err, rep->n != n, __FILE__, __LINE__, "testminnlcunit.ap:5348");
      set_error_flag(err, !(0 <= rep->stpidxa), __FILE__, __LINE__, "testminnlcunit.ap:5349");
      set_error_flag(err, !(rep->stpidxa < rep->stpidxb), __FILE__, __LINE__, "testminnlcunit.ap:5350");
      set_error_flag(err, !(rep->stpidxb < rep->cnt), __FILE__, __LINE__, "testminnlcunit.ap:5351");
      set_error_flag(err, rep->x0.cnt != rep->n, __FILE__, __LINE__, "testminnlcunit.ap:5352");
      set_error_flag(err, rep->d.cnt != rep->n, __FILE__, __LINE__, "testminnlcunit.ap:5353");
      set_error_flag(err, rep->stp.cnt != rep->cnt, __FILE__, __LINE__, "testminnlcunit.ap:5354");
      set_error_flag(err, rep->g.cnt != rep->cnt, __FILE__, __LINE__, "testminnlcunit.ap:5355");
      set_error_flag(err, !isfinitevector(&rep->x0, n), __FILE__, __LINE__, "testminnlcunit.ap:5356");
      set_error_flag(err, !isfinitevector(&rep->d, n), __FILE__, __LINE__, "testminnlcunit.ap:5357");
      set_error_flag(err, !isfinitevector(&rep->stp, rep->cnt), __FILE__, __LINE__, "testminnlcunit.ap:5358");
      set_error_flag(err, !isfinitevector(&rep->g, rep->cnt), __FILE__, __LINE__, "testminnlcunit.ap:5359");
      if (*err) {
         return;
      }
   } else {
   // Check negative report: fields must be empty
      set_error_flag(err, rep->stpidxa != -1, __FILE__, __LINE__, "testminnlcunit.ap:5368");
      set_error_flag(err, rep->stpidxb != -1, __FILE__, __LINE__, "testminnlcunit.ap:5369");
      set_error_flag(err, rep->fidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:5370");
      set_error_flag(err, rep->vidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:5371");
      set_error_flag(err, rep->cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5372");
      set_error_flag(err, rep->n != 0, __FILE__, __LINE__, "testminnlcunit.ap:5373");
      set_error_flag(err, rep->x0.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5374");
      set_error_flag(err, rep->d.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5375");
      set_error_flag(err, rep->stp.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5376");
      set_error_flag(err, rep->g.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:5377");
   }
}

// This function tests OptGuard
//
// On failure sets error flag.
static void testminnlcunit_testoptguard(bool *wereerrors) {
   ae_frame _frame_block;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   double diffstep;
   ae_int_t pass;
   ae_int_t solvertype;
   double vbnd;
   double fscale;
   ae_int_t defecttype;
   double vshift;
   double vpower;
   ae_int_t cntabove;
   ae_int_t cntbelow;
   bool linesearchstarted;
   bool wasgoodlinesearch0;
   bool wasgoodlinesearch1;
   ae_int_t shortsessions;
   ae_int_t maxshortsessions;
   double stplen;
   double shortstplen;
   bool failed;
   ae_int_t passcount;
   ae_int_t maxfails;
   ae_int_t failurecounter;
   ae_int_t maxc1test0fails;
   ae_int_t maxc1test1fails;
   ae_int_t c1test0fails;
   ae_int_t c1test1fails;
   ae_int_t goodidx;
   double avgstr0len;
   double avglng0len;
   double avgstr1len;
   double avglng1len;
   ae_int_t funcidx;
   ae_int_t varidx;
   ae_int_t skind;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minnlcstate, state);
   NewObj(minnlcreport, rep);
   NewObj(optguardreport, ogrep);
   NewObj(optguardnonc1test0report, ognonc1test0strrep);
   NewObj(optguardnonc1test0report, ognonc1test0lngrep);
   NewObj(optguardnonc1test1report, ognonc1test1strrep);
   NewObj(optguardnonc1test1report, ognonc1test1lngrep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(xu, 0, DT_REAL);
   NewMatrix(jactrue, 0, 0, DT_REAL);
   NewMatrix(jacdefect, 0, 0, DT_REAL);
   hqrndrandomize(&rs);
// Test functionality which should work in all NLC solvers
   for (solvertype = 0; solvertype <= testminnlcunit_maxsolvertype; solvertype++) {
   // Check that gradient verification is disabled by default:
   // gradient checking for bad problem must return nothing
      n = 10;
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = 1.0 + 0.1 * i;
      }
      spdmatrixrndcond(n, 1.0E3, &a);
      spdmatrixrndcond(n, 1.0E3, &a1);
      minnlccreate(n, &x0, &state);
      if (solvertype == 0) {
         minnlcsetalgoaul(&state, 1000.0, 5);
      } else {
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
      }
      minnlcsetcond(&state, 1.0E-7, 10);
      minnlcsetnlc(&state, 0, 1);
      while (minnlciteration(&state)) {
         if (state.needfij) {
            state.fi.xR[0] = 0.0;
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.fi.xR[0] += 0.5 * state.x.xR[i] * v;
            }
            state.fi.xR[1] = 0.0;
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a1.xyR[i][j];
               }
               state.fi.xR[1] += 0.5 * state.x.xR[i] * v;
            }
            for (i = 0; i < n; i++) {
               state.j.xyR[0][i] = 0.0;
               state.j.xyR[1][i] = 0.0;
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnlcresults(&state, &x1, &rep);
      minnlcoptguardresults(&state, &ogrep);
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:3909");
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:3910");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
      set_error_flag(wereerrors, ogrep.badgradxbase.cnt != 0, __FILE__, __LINE__, "testminnlcunit.ap:3913");
      set_error_flag(wereerrors, ogrep.badgraduser.rows != 0, __FILE__, __LINE__, "testminnlcunit.ap:3914");
      set_error_flag(wereerrors, ogrep.badgraduser.cols != 0, __FILE__, __LINE__, "testminnlcunit.ap:3915");
      set_error_flag(wereerrors, ogrep.badgradnum.rows != 0, __FILE__, __LINE__, "testminnlcunit.ap:3916");
      set_error_flag(wereerrors, ogrep.badgradnum.cols != 0, __FILE__, __LINE__, "testminnlcunit.ap:3917");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
      set_error_flag(wereerrors, ogrep.badgradsuspected, __FILE__, __LINE__, "testminnlcunit.ap:3920");
      set_error_flag(wereerrors, ogrep.badgradfidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:3921");
      set_error_flag(wereerrors, ogrep.badgradvidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:3922");
   // Test that C0/C1 continuity monitoring is disabled by default;
   // we solve nonsmooth problem and test that nothing is returned
   // by OptGuard.
      n = 10;
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
      minnlccreate(n, &x0, &state);
      if (solvertype == 0) {
         minnlcsetalgoaul(&state, 1000.0, 1);
      } else {
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
      }
      minnlcsetcond(&state, 1.0E-9, 50);
      while (minnlciteration(&state)) {
         if (state.needfij) {
            state.fi.xR[0] = 0.0;
            for (i = 0; i < n; i++) {
               state.j.xyR[0][i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.fi.xR[0] += fabs(v);
               v = (double)sign(v);
               for (j = 0; j < n; j++) {
                  state.j.xyR[0][j] += v * a.xyR[i][j];
               }
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnlcresults(&state, &x1, &rep);
      minnlcoptguardresults(&state, &ogrep);
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:3970");
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:3971");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
      set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testminnlcunit.ap:3974");
      set_error_flag(wereerrors, ogrep.nonc1suspected, __FILE__, __LINE__, "testminnlcunit.ap:3975");
      set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:3976");
      set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testminnlcunit.ap:3977");
      set_error_flag(wereerrors, ogrep.nonc1fidx >= 0, __FILE__, __LINE__, "testminnlcunit.ap:3978");
      set_error_flag(wereerrors, ogrep.nonc1test0positive, __FILE__, __LINE__, "testminnlcunit.ap:3979");
      set_error_flag(wereerrors, ogrep.nonc1test1positive, __FILE__, __LINE__, "testminnlcunit.ap:3980");
   // Test gradient checking functionality, try various
   // defect types:
   // * accidental zeroing of some gradient component
   // * accidental addition of 1.0 to some component
   // * accidental multiplication by 2.0
   // Try distorting both target and constraints.
      diffstep = 0.001;
      n = 10;
      for (skind = 0; skind <= 1; skind++) {
         for (funcidx = 0; funcidx <= 1; funcidx++) {
            for (defecttype = -1; defecttype <= 2; defecttype++) {
               varidx = hqrnduniformi(&rs, n);
               ae_vector_set_length(&x0, n);
               ae_vector_set_length(&s, n);
               ae_vector_set_length(&bndl, n);
               ae_vector_set_length(&bndu, n);
               for (i = 0; i < n; i++) {
                  s.xR[i] = pow(10.0, skind * (30 * hqrnduniformr(&rs) - 15));
                  x0.xR[i] = (1.0 + 0.1 * i) * s.xR[i];
                  j = hqrnduniformi(&rs, 3);
                  bndl.xR[i] = -100 * s.xR[i];
                  bndu.xR[i] = 100 * s.xR[i];
                  if (j == 1) {
                     bndl.xR[i] = x0.xR[i];
                  }
                  if (j == 2) {
                     bndu.xR[i] = x0.xR[i];
                  }
               }
               spdmatrixrndcond(n, 1.0E3, &a);
               spdmatrixrndcond(n, 1.0E3, &a1);
               minnlccreate(n, &x0, &state);
               if (solvertype == 0) {
                  minnlcsetalgoaul(&state, 1000.0, 5);
               } else {
                  if (solvertype == 1) {
                     minnlcsetalgoslp(&state);
                  } else {
                     if (solvertype == 2) {
                        minnlcsetalgosqp(&state);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
               }
               minnlcoptguardgradient(&state, diffstep);
               minnlcsetcond(&state, 1.0E-7, 10);
               minnlcsetscale(&state, &s);
               minnlcsetbc(&state, &bndl, &bndu);
               minnlcsetnlc(&state, 0, 1);
               while (minnlciteration(&state)) {
                  if (state.needfij) {
                     if (solvertype != 0) {
                        for (i = 0; i < n; i++) {
                           set_error_flag(wereerrors, state.x.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminnlcunit.ap:4040");
                           set_error_flag(wereerrors, state.x.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminnlcunit.ap:4041");
                        }
                     }
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        v = 0.0;
                        for (j = 0; j < n; j++) {
                           v += state.x.xR[j] / s.xR[j] * a.xyR[i][j];
                        }
                        state.fi.xR[0] += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                        state.j.xyR[0][i] = v;
                     }
                     state.fi.xR[1] = 0.0;
                     for (i = 0; i < n; i++) {
                        v = 0.0;
                        for (j = 0; j < n; j++) {
                           v += state.x.xR[j] / s.xR[j] * a1.xyR[i][j];
                        }
                        state.fi.xR[1] += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                        state.j.xyR[1][i] = v;
                     }
                     if (defecttype == 0) {
                        state.j.xyR[funcidx][varidx] = 0.0;
                     }
                     if (defecttype == 1) {
                        state.j.xyR[funcidx][varidx]++;
                     }
                     if (defecttype == 2) {
                        state.j.xyR[funcidx][varidx] *= 2;
                     }
                     for (i = 0; i < n; i++) {
                        state.j.xyR[0][i] /= s.xR[i];
                        state.j.xyR[1][i] /= s.xR[i];
                     }
                     continue;
                  }
                  ae_assert(false, "Assertion failed");
               }
               minnlcresults(&state, &x1, &rep);
               minnlcoptguardresults(&state, &ogrep);
            // Check that something is returned
               set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:4091");
               set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:4092");
               if (*wereerrors) {
                  ae_frame_leave();
                  return;
               }
            // Compute reference values for true and spoiled Jacobian at X0
               set_error_flag(wereerrors, !isfinitevector(&ogrep.badgradxbase, n), __FILE__, __LINE__, "testminnlcunit.ap:4099");
               if (*wereerrors) {
                  ae_frame_leave();
                  return;
               }
               ae_matrix_set_length(&jactrue, 2, n);
               ae_matrix_set_length(&jacdefect, 2, n);
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += ogrep.badgradxbase.xR[j] / s.xR[j] * a.xyR[i][j];
                  }
                  jactrue.xyR[0][i] = v;
                  jacdefect.xyR[0][i] = v;
               }
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += ogrep.badgradxbase.xR[j] / s.xR[j] * a1.xyR[i][j];
                  }
                  jactrue.xyR[1][i] = v;
                  jacdefect.xyR[1][i] = v;
               }
               if (defecttype == 0) {
                  jacdefect.xyR[funcidx][varidx] = 0.0;
               }
               if (defecttype == 1) {
                  jacdefect.xyR[funcidx][varidx]++;
               }
               if (defecttype == 2) {
                  jacdefect.xyR[funcidx][varidx] *= 2;
               }
               for (i = 0; i < n; i++) {
                  jactrue.xyR[0][i] /= s.xR[i];
                  jactrue.xyR[1][i] /= s.xR[i];
                  jacdefect.xyR[0][i] /= s.xR[i];
                  jacdefect.xyR[1][i] /= s.xR[i];
               }
            // Check OptGuard report
               set_error_flag(wereerrors, !apservisfinitematrix(&ogrep.badgraduser, 2, n), __FILE__, __LINE__, "testminnlcunit.ap:4137");
               set_error_flag(wereerrors, !apservisfinitematrix(&ogrep.badgradnum, 2, n), __FILE__, __LINE__, "testminnlcunit.ap:4138");
               if (*wereerrors) {
                  ae_frame_leave();
                  return;
               }
               if (defecttype >= 0) {
                  set_error_flag(wereerrors, !ogrep.badgradsuspected, __FILE__, __LINE__, "testminnlcunit.ap:4143");
                  set_error_flag(wereerrors, ogrep.badgradfidx != funcidx, __FILE__, __LINE__, "testminnlcunit.ap:4144");
                  set_error_flag(wereerrors, ogrep.badgradvidx != varidx, __FILE__, __LINE__, "testminnlcunit.ap:4145");
               } else {
                  set_error_flag(wereerrors, ogrep.badgradsuspected, __FILE__, __LINE__, "testminnlcunit.ap:4149");
                  set_error_flag(wereerrors, ogrep.badgradfidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:4150");
                  set_error_flag(wereerrors, ogrep.badgradvidx != -1, __FILE__, __LINE__, "testminnlcunit.ap:4151");
               }
               for (i = 0; i <= 1; i++) {
                  for (j = 0; j < n; j++) {
                     set_error_flag(wereerrors, fabs(jactrue.xyR[i][j] - ogrep.badgradnum.xyR[i][j]) > 0.01 / s.xR[j], __FILE__, __LINE__, "testminnlcunit.ap:4156");
                     set_error_flag(wereerrors, fabs(jacdefect.xyR[i][j] - ogrep.badgraduser.xyR[i][j]) > 0.01 / s.xR[j], __FILE__, __LINE__, "testminnlcunit.ap:4157");
                  }
               }
            }
         }
      }
   // Make sure than no false positives are reported for larger
   // problems where numerical noise can be an issue:
   // * N=100 dimensions
   // * nonnegativity constraints
   // * positive-definite quadratic programming problem
   // * upper limit on iterations count, MaxIts=25
   // We simply test that OptGuard does not return error code.
      n = 100;
      spdmatrixrndcond(n, 1.0E2, &a);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         b.xR[i] = hqrndnormal(&rs);
         bndl.xR[i] = 0.0;
         bndu.xR[i] = +INFINITY;
         x0.xR[i] = pow(2.0, hqrndnormal(&rs));
      }
      minnlccreate(n, &x0, &state);
      if (solvertype == 0) {
         minnlcsetalgoaul(&state, 1000.0, 3);
      } else {
         if (solvertype == 1) {
            minnlcsetalgoslp(&state);
         } else {
            if (solvertype == 2) {
               minnlcsetalgosqp(&state);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
      }
      minnlcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel));
      minnlcsetbc(&state, &bndl, &bndu);
      minnlcsetcond(&state, 1.0E-7, 25);
      while (minnlciteration(&state)) {
         if (state.needfij) {
            state.fi.xR[0] = 0.0;
            for (i = 0; i < n; i++) {
               state.fi.xR[0] += b.xR[i] * state.x.xR[i];
               state.j.xyR[0][i] = b.xR[i];
               for (j = 0; j < n; j++) {
                  state.fi.xR[0] += 0.5 * state.x.xR[i] * a.xyR[i][j] * state.x.xR[j];
                  state.j.xyR[0][i] += a.xyR[i][j] * state.x.xR[j];
               }
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnlcresults(&state, &x1, &rep);
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:4215");
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:4216");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
      minnlcoptguardresults(&state, &ogrep);
      set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:4220");
   }
// Test functionality which works only in some NLC solvers
   for (solvertype = 0; solvertype <= testminnlcunit_maxsolvertype; solvertype++) {
   // Skip
      if (solvertype == 2) {
         continue;
      }
   // Test detection of discontinuities in the target function
   // and its gradient (analytic gradient is used).
   //
   // Target function is convex quadratic modified by addition of
   // nonsmooth/discontinuous (depending on DefectType) perturbation.
   //
   // This test is complicated because OptGuard does NOT guarantee
   // that C0/C1 violations are ALWAYS caught. OptGuard needs line
   // search to perform
   // * at least 4 function evaluations, with discontinuity in the
   //   middle of them (at least two function values from the left,
   //   at least two from the right)
   // * at least 7 function evaluations to catch C1 violation
   //
   // Furthermore, it is possible that optimizer will perform a few
   // function evaluations BEFORE and AFTER line search starts,
   // which complicates everything.
   //
   // N, VPower and VBnd are selected randomly at the start of the test.
      for (defecttype = 0; defecttype <= 1; defecttype++) {
         n = 1 + hqrnduniformi(&rs, 10);
         vpower = 10 * pow(10.0, -0.2 * hqrnduniformr(&rs));
         vbnd = 1 * pow(10.0, -0.2 * hqrnduniformr(&rs));
         fscale = 0.1;
         maxshortsessions = 4;
         shortstplen = 1.0E-6;
         shortsessions = 0;
         for (pass = 1; pass <= 100; pass++) {
         // Formulate problem
            ae_vector_set_length(&s, n);
            ae_vector_set_length(&xlast, n);
            ae_vector_set_length(&x0, n);
            ae_vector_set_length(&xu, n);
            ae_vector_set_length(&bndl, n);
            ae_vector_set_length(&bndu, n);
            do {
               v = 0.0;
               for (i = 0; i < n; i++) {
                  xu.xR[i] = 0.1 + hqrnduniformr(&rs);
                  v += sqr(xu.xR[i]);
               }
               v = sqrt(v);
            } while (v <= 0.0);
            for (i = 0; i < n; i++) {
               xu.xR[i] /= v;
            }
            for (i = 0; i < n; i++) {
               xlast.xR[i] = 0.0;
               x0.xR[i] = 2 * xu.xR[i] + 0.1 * hqrnduniformr(&rs);
               bndl.xR[i] = 0.0;
               bndu.xR[i] = +INFINITY;
               s.xR[i] = pow(2.0, 0.1 * hqrndnormal(&rs));
            }
            if (defecttype == 0) {
               vshift = 1.0;
            } else {
               vshift = 0.0;
            }
         // Prepare code which detects "good" (long enough) line searches
            cntbelow = 0;
            cntabove = 0;
            wasgoodlinesearch0 = false;
            wasgoodlinesearch1 = false;
            linesearchstarted = false;
         // Create and try to solve
            minnlccreate(n, &x0, &state);
            if (solvertype == 0) {
               minnlcsetalgoaul(&state, 1000.0, 5);
            } else {
               if (solvertype == 1) {
                  minnlcsetalgoslp(&state);
               } else {
                  if (solvertype == 2) {
                     minnlcsetalgosqp(&state);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            }
            minnlcsetbc(&state, &bndl, &bndu);
            minnlcsetscale(&state, &s);
            minnlcsetcond(&state, 1.0E-7, 1000);
            minnlcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel));
            minnlcsetxrep(&state, true);
            while (minnlciteration(&state)) {
               if (state.needfij) {
                  state.fi.xR[0] = 0.0;
                  for (i = 0; i < n; i++) {
                     state.fi.xR[0] += fscale * pow(state.x.xR[i], 2.0);
                     state.j.xyR[0][i] = 2 * fscale * state.x.xR[i];
                  }
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     v += state.x.xR[i] * xu.xR[i];
                  }
                  if (v < vbnd) {
                     state.fi.xR[0] += (vshift + vpower * (vbnd - v));
                     for (i = 0; i < n; i++) {
                        state.j.xyR[0][i] -= vpower * xu.xR[i];
                     }
                     if (linesearchstarted) {
                        cntbelow++;
                     }
                  } else {
                     if (linesearchstarted) {
                        cntabove++;
                     }
                  }
                  continue;
               }
               if (state.xupdated) {
               // Finalize previous line search
                  if (linesearchstarted) {
                     stplen = 0.0;
                     for (i = 0; i < n; i++) {
                        stplen += sqr(state.x.xR[i] - xlast.xR[i]);
                     }
                     stplen = sqrt(stplen);
                     wasgoodlinesearch0 = wasgoodlinesearch0 || ((cntbelow >= 2 && cntabove >= 2) && stplen >= shortstplen);
                     wasgoodlinesearch1 = wasgoodlinesearch1 || ((cntbelow >= 2 && cntabove >= 2) && stplen >= shortstplen);
                  }
               // Start new line search
                  linesearchstarted = true;
                  cntbelow = 0;
                  cntabove = 0;
                  for (i = 0; i < n; i++) {
                     xlast.xR[i] = state.x.xR[i];
                  }
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     v += state.x.xR[i] * xu.xR[i];
                  }
                  if (v < vbnd) {
                     cntbelow++;
                  } else {
                     cntabove++;
                  }
               // Done
                  continue;
               }
               ae_assert(false, "Assertion failed");
            }
            minnlcresults(&state, &x1, &rep);
            minnlcoptguardresults(&state, &ogrep);
         // Check basic properties of the solution
            set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:4397");
            set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:4398");
            if (*wereerrors) {
               ae_frame_leave();
               return;
            }
         // Check OptGuard report, increase
            if (defecttype == 0) {
               if (wasgoodlinesearch0) {
                  set_error_flag(wereerrors, optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:4409");
                  set_error_flag(wereerrors, !ogrep.nonc0suspected, __FILE__, __LINE__, "testminnlcunit.ap:4410");
                  set_error_flag(wereerrors, ogrep.nonc0fidx != 0, __FILE__, __LINE__, "testminnlcunit.ap:4411");
               } else {
                  shortsessions++;
               }
            }
            if (defecttype == 1) {
               if (wasgoodlinesearch1) {
                  set_error_flag(wereerrors, optguardallclear(&ogrep), __FILE__, __LINE__, "testminnlcunit.ap:4420");
                  set_error_flag(wereerrors, !ogrep.nonc1suspected, __FILE__, __LINE__, "testminnlcunit.ap:4421");
                  set_error_flag(wereerrors, ogrep.nonc1fidx != 0, __FILE__, __LINE__, "testminnlcunit.ap:4422");
               } else {
                  shortsessions++;
               }
            }
            if (*wereerrors) {
               ae_frame_leave();
               return;
            }
         }
      // Check that short optimization sessions are rare.
         set_error_flag(wereerrors, shortsessions > maxshortsessions, __FILE__, __LINE__, "testminnlcunit.ap:4434");
      }
   // One more test for detection of C1 continuity violations in the target.
   //
   // Target function is a sum of |(x,c_i)| for i=1..N.
   // No constraints is present.
   // Analytic gradient is provided.
   //
   // OptGuard should be able to detect violations in more than
   // 99.9% of runs; it means that 100 runs should have no more than 4
   // failures in all cases (even after multiple repeated tests; according
   // to the binomial distribution quantiles).
   //
   // We select some N and perform exhaustive search for this N.
   //
   // NOTE: we skip SQP for this test
      passcount = 100;
      maxfails = 4;
      maxc1test0fails = 10;
      maxc1test1fails = 10;
      n = 1 + hqrnduniformi(&rs, 10);
      failurecounter = 0;
      c1test0fails = 0;
      c1test1fails = 0;
      avgstr0len = 0.0;
      avglng0len = 0.0;
      avgstr1len = 0.0;
      avglng1len = 0.0;
      for (pass = 1; pass <= passcount; pass++) {
      // Formulate problem
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(2.0, hqrndnormal(&rs));
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = hqrndnormal(&rs);
            }
         }
      // Create and try to solve
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 1);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 1.0E-7, 50);
         minnlcsetscale(&state, &s);
         minnlcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel));
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.j.xyR[0][i] = 0.0;
               }
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += state.x.xR[j] * a.xyR[i][j];
                  }
                  state.fi.xR[0] += fabs(v);
                  v = (double)sign(v);
                  for (j = 0; j < n; j++) {
                     state.j.xyR[0][j] += v * a.xyR[i][j];
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         minnlcoptguardresults(&state, &ogrep);
      // Check basic properties of the solution
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:4524");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:4525");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Check generic OptGuard report: distinguish between "hard"
      // failures which result in immediate termination
      // (C0 violation being reported) and "soft" ones
      // (C1 violation is NOT reported) which accumulate
      // until we exhaust limit.
         set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testminnlcunit.ap:4536");
         set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testminnlcunit.ap:4537");
         failed = false;
         failed = failed || optguardallclear(&ogrep);
         failed = failed || !ogrep.nonc1suspected;
         failed = failed || ogrep.nonc1fidx != 0;
         if (failed) {
            failurecounter++;
         }
      // Check C1 continuity test #0
         minnlcoptguardnonc1test0results(&state, &ognonc1test0strrep, &ognonc1test0lngrep);
         minnlcoptguardnonc1test1results(&state, &ognonc1test1strrep, &ognonc1test1lngrep);
         if (ogrep.nonc1test0positive) {
            set_error_flag(wereerrors, !ogrep.nonc1suspected, __FILE__, __LINE__, "testminnlcunit.ap:4552");
            set_error_flag(wereerrors, !ognonc1test0strrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4553");
            set_error_flag(wereerrors, !ognonc1test0lngrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4554");
            set_error_flag(wereerrors, ogrep.nonc1fidx != 0, __FILE__, __LINE__, "testminnlcunit.ap:4555");
            testminnlcunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0strrep, &a, n);
            testminnlcunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0lngrep, &a, n);
            avgstr0len += (double)ognonc1test0strrep.cnt / passcount;
            avglng0len += (double)ognonc1test0lngrep.cnt / passcount;
         } else {
            set_error_flag(wereerrors, ognonc1test0strrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4563");
            set_error_flag(wereerrors, ognonc1test0lngrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4564");
            testminnlcunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0strrep, &a, n);
            testminnlcunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0lngrep, &a, n);
            c1test0fails++;
         }
         if (ogrep.nonc1test1positive) {
            set_error_flag(wereerrors, !ogrep.nonc1suspected, __FILE__, __LINE__, "testminnlcunit.ap:4571");
            set_error_flag(wereerrors, !ognonc1test1strrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4572");
            set_error_flag(wereerrors, !ognonc1test1lngrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4573");
            set_error_flag(wereerrors, ogrep.nonc1fidx != 0, __FILE__, __LINE__, "testminnlcunit.ap:4574");
            testminnlcunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1strrep, &a, n);
            testminnlcunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1lngrep, &a, n);
            avgstr1len += (double)ognonc1test1strrep.cnt / passcount;
            avglng1len += (double)ognonc1test1lngrep.cnt / passcount;
         } else {
            set_error_flag(wereerrors, ognonc1test1strrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4582");
            set_error_flag(wereerrors, ognonc1test1lngrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4583");
            testminnlcunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1strrep, &a, n);
            testminnlcunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1lngrep, &a, n);
            c1test1fails++;
         }
      }
      set_error_flag(wereerrors, failurecounter > maxfails, __FILE__, __LINE__, "testminnlcunit.ap:4590");
      set_error_flag(wereerrors, c1test0fails > maxc1test0fails, __FILE__, __LINE__, "testminnlcunit.ap:4591");
      set_error_flag(wereerrors, c1test1fails > maxc1test1fails, __FILE__, __LINE__, "testminnlcunit.ap:4592");
      set_error_flag(wereerrors, avglng0len <= avgstr0len, __FILE__, __LINE__, "testminnlcunit.ap:4593");
      set_error_flag(wereerrors, avglng1len <= avgstr1len, __FILE__, __LINE__, "testminnlcunit.ap:4594");
   // Detection of C1 continuity violations in the target under numerical differentiation:
   // * target function is a sum of |(x,c_i)| for i=1..N.
   // * no constraints is present.
   // * analytic gradient is provided.
   //
   // OptGuard should always be able to detect violations in more than
   // 99% of runs (note: reduced strength when compared with analytic gradient);
   // it means that 100 runs should have no more than 10 failures in all cases
   // (even after multiple repeated tests; according to the binomial distribution
   // quantiles).
   //
   // We select some N and perform exhaustive search for this N.
   //
   // NOTE: we skip SQP solver for this test
      diffstep = 0.0001;
      passcount = 100;
      maxfails = 10;
      n = 1 + hqrnduniformi(&rs, 10);
      failurecounter = 0;
      for (pass = 1; pass <= passcount; pass++) {
      // Formulate problem
         ae_vector_set_length(&x0, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = 0.01 * pow(2.0, 0.33 * hqrndnormal(&rs));
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = hqrndnormal(&rs);
            }
         }
      // Create and try to solve
         minnlccreatef(n, &x0, diffstep, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 1);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 1.0E-7, 50);
         minnlcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel));
         while (minnlciteration(&state)) {
            if (state.needfi) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += state.x.xR[j] * a.xyR[i][j];
                  }
                  state.fi.xR[0] += fabs(v);
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         minnlcoptguardresults(&state, &ogrep);
      // Check basic properties of the solution
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:4669");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:4670");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Check OptGuard report: distinguish between "hard"
      // failures which result in immediate termination
      // (C0 violation being reported) and "soft" ones
      // (C1 violation is NOT reported) which accumulate
      // until we exhaust limit.
         set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testminnlcunit.ap:4681");
         set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testminnlcunit.ap:4682");
         failed = false;
         failed = failed || optguardallclear(&ogrep);
         failed = failed || !ogrep.nonc1suspected;
         failed = failed || ogrep.nonc1fidx != 0;
         if (failed) {
            failurecounter++;
         }
      }
      set_error_flag(wereerrors, failurecounter > maxfails, __FILE__, __LINE__, "testminnlcunit.ap:4690");
   // Detection of C1 continuity violations in the nonlinear constraints.
   //
   // This test is a bit tricky because optimizers are less sensitive to
   // continuity violations in constraints, so we may have hard time collecting
   // enough statistics. In order to do so we solve carefully designed hard
   // problem with MULTIPLE bad constraints and only one good constraint.
   //
   // Optimizer may report any of bad constraints, but not good one.
   //
   // We select some N and perform exhaustive search for this N.
      passcount = 100;
      maxfails = 20;
      n = 5;
      failurecounter = 0;
      c1test0fails = 0;
      c1test1fails = 0;
      for (pass = 1; pass <= passcount; pass++) {
      // Formulate problem, select constraint index to perturb with
      // nonsmoothness; make sure that this constraint is active at
      // the solution
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&b, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = hqrnduniformr(&rs) - 0.5;
            s.xR[i] = pow(2.0, hqrndnormal(&rs));
            b.xR[i] = hqrndnormal(&rs);
         }
         ae_matrix_set_length(&a, n, n);
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = pow(2.0, 0.01 * hqrndnormal(&rs));
            }
         }
         goodidx = hqrnduniformi(&rs, n);
      // Create and try to solve
         minnlccreate(n, &x0, &state);
         if (solvertype == 0) {
            minnlcsetalgoaul(&state, 1000.0, 3);
         } else {
            if (solvertype == 1) {
               minnlcsetalgoslp(&state);
            } else {
               if (solvertype == 2) {
                  minnlcsetalgosqp(&state);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         minnlcsetcond(&state, 1.0E-7, 50);
         minnlcsetnlc(&state, 0, n);
         minnlcsetscale(&state, &s);
         minnlcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminnlcunit_maxoptguardlevel));
         while (minnlciteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += b.xR[i] * state.x.xR[i];
                  state.j.xyR[0][i] = b.xR[i];
               }
               for (i = 0; i < n; i++) {
                  state.fi.xR[1 + i] = -1.0;
                  for (j = 0; j < n; j++) {
                     state.fi.xR[1 + i] += a.xyR[i][j] * sqr(state.x.xR[j]);
                     state.j.xyR[1 + i][j] = 2 * a.xyR[i][j] * state.x.xR[j];
                  }
                  if (i != goodidx) {
                     state.fi.xR[1 + i] = rmax2(state.fi.xR[1 + i], 0.0);
                     for (j = 0; j < n; j++) {
                        state.j.xyR[1 + i][j] *= sign(state.fi.xR[1 + i]);
                     }
                  }
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnlcresults(&state, &x1, &rep);
         minnlcoptguardresults(&state, &ogrep);
      // Check basic properties of the solution
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminnlcunit.ap:4786");
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnlcunit.ap:4787");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Check generic OptGuard report: distinguish between "hard"
      // failures which result in immediate termination
      // (C0 violation being reported) and "soft" ones
      // (C1 violation is NOT reported) which accumulate
      // until we exhaust limit.
         set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testminnlcunit.ap:4798");
         set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testminnlcunit.ap:4799");
         set_error_flag(wereerrors, ogrep.nonc1fidx == goodidx + 1, __FILE__, __LINE__, "testminnlcunit.ap:4800");
         failed = false;
         failed = failed || optguardallclear(&ogrep);
         failed = failed || !ogrep.nonc1suspected;
         if (failed) {
            failurecounter++;
         }
      // Check C1 continuity tests #0 and #1
         minnlcoptguardnonc1test0results(&state, &ognonc1test0strrep, &ognonc1test0lngrep);
         minnlcoptguardnonc1test1results(&state, &ognonc1test1strrep, &ognonc1test1lngrep);
         if (ogrep.nonc1test0positive) {
            set_error_flag(wereerrors, !ogrep.nonc1suspected, __FILE__, __LINE__, "testminnlcunit.ap:4814");
            set_error_flag(wereerrors, !ognonc1test0strrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4815");
            set_error_flag(wereerrors, !ognonc1test0lngrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4816");
            set_error_flag(wereerrors, ogrep.nonc1fidx < 1, __FILE__, __LINE__, "testminnlcunit.ap:4817");
            set_error_flag(wereerrors, ogrep.nonc1fidx > n, __FILE__, __LINE__, "testminnlcunit.ap:4818");
            set_error_flag(wereerrors, ogrep.nonc1fidx == goodidx + 1, __FILE__, __LINE__, "testminnlcunit.ap:4819");
            testminnlcunit_testoptguardc1test0reportfortask1(wereerrors, &ognonc1test0strrep, &a, n, goodidx);
            testminnlcunit_testoptguardc1test0reportfortask1(wereerrors, &ognonc1test0lngrep, &a, n, goodidx);
         } else {
            set_error_flag(wereerrors, ognonc1test0strrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4825");
            set_error_flag(wereerrors, ognonc1test0lngrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4826");
            testminnlcunit_testoptguardc1test0reportfortask1(wereerrors, &ognonc1test0strrep, &a, n, goodidx);
            testminnlcunit_testoptguardc1test0reportfortask1(wereerrors, &ognonc1test0lngrep, &a, n, goodidx);
            c1test0fails++;
         }
         if (ogrep.nonc1test1positive) {
            set_error_flag(wereerrors, !ogrep.nonc1suspected, __FILE__, __LINE__, "testminnlcunit.ap:4833");
            set_error_flag(wereerrors, !ognonc1test1strrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4834");
            set_error_flag(wereerrors, !ognonc1test1lngrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4835");
            set_error_flag(wereerrors, ogrep.nonc1fidx < 1, __FILE__, __LINE__, "testminnlcunit.ap:4836");
            set_error_flag(wereerrors, ogrep.nonc1fidx > n, __FILE__, __LINE__, "testminnlcunit.ap:4837");
            set_error_flag(wereerrors, ogrep.nonc1fidx == goodidx + 1, __FILE__, __LINE__, "testminnlcunit.ap:4838");
            testminnlcunit_testoptguardc1test1reportfortask1(wereerrors, &ognonc1test1strrep, &a, n, goodidx);
            testminnlcunit_testoptguardc1test1reportfortask1(wereerrors, &ognonc1test1lngrep, &a, n, goodidx);
         } else {
            set_error_flag(wereerrors, ognonc1test1strrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4844");
            set_error_flag(wereerrors, ognonc1test1lngrep.positive, __FILE__, __LINE__, "testminnlcunit.ap:4845");
            testminnlcunit_testoptguardc1test1reportfortask1(wereerrors, &ognonc1test1strrep, &a, n, goodidx);
            testminnlcunit_testoptguardc1test1reportfortask1(wereerrors, &ognonc1test1lngrep, &a, n, goodidx);
            c1test1fails++;
         }
      }
      set_error_flag(wereerrors, failurecounter > maxfails, __FILE__, __LINE__, "testminnlcunit.ap:4851");
   }
   ae_frame_leave();
}

bool testminnlc(bool silent) {
   bool waserrors;
   bool bcerr;
   bool lcerr;
   bool nlcerr;
   bool othererr;
   bool optguarderr;
   bool bugs;
   bool result;
   waserrors = false;
   bcerr = false;
   lcerr = false;
   nlcerr = false;
   othererr = false;
   optguarderr = false;
   bugs = false;
   testminnlcunit_testbugs(&bugs);
   testminnlcunit_testbc(&bcerr);
   testminnlcunit_testlc(&lcerr);
   testminnlcunit_testnlc(&nlcerr);
   testminnlcunit_testother(&othererr);
   testminnlcunit_testoptguard(&optguarderr);
// end
   waserrors = ((((bcerr || lcerr) || nlcerr) || othererr) || bugs) || optguarderr;
   if (!silent) {
      printf("TESTING MINNLC OPTIMIZATION\n");
      printf("GENERIC TESTS:\n");
      printf("* box constrained                         ");
      if (bcerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* linearly constrained                    ");
      if (lcerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* nonlinearly constrained                 ");
      if (nlcerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* other properties                        ");
      if (othererr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* optguard integrity monitor              ");
      if (optguarderr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* fixed bugs                              ");
      if (bugs) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === minns testing unit ===
static const double testminnsunit_scalingtesttol = 1.0E-6;
static const ae_int_t testminnsunit_scalingtestcnt = 3;

// Basic unconstrained test
static void testminnsunit_basictest0uc(bool *errors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   double sumits;
   double sumnfev;
   ae_int_t pass;
   ae_int_t passcount;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewObj(minnsstate, s);
   NewObj(minnsreport, rep);
   n = 5;
   passcount = 10;
   sumits = 0.0;
   sumnfev = 0.0;
   ae_vector_set_length(&x0, n);
   ae_vector_set_length(&d, n);
   for (pass = 1; pass <= 10; pass++) {
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         d.xR[i] = pow(10.0, randommid());
      }
      minnscreate(n, &x0, &s);
      minnssetalgoags(&s, 0.1, 0.0);
      while (minnsiteration(&s)) {
         if (s.needfij) {
            s.fi.xR[0] = 0.0;
            for (i = 0; i < n; i++) {
               s.fi.xR[0] += d.xR[i] * fabs(s.x.xR[i]);
               s.j.xyR[0][i] = d.xR[i] * sign(s.x.xR[i]);
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnsresults(&s, &x1, &rep);
      set_error_flag(errors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:143");
      if (*errors) {
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(errors, !isfinite(x1.xR[i]) || fabs(x1.xR[i]) > 0.001, __FILE__, __LINE__, "testminnsunit.ap:147");
      }
      sumits += (double)rep.iterationscount / passcount;
      sumnfev += (double)rep.nfev / passcount;
   }
   ae_frame_leave();
}

// Basic unconstrained test: nonsmooth Rosenbrock posed as unconstrained problem.
//
//              [                                                                       ]
//     minimize [ 10*|x0^2-x1| + (1-x0)^2 + 100*max(sqrt(2)*x0-1,0) + 100*max(2*x1-1,0) ]
//              [                                                                       ]
//
// It's exact solution is x0=1/sqrt(2), x1=1/2
static void testminnsunit_basictest1uc(bool *errors) {
   ae_frame _frame_block;
   ae_int_t n;
   double v0;
   double v1;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewObj(minnsstate, s);
   NewObj(minnsreport, rep);
   n = 2;
   ae_vector_set_length(&x0, n);
   x0.xR[0] = 0.0;
   x0.xR[1] = 0.0;
   minnscreate(n, &x0, &s);
   minnssetalgoags(&s, 0.1, 0.0);
   while (minnsiteration(&s)) {
      if (s.needfij) {
         v0 = s.x.xR[0];
         v1 = s.x.xR[1];
         s.fi.xR[0] = 10 * fabs(sqr(v0) - v1) + sqr(v0 - 1);
         s.j.xyR[0][0] = 10 * sign(sqr(v0) - v1) * 2 * v0 + 2 * (v0 - 1);
         s.j.xyR[0][1] = (double)(10 * sign(sqr(v0) - v1) * (-1));
         if (sqrt(2.0) * v0 - 1 > 0.0) {
            s.fi.xR[0] += 100 * (sqrt(2.0) * v0 - 1);
            s.j.xyR[0][0] += 100 * sqrt(2.0);
         }
         if (2 * v1 - 1 > 0.0) {
            s.fi.xR[0] += 100 * (2 * v1 - 1);
            s.j.xyR[0][1] += 100 * 2;
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   minnsresults(&s, &x1, &rep);
   set_error_flag(errors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:204");
   if (*errors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(errors, !isfinite(x1.xR[0]) || fabs(x1.xR[0] - 1 / sqrt(2.0)) > 0.001, __FILE__, __LINE__, "testminnsunit.ap:207");
   set_error_flag(errors, !isfinite(x1.xR[1]) || fabs(x1.xR[1] - 1.0 / 2.0) > 0.001, __FILE__, __LINE__, "testminnsunit.ap:208");
   ae_frame_leave();
}

// Basic box constrained test
static void testminnsunit_basictest0bc(bool *errors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   double sumits;
   double sumnfev;
   ae_int_t pass;
   ae_int_t passcount;
   double v0;
   double v1;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewObj(minnsstate, s);
   NewObj(minnsreport, rep);
   n = 5;
   passcount = 10;
   sumits = 0.0;
   sumnfev = 0.0;
   ae_vector_set_length(&x0, n);
   ae_vector_set_length(&bl, n);
   ae_vector_set_length(&bu, n);
   ae_vector_set_length(&d, n);
   for (pass = 1; pass <= 10; pass++) {
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         d.xR[i] = pow(10.0, randommid());
         v0 = randommid();
         v1 = randommid();
         bl.xR[i] = rmin2(v0, v1);
         bu.xR[i] = rmax2(v0, v1);
      }
      minnscreate(n, &x0, &s);
      minnssetalgoags(&s, 0.1, 0.0);
      minnssetbc(&s, &bl, &bu);
      while (minnsiteration(&s)) {
         if (s.needfij) {
            s.fi.xR[0] = 0.0;
            for (i = 0; i < n; i++) {
               s.fi.xR[0] += d.xR[i] * fabs(s.x.xR[i]);
               s.j.xyR[0][i] = d.xR[i] * sign(s.x.xR[i]);
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnsresults(&s, &x1, &rep);
      set_error_flag(errors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:263");
      if (*errors) {
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(errors, !isfinite(x1.xR[i]) || fabs(x1.xR[i] - rboundval(0.0, bl.xR[i], bu.xR[i])) > 0.001, __FILE__, __LINE__, "testminnsunit.ap:267");
      }
      sumits += (double)rep.iterationscount / passcount;
      sumnfev += (double)rep.nfev / passcount;
   }
   ae_frame_leave();
}

// Basic constrained test: nonsmooth Rosenbrock posed as box constrained problem.
//
//              [                         ]
//     minimize [ 10*|x0^2-x1| + (1-x0)^2 ]
//              [                         ]
//
//     s.t. x0 <= 1/sqrt(2), x1 <= 0.5
//
// It's exact solution is x0=1/sqrt(2), x1=1/2
static void testminnsunit_basictest1bc(bool *errors) {
   ae_frame _frame_block;
   ae_int_t n;
   double v0;
   double v1;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewObj(minnsstate, s);
   NewObj(minnsreport, rep);
   n = 2;
   ae_vector_set_length(&x0, n);
   ae_vector_set_length(&bndl, n);
   ae_vector_set_length(&bndu, n);
   x0.xR[0] = 0.0;
   x0.xR[1] = 0.0;
   bndl.xR[0] = -INFINITY;
   bndl.xR[1] = -INFINITY;
   bndu.xR[0] = 1 / sqrt(2.0);
   bndu.xR[1] = 1.0 / 2.0;
   minnscreate(n, &x0, &s);
   minnssetbc(&s, &bndl, &bndu);
   minnssetalgoags(&s, 0.1, 0.0);
   while (minnsiteration(&s)) {
      if (s.needfij) {
         v0 = s.x.xR[0];
         v1 = s.x.xR[1];
         s.fi.xR[0] = 10 * fabs(sqr(v0) - v1) + sqr(v0 - 1);
         s.j.xyR[0][0] = 10 * sign(sqr(v0) - v1) * 2 * v0 + 2 * (v0 - 1);
         s.j.xyR[0][1] = (double)(10 * sign(sqr(v0) - v1) * (-1));
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   minnsresults(&s, &x1, &rep);
   set_error_flag(errors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:323");
   if (*errors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(errors, !isfinite(x1.xR[0]) || fabs(x1.xR[0] - 1 / sqrt(2.0)) > 0.001, __FILE__, __LINE__, "testminnsunit.ap:326");
   set_error_flag(errors, !isfinite(x1.xR[1]) || fabs(x1.xR[1] - 1.0 / 2.0) > 0.001, __FILE__, __LINE__, "testminnsunit.ap:327");
   ae_frame_leave();
}

// Basic linearly constrained test
static void testminnsunit_basictest0lc(bool *errors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   double d;
   double sumits;
   double sumnfev;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t nc;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(minnsstate, s);
   NewObj(minnsreport, rep);
   d = -10.0;
   n = 5;
   passcount = 10;
   sumits = 0.0;
   sumnfev = 0.0;
   ae_vector_set_length(&x0, n);
   ae_matrix_set_length(&c, 2 * n, n + 1);
   ae_vector_set_length(&ct, 2 * n);
   for (pass = 1; pass <= 10; pass++) {
      nc = 0;
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         if (randombool()) {
            for (j = 0; j <= n; j++) {
               c.xyR[nc][j] = 0.0;
            }
            c.xyR[nc][i] = 1.0 + randomreal();
            ct.xZ[nc] = 0;
            nc++;
         } else {
            for (j = 0; j <= n; j++) {
               c.xyR[nc + 0][j] = 0.0;
               c.xyR[nc + 1][j] = 0.0;
            }
            c.xyR[nc + 0][i] = 1.0 + randomreal();
            c.xyR[nc + 1][i] = 1.0 + randomreal();
            ct.xZ[nc + 0] = 1;
            ct.xZ[nc + 1] = -1;
            nc += 2;
         }
      }
      minnscreate(n, &x0, &s);
      minnssetalgoags(&s, 0.1, 0.0);
      minnssetlc(&s, &c, &ct, nc);
      while (minnsiteration(&s)) {
         if (s.needfij) {
            s.fi.xR[0] = 0.0;
            for (i = 0; i < n; i++) {
               s.fi.xR[0] = d * sqr(s.x.xR[i]);
               s.j.xyR[0][i] = d * 2 * s.x.xR[i];
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnsresults(&s, &x1, &rep);
      set_error_flag(errors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:404");
      if (*errors) {
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(errors, !isfinite(x1.xR[i]) || fabs(x1.xR[i]) > 0.001, __FILE__, __LINE__, "testminnsunit.ap:408");
      }
      sumits += (double)rep.iterationscount / passcount;
      sumnfev += (double)rep.nfev / passcount;
   }
   ae_frame_leave();
}

// Basic constrained test: nonsmooth Rosenbrock posed as linearly constrained problem.
//
//              [                         ]
//     minimize [ 10*|x0^2-x1| + (1-x0)^2 ]
//              [                         ]
//
//     s.t. x0 <= 1/sqrt(2), x1 <= 0.5
//
// It's exact solution is x0=1/sqrt(2), x1=1/2
static void testminnsunit_basictest1lc(bool *errors) {
   ae_frame _frame_block;
   ae_int_t n;
   double v0;
   double v1;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(minnsstate, s);
   NewObj(minnsreport, rep);
   n = 2;
   ae_vector_set_length(&x0, n);
   ae_matrix_set_length(&c, 2, n + 1);
   ae_vector_set_length(&ct, 2);
   x0.xR[0] = 0.0;
   x0.xR[1] = 0.0;
   c.xyR[0][0] = 1.0;
   c.xyR[0][1] = 0.0;
   c.xyR[0][2] = 1 / sqrt(2.0);
   c.xyR[1][0] = 0.0;
   c.xyR[1][1] = 1.0;
   c.xyR[1][2] = 1.0 / 2.0;
   ct.xZ[0] = -1;
   ct.xZ[1] = -1;
   minnscreate(n, &x0, &s);
   minnssetlc(&s, &c, &ct, 2);
   minnssetalgoags(&s, 0.1, 0.0);
   while (minnsiteration(&s)) {
      if (s.needfij) {
         v0 = s.x.xR[0];
         v1 = s.x.xR[1];
         s.fi.xR[0] = 10 * fabs(sqr(v0) - v1) + sqr(v0 - 1);
         s.j.xyR[0][0] = 10 * sign(sqr(v0) - v1) * 2 * v0 + 2 * (v0 - 1);
         s.j.xyR[0][1] = (double)(10 * sign(sqr(v0) - v1) * (-1));
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   minnsresults(&s, &x1, &rep);
   set_error_flag(errors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:470");
   if (*errors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(errors, !isfinite(x1.xR[0]) || fabs(x1.xR[0] - 1 / sqrt(2.0)) > 0.001, __FILE__, __LINE__, "testminnsunit.ap:473");
   set_error_flag(errors, !isfinite(x1.xR[1]) || fabs(x1.xR[1] - 1.0 / 2.0) > 0.001, __FILE__, __LINE__, "testminnsunit.ap:474");
   ae_frame_leave();
}

// Basic nonlinearly constrained test
static void testminnsunit_basictest0nlc(bool *errors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t nec;
   ae_int_t nic;
   double d;
   double sumits;
   double sumnfev;
   ae_int_t pass;
   ae_int_t passcount;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewMatrix(ec, 0, 0, DT_REAL);
   NewMatrix(ic, 0, 0, DT_REAL);
   NewObj(minnsstate, s);
   NewObj(minnsreport, rep);
   d = -10.0;
   n = 5;
   passcount = 10;
   sumits = 0.0;
   sumnfev = 0.0;
   ae_vector_set_length(&x0, n);
   ae_matrix_set_length(&ec, 2 * n, n + 1);
   ae_matrix_set_length(&ic, 2 * n, n + 1);
   for (pass = 1; pass <= 10; pass++) {
      nec = 0;
      nic = 0;
      for (i = 0; i < n; i++) {
         x0.xR[i] = randommid();
         if (randombool()) {
            for (j = 0; j <= n; j++) {
               ec.xyR[nec][j] = 0.0;
            }
            ec.xyR[nec][i] = 1.0 + randomreal();
            nec++;
         } else {
            for (j = 0; j <= n; j++) {
               ic.xyR[nic + 0][j] = 0.0;
               ic.xyR[nic + 1][j] = 0.0;
            }
            ic.xyR[nic + 0][i] = 1.0 + randomreal();
            ic.xyR[nic + 1][i] = -1.0 - randomreal();
            nic += 2;
         }
      }
      minnscreate(n, &x0, &s);
      minnssetalgoags(&s, 0.1, 100.0);
      minnssetnlc(&s, nec, nic);
      while (minnsiteration(&s)) {
         if (s.needfij) {
            s.fi.xR[0] = 0.0;
            for (j = 0; j < n; j++) {
               s.fi.xR[0] = d * sqr(s.x.xR[j]);
               s.j.xyR[0][j] = d * 2 * s.x.xR[j];
            }
            for (i = 0; i < nec; i++) {
               s.fi.xR[1 + i] = -ec.xyR[i][n];
               for (j = 0; j < n; j++) {
                  s.fi.xR[1 + i] += s.x.xR[j] * ec.xyR[i][j];
                  s.j.xyR[1 + i][j] = ec.xyR[i][j];
               }
            }
            for (i = 0; i < nic; i++) {
               s.fi.xR[1 + nec + i] = -ic.xyR[i][n];
               for (j = 0; j < n; j++) {
                  s.fi.xR[1 + nec + i] += s.x.xR[j] * ic.xyR[i][j];
                  s.j.xyR[1 + nec + i][j] = ic.xyR[i][j];
               }
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnsresults(&s, &x1, &rep);
      set_error_flag(errors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:567");
      if (*errors) {
         ae_frame_leave();
         return;
      }
      for (i = 0; i < n; i++) {
         set_error_flag(errors, !isfinite(x1.xR[i]) || fabs(x1.xR[i]) > 0.001, __FILE__, __LINE__, "testminnsunit.ap:571");
      }
      sumits += (double)rep.iterationscount / passcount;
      sumnfev += (double)rep.nfev / passcount;
   }
   ae_frame_leave();
}

// Unconstrained test
static void testminnsunit_testuc(bool *primaryerrors, bool *othererrors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   double v;
   ae_int_t pass;
   bool requirexrep;
   double epsrad;
   bool werexreports;
   double repferr;
   double xtol;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x0s, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x1s, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(xrfirst, 0, DT_REAL);
   NewVector(xrlast, 0, DT_REAL);
   NewObj(minnsstate, state);
   NewObj(minnsreport, rep);
   for (pass = 1; pass <= 10; pass++) {
      for (n = 1; n <= 5; n++) {
      // First test:
      // * test that problem is successfully solved
      // * test that X-reports are performed correctly - present
      //   when requested, return first and last points correctly,
      //   not present by default, function value is reported
      //   correctly.
      // * we use non-unit scale, randomly chosen one, which results
      //   in badly conditioned problems (to check robustness)
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&xrfirst, n);
         ae_vector_set_length(&xrlast, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 10 * randommid();
            xc.xR[i] = randommid();
            d.xR[i] = pow(10.0, 2 * randommid());
            s.xR[i] = pow(10.0, 2 * randommid());
         }
         requirexrep = randombool();
         xtol = 0.01 * pow(10.0, -1 * randomreal());
         epsrad = xtol / 100;
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, epsrad, 0);
         minnssetscale(&state, &s);
         if (requirexrep) {
            minnssetxrep(&state, true);
         }
         werexreports = false;
         repferr = 0.0;
         while (minnsiteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] - xc.xR[i]);
               }
               continue;
            }
            if (state.xupdated) {
               if (!werexreports) {
                  ae_v_move(xrfirst.xR, 1, state.x.xR, 1, n);
               }
               ae_v_move(xrlast.xR, 1, state.x.xR, 1, n);
               werexreports = true;
               v = 0.0;
               for (i = 0; i < n; i++) {
                  v += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
               }
               repferr = rmax2(repferr, fabs(v - state.f));
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnsresults(&state, &x1, &rep);
         set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:668");
         set_error_flag(othererrors, werexreports && !requirexrep, __FILE__, __LINE__, "testminnsunit.ap:669");
         set_error_flag(othererrors, requirexrep && !werexreports, __FILE__, __LINE__, "testminnsunit.ap:670");
         set_error_flag(othererrors, repferr > 10000 * machineepsilon, __FILE__, __LINE__, "testminnsunit.ap:671");
         if (*primaryerrors || (*othererrors)) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(primaryerrors, !isfinite(x1.xR[i]) || fabs(x1.xR[i] - xc.xR[i]) / s.xR[i] > xtol, __FILE__, __LINE__, "testminnsunit.ap:676");
            if (requirexrep) {
               set_error_flag(othererrors, !isfinite(xrfirst.xR[i]) || fabs(x0.xR[i] - xrfirst.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testminnsunit.ap:679");
               set_error_flag(othererrors, !isfinite(xrlast.xR[i]) || fabs(x1.xR[i] - xrlast.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testminnsunit.ap:680");
            }
         }
      // Test numerical differentiation:
      // * test that problem is successfully solved
      // * test that correct function value is reported
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&xrlast, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 10 * randommid();
            xc.xR[i] = randommid();
            d.xR[i] = pow(10.0, 2 * randommid());
            s.xR[i] = pow(10.0, 2 * randommid());
         }
         xtol = 0.01 * pow(10.0, -1 * randomreal());
         epsrad = xtol / 100;
         minnscreatef(n, &x0, epsrad / 100, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, epsrad, 0);
         minnssetscale(&state, &s);
         minnssetxrep(&state, true);
         repferr = 0.0;
         while (minnsiteration(&state)) {
            if (state.needfi) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
               }
               continue;
            }
            if (state.xupdated) {
               v = 0.0;
               for (i = 0; i < n; i++) {
                  v += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
               }
               repferr = rmax2(repferr, fabs(v - state.f));
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnsresults(&state, &x1, &rep);
         set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:731");
         set_error_flag(othererrors, repferr > 10000 * machineepsilon, __FILE__, __LINE__, "testminnsunit.ap:732");
         if (*primaryerrors || (*othererrors)) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(primaryerrors, !isfinite(x1.xR[i]) || fabs(x1.xR[i] - xc.xR[i]) / s.xR[i] > xtol, __FILE__, __LINE__, "testminnsunit.ap:736");
         }
      // Test scaling: we perform several steps on unit-scale problem,
      // then we perform same amount of steps on re-scaled problem,
      // starting from same point (but scaled according to chosen scale).
      //
      // Correctly written optimizer should perform essentially same steps
      // (up to scale) on both problems. At least, it holds within first
      // several steps, before rounding errors start to accumulate.
      //
      // NOTE: we also check that correctly scaled points are reported.
      //       And, as side effect, we check MinNSRestartFrom().
      //
      // NOTE: we use moderate scale and diagonal coefficients in order
      //       to have well-conditioned system. We test correctness of
      //       formulae here, not robustness of algorithm.
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&x0s, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&xrlast, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, randommid());
            d.xR[i] = pow(10.0, randommid());
            x0.xR[i] = randommid();
            xc.xR[i] = randommid();
            x0s.xR[i] = x0.xR[i] * s.xR[i];
         }
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, 0.0, testminnsunit_scalingtestcnt);
         minnssetxrep(&state, false);
         while (minnsiteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] - xc.xR[i]);
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnsresults(&state, &x1, &rep);
         set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:788");
         if (*primaryerrors || (*othererrors)) {
            ae_frame_leave();
            return;
         }
         minnssetscale(&state, &s);
         minnssetxrep(&state, true);
         minnsrestartfrom(&state, &x0s);
         werexreports = false;
         while (minnsiteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] / s.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] / s.xR[i] - xc.xR[i]) / s.xR[i];
               }
               continue;
            }
            if (state.xupdated) {
               ae_v_move(xrlast.xR, 1, state.x.xR, 1, n);
               werexreports = true;
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnsresults(&state, &x1s, &rep);
         set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:818");
         if (*primaryerrors || (*othererrors)) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(primaryerrors, (!isfinite(x1.xR[i]) || !isfinite(x1s.xR[i])) || fabs(x1.xR[i] - x1s.xR[i] / s.xR[i]) > 1.0E-4, __FILE__, __LINE__, "testminnsunit.ap:823");
            set_error_flag(othererrors, !isfinite(xrlast.xR[i]) || fabs(x1s.xR[i] - xrlast.xR[i]) > testminnsunit_scalingtesttol, __FILE__, __LINE__, "testminnsunit.ap:827");
         }
      }
   }
   ae_frame_leave();
}

// Box constrained test
static void testminnsunit_testbc(bool *primaryerrors, bool *othererrors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double v0;
   double v1;
   ae_int_t pass;
   ae_int_t passcount;
   bool requirexrep;
   double epsrad;
   bool werexreports;
   double repferr;
   double xtol;
   ae_int_t maxn;
   double conda;
   double gnorm;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x0s, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x1s, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(scaledbndl, 0, DT_REAL);
   NewVector(scaledbndu, 0, DT_REAL);
   NewVector(xrfirst, 0, DT_REAL);
   NewVector(xrlast, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewObj(minnsstate, state);
   NewObj(minnsreport, rep);
   passcount = 10;
   maxn = 5;
// First test:
// * sparse function
// * test that problem is successfully solved
// * non-unit scale is used, which results in badly conditioned problem
// * check that all iterates are feasible (box-constrained)
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&xrfirst, n);
         ae_vector_set_length(&xrlast, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 10 * randommid();
            xc.xR[i] = randommid();
            d.xR[i] = pow(10.0, 2 * randommid());
            s.xR[i] = pow(10.0, 2 * randommid());
            bndl.xR[i] = -INFINITY;
            bndu.xR[i] = +INFINITY;
            k = randominteger(5);
            if (k == 1) {
               bndl.xR[i] = randommid();
            }
            if (k == 2) {
               bndu.xR[i] = randommid();
            }
            if (k == 3) {
               v0 = randommid();
               v1 = randommid();
               bndl.xR[i] = rmin2(v0, v1);
               bndu.xR[i] = rmax2(v0, v1);
            }
            if (k == 4) {
               bndl.xR[i] = randommid();
               bndu.xR[i] = bndl.xR[i];
            }
         }
         requirexrep = randombool();
         xtol = 0.01 * pow(10.0, -1 * randomreal());
         epsrad = xtol / 100;
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, epsrad, 0);
         minnssetbc(&state, &bndl, &bndu);
         minnssetscale(&state, &s);
         if (requirexrep) {
            minnssetxrep(&state, true);
         }
         werexreports = false;
         repferr = 0.0;
         while (minnsiteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] - xc.xR[i]);
               }
               continue;
            }
            if (state.xupdated) {
               if (!werexreports) {
                  ae_v_move(xrfirst.xR, 1, state.x.xR, 1, n);
               }
               ae_v_move(xrlast.xR, 1, state.x.xR, 1, n);
               werexreports = true;
               v = 0.0;
               for (i = 0; i < n; i++) {
                  v += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
               }
               repferr = rmax2(repferr, fabs(v - state.f));
               for (i = 0; i < n; i++) {
                  set_error_flag(primaryerrors, state.x.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminnsunit.ap:944");
                  set_error_flag(primaryerrors, state.x.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminnsunit.ap:945");
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnsresults(&state, &x1, &rep);
         set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:953");
         set_error_flag(othererrors, werexreports && !requirexrep, __FILE__, __LINE__, "testminnsunit.ap:954");
         set_error_flag(othererrors, requirexrep && !werexreports, __FILE__, __LINE__, "testminnsunit.ap:955");
         set_error_flag(othererrors, repferr > 10000 * machineepsilon, __FILE__, __LINE__, "testminnsunit.ap:956");
         if (*primaryerrors || (*othererrors)) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(primaryerrors, !isfinite(x1.xR[i]) || fabs(x1.xR[i] - rboundval(xc.xR[i], bndl.xR[i], bndu.xR[i])) / s.xR[i] > xtol, __FILE__, __LINE__, "testminnsunit.ap:961");
            set_error_flag(primaryerrors, x1.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminnsunit.ap:962");
            set_error_flag(primaryerrors, x1.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminnsunit.ap:963");
            if (requirexrep) {
               set_error_flag(othererrors, !isfinite(xrfirst.xR[i]) || fabs(rboundval(x0.xR[i], bndl.xR[i], bndu.xR[i]) - xrfirst.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testminnsunit.ap:966");
               set_error_flag(othererrors, !isfinite(xrlast.xR[i]) || fabs(x1.xR[i] - xrlast.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testminnsunit.ap:967");
            }
         }
      }
   }
// A bit harder test:
// * dense quadratic function (smooth), may be prone to different
//   rounding-related issues
// * non-negativity box constraints
// * unit scale is used
// * extreme stopping criteria (EpsX=1.0E-12)
// * single pass for each problem size
// * check that constrained gradient at solution is small
   conda = 1.0E3;
   epsrad = 1.0E-12;
   for (n = 1; n <= 10; n++) {
      ae_vector_set_length(&x0, n);
      ae_vector_set_length(&bndl, n);
      ae_vector_set_length(&bndu, n);
      ae_vector_set_length(&b, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = 1.0;
         b.xR[i] = randomreal() - 0.5;
         bndl.xR[i] = 0.0;
         bndu.xR[i] = +INFINITY;
      }
      spdmatrixrndcond(n, conda, &a);
      minnscreate(n, &x0, &state);
      minnssetalgoags(&state, 0.1, 0.0);
      minnssetcond(&state, epsrad, 0);
      minnssetbc(&state, &bndl, &bndu);
      while (minnsiteration(&state)) {
         if (state.needfij) {
            state.fi.xR[0] = 0.0;
            for (i = 0; i < n; i++) {
               state.j.xyR[0][i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               state.fi.xR[0] += b.xR[i] * state.x.xR[i];
               for (j = 0; j < n; j++) {
                  state.fi.xR[0] += 0.5 * state.x.xR[i] * a.xyR[i][j] * state.x.xR[j];
               }
            }
            for (i = 0; i < n; i++) {
               state.j.xyR[0][i] += b.xR[i];
               for (j = 0; j < n; j++) {
                  state.j.xyR[0][i] += a.xyR[i][j] * state.x.xR[j];
               }
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnsresults(&state, &x1, &rep);
      set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:1030");
      if (*primaryerrors || (*othererrors)) {
         ae_frame_leave();
         return;
      }
      gnorm = 0.0;
      for (i = 0; i < n; i++) {
         v = b.xR[i];
         for (j = 0; j < n; j++) {
            v += a.xyR[i][j] * x1.xR[j];
         }
         if (x1.xR[i] == bndl.xR[i] && v > 0.0) {
            v = 0.0;
         }
         if (x1.xR[i] == bndu.xR[i] && v < 0.0) {
            v = 0.0;
         }
         gnorm += sqr(v);
         set_error_flag(primaryerrors, x1.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminnsunit.ap:1045");
         set_error_flag(primaryerrors, x1.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminnsunit.ap:1046");
      }
      gnorm = sqrt(gnorm);
      set_error_flag(primaryerrors, gnorm > 1.0E-4, __FILE__, __LINE__, "testminnsunit.ap:1049");
   }
// Test on HIGHLY nonconvex bound constrained problem.
// Algorithm should be able to stop.
//
// NOTE: because algorithm can be attracted to saddle points,
//       x[i] may be -1, +1 or approximately zero.
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = randomreal() - 0.5;
            bndl.xR[i] = -1.0;
            bndu.xR[i] = 1.0;
         }
         epsrad = 0.0001;
         xtol = 15.0 * epsrad;
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, epsrad, 0);
         minnssetbc(&state, &bndl, &bndu);
         v = -1000.0;
         while (minnsiteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  v0 = fabs(state.x.xR[i]);
                  v1 = (double)sign(state.x.xR[i]);
                  state.fi.xR[0] += v * (v0 + v0 * v0);
                  state.j.xyR[0][i] = v * (v1 + 2 * v0 * v1);
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnsresults(&state, &x1, &rep);
         set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:1095");
         for (i = 0; i < n; i++) {
            v = fabs(x1.xR[i]);
            set_error_flag(primaryerrors, !isfinite(x1.xR[i]), __FILE__, __LINE__, "testminnsunit.ap:1099");
            set_error_flag(primaryerrors, v != 1.0 && v > xtol, __FILE__, __LINE__, "testminnsunit.ap:1100");
         }
      }
   }
// Test numerical differentiation:
// * test that problem is successfully solved
// * test that correct function value is reported
// * test that all iterates are within bound-constrained area
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&xrlast, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 10 * randommid();
            xc.xR[i] = randommid();
            d.xR[i] = pow(10.0, 2 * randommid());
            s.xR[i] = pow(10.0, 2 * randommid());
            bndl.xR[i] = -INFINITY;
            bndu.xR[i] = +INFINITY;
            k = randominteger(5);
            if (k == 1) {
               bndl.xR[i] = randommid();
            }
            if (k == 2) {
               bndu.xR[i] = randommid();
            }
            if (k == 3) {
               v0 = randommid();
               v1 = randommid();
               bndl.xR[i] = rmin2(v0, v1);
               bndu.xR[i] = rmax2(v0, v1);
            }
            if (k == 4) {
               bndl.xR[i] = randommid();
               bndu.xR[i] = bndl.xR[i];
            }
         }
         xtol = 0.01 * pow(10.0, -2 * randomreal());
         epsrad = xtol / 100;
         minnscreatef(n, &x0, epsrad / 100, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, epsrad, 0);
         minnssetscale(&state, &s);
         minnssetbc(&state, &bndl, &bndu);
         minnssetxrep(&state, true);
         repferr = 0.0;
         while (minnsiteration(&state)) {
            if (state.needfi) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                  set_error_flag(primaryerrors, state.x.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminnsunit.ap:1164");
                  set_error_flag(primaryerrors, state.x.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminnsunit.ap:1165");
               }
               continue;
            }
            if (state.xupdated) {
               v = 0.0;
               for (i = 0; i < n; i++) {
                  v += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                  set_error_flag(primaryerrors, state.x.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminnsunit.ap:1176");
                  set_error_flag(primaryerrors, state.x.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminnsunit.ap:1177");
               }
               repferr = rmax2(repferr, fabs(v - state.f));
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnsresults(&state, &x1, &rep);
         set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:1186");
         set_error_flag(othererrors, repferr > 10000 * machineepsilon, __FILE__, __LINE__, "testminnsunit.ap:1187");
         if (*primaryerrors || (*othererrors)) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(primaryerrors, !isfinite(x1.xR[i]) || fabs(x1.xR[i] - rboundval(xc.xR[i], bndl.xR[i], bndu.xR[i])) / s.xR[i] > xtol, __FILE__, __LINE__, "testminnsunit.ap:1191");
         }
      }
   }
// Test scaling: we perform several steps on unit-scale problem,
// then we perform same amount of steps on re-scaled problem,
// starting from same point (but scaled according to chosen scale).
//
// Correctly written optimizer should perform essentially same steps
// (up to scale) on both problems. At least, it holds within first
// several steps, before rounding errors start to accumulate.
//
// NOTE: we also check that correctly scaled points are reported.
//       And, as side effect, we check MinNSRestartFrom().
//
// NOTE: we use very low scale and diagonal coefficients in order
//       to have well-conditioned system. We test correctness of
//       formulae here, not robustness of algorithm.
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&x0s, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&xrlast, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         ae_vector_set_length(&scaledbndl, n);
         ae_vector_set_length(&scaledbndu, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(2.0, (double)(randominteger(5) - 2));
            d.xR[i] = pow(10.0, randomreal() - 0.5);
            x0.xR[i] = randommid();
            xc.xR[i] = randommid();
            x0s.xR[i] = x0.xR[i] * s.xR[i];
            bndl.xR[i] = -INFINITY;
            bndu.xR[i] = +INFINITY;
            k = randominteger(5);
            if (k == 1) {
               bndl.xR[i] = randommid();
            }
            if (k == 2) {
               bndu.xR[i] = randommid();
            }
            if (k == 3) {
               v0 = randommid();
               v1 = randommid();
               bndl.xR[i] = rmin2(v0, v1);
               bndu.xR[i] = rmax2(v0, v1);
            }
            if (k == 4) {
               bndl.xR[i] = randommid();
               bndu.xR[i] = bndl.xR[i];
            }
            scaledbndl.xR[i] = bndl.xR[i] * s.xR[i];
            scaledbndu.xR[i] = bndu.xR[i] * s.xR[i];
         }
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.01, 0.0);
         minnssetcond(&state, 0.0, testminnsunit_scalingtestcnt);
         minnssetbc(&state, &bndl, &bndu);
         minnssetxrep(&state, false);
         while (minnsiteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] - xc.xR[i]);
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnsresults(&state, &x1, &rep);
         set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:1272");
         if (*primaryerrors || (*othererrors)) {
            ae_frame_leave();
            return;
         }
         minnssetscale(&state, &s);
         minnssetbc(&state, &scaledbndl, &scaledbndu);
         minnsrestartfrom(&state, &x0s);
         while (minnsiteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] / s.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] / s.xR[i] - xc.xR[i]) / s.xR[i];
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnsresults(&state, &x1s, &rep);
         set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:1293");
         if (*primaryerrors || (*othererrors)) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(primaryerrors, (!isfinite(x1.xR[i]) || !isfinite(x1s.xR[i])) || fabs(x1.xR[i] - x1s.xR[i] / s.xR[i]) > testminnsunit_scalingtesttol, __FILE__, __LINE__, "testminnsunit.ap:1297");
         }
      }
   }
   ae_frame_leave();
}

// Linearly constrained test
static void testminnsunit_testlc(bool *primaryerrors, bool *othererrors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t nc;
   double v;
   double v0;
   double v1;
   double vv;
   double flast0;
   double flast1;
   ae_int_t pass;
   double epsrad;
   double repferr;
   double xtol;
   double ftol;
   double rho;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x0s, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(x1s, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(scaledc, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewVector(scaledbndl, 0, DT_REAL);
   NewVector(scaledbndu, 0, DT_REAL);
   NewVector(xrfirst, 0, DT_REAL);
   NewVector(xrlast, 0, DT_REAL);
   NewObj(minnsstate, state);
   NewObj(minnsreport, rep);
   for (pass = 1; pass <= 10; pass++) {
      for (n = 1; n <= 5; n++) {
      // First test:
      // * smooth problem
      // * subject to random linear constraints
      // * with non-unit scale
      //
      // We:
      // * compare function value at constrained solution with function
      //   value for penalized unconstrained problem. We do not compare
      //   actual X-values returned, because they are highly unstable -
      //   function values at minimum show better stability.
      // * check that correct function values are reported
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = 10 * randommid();
            xc.xR[i] = randommid();
            d.xR[i] = 1 + randomreal();
            s.xR[i] = 1 + randomreal();
         }
         nc = randominteger((n + 1) / 2);
         if (nc > 0) {
            ae_matrix_set_length(&c, nc, n + 1);
            ae_vector_set_length(&ct, nc);
            for (i = 0; i < nc; i++) {
               ct.xZ[i] = randominteger(3) - 1;
               for (j = 0; j <= n; j++) {
                  c.xyR[i][j] = randomreal() - 0.5;
               }
            }
         }
         epsrad = 0.00001;
         ftol = 0.01;
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, epsrad, 0);
         minnssetscale(&state, &s);
         minnssetxrep(&state, true);
         minnssetlc(&state, &c, &ct, nc);
         repferr = 0.0;
         flast0 = NAN;
         while (minnsiteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * sqr(state.x.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * (2 * (state.x.xR[i] - xc.xR[i]));
               }
               continue;
            }
            if (state.xupdated) {
               flast0 = 0.0;
               for (i = 0; i < n; i++) {
                  flast0 += d.xR[i] * sqr(state.x.xR[i] - xc.xR[i]);
               }
               repferr = rmax2(repferr, fabs(flast0 - state.f));
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnsresults(&state, &x1, &rep);
         set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:1402");
         set_error_flag(primaryerrors, !isfinite(flast0), __FILE__, __LINE__, "testminnsunit.ap:1403");
         set_error_flag(othererrors, repferr > 10000 * machineepsilon, __FILE__, __LINE__, "testminnsunit.ap:1404");
         if (*primaryerrors || (*othererrors)) {
            ae_frame_leave();
            return;
         }
         minnssetlc(&state, &c, &ct, 0);
         minnsrestartfrom(&state, &x0);
         rho = 10000.0;
         repferr = 0.0;
         flast1 = NAN;
         while (minnsiteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * sqr(state.x.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * (2 * (state.x.xR[i] - xc.xR[i]));
               }
               for (i = 0; i < nc; i++) {
                  v = ae_v_dotproduct(state.x.xR, 1, c.xyR[i], 1, n);
                  v -= c.xyR[i][n];
                  vv = 0.0;
                  if (ct.xZ[i] < 0) {
                     vv = (double)sign(rmax2(v, 0.0));
                     v = rmax2(v, 0.0);
                  }
                  if (ct.xZ[i] == 0) {
                     vv = (double)sign(v);
                     v = fabs(v);
                  }
                  if (ct.xZ[i] > 0) {
                     vv = (double)-sign(rmax2(-v, 0.0));
                     v = rmax2(-v, 0.0);
                  }
                  state.fi.xR[0] += rho * v;
                  for (j = 0; j < n; j++) {
                     state.j.xyR[0][j] += rho * vv * c.xyR[i][j];
                  }
               }
               continue;
            }
            if (state.xupdated) {
               flast1 = 0.0;
               for (i = 0; i < n; i++) {
                  flast1 += d.xR[i] * sqr(state.x.xR[i] - xc.xR[i]);
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnsresults(&state, &x2, &rep);
         set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:1462");
         set_error_flag(primaryerrors, !isfinite(flast1), __FILE__, __LINE__, "testminnsunit.ap:1463");
         if (*primaryerrors || (*othererrors)) {
            ae_frame_leave();
            return;
         }
         set_error_flag(primaryerrors, fabs(flast0 - flast1) > ftol, __FILE__, __LINE__, "testminnsunit.ap:1466");
      // Test on HIGHLY nonconvex linearly constrained problem.
      // Algorithm should be able to stop at the bounds.
         ae_vector_set_length(&x0, n);
         ae_matrix_set_length(&c, 2 * n, n + 1);
         ae_vector_set_length(&ct, 2 * n);
         for (i = 0; i < n; i++) {
            x0.xR[i] = randomreal() - 0.5;
            for (j = 0; j < n; j++) {
               c.xyR[2 * i + 0][j] = 0.0;
               c.xyR[2 * i + 1][j] = 0.0;
            }
            c.xyR[2 * i + 0][i] = 1.0;
            c.xyR[2 * i + 0][n] = -1.0;
            ct.xZ[2 * i + 0] = 1;
            c.xyR[2 * i + 1][i] = 1.0;
            c.xyR[2 * i + 1][n] = 1.0;
            ct.xZ[2 * i + 1] = -1;
         }
         epsrad = 0.0001;
         xtol = 15.0 * epsrad;
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, epsrad, 0);
         minnssetlc(&state, &c, &ct, 2 * n);
         v = -1000.0;
         while (minnsiteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  v0 = fabs(state.x.xR[i]);
                  v1 = (double)sign(state.x.xR[i]);
                  state.fi.xR[0] += v * (v0 + v0 * v0);
                  state.j.xyR[0][i] = v * (v1 + 2 * v0 * v1);
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnsresults(&state, &x1, &rep);
         set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:1516");
         for (i = 0; i < n; i++) {
            set_error_flag(primaryerrors, !isfinite(x1.xR[i]), __FILE__, __LINE__, "testminnsunit.ap:1519");
            set_error_flag(primaryerrors, (fabs(x1.xR[i] - 1) > xtol && fabs(x1.xR[i]) > xtol) && fabs(x1.xR[i] + 1) > xtol, __FILE__, __LINE__, "testminnsunit.ap:1520");
         }
      // Test scaling: we perform several steps on unit-scale problem,
      // then we perform same amount of steps on re-scaled problem,
      // starting from same point (but scaled according to chosen scale).
      //
      // Correctly written optimizer should perform essentially same steps
      // (up to scale) on both problems. At least, it holds within first
      // several steps, before rounding errors start to accumulate.
      //
      // NOTE: we also check that correctly scaled points are reported.
      //       And, as side effect, we check MinNSRestartFrom().
      //
      // NOTE: we use moderate scale and diagonal coefficients in order
      //       to have well-conditioned system. We test correctness of
      //       formulae here, not robustness of algorithm.
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&xc, n);
         ae_vector_set_length(&x0s, n);
         ae_vector_set_length(&d, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&xrlast, n);
         ae_matrix_set_length(&c, 2 * n, n + 1);
         ae_matrix_set_length(&scaledc, 2 * n, n + 1);
         ae_vector_set_length(&ct, 2 * n);
         for (i = 0; i < 2 * n; i++) {
            ct.xZ[i] = 0;
            for (j = 0; j <= n; j++) {
               c.xyR[i][j] = 0.0;
            }
         }
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, randommid());
            d.xR[i] = pow(10.0, randommid());
            x0.xR[i] = randommid();
            xc.xR[i] = randommid();
            x0s.xR[i] = x0.xR[i] * s.xR[i];
            k = randominteger(5);
            if (k == 1) {
               c.xyR[2 * i + 0][i] = 1.0;
               c.xyR[2 * i + 0][n] = randommid();
               ct.xZ[2 * i + 0] = 1;
            }
            if (k == 2) {
               c.xyR[2 * i + 0][i] = 1.0;
               c.xyR[2 * i + 0][n] = randommid();
               ct.xZ[2 * i + 0] = -1;
            }
            if (k == 3) {
               v0 = randommid();
               v1 = randommid();
               c.xyR[2 * i + 0][i] = 1.0;
               c.xyR[2 * i + 0][n] = rmin2(v0, v1);
               c.xyR[2 * i + 1][i] = 1.0;
               c.xyR[2 * i + 1][n] = rmax2(v0, v1);
               ct.xZ[2 * i + 0] = 1;
               ct.xZ[2 * i + 1] = -1;
            }
            if (k == 4) {
               c.xyR[2 * i + 0][i] = 1.0;
               c.xyR[2 * i + 0][n] = randommid();
               ct.xZ[2 * i + 0] = 0;
            }
         }
         for (i = 0; i < 2 * n; i++) {
            for (j = 0; j < n; j++) {
               scaledc.xyR[i][j] = c.xyR[i][j] / s.xR[j];
            }
            scaledc.xyR[i][n] = c.xyR[i][n];
         }
         minnscreate(n, &x0, &state);
         minnssetalgoags(&state, 0.1, 0.0);
         minnssetcond(&state, 0.0, testminnsunit_scalingtestcnt);
         minnssetlc(&state, &c, &ct, 2 * n);
         minnssetxrep(&state, false);
         while (minnsiteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] - xc.xR[i]);
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnsresults(&state, &x1, &rep);
         set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:1622");
         if (*primaryerrors || (*othererrors)) {
            ae_frame_leave();
            return;
         }
         minnssetscale(&state, &s);
         minnssetlc(&state, &scaledc, &ct, 2 * n);
         minnsrestartfrom(&state, &x0s);
         while (minnsiteration(&state)) {
            if (state.needfij) {
               state.fi.xR[0] = 0.0;
               for (i = 0; i < n; i++) {
                  state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] / s.xR[i] - xc.xR[i]);
                  state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] / s.xR[i] - xc.xR[i]) / s.xR[i];
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minnsresults(&state, &x1s, &rep);
         set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:1643");
         if (*primaryerrors || (*othererrors)) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < n; i++) {
            set_error_flag(primaryerrors, (!isfinite(x1.xR[i]) || !isfinite(x1s.xR[i])) || fabs(x1.xR[i] - x1s.xR[i] / s.xR[i]) > testminnsunit_scalingtesttol, __FILE__, __LINE__, "testminnsunit.ap:1647");
         }
      }
   }
   ae_frame_leave();
}

// Nonlinearly constrained test
static void testminnsunit_testnlc(bool *primaryerrors, bool *othererrors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t nc;
   ae_int_t nec;
   double v;
   ae_int_t pass;
   ae_int_t passcount;
   double epsrad;
   double xtol;
   double rho;
   ae_int_t maxn;
   double diffstep;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x0s, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(x1s, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(r, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(scaledc, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewVector(scaledbndl, 0, DT_REAL);
   NewVector(scaledbndu, 0, DT_REAL);
   NewVector(xrfirst, 0, DT_REAL);
   NewVector(xrlast, 0, DT_REAL);
   NewObj(minnsstate, state);
   NewObj(minnsreport, rep);
   passcount = 10;
   maxn = 5;
   rho = 100.0;
// First test:
// * simple problem
// * subject to random nonlinear constraints of form r[i]*x[i] OPERATION 0.0,
//   where OPERATION is <= or =
// * with non-unit scale
//
// We:
// * compare numerical solution with analytic one, which can be
//   easily calculated
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (nc = 1; nc <= n; nc++) {
            for (nec = 0; nec <= nc; nec++) {
               ae_vector_set_length(&x0, n);
               ae_vector_set_length(&xc, n);
               ae_vector_set_length(&d, n);
               ae_vector_set_length(&r, n);
               ae_vector_set_length(&s, n);
               for (i = 0; i < n; i++) {
                  x0.xR[i] = randommid();
                  xc.xR[i] = randommid();
                  d.xR[i] = pow(10.0, randomreal() - 0.5);
                  s.xR[i] = pow(10.0, randomreal() - 0.5);
                  r.xR[i] = (2 * randominteger(2) - 1) * (0.1 + randomreal());
               }
               xtol = 0.01;
               epsrad = xtol / 100;
               minnscreate(n, &x0, &state);
               minnssetalgoags(&state, 0.1, rho);
               minnssetcond(&state, epsrad, 0);
               minnssetscale(&state, &s);
               minnssetnlc(&state, nec, nc - nec);
               while (minnsiteration(&state)) {
                  if (state.needfij) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                        state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] - xc.xR[i]);
                     }
                     for (i = 1; i <= nc; i++) {
                        state.fi.xR[i] = state.x.xR[i - 1] * r.xR[i - 1];
                        for (j = 0; j < n; j++) {
                           state.j.xyR[i][j] = 0.0;
                        }
                        state.j.xyR[i][i - 1] = r.xR[i - 1];
                     }
                     continue;
                  }
                  ae_assert(false, "Assertion failed");
               }
               minnsresults(&state, &x1, &rep);
               set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:1743");
               if (*primaryerrors || (*othererrors)) {
                  ae_frame_leave();
                  return;
               }
               for (i = 0; i < n; i++) {
                  v = xc.xR[i];
                  if (i < nec) {
                     v = 0.0;
                  }
                  if (i >= nec && i < nc) {
                     if (r.xR[i] > 0.0) {
                        v = rmin2(v, 0.0);
                     }
                     if (r.xR[i] < 0.0) {
                        v = rmax2(v, 0.0);
                     }
                  }
                  set_error_flag(primaryerrors, !isfinite(x1.xR[i]), __FILE__, __LINE__, "testminnsunit.ap:1762");
                  set_error_flag(primaryerrors, fabs(x1.xR[i] - v) > xtol * s.xR[i], __FILE__, __LINE__, "testminnsunit.ap:1763");
               }
            }
         }
      }
   }
// Numerical differentiation test.
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (nc = 1; nc <= n; nc++) {
            for (nec = 0; nec <= nc; nec++) {
               ae_vector_set_length(&x0, n);
               ae_vector_set_length(&xc, n);
               ae_vector_set_length(&d, n);
               ae_vector_set_length(&r, n);
               ae_vector_set_length(&s, n);
               for (i = 0; i < n; i++) {
                  x0.xR[i] = randommid();
                  xc.xR[i] = randommid();
                  d.xR[i] = pow(10.0, randomreal() - 0.5);
                  s.xR[i] = pow(10.0, randomreal() - 0.5);
                  r.xR[i] = (2 * randominteger(2) - 1) * (0.1 + randomreal());
               }
               xtol = 0.01;
               epsrad = xtol / 100;
               diffstep = epsrad / 10;
               minnscreatef(n, &x0, diffstep, &state);
               minnssetalgoags(&state, 0.1, rho);
               minnssetcond(&state, epsrad, 0);
               minnssetscale(&state, &s);
               minnssetnlc(&state, nec, nc - nec);
               while (minnsiteration(&state)) {
                  if (state.needfi) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                     }
                     for (i = 1; i <= nc; i++) {
                        state.fi.xR[i] = state.x.xR[i - 1] * r.xR[i - 1];
                     }
                     continue;
                  }
                  ae_assert(false, "Assertion failed");
               }
               minnsresults(&state, &x1, &rep);
               set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:1813");
               if (*primaryerrors || (*othererrors)) {
                  ae_frame_leave();
                  return;
               }
               for (i = 0; i < n; i++) {
                  v = xc.xR[i];
                  if (i < nec) {
                     v = 0.0;
                  }
                  if (i >= nec && i < nc) {
                     if (r.xR[i] > 0.0) {
                        v = rmin2(v, 0.0);
                     }
                     if (r.xR[i] < 0.0) {
                        v = rmax2(v, 0.0);
                     }
                  }
                  set_error_flag(primaryerrors, !isfinite(x1.xR[i]), __FILE__, __LINE__, "testminnsunit.ap:1832");
                  set_error_flag(primaryerrors, fabs(x1.xR[i] - v) > xtol * s.xR[i], __FILE__, __LINE__, "testminnsunit.ap:1833");
               }
            }
         }
      }
   }
// Test scaling: we perform several steps on unit-scale problem,
// then we perform same amount of steps on re-scaled problem,
// starting from same point (but scaled according to chosen scale).
//
// Correctly written optimizer should perform essentially same steps
// (up to scale) on both problems. At least, it holds within first
// several steps, before rounding errors start to accumulate.
//
// NOTE: we use moderate scale and diagonal coefficients in order
//       to have well-conditioned system. We test correctness of
//       formulae here, not robustness of algorithm.
//
// NOTE: we have to use very relaxed thresholds for this test because
//       each AGS iteration involves solution of several nested QP
//       subproblems, so rounding errors accumulate too quickly.
//       It does not mean that algorithm is inexact, just that two
//       almost identical optimization sessions diverge too fast to
//       compare them.
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (nc = 1; nc <= n; nc++) {
            for (nec = 0; nec <= nc; nec++) {
               ae_vector_set_length(&x0, n);
               ae_vector_set_length(&x0s, n);
               ae_vector_set_length(&xc, n);
               ae_vector_set_length(&d, n);
               ae_vector_set_length(&r, n);
               ae_vector_set_length(&s, n);
               for (i = 0; i < n; i++) {
                  x0.xR[i] = randommid();
                  xc.xR[i] = randommid();
                  d.xR[i] = pow(10.0, randomreal() - 0.5);
                  s.xR[i] = pow(10.0, randomreal() - 0.5);
                  r.xR[i] = (2 * randominteger(2) - 1) * (0.1 + randomreal());
                  x0s.xR[i] = x0.xR[i] * s.xR[i];
               }
               minnscreate(n, &x0, &state);
               minnssetalgoags(&state, 0.1, 1.0);
               minnssetcond(&state, 0.0, testminnsunit_scalingtestcnt);
               minnssetnlc(&state, nec, nc - nec);
               while (minnsiteration(&state)) {
                  if (state.needfij) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] - xc.xR[i]);
                        state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] - xc.xR[i]);
                     }
                     for (i = 1; i <= nc; i++) {
                        state.fi.xR[i] = state.x.xR[i - 1] * r.xR[i - 1];
                        for (j = 0; j < n; j++) {
                           state.j.xyR[i][j] = 0.0;
                        }
                        state.j.xyR[i][i - 1] = r.xR[i - 1];
                     }
                     continue;
                  }
                  ae_assert(false, "Assertion failed");
               }
               minnsresults(&state, &x1, &rep);
               set_error_flag(primaryerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:1906");
               if (*primaryerrors || (*othererrors)) {
                  ae_frame_leave();
                  return;
               }
               minnssetscale(&state, &s);
               minnsrestartfrom(&state, &x0s);
               while (minnsiteration(&state)) {
                  if (state.needfij) {
                     state.fi.xR[0] = 0.0;
                     for (i = 0; i < n; i++) {
                        state.fi.xR[0] += d.xR[i] * fabs(state.x.xR[i] / s.xR[i] - xc.xR[i]);
                        state.j.xyR[0][i] = d.xR[i] * sign(state.x.xR[i] / s.xR[i] - xc.xR[i]) / s.xR[i];
                     }
                     for (i = 1; i <= nc; i++) {
                        state.fi.xR[i] = state.x.xR[i - 1] / s.xR[i - 1] * r.xR[i - 1];
                        for (j = 0; j < n; j++) {
                           state.j.xyR[i][j] = 0.0;
                        }
                        state.j.xyR[i][i - 1] = r.xR[i - 1] / s.xR[i - 1];
                     }
                     continue;
                  }
                  ae_assert(false, "Assertion failed");
               }
               minnsresults(&state, &x1s, &rep);
               for (i = 0; i < n; i++) {
                  set_error_flag(primaryerrors, (!isfinite(x1.xR[i]) || !isfinite(x1s.xR[i])) || fabs(x1.xR[i] - x1s.xR[i] / s.xR[i]) > testminnsunit_scalingtesttol, __FILE__, __LINE__, "testminnsunit.ap:1937");
               }
            }
         }
      }
   }
   ae_frame_leave();
}

// Special tests
static void testminnsunit_testother(bool *othererrors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t k;
   double v0;
   double v1;
   double v;
   double xtol;
   double epsrad;
   double rho;
   ae_frame_make(&_frame_block);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewObj(minnsstate, state);
   NewObj(minnsreport, rep);
// First test:
// * 2D problem, minimization of F(x0,x1)=x1
// * two constraints, with wildly different magnitudes
//   * G0(x0,x1)=Rho*Abs(x0+x1)=0
//   * H0(x0,x1)=Rho*(x0-1000) <= 0
//   where Rho is some large value
//
// Optimizer should be able to deal with situation when
// magnitude of Jacobian components is so wildly different.
   n = 2;
   ae_vector_set_length(&x0, n);
   x0.xR[0] = 0.1;
   x0.xR[1] = 1.0;
   epsrad = 0.00001;
   xtol = 0.01;
   for (k = 0; k <= 6; k++) {
      rho = pow(10.0, (double)k);
      minnscreate(n, &x0, &state);
      minnssetalgoags(&state, 0.1, 10.0);
      minnssetcond(&state, epsrad, 0);
      minnssetnlc(&state, 1, 1);
      v = 1000.0;
      while (minnsiteration(&state)) {
         if (state.needfij) {
            v0 = state.x.xR[0];
            v1 = state.x.xR[1];
            state.fi.xR[0] = v1;
            state.j.xyR[0][0] = 0.0;
            state.j.xyR[0][1] = 1.0;
            state.fi.xR[1] = rho * fabs(v0 + v1);
            state.j.xyR[1][0] = rho * sign(v0 + v1);
            state.j.xyR[1][1] = rho * sign(v0 + v1);
            state.fi.xR[2] = rho * (v0 - v);
            state.j.xyR[2][0] = rho;
            state.j.xyR[2][1] = 0.0;
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minnsresults(&state, &x1, &rep);
      set_error_flag(othererrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminnsunit.ap:2003");
      set_error_flag(othererrors, !isfinite(x1.xR[0]), __FILE__, __LINE__, "testminnsunit.ap:2004");
      set_error_flag(othererrors, !isfinite(x1.xR[1]), __FILE__, __LINE__, "testminnsunit.ap:2005");
      set_error_flag(othererrors, fabs(x1.xR[0] - v) > xtol, __FILE__, __LINE__, "testminnsunit.ap:2006");
      set_error_flag(othererrors, fabs(x1.xR[1] + v) > xtol, __FILE__, __LINE__, "testminnsunit.ap:2007");
   }
   ae_frame_leave();
}

bool testminns(bool silent) {
   bool wereerrors;
   bool ucerrors;
   bool bcerrors;
   bool lcerrors;
   bool nlcerrors;
   bool othererrors;
   bool result;
   wereerrors = false;
   ucerrors = false;
   bcerrors = false;
   lcerrors = false;
   nlcerrors = false;
   othererrors = false;
// Basic tests
   testminnsunit_basictest0nlc(&nlcerrors);
   testminnsunit_basictest0uc(&ucerrors);
   testminnsunit_basictest1uc(&ucerrors);
   testminnsunit_basictest0bc(&bcerrors);
   testminnsunit_basictest1bc(&bcerrors);
   testminnsunit_basictest0lc(&lcerrors);
   testminnsunit_basictest1lc(&lcerrors);
// Special tests
   testminnsunit_testother(&othererrors);
// Full scale tests
   testminnsunit_testuc(&ucerrors, &othererrors);
   testminnsunit_testbc(&bcerrors, &othererrors);
   testminnsunit_testlc(&lcerrors, &othererrors);
   testminnsunit_testnlc(&nlcerrors, &othererrors);
// end
   wereerrors = (((ucerrors || bcerrors) || lcerrors) || nlcerrors) || othererrors;
   if (!silent) {
      printf("TESTING MINNS OPTIMIZATION\n");
      printf("TESTS:\n");
      printf("* UNCONSTRAINED                           ");
      if (ucerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* BOUND CONSTRAINED                       ");
      if (bcerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* LINEARLY CONSTRAINED                    ");
      if (lcerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* NONLINEARLY CONSTRAINED                 ");
      if (nlcerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* OTHER PROPERTIES                        ");
      if (othererrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (wereerrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !wereerrors;
   return result;
}

// === minbc testing unit ===
static const ae_int_t testminbcunit_maxoptguardlevel = 1;

// Calculate test function IIP2
//
// f(x) = sum( ((i*i+1)^FK*x[i])^2, i=0..N-1)
//
// It has high condition number which makes fast convergence unlikely without
// good preconditioner.
//
static void testminbcunit_calciip2(minbcstate *state, ae_int_t n, ae_int_t fk) {
   ae_int_t i;
   if (state->needfg) {
      state->f = 0.0;
   }
   for (i = 0; i < n; i++) {
      if (state->needfg) {
         state->f += pow((double)(i * i + 1), (double)(2 * fk)) * sqr(state->x.xR[i]);
         state->g.xR[i] = pow((double)(i * i + 1), (double)(2 * fk)) * 2 * state->x.xR[i];
      }
   }
}

// This function sets random preconditioner:
// * unit one, for PrecKind=0
// * diagonal-based one, for PrecKind=1
// * scale-based one, for PrecKind=2
static void testminbcunit_setrandompreconditioner(minbcstate *state, ae_int_t n, ae_int_t preckind) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewVector(p, 0, DT_REAL);
   if (preckind == 1) {
      ae_vector_set_length(&p, n);
      for (i = 0; i < n; i++) {
         p.xR[i] = exp(3.0 * randommid());
      }
      minbcsetprecdiag(state, &p);
   } else {
      minbcsetprecdefault(state);
   }
   ae_frame_leave();
}

// This function test feasibility properties.
// It launches a sequence of problems and examines their solutions.
// Most of the attention is directed towards feasibility properties,
// although we make some quick checks to ensure that actual solution is found.
//
// On failure sets FeasErr (or ConvErr, depending on failure type) to True,
// or leaves it unchanged otherwise.
//
// IntErr is set to True on internal errors (errors in the control flow).
static void testminbcunit_testfeasibility(bool *feaserr, bool *converr, bool *interr) {
   ae_frame _frame_block;
   ae_int_t pkind;
   ae_int_t preckind;
   ae_int_t passcount;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t nmax;
   ae_int_t i;
   ae_int_t p;
   double v;
   double weakepsg;
   ae_int_t dkind;
   double diffstep;
   ae_frame_make(&_frame_block);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(xs, 0, DT_REAL);
   NewVector(svdw, 0, DT_REAL);
   NewMatrix(csvdu, 0, 0, DT_REAL);
   NewMatrix(svdvt, 0, 0, DT_REAL);
   NewObj(minbcstate, state);
   NewObj(minbcreport, rep);
   nmax = 5;
   weakepsg = 1.0E-4;
   passcount = 10;
   for (pass = 1; pass <= passcount; pass++) {
   // Another simple problem:
   // * bound constraints 0 <= x[i] <= 1
   // * no linear constraints
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P={2,4} and x0 is randomly selected from [-1,+2]^N
   // * with such simple boundaries and function it is easy to find
   //   analytic form of solution: S[i] = bound(x0[i], 0, 1)
   // * we also check that both final solution and subsequent iterates
   //   are strictly feasible
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         for (preckind = 0; preckind <= 2; preckind++) {
            for (pkind = 1; pkind <= 2; pkind++) {
               for (n = 1; n <= nmax; n++) {
               // Generate X, BL, BU.
                  p = 2 * pkind;
                  ae_vector_set_length(&bl, n);
                  ae_vector_set_length(&bu, n);
                  ae_vector_set_length(&x, n);
                  ae_vector_set_length(&x0, n);
                  for (i = 0; i < n; i++) {
                     bl.xR[i] = 0.0;
                     bu.xR[i] = 1.0;
                     x.xR[i] = randomreal();
                     x0.xR[i] = 3.0 * randomreal() - 1.0;
                  }
               // Create and optimize
                  if (dkind == 0) {
                     minbccreate(n, &x, &state);
                  }
                  if (dkind == 1) {
                     minbccreatef(n, &x, diffstep, &state);
                  }
                  minbcsetbc(&state, &bl, &bu);
                  minbcsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbcunit_setrandompreconditioner(&state, n, preckind);
                  while (minbciteration(&state)) {
                     if (state.needf || state.needfg) {
                        state.f = 0.0;
                     }
                     for (i = 0; i < n; i++) {
                        if (state.needf || state.needfg) {
                           state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                        }
                        if (state.needfg) {
                           state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                        }
                        *feaserr = *feaserr || state.x.xR[i] < 0.0;
                        *feaserr = *feaserr || state.x.xR[i] > 1.0;
                     }
                  }
                  minbcresults(&state, &x, &rep);
                  if (rep.terminationtype <= 0) {
                     *converr = true;
                     ae_frame_leave();
                     return;
                  }
               // * compare solution with analytic one
               // * check feasibility
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     if (x.xR[i] > 0.0 && x.xR[i] < 1.0) {
                        v += sqr(p * pow(x.xR[i] - x0.xR[i], (double)(p - 1)));
                     }
                     *feaserr = *feaserr || x.xR[i] < 0.0;
                     *feaserr = *feaserr || x.xR[i] > 1.0;
                  }
                  *converr = *converr || sqrt(v) > weakepsg;
               }
            }
         }
      }
   // Same as previous problem, but with minor modifications:
   // * some bound constraints are 0 <= x[i] <= 1, some are Ci=x[i]=Ci
   // * no linear constraints
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from converging
   //   to the feasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P={2,4} and x0 is randomly selected from [-1,+2]^N
   // * with such simple boundaries and function it is easy to find
   //   analytic form of solution: S[i] = bound(x0[i], 0, 1)
   // * we also check that both final solution and subsequent iterates
   //   are strictly feasible
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         for (preckind = 0; preckind <= 2; preckind++) {
            for (pkind = 1; pkind <= 2; pkind++) {
               for (n = 1; n <= nmax; n++) {
               // Generate X, BL, BU.
                  p = 2 * pkind;
                  ae_vector_set_length(&bl, n);
                  ae_vector_set_length(&bu, n);
                  ae_vector_set_length(&x, n);
                  ae_vector_set_length(&x0, n);
                  for (i = 0; i < n; i++) {
                     if (randombool()) {
                        bl.xR[i] = 0.0;
                        bu.xR[i] = 1.0;
                     } else {
                        bl.xR[i] = randomreal();
                        bu.xR[i] = bl.xR[i];
                     }
                     x.xR[i] = randomreal();
                     x0.xR[i] = 3.0 * randomreal() - 1.0;
                  }
               // Create and optimize
                  if (dkind == 0) {
                     minbccreate(n, &x, &state);
                  }
                  if (dkind == 1) {
                     minbccreatef(n, &x, diffstep, &state);
                  }
                  minbcsetbc(&state, &bl, &bu);
                  minbcsetcond(&state, weakepsg, 0.0, 0.0, 0);
                  testminbcunit_setrandompreconditioner(&state, n, preckind);
                  while (minbciteration(&state)) {
                     if (state.needf || state.needfg) {
                        state.f = 0.0;
                     }
                     for (i = 0; i < n; i++) {
                        if (state.needf || state.needfg) {
                           state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                        }
                        if (state.needfg) {
                           state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                        }
                        *feaserr = *feaserr || state.x.xR[i] < bl.xR[i];
                        *feaserr = *feaserr || state.x.xR[i] > bu.xR[i];
                     }
                  }
                  minbcresults(&state, &x, &rep);
                  if (rep.terminationtype <= 0) {
                     *converr = true;
                     ae_frame_leave();
                     return;
                  }
               // * compare solution with analytic one
               // * check feasibility
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     if (x.xR[i] > bl.xR[i] && x.xR[i] < bu.xR[i]) {
                        v += sqr(p * pow(x.xR[i] - x0.xR[i], (double)(p - 1)));
                     }
                     *feaserr = *feaserr || x.xR[i] < bl.xR[i];
                     *feaserr = *feaserr || x.xR[i] > bu.xR[i];
                  }
                  *converr = *converr || sqrt(v) > weakepsg;
               }
            }
         }
      }
   // Infeasible problem:
   // * all bound constraints are 0 <= x[i] <= 1 except for one
   // * that one is 0 >= x[i] >= 1
   // * no linear constraints
   // * preconditioner is chosen at random (we just want to be
   //   sure that preconditioning won't prevent us from detecting
   //   infeasible point):
   //   * unit preconditioner
   //   * random diagonal-based preconditioner
   //   * random scale-based preconditioner
   // * F(x) = |x-x0|^P, where P={2,4} and x0 is randomly selected from [-1,+2]^N
   // * algorithm must return correct error code on such problem
      for (preckind = 0; preckind <= 2; preckind++) {
         for (pkind = 1; pkind <= 2; pkind++) {
            for (n = 1; n <= nmax; n++) {
            // Generate X, BL, BU.
               p = 2 * pkind;
               ae_vector_set_length(&bl, n);
               ae_vector_set_length(&bu, n);
               ae_vector_set_length(&x, n);
               ae_vector_set_length(&x0, n);
               for (i = 0; i < n; i++) {
                  bl.xR[i] = 0.0;
                  bu.xR[i] = 1.0;
                  x.xR[i] = randomreal();
                  x0.xR[i] = 3.0 * randomreal() - 1.0;
               }
               i = randominteger(n);
               bl.xR[i] = 1.0;
               bu.xR[i] = 0.0;
            // Create and optimize
               minbccreate(n, &x, &state);
               minbcsetbc(&state, &bl, &bu);
               minbcsetcond(&state, weakepsg, 0.0, 0.0, 0);
               testminbcunit_setrandompreconditioner(&state, n, preckind);
               while (minbciteration(&state)) {
                  if (state.needfg) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += pow(state.x.xR[i] - x0.xR[i], (double)p);
                        state.g.xR[i] = p * pow(state.x.xR[i] - x0.xR[i], (double)(p - 1));
                     }
                     continue;
                  }
               // Unknown protocol specified
                  *interr = true;
                  ae_frame_leave();
                  return;
               }
               minbcresults(&state, &x, &rep);
               *feaserr = *feaserr || rep.terminationtype != -3;
            }
         }
      }
   }
   ae_frame_leave();
}

// This function additional properties.
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testminbcunit_testother(bool *err) {
   ae_frame _frame_block;
   ae_int_t passcount;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double fprev;
   double xprev;
   double stpmax;
   double v;
   ae_int_t pkind;
   ae_int_t ckind;
   ae_int_t mkind;
   double vc;
   double vm;
   double epsx;
   double epsg;
   double eps;
   double tmpeps;
   double diffstep;
   ae_int_t dkind;
   bool wasf;
   bool wasfg;
   double r;
   ae_int_t spoiliteration;
   ae_int_t stopiteration;
   ae_int_t spoilvar;
   double spoilval;
   double ss;
   ae_int_t stopcallidx;
   ae_int_t callidx;
   ae_int_t maxits;
   bool terminationrequested;
   ae_frame_make(&_frame_block);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(xf, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(xlast, 0, DT_REAL);
   NewVector(a, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(h, 0, DT_REAL);
   NewMatrix(fulla, 0, 0, DT_REAL);
   NewObj(minbcstate, state);
   NewObj(minbcreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   epsx = 1.0E-4;
   epsg = 1.0E-8;
   passcount = 10;
// Try to reproduce bug 570 (optimizer hangs on problems where it is required
// to perform very small step - less than 1E-50 - in order to activate constraints).
//
// The problem being solved is:
//
//     min x[0]+x[1]+...+x[n-1]
//
// subject to
//
//     x[i] >= 0, for i=0..n-1
//
// with initial point
//
//     x[0] = 1.0E-100, x[1]=x[2]=...=0.5
//
// We try to reproduce this problem in different settings:
// * boundary-only constraints - we test that completion code is positive,
//   and all x[] are EXACTLY zero
// * boundary constraints posed as general linear ones - we test that
//   completion code is positive, and all x[] are APPROXIMATELY zero.
   n = 10;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&bl, n);
   ae_vector_set_length(&bu, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = 0.5;
      bl.xR[i] = 0.0;
      bu.xR[i] = +INFINITY;
   }
   x.xR[0] = 1.0E-100;
   minbccreate(n, &x, &state);
   minbcsetbc(&state, &bl, &bu);
   minbcsetcond(&state, 0.0, 0.0, 0.0, 2 * n);
   while (minbciteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += state.x.xR[i];
            state.g.xR[i] = 1.0;
         }
      }
   }
   minbcresults(&state, &xf, &rep);
   set_error_flag(err, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbcunit.ap:494");
   if (rep.terminationtype > 0) {
      for (i = 0; i < n; i++) {
         set_error_flag(err, xf.xR[i] != 0.0, __FILE__, __LINE__, "testminbcunit.ap:497");
      }
   }
// Test reports:
// * first value must be starting point
// * last value must be last point
   for (pass = 1; pass <= passcount; pass++) {
      n = 50;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      ae_vector_set_length(&bl, n);
      ae_vector_set_length(&bu, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 10.0;
         bl.xR[i] = randommid();
         bu.xR[i] = +INFINITY;
      }
      minbccreate(n, &x, &state);
      minbcsetbc(&state, &bl, &bu);
      minbcsetcond(&state, 1.0E-64, 0.0, 0.0, 10);
      minbcsetxrep(&state, true);
      fprev = maxrealnumber;
      while (minbciteration(&state)) {
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += sqr((1 + i) * state.x.xR[i]);
               state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
            }
         }
         if (state.xupdated) {
            if (fprev == maxrealnumber) {
               for (i = 0; i < n; i++) {
                  set_error_flag(err, state.x.xR[i] != x.xR[i], __FILE__, __LINE__, "testminbcunit.ap:538");
               }
            }
            fprev = state.f;
            ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
         }
      }
      minbcresults(&state, &x, &rep);
      for (i = 0; i < n; i++) {
         set_error_flag(err, x.xR[i] != xlast.xR[i], __FILE__, __LINE__, "testminbcunit.ap:545");
      }
   }
// Test differentiation vs. analytic gradient
// (first one issues NeedF requests, second one issues NeedFG requests)
   for (pass = 1; pass <= passcount; pass++) {
      n = 10;
      diffstep = 1.0E-6;
      for (dkind = 0; dkind <= 1; dkind++) {
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&xlast, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 1.0;
         }
         if (dkind == 0) {
            minbccreate(n, &x, &state);
         }
         if (dkind == 1) {
            minbccreatef(n, &x, diffstep, &state);
         }
         minbcsetcond(&state, 1.0E-6, 0.0, epsx, 0);
         wasf = false;
         wasfg = false;
         while (minbciteration(&state)) {
            if (state.needf || state.needfg) {
               state.f = 0.0;
            }
            for (i = 0; i < n; i++) {
               if (state.needf || state.needfg) {
                  state.f += sqr((1 + i) * state.x.xR[i]);
               }
               if (state.needfg) {
                  state.g.xR[i] = 2 * (1 + i) * state.x.xR[i];
               }
            }
            wasf = wasf || state.needf;
            wasfg = wasfg || state.needfg;
         }
         minbcresults(&state, &x, &rep);
         if (dkind == 0) {
            set_error_flag(err, wasf || !wasfg, __FILE__, __LINE__, "testminbcunit.ap:585");
         }
         if (dkind == 1) {
            set_error_flag(err, !wasf || wasfg, __FILE__, __LINE__, "testminbcunit.ap:587");
         }
      }
   }
// Test that numerical differentiation uses scaling.
//
// In order to test that we solve simple optimization
// problem: min(x^2) with initial x equal to 0.0.
//
// We choose random DiffStep and S, then we check that
// optimizer evaluates function at +-DiffStep*S only.
   for (pass = 1; pass <= passcount; pass++) {
      ae_vector_set_length(&x, 1);
      ae_vector_set_length(&s, 1);
      diffstep = randomreal() * 1.0E-6;
      s.xR[0] = exp(randomreal() * 4 - 2);
      x.xR[0] = 0.0;
      minbccreatef(1, &x, diffstep, &state);
      minbcsetcond(&state, 1.0E-6, 0.0, epsx, 0);
      minbcsetscale(&state, &s);
      v = 0.0;
      while (minbciteration(&state)) {
         state.f = sqr(state.x.xR[0]);
         v = rmax2(v, fabs(state.x.xR[0]));
      }
      minbcresults(&state, &x, &rep);
      r = v / (s.xR[0] * diffstep);
      set_error_flag(err, fabs(log(r)) > log(1 + 1000 * machineepsilon), __FILE__, __LINE__, "testminbcunit.ap:618");
   }
// Test stpmax
   for (pass = 1; pass <= passcount; pass++) {
      n = 1;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&bl, n);
      ae_vector_set_length(&bu, n);
      x.xR[0] = 100.0;
      bl.xR[0] = randommid();
      bu.xR[0] = +INFINITY;
      stpmax = 0.05 + 0.05 * randomreal();
      minbccreate(n, &x, &state);
      minbcsetbc(&state, &bl, &bu);
      minbcsetcond(&state, epsg, 0.0, epsx, 0);
      minbcsetxrep(&state, true);
      minbcsetstpmax(&state, stpmax);
      xprev = x.xR[0];
      while (minbciteration(&state)) {
         if (state.needfg) {
            state.f = exp(state.x.xR[0]) + exp(-state.x.xR[0]);
            state.g.xR[0] = exp(state.x.xR[0]) - exp(-state.x.xR[0]);
            set_error_flag(err, fabs(state.x.xR[0] - xprev) > (1 + sqrt(machineepsilon)) * stpmax, __FILE__, __LINE__, "testminbcunit.ap:646");
         }
         if (state.xupdated) {
            set_error_flag(err, fabs(state.x.xR[0] - xprev) > (1 + sqrt(machineepsilon)) * stpmax, __FILE__, __LINE__, "testminbcunit.ap:650");
            xprev = state.x.xR[0];
         }
      }
   }
// Ability to solve problems with function which is unbounded from below
   for (pass = 1; pass <= passcount; pass++) {
      n = 1;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&bl, n);
      ae_vector_set_length(&bu, n);
      bl.xR[0] = 4 * randomreal() + 1;
      bu.xR[0] = bl.xR[0] + 1;
      x.xR[0] = 0.5 * (bl.xR[0] + bu.xR[0]);
      minbccreate(n, &x, &state);
      minbcsetbc(&state, &bl, &bu);
      minbcsetcond(&state, epsg, 0.0, epsx, 0);
      while (minbciteration(&state)) {
         if (state.needfg) {
            state.f = -1.0E8 * sqr(state.x.xR[0]);
            state.g.xR[0] = -2.0E8 * state.x.xR[0];
         }
      }
      minbcresults(&state, &x, &rep);
      set_error_flag(err, fabs(x.xR[0] - bu.xR[0]) > epsx, __FILE__, __LINE__, "testminbcunit.ap:680");
   }
// Test correctness of the scaling:
// * initial point is random point from [+1,+2]^N
// * f(x) = SUM(A[i]*x[i]^4), C[i] is random from [0.01,100]
// * function is EFFECTIVELY unconstrained; it has formal constraints,
//   but they are inactive at the solution; we try different variants
//   in order to explore different control paths of the optimizer:
//   0) absense of constraints
//   1) bound constraints -100000 <= x[i] <= 100000
// * we use random scaling matrix
// * we test different variants of the preconditioning:
//   0) unit preconditioner
//   1) random diagonal from [0.01,100]
//   2) scale preconditioner
// * we set very stringent stopping conditions
// * and we test that in the extremum stopping conditions are
//   satisfied subject to the current scaling coefficients.
   for (pass = 1; pass <= passcount; pass++) {
      tmpeps = 1.0E-5;
      for (n = 1; n <= 10; n++) {
         for (ckind = 0; ckind <= 1; ckind++) {
            for (pkind = 0; pkind <= 2; pkind++) {
               ae_vector_set_length(&x, n);
               ae_vector_set_length(&a, n);
               ae_vector_set_length(&s, n);
               ae_vector_set_length(&h, n);
               ae_vector_set_length(&bl, n);
               ae_vector_set_length(&bu, n);
               for (i = 0; i < n; i++) {
                  x.xR[i] = randomreal() + 1;
                  bl.xR[i] = -100000.0;
                  bu.xR[i] = 100000.0;
                  a.xR[i] = exp(log(10.0) * randommid());
                  s.xR[i] = exp(log(10.0) * randommid());
                  h.xR[i] = exp(log(10.0) * randommid());
               }
               minbccreate(n, &x, &state);
               if (ckind == 1) {
                  minbcsetbc(&state, &bl, &bu);
               }
               if (pkind == 1) {
                  minbcsetprecdiag(&state, &h);
               }
               if (pkind == 2) {
                  minbcsetprecscale(&state);
               }
               minbcsetcond(&state, tmpeps, 0.0, 0.0, 0);
               minbcsetscale(&state, &s);
               while (minbciteration(&state)) {
                  if (state.needfg) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += a.xR[i] * sqr(state.x.xR[i]);
                        state.g.xR[i] = 2 * a.xR[i] * state.x.xR[i];
                     }
                  }
               }
               minbcresults(&state, &x, &rep);
               if (rep.terminationtype <= 0) {
                  set_error_flag(err, true, __FILE__, __LINE__, "testminbcunit.ap:747");
                  ae_frame_leave();
                  return;
               }
               v = 0.0;
               for (i = 0; i < n; i++) {
                  v += sqr(s.xR[i] * 2 * a.xR[i] * x.xR[i]);
               }
               v = sqrt(v);
               set_error_flag(err, v > tmpeps, __FILE__, __LINE__, "testminbcunit.ap:754");
            }
         }
      }
   }
// Check correctness of the "trimming".
//
// Trimming is a technique which is used to help algorithm
// cope with unbounded functions. In order to check this
// technique we will try to solve following optimization
// problem:
//
//     min f(x) subject to no constraints on X
//            { 1/(1-x) + 1/(1+x) + c*x, if -0.999999<x<0.999999
//     f(x) = {
//            { M, if x <= -0.999999 or x >= 0.999999
//
// where c is either 1.0 or 1.0E+4, M is either 1.0E8, 1.0E20 or +INF
// (we try different combinations)
   for (pass = 1; pass <= passcount; pass++) {
      for (ckind = 0; ckind <= 1; ckind++) {
         for (mkind = 0; mkind <= 2; mkind++) {
         // Choose c and M
            vc = 1.0;
            vm = 1.0;
            if (ckind == 0) {
               vc = 1.0;
            }
            if (ckind == 1) {
               vc = 1.0E+4;
            }
            if (mkind == 0) {
               vm = 1.0E+8;
            }
            if (mkind == 1) {
               vm = 1.0E+20;
            }
            if (mkind == 2) {
               vm = +INFINITY;
            }
         // Create optimizer, solve optimization problem
            epsg = 1.0E-6 * vc;
            ae_vector_set_length(&x, 1);
            x.xR[0] = 0.0;
            minbccreate(1, &x, &state);
            minbcsetcond(&state, epsg, 0.0, 0.0, 0);
            while (minbciteration(&state)) {
               if (state.needfg) {
                  if (-0.999999 < state.x.xR[0] && state.x.xR[0] < 0.999999) {
                     state.f = 1 / (1 - state.x.xR[0]) + 1 / (1 + state.x.xR[0]) + vc * state.x.xR[0];
                     state.g.xR[0] = 1 / sqr(1 - state.x.xR[0]) - 1 / sqr(1 + state.x.xR[0]) + vc;
                  } else {
                     state.f = vm;
                     state.g.xR[0] = 0.0;
                  }
               }
            }
            minbcresults(&state, &x, &rep);
            if (rep.terminationtype <= 0) {
               set_error_flag(err, true, __FILE__, __LINE__, "testminbcunit.ap:822");
               ae_frame_leave();
               return;
            }
            set_error_flag(err, fabs(1 / sqr(1 - x.xR[0]) - 1 / sqr(1 + x.xR[0]) + vc) > epsg, __FILE__, __LINE__, "testminbcunit.ap:825");
         }
      }
   }
// Test behaviour on noisy functions.
//
// Consider following problem:
// * f(x,y) = (x+1)^2 + (y+1)^2 + 10000*MachineEpsilon*RandomReal()
// * boundary constraints x >= 0, y >= 0
// * starting point (x0,y0)=(10*MachineEpsilon,1.0)
//
// Such problem contains small numerical noise. Without noise its
// solution is (xs,ys)=(0,0), which is easy to find. However, presence
// of the noise makes it hard to solve:
// * noisy f(x,y) is monotonically decreasing only when we perform
//   steps orders of magnitude larger than 10000*MachineEpsilon
// * at small scales f(x,y) is non-monotonic and non-convex
// * however, our first step must be done towards
//   (x1,y1) = (0,1-some_small_value), and length of such step is
//   many times SMALLER than 10000*MachineEpsilon
// * second step, from (x1,y1) to (xs,ys), will be large enough to
//   ignore numerical noise, so the only problem is to perform
//   first step
//
// Naive implementation of BC should fail sometimes (sometimes -
// due to non-deterministic nature of noise) on such problem. However,
// our improved implementation should solve it correctly. We test
// several variations of inner stopping criteria.
   for (pass = 1; pass <= passcount; pass++) {
      eps = 1.0E-9;
      ae_vector_set_length(&x, 2);
      ae_vector_set_length(&bl, 2);
      ae_vector_set_length(&bu, 2);
      x.xR[0] = 10 * machineepsilon;
      x.xR[1] = 1.0;
      bl.xR[0] = 0.0;
      bu.xR[0] = +INFINITY;
      bl.xR[1] = 0.0;
      bu.xR[1] = +INFINITY;
      for (ckind = 0; ckind <= 2; ckind++) {
         minbccreate(2, &x, &state);
         minbcsetbc(&state, &bl, &bu);
         if (ckind == 0) {
            minbcsetcond(&state, eps, 0.0, 0.0, 0);
         }
         if (ckind == 1) {
            minbcsetcond(&state, 0.0, eps, 0.0, 0);
         }
         if (ckind == 2) {
            minbcsetcond(&state, 0.0, 0.0, eps, 0);
         }
         while (minbciteration(&state)) {
            if (state.needfg) {
               state.f = sqr(state.x.xR[0] + 1) + sqr(state.x.xR[1] + 1) + 10000 * machineepsilon * randomreal();
               state.g.xR[0] = 2 * (state.x.xR[0] + 1);
               state.g.xR[1] = 2 * (state.x.xR[1] + 1);
            }
         }
         minbcresults(&state, &xf, &rep);
         if ((rep.terminationtype <= 0 || xf.xR[0] != 0.0) || xf.xR[1] != 0.0) {
            set_error_flag(err, true, __FILE__, __LINE__, "testminbcunit.ap:889");
            ae_frame_leave();
            return;
         }
      }
   }
// Deterministic variation of the previous problem.
//
// Consider following problem:
// * boundary constraints x >= 0, y >= 0
// * starting point (x0,y0)=(10*MachineEpsilon,1.0)
//            / (x+1)^2 + (y+1)^2,        for (x,y) != (x0,y0)
// * f(x,y) = |
//            \ (x+1)^2 + (y+1)^2 - 0.1,  for (x,y)=(x0,y0)
//
// Such problem contains deterministic numerical noise (-0.1 at
// starting point). Without noise its solution is easy to find.
// However, presence of the noise makes it hard to solve:
// * our first step must be done towards (x1,y1) = (0,1-some_small_value),
//   but such step will increase function valye by approximately 0.1  -
//   instead of decreasing it.
//
// Naive implementation of BC should fail on such problem. However,
// our improved implementation should solve it correctly. We test
// several variations of inner stopping criteria.
   for (pass = 1; pass <= passcount; pass++) {
      eps = 1.0E-9;
      ae_vector_set_length(&x, 2);
      ae_vector_set_length(&bl, 2);
      ae_vector_set_length(&bu, 2);
      x.xR[0] = 10 * machineepsilon;
      x.xR[1] = 1.0;
      bl.xR[0] = 0.0;
      bu.xR[0] = +INFINITY;
      bl.xR[1] = 0.0;
      bu.xR[1] = +INFINITY;
      for (ckind = 0; ckind <= 2; ckind++) {
         minbccreate(2, &x, &state);
         minbcsetbc(&state, &bl, &bu);
         if (ckind == 0) {
            minbcsetcond(&state, eps, 0.0, 0.0, 0);
         }
         if (ckind == 1) {
            minbcsetcond(&state, 0.0, eps, 0.0, 0);
         }
         if (ckind == 2) {
            minbcsetcond(&state, 0.0, 0.0, eps, 0);
         }
         while (minbciteration(&state)) {
            if (state.needfg) {
               state.f = sqr(state.x.xR[0] + 1) + sqr(state.x.xR[1] + 1);
               if (state.x.xR[0] == x.xR[0] && state.x.xR[1] == x.xR[1]) {
                  state.f -= 0.1;
               }
               state.g.xR[0] = 2 * (state.x.xR[0] + 1);
               state.g.xR[1] = 2 * (state.x.xR[1] + 1);
            }
         }
         minbcresults(&state, &xf, &rep);
         if ((rep.terminationtype <= 0 || xf.xR[0] != 0.0) || xf.xR[1] != 0.0) {
            set_error_flag(err, true, __FILE__, __LINE__, "testminbcunit.ap:952");
            ae_frame_leave();
            return;
         }
      }
   }
// Test integrity checks for NAN/INF:
// * algorithm solves optimization problem, which is normal for some time (quadratic)
// * after 5-th step we choose random component of gradient and consistently spoil
//   it by NAN or INF.
// * we check that correct termination code is returned (-8)
   n = 100;
   for (pass = 1; pass <= 10; pass++) {
      spoiliteration = 5;
      stopiteration = 8;
      if (hqrndnormal(&rs) > 0.0) {
      // Gradient can be spoiled by +INF, -INF, NAN
         spoilvar = hqrnduniformi(&rs, n);
         i = hqrnduniformi(&rs, 3);
         spoilval = NAN;
         if (i == 0) {
            spoilval = -INFINITY;
         }
         if (i == 1) {
            spoilval = +INFINITY;
         }
      } else {
      // Function value can be spoiled only by NAN
      // (+INF can be recognized as legitimate value during optimization)
         spoilvar = -1;
         spoilval = NAN;
      }
      spdmatrixrndcond(n, 1.0E5, &fulla);
      ae_vector_set_length(&b, n);
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         b.xR[i] = hqrndnormal(&rs);
         x0.xR[i] = hqrndnormal(&rs);
      }
      minbccreate(n, &x0, &state);
      minbcsetcond(&state, 0.0, 0.0, 0.0, stopiteration);
      minbcsetxrep(&state, true);
      k = -1;
      while (minbciteration(&state)) {
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += b.xR[i] * state.x.xR[i];
               state.g.xR[i] = b.xR[i];
               for (j = 0; j < n; j++) {
                  state.f += 0.5 * state.x.xR[i] * fulla.xyR[i][j] * state.x.xR[j];
                  state.g.xR[i] += fulla.xyR[i][j] * state.x.xR[j];
               }
            }
            if (k >= spoiliteration) {
               if (spoilvar < 0) {
                  state.f = spoilval;
               } else {
                  state.g.xR[spoilvar] = spoilval;
               }
            }
            continue;
         }
         if (state.xupdated) {
            k++;
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minbcresults(&state, &x1, &rep);
      set_error_flag(err, rep.terminationtype != -8, __FILE__, __LINE__, "testminbcunit.ap:1037");
   }
// Check algorithm ability to handle request for termination:
// * to terminate with correct return code = 8
// * to return point which was "current" at the moment of termination
//
// NOTE: we solve problem with "corrupted" preconditioner which makes it hard
//       to converge in less than StopCallIdx iterations
   for (pass = 1; pass <= 50; pass++) {
      n = 3;
      ss = 100.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&xlast, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = 6 + randomreal();
      }
      ae_vector_set_length(&s, 3);
      s.xR[0] = 0.00001;
      s.xR[1] = 0.00001;
      s.xR[2] = 10000.0;
      stopcallidx = randominteger(20);
      maxits = 25;
      minbccreate(n, &x, &state);
      minbcsetcond(&state, 0.0, 0.0, 0.0, maxits);
      minbcsetxrep(&state, true);
      minbcsetprecdiag(&state, &s);
      callidx = 0;
      terminationrequested = false;
      ae_v_move(xlast.xR, 1, x.xR, 1, n);
      while (minbciteration(&state)) {
         if (state.needfg) {
            state.f = ss * sqr(exp(state.x.xR[0]) - 2) + sqr(state.x.xR[1]) + sqr(state.x.xR[2] - state.x.xR[0]);
            state.g.xR[0] = 2 * ss * (exp(state.x.xR[0]) - 2) * exp(state.x.xR[0]) + 2 * (state.x.xR[2] - state.x.xR[0]) * (-1);
            state.g.xR[1] = 2 * state.x.xR[1];
            state.g.xR[2] = 2 * (state.x.xR[2] - state.x.xR[0]);
            if (callidx == stopcallidx) {
               minbcrequesttermination(&state);
               terminationrequested = true;
            }
            callidx++;
            continue;
         }
         if (state.xupdated) {
            if (!terminationrequested) {
               ae_v_move(xlast.xR, 1, state.x.xR, 1, n);
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minbcresults(&state, &x, &rep);
      set_error_flag(err, rep.terminationtype != 8, __FILE__, __LINE__, "testminbcunit.ap:1095");
      for (i = 0; i < n; i++) {
         set_error_flag(err, x.xR[i] != xlast.xR[i], __FILE__, __LINE__, "testminbcunit.ap:1097");
      }
   }
   ae_frame_leave();
}

// This function tests preconditioning
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testminbcunit_testpreconditioning(bool *err) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t i;
   ae_int_t k;
   ae_int_t cntb1;
   ae_int_t cntb2;
   ae_int_t cntg1;
   ae_int_t cntg2;
   double epsg;
   ae_int_t ckind;
   ae_int_t fk;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(vd, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(units, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(diagh, 0, DT_REAL);
   NewObj(minbcstate, state);
   NewObj(minbcreport, rep);
// Preconditioner test 1.
//
// If
// * B1 is default preconditioner with unit scale
// * G1 is diagonal preconditioner based on approximate diagonal of Hessian matrix
// * B2 is default preconditioner with non-unit scale S[i]=1/sqrt(h[i])
// * G2 is scale-based preconditioner with non-unit scale S[i]=1/sqrt(h[i])
// then B1 is worse than G1, B2 is worse than G2.
// "Worse" means more iterations to converge.
//
// Test problem setup:
// * f(x) = sum( ((i*i+1)*x[i])^2, i=0..N-1)
// * constraints:
//   0) absent
//   1) box
//
// N        - problem size
// K        - number of repeated passes (should be large enough to average out random factors)
   k = 100;
   epsg = 1.0E-8;
   for (n = 10; n <= 10; n++) {
      for (ckind = 0; ckind <= 1; ckind++) {
         fk = 1;
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&units, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = 0.0;
            units.xR[i] = 1.0;
         }
         minbccreate(n, &x, &state);
         minbcsetcond(&state, epsg, 0.0, 0.0, 0);
         if (ckind == 1) {
            ae_vector_set_length(&bl, n);
            ae_vector_set_length(&bu, n);
            for (i = 0; i < n; i++) {
               bl.xR[i] = -1.0;
               bu.xR[i] = 1.0;
            }
            minbcsetbc(&state, &bl, &bu);
         }
      // Test it with default preconditioner VS. perturbed diagonal preconditioner
         minbcsetprecdefault(&state);
         minbcsetscale(&state, &units);
         cntb1 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            minbcrestartfrom(&state, &x);
            while (minbciteration(&state)) {
               testminbcunit_calciip2(&state, n, fk);
            }
            minbcresults(&state, &x, &rep);
            cntb1 += rep.iterationscount;
            *err = *err || rep.terminationtype <= 0;
         }
         ae_vector_set_length(&diagh, n);
         for (i = 0; i < n; i++) {
            diagh.xR[i] = 2 * pow((double)(i * i + 1), (double)(2 * fk)) * (0.8 + 0.4 * randomreal());
         }
         minbcsetprecdiag(&state, &diagh);
         minbcsetscale(&state, &units);
         cntg1 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            minbcrestartfrom(&state, &x);
            while (minbciteration(&state)) {
               testminbcunit_calciip2(&state, n, fk);
            }
            minbcresults(&state, &x, &rep);
            cntg1 += rep.iterationscount;
            *err = *err || rep.terminationtype <= 0;
         }
         *err = *err || cntb1 < cntg1;
      // Test it with scale-based preconditioner
         ae_vector_set_length(&s, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = 1 / sqrt(2 * pow((double)(i * i + 1), (double)(2 * fk)) * (0.8 + 0.4 * randomreal()));
         }
         minbcsetprecdefault(&state);
         minbcsetscale(&state, &s);
         cntb2 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            minbcrestartfrom(&state, &x);
            while (minbciteration(&state)) {
               testminbcunit_calciip2(&state, n, fk);
            }
            minbcresults(&state, &x, &rep);
            cntb2 += rep.iterationscount;
            *err = *err || rep.terminationtype <= 0;
         }
         minbcsetprecscale(&state);
         minbcsetscale(&state, &s);
         cntg2 = 0;
         for (pass = 0; pass < k; pass++) {
            for (i = 0; i < n; i++) {
               x.xR[i] = randommid();
            }
            minbcrestartfrom(&state, &x);
            while (minbciteration(&state)) {
               testminbcunit_calciip2(&state, n, fk);
            }
            minbcresults(&state, &x, &rep);
            cntg2 += rep.iterationscount;
            *err = *err || rep.terminationtype <= 0;
         }
         *err = *err || cntb2 < cntg2;
      }
   }
   ae_frame_leave();
}

// This function tests report of "non-C1" test #0 for task #0
// given by matrix A.
//
// On failure sets error flag.
static void testminbcunit_testoptguardc1test0reportfortask0(bool *err, optguardnonc1test0report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool hasc1discontinuities;
   if (rep->positive) {
   // Check positive report, first checks
      set_error_flag(err, rep->fidx != 0, __FILE__, __LINE__, "testminbcunit.ap:1858");
      set_error_flag(err, rep->n != n, __FILE__, __LINE__, "testminbcunit.ap:1859");
      set_error_flag(err, !(0 <= rep->stpidxa), __FILE__, __LINE__, "testminbcunit.ap:1860");
      set_error_flag(err, !(rep->stpidxa < rep->stpidxb), __FILE__, __LINE__, "testminbcunit.ap:1861");
      set_error_flag(err, !(rep->stpidxb < rep->cnt), __FILE__, __LINE__, "testminbcunit.ap:1862");
      set_error_flag(err, rep->x0.cnt != rep->n, __FILE__, __LINE__, "testminbcunit.ap:1863");
      set_error_flag(err, rep->d.cnt != rep->n, __FILE__, __LINE__, "testminbcunit.ap:1864");
      set_error_flag(err, rep->stp.cnt != rep->cnt, __FILE__, __LINE__, "testminbcunit.ap:1865");
      set_error_flag(err, rep->f.cnt != rep->cnt, __FILE__, __LINE__, "testminbcunit.ap:1866");
      set_error_flag(err, !isfinitevector(&rep->x0, n), __FILE__, __LINE__, "testminbcunit.ap:1867");
      set_error_flag(err, !isfinitevector(&rep->d, n), __FILE__, __LINE__, "testminbcunit.ap:1868");
      set_error_flag(err, !isfinitevector(&rep->stp, rep->cnt), __FILE__, __LINE__, "testminbcunit.ap:1869");
      set_error_flag(err, !isfinitevector(&rep->f, rep->cnt), __FILE__, __LINE__, "testminbcunit.ap:1870");
      if (*err) {
         return;
      }
   // Check consistency of X0, D, Stp and F
      for (k = 0; k < rep->cnt - 1; k++) {
         set_error_flag(err, rep->stp.xR[k] >= rep->stp.xR[k + 1], __FILE__, __LINE__, "testminbcunit.ap:1878");
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += fabs(vv);
         }
         set_error_flag(err, fabs(v - rep->f.xR[k]) > 1.0E-6 * rmax2(fabs(v), 1.0), __FILE__, __LINE__, "testminbcunit.ap:1891");
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      set_error_flag(err, !hasc1discontinuities, __FILE__, __LINE__, "testminbcunit.ap:1909");
   } else {
   // Check negative report: fields must be empty
      set_error_flag(err, rep->stpidxa != -1, __FILE__, __LINE__, "testminbcunit.ap:1916");
      set_error_flag(err, rep->stpidxb != -1, __FILE__, __LINE__, "testminbcunit.ap:1917");
      set_error_flag(err, rep->fidx != -1, __FILE__, __LINE__, "testminbcunit.ap:1918");
      set_error_flag(err, rep->cnt != 0, __FILE__, __LINE__, "testminbcunit.ap:1919");
      set_error_flag(err, rep->n != 0, __FILE__, __LINE__, "testminbcunit.ap:1920");
      set_error_flag(err, rep->x0.cnt != 0, __FILE__, __LINE__, "testminbcunit.ap:1921");
      set_error_flag(err, rep->d.cnt != 0, __FILE__, __LINE__, "testminbcunit.ap:1922");
      set_error_flag(err, rep->stp.cnt != 0, __FILE__, __LINE__, "testminbcunit.ap:1923");
      set_error_flag(err, rep->f.cnt != 0, __FILE__, __LINE__, "testminbcunit.ap:1924");
   }
}

// This function tests report of "non-C1" test #1 for task #0
// given by matrix A.
//
// On failure sets error flag.
static void testminbcunit_testoptguardc1test1reportfortask0(bool *err, optguardnonc1test1report *rep, RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double va;
   double vb;
   bool tooclose;
   bool hasc1discontinuities;
   if (rep->positive) {
   // Check positive report, first checks
      set_error_flag(err, rep->fidx != 0, __FILE__, __LINE__, "testminbcunit.ap:1952");
      set_error_flag(err, rep->vidx < 0, __FILE__, __LINE__, "testminbcunit.ap:1953");
      set_error_flag(err, rep->vidx > n, __FILE__, __LINE__, "testminbcunit.ap:1954");
      set_error_flag(err, rep->n != n, __FILE__, __LINE__, "testminbcunit.ap:1955");
      set_error_flag(err, !(0 <= rep->stpidxa), __FILE__, __LINE__, "testminbcunit.ap:1956");
      set_error_flag(err, !(rep->stpidxa < rep->stpidxb), __FILE__, __LINE__, "testminbcunit.ap:1957");
      set_error_flag(err, !(rep->stpidxb < rep->cnt), __FILE__, __LINE__, "testminbcunit.ap:1958");
      set_error_flag(err, rep->x0.cnt != rep->n, __FILE__, __LINE__, "testminbcunit.ap:1959");
      set_error_flag(err, rep->d.cnt != rep->n, __FILE__, __LINE__, "testminbcunit.ap:1960");
      set_error_flag(err, rep->stp.cnt != rep->cnt, __FILE__, __LINE__, "testminbcunit.ap:1961");
      set_error_flag(err, rep->g.cnt != rep->cnt, __FILE__, __LINE__, "testminbcunit.ap:1962");
      set_error_flag(err, !isfinitevector(&rep->x0, n), __FILE__, __LINE__, "testminbcunit.ap:1963");
      set_error_flag(err, !isfinitevector(&rep->d, n), __FILE__, __LINE__, "testminbcunit.ap:1964");
      set_error_flag(err, !isfinitevector(&rep->stp, rep->cnt), __FILE__, __LINE__, "testminbcunit.ap:1965");
      set_error_flag(err, !isfinitevector(&rep->g, rep->cnt), __FILE__, __LINE__, "testminbcunit.ap:1966");
      if (*err) {
         return;
      }
   // Check consistency of X0, D, Stp and G
      for (k = 0; k < rep->cnt - 1; k++) {
         set_error_flag(err, rep->stp.xR[k] >= rep->stp.xR[k + 1], __FILE__, __LINE__, "testminbcunit.ap:1974");
      }
      for (k = 0; k < rep->cnt; k++) {
         v = 0.0;
         tooclose = false;
         for (i = 0; i < n; i++) {
            vv = 0.0;
            for (j = 0; j < n; j++) {
               vv += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[k]);
            }
            v += sign(vv) * a->xyR[i][rep->vidx];
            tooclose = tooclose || fabs(vv) < 1.0E-4;
         }
         if (!tooclose) {
            set_error_flag(err, fabs(v - rep->g.xR[k]) > 1.0E-6 * rmax2(fabs(v), 1.0), __FILE__, __LINE__, "testminbcunit.ap:1988");
         }
      }
   // Check that interval [#StpIdxA,#StpIdxB] contains at least one discontinuity
      tooclose = false;
      hasc1discontinuities = false;
      for (i = 0; i < n; i++) {
         va = 0.0;
         vb = 0.0;
         for (j = 0; j < n; j++) {
            va += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxa]);
            vb += a->xyR[i][j] * (rep->x0.xR[j] + rep->d.xR[j] * rep->stp.xR[rep->stpidxb]);
         }
         tooclose = (tooclose || fabs(va) < 1.0E-8) || fabs(vb) < 1.0E-8;
         hasc1discontinuities = hasc1discontinuities || sign(va) != sign(vb);
      }
      if (!tooclose) {
         set_error_flag(err, !hasc1discontinuities, __FILE__, __LINE__, "testminbcunit.ap:2009");
      }
   } else {
   // Check negative report: fields must be empty
      set_error_flag(err, rep->stpidxa != -1, __FILE__, __LINE__, "testminbcunit.ap:2016");
      set_error_flag(err, rep->stpidxb != -1, __FILE__, __LINE__, "testminbcunit.ap:2017");
      set_error_flag(err, rep->fidx != -1, __FILE__, __LINE__, "testminbcunit.ap:2018");
      set_error_flag(err, rep->vidx != -1, __FILE__, __LINE__, "testminbcunit.ap:2019");
      set_error_flag(err, rep->cnt != 0, __FILE__, __LINE__, "testminbcunit.ap:2020");
      set_error_flag(err, rep->n != 0, __FILE__, __LINE__, "testminbcunit.ap:2021");
      set_error_flag(err, rep->x0.cnt != 0, __FILE__, __LINE__, "testminbcunit.ap:2022");
      set_error_flag(err, rep->d.cnt != 0, __FILE__, __LINE__, "testminbcunit.ap:2023");
      set_error_flag(err, rep->stp.cnt != 0, __FILE__, __LINE__, "testminbcunit.ap:2024");
      set_error_flag(err, rep->g.cnt != 0, __FILE__, __LINE__, "testminbcunit.ap:2025");
   }
}

// This function tests OptGuard
//
// On failure sets error flag.
static void testminbcunit_testoptguard(bool *wereerrors) {
   ae_frame _frame_block;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   double diffstep;
   ae_int_t pass;
   ae_int_t defecttype;
   bool failed;
   ae_int_t passcount;
   ae_int_t maxfails;
   ae_int_t failurecounter;
   ae_int_t maxc1test0fails;
   ae_int_t maxc1test1fails;
   ae_int_t c1test0fails;
   ae_int_t c1test1fails;
   double avgstr0len;
   double avglng0len;
   double avgstr1len;
   double avglng1len;
   ae_int_t varidx;
   ae_int_t skind;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewObj(minbcstate, state);
   NewObj(minbcreport, rep);
   NewObj(optguardreport, ogrep);
   NewObj(optguardnonc1test0report, ognonc1test0strrep);
   NewObj(optguardnonc1test0report, ognonc1test0lngrep);
   NewObj(optguardnonc1test1report, ognonc1test1strrep);
   NewObj(optguardnonc1test1report, ognonc1test1lngrep);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a1, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(b, 0, DT_REAL);
   NewVector(bndl, 0, DT_REAL);
   NewVector(bndu, 0, DT_REAL);
   NewMatrix(jactrue, 0, 0, DT_REAL);
   NewMatrix(jacdefect, 0, 0, DT_REAL);
   hqrndrandomize(&rs);
// Check that gradient verification is disabled by default:
// gradient checking for bad problem must return nothing
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = 1.0 + 0.1 * i;
   }
   spdmatrixrndcond(n, 1.0E3, &a);
   spdmatrixrndcond(n, 1.0E3, &a1);
   minbccreate(n, &x0, &state);
   minbcsetcond(&state, 0.0, 0.0, 1.0E-9, 10);
   while (minbciteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += 0.5 * state.x.xR[i] * v;
         }
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   minbcresults(&state, &x1, &rep);
   minbcoptguardresults(&state, &ogrep);
   set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbcunit.ap:1321");
   set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminbcunit.ap:1322");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(wereerrors, ogrep.badgradxbase.cnt != 0, __FILE__, __LINE__, "testminbcunit.ap:1325");
   set_error_flag(wereerrors, ogrep.badgraduser.rows != 0, __FILE__, __LINE__, "testminbcunit.ap:1326");
   set_error_flag(wereerrors, ogrep.badgraduser.cols != 0, __FILE__, __LINE__, "testminbcunit.ap:1327");
   set_error_flag(wereerrors, ogrep.badgradnum.rows != 0, __FILE__, __LINE__, "testminbcunit.ap:1328");
   set_error_flag(wereerrors, ogrep.badgradnum.cols != 0, __FILE__, __LINE__, "testminbcunit.ap:1329");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(wereerrors, ogrep.badgradsuspected, __FILE__, __LINE__, "testminbcunit.ap:1332");
   set_error_flag(wereerrors, ogrep.badgradfidx != -1, __FILE__, __LINE__, "testminbcunit.ap:1333");
   set_error_flag(wereerrors, ogrep.badgradvidx != -1, __FILE__, __LINE__, "testminbcunit.ap:1334");
// Test that C0/C1 continuity monitoring is disabled by default;
// we solve nonsmooth problem and test that nothing is returned
// by OptGuard.
   n = 10;
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      x0.xR[i] = hqrndnormal(&rs);
   }
   ae_matrix_set_length(&a, n, n);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a.xyR[i][j] = hqrndnormal(&rs);
      }
   }
   minbccreate(n, &x0, &state);
   minbcsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
   while (minbciteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.g.xR[i] = 0.0;
         }
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += state.x.xR[j] * a.xyR[i][j];
            }
            state.f += fabs(v);
            v = (double)sign(v);
            for (j = 0; j < n; j++) {
               state.g.xR[j] += v * a.xyR[i][j];
            }
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   minbcresults(&state, &x1, &rep);
   minbcoptguardresults(&state, &ogrep);
   set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminbcunit.ap:1374");
   set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbcunit.ap:1375");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testminbcunit.ap:1378");
   set_error_flag(wereerrors, ogrep.nonc1suspected, __FILE__, __LINE__, "testminbcunit.ap:1379");
   set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminbcunit.ap:1380");
   set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testminbcunit.ap:1381");
   set_error_flag(wereerrors, ogrep.nonc1fidx >= 0, __FILE__, __LINE__, "testminbcunit.ap:1382");
   set_error_flag(wereerrors, ogrep.nonc1test0positive, __FILE__, __LINE__, "testminbcunit.ap:1383");
   set_error_flag(wereerrors, ogrep.nonc1test1positive, __FILE__, __LINE__, "testminbcunit.ap:1384");
// Test gradient checking functionality, try various
// defect types:
// * accidental zeroing of some gradient component
// * accidental addition of 1.0 to some component
// * accidental multiplication by 2.0
// Try distorting both target and constraints.
   diffstep = 0.001;
   n = 10;
   for (skind = 0; skind <= 1; skind++) {
      for (defecttype = -1; defecttype <= 2; defecttype++) {
         varidx = hqrnduniformi(&rs, n);
         ae_vector_set_length(&x0, n);
         ae_vector_set_length(&s, n);
         ae_vector_set_length(&bndl, n);
         ae_vector_set_length(&bndu, n);
         for (i = 0; i < n; i++) {
            s.xR[i] = pow(10.0, skind * (30 * hqrnduniformr(&rs) - 15));
            x0.xR[i] = (1.0 + 0.1 * i) * s.xR[i];
            j = hqrnduniformi(&rs, 3);
            bndl.xR[i] = -100 * s.xR[i];
            bndu.xR[i] = 100 * s.xR[i];
            if (j == 1) {
               bndl.xR[i] = x0.xR[i];
            }
            if (j == 2) {
               bndu.xR[i] = x0.xR[i];
            }
         }
         spdmatrixrndcond(n, 1.0E3, &a);
         spdmatrixrndcond(n, 1.0E3, &a1);
         minbccreate(n, &x0, &state);
         minbcoptguardgradient(&state, diffstep);
         minbcsetcond(&state, 0.0, 0.0, 1.0E-9, 10);
         minbcsetscale(&state, &s);
         minbcsetbc(&state, &bndl, &bndu);
         while (minbciteration(&state)) {
            if (state.needfg) {
               for (i = 0; i < n; i++) {
                  set_error_flag(wereerrors, state.x.xR[i] < bndl.xR[i], __FILE__, __LINE__, "testminbcunit.ap:1432");
                  set_error_flag(wereerrors, state.x.xR[i] > bndu.xR[i], __FILE__, __LINE__, "testminbcunit.ap:1433");
               }
               state.f = 0.0;
               for (i = 0; i < n; i++) {
                  v = 0.0;
                  for (j = 0; j < n; j++) {
                     v += state.x.xR[j] / s.xR[j] * a.xyR[i][j];
                  }
                  state.f += 0.5 * (state.x.xR[i] / s.xR[i]) * v;
                  state.g.xR[i] = v;
               }
               if (defecttype == 0) {
                  state.g.xR[varidx] = 0.0;
               }
               if (defecttype == 1) {
                  state.g.xR[varidx]++;
               }
               if (defecttype == 2) {
                  state.g.xR[varidx] *= 2;
               }
               for (i = 0; i < n; i++) {
                  state.g.xR[i] /= s.xR[i];
               }
               continue;
            }
            ae_assert(false, "Assertion failed");
         }
         minbcresults(&state, &x1, &rep);
         minbcoptguardresults(&state, &ogrep);
      // Check that something is returned
         set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbcunit.ap:1466");
         set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminbcunit.ap:1467");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
      // Compute reference values for true and spoiled Jacobian at X0
         set_error_flag(wereerrors, !isfinitevector(&ogrep.badgradxbase, n), __FILE__, __LINE__, "testminbcunit.ap:1474");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         ae_matrix_set_length(&jactrue, 1, n);
         ae_matrix_set_length(&jacdefect, 1, n);
         for (i = 0; i < n; i++) {
            v = 0.0;
            for (j = 0; j < n; j++) {
               v += ogrep.badgradxbase.xR[j] / s.xR[j] * a.xyR[i][j];
            }
            jactrue.xyR[0][i] = v;
            jacdefect.xyR[0][i] = v;
         }
         if (defecttype == 0) {
            jacdefect.xyR[0][varidx] = 0.0;
         }
         if (defecttype == 1) {
            jacdefect.xyR[0][varidx]++;
         }
         if (defecttype == 2) {
            jacdefect.xyR[0][varidx] *= 2;
         }
         for (i = 0; i < n; i++) {
            jactrue.xyR[0][i] /= s.xR[i];
            jacdefect.xyR[0][i] /= s.xR[i];
         }
      // Check OptGuard report
         set_error_flag(wereerrors, !apservisfinitematrix(&ogrep.badgraduser, 1, n), __FILE__, __LINE__, "testminbcunit.ap:1502");
         set_error_flag(wereerrors, !apservisfinitematrix(&ogrep.badgradnum, 1, n), __FILE__, __LINE__, "testminbcunit.ap:1503");
         if (*wereerrors) {
            ae_frame_leave();
            return;
         }
         if (defecttype >= 0) {
            set_error_flag(wereerrors, !ogrep.badgradsuspected, __FILE__, __LINE__, "testminbcunit.ap:1508");
            set_error_flag(wereerrors, ogrep.badgradfidx != 0, __FILE__, __LINE__, "testminbcunit.ap:1509");
            set_error_flag(wereerrors, ogrep.badgradvidx != varidx, __FILE__, __LINE__, "testminbcunit.ap:1510");
         } else {
            set_error_flag(wereerrors, ogrep.badgradsuspected, __FILE__, __LINE__, "testminbcunit.ap:1514");
            set_error_flag(wereerrors, ogrep.badgradfidx != -1, __FILE__, __LINE__, "testminbcunit.ap:1515");
            set_error_flag(wereerrors, ogrep.badgradvidx != -1, __FILE__, __LINE__, "testminbcunit.ap:1516");
         }
         for (j = 0; j < n; j++) {
            set_error_flag(wereerrors, fabs(jactrue.xyR[0][j] - ogrep.badgradnum.xyR[0][j]) > 0.01 / s.xR[j], __FILE__, __LINE__, "testminbcunit.ap:1520");
            set_error_flag(wereerrors, fabs(jacdefect.xyR[0][j] - ogrep.badgraduser.xyR[0][j]) > 0.01 / s.xR[j], __FILE__, __LINE__, "testminbcunit.ap:1521");
         }
      }
   }
// A test for detection of C1 continuity violations in the target.
//
// Target function is a sum of |(x,c_i)| for i=1..N.
// No constraints is present.
// Analytic gradient is provided.
//
// OptGuard should be able to detect violations in more than
// 99.9% of runs; it means that 100 runs should have no more than 4
// failures in all cases (even after multiple repeated tests; according
// to the binomial distribution quantiles).
//
// We select some N and perform exhaustive search for this N.
   passcount = 100;
   maxfails = 4;
   maxc1test0fails = 10;
   maxc1test1fails = 10;
   n = 1 + hqrnduniformi(&rs, 10);
   failurecounter = 0;
   c1test0fails = 0;
   c1test1fails = 0;
   avgstr0len = 0.0;
   avglng0len = 0.0;
   avgstr1len = 0.0;
   avglng1len = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = pow(2.0, hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      minbccreate(n, &x0, &state);
      minbcsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      minbcsetscale(&state, &s);
      minbcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminbcunit_maxoptguardlevel));
      while (minbciteration(&state)) {
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.g.xR[i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
               v = (double)sign(v);
               for (j = 0; j < n; j++) {
                  state.g.xR[j] += v * a.xyR[i][j];
               }
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minbcresults(&state, &x1, &rep);
      minbcoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminbcunit.ap:1602");
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbcunit.ap:1603");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
   // Check generic OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testminbcunit.ap:1614");
      set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testminbcunit.ap:1615");
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   // Check C1 continuity test #0
      minbcoptguardnonc1test0results(&state, &ognonc1test0strrep, &ognonc1test0lngrep);
      minbcoptguardnonc1test1results(&state, &ognonc1test1strrep, &ognonc1test1lngrep);
      if (ogrep.nonc1test0positive) {
         set_error_flag(wereerrors, !ogrep.nonc1suspected, __FILE__, __LINE__, "testminbcunit.ap:1630");
         set_error_flag(wereerrors, !ognonc1test0strrep.positive, __FILE__, __LINE__, "testminbcunit.ap:1631");
         set_error_flag(wereerrors, !ognonc1test0lngrep.positive, __FILE__, __LINE__, "testminbcunit.ap:1632");
         set_error_flag(wereerrors, ogrep.nonc1fidx != 0, __FILE__, __LINE__, "testminbcunit.ap:1633");
         testminbcunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0strrep, &a, n);
         testminbcunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0lngrep, &a, n);
         avgstr0len += (double)ognonc1test0strrep.cnt / passcount;
         avglng0len += (double)ognonc1test0lngrep.cnt / passcount;
      } else {
         set_error_flag(wereerrors, ognonc1test0strrep.positive, __FILE__, __LINE__, "testminbcunit.ap:1641");
         set_error_flag(wereerrors, ognonc1test0lngrep.positive, __FILE__, __LINE__, "testminbcunit.ap:1642");
         testminbcunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0strrep, &a, n);
         testminbcunit_testoptguardc1test0reportfortask0(wereerrors, &ognonc1test0lngrep, &a, n);
         c1test0fails++;
      }
      if (ogrep.nonc1test1positive) {
         set_error_flag(wereerrors, !ogrep.nonc1suspected, __FILE__, __LINE__, "testminbcunit.ap:1649");
         set_error_flag(wereerrors, !ognonc1test1strrep.positive, __FILE__, __LINE__, "testminbcunit.ap:1650");
         set_error_flag(wereerrors, !ognonc1test1lngrep.positive, __FILE__, __LINE__, "testminbcunit.ap:1651");
         set_error_flag(wereerrors, ogrep.nonc1fidx != 0, __FILE__, __LINE__, "testminbcunit.ap:1652");
         testminbcunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1strrep, &a, n);
         testminbcunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1lngrep, &a, n);
         avgstr1len += (double)ognonc1test1strrep.cnt / passcount;
         avglng1len += (double)ognonc1test1lngrep.cnt / passcount;
      } else {
         set_error_flag(wereerrors, ognonc1test1strrep.positive, __FILE__, __LINE__, "testminbcunit.ap:1660");
         set_error_flag(wereerrors, ognonc1test1lngrep.positive, __FILE__, __LINE__, "testminbcunit.ap:1661");
         testminbcunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1strrep, &a, n);
         testminbcunit_testoptguardc1test1reportfortask0(wereerrors, &ognonc1test1lngrep, &a, n);
         c1test1fails++;
      }
   }
   set_error_flag(wereerrors, failurecounter > maxfails, __FILE__, __LINE__, "testminbcunit.ap:1668");
   set_error_flag(wereerrors, c1test0fails > maxc1test0fails, __FILE__, __LINE__, "testminbcunit.ap:1669");
   set_error_flag(wereerrors, c1test1fails > maxc1test1fails, __FILE__, __LINE__, "testminbcunit.ap:1670");
   set_error_flag(wereerrors, avglng0len <= avgstr0len, __FILE__, __LINE__, "testminbcunit.ap:1671");
   set_error_flag(wereerrors, avglng1len <= avgstr1len, __FILE__, __LINE__, "testminbcunit.ap:1672");
// Detection of C1 continuity violations in the target under numerical differentiation:
// * target function is a sum of |(x,c_i)| for i=1..N.
// * no constraints is present.
// * analytic gradient is provided.
//
// OptGuard should always be able to detect violations in more than
// 99% of runs (note: reduced strength when compared with analytic gradient);
// it means that 100 runs should have no more than 10 failures in all cases
// (even after multiple repeated tests; according to the binomial distribution
// quantiles).
//
// We select some N and perform exhaustive search for this N.
   diffstep = 0.0001;
   passcount = 100;
   maxfails = 10;
   n = 1 + hqrnduniformi(&rs, 10);
   failurecounter = 0;
   for (pass = 1; pass <= passcount; pass++) {
   // Formulate problem
      ae_vector_set_length(&x0, n);
      for (i = 0; i < n; i++) {
         x0.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&s, n);
      for (i = 0; i < n; i++) {
         s.xR[i] = 0.01 * pow(2.0, 0.33 * hqrndnormal(&rs));
      }
      ae_matrix_set_length(&a, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Create and try to solve
      minbccreatef(n, &x0, diffstep, &state);
      minbcsetcond(&state, 0.0, 0.0, 1.0E-9, 50);
      minbcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminbcunit_maxoptguardlevel));
      while (minbciteration(&state)) {
         if (state.needf) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               v = 0.0;
               for (j = 0; j < n; j++) {
                  v += state.x.xR[j] * a.xyR[i][j];
               }
               state.f += fabs(v);
            }
            continue;
         }
         ae_assert(false, "Assertion failed");
      }
      minbcresults(&state, &x1, &rep);
      minbcoptguardresults(&state, &ogrep);
   // Check basic properties of the solution
      set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminbcunit.ap:1738");
      set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbcunit.ap:1739");
      if (*wereerrors) {
         ae_frame_leave();
         return;
      }
   // Check OptGuard report: distinguish between "hard"
   // failures which result in immediate termination
   // (C0 violation being reported) and "soft" ones
   // (C1 violation is NOT reported) which accumulate
   // until we exhaust limit.
      set_error_flag(wereerrors, ogrep.nonc0suspected, __FILE__, __LINE__, "testminbcunit.ap:1750");
      set_error_flag(wereerrors, ogrep.nonc0fidx >= 0, __FILE__, __LINE__, "testminbcunit.ap:1751");
      failed = false;
      failed = failed || optguardallclear(&ogrep);
      failed = failed || !ogrep.nonc1suspected;
      failed = failed || ogrep.nonc1fidx != 0;
      if (failed) {
         failurecounter++;
      }
   }
   set_error_flag(wereerrors, failurecounter > maxfails, __FILE__, __LINE__, "testminbcunit.ap:1759");
// Make sure than no false positives are reported for larger
// problems where numerical noise can be an issue:
// * N=100 dimensions
// * positive-definite quadratic programming problem
// * upper limit on iterations count, MaxIts=25
// We simply test that OptGuard does not return error code.
   n = 100;
   spdmatrixrndcond(n, 1.0E2, &a);
   ae_vector_set_length(&b, n);
   ae_vector_set_length(&x0, n);
   for (i = 0; i < n; i++) {
      b.xR[i] = hqrndnormal(&rs);
      x0.xR[i] = pow(2.0, hqrndnormal(&rs));
   }
   minbccreate(n, &x0, &state);
   minbcoptguardsmoothness(&state, 1 + hqrnduniformi(&rs, testminbcunit_maxoptguardlevel));
   minbcsetcond(&state, 0.0, 0.0, 1.0E-9, 25);
   while (minbciteration(&state)) {
      if (state.needfg) {
         state.f = 0.0;
         for (i = 0; i < n; i++) {
            state.f += b.xR[i] * state.x.xR[i];
            state.g.xR[i] = b.xR[i];
            for (j = 0; j < n; j++) {
               state.f += 0.5 * state.x.xR[i] * a.xyR[i][j] * state.x.xR[j];
               state.g.xR[i] += a.xyR[i][j] * state.x.xR[j];
            }
         }
         continue;
      }
      ae_assert(false, "Assertion failed");
   }
   minbcresults(&state, &x1, &rep);
   set_error_flag(wereerrors, !isfinitevector(&x1, n), __FILE__, __LINE__, "testminbcunit.ap:1802");
   set_error_flag(wereerrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testminbcunit.ap:1803");
   if (*wereerrors) {
      ae_frame_leave();
      return;
   }
   minbcoptguardresults(&state, &ogrep);
   set_error_flag(wereerrors, !optguardallclear(&ogrep), __FILE__, __LINE__, "testminbcunit.ap:1807");
   ae_frame_leave();
}

bool testminbc(bool silent) {
   bool waserrors;
   bool feasibilityerrors;
   bool othererrors;
   bool precerrors;
   bool interrors;
   bool converrors;
   bool optguarderrors;
   bool result;
   waserrors = false;
   feasibilityerrors = false;
   othererrors = false;
   precerrors = false;
   interrors = false;
   converrors = false;
   optguarderrors = false;
   testminbcunit_testfeasibility(&feasibilityerrors, &converrors, &interrors);
   testminbcunit_testother(&othererrors);
   testminbcunit_testpreconditioning(&precerrors);
   testminbcunit_testoptguard(&optguarderrors);
// end
   waserrors = ((((feasibilityerrors || othererrors) || converrors) || interrors) || precerrors) || optguarderrors;
   if (!silent) {
      printf("TESTING BC OPTIMIZATION\n");
      printf("FEASIBILITY PROPERTIES:                   ");
      if (feasibilityerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("PRECONDITIONING:                          ");
      if (precerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("OTHER PROPERTIES:                         ");
      if (othererrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("CONVERGENCE PROPERTIES:                   ");
      if (converrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("INTERNAL ERRORS:                          ");
      if (interrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("OPTGUARD:                                 ");
      if (optguarderrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === nearestneighbor testing unit ===
// Compare results from different queries:
// * X     just X-values
// * XY    X-values and Y-values
// * XT    X-values and tag values
static bool testnearestneighborunit_kdtresultsdifferent(RMatrix *refxy, ae_int_t ntotal, RMatrix *qx, RMatrix *qxy, ZVector *qt, ae_int_t n, ae_int_t nx, ae_int_t ny) {
   ae_int_t i;
   ae_int_t j;
   bool result;
   result = false;
   for (i = 0; i < n; i++) {
      if (qt->xZ[i] < 0 || qt->xZ[i] >= ntotal) {
         result = true;
         return result;
      }
      for (j = 0; j < nx; j++) {
         result = result || qx->xyR[i][j] != refxy->xyR[qt->xZ[i]][j];
         result = result || qxy->xyR[i][j] != refxy->xyR[qt->xZ[i]][j];
      }
      for (j = 0; j < ny; j++) {
         result = result || qxy->xyR[i][nx + j] != refxy->xyR[qt->xZ[i]][nx + j];
      }
   }
   return result;
}

// Returns norm
static double testnearestneighborunit_vnorm(RVector *x, ae_int_t n, ae_int_t normtype) {
   ae_int_t i;
   double result;
   result = randomreal();
   if (normtype == 0) {
      result = 0.0;
      for (i = 0; i < n; i++) {
         result = rmax2(result, fabs(x->xR[i]));
      }
      return result;
   }
   if (normtype == 1) {
      result = 0.0;
      for (i = 0; i < n; i++) {
         result += fabs(x->xR[i]);
      }
      return result;
   }
   if (normtype == 2) {
      result = 0.0;
      for (i = 0; i < n; i++) {
         result += sqr(x->xR[i]);
      }
      result = sqrt(result);
      return result;
   }
   return result;
}

// Testing Nearest Neighbor Search on uniformly distributed hypercube
//
// NormType: 0, 1, 2
// D: space dimension
// N: points count
static void testnearestneighborunit_testkdtuniform(RMatrix *xy, ae_int_t n, ae_int_t nx, ae_int_t ny, ae_int_t normtype, bool *kdterrors) {
   ae_frame _frame_block;
   double errtol;
   double spread;
   ae_int_t kx;
   ae_int_t kxy;
   ae_int_t kt;
   double eps;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t task;
   bool isequal;
   double r;
   ae_int_t q;
   ae_int_t qcount;
   double v;
   bool inthebox;
   bool orderedrnn;
   ae_frame_make(&_frame_block);
   NewVector(tags, 0, DT_INT);
   NewVector(ptx, 0, DT_REAL);
   NewVector(tmpx, 0, DT_REAL);
   NewVector(tmpb, 0, DT_BOOL);
   NewObj(kdtree, treex);
   NewObj(kdtree, treexy);
   NewObj(kdtree, treext);
   NewObj(kdtreerequestbuffer, bufx);
   NewObj(kdtreerequestbuffer, bufxy);
   NewObj(kdtreerequestbuffer, bufxt);
   NewMatrix(qx, 0, 0, DT_REAL);
   NewMatrix(qxy, 0, 0, DT_REAL);
   NewVector(qtags, 0, DT_INT);
   NewVector(qr, 0, DT_REAL);
   NewVector(boxmin, 0, DT_REAL);
   NewVector(boxmax, 0, DT_REAL);
   NewVector(qmin, 0, DT_REAL);
   NewVector(qmax, 0, DT_REAL);
   qcount = 10;
   ae_assert(n > 0, "Assertion failed");
// Tol - roundoff error tolerance (for ' >= ' comparisons)
   errtol = 100000 * machineepsilon;
// Evaluate bounding box and spread.
   ae_vector_set_length(&boxmin, nx);
   ae_vector_set_length(&boxmax, nx);
   for (j = 0; j < nx; j++) {
      boxmin.xR[j] = xy->xyR[0][j];
      boxmax.xR[j] = xy->xyR[0][j];
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < nx; j++) {
         boxmin.xR[j] = rmin2(boxmin.xR[j], xy->xyR[i][j]);
         boxmax.xR[j] = rmax2(boxmax.xR[j], xy->xyR[i][j]);
      }
   }
   spread = 0.0;
   for (j = 0; j < nx; j++) {
      spread = rmax2(spread, boxmax.xR[j] - boxmin.xR[j]);
   }
   if (spread == 0.0) {
      spread = 1.0;
   }
// fill tags
   ae_vector_set_length(&tags, n);
   for (i = 0; i < n; i++) {
      tags.xZ[i] = i;
   }
// build trees
   kdtreebuild(xy, n, nx, 0, normtype, &treex);
   kdtreebuild(xy, n, nx, ny, normtype, &treexy);
   kdtreebuildtagged(xy, &tags, n, nx, 0, normtype, &treext);
// allocate arrays
   ae_vector_set_length(&tmpx, nx);
   ae_vector_set_length(&tmpb, n);
   ae_matrix_set_length(&qx, n, nx);
   ae_matrix_set_length(&qxy, n, nx + ny);
   ae_vector_set_length(&qtags, n);
   ae_vector_set_length(&qr, n);
   ae_vector_set_length(&ptx, nx);
// test general K-NN queries (with self-matches):
// * compare results from different trees (must be equal) and
//   check that correct (value,tag) pairs are returned
// * test results from XT tree - let R be radius of query result.
//   then all points not in result must be not closer than R.
   for (q = 1; q <= qcount; q++) {
   // Select K: 1..N
      if (randombool()) {
         k = 1 + randominteger(n);
      } else {
         k = 1;
      }
   // Select point (either one of the points, or random)
      if (randombool()) {
         i = randominteger(n);
         ae_v_move(ptx.xR, 1, xy->xyR[i], 1, nx);
      } else {
         for (i = 0; i < nx; i++) {
            ptx.xR[i] = randommid();
         }
      }
   // Test functions which use internal buffer:
   // * consistency of results from different queries
   // * points in query are IN the R-sphere (or at the boundary),
   //   and points not in query are outside of the R-sphere (or at the boundary)
   // * distances are correct and are ordered
      kx = kdtreequeryknn(&treex, &ptx, k, true);
      kxy = kdtreequeryknn(&treexy, &ptx, k, true);
      kt = kdtreequeryknn(&treext, &ptx, k, true);
      if ((kx != k || kxy != k) || kt != k) {
         *kdterrors = true;
         ae_frame_leave();
         return;
      }
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreequeryresultsxi(&treex, &qx);
      kdtreequeryresultsxyi(&treexy, &qxy);
      kdtreequeryresultstagsi(&treext, &qtags);
      kdtreequeryresultsdistancesi(&treext, &qr);
      *kdterrors = *kdterrors || testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreequeryresultsx(&treex, &qx);
      kdtreequeryresultsxy(&treexy, &qxy);
      kdtreequeryresultstags(&treext, &qtags);
      kdtreequeryresultsdistances(&treext, &qr);
      *kdterrors = *kdterrors || testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = true;
      }
      r = 0.0;
      for (i = 0; i < k; i++) {
         tmpb.xB[qtags.xZ[i]] = false;
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, qx.xyR[i], 1, nx);
         r = rmax2(r, testnearestneighborunit_vnorm(&tmpx, nx, normtype));
      }
      for (i = 0; i < n; i++) {
         if (tmpb.xB[i]) {
            ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
            ae_v_sub(tmpx.xR, 1, xy->xyR[i], 1, nx);
            *kdterrors = *kdterrors || testnearestneighborunit_vnorm(&tmpx, nx, normtype) < r * (1 - errtol);
         }
      }
      for (i = 0; i < k - 1; i++) {
         *kdterrors = *kdterrors || qr.xR[i] > qr.xR[i + 1];
      }
      for (i = 0; i < k; i++) {
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, xy->xyR[qtags.xZ[i]], 1, nx);
         *kdterrors = *kdterrors || fabs(testnearestneighborunit_vnorm(&tmpx, nx, normtype) - qr.xR[i]) > errtol;
      }
   // Test functions which use external buffer:
   // * create external request buffer, perform buffered request
   // * reset status of internal buffer by performing 1-NN query, it is essential
   //   to test the fact that external buffer is used
   // * check consistency of results from different queries
   // * check that points in query are IN the R-sphere (or at the boundary),
   //   and points not in query are outside of the R-sphere (or at the boundary)
   // * check that distances are correct and are ordered
      kdtreecreaterequestbuffer(&treex, &bufx);
      kdtreecreaterequestbuffer(&treexy, &bufxy);
      kdtreecreaterequestbuffer(&treext, &bufxt);
      kx = kdtreetsqueryknn(&treex, &bufx, &ptx, k, true);
      kxy = kdtreetsqueryknn(&treexy, &bufxy, &ptx, k, true);
      kt = kdtreetsqueryknn(&treext, &bufxt, &ptx, k, true);
      kdtreequeryknn(&treex, &ptx, 1, true);
      kdtreequeryknn(&treexy, &ptx, 1, true);
      kdtreequeryknn(&treext, &ptx, 1, true);
      if ((kx != k || kxy != k) || kt != k) {
         *kdterrors = true;
         ae_frame_leave();
         return;
      }
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreetsqueryresultsx(&treex, &bufx, &qx);
      kdtreetsqueryresultsxy(&treexy, &bufxy, &qxy);
      kdtreetsqueryresultstags(&treext, &bufxt, &qtags);
      kdtreetsqueryresultsdistances(&treext, &bufxt, &qr);
      *kdterrors = *kdterrors || testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = true;
      }
      r = 0.0;
      for (i = 0; i < k; i++) {
         tmpb.xB[qtags.xZ[i]] = false;
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, qx.xyR[i], 1, nx);
         r = rmax2(r, testnearestneighborunit_vnorm(&tmpx, nx, normtype));
      }
      for (i = 0; i < n; i++) {
         if (tmpb.xB[i]) {
            ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
            ae_v_sub(tmpx.xR, 1, xy->xyR[i], 1, nx);
            *kdterrors = *kdterrors || testnearestneighborunit_vnorm(&tmpx, nx, normtype) < r * (1 - errtol);
         }
      }
      for (i = 0; i < k - 1; i++) {
         *kdterrors = *kdterrors || qr.xR[i] > qr.xR[i + 1];
      }
      for (i = 0; i < k; i++) {
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, xy->xyR[qtags.xZ[i]], 1, nx);
         *kdterrors = *kdterrors || fabs(testnearestneighborunit_vnorm(&tmpx, nx, normtype) - qr.xR[i]) > errtol;
      }
   // Test reallocation properties: functions must automatically
   // resize array which is too small, but leave unchanged array which is
   // too large.
      if (n >= 2) {
      // First step: array is too small, two elements are required
         k = 2;
         kx = kdtreequeryknn(&treex, &ptx, k, true);
         kxy = kdtreequeryknn(&treexy, &ptx, k, true);
         kt = kdtreequeryknn(&treext, &ptx, k, true);
         if ((kx != k || kxy != k) || kt != k) {
            *kdterrors = true;
            ae_frame_leave();
            return;
         }
         ae_matrix_set_length(&qx, 1, 1);
         ae_matrix_set_length(&qxy, 1, 1);
         ae_vector_set_length(&qtags, 1);
         ae_vector_set_length(&qr, 1);
         kdtreequeryresultsx(&treex, &qx);
         kdtreequeryresultsxy(&treexy, &qxy);
         kdtreequeryresultstags(&treext, &qtags);
         kdtreequeryresultsdistances(&treext, &qr);
         *kdterrors = *kdterrors || testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
      // Second step: array is one row larger than needed, so only first
      // row is overwritten. Test it.
         k = 1;
         kx = kdtreequeryknn(&treex, &ptx, k, true);
         kxy = kdtreequeryknn(&treexy, &ptx, k, true);
         kt = kdtreequeryknn(&treext, &ptx, k, true);
         if ((kx != k || kxy != k) || kt != k) {
            *kdterrors = true;
            ae_frame_leave();
            return;
         }
         for (i = 0; i < nx; i++) {
            qx.xyR[1][i] = NAN;
         }
         for (i = 0; i < nx + ny; i++) {
            qxy.xyR[1][i] = NAN;
         }
         qtags.xZ[1] = 999;
         qr.xR[1] = NAN;
         kdtreequeryresultsx(&treex, &qx);
         kdtreequeryresultsxy(&treexy, &qxy);
         kdtreequeryresultstags(&treext, &qtags);
         kdtreequeryresultsdistances(&treext, &qr);
         *kdterrors = *kdterrors || testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
         for (i = 0; i < nx; i++) {
            *kdterrors = *kdterrors || !isnan(qx.xyR[1][i]);
         }
         for (i = 0; i < nx + ny; i++) {
            *kdterrors = *kdterrors || !isnan(qxy.xyR[1][i]);
         }
         *kdterrors = *kdterrors || !(qtags.xZ[1] == 999);
         *kdterrors = *kdterrors || !isnan(qr.xR[1]);
      }
   // Test reallocation properties: 'interactive' functions must allocate
   // new array on each call.
      if (n >= 2) {
      // On input array is either too small or too large
         for (k = 1; k <= 2; k++) {
            ae_assert(k == 1 || k == 2, "KNN: internal error (unexpected K)!");
            kx = kdtreequeryknn(&treex, &ptx, k, true);
            kxy = kdtreequeryknn(&treexy, &ptx, k, true);
            kt = kdtreequeryknn(&treext, &ptx, k, true);
            if ((kx != k || kxy != k) || kt != k) {
               *kdterrors = true;
               ae_frame_leave();
               return;
            }
            ae_matrix_set_length(&qx, 3 - k, 3 - k);
            ae_matrix_set_length(&qxy, 3 - k, 3 - k);
            ae_vector_set_length(&qtags, 3 - k);
            ae_vector_set_length(&qr, 3 - k);
            kdtreequeryresultsxi(&treex, &qx);
            kdtreequeryresultsxyi(&treexy, &qxy);
            kdtreequeryresultstagsi(&treext, &qtags);
            kdtreequeryresultsdistancesi(&treext, &qr);
            *kdterrors = *kdterrors || testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
            *kdterrors = (*kdterrors || qx.rows != k) || qx.cols != nx;
            *kdterrors = (*kdterrors || qxy.rows != k) || qxy.cols != nx + ny;
            *kdterrors = *kdterrors || qtags.cnt != k;
            *kdterrors = *kdterrors || qr.cnt != k;
         }
      }
   }
// test general approximate K-NN queries (with self-matches):
// * compare results from different trees (must be equal) and
//   check that correct (value,tag) pairs are returned
// * test results from XT tree - let R be radius of query result.
//   then all points not in result must be not closer than R/(1+Eps).
   for (q = 1; q <= qcount; q++) {
   // Select K: 1..N
      if (randombool()) {
         k = 1 + randominteger(n);
      } else {
         k = 1;
      }
   // Select Eps
      eps = 0.5 + randomreal();
   // Select point (either one of the points, or random)
      if (randombool()) {
         i = randominteger(n);
         ae_v_move(ptx.xR, 1, xy->xyR[i], 1, nx);
      } else {
         for (i = 0; i < nx; i++) {
            ptx.xR[i] = randommid();
         }
      }
   // Test functions which use internal buffer:
   // * consistency of results from different queries
   // * points in query are IN the R-sphere (or at the boundary),
   //   and points not in query are outside of the R-sphere (or at the boundary)
   // * distances are correct and are ordered
      kx = kdtreequeryaknn(&treex, &ptx, k, true, eps);
      kxy = kdtreequeryaknn(&treexy, &ptx, k, true, eps);
      kt = kdtreequeryaknn(&treext, &ptx, k, true, eps);
      if ((kx != k || kxy != k) || kt != k) {
         *kdterrors = true;
         ae_frame_leave();
         return;
      }
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreequeryresultsxi(&treex, &qx);
      kdtreequeryresultsxyi(&treexy, &qxy);
      kdtreequeryresultstagsi(&treext, &qtags);
      kdtreequeryresultsdistancesi(&treext, &qr);
      *kdterrors = *kdterrors || testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreequeryresultsx(&treex, &qx);
      kdtreequeryresultsxy(&treexy, &qxy);
      kdtreequeryresultstags(&treext, &qtags);
      kdtreequeryresultsdistances(&treext, &qr);
      *kdterrors = *kdterrors || testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = true;
      }
      r = 0.0;
      for (i = 0; i < k; i++) {
         tmpb.xB[qtags.xZ[i]] = false;
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, qx.xyR[i], 1, nx);
         r = rmax2(r, testnearestneighborunit_vnorm(&tmpx, nx, normtype));
      }
      for (i = 0; i < n; i++) {
         if (tmpb.xB[i]) {
            ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
            ae_v_sub(tmpx.xR, 1, xy->xyR[i], 1, nx);
            *kdterrors = *kdterrors || testnearestneighborunit_vnorm(&tmpx, nx, normtype) < r * (1 - errtol) / (1 + eps);
         }
      }
      for (i = 0; i < k - 1; i++) {
         *kdterrors = *kdterrors || qr.xR[i] > qr.xR[i + 1];
      }
      for (i = 0; i < k; i++) {
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, xy->xyR[qtags.xZ[i]], 1, nx);
         *kdterrors = *kdterrors || fabs(testnearestneighborunit_vnorm(&tmpx, nx, normtype) - qr.xR[i]) > errtol;
      }
   // Test functions which use external buffer:
   // * create external request buffer, perform buffered request
   // * reset status of internal buffer by performing 1-NN query, it is essential
   //   to test the fact that external buffer is used
   // * check consistency of results from different queries
   // * check that points in query are IN the R-sphere (or at the boundary),
   //   and points not in query are outside of the R-sphere (or at the boundary)
   // * check that distances are correct and are ordered
      kdtreecreaterequestbuffer(&treex, &bufx);
      kdtreecreaterequestbuffer(&treexy, &bufxy);
      kdtreecreaterequestbuffer(&treext, &bufxt);
      kx = kdtreetsqueryaknn(&treex, &bufx, &ptx, k, true, eps);
      kxy = kdtreetsqueryaknn(&treexy, &bufxy, &ptx, k, true, eps);
      kt = kdtreetsqueryaknn(&treext, &bufxt, &ptx, k, true, eps);
      kdtreequeryknn(&treex, &ptx, 1, true);
      kdtreequeryknn(&treexy, &ptx, 1, true);
      kdtreequeryknn(&treext, &ptx, 1, true);
      if ((kx != k || kxy != k) || kt != k) {
         *kdterrors = true;
         ae_frame_leave();
         return;
      }
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreetsqueryresultsx(&treex, &bufx, &qx);
      kdtreetsqueryresultsxy(&treexy, &bufxy, &qxy);
      kdtreetsqueryresultstags(&treext, &bufxt, &qtags);
      kdtreetsqueryresultsdistances(&treext, &bufxt, &qr);
      *kdterrors = *kdterrors || testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, k, nx, ny);
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = true;
      }
      r = 0.0;
      for (i = 0; i < k; i++) {
         tmpb.xB[qtags.xZ[i]] = false;
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, qx.xyR[i], 1, nx);
         r = rmax2(r, testnearestneighborunit_vnorm(&tmpx, nx, normtype));
      }
      for (i = 0; i < n; i++) {
         if (tmpb.xB[i]) {
            ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
            ae_v_sub(tmpx.xR, 1, xy->xyR[i], 1, nx);
            *kdterrors = *kdterrors || testnearestneighborunit_vnorm(&tmpx, nx, normtype) < r * (1 - errtol) / (1 + eps);
         }
      }
      for (i = 0; i < k - 1; i++) {
         *kdterrors = *kdterrors || qr.xR[i] > qr.xR[i + 1];
      }
      for (i = 0; i < k; i++) {
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, xy->xyR[qtags.xZ[i]], 1, nx);
         *kdterrors = *kdterrors || fabs(testnearestneighborunit_vnorm(&tmpx, nx, normtype) - qr.xR[i]) > errtol;
      }
   }
// test ordered/unordered R-NN queries  (with self-matches):
// * compare results from different trees (must be equal) and
//   check that correct (value,tag) pairs are returned
// * test results from XT tree - let R be radius of query result.
//   then all points not in result must be not closer than R.
   for (q = 1; q <= qcount; q++) {
   // Use ordering?
      orderedrnn = randombool();
   // Select R
      if (randombool(0.3)) {
         r = machineepsilon;
      } else {
         r = rmax2(randomreal(), machineepsilon);
      }
   // Select point (either one of the points, or random)
      if (randombool()) {
         i = randominteger(n);
         ae_v_move(ptx.xR, 1, xy->xyR[i], 1, nx);
      } else {
         for (i = 0; i < nx; i++) {
            ptx.xR[i] = randommid();
         }
      }
   // Test functions which use internal buffer:
   // * consistency of results from different queries
   // * points in query are IN the R-sphere (or at the boundary),
   //   and points not in query are outside of the R-sphere (or at the boundary)
   // * distances are correct and are ordered
      if (orderedrnn) {
         kx = kdtreequeryrnn(&treex, &ptx, r, true);
         kxy = kdtreequeryrnn(&treexy, &ptx, r, true);
         kt = kdtreequeryrnn(&treext, &ptx, r, true);
      } else {
         kx = kdtreequeryrnnu(&treex, &ptx, r, true);
         kxy = kdtreequeryrnnu(&treexy, &ptx, r, true);
         kt = kdtreequeryrnnu(&treext, &ptx, r, true);
      }
      if (kxy != kx || kt != kx) {
         set_error_flag(kdterrors, true, __FILE__, __LINE__, "testnearestneighborunit.ap:648");
         ae_frame_leave();
         return;
      }
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreequeryresultsxi(&treex, &qx);
      kdtreequeryresultsxyi(&treexy, &qxy);
      kdtreequeryresultstagsi(&treext, &qtags);
      kdtreequeryresultsdistancesi(&treext, &qr);
      set_error_flag(kdterrors, testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, kx, nx, ny), __FILE__, __LINE__, "testnearestneighborunit.ap:659");
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreequeryresultsx(&treex, &qx);
      kdtreequeryresultsxy(&treexy, &qxy);
      kdtreequeryresultstags(&treext, &qtags);
      kdtreequeryresultsdistances(&treext, &qr);
      set_error_flag(kdterrors, testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, kx, nx, ny), __FILE__, __LINE__, "testnearestneighborunit.ap:668");
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = true;
      }
      for (i = 0; i < kx; i++) {
         tmpb.xB[qtags.xZ[i]] = false;
      }
      for (i = 0; i < n; i++) {
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, xy->xyR[i], 1, nx);
         if (tmpb.xB[i]) {
            set_error_flag(kdterrors, testnearestneighborunit_vnorm(&tmpx, nx, normtype) < r * (1 - errtol), __FILE__, __LINE__, "testnearestneighborunit.ap:678");
         } else {
            set_error_flag(kdterrors, testnearestneighborunit_vnorm(&tmpx, nx, normtype) > r * (1 + errtol), __FILE__, __LINE__, "testnearestneighborunit.ap:680");
         }
      }
      if (orderedrnn) {
         for (i = 0; i < kx - 1; i++) {
            set_error_flag(kdterrors, qr.xR[i] > qr.xR[i + 1], __FILE__, __LINE__, "testnearestneighborunit.ap:685");
         }
      }
   // Test functions which use external buffer:
   // * create external request buffer, perform buffered request
   // * reset status of internal buffer by performing 1-NN query, it is essential
   //   to test the fact that external buffer is used
   // * check consistency of results from different queries
   // * check that points in query are IN the R-sphere (or at the boundary),
   //   and points not in query are outside of the R-sphere (or at the boundary)
   // * check that distances are correct and are ordered
      kdtreecreaterequestbuffer(&treex, &bufx);
      kdtreecreaterequestbuffer(&treexy, &bufxy);
      kdtreecreaterequestbuffer(&treext, &bufxt);
      if (orderedrnn) {
         kx = kdtreetsqueryrnn(&treex, &bufx, &ptx, r, true);
         kxy = kdtreetsqueryrnn(&treexy, &bufxy, &ptx, r, true);
         kt = kdtreetsqueryrnn(&treext, &bufxt, &ptx, r, true);
      } else {
         kx = kdtreetsqueryrnnu(&treex, &bufx, &ptx, r, true);
         kxy = kdtreetsqueryrnnu(&treexy, &bufxy, &ptx, r, true);
         kt = kdtreetsqueryrnnu(&treext, &bufxt, &ptx, r, true);
      }
      kdtreequeryknn(&treex, &ptx, 1, true);
      kdtreequeryknn(&treexy, &ptx, 1, true);
      kdtreequeryknn(&treext, &ptx, 1, true);
      if (kxy != kx || kt != kx) {
         set_error_flag(kdterrors, true, __FILE__, __LINE__, "testnearestneighborunit.ap:718");
         ae_frame_leave();
         return;
      }
      SetMatrix(&qx);
      SetMatrix(&qxy);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreetsqueryresultsx(&treex, &bufx, &qx);
      kdtreetsqueryresultsxy(&treexy, &bufxy, &qxy);
      kdtreetsqueryresultstags(&treext, &bufxt, &qtags);
      kdtreetsqueryresultsdistances(&treext, &bufxt, &qr);
      set_error_flag(kdterrors, testnearestneighborunit_kdtresultsdifferent(xy, n, &qx, &qxy, &qtags, kx, nx, ny), __FILE__, __LINE__, "testnearestneighborunit.ap:729");
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = true;
      }
      for (i = 0; i < kx; i++) {
         tmpb.xB[qtags.xZ[i]] = false;
      }
      for (i = 0; i < n; i++) {
         ae_v_move(tmpx.xR, 1, ptx.xR, 1, nx);
         ae_v_sub(tmpx.xR, 1, xy->xyR[i], 1, nx);
         if (tmpb.xB[i]) {
            set_error_flag(kdterrors, testnearestneighborunit_vnorm(&tmpx, nx, normtype) < r * (1 - errtol), __FILE__, __LINE__, "testnearestneighborunit.ap:739");
         } else {
            set_error_flag(kdterrors, testnearestneighborunit_vnorm(&tmpx, nx, normtype) > r * (1 + errtol), __FILE__, __LINE__, "testnearestneighborunit.ap:741");
         }
      }
      if (orderedrnn) {
         for (i = 0; i < kx - 1; i++) {
            set_error_flag(kdterrors, qr.xR[i] > qr.xR[i + 1], __FILE__, __LINE__, "testnearestneighborunit.ap:746");
         }
      }
   }
// test box queries
   ae_vector_set_length(&qmin, nx);
   ae_vector_set_length(&qmax, nx);
   for (q = 1; q <= qcount; q++) {
   // Test for box exactly equal to one of the points.
   // More than one exactly equal point may be found.
   // Only thread-safe version is tested.
      kdtreecreaterequestbuffer(&treext, &bufxt);
      k = randominteger(n);
      for (j = 0; j < nx; j++) {
         qmin.xR[j] = xy->xyR[k][j];
         qmax.xR[j] = xy->xyR[k][j];
      }
      kx = kdtreetsquerybox(&treext, &bufxt, &qmin, &qmax);
      if (kx < 1) {
         *kdterrors = true;
         ae_frame_leave();
         return;
      }
      SetMatrix(&qx);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreetsqueryresultsx(&treext, &bufxt, &qx);
      kdtreetsqueryresultstags(&treext, &bufxt, &qtags);
      kdtreetsqueryresultsdistances(&treext, &bufxt, &qr);
      for (i = 0; i < kx; i++) {
         set_error_flag(kdterrors, qr.xR[i] != 0.0, __FILE__, __LINE__, "testnearestneighborunit.ap:783");
      }
      for (i = 0; i < kx; i++) {
         for (j = 0; j < nx; j++) {
            set_error_flag(kdterrors, qx.xyR[i][j] != xy->xyR[k][j], __FILE__, __LINE__, "testnearestneighborunit.ap:788");
            set_error_flag(kdterrors, qx.xyR[i][j] != xy->xyR[qtags.xZ[i]][j], __FILE__, __LINE__, "testnearestneighborunit.ap:789");
         }
      }
   // Test for randomly generated box (thread-safe version)
      for (j = 0; j < nx; j++) {
         qmin.xR[j] = boxmin.xR[j] + randomreal() * (boxmax.xR[j] - boxmin.xR[j]);
         qmax.xR[j] = qmin.xR[j];
         v = spread * pow(10.0, -2 * randomreal());
         qmin.xR[j] -= v;
         qmax.xR[j] += v;
      }
      kx = kdtreetsquerybox(&treext, &bufxt, &qmin, &qmax);
      SetMatrix(&qx);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreetsqueryresultsx(&treext, &bufxt, &qx);
      kdtreetsqueryresultstags(&treext, &bufxt, &qtags);
      kdtreetsqueryresultsdistances(&treext, &bufxt, &qr);
      for (i = 0; i < kx; i++) {
         set_error_flag(kdterrors, qr.xR[i] != 0.0, __FILE__, __LINE__, "testnearestneighborunit.ap:812");
      }
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = false;
      }
      for (i = 0; i < kx; i++) {
         tmpb.xB[qtags.xZ[i]] = true;
      }
      for (i = 0; i < n; i++) {
         inthebox = true;
         for (j = 0; j < nx; j++) {
            inthebox = inthebox && xy->xyR[i][j] >= qmin.xR[j];
            inthebox = inthebox && xy->xyR[i][j] <= qmax.xR[j];
         }
         if (tmpb.xB[i]) {
            set_error_flag(kdterrors, !inthebox, __FILE__, __LINE__, "testnearestneighborunit.ap:826");
         } else {
            set_error_flag(kdterrors, inthebox, __FILE__, __LINE__, "testnearestneighborunit.ap:828");
         }
      }
   // Test for randomly generated box (non-thread-safe version)
      for (j = 0; j < nx; j++) {
         qmin.xR[j] = boxmin.xR[j] + randomreal() * (boxmax.xR[j] - boxmin.xR[j]);
         qmax.xR[j] = qmin.xR[j];
         v = spread * pow(10.0, -2 * randomreal());
         qmin.xR[j] -= v;
         qmax.xR[j] += v;
      }
      kx = kdtreequerybox(&treext, &qmin, &qmax);
      SetMatrix(&qx);
      SetVector(&qtags);
      SetVector(&qr);
      kdtreequeryresultsx(&treext, &qx);
      kdtreequeryresultstags(&treext, &qtags);
      kdtreequeryresultsdistances(&treext, &qr);
      for (i = 0; i < kx; i++) {
         set_error_flag(kdterrors, qr.xR[i] != 0.0, __FILE__, __LINE__, "testnearestneighborunit.ap:850");
      }
      for (i = 0; i < n; i++) {
         tmpb.xB[i] = false;
      }
      for (i = 0; i < kx; i++) {
         tmpb.xB[qtags.xZ[i]] = true;
      }
      for (i = 0; i < n; i++) {
         inthebox = true;
         for (j = 0; j < nx; j++) {
            inthebox = inthebox && xy->xyR[i][j] >= qmin.xR[j];
            inthebox = inthebox && xy->xyR[i][j] <= qmax.xR[j];
         }
         if (tmpb.xB[i]) {
            set_error_flag(kdterrors, !inthebox, __FILE__, __LINE__, "testnearestneighborunit.ap:864");
         } else {
            set_error_flag(kdterrors, inthebox, __FILE__, __LINE__, "testnearestneighborunit.ap:866");
         }
      }
   }
// Test self-matching:
// * self-match - nearest neighbor of each point in XY is the point itself
// * no self-match - nearest neighbor is NOT the point itself
   if (n > 1) {
   // test for N=1 have non-general form, but it is not really needed
      for (task = 0; task <= 1; task++) {
         for (i = 0; i < n; i++) {
            ae_v_move(ptx.xR, 1, xy->xyR[i], 1, nx);
            kx = kdtreequeryknn(&treex, &ptx, 1, task == 0);
            kdtreequeryresultsxi(&treex, &qx);
            if (kx != 1) {
               *kdterrors = true;
               ae_frame_leave();
               return;
            }
            isequal = true;
            for (j = 0; j < nx; j++) {
               isequal = isequal && qx.xyR[0][j] == ptx.xR[j];
            }
            if (task == 0) {
               *kdterrors = *kdterrors || !isequal;
            } else {
               *kdterrors = *kdterrors || isequal;
            }
         }
      }
   }
   ae_frame_leave();
}

// Testing serialization of KD trees
//
// This function sets Err to True on errors, but leaves it unchanged on success
static void testnearestneighborunit_testkdtreeserialization(bool *err) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t normtype;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t q;
   double threshold;
   ae_int_t k0;
   ae_int_t k1;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(tags, 0, DT_INT);
   NewVector(qsizes, 0, DT_INT);
   NewObj(kdtree, tree0);
   NewObj(kdtree, tree1);
   NewMatrix(xy0, 0, 0, DT_REAL);
   NewMatrix(xy1, 0, 0, DT_REAL);
   NewVector(tags0, 0, DT_INT);
   NewVector(tags1, 0, DT_INT);
   threshold = 100 * machineepsilon;
// different N, NX, NY, NormType
   n = 1;
   while (n <= 51) {
   // prepare array with query sizes
      ae_vector_set_length(&qsizes, 4);
      qsizes.xZ[0] = 1;
      qsizes.xZ[1] = imin2(2, n);
      qsizes.xZ[2] = imin2(4, n);
      qsizes.xZ[3] = n;
   // different NX/NY/NormType
      for (nx = 1; nx <= 2; nx++) {
         for (ny = 0; ny <= 2; ny++) {
            for (normtype = 0; normtype <= 2; normtype++) {
            // Prepare data
               ae_matrix_set_length(&xy, n, nx + ny);
               ae_vector_set_length(&tags, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < nx + ny; j++) {
                     xy.xyR[i][j] = randomreal();
                  }
                  tags.xZ[i] = randominteger(100);
               }
            // Build tree, pass it through serializer
               kdtreebuildtagged(&xy, &tags, n, nx, ny, normtype, &tree0);
               {
               // This code passes data structure through serializers
               // (serializes it to string and loads back)
                  ae_int_t _local_ssize;
                  ae_frame _local_frame_block;
                  ae_frame_make(&_local_frame_block);
                  NewSerializer(_local_serializer);
                  ae_serializer_alloc_start(&_local_serializer);
                  kdtreealloc(&_local_serializer, &tree0);
                  _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                  NewBlock(_local_dynamic_block, _local_ssize + 1);
                  ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  kdtreeserialize(&_local_serializer, &tree0);
                  ae_serializer_stop(&_local_serializer);
                  ae_serializer_init(&_local_serializer);
                  ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  kdtreeunserialize(&_local_serializer, &tree1);
                  ae_serializer_stop(&_local_serializer);
                  ae_frame_leave();
               }
            // For each point of XY we make queries with different sizes
               ae_vector_set_length(&x, nx);
               for (k = 0; k < n; k++) {
                  for (q = 0; q < qsizes.cnt; q++) {
                     ae_v_move(x.xR, 1, xy.xyR[k], 1, nx);
                     k0 = kdtreequeryknn(&tree0, &x, qsizes.xZ[q], true);
                     k1 = kdtreequeryknn(&tree1, &x, qsizes.xZ[q], true);
                     if (k0 != k1) {
                        *err = true;
                        ae_frame_leave();
                        return;
                     }
                     kdtreequeryresultsxy(&tree0, &xy0);
                     kdtreequeryresultsxy(&tree1, &xy1);
                     for (i = 0; i < k0; i++) {
                        for (j = 0; j < nx + ny; j++) {
                           if (fabs(xy0.xyR[i][j] - xy1.xyR[i][j]) > threshold) {
                              *err = true;
                              ae_frame_leave();
                              return;
                           }
                        }
                     }
                     kdtreequeryresultstags(&tree0, &tags0);
                     kdtreequeryresultstags(&tree1, &tags1);
                     for (i = 0; i < k0; i++) {
                        if (tags0.xZ[i] != tags1.xZ[i]) {
                           *err = true;
                           ae_frame_leave();
                           return;
                        }
                     }
                  }
               }
            }
         }
      }
   // Next N
      n += 25;
   }
   ae_frame_leave();
}

// This function tests different special cases:
// * Kd-tree for a zero number of points
// * Kd-tree for array with a lot of duplicates (early versions of ALGLIB
//   raised stack overflow on such datasets)
//
// It returns True on errors, False on success.
static bool testnearestneighborunit_testspecialcases() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nk;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t normtype;
   ae_int_t i;
   ae_int_t j;
   double v;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(kdtree, kdt);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(tags, 0, DT_INT);
   NewVector(x, 0, DT_REAL);
   result = false;
   for (nx = 1; nx <= 3; nx++) {
      for (ny = 0; ny <= 3; ny++) {
         for (normtype = 0; normtype <= 2; normtype++) {
         // Build tree
            if (randombool()) {
               kdtreebuildtagged(&xy, &tags, 0, nx, ny, normtype, &kdt);
            } else {
               kdtreebuild(&xy, 0, nx, ny, normtype, &kdt);
            }
         // Test different queries
            ae_vector_set_length(&x, nx);
            for (i = 0; i < nx; i++) {
               x.xR[i] = randomreal();
            }
            result = result || kdtreequeryknn(&kdt, &x, 1, true) > 0;
            result = result || kdtreequeryrnn(&kdt, &x, 1.0E6, true) > 0;
            result = result || kdtreequeryaknn(&kdt, &x, 1, true, 2.0) > 0;
         }
      }
   }
// Ability to handle array with a lot of duplicates without causing
// stack overflow.
//
// Two situations are handled:
// * array where ALL N elements are duplicates
// * array where there are NK distinct elements and N-NK duplicates
   nx = 2;
   ny = 1;
   n = 100000;
   nk = 100;
   v = randomreal();
   ae_matrix_set_length(&xy, n, nx + ny);
   ae_vector_set_length(&x, nx);
   for (i = 0; i < n; i++) {
      for (j = 0; j < nx + ny; j++) {
         xy.xyR[i][j] = v;
      }
   }
   kdtreebuild(&xy, n, nx, ny, 2, &kdt);
   for (j = 0; j < nx; j++) {
      x.xR[j] = v;
   }
   result = result || kdtreequeryrnn(&kdt, &x, 0.0001, true) != n;
   for (i = 0; i < nk; i++) {
      for (j = 0; j < nx + ny; j++) {
         xy.xyR[i][j] = randomreal();
      }
   }
   kdtreebuild(&xy, n, nx, ny, 2, &kdt);
   result = result || kdtreequeryrnn(&kdt, &x, 0.0001, true) < n - nk;
   ae_frame_leave();
   return result;
}

// Testing Nearest Neighbor Search
bool testnearestneighbor(bool silent) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_int_t normtype;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t n;
   ae_int_t smalln;
   ae_int_t largen;
   ae_int_t passcount;
   ae_int_t pass;
   bool waserrors;
   bool kdterrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   kdterrors = false;
   passcount = 2;
   smalln = 256;
   largen = 2048;
   ny = 3;
//
   testnearestneighborunit_testkdtreeserialization(&kdterrors);
   for (pass = 1; pass <= passcount; pass++) {
      for (normtype = 0; normtype <= 2; normtype++) {
         for (nx = 1; nx <= 3; nx++) {
         // Test in hypercube
            ae_matrix_set_length(&xy, largen, nx + ny);
            for (i = 0; i < largen; i++) {
               for (j = 0; j < nx + ny; j++) {
                  xy.xyR[i][j] = 5.0 * randommid();
               }
            }
            for (n = 1; n <= 10; n++) {
               testnearestneighborunit_testkdtuniform(&xy, n, nx, randominteger(ny + 1), normtype, &kdterrors);
            }
            testnearestneighborunit_testkdtuniform(&xy, largen, nx, randominteger(ny + 1), normtype, &kdterrors);
         // Test clustered (2*N points, pairs of equal points)
            ae_matrix_set_length(&xy, 2 * smalln, nx + ny);
            for (i = 0; i < smalln; i++) {
               for (j = 0; j < nx + ny; j++) {
                  xy.xyR[2 * i + 0][j] = 5.0 * randommid();
                  xy.xyR[2 * i + 1][j] = xy.xyR[2 * i + 0][j];
               }
            }
            testnearestneighborunit_testkdtuniform(&xy, 2 * smalln, nx, randominteger(ny + 1), normtype, &kdterrors);
         // Test degenerate case: all points are same except for one
            ae_matrix_set_length(&xy, smalln, nx + ny);
            v = randomreal();
            for (i = 0; i < smalln - 1; i++) {
               for (j = 0; j < nx + ny; j++) {
                  xy.xyR[i][j] = v;
               }
            }
            for (j = 0; j < nx + ny; j++) {
               xy.xyR[smalln - 1][j] = 5.0 * randommid();
            }
            testnearestneighborunit_testkdtuniform(&xy, smalln, nx, randominteger(ny + 1), normtype, &kdterrors);
         }
      }
   }
   kdterrors = kdterrors || testnearestneighborunit_testspecialcases();
// report
   waserrors = kdterrors;
   if (!silent) {
      printf("TESTING NEAREST NEIGHBOR SEARCH\n");
      printf("* KD TREES:                              ");
      if (!kdterrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === odesolver testing unit ===
// Test
bool testodesolver(bool silent) {
   ae_frame _frame_block;
   ae_int_t passcount;
   bool curerrors;
   bool rkckerrors;
   bool waserrors;
   double h;
   double eps;
   ae_int_t solver;
   ae_int_t pass;
   ae_int_t mynfev;
   double v;
   ae_int_t m;
   ae_int_t m2;
   ae_int_t i;
   double err;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(xtbl, 0, DT_REAL);
   NewMatrix(ytbl, 0, 0, DT_REAL);
   NewObj(odesolverreport, rep);
   NewVector(xg, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(odesolverstate, state);
   rkckerrors = false;
   waserrors = false;
   passcount = 10;
// simple test: just A*sin(x)+B*cos(x)
   ae_assert(passcount >= 2, "Assertion failed");
   for (pass = 0; pass < passcount; pass++) {
      for (solver = 0; solver <= 0; solver++) {
      // prepare
         h = 1.0E-2;
         eps = 1.0E-5;
         if (pass % 2 == 0) {
            eps = -eps;
         }
         ae_vector_set_length(&y, 2);
         for (i = 0; i <= 1; i++) {
            y.xR[i] = randommid();
         }
         m = 2 + randominteger(10);
         ae_vector_set_length(&xg, m);
         xg.xR[0] = (m - 1) * randomreal();
         for (i = 1; i < m; i++) {
            xg.xR[i] = xg.xR[i - 1] + randomreal();
         }
         v = 2 * pi / (xg.xR[m - 1] - xg.xR[0]);
         ae_v_muld(xg.xR, 1, m, v);
         if (randombool()) {
            ae_v_muld(xg.xR, 1, m, -1);
         }
         mynfev = 0;
      // choose solver
         if (solver == 0) {
            odesolverrkck(&y, 2, &xg, m, eps, h, &state);
         }
      // solve
         while (odesolveriteration(&state)) {
            state.dy.xR[0] = state.y.xR[1];
            state.dy.xR[1] = -state.y.xR[0];
            mynfev++;
         }
         odesolverresults(&state, &m2, &xtbl, &ytbl, &rep);
      // check results
         curerrors = false;
         if (rep.terminationtype <= 0) {
            curerrors = true;
         } else {
            curerrors = curerrors || m2 != m;
            err = 0.0;
            for (i = 0; i < m; i++) {
               err = rmax2(err, fabs(ytbl.xyR[i][0] - (y.xR[0] * cos(xtbl.xR[i] - xtbl.xR[0]) + y.xR[1] * sin(xtbl.xR[i] - xtbl.xR[0]))));
               err = rmax2(err, fabs(ytbl.xyR[i][1] - (-y.xR[0] * sin(xtbl.xR[i] - xtbl.xR[0]) + y.xR[1] * cos(xtbl.xR[i] - xtbl.xR[0]))));
            }
            curerrors = curerrors || err > 10 * fabs(eps);
            curerrors = curerrors || mynfev != rep.nfev;
         }
         if (solver == 0) {
            rkckerrors = rkckerrors || curerrors;
         }
      }
   }
// another test:
//
//     y(0)   = 0
//     dy/dx  = f(x,y)
//     f(x,y) = 0,   x<1
//              x-1, x >= 1
//
// with BOTH absolute and fractional tolerances.
// Starting from zero will be real challenge for
// fractional tolerance.
   ae_assert(passcount >= 2, "Assertion failed");
   for (pass = 0; pass < passcount; pass++) {
      h = 1.0E-4;
      eps = 1.0E-4;
      if (pass % 2 == 0) {
         eps = -eps;
      }
      ae_vector_set_length(&y, 1);
      y.xR[0] = 0.0;
      m = 21;
      ae_vector_set_length(&xg, m);
      for (i = 0; i < m; i++) {
         xg.xR[i] = (double)(2 * i) / (m - 1);
      }
      mynfev = 0;
      odesolverrkck(&y, 1, &xg, m, eps, h, &state);
      while (odesolveriteration(&state)) {
         state.dy.xR[0] = rmax2(state.x - 1, 0.0);
         mynfev++;
      }
      odesolverresults(&state, &m2, &xtbl, &ytbl, &rep);
      if (rep.terminationtype <= 0) {
         rkckerrors = true;
      } else {
         rkckerrors = rkckerrors || m2 != m;
         err = 0.0;
         for (i = 0; i < m; i++) {
            err = rmax2(err, fabs(ytbl.xyR[i][0] - sqr(rmax2(xg.xR[i] - 1, 0.0)) / 2));
         }
         rkckerrors = rkckerrors || err > fabs(eps);
         rkckerrors = rkckerrors || mynfev != rep.nfev;
      }
   }
// end
   waserrors = rkckerrors;
   if (!silent) {
      printf("TESTING ODE SOLVER\n");
      printf("* RK CASH-KARP:                           ");
      if (rkckerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === inverseupdate testing unit ===
// Copy
static void testinverseupdateunit_makeacopy(RMatrix *a, ae_int_t m, ae_int_t n, RMatrix *b) {
   ae_int_t i;
   ae_int_t j;
   SetMatrix(b);
   ae_matrix_set_length(b, m - 1 + 1, n - 1 + 1);
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         b->xyR[i][j] = a->xyR[i][j];
      }
   }
}

// LU decomposition
static void testinverseupdateunit_matlu(RMatrix *a, ae_int_t m, ae_int_t n, ZVector *pivots) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t jp;
   double s;
   ae_frame_make(&_frame_block);
   SetVector(pivots);
   NewVector(t1, 0, DT_REAL);
   ae_vector_set_length(pivots, imin2(m - 1, n - 1) + 1);
   ae_vector_set_length(&t1, imax2(m - 1, n - 1) + 1);
   ae_assert(m >= 0 && n >= 0, "Error in LUDecomposition: incorrect function arguments");
// Quick return if possible
   if (m == 0 || n == 0) {
      ae_frame_leave();
      return;
   }
   for (j = 0; j < imin2(m, n); j++) {
   // Find pivot and test for singularity.
      jp = j;
      for (i = j + 1; i < m; i++) {
         if (fabs(a->xyR[i][j]) > fabs(a->xyR[jp][j])) {
            jp = i;
         }
      }
      pivots->xZ[j] = jp;
      if (a->xyR[jp][j] != 0.0) {
      // Apply the interchange to rows
         if (jp != j) {
            ae_v_move(t1.xR, 1, a->xyR[j], 1, n);
            ae_v_move(a->xyR[j], 1, a->xyR[jp], 1, n);
            ae_v_move(a->xyR[jp], 1, t1.xR, 1, n);
         }
      // Compute elements J+1:M of J-th column.
         if (j + 1 < m) {
            jp = j + 1;
            s = 1 / a->xyR[j][j];
            ae_v_muld(&a->xyR[jp][j], a->stride, m - jp, s);
         }
      }
      if (j < imin2(m, n) - 1) {
      // Update trailing submatrix.
         jp = j + 1;
         for (i = j + 1; i < m; i++) {
            s = a->xyR[i][j];
            ae_v_subd(&a->xyR[i][jp], 1, &a->xyR[j][jp], 1, n - jp, s);
         }
      }
   }
   ae_frame_leave();
}

// Generate matrix with given condition number C (2-norm)
static void testinverseupdateunit_generaterandomorthogonalmatrix(RMatrix *a0, ae_int_t n) {
   ae_frame _frame_block;
   double t;
   double lambdav;
   ae_int_t s;
   ae_int_t i;
   ae_int_t j;
   double u1;
   double u2;
   double sm;
   ae_frame_make(&_frame_block);
   NewVector(w, 0, DT_REAL);
   NewVector(v, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   if (n <= 0) {
      ae_frame_leave();
      return;
   }
   ae_vector_set_length(&w, n + 1);
   ae_vector_set_length(&v, n + 1);
   ae_matrix_set_length(&a, n + 1, n + 1);
   ae_matrix_set_length(a0, n - 1 + 1, n - 1 + 1);
// Prepare A
   for (i = 1; i <= n; i++) {
      for (j = 1; j <= n; j++) {
         if (i == j) {
            a.xyR[i][j] = 1.0;
         } else {
            a.xyR[i][j] = 0.0;
         }
      }
   }
// Calculate A using Stewart algorithm
   for (s = 2; s <= n; s++) {
   // Prepare v and Lambda = v'*v
      do {
         i = 1;
         while (i <= s) {
            u1 = randommid();
            u2 = randommid();
            sm = u1 * u1 + u2 * u2;
            if (sm == 0.0 || sm > 1.0) {
               continue;
            }
            sm = sqrt(-2 * log(sm) / sm);
            v.xR[i] = u1 * sm;
            if (i + 1 <= s) {
               v.xR[i + 1] = u2 * sm;
            }
            i += 2;
         }
         lambdav = ae_v_dotproduct(&v.xR[1], 1, &v.xR[1], 1, s);
      } while (lambdav == 0.0);
      lambdav = 2 / lambdav;
   // A * (I - 2 vv'/v'v ) =
   //   = A - (2/v'v) * A * v * v' =
   //   = A - (2/v'v) * w * v'
   //  where w = Av
      for (i = 1; i <= s; i++) {
         t = ae_v_dotproduct(&a.xyR[i][1], 1, &v.xR[1], 1, s);
         w.xR[i] = t;
      }
      for (i = 1; i <= s; i++) {
         t = w.xR[i] * lambdav;
         ae_v_subd(&a.xyR[i][1], 1, &v.xR[1], 1, s, t);
      }
   }
//
   for (i = 1; i <= n; i++) {
      for (j = 1; j <= n; j++) {
         a0->xyR[i - 1][j - 1] = a.xyR[i][j];
      }
   }
   ae_frame_leave();
}

static void testinverseupdateunit_generaterandommatrixcond(RMatrix *a0, ae_int_t n, double c) {
   ae_frame _frame_block;
   double l1;
   double l2;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_frame_make(&_frame_block);
   NewMatrix(q1, 0, 0, DT_REAL);
   NewMatrix(q2, 0, 0, DT_REAL);
   NewVector(cc, 0, DT_REAL);
   testinverseupdateunit_generaterandomorthogonalmatrix(&q1, n);
   testinverseupdateunit_generaterandomorthogonalmatrix(&q2, n);
   ae_vector_set_length(&cc, n - 1 + 1);
   l1 = 0.0;
   l2 = log(1 / c);
   cc.xR[0] = exp(l1);
   for (i = 1; i < n - 1; i++) {
      cc.xR[i] = exp(randomreal() * (l2 - l1) + l1);
   }
   cc.xR[n - 1] = exp(l2);
   ae_matrix_set_length(a0, n - 1 + 1, n - 1 + 1);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         a0->xyR[i][j] = 0.0;
         for (k = 0; k < n; k++) {
            a0->xyR[i][j] += q1.xyR[i][k] * cc.xR[k] * q2.xyR[j][k];
         }
      }
   }
   ae_frame_leave();
}

// triangular inverse
static bool testinverseupdateunit_invmattr(RMatrix *a, ae_int_t n, bool isupper, bool isunittriangular) {
   ae_frame _frame_block;
   bool nounit;
   ae_int_t i;
   ae_int_t j;
   double v;
   double ajj;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(t, 0, DT_REAL);
   result = true;
   ae_vector_set_length(&t, n - 1 + 1);
// Test the input parameters.
   nounit = !isunittriangular;
   if (isupper) {
   // Compute inverse of upper triangular matrix.
      for (j = 0; j < n; j++) {
         if (nounit) {
            if (a->xyR[j][j] == 0.0) {
               result = false;
               ae_frame_leave();
               return result;
            }
            a->xyR[j][j] = 1 / a->xyR[j][j];
            ajj = -a->xyR[j][j];
         } else {
            ajj = -1.0;
         }
      // Compute elements 1:j-1 of j-th column.
         if (j > 0) {
            ae_v_move(t.xR, 1, &a->xyR[0][j], a->stride, j);
            for (i = 0; i < j; i++) {
               if (i < j - 1) {
                  v = ae_v_dotproduct(&a->xyR[i][i + 1], 1, &t.xR[i + 1], 1, j - i - 1);
               } else {
                  v = 0.0;
               }
               if (nounit) {
                  a->xyR[i][j] = v + a->xyR[i][i] * t.xR[i];
               } else {
                  a->xyR[i][j] = v + t.xR[i];
               }
            }
            ae_v_muld(&a->xyR[0][j], a->stride, j, ajj);
         }
      }
   } else {
   // Compute inverse of lower triangular matrix.
      for (j = n - 1; j >= 0; j--) {
         if (nounit) {
            if (a->xyR[j][j] == 0.0) {
               result = false;
               ae_frame_leave();
               return result;
            }
            a->xyR[j][j] = 1 / a->xyR[j][j];
            ajj = -a->xyR[j][j];
         } else {
            ajj = -1.0;
         }
         if (j < n - 1) {
         // Compute elements j+1:n of j-th column.
            ae_v_move(&t.xR[j + 1], 1, &a->xyR[j + 1][j], a->stride, n - j - 1);
            for (i = j + 1; i < n; i++) {
               if (i > j + 1) {
                  v = ae_v_dotproduct(&a->xyR[i][j + 1], 1, &t.xR[j + 1], 1, i - j - 1);
               } else {
                  v = 0.0;
               }
               if (nounit) {
                  a->xyR[i][j] = v + a->xyR[i][i] * t.xR[i];
               } else {
                  a->xyR[i][j] = v + t.xR[i];
               }
            }
            ae_v_muld(&a->xyR[j + 1][j], a->stride, n - j - 1, ajj);
         }
      }
   }
   ae_frame_leave();
   return result;
}

// LU inverse
static bool testinverseupdateunit_invmatlu(RMatrix *a, ZVector *pivots, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t jp;
   double v;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(work, 0, DT_REAL);
   result = true;
// Quick return if possible
   if (n == 0) {
      ae_frame_leave();
      return result;
   }
   ae_vector_set_length(&work, n - 1 + 1);
// Form inv(U)
   if (!testinverseupdateunit_invmattr(a, n, true, false)) {
      result = false;
      ae_frame_leave();
      return result;
   }
// Solve the equation inv(A)*L = inv(U) for inv(A).
   for (j = n - 1; j >= 0; j--) {
   // Copy current column of L to WORK and replace with zeros.
      for (i = j + 1; i < n; i++) {
         work.xR[i] = a->xyR[i][j];
         a->xyR[i][j] = 0.0;
      }
   // Compute current column of inv(A).
      if (j < n - 1) {
         for (i = 0; i < n; i++) {
            v = ae_v_dotproduct(&a->xyR[i][j + 1], 1, &work.xR[j + 1], 1, n - j - 1);
            a->xyR[i][j] -= v;
         }
      }
   }
// Apply column interchanges.
   for (j = n - 2; j >= 0; j--) {
      jp = pivots->xZ[j];
      if (jp != j) {
         ae_v_move(work.xR, 1, &a->xyR[0][j], a->stride, n);
         ae_v_move(&a->xyR[0][j], a->stride, &a->xyR[0][jp], a->stride, n);
         ae_v_move(&a->xyR[0][jp], a->stride, work.xR, 1, n);
      }
   }
   ae_frame_leave();
   return result;
}

// Matrix inverse
static bool testinverseupdateunit_invmat(RMatrix *a, ae_int_t n) {
   ae_frame _frame_block;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(pivots, 0, DT_INT);
   testinverseupdateunit_matlu(a, n, n, &pivots);
   result = testinverseupdateunit_invmatlu(a, &pivots, n);
   ae_frame_leave();
   return result;
}

// Diff
static double testinverseupdateunit_matrixdiff(RMatrix *a, RMatrix *b, ae_int_t m, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   double result;
   result = 0.0;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
         result = rmax2(result, fabs(b->xyR[i][j] - a->xyR[i][j]));
      }
   }
   return result;
}

// Update and inverse
static bool testinverseupdateunit_updandinv(RMatrix *a, RVector *u, RVector *v, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   double r;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(pivots, 0, DT_INT);
   for (i = 0; i < n; i++) {
      r = u->xR[i];
      ae_v_addd(a->xyR[i], 1, v->xR, 1, n, r);
   }
   testinverseupdateunit_matlu(a, n, n, &pivots);
   result = testinverseupdateunit_invmatlu(a, &pivots, n);
   ae_frame_leave();
   return result;
}

// Compute matrix norm
static double testinverseupdateunit_normalizednrm(RMatrix *a, ae_int_t n) {
   ae_int_t i;
   ae_int_t j;
   double result;
   result = 1.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         result = rmax2(result, fabs(a->xyR[i][j]));
      }
   }
   return result;
}

bool testinverseupdate(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t i;
   ae_int_t updrow;
   ae_int_t updcol;
   double val;
   ae_int_t pass;
   ae_int_t passcount;
   bool waserrors;
   double threshold;
   double c;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(inva, 0, 0, DT_REAL);
   NewMatrix(b1, 0, 0, DT_REAL);
   NewMatrix(b2, 0, 0, DT_REAL);
   NewVector(u, 0, DT_REAL);
   NewVector(v, 0, DT_REAL);
   waserrors = false;
   maxn = 10;
   passcount = 100;
   threshold = 1.0E-6;
// process
   for (n = 1; n <= maxn; n++) {
      ae_matrix_set_length(&a, n - 1 + 1, n - 1 + 1);
      ae_matrix_set_length(&b1, n - 1 + 1, n - 1 + 1);
      ae_matrix_set_length(&b2, n - 1 + 1, n - 1 + 1);
      ae_vector_set_length(&u, n - 1 + 1);
      ae_vector_set_length(&v, n - 1 + 1);
      for (pass = 1; pass <= passcount; pass++) {
         c = exp(randomreal() * log(10.0));
         testinverseupdateunit_generaterandommatrixcond(&a, n, c);
         testinverseupdateunit_makeacopy(&a, n, n, &inva);
         if (!testinverseupdateunit_invmat(&inva, n)) {
            set_error_flag(&waserrors, true, __FILE__, __LINE__, "testinverseupdateunit.ap:642");
            break;
         }
      // Test simple update
         updrow = randominteger(n);
         updcol = randominteger(n);
         val = 0.1 * randommid();
         for (i = 0; i < n; i++) {
            if (i == updrow) {
               u.xR[i] = val;
            } else {
               u.xR[i] = 0.0;
            }
            if (i == updcol) {
               v.xR[i] = 1.0;
            } else {
               v.xR[i] = 0.0;
            }
         }
         testinverseupdateunit_makeacopy(&a, n, n, &b1);
         if (!testinverseupdateunit_updandinv(&b1, &u, &v, n)) {
            set_error_flag(&waserrors, true, __FILE__, __LINE__, "testinverseupdateunit.ap:666");
            break;
         }
         testinverseupdateunit_makeacopy(&inva, n, n, &b2);
         rmatrixinvupdatesimple(&b2, n, updrow, updcol, val);
         set_error_flag(&waserrors, testinverseupdateunit_matrixdiff(&b1, &b2, n, n) > threshold * testinverseupdateunit_normalizednrm(&b1, n), __FILE__, __LINE__, "testinverseupdateunit.ap:671");
      // Test row update
         updrow = randominteger(n);
         for (i = 0; i < n; i++) {
            if (i == updrow) {
               u.xR[i] = 1.0;
            } else {
               u.xR[i] = 0.0;
            }
            v.xR[i] = 0.1 * randommid();
         }
         testinverseupdateunit_makeacopy(&a, n, n, &b1);
         if (!testinverseupdateunit_updandinv(&b1, &u, &v, n)) {
            set_error_flag(&waserrors, true, __FILE__, __LINE__, "testinverseupdateunit.ap:688");
            break;
         }
         testinverseupdateunit_makeacopy(&inva, n, n, &b2);
         rmatrixinvupdaterow(&b2, n, updrow, &v);
         set_error_flag(&waserrors, testinverseupdateunit_matrixdiff(&b1, &b2, n, n) > threshold * testinverseupdateunit_normalizednrm(&b1, n), __FILE__, __LINE__, "testinverseupdateunit.ap:693");
      // Test column update
         updcol = randominteger(n);
         for (i = 0; i < n; i++) {
            if (i == updcol) {
               v.xR[i] = 1.0;
            } else {
               v.xR[i] = 0.0;
            }
            u.xR[i] = 0.1 * randommid();
         }
         testinverseupdateunit_makeacopy(&a, n, n, &b1);
         if (!testinverseupdateunit_updandinv(&b1, &u, &v, n)) {
            set_error_flag(&waserrors, true, __FILE__, __LINE__, "testinverseupdateunit.ap:710");
            break;
         }
         testinverseupdateunit_makeacopy(&inva, n, n, &b2);
         rmatrixinvupdatecolumn(&b2, n, updcol, &u);
         set_error_flag(&waserrors, testinverseupdateunit_matrixdiff(&b1, &b2, n, n) > threshold * testinverseupdateunit_normalizednrm(&b1, n), __FILE__, __LINE__, "testinverseupdateunit.ap:715");
      // Test full update
         for (i = 0; i < n; i++) {
            v.xR[i] = 0.1 * randommid();
            u.xR[i] = 0.1 * randommid();
         }
         testinverseupdateunit_makeacopy(&a, n, n, &b1);
         if (!testinverseupdateunit_updandinv(&b1, &u, &v, n)) {
            set_error_flag(&waserrors, true, __FILE__, __LINE__, "testinverseupdateunit.ap:728");
            break;
         }
         testinverseupdateunit_makeacopy(&inva, n, n, &b2);
         rmatrixinvupdateuv(&b2, n, &u, &v);
         set_error_flag(&waserrors, testinverseupdateunit_matrixdiff(&b1, &b2, n, n) > threshold * testinverseupdateunit_normalizednrm(&b1, n), __FILE__, __LINE__, "testinverseupdateunit.ap:733");
      }
   }
// report
   if (!silent) {
      printf("TESTING INVERSE UPDATE (REAL)\n");
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === schur testing unit ===
static void testschurunit_testschurproblem(RMatrix *a, ae_int_t n, double *materr, double *orterr, bool *errstruct, bool *wfailed) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double locerr;
   ae_frame_make(&_frame_block);
   NewMatrix(s, 0, 0, DT_REAL);
   NewMatrix(t, 0, 0, DT_REAL);
   NewVector(sr, 0, DT_REAL);
   NewVector(astc, 0, DT_REAL);
   NewVector(sastc, 0, DT_REAL);
   ae_vector_set_length(&sr, n - 1 + 1);
   ae_vector_set_length(&astc, n - 1 + 1);
   ae_vector_set_length(&sastc, n - 1 + 1);
// Schur decomposition, convergence test
   ae_matrix_set_length(&t, n - 1 + 1, n - 1 + 1);
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         t.xyR[i][j] = a->xyR[i][j];
      }
   }
   if (!rmatrixschur(&t, n, &s)) {
      *wfailed = true;
      ae_frame_leave();
      return;
   }
// decomposition error
   locerr = 0.0;
   for (j = 0; j < n; j++) {
      ae_v_move(sr.xR, 1, s.xyR[j], 1, n);
      for (k = 0; k < n; k++) {
         v = ae_v_dotproduct(t.xyR[k], 1, sr.xR, 1, n);
         astc.xR[k] = v;
      }
      for (k = 0; k < n; k++) {
         v = ae_v_dotproduct(s.xyR[k], 1, astc.xR, 1, n);
         sastc.xR[k] = v;
      }
      for (k = 0; k < n; k++) {
         locerr = rmax2(locerr, fabs(sastc.xR[k] - a->xyR[k][j]));
      }
   }
   *materr = rmax2(*materr, locerr);
// orthogonality error
   locerr = 0.0;
   for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
         v = ae_v_dotproduct(&s.xyR[0][i], s.stride, &s.xyR[0][j], s.stride, n);
         if (i != j) {
            locerr = rmax2(locerr, fabs(v));
         } else {
            locerr = rmax2(locerr, fabs(v - 1));
         }
      }
   }
   *orterr = rmax2(*orterr, locerr);
// T matrix structure
   for (j = 0; j < n; j++) {
      for (i = j + 2; i < n; i++) {
         if (t.xyR[i][j] != 0.0) {
            *errstruct = true;
         }
      }
   }
   ae_frame_leave();
}

// Testing Schur decomposition subroutine
bool testschur(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   ae_int_t passcount;
   bool waserrors;
   bool errstruct;
   bool wfailed;
   double materr;
   double orterr;
   double threshold;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(a, 0, 0, DT_REAL);
   materr = 0.0;
   orterr = 0.0;
   errstruct = false;
   wfailed = false;
   waserrors = false;
   maxn = 70;
   passcount = 1;
   threshold = 5 * 100 * machineepsilon;
   ae_matrix_set_length(&a, maxn - 1 + 1, maxn - 1 + 1);
// zero matrix, several cases
   for (i = 0; i < maxn; i++) {
      for (j = 0; j < maxn; j++) {
         a.xyR[i][j] = 0.0;
      }
   }
   for (n = 1; n <= maxn; n++) {
      if (n > 30 && n % 2 == 0) {
         continue;
      }
      testschurunit_testschurproblem(&a, n, &materr, &orterr, &errstruct, &wfailed);
   }
// Dense matrix
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         if (n > 30 && n % 2 == 0) {
            continue;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               a.xyR[i][j] = randommid();
            }
         }
         testschurunit_testschurproblem(&a, n, &materr, &orterr, &errstruct, &wfailed);
      }
   }
// report
   waserrors = ((materr > threshold || orterr > threshold) || errstruct) || wfailed;
   if (!silent) {
      printf("TESTING SCHUR DECOMPOSITION\n");
      printf("Schur decomposition error:               %5.3e\n", materr);
      printf("Schur orthogonality error:               %5.3e\n", orterr);
      printf("T matrix structure:                      ");
      if (!errstruct) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("Always converged:                        ");
      if (!wfailed) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("Threshold:                               %5.3e\n", threshold);
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === spdgevd testing unit ===
// Testing bidiagonal SVD decomposition subroutine
bool testspdgevd(bool silent) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t passcount;
   ae_int_t maxn;
   ae_int_t atask;
   ae_int_t btask;
   bool isuppera;
   bool isupperb;
   ae_int_t i;
   ae_int_t j;
   ae_int_t minij;
   double v;
   double v1;
   double v2;
   double err;
   double valerr;
   double threshold;
   bool waserrors;
   bool wfailed;
   bool wnsorted;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(d, 0, DT_REAL);
   NewVector(t1, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewMatrix(afull, 0, 0, DT_REAL);
   NewMatrix(bfull, 0, 0, DT_REAL);
   NewMatrix(l, 0, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   threshold = 10000 * machineepsilon;
   valerr = 0.0;
   wfailed = false;
   wnsorted = false;
   maxn = 20;
   passcount = 5;
// Main cycle
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
         for (atask = 0; atask <= 1; atask++) {
            for (btask = 0; btask <= 1; btask++) {
               isuppera = atask == 0;
               isupperb = btask == 0;
            // Initialize A, B, AFull, BFull
               ae_vector_set_length(&t1, n - 1 + 1);
               ae_matrix_set_length(&a, n - 1 + 1, n - 1 + 1);
               ae_matrix_set_length(&b, n - 1 + 1, n - 1 + 1);
               ae_matrix_set_length(&afull, n - 1 + 1, n - 1 + 1);
               ae_matrix_set_length(&bfull, n - 1 + 1, n - 1 + 1);
               ae_matrix_set_length(&l, n - 1 + 1, n - 1 + 1);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     a.xyR[i][j] = randommid();
                     a.xyR[j][i] = a.xyR[i][j];
                     afull.xyR[i][j] = a.xyR[i][j];
                     afull.xyR[j][i] = a.xyR[i][j];
                  }
               }
               for (i = 0; i < n; i++) {
                  for (j = i + 1; j < n; j++) {
                     l.xyR[i][j] = randomreal();
                     l.xyR[j][i] = l.xyR[i][j];
                  }
                  l.xyR[i][i] = 1.5 + randomreal();
               }
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     minij = imin2(i, j);
                     v = ae_v_dotproduct(l.xyR[i], 1, &l.xyR[0][j], l.stride, minij + 1);
                     b.xyR[i][j] = v;
                     b.xyR[j][i] = v;
                     bfull.xyR[i][j] = v;
                     bfull.xyR[j][i] = v;
                  }
               }
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     if (isuppera) {
                        if (j < i) {
                           a.xyR[i][j] = randommid();
                        }
                     } else {
                        if (i < j) {
                           a.xyR[i][j] = randommid();
                        }
                     }
                     if (isupperb) {
                        if (j < i) {
                           b.xyR[i][j] = randommid();
                        }
                     } else {
                        if (i < j) {
                           b.xyR[i][j] = randommid();
                        }
                     }
                  }
               }
            // Problem 1
               if (!smatrixgevd(&a, n, isuppera, &b, isupperb, 1, 1, &d, &z)) {
                  wfailed = true;
                  continue;
               }
               err = 0.0;
               for (j = 0; j < n; j++) {
                  for (i = 0; i < n; i++) {
                     v1 = ae_v_dotproduct(afull.xyR[i], 1, &z.xyR[0][j], z.stride, n);
                     v2 = ae_v_dotproduct(bfull.xyR[i], 1, &z.xyR[0][j], z.stride, n);
                     err = rmax2(err, fabs(v1 - d.xR[j] * v2));
                  }
               }
               valerr = rmax2(err, valerr);
            // Problem 2
               if (!smatrixgevd(&a, n, isuppera, &b, isupperb, 1, 2, &d, &z)) {
                  wfailed = true;
                  continue;
               }
               err = 0.0;
               for (j = 0; j < n; j++) {
                  for (i = 0; i < n; i++) {
                     v1 = ae_v_dotproduct(bfull.xyR[i], 1, &z.xyR[0][j], z.stride, n);
                     t1.xR[i] = v1;
                  }
                  for (i = 0; i < n; i++) {
                     v2 = ae_v_dotproduct(afull.xyR[i], 1, t1.xR, 1, n);
                     err = rmax2(err, fabs(v2 - d.xR[j] * z.xyR[i][j]));
                  }
               }
               valerr = rmax2(err, valerr);
            // Test problem 3
               if (!smatrixgevd(&a, n, isuppera, &b, isupperb, 1, 3, &d, &z)) {
                  wfailed = true;
                  continue;
               }
               err = 0.0;
               for (j = 0; j < n; j++) {
                  for (i = 0; i < n; i++) {
                     v1 = ae_v_dotproduct(afull.xyR[i], 1, &z.xyR[0][j], z.stride, n);
                     t1.xR[i] = v1;
                  }
                  for (i = 0; i < n; i++) {
                     v2 = ae_v_dotproduct(bfull.xyR[i], 1, t1.xR, 1, n);
                     err = rmax2(err, fabs(v2 - d.xR[j] * z.xyR[i][j]));
                  }
               }
               valerr = rmax2(err, valerr);
            }
         }
      }
   }
// report
   waserrors = (valerr > threshold || wfailed) || wnsorted;
   if (!silent) {
      printf("TESTING SYMMETRIC GEVD\n");
      printf("Av-lambdav error (generalized):          %5.3e\n", valerr);
      printf("Eigen values order:                      ");
      if (!wnsorted) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("Always converged:                        ");
      if (!wfailed) {
         printf("YES\n");
      } else {
         printf("NO\n");
      }
      printf("Threshold:                               %5.3e\n", threshold);
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === gammafunc testing unit ===
bool testgammafunc(bool silent) {
   double threshold;
   double v;
   double s;
   bool waserrors;
   bool gammaerrors;
   bool lngammaerrors;
   bool result;
   gammaerrors = false;
   lngammaerrors = false;
   waserrors = false;
   threshold = 100 * machineepsilon;
//
   gammaerrors = gammaerrors || fabs(gammafunction(0.5) - sqrt(pi)) > threshold;
   gammaerrors = gammaerrors || fabs(gammafunction(1.5) - 0.5 * sqrt(pi)) > threshold;
   v = lngamma(0.5, &s);
   lngammaerrors = (lngammaerrors || fabs(v - log(sqrt(pi))) > threshold) || s != 1.0;
   v = lngamma(1.5, &s);
   lngammaerrors = (lngammaerrors || fabs(v - log(0.5 * sqrt(pi))) > threshold) || s != 1.0;
// report
   waserrors = gammaerrors || lngammaerrors;
   if (!silent) {
      printf("TESTING GAMMA FUNCTION\n");
      printf("GAMMA:                                   ");
      if (gammaerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("LN GAMMA:                                ");
      if (lngammaerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
// end
   result = !waserrors;
   return result;
}

// === gq testing unit ===
// Maps:
//     0   =>  -0.9
//     1   =>  -0.5
//     2   =>  -0.1
//     3   =>   0.0
//     4   =>  +0.1
//     5   =>  +0.5
//     6   =>  +0.9
//     7   =>  +1.0
//     8   =>  +1.5
//     9   =>  +2.0
static double testgqunit_mapkind(ae_int_t k) {
   double result;
   result = 0.0;
   if (k == 0) {
      result = -0.9;
   }
   if (k == 1) {
      result = -0.5;
   }
   if (k == 2) {
      result = -0.1;
   }
   if (k == 3) {
      result = 0.0;
   }
   if (k == 4) {
      result = 0.1;
   }
   if (k == 5) {
      result = 0.5;
   }
   if (k == 6) {
      result = 0.9;
   }
   if (k == 7) {
      result = 1.0;
   }
   if (k == 8) {
      result = 1.5;
   }
   if (k == 9) {
      result = 2.0;
   }
   return result;
}

// Gauss-Legendre, another variant
static void testgqunit_buildgausslegendrequadrature(ae_int_t n, RVector *x, RVector *w) {
   ae_int_t i;
   ae_int_t j;
   double r;
   double r1;
   double p1;
   double p2;
   double p3;
   double dp3;
   double tmp;
   SetVector(x);
   SetVector(w);
   ae_vector_set_length(x, n - 1 + 1);
   ae_vector_set_length(w, n - 1 + 1);
   for (i = 0; i < (n + 1) / 2; i++) {
      r = cos(pi * (4 * i + 3) / (4 * n + 2));
      do {
         p2 = 0.0;
         p3 = 1.0;
         for (j = 0; j < n; j++) {
            p1 = p2;
            p2 = p3;
            p3 = ((2 * j + 1) * r * p2 - j * p1) / (j + 1);
         }
         dp3 = n * (r * p3 - p2) / (r * r - 1);
         r1 = r;
         r -= p3 / dp3;
      } while (fabs(r - r1) >= machineepsilon * (1 + fabs(r)) * 100);
      x->xR[i] = r;
      x->xR[n - 1 - i] = -r;
      w->xR[i] = 2 / ((1 - r * r) * dp3 * dp3);
      w->xR[n - 1 - i] = 2 / ((1 - r * r) * dp3 * dp3);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n - 1 - i; j++) {
         if (x->xR[j] >= x->xR[j + 1]) {
            tmp = x->xR[j];
            x->xR[j] = x->xR[j + 1];
            x->xR[j + 1] = tmp;
            tmp = w->xR[j];
            w->xR[j] = w->xR[j + 1];
            w->xR[j + 1] = tmp;
         }
      }
   }
}

// Gauss-Jacobi, another variant
static void testgqunit_buildgaussjacobiquadrature(ae_int_t n, double alpha, double beta, RVector *x, RVector *w) {
   ae_int_t i;
   ae_int_t j;
   double r;
   double r1;
   double t1;
   double t2;
   double t3;
   double p1;
   double p2;
   double p3;
   double pp;
   double an;
   double bn;
   double a;
   double b;
   double c;
   double tmpsgn;
   double tmp;
   double alfbet;
   double temp;
   SetVector(x);
   SetVector(w);
   ae_vector_set_length(x, n - 1 + 1);
   ae_vector_set_length(w, n - 1 + 1);
   r = 0.0;
   for (i = 0; i < n; i++) {
      if (i == 0) {
         an = alpha / n;
         bn = beta / n;
         t1 = (1 + alpha) * (2.78 / (4 + n * n) + 0.768 * an / n);
         t2 = 1 + 1.48 * an + 0.96 * bn + 0.452 * an * an + 0.83 * an * bn;
         r = (t2 - t1) / t2;
      } else {
         if (i == 1) {
            t1 = (4.1 + alpha) / ((1 + alpha) * (1 + 0.156 * alpha));
            t2 = 1 + 0.06 * (n - 8) * (1 + 0.12 * alpha) / n;
            t3 = 1 + 0.012 * beta * (1 + 0.25 * fabs(alpha)) / n;
            r -= t1 * t2 * t3 * (1 - r);
         } else {
            if (i == 2) {
               t1 = (1.67 + 0.28 * alpha) / (1 + 0.37 * alpha);
               t2 = 1 + 0.22 * (n - 8) / n;
               t3 = 1 + 8 * beta / ((6.28 + beta) * n * n);
               r -= t1 * t2 * t3 * (x->xR[0] - r);
            } else {
               if (i < n - 2) {
                  r = 3 * x->xR[i - 1] - 3 * x->xR[i - 2] + x->xR[i - 3];
               } else {
                  if (i == n - 2) {
                     t1 = (1 + 0.235 * beta) / (0.766 + 0.119 * beta);
                     t2 = 1 / (1 + 0.639 * (n - 4) / (1 + 0.71 * (n - 4)));
                     t3 = 1 / (1 + 20 * alpha / ((7.5 + alpha) * n * n));
                     r += t1 * t2 * t3 * (r - x->xR[i - 2]);
                  } else {
                     if (i == n - 1) {
                        t1 = (1 + 0.37 * beta) / (1.67 + 0.28 * beta);
                        t2 = 1 / (1 + 0.22 * (n - 8) / n);
                        t3 = 1 / (1 + 8 * alpha / ((6.28 + alpha) * n * n));
                        r += t1 * t2 * t3 * (r - x->xR[i - 2]);
                     }
                  }
               }
            }
         }
      }
      alfbet = alpha + beta;
      do {
         temp = 2 + alfbet;
         p1 = (alpha - beta + temp * r) * 0.5;
         p2 = 1.0;
         for (j = 2; j <= n; j++) {
            p3 = p2;
            p2 = p1;
            temp = 2 * j + alfbet;
            a = 2 * j * (j + alfbet) * (temp - 2);
            b = (temp - 1) * (alpha * alpha - beta * beta + temp * (temp - 2) * r);
            c = 2 * (j - 1 + alpha) * (j - 1 + beta) * temp;
            p1 = (b * p2 - c * p3) / a;
         }
         pp = (n * (alpha - beta - temp * r) * p1 + 2 * (n + alpha) * (n + beta) * p2) / (temp * (1 - r * r));
         r1 = r;
         r = r1 - p1 / pp;
      } while (fabs(r - r1) >= machineepsilon * (1 + fabs(r)) * 100);
      x->xR[i] = r;
      w->xR[i] = exp(lngamma(alpha + n, &tmpsgn) + lngamma(beta + n, &tmpsgn) - lngamma((double)(n + 1), &tmpsgn) - lngamma(n + alfbet + 1, &tmpsgn)) * temp * pow(2.0, alfbet) / (pp * p2);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n - 1 - i; j++) {
         if (x->xR[j] >= x->xR[j + 1]) {
            tmp = x->xR[j];
            x->xR[j] = x->xR[j + 1];
            x->xR[j + 1] = tmp;
            tmp = w->xR[j];
            w->xR[j] = w->xR[j + 1];
            w->xR[j + 1] = tmp;
         }
      }
   }
}

// Gauss-Laguerre, another variant
static void testgqunit_buildgausslaguerrequadrature(ae_int_t n, double alpha, RVector *x, RVector *w) {
   ae_int_t i;
   ae_int_t j;
   double r;
   double r1;
   double p1;
   double p2;
   double p3;
   double dp3;
   double tsg;
   double tmp;
   SetVector(x);
   SetVector(w);
   ae_vector_set_length(x, n - 1 + 1);
   ae_vector_set_length(w, n - 1 + 1);
   r = 0.0;
   for (i = 0; i < n; i++) {
      if (i == 0) {
         r = (1 + alpha) * (3 + 0.92 * alpha) / (1 + 2.4 * n + 1.8 * alpha);
      } else {
         if (i == 1) {
            r += (15 + 6.25 * alpha) / (1 + 0.9 * alpha + 2.5 * n);
         } else {
            r += ((1 + 2.55 * (i - 1)) / (1.9 * (i - 1)) + 1.26 * (i - 1) * alpha / (1 + 3.5 * (i - 1))) / (1 + 0.3 * alpha) * (r - x->xR[i - 2]);
         }
      }
      do {
         p2 = 0.0;
         p3 = 1.0;
         for (j = 0; j < n; j++) {
            p1 = p2;
            p2 = p3;
            p3 = ((-r + 2 * j + alpha + 1) * p2 - (j + alpha) * p1) / (j + 1);
         }
         dp3 = (n * p3 - (n + alpha) * p2) / r;
         r1 = r;
         r -= p3 / dp3;
      } while (fabs(r - r1) >= machineepsilon * (1 + fabs(r)) * 100);
      x->xR[i] = r;
      w->xR[i] = -exp(lngamma(alpha + n, &tsg) - lngamma((double)n, &tsg)) / (dp3 * n * p2);
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n - 1 - i; j++) {
         if (x->xR[j] >= x->xR[j + 1]) {
            tmp = x->xR[j];
            x->xR[j] = x->xR[j + 1];
            x->xR[j + 1] = tmp;
            tmp = w->xR[j];
            w->xR[j] = w->xR[j + 1];
            w->xR[j + 1] = tmp;
         }
      }
   }
}

// Gauss-Hermite, another variant
static void testgqunit_buildgausshermitequadrature(ae_int_t n, RVector *x, RVector *w) {
   ae_int_t i;
   ae_int_t j;
   double r;
   double r1;
   double p1;
   double p2;
   double p3;
   double dp3;
   double pipm4;
   double tmp;
   SetVector(x);
   SetVector(w);
   ae_vector_set_length(x, n - 1 + 1);
   ae_vector_set_length(w, n - 1 + 1);
   pipm4 = pow(pi, -0.25);
   r = 0.0;
   for (i = 0; i < (n + 1) / 2; i++) {
      if (i == 0) {
         r = sqrt((double)(2 * n + 1)) - 1.85575 * pow((double)(2 * n + 1), -1.0 / 6.0);
      } else {
         if (i == 1) {
            r -= 1.14 * pow((double)n, 0.426) / r;
         } else {
            if (i == 2) {
               r = 1.86 * r - 0.86 * x->xR[0];
            } else {
               if (i == 3) {
                  r = 1.91 * r - 0.91 * x->xR[1];
               } else {
                  r = 2 * r - x->xR[i - 2];
               }
            }
         }
      }
      do {
         p2 = 0.0;
         p3 = pipm4;
         for (j = 0; j < n; j++) {
            p1 = p2;
            p2 = p3;
            p3 = p2 * r * sqrt(2.0 / (j + 1)) - p1 * sqrt((double)j / (j + 1));
         }
         dp3 = sqrt((double)(2 * j)) * p2;
         r1 = r;
         r -= p3 / dp3;
      } while (fabs(r - r1) >= machineepsilon * (1 + fabs(r)) * 100);
      x->xR[i] = r;
      w->xR[i] = 2 / (dp3 * dp3);
      x->xR[n - 1 - i] = -x->xR[i];
      w->xR[n - 1 - i] = w->xR[i];
   }
   for (i = 0; i < n; i++) {
      for (j = 0; j < n - 1 - i; j++) {
         if (x->xR[j] >= x->xR[j + 1]) {
            tmp = x->xR[j];
            x->xR[j] = x->xR[j + 1];
            x->xR[j + 1] = tmp;
            tmp = w->xR[j];
            w->xR[j] = w->xR[j + 1];
            w->xR[j + 1] = tmp;
         }
      }
   }
}

// Test
bool testgq(bool silent) {
   ae_frame _frame_block;
   double err;
   ae_int_t n;
   ae_int_t i;
   ae_int_t info;
   ae_int_t akind;
   ae_int_t bkind;
   double alphac;
   double betac;
   double errtol;
   double nonstricterrtol;
   double stricterrtol;
   bool recerrors;
   bool specerrors;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(alpha, 0, DT_REAL);
   NewVector(beta, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   recerrors = false;
   specerrors = false;
   waserrors = false;
   errtol = 1.0E-12;
   nonstricterrtol = 1.0E-6;
   stricterrtol = 1000 * machineepsilon;
// Three tests for rec-based Gauss quadratures with known weights/nodes:
// 1. Gauss-Legendre with N=2
// 2. Gauss-Legendre with N=5
// 3. Gauss-Chebyshev with N=1, 2, 4, 8, ..., 512
   err = 0.0;
   ae_vector_set_length(&alpha, 2);
   ae_vector_set_length(&beta, 2);
   alpha.xR[0] = 0.0;
   alpha.xR[1] = 0.0;
   beta.xR[1] = 1.0 / (4 * 1 * 1 - 1);
   gqgeneraterec(&alpha, &beta, 2.0, 2, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[0] + sqrt(3.0) / 3));
      err = rmax2(err, fabs(x.xR[1] - sqrt(3.0) / 3));
      err = rmax2(err, fabs(w.xR[0] - 1));
      err = rmax2(err, fabs(w.xR[1] - 1));
      for (i = 0; i <= 0; i++) {
         recerrors = recerrors || x.xR[i] >= x.xR[i + 1];
      }
   } else {
      recerrors = true;
   }
   ae_vector_set_length(&alpha, 5);
   ae_vector_set_length(&beta, 5);
   alpha.xR[0] = 0.0;
   for (i = 1; i <= 4; i++) {
      alpha.xR[i] = 0.0;
      beta.xR[i] = sqr((double)i) / (4 * sqr((double)i) - 1);
   }
   gqgeneraterec(&alpha, &beta, 2.0, 5, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[0] + sqrt(245 + 14 * sqrt(70.0)) / 21));
      err = rmax2(err, fabs(x.xR[0] + x.xR[4]));
      err = rmax2(err, fabs(x.xR[1] + sqrt(245 - 14 * sqrt(70.0)) / 21));
      err = rmax2(err, fabs(x.xR[1] + x.xR[3]));
      err = rmax2(err, fabs(x.xR[2]));
      err = rmax2(err, fabs(w.xR[0] - (322 - 13 * sqrt(70.0)) / 900));
      err = rmax2(err, fabs(w.xR[0] - w.xR[4]));
      err = rmax2(err, fabs(w.xR[1] - (322 + 13 * sqrt(70.0)) / 900));
      err = rmax2(err, fabs(w.xR[1] - w.xR[3]));
      err = rmax2(err, fabs(w.xR[2] - 128.0 / 225.0));
      for (i = 0; i <= 3; i++) {
         recerrors = recerrors || x.xR[i] >= x.xR[i + 1];
      }
   } else {
      recerrors = true;
   }
   n = 1;
   while (n <= 512) {
      ae_vector_set_length(&alpha, n);
      ae_vector_set_length(&beta, n);
      for (i = 0; i < n; i++) {
         alpha.xR[i] = 0.0;
         if (i == 0) {
            beta.xR[i] = 0.0;
         }
         if (i == 1) {
            beta.xR[i] = 1.0 / 2.0;
         }
         if (i > 1) {
            beta.xR[i] = 1.0 / 4.0;
         }
      }
      gqgeneraterec(&alpha, &beta, pi, n, &info, &x, &w);
      if (info > 0) {
         for (i = 0; i < n; i++) {
            err = rmax2(err, fabs(x.xR[i] - cos(pi * (n - i - 0.5) / n)));
            err = rmax2(err, fabs(w.xR[i] - pi / n));
         }
         for (i = 0; i < n - 1; i++) {
            recerrors = recerrors || x.xR[i] >= x.xR[i + 1];
         }
      } else {
         recerrors = true;
      }
      n *= 2;
   }
   recerrors = recerrors || err > errtol;
// Three tests for rec-based Gauss-Lobatto quadratures with known weights/nodes:
// 1. Gauss-Lobatto with N=3
// 2. Gauss-Lobatto with N=4
// 3. Gauss-Lobatto with N=6
   err = 0.0;
   ae_vector_set_length(&alpha, 2);
   ae_vector_set_length(&beta, 2);
   alpha.xR[0] = 0.0;
   alpha.xR[1] = 0.0;
   beta.xR[0] = 0.0;
   beta.xR[1] = (double)(1 * 1) / (4 * 1 * 1 - 1);
   gqgenerategausslobattorec(&alpha, &beta, 2.0, -1.0, 1.0, 3, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[0] + 1));
      err = rmax2(err, fabs(x.xR[1]));
      err = rmax2(err, fabs(x.xR[2] - 1));
      err = rmax2(err, fabs(w.xR[0] - 1.0 / 3.0));
      err = rmax2(err, fabs(w.xR[1] - 4.0 / 3.0));
      err = rmax2(err, fabs(w.xR[2] - 1.0 / 3.0));
      for (i = 0; i <= 1; i++) {
         recerrors = recerrors || x.xR[i] >= x.xR[i + 1];
      }
   } else {
      recerrors = true;
   }
   ae_vector_set_length(&alpha, 3);
   ae_vector_set_length(&beta, 3);
   alpha.xR[0] = 0.0;
   alpha.xR[1] = 0.0;
   alpha.xR[2] = 0.0;
   beta.xR[0] = 0.0;
   beta.xR[1] = (double)(1 * 1) / (4 * 1 * 1 - 1);
   beta.xR[2] = (double)(2 * 2) / (4 * 2 * 2 - 1);
   gqgenerategausslobattorec(&alpha, &beta, 2.0, -1.0, 1.0, 4, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[0] + 1));
      err = rmax2(err, fabs(x.xR[1] + sqrt(5.0) / 5));
      err = rmax2(err, fabs(x.xR[2] - sqrt(5.0) / 5));
      err = rmax2(err, fabs(x.xR[3] - 1));
      err = rmax2(err, fabs(w.xR[0] - 1.0 / 6.0));
      err = rmax2(err, fabs(w.xR[1] - 5.0 / 6.0));
      err = rmax2(err, fabs(w.xR[2] - 5.0 / 6.0));
      err = rmax2(err, fabs(w.xR[3] - 1.0 / 6.0));
      for (i = 0; i <= 2; i++) {
         recerrors = recerrors || x.xR[i] >= x.xR[i + 1];
      }
   } else {
      recerrors = true;
   }
   ae_vector_set_length(&alpha, 5);
   ae_vector_set_length(&beta, 5);
   alpha.xR[0] = 0.0;
   alpha.xR[1] = 0.0;
   alpha.xR[2] = 0.0;
   alpha.xR[3] = 0.0;
   alpha.xR[4] = 0.0;
   beta.xR[0] = 0.0;
   beta.xR[1] = (double)(1 * 1) / (4 * 1 * 1 - 1);
   beta.xR[2] = (double)(2 * 2) / (4 * 2 * 2 - 1);
   beta.xR[3] = (double)(3 * 3) / (4 * 3 * 3 - 1);
   beta.xR[4] = (double)(4 * 4) / (4 * 4 * 4 - 1);
   gqgenerategausslobattorec(&alpha, &beta, 2.0, -1.0, 1.0, 6, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[0] + 1));
      err = rmax2(err, fabs(x.xR[1] + sqrt((7 + 2 * sqrt(7.0)) / 21)));
      err = rmax2(err, fabs(x.xR[2] + sqrt((7 - 2 * sqrt(7.0)) / 21)));
      err = rmax2(err, fabs(x.xR[3] - sqrt((7 - 2 * sqrt(7.0)) / 21)));
      err = rmax2(err, fabs(x.xR[4] - sqrt((7 + 2 * sqrt(7.0)) / 21)));
      err = rmax2(err, fabs(x.xR[5] - 1));
      err = rmax2(err, fabs(w.xR[0] - 1.0 / 15.0));
      err = rmax2(err, fabs(w.xR[1] - (14 - sqrt(7.0)) / 30));
      err = rmax2(err, fabs(w.xR[2] - (14 + sqrt(7.0)) / 30));
      err = rmax2(err, fabs(w.xR[3] - (14 + sqrt(7.0)) / 30));
      err = rmax2(err, fabs(w.xR[4] - (14 - sqrt(7.0)) / 30));
      err = rmax2(err, fabs(w.xR[5] - 1.0 / 15.0));
      for (i = 0; i <= 4; i++) {
         recerrors = recerrors || x.xR[i] >= x.xR[i + 1];
      }
   } else {
      recerrors = true;
   }
   recerrors = recerrors || err > errtol;
// Three tests for rec-based Gauss-Radau quadratures with known weights/nodes:
// 1. Gauss-Radau with N=2
// 2. Gauss-Radau with N=3
// 3. Gauss-Radau with N=3 (another case)
   err = 0.0;
   ae_vector_set_length(&alpha, 1);
   ae_vector_set_length(&beta, 2);
   alpha.xR[0] = 0.0;
   beta.xR[0] = 0.0;
   beta.xR[1] = (double)(1 * 1) / (4 * 1 * 1 - 1);
   gqgenerategaussradaurec(&alpha, &beta, 2.0, -1.0, 2, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[0] + 1));
      err = rmax2(err, fabs(x.xR[1] - 1.0 / 3.0));
      err = rmax2(err, fabs(w.xR[0] - 0.5));
      err = rmax2(err, fabs(w.xR[1] - 1.5));
      for (i = 0; i <= 0; i++) {
         recerrors = recerrors || x.xR[i] >= x.xR[i + 1];
      }
   } else {
      recerrors = true;
   }
   ae_vector_set_length(&alpha, 2);
   ae_vector_set_length(&beta, 3);
   alpha.xR[0] = 0.0;
   alpha.xR[1] = 0.0;
   for (i = 0; i <= 2; i++) {
      beta.xR[i] = sqr((double)i) / (4 * sqr((double)i) - 1);
   }
   gqgenerategaussradaurec(&alpha, &beta, 2.0, -1.0, 3, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[0] + 1));
      err = rmax2(err, fabs(x.xR[1] - (1 - sqrt(6.0)) / 5));
      err = rmax2(err, fabs(x.xR[2] - (1 + sqrt(6.0)) / 5));
      err = rmax2(err, fabs(w.xR[0] - 2.0 / 9.0));
      err = rmax2(err, fabs(w.xR[1] - (16 + sqrt(6.0)) / 18));
      err = rmax2(err, fabs(w.xR[2] - (16 - sqrt(6.0)) / 18));
      for (i = 0; i <= 1; i++) {
         recerrors = recerrors || x.xR[i] >= x.xR[i + 1];
      }
   } else {
      recerrors = true;
   }
   ae_vector_set_length(&alpha, 2);
   ae_vector_set_length(&beta, 3);
   alpha.xR[0] = 0.0;
   alpha.xR[1] = 0.0;
   for (i = 0; i <= 2; i++) {
      beta.xR[i] = sqr((double)i) / (4 * sqr((double)i) - 1);
   }
   gqgenerategaussradaurec(&alpha, &beta, 2.0, 1.0, 3, &info, &x, &w);
   if (info > 0) {
      err = rmax2(err, fabs(x.xR[2] - 1));
      err = rmax2(err, fabs(x.xR[1] + (1 - sqrt(6.0)) / 5));
      err = rmax2(err, fabs(x.xR[0] + (1 + sqrt(6.0)) / 5));
      err = rmax2(err, fabs(w.xR[2] - 2.0 / 9.0));
      err = rmax2(err, fabs(w.xR[1] - (16 + sqrt(6.0)) / 18));
      err = rmax2(err, fabs(w.xR[0] - (16 - sqrt(6.0)) / 18));
      for (i = 0; i <= 1; i++) {
         recerrors = recerrors || x.xR[i] >= x.xR[i + 1];
      }
   } else {
      recerrors = true;
   }
   recerrors = recerrors || err > errtol;
// test recurrence-based special cases (Legendre, Jacobi, Hermite, ...)
// against another implementation (polynomial root-finder)
   for (n = 1; n <= 20; n++) {
   // test gauss-legendre
      err = 0.0;
      gqgenerategausslegendre(n, &info, &x, &w);
      if (info > 0) {
         testgqunit_buildgausslegendrequadrature(n, &x2, &w2);
         for (i = 0; i < n; i++) {
            err = rmax2(err, fabs(x.xR[i] - x2.xR[i]));
            err = rmax2(err, fabs(w.xR[i] - w2.xR[i]));
         }
      } else {
         specerrors = true;
      }
      specerrors = specerrors || err > errtol;
   // Test Gauss-Jacobi.
   // Since task is much more difficult we will use less strict
   // threshold.
      err = 0.0;
      for (akind = 0; akind <= 9; akind++) {
         for (bkind = 0; bkind <= 9; bkind++) {
            alphac = testgqunit_mapkind(akind);
            betac = testgqunit_mapkind(bkind);
            gqgenerategaussjacobi(n, alphac, betac, &info, &x, &w);
            if (info > 0) {
               testgqunit_buildgaussjacobiquadrature(n, alphac, betac, &x2, &w2);
               for (i = 0; i < n; i++) {
                  err = rmax2(err, fabs(x.xR[i] - x2.xR[i]));
                  err = rmax2(err, fabs(w.xR[i] - w2.xR[i]));
               }
            } else {
               specerrors = true;
            }
         }
      }
      specerrors = specerrors || err > nonstricterrtol;
   // special test for Gauss-Jacobi (Chebyshev weight
   // function with analytically known nodes/weights)
      err = 0.0;
      gqgenerategaussjacobi(n, -0.5, -0.5, &info, &x, &w);
      if (info > 0) {
         for (i = 0; i < n; i++) {
            err = rmax2(err, fabs(x.xR[i] + cos(pi * (i + 0.5) / n)));
            err = rmax2(err, fabs(w.xR[i] - pi / n));
         }
      } else {
         specerrors = true;
      }
      specerrors = specerrors || err > stricterrtol;
   // Test Gauss-Laguerre
      err = 0.0;
      for (akind = 0; akind <= 9; akind++) {
         alphac = testgqunit_mapkind(akind);
         gqgenerategausslaguerre(n, alphac, &info, &x, &w);
         if (info > 0) {
            testgqunit_buildgausslaguerrequadrature(n, alphac, &x2, &w2);
            for (i = 0; i < n; i++) {
               err = rmax2(err, fabs(x.xR[i] - x2.xR[i]));
               err = rmax2(err, fabs(w.xR[i] - w2.xR[i]));
            }
         } else {
            specerrors = true;
         }
      }
      specerrors = specerrors || err > nonstricterrtol;
   // Test Gauss-Hermite
      err = 0.0;
      gqgenerategausshermite(n, &info, &x, &w);
      if (info > 0) {
         testgqunit_buildgausshermitequadrature(n, &x2, &w2);
         for (i = 0; i < n; i++) {
            err = rmax2(err, fabs(x.xR[i] - x2.xR[i]));
            err = rmax2(err, fabs(w.xR[i] - w2.xR[i]));
         }
      } else {
         specerrors = true;
      }
      specerrors = specerrors || err > nonstricterrtol;
   }
// end
   waserrors = recerrors || specerrors;
   if (!silent) {
      printf("TESTING GAUSS QUADRATURES\n");
      printf("FINAL RESULT:                             ");
      if (waserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* SPECIAL CASES (LEGENDRE/JACOBI/..)      ");
      if (specerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* RECURRENCE-BASED:                       ");
      if (recerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === gkq testing unit ===
// Maps:
//     0   =>  -0.9
//     1   =>  -0.5
//     2   =>  -0.1
//     3   =>   0.0
//     4   =>  +0.1
//     5   =>  +0.5
//     6   =>  +0.9
//     7   =>  +1.0
//     8   =>  +1.5
//     9   =>  +2.0
static double testgkqunit_mapkind(ae_int_t k) {
   double result;
   result = 0.0;
   if (k == 0) {
      result = -0.9;
   }
   if (k == 1) {
      result = -0.5;
   }
   if (k == 2) {
      result = -0.1;
   }
   if (k == 3) {
      result = 0.0;
   }
   if (k == 4) {
      result = 0.1;
   }
   if (k == 5) {
      result = 0.5;
   }
   if (k == 6) {
      result = 0.9;
   }
   if (k == 7) {
      result = 1.0;
   }
   if (k == 8) {
      result = 1.5;
   }
   if (k == 9) {
      result = 2.0;
   }
   return result;
}

// Test
bool testgkq(bool silent) {
   ae_frame _frame_block;
   ae_int_t pkind;
   double errtol;
   double eps;
   ae_int_t n;
   ae_int_t i;
   ae_int_t k;
   ae_int_t info;
   double err;
   ae_int_t akind;
   ae_int_t bkind;
   double alphac;
   double betac;
   ae_int_t info1;
   ae_int_t info2;
   bool successatleastonce;
   bool intblerrors;
   bool vstblerrors;
   bool generrors;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x1, 0, DT_REAL);
   NewVector(wg1, 0, DT_REAL);
   NewVector(wk1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(wg2, 0, DT_REAL);
   NewVector(wk2, 0, DT_REAL);
   intblerrors = false;
   vstblerrors = false;
   generrors = false;
   waserrors = false;
   errtol = 10000 * machineepsilon;
// test recurrence-based Legendre nodes against the precalculated table
   for (pkind = 0; pkind <= 5; pkind++) {
      n = 0;
      if (pkind == 0) {
         n = 15;
      }
      if (pkind == 1) {
         n = 21;
      }
      if (pkind == 2) {
         n = 31;
      }
      if (pkind == 3) {
         n = 41;
      }
      if (pkind == 4) {
         n = 51;
      }
      if (pkind == 5) {
         n = 61;
      }
      gkqlegendrecalc(n, &info, &x1, &wk1, &wg1);
      gkqlegendretbl(n, &x2, &wk2, &wg2, &eps);
      if (info <= 0) {
         generrors = true;
         break;
      }
      for (i = 0; i < n; i++) {
         vstblerrors = vstblerrors || fabs(x1.xR[i] - x2.xR[i]) > errtol;
         vstblerrors = vstblerrors || fabs(wk1.xR[i] - wk2.xR[i]) > errtol;
         vstblerrors = vstblerrors || fabs(wg1.xR[i] - wg2.xR[i]) > errtol;
      }
   }
// Test recurrence-baced Gauss-Kronrod nodes against Gauss-only nodes
// calculated with subroutines from GQ unit.
   for (k = 1; k <= 30; k++) {
      n = 2 * k + 1;
   // Gauss-Legendre
      err = 0.0;
      gkqgenerategausslegendre(n, &info1, &x1, &wk1, &wg1);
      gqgenerategausslegendre(k, &info2, &x2, &wg2);
      if (info1 > 0 && info2 > 0) {
         for (i = 0; i < k; i++) {
            err = rmax2(err, fabs(x1.xR[2 * i + 1] - x2.xR[i]));
            err = rmax2(err, fabs(wg1.xR[2 * i + 1] - wg2.xR[i]));
         }
      } else {
         generrors = true;
      }
      generrors = generrors || err > errtol;
   }
   for (k = 1; k <= 15; k++) {
      n = 2 * k + 1;
   // Gauss-Jacobi
      successatleastonce = false;
      err = 0.0;
      for (akind = 0; akind <= 9; akind++) {
         for (bkind = 0; bkind <= 9; bkind++) {
            alphac = testgkqunit_mapkind(akind);
            betac = testgkqunit_mapkind(bkind);
            gkqgenerategaussjacobi(n, alphac, betac, &info1, &x1, &wk1, &wg1);
            gqgenerategaussjacobi(k, alphac, betac, &info2, &x2, &wg2);
            if (info1 > 0 && info2 > 0) {
               successatleastonce = true;
               for (i = 0; i < k; i++) {
                  err = rmax2(err, fabs(x1.xR[2 * i + 1] - x2.xR[i]));
                  err = rmax2(err, fabs(wg1.xR[2 * i + 1] - wg2.xR[i]));
               }
            } else {
               generrors = generrors || info1 != -5;
            }
         }
      }
      generrors = (generrors || err > errtol) || !successatleastonce;
   }
// end
   waserrors = (intblerrors || vstblerrors) || generrors;
   if (!silent) {
      printf("TESTING GAUSS-KRONROD QUADRATURES\n");
      printf("FINAL RESULT:                             ");
      if (waserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* PRE-CALCULATED TABLE:                   ");
      if (intblerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* CALCULATED AGAINST THE TABLE:           ");
      if (vstblerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* GENERAL PROPERTIES:                     ");
      if (generrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === autogk testing unit ===
// Test
bool testautogk(bool silent) {
   ae_frame _frame_block;
   double a;
   double b;
   double v;
   double exact;
   double eabs;
   double alpha;
   ae_int_t pkind;
   double errtol;
   bool simpleerrors;
   bool sngenderrors;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(autogkstate, state);
   NewObj(autogkreport, rep);
   simpleerrors = false;
   sngenderrors = false;
   waserrors = false;
   errtol = 10000 * machineepsilon;
// Simple test: integral(exp(x),+-1,+-2), no maximum width requirements
   a = (2 * randominteger(2) - 1) * 1.0;
   b = (2 * randominteger(2) - 1) * 2.0;
   autogksmooth(a, b, &state);
   while (autogkiteration(&state)) {
      state.f = exp(state.x);
   }
   autogkresults(&state, &v, &rep);
   exact = exp(b) - exp(a);
   eabs = fabs(exp(b) - exp(a));
   if (rep.terminationtype <= 0) {
      simpleerrors = true;
   } else {
      simpleerrors = simpleerrors || fabs(exact - v) > errtol * eabs;
   }
// Simple test: integral(exp(x),+-1,+-2), XWidth=0.1
   a = (2 * randominteger(2) - 1) * 1.0;
   b = (2 * randominteger(2) - 1) * 2.0;
   autogksmoothw(a, b, 0.1, &state);
   while (autogkiteration(&state)) {
      state.f = exp(state.x);
   }
   autogkresults(&state, &v, &rep);
   exact = exp(b) - exp(a);
   eabs = fabs(exp(b) - exp(a));
   if (rep.terminationtype <= 0) {
      simpleerrors = true;
   } else {
      simpleerrors = simpleerrors || fabs(exact - v) > errtol * eabs;
   }
// Simple test: integral(cos(100*x),0,2*pi), no maximum width requirements
   a = 0.0;
   b = 2 * pi;
   autogksmooth(a, b, &state);
   while (autogkiteration(&state)) {
      state.f = cos(100 * state.x);
   }
   autogkresults(&state, &v, &rep);
   exact = 0.0;
   eabs = 4.0;
   if (rep.terminationtype <= 0) {
      simpleerrors = true;
   } else {
      simpleerrors = simpleerrors || fabs(exact - v) > errtol * eabs;
   }
// Simple test: integral(cos(100*x),0,2*pi), XWidth=0.3
   a = 0.0;
   b = 2 * pi;
   autogksmoothw(a, b, 0.3, &state);
   while (autogkiteration(&state)) {
      state.f = cos(100 * state.x);
   }
   autogkresults(&state, &v, &rep);
   exact = 0.0;
   eabs = 4.0;
   if (rep.terminationtype <= 0) {
      simpleerrors = true;
   } else {
      simpleerrors = simpleerrors || fabs(exact - v) > errtol * eabs;
   }
// singular problem on [a,b] = [0.1, 0.5]
//     f2(x) = (1+x)*(b-x)^alpha, -1 < alpha < 1
   for (pkind = 0; pkind <= 6; pkind++) {
      a = 0.1;
      b = 0.5;
      alpha = 0.0;
      if (pkind == 0) {
         alpha = -0.9;
      }
      if (pkind == 1) {
         alpha = -0.5;
      }
      if (pkind == 2) {
         alpha = -0.1;
      }
      if (pkind == 3) {
         alpha = 0.0;
      }
      if (pkind == 4) {
         alpha = 0.1;
      }
      if (pkind == 5) {
         alpha = 0.5;
      }
      if (pkind == 6) {
         alpha = 0.9;
      }
   // f1(x) = (1+x)*(x-a)^alpha, -1 < alpha < 1
   // 1. use singular integrator for [a,b]
   // 2. use singular integrator for [b,a]
      exact = pow(b - a, alpha + 2) / (alpha + 2) + (1 + a) * pow(b - a, alpha + 1) / (alpha + 1);
      eabs = fabs(exact);
      autogksingular(a, b, alpha, 0.0, &state);
      while (autogkiteration(&state)) {
         if (state.xminusa < 0.01) {
            state.f = pow(state.xminusa, alpha) * (1 + state.x);
         } else {
            state.f = pow(state.x - a, alpha) * (1 + state.x);
         }
      }
      autogkresults(&state, &v, &rep);
      if (rep.terminationtype <= 0) {
         sngenderrors = true;
      } else {
         sngenderrors = sngenderrors || fabs(v - exact) > errtol * eabs;
      }
      autogksingular(b, a, 0.0, alpha, &state);
      while (autogkiteration(&state)) {
         if (state.bminusx > -0.01) {
            state.f = pow(-state.bminusx, alpha) * (1 + state.x);
         } else {
            state.f = pow(state.x - a, alpha) * (1 + state.x);
         }
      }
      autogkresults(&state, &v, &rep);
      if (rep.terminationtype <= 0) {
         sngenderrors = true;
      } else {
         sngenderrors = sngenderrors || fabs(-v - exact) > errtol * eabs;
      }
   // f1(x) = (1+x)*(b-x)^alpha, -1 < alpha < 1
   // 1. use singular integrator for [a,b]
   // 2. use singular integrator for [b,a]
      exact = (1 + b) * pow(b - a, alpha + 1) / (alpha + 1) - pow(b - a, alpha + 2) / (alpha + 2);
      eabs = fabs(exact);
      autogksingular(a, b, 0.0, alpha, &state);
      while (autogkiteration(&state)) {
         if (state.bminusx < 0.01) {
            state.f = pow(state.bminusx, alpha) * (1 + state.x);
         } else {
            state.f = pow(b - state.x, alpha) * (1 + state.x);
         }
      }
      autogkresults(&state, &v, &rep);
      if (rep.terminationtype <= 0) {
         sngenderrors = true;
      } else {
         sngenderrors = sngenderrors || fabs(v - exact) > errtol * eabs;
      }
      autogksingular(b, a, alpha, 0.0, &state);
      while (autogkiteration(&state)) {
         if (state.xminusa > -0.01) {
            state.f = pow(-state.xminusa, alpha) * (1 + state.x);
         } else {
            state.f = pow(b - state.x, alpha) * (1 + state.x);
         }
      }
      autogkresults(&state, &v, &rep);
      if (rep.terminationtype <= 0) {
         sngenderrors = true;
      } else {
         sngenderrors = sngenderrors || fabs(-v - exact) > errtol * eabs;
      }
   }
// end
   waserrors = simpleerrors || sngenderrors;
   if (!silent) {
      printf("TESTING AUTOGK\n");
      printf("INTEGRATION WITH GIVEN ACCURACY:          ");
      if (simpleerrors || sngenderrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* SIMPLE PROBLEMS:                        ");
      if (simpleerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* SINGULAR PROBLEMS (ENDS OF INTERVAL):   ");
      if (sngenderrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === normaldistr testing unit ===
// Normal test
// ALGLIB: Copyright 15.11.2019 by Sergey Bochkanov
static void testnormaldistrunit_testnormal(bool *errorflag) {
   ae_frame _frame_block;
   double v0;
   double v1;
   double x;
   double h;
   ae_int_t k;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Test that PDF is roughly equal to derivative of CDF
   for (k = 0; k <= 999; k++) {
      x = hqrndnormal(&rs);
      h = 1.0E-5;
      v0 = normalpdf(x);
      v1 = (normalcdf(x + h) - normalcdf(x - h)) / (2 * h);
      set_error_flag(errorflag, fabs(v0 - v1) > 1.0E-4, __FILE__, __LINE__, "testnormaldistrunit.ap:75");
   }
   ae_frame_leave();
}

// Bivariate normal test
// ALGLIB: Copyright 15.11.2019 by Sergey Bochkanov
static void testnormaldistrunit_testbvn(bool *errorflag) {
   ae_frame _frame_block;
   double v0;
   double v1;
   double err;
   double x;
   double y;
   double rho;
   double h;
   ae_int_t k;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Test bivariate normal CDF values (small Rho and hard Rho)
   err = 0.0;
   err = rmax2(err, fabs(0.142221121370770000 - bivariatenormalcdf(-1.060937077356340000, 1.523763953950230000, 0.344134938671007000)));
   err = rmax2(err, fabs(0.001090824383322160 - bivariatenormalcdf(-3.034280037001620000, 0.633583566571867000, 0.196737644948391000)));
   err = rmax2(err, fabs(0.000063428666799461 - bivariatenormalcdf(-3.577198111015300000, -2.584892928002350000, 0.603284544092224000)));
   err = rmax2(err, fabs(0.000000019144648137 - bivariatenormalcdf(-1.053171728048290000, -2.987017621703680000, -0.659498170394145000)));
   err = rmax2(err, fabs(0.972551066792029000 - bivariatenormalcdf(4.785178416287600000, 1.919693671247900000, 0.261346800934746000)));
   err = rmax2(err, fabs(0.000000608605272790 - bivariatenormalcdf(-4.852815283224590000, 2.398320119295830000, 0.662485812586403000)));
   err = rmax2(err, fabs(0.576135824931800000 - bivariatenormalcdf(0.192020298597275000, 4.695461487450740000, -0.110028699320946000)));
   err = rmax2(err, fabs(0.876357061322732000 - bivariatenormalcdf(2.095780141251770000, 1.211768206209080000, 0.397007061864995000)));
   err = rmax2(err, fabs(0.002969212104812400 - bivariatenormalcdf(-2.654007687508430000, 1.340051767837440000, -0.233916559318503000)));
   err = rmax2(err, fabs(0.000377048151161364 - bivariatenormalcdf(1.128363097510700000, -2.781006578069910000, -0.642877478801918000)));
   err = rmax2(err, fabs(0.995657061734790000 - bivariatenormalcdf(3.966506850977000000, 2.626841258388710000, 0.291409185863929000)));
   err = rmax2(err, fabs(0.003282876365551870 - bivariatenormalcdf(-2.717530641700190000, 3.217920162027340000, -0.101773464540366000)));
   err = rmax2(err, fabs(0.002099371685469470 - bivariatenormalcdf(-1.811681729272450000, -2.262911120125770000, 0.361735313431128000)));
   err = rmax2(err, fabs(0.648944114852307000 - bivariatenormalcdf(1.861468373436860000, 0.432740073549983000, 0.092845182466246300)));
   err = rmax2(err, fabs(0.000000000094851728 - bivariatenormalcdf(-4.898527851968480000, -3.491204153631050000, -0.010492822687090300)));
   err = rmax2(err, fabs(0.000416778593465223 - bivariatenormalcdf(-3.341356669094100000, 1.862802982022170000, 0.398642687655347000)));
   err = rmax2(err, fabs(0.741640376816388000 - bivariatenormalcdf(4.687494092358740000, 0.648415139929991000, -0.692925257444683000)));
   err = rmax2(err, fabs(0.868844042717264000 - bivariatenormalcdf(2.369093655782270000, 1.148153167494120000, 0.297877516862745000)));
   err = rmax2(err, fabs(0.999356215351682000 - bivariatenormalcdf(4.352384277131720000, 3.221749932900420000, -0.257163446680127000)));
   err = rmax2(err, fabs(0.998760969813713000 - bivariatenormalcdf(3.422289814750960000, 3.111433954663520000, 0.198012195099628000)));
   set_error_flag(errorflag, err > 1.0E-12, __FILE__, __LINE__, "testnormaldistrunit.ap:121");
   err = 0.0;
   err = rmax2(err, fabs(0.080575405379940000 - bivariatenormalcdf(-1.060937077356340000, 1.523763953950230000, -0.999999999999000000)));
   err = rmax2(err, fabs(0.000000000000000007 - bivariatenormalcdf(-1.060937077356340000, -1.060937077356340000, -0.999999999999000000)));
   err = rmax2(err, fabs(0.000000000000000007 - bivariatenormalcdf(-1.060937077356340000, -1.060937077354570000, -0.999999999999000000)));
   err = rmax2(err, fabs(0.000000000000000016 - bivariatenormalcdf(-3.034280037001620000, 0.633583566571867000, -0.999999999990000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-3.034280037001620000, -3.034280037001620000, -0.999999999990000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-3.034280037001620000, -3.034280036974940000, -0.999999999990000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-3.577198111015300000, -2.584892928002350000, -0.999999999900000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-3.577198111015300000, -3.577198111015300000, -0.999999999900000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-3.577198111015300000, -3.577198111015280000, -0.999999999900000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-1.053171728048290000, -2.987017621703680000, -0.999999999000000000)));
   err = rmax2(err, fabs(0.000000000000000021 - bivariatenormalcdf(-1.053171728048290000, -1.053171728048290000, -0.999999999000000000)));
   err = rmax2(err, fabs(0.000000000000000014 - bivariatenormalcdf(-1.053171728048290000, -1.052982935276290000, -0.999999999000000000)));
   err = rmax2(err, fabs(0.972550843757766000 - bivariatenormalcdf(4.785178416287600000, 1.919693671247900000, -0.999999990000000000)));
   err = rmax2(err, fabs(0.999998291644901000 - bivariatenormalcdf(4.785178416287600000, 4.785178416287600000, -0.999999990000000000)));
   err = rmax2(err, fabs(0.999998291644901000 - bivariatenormalcdf(4.785178416287600000, 4.785178416295720000, -0.999999990000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-4.852815283224590000, 2.398320119295830000, -0.999999900000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-4.852815283224590000, -4.852815283224590000, -0.999999900000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-4.852815283224590000, -4.852815283224590000, -0.999999900000000000)));
   err = rmax2(err, fabs(0.576135517318684000 - bivariatenormalcdf(0.192020298597275000, 4.695461487450740000, -0.999999000000000000)));
   err = rmax2(err, fabs(0.152273694692214000 - bivariatenormalcdf(0.192020298597275000, 0.192020298597275000, -0.999999000000000000)));
   err = rmax2(err, fabs(0.152273697664791000 - bivariatenormalcdf(0.192020298597275000, 0.192020306187062000, -0.999999000000000000)));
   err = rmax2(err, fabs(0.869148589647661000 - bivariatenormalcdf(2.095780141251770000, 1.211768206209080000, -0.999990000000000000)));
   err = rmax2(err, fabs(0.963898301217005000 - bivariatenormalcdf(2.095780141251770000, 2.095780141251770000, -0.999990000000000000)));
   err = rmax2(err, fabs(0.963898301217035000 - bivariatenormalcdf(2.095780141251770000, 2.095780141252440000, -0.999990000000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-2.654007687508430000, 1.340051767837440000, -0.999900000000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-2.654007687508430000, -2.654007687508430000, -0.999900000000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-2.654007687508430000, -2.654007613149620000, -0.999900000000000000)));
   err = rmax2(err, fabs(0.000000000000000019 - bivariatenormalcdf(1.128363097510700000, -2.781006578069910000, -0.999000000000000000)));
   err = rmax2(err, fabs(0.740833394117601000 - bivariatenormalcdf(1.128363097510700000, 1.128363097510700000, -0.999000000000000000)));
   err = rmax2(err, fabs(0.740862731628071000 - bivariatenormalcdf(1.128363097510700000, 1.128502099120660000, -0.999000000000000000)));
   err = rmax2(err, fabs(0.995654456762395000 - bivariatenormalcdf(3.966506850977000000, 2.626841258388710000, -0.990000000000000000)));
   err = rmax2(err, fabs(0.999927066319845000 - bivariatenormalcdf(3.966506850977000000, 3.966506850977000000, -0.990000000000000000)));
   err = rmax2(err, fabs(0.999927066319846000 - bivariatenormalcdf(3.966506850977000000, 3.966506850981670000, -0.990000000000000000)));
   err = rmax2(err, fabs(0.002769246133985220 - bivariatenormalcdf(-2.717530641700190000, 3.217920162027340000, -0.900000000000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-2.717530641700190000, -2.717530641700190000, -0.900000000000000000)));
   err = rmax2(err, fabs(0.000000000000000000 - bivariatenormalcdf(-2.717530641700190000, -2.717530635181090000, -0.900000000000000000)));
   err = rmax2(err, fabs(0.010079636581695100 - bivariatenormalcdf(-1.811681729272450000, -2.262911120125770000, 0.900000000000000000)));
   err = rmax2(err, fabs(0.021493462833838000 - bivariatenormalcdf(-1.811681729272450000, -1.811681729272450000, 0.900000000000000000)));
   err = rmax2(err, fabs(0.021493462833871500 - bivariatenormalcdf(-1.811681729272450000, -1.811681729271170000, 0.900000000000000000)));
   err = rmax2(err, fabs(0.667398193291227000 - bivariatenormalcdf(1.861468373436860000, 0.432740073549983000, 0.990000000000000000)));
   err = rmax2(err, fabs(0.964688949692122000 - bivariatenormalcdf(1.861468373436860000, 1.861468373436860000, 0.990000000000000000)));
   err = rmax2(err, fabs(0.964688949699170000 - bivariatenormalcdf(1.861468373436860000, 1.861468373617680000, 0.990000000000000000)));
   err = rmax2(err, fabs(0.000000482786767864 - bivariatenormalcdf(-4.898527851968480000, -3.491204153631050000, 0.999000000000000000)));
   err = rmax2(err, fabs(0.000000439041574222 - bivariatenormalcdf(-4.898527851968480000, -4.898527851968480000, 0.999000000000000000)));
   err = rmax2(err, fabs(0.000000439041575582 - bivariatenormalcdf(-4.898527851968480000, -4.898527850755250000, 0.999000000000000000)));
   err = rmax2(err, fabs(0.000416850246666766 - bivariatenormalcdf(-3.341356669094100000, 1.862802982022170000, 0.999900000000000000)));
   err = rmax2(err, fabs(0.000408379488679640 - bivariatenormalcdf(-3.341356669094100000, -3.341356669094100000, 0.999900000000000000)));
   err = rmax2(err, fabs(0.000408379488680111 - bivariatenormalcdf(-3.341356669094100000, -3.341356669093450000, 0.999900000000000000)));
   err = rmax2(err, fabs(0.741641759669778000 - bivariatenormalcdf(4.687494092358740000, 0.648415139929991000, 0.999990000000000000)));
   err = rmax2(err, fabs(0.999998605095178000 - bivariatenormalcdf(4.687494092358740000, 4.687494092358740000, 0.999990000000000000)));
   err = rmax2(err, fabs(0.999998606247630000 - bivariatenormalcdf(4.687494092358740000, 4.687843556049730000, 0.999990000000000000)));
   err = rmax2(err, fabs(0.874547330614982000 - bivariatenormalcdf(2.369093655782270000, 1.148153167494120000, 0.999999000000000000)));
   err = rmax2(err, fabs(0.991070530231016000 - bivariatenormalcdf(2.369093655782270000, 2.369093655782270000, 0.999999000000000000)));
   err = rmax2(err, fabs(0.991070530231065000 - bivariatenormalcdf(2.369093655782270000, 2.369093655786410000, 0.999999000000000000)));
   err = rmax2(err, fabs(0.999362948580782000 - bivariatenormalcdf(4.352384277131720000, 3.221749932900420000, 0.999999900000000000)));
   err = rmax2(err, fabs(0.999993261271150000 - bivariatenormalcdf(4.352384277131720000, 4.352384277131720000, 0.999999900000000000)));
   err = rmax2(err, fabs(0.999993261272904000 - bivariatenormalcdf(4.352384277131720000, 4.352384391237480000, 0.999999900000000000)));
   err = rmax2(err, fabs(0.999069094420465000 - bivariatenormalcdf(3.422289814750960000, 3.111433954663520000, 0.999999990000000000)));
   err = rmax2(err, fabs(0.999689455134645000 - bivariatenormalcdf(3.422289814750960000, 3.422289814750960000, 0.999999990000000000)));
   err = rmax2(err, fabs(0.999689455134658000 - bivariatenormalcdf(3.422289814750960000, 3.422289814777010000, 0.999999990000000000)));
   err = rmax2(err, fabs(0.294719708527162000 - bivariatenormalcdf(-0.539648565868907000, 2.177679562057720000, 0.999999999000000000)));
   err = rmax2(err, fabs(0.294713555379044000 - bivariatenormalcdf(-0.539648565868907000, -0.539648565868907000, 0.999999999000000000)));
   err = rmax2(err, fabs(0.294718518285085000 - bivariatenormalcdf(-0.539648565868907000, -0.539602058260055000, 0.999999999000000000)));
   err = rmax2(err, fabs(0.000002811467986141 - bivariatenormalcdf(-4.540093229575050000, 2.436946780486250000, 0.999999999900000000)));
   err = rmax2(err, fabs(0.000002811392754616 - bivariatenormalcdf(-4.540093229575050000, -4.540093229575050000, 0.999999999900000000)));
   err = rmax2(err, fabs(0.000002811467986126 - bivariatenormalcdf(-4.540093229575050000, -4.540001786779430000, 0.999999999900000000)));
   err = rmax2(err, fabs(0.565106870340374000 - bivariatenormalcdf(0.163929988133744000, 3.995097146641120000, 0.999999999990000000)));
   err = rmax2(err, fabs(0.565106168077456000 - bivariatenormalcdf(0.163929988133744000, 0.163929988133744000, 0.999999999990000000)));
   err = rmax2(err, fabs(0.565106168096292000 - bivariatenormalcdf(0.163929988133744000, 0.163929988229317000, 0.999999999990000000)));
   err = rmax2(err, fabs(0.000064751025417698 - bivariatenormalcdf(3.421155338081630000, -3.827403648909790000, 0.999999999999000000)));
   err = rmax2(err, fabs(0.999688220825439000 - bivariatenormalcdf(3.421155338081630000, 3.421155338081630000, 0.999999999999000000)));
   err = rmax2(err, fabs(0.999688221472430000 - bivariatenormalcdf(3.421155338081630000, 3.421174755498880000, 0.999999999999000000)));
   set_error_flag(errorflag, err > 1.0E-12, __FILE__, __LINE__, "testnormaldistrunit.ap:195");
// Test that BVN PDF is roughly equal to derivative of BVN CDF
   for (k = 0; k <= 999; k++) {
   // Generate trial point
      x = hqrndnormal(&rs);
      y = hqrndnormal(&rs);
      rho = 0.0;
   // Compare two values: normal PDF and differentiation of normal CDF with step H
      h = 1.0E-5;
      v0 = bivariatenormalpdf(x, y, rho);
      v1 = (bivariatenormalcdf(x + h, y + h, rho) + bivariatenormalcdf(x - h, y - h, rho) - bivariatenormalcdf(x + h, y - h, rho) - bivariatenormalcdf(x - h, y + h, rho)) / sqr(2 * h);
      set_error_flag(errorflag, fabs(v0 - v1) > 1.0E-4, __FILE__, __LINE__, "testnormaldistrunit.ap:215");
   }
   ae_frame_leave();
}

bool testnormaldistr(bool silent) {
   bool nrmerr;
   bool bvnerr;
   bool wereerrors;
   bool result;
   nrmerr = false;
   bvnerr = false;
   testnormaldistrunit_testnormal(&nrmerr);
   testnormaldistrunit_testbvn(&bvnerr);
// report
   wereerrors = bvnerr || nrmerr;
   if (!silent) {
      printf("TESTING NORMAL DISTRIBUTION\n");
      printf("NORMAL DISTRIBUTION:                     ");
      if (nrmerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("BIVARIATE NORMALS:                       ");
      if (bvnerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (wereerrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
// end
   result = !wereerrors;
   return result;
}

// === basestat testing unit ===
// This function tests ranking functionality. In case  of  failure  it  sets
// Err parameter to True; this parameter is left unchanged otherwise.
static void testbasestatunit_testranking(bool *err) {
   ae_frame _frame_block;
   ae_int_t testk;
   ae_int_t npoints;
   ae_int_t nfeatures;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_frame_make(&_frame_block);
   NewMatrix(xy0, 0, 0, DT_REAL);
   NewMatrix(xy1, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
// Test 1 - large array, unique ranks, each row is obtained as follows:
// * we generate X[i=0..N-1] = I
// * we add random noise: X[i] := X[i] + 0.2*randomreal()-0.1
// * we perform random permutation
//
// Such dataset has following properties:
// * all data are unique within their rows
// * rank(X[i]) = round(X[i])
//
// We perform several tests with different NPoints/NFeatures.
   for (testk = 0; testk <= 2; testk++) {
   // Select problem size
      if (testk == 0) {
         npoints = 200;
         nfeatures = 1000;
      } else {
         if (testk == 1) {
            npoints = 1000;
            nfeatures = 200;
         } else {
            npoints = iround(sqrt(smpactivationlevel()));
            nfeatures = iround(sqrt(smpactivationlevel()));
         }
      }
   // Generate XY0, XY1, XY2
      ae_matrix_set_length(&xy0, npoints, nfeatures);
      ae_matrix_set_length(&xy1, npoints, nfeatures);
      ae_matrix_set_length(&xy2, npoints, nfeatures);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nfeatures; j++) {
            xy0.xyR[i][j] = j + 0.1 * randommid();
         }
         for (j = 0; j < nfeatures - 1; j++) {
            k = randominteger(nfeatures - j);
            if (k != 0) {
               v = xy0.xyR[i][j];
               xy0.xyR[i][j] = xy0.xyR[i][j + k];
               xy0.xyR[i][j + k] = v;
            }
         }
         for (j = 0; j < nfeatures; j++) {
            xy1.xyR[i][j] = xy0.xyR[i][j];
            xy2.xyR[i][j] = xy0.xyR[i][j];
         }
      }
   // Test uncentered ranks
      rankdata(&xy0, npoints, nfeatures);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nfeatures; j++) {
            if (xy0.xyR[i][j] != round(xy2.xyR[i][j])) {
               *err = true;
            }
         }
      }
   // Test centered ranks:
   // they must be equal to uncentered ranks minus (NFeatures-1)/2
      rankdatacentered(&xy1, npoints, nfeatures);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nfeatures; j++) {
            if (xy1.xyR[i][j] != round(xy2.xyR[i][j]) - (double)(nfeatures - 1) / 2.0) {
               *err = true;
            }
         }
      }
   }
// Test correct handling of tied ranks
   npoints = 3;
   nfeatures = 4;
   ae_matrix_set_length(&xy0, npoints, nfeatures);
   ae_matrix_set_length(&xy1, npoints, nfeatures);
   xy0.xyR[0][0] = 2.25;
   xy0.xyR[0][1] = 3.75;
   xy0.xyR[0][2] = 3.25;
   xy0.xyR[0][3] = 2.25;
   xy0.xyR[1][0] = 2.0;
   xy0.xyR[1][1] = 2.0;
   xy0.xyR[1][2] = 2.0;
   xy0.xyR[1][3] = 7.0;
   xy0.xyR[2][0] = 9.0;
   xy0.xyR[2][1] = 9.0;
   xy0.xyR[2][2] = 9.0;
   xy0.xyR[2][3] = 9.0;
   for (i = 0; i < npoints; i++) {
      for (j = 0; j < nfeatures; j++) {
         xy1.xyR[i][j] = xy0.xyR[i][j];
      }
   }
   rankdata(&xy0, npoints, nfeatures);
   if (fabs(xy0.xyR[0][0] - 0.5) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy0.xyR[0][1] - 3.0) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy0.xyR[0][2] - 2.0) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy0.xyR[0][3] - 0.5) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy0.xyR[1][0] - 1.0) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy0.xyR[1][1] - 1.0) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy0.xyR[1][2] - 1.0) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy0.xyR[1][3] - 3.0) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy0.xyR[2][0] - 1.5) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy0.xyR[2][1] - 1.5) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy0.xyR[2][2] - 1.5) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy0.xyR[2][3] - 1.5) > 10 * machineepsilon) {
      *err = true;
   }
   rankdatacentered(&xy1, npoints, nfeatures);
   if (fabs(xy1.xyR[0][0] + 1.0) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy1.xyR[0][1] - 1.5) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy1.xyR[0][2] - 0.5) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy1.xyR[0][3] + 1.0) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy1.xyR[1][0] + 0.5) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy1.xyR[1][1] + 0.5) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy1.xyR[1][2] + 0.5) > 10 * machineepsilon) {
      *err = true;
   }
   if (fabs(xy1.xyR[1][3] - 1.5) > 10 * machineepsilon) {
      *err = true;
   }
   if (xy1.xyR[2][0] != 0.0) {
      *err = true;
   }
   if (xy1.xyR[2][1] != 0.0) {
      *err = true;
   }
   if (xy1.xyR[2][2] != 0.0) {
      *err = true;
   }
   if (xy1.xyR[2][3] != 0.0) {
      *err = true;
   }
   ae_frame_leave();
}

bool testbasestat(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   bool s1errors;
   bool covcorrerrors;
   bool rankerrors;
   double threshold;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t kx;
   ae_int_t ky;
   ae_int_t ctype;
   ae_int_t cidxx;
   ae_int_t cidxy;
   double mean;
   double variance;
   double skewness;
   double kurtosis;
   double adev;
   double median;
   double pv;
   double v;
   double tmean;
   double tvariance;
   double tskewness;
   double tkurtosis;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(mx, 0, 0, DT_REAL);
   NewMatrix(my, 0, 0, DT_REAL);
   NewMatrix(cc, 0, 0, DT_REAL);
   NewMatrix(cp, 0, 0, DT_REAL);
   NewMatrix(cs, 0, 0, DT_REAL);
// Primary settings
   waserrors = false;
   s1errors = false;
   covcorrerrors = false;
   rankerrors = false;
   threshold = 1000 * machineepsilon;
// Ranking
   testbasestatunit_testranking(&rankerrors);
// * prepare X and Y - two test samples
// * test 1-sample coefficients
// * test for SampleMean, SampleVariance,
//   SampleSkewness, SampleKurtosis.
   n = 10;
   ae_vector_set_length(&x, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = sqr((double)i);
   }
   samplemoments(&x, n, &mean, &variance, &skewness, &kurtosis);
   s1errors = s1errors || fabs(mean - 28.5) > 0.001;
   s1errors = s1errors || fabs(variance - 801.1667) > 0.001;
   s1errors = s1errors || fabs(skewness - 0.5751) > 0.001;
   s1errors = s1errors || fabs(kurtosis + 1.2666) > 0.001;
   tmean = samplemean(&x, n);
   tvariance = samplevariance(&x, n);
   tskewness = sampleskewness(&x, n);
   tkurtosis = samplekurtosis(&x, n);
   s1errors = s1errors || fabs(mean - tmean) > 1.0E-15;
   s1errors = s1errors || fabs(variance - tvariance) > 1.0E-15;
   s1errors = s1errors || fabs(skewness - tskewness) > 1.0E-15;
   s1errors = s1errors || fabs(kurtosis - tkurtosis) > 1.0E-15;
   sampleadev(&x, n, &adev);
   s1errors = s1errors || fabs(adev - 23.2000) > 0.001;
   samplemedian(&x, n, &median);
   s1errors = s1errors || fabs(median - 0.5 * (16 + 25)) > 0.001;
   for (i = 0; i < n; i++) {
      samplepercentile(&x, n, (double)i / (n - 1), &pv);
      s1errors = s1errors || fabs(pv - x.xR[i]) > 0.001;
   }
   samplepercentile(&x, n, 0.5, &pv);
   s1errors = s1errors || fabs(pv - 0.5 * (16 + 25)) > 0.001;
// test covariance/correlation:
// * 2-sample coefficients
//
// We generate random matrices MX and MY
   n = 10;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&y, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = sqr((double)i);
      y.xR[i] = (double)i;
   }
   covcorrerrors = covcorrerrors || fabs(pearsoncorr2(&x, &y, n) - 0.9627) > 0.0001;
   covcorrerrors = covcorrerrors || fabs(spearmancorr2(&x, &y, n) - 1.0000) > 0.0001;
   covcorrerrors = covcorrerrors || fabs(cov2(&x, &y, n) - 82.5000) > 0.0001;
   for (i = 0; i < n; i++) {
      x.xR[i] = sqr(i - 0.5 * n);
      y.xR[i] = (double)i;
   }
   covcorrerrors = covcorrerrors || fabs(pearsoncorr2(&x, &y, n) + 0.3676) > 0.0001;
   covcorrerrors = covcorrerrors || fabs(spearmancorr2(&x, &y, n) + 0.2761) > 0.0001;
   covcorrerrors = covcorrerrors || fabs(cov2(&x, &y, n) + 9.1667) > 0.0001;
// test covariance/correlation:
// * matrix covariance/correlation
// * matrix cross-covariance/cross-correlation
//
// We generate random matrices MX and MY which contain KX (KY)
// columns, all except one are random, one of them is constant.
// We test that function (a) do not crash on constant column,
// and (b) return variances/correlations that are exactly zero
// for this column.
//
// CType control variable controls type of constant: 0 - no constant
// column, 1 - zero column, 2 - nonzero column with value whose
// binary representation contains many non-zero bits. Using such
// type of constant column we are able to ensure than even in the
// presense of roundoff error functions correctly detect constant
// columns.
   for (n = 0; n <= 10; n++) {
      if (n > 0) {
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
      }
      for (ctype = 0; ctype <= 2; ctype++) {
         for (kx = 1; kx <= 10; kx++) {
            for (ky = 1; ky <= 10; ky++) {
            // Fill matrices, add constant column (when CType=1 or =2)
               cidxx = -1;
               cidxy = -1;
               if (n > 0) {
                  ae_matrix_set_length(&mx, n, kx);
                  ae_matrix_set_length(&my, n, ky);
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < kx; j++) {
                        mx.xyR[i][j] = randommid();
                     }
                     for (j = 0; j < ky; j++) {
                        my.xyR[i][j] = randommid();
                     }
                  }
                  if (ctype == 1) {
                     cidxx = randominteger(kx);
                     cidxy = randominteger(ky);
                     for (i = 0; i < n; i++) {
                        mx.xyR[i][cidxx] = 0.0;
                        my.xyR[i][cidxy] = 0.0;
                     }
                  }
                  if (ctype == 2) {
                     cidxx = randominteger(kx);
                     cidxy = randominteger(ky);
                     v = sqrt((double)(randominteger(kx) + 1) / kx);
                     for (i = 0; i < n; i++) {
                        mx.xyR[i][cidxx] = v;
                        my.xyR[i][cidxy] = v;
                     }
                  }
               }
            // test covariance/correlation matrix using
            // 2-sample functions as reference point.
            //
            // We also test that coefficients for constant variables
            // are exactly zero.
               covm(&mx, n, kx, &cc);
               pearsoncorrm(&mx, n, kx, &cp);
               spearmancorrm(&mx, n, kx, &cs);
               for (i = 0; i < kx; i++) {
                  for (j = 0; j < kx; j++) {
                     if (n > 0) {
                        ae_v_move(x.xR, 1, &mx.xyR[0][i], mx.stride, n);
                        ae_v_move(y.xR, 1, &mx.xyR[0][j], mx.stride, n);
                     }
                     covcorrerrors = covcorrerrors || fabs(cov2(&x, &y, n) - cc.xyR[i][j]) > threshold;
                     covcorrerrors = covcorrerrors || fabs(pearsoncorr2(&x, &y, n) - cp.xyR[i][j]) > threshold;
                     covcorrerrors = covcorrerrors || fabs(spearmancorr2(&x, &y, n) - cs.xyR[i][j]) > threshold;
                  }
               }
               if (ctype != 0 && n > 0) {
                  for (i = 0; i < kx; i++) {
                     covcorrerrors = covcorrerrors || cc.xyR[i][cidxx] != 0.0;
                     covcorrerrors = covcorrerrors || cc.xyR[cidxx][i] != 0.0;
                     covcorrerrors = covcorrerrors || cp.xyR[i][cidxx] != 0.0;
                     covcorrerrors = covcorrerrors || cp.xyR[cidxx][i] != 0.0;
                     covcorrerrors = covcorrerrors || cs.xyR[i][cidxx] != 0.0;
                     covcorrerrors = covcorrerrors || cs.xyR[cidxx][i] != 0.0;
                  }
               }
            // test cross-covariance/cross-correlation matrix using
            // 2-sample functions as reference point.
            //
            // We also test that coefficients for constant variables
            // are exactly zero.
               covm2(&mx, &my, n, kx, ky, &cc);
               pearsoncorrm2(&mx, &my, n, kx, ky, &cp);
               spearmancorrm2(&mx, &my, n, kx, ky, &cs);
               for (i = 0; i < kx; i++) {
                  for (j = 0; j < ky; j++) {
                     if (n > 0) {
                        ae_v_move(x.xR, 1, &mx.xyR[0][i], mx.stride, n);
                        ae_v_move(y.xR, 1, &my.xyR[0][j], my.stride, n);
                     }
                     covcorrerrors = covcorrerrors || fabs(cov2(&x, &y, n) - cc.xyR[i][j]) > threshold;
                     covcorrerrors = covcorrerrors || fabs(pearsoncorr2(&x, &y, n) - cp.xyR[i][j]) > threshold;
                     covcorrerrors = covcorrerrors || fabs(spearmancorr2(&x, &y, n) - cs.xyR[i][j]) > threshold;
                  }
               }
               if (ctype != 0 && n > 0) {
                  for (i = 0; i < kx; i++) {
                     covcorrerrors = covcorrerrors || cc.xyR[i][cidxy] != 0.0;
                     covcorrerrors = covcorrerrors || cp.xyR[i][cidxy] != 0.0;
                     covcorrerrors = covcorrerrors || cs.xyR[i][cidxy] != 0.0;
                  }
                  for (j = 0; j < ky; j++) {
                     covcorrerrors = covcorrerrors || cc.xyR[cidxx][j] != 0.0;
                     covcorrerrors = covcorrerrors || cp.xyR[cidxx][j] != 0.0;
                     covcorrerrors = covcorrerrors || cs.xyR[cidxx][j] != 0.0;
                  }
               }
            }
         }
      }
   }
// Final report
   waserrors = (s1errors || covcorrerrors) || rankerrors;
   if (!silent) {
      printf("DESC.STAT TEST\n");
      printf("TOTAL RESULTS:                           ");
      if (!waserrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* 1-SAMPLE FUNCTIONALITY:                ");
      if (!s1errors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* CORRELATION/COVARIATION:               ");
      if (!covcorrerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* RANKING:                               ");
      if (!rankerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST SUMMARY: FAILED\n");
      } else {
         printf("TEST SUMMARY: PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === wsr testing unit ===
bool testwsr(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   ae_int_t n;
   ae_int_t i;
   double taill;
   double tailr;
   double tailb;
   double taillprev;
   double tailrprev;
   double ebase;
   double eshift;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(xa, 0, DT_REAL);
   waserrors = false;
// Test monotonicity of tail values for moving value of E
   for (n = 5; n <= 50; n++) {
   // Generate uniform and sorted X spanning [0,1]
      ae_vector_set_length(&xa, n);
      for (i = 0; i < n; i++) {
         xa.xR[i] = (double)i / (n - 1);
      }
   // Test N+1 values of E
      ebase = -0.5 / (n - 1);
      eshift = 1.0 / (n - 1);
      tailrprev = 0.0;
      taillprev = 1.0;
      for (i = 0; i <= n; i++) {
         wilcoxonsignedranktest(&xa, n, ebase + eshift * i, &tailb, &taill, &tailr);
         set_error_flag(&waserrors, tailb != 2 * rmin2(taill, tailr), __FILE__, __LINE__, "testwsrunit.ap:42");
         set_error_flag(&waserrors, tailrprev > tailr, __FILE__, __LINE__, "testwsrunit.ap:43");
         set_error_flag(&waserrors, taillprev < taill, __FILE__, __LINE__, "testwsrunit.ap:44");
         tailrprev = tailr;
         taillprev = taill;
      }
   }
// Test for integer overflow in the function: if one crucial
// calculation step is performed in 32-bit integer arithmetics,
// it will return incorrect results.
//
// We use special handcrafted N, such that in 32-bit integer
// arithmetics int32(N*N)<0. Such negative N leads to domain
// error in the sqrt() function.
   n = 50000;
   ae_vector_set_length(&xa, n);
   for (i = 0; i < n; i++) {
      xa.xR[i] = sin((double)(10 * i));
   }
   wilcoxonsignedranktest(&xa, n, 0.0, &tailb, &taill, &tailr);
   set_error_flag(&waserrors, !isfinite(tailb), __FILE__, __LINE__, "testwsrunit.ap:64");
   set_error_flag(&waserrors, !isfinite(taill), __FILE__, __LINE__, "testwsrunit.ap:65");
   set_error_flag(&waserrors, !isfinite(tailr), __FILE__, __LINE__, "testwsrunit.ap:66");
//
   if (!silent) {
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === mannwhitneyu testing unit ===
bool testmannwhitneyu(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   ae_int_t testmin;
   ae_int_t testmax;
   ae_int_t testcnt;
   ae_int_t pass;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t k;
   double taill;
   double tailr;
   double tailb;
   double taill1;
   double tailr1;
   double tailb1;
   double taillprev;
   double tailrprev;
   double ebase;
   double eshift;
   ae_int_t ecnt;
   double worsterr;
   double v;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   waserrors = false;
   hqrndrandomize(&rs);
// Test monotonicity of tail values for monotinically moving distributions.
   for (n = 5; n <= 20; n++) {
      for (m = 5; m <= 20; m++) {
      // Generate uniform and sorted X/Y spanning [0,1]
         ae_vector_set_length(&x, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = (double)i / (n - 1) + 100 * machineepsilon * hqrndnormal(&rs);
         }
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            y.xR[i] = (double)i / (m - 1) + 100 * machineepsilon * hqrndnormal(&rs);
         }
      // Test 100 values of E
         ecnt = 100;
         ebase = -1.1;
         eshift = -2 * ebase / (ecnt - 1);
         tailrprev = 0.0;
         taillprev = 1.0;
         for (i = 0; i < m; i++) {
            y.xR[i] += ebase;
         }
         for (k = 0; k < ecnt; k++) {
            mannwhitneyutest(&x, n, &y, m, &tailb, &taill, &tailr);
            set_error_flag(&waserrors, tailb != 2 * rmin2(taill, tailr), __FILE__, __LINE__, "testmannwhitneyuunit.ap:57");
            set_error_flag(&waserrors, tailrprev > tailr, __FILE__, __LINE__, "testmannwhitneyuunit.ap:58");
            set_error_flag(&waserrors, taillprev < taill, __FILE__, __LINE__, "testmannwhitneyuunit.ap:59");
            tailrprev = tailr;
            taillprev = taill;
            for (i = 0; i < m; i++) {
               y.xR[i] += eshift;
            }
         }
      }
   }
// Test frequency of p-value 0.05
   testmin = 5;
   testmax = 50;
   testcnt = 10000;
   worsterr = 0.0;
   for (n = testmin; n <= testmax; n++) {
      m = n + hqrnduniformi(&rs, testmax - n + 1);
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, m);
   // Generate two uniformly distributed values, calculate p-value for both-tails, repeat
      k = 0;
      for (pass = 0; pass < testcnt; pass++) {
         for (i = 0; i < n; i++) {
            x.xR[i] = hqrnduniformr(&rs);
         }
         for (i = 0; i < m; i++) {
            y.xR[i] = hqrnduniformr(&rs);
         }
         mannwhitneyutest(&x, n, &y, m, &tailb, &taill, &tailr);
         if (tailb < 0.05) {
            k++;
         }
      }
      v = fabs((double)k / testcnt - 0.05);
      worsterr = rmax2(worsterr, v);
   // Test error in quantile; for different N's we have different tolerances
      if (n < 10) {
         set_error_flag(&waserrors, v > 0.035, __FILE__, __LINE__, "testmannwhitneyuunit.ap:101");
      } else {
         if (n < 15) {
            set_error_flag(&waserrors, v > 0.025, __FILE__, __LINE__, "testmannwhitneyuunit.ap:103");
         } else {
            if (n < 30) {
               set_error_flag(&waserrors, v > 0.020, __FILE__, __LINE__, "testmannwhitneyuunit.ap:105");
            } else {
               set_error_flag(&waserrors, v > 0.015, __FILE__, __LINE__, "testmannwhitneyuunit.ap:107");
            }
         }
      }
   }
// Test symmetry properties
   for (n = 5; n <= 50; n++) {
      for (m = 5; m <= 50; m++) {
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, m);
         for (i = 0; i < n; i++) {
            x.xR[i] = hqrnduniformr(&rs);
         }
         for (i = 0; i < m; i++) {
            y.xR[i] = hqrnduniformr(&rs);
         }
         mannwhitneyutest(&x, n, &y, m, &tailb, &taill, &tailr);
         mannwhitneyutest(&y, m, &x, n, &tailb1, &taill1, &tailr1);
         set_error_flag(&waserrors, fabs(tailb - tailb1) > 1.0E-12, __FILE__, __LINE__, "testmannwhitneyuunit.ap:126");
         set_error_flag(&waserrors, fabs(taill - tailr1) > 1.0E-12, __FILE__, __LINE__, "testmannwhitneyuunit.ap:127");
         set_error_flag(&waserrors, fabs(tailr - taill1) > 1.0E-12, __FILE__, __LINE__, "testmannwhitneyuunit.ap:128");
      }
   }
// Test for integer overflow in the function: if one crucial
// calculation step is performed in 32-bit integer arithmetics,
// it will return incorrect results.
//
// We use special handcrafted N, such that in 32-bit integer
// arithmetics int32(N*N)<0. Such negative N leads to domain
// error in the sqrt() function.
   n = 50000;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&y, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = sin((double)(10 * i));
      y.xR[i] = sin((double)(13 * i));
   }
   mannwhitneyutest(&x, n, &y, n, &tailb, &taill, &tailr);
   set_error_flag(&waserrors, !isfinite(tailb), __FILE__, __LINE__, "testmannwhitneyuunit.ap:149");
   set_error_flag(&waserrors, !isfinite(taill), __FILE__, __LINE__, "testmannwhitneyuunit.ap:150");
   set_error_flag(&waserrors, !isfinite(tailr), __FILE__, __LINE__, "testmannwhitneyuunit.ap:151");
//
   if (!silent) {
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === stest testing unit ===
bool teststest(bool silent) {
   ae_frame _frame_block;
   double taill;
   double tailr;
   double tailb;
   bool waserrors;
   double eps;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   waserrors = false;
   eps = 1.0E-3;
// Test 1
   ae_vector_set_length(&x, 6);
   x.xR[0] = -3.0;
   x.xR[1] = -2.0;
   x.xR[2] = -1.0;
   x.xR[3] = 1.0;
   x.xR[4] = 2.0;
   x.xR[5] = 3.0;
   onesamplesigntest(&x, 6, 0.0, &tailb, &taill, &tailr);
   waserrors = waserrors || fabs(taill - 0.65625) > eps;
   waserrors = waserrors || fabs(tailr - 0.65625) > eps;
   waserrors = waserrors || fabs(tailb - 1.00000) > eps;
   onesamplesigntest(&x, 6, -1.0, &tailb, &taill, &tailr);
   waserrors = waserrors || fabs(taill - 0.81250) > eps;
   waserrors = waserrors || fabs(tailr - 0.50000) > eps;
   waserrors = waserrors || fabs(tailb - 1.00000) > eps;
   onesamplesigntest(&x, 6, -1.5, &tailb, &taill, &tailr);
   waserrors = waserrors || fabs(taill - 0.89062) > eps;
   waserrors = waserrors || fabs(tailr - 0.34375) > eps;
   waserrors = waserrors || fabs(tailb - 0.68750) > eps;
   onesamplesigntest(&x, 6, -3.0, &tailb, &taill, &tailr);
   waserrors = waserrors || fabs(taill - 1.00000) > eps;
   waserrors = waserrors || fabs(tailr - 0.03125) > eps;
   waserrors = waserrors || fabs(tailb - 0.06250) > eps;
// Test 2
   ae_vector_set_length(&x, 3);
   x.xR[0] = 2.0;
   x.xR[1] = 2.0;
   x.xR[2] = 2.0;
   onesamplesigntest(&x, 3, 2.0, &tailb, &taill, &tailr);
   waserrors = waserrors || taill != 1.0;
   waserrors = waserrors || tailr != 1.0;
   waserrors = waserrors || tailb != 1.0;
// Final report
   if (!silent) {
      printf("SIGN TEST:                               ");
      if (!waserrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST SUMMARY: FAILED\n");
      } else {
         printf("TEST SUMMARY: PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === studentttests testing unit ===
bool teststudentttests(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   double eps;
   ae_int_t n;
   ae_int_t i;
   double taill;
   double tailr;
   double tailb;
   double taill1;
   double tailr1;
   double tailb1;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(xa, 0, DT_REAL);
   NewVector(ya, 0, DT_REAL);
   NewVector(xb, 0, DT_REAL);
   NewVector(yb, 0, DT_REAL);
   waserrors = false;
   eps = 0.001;
// 1-sample test
   n = 8;
   ae_vector_set_length(&x, 8);
   x.xR[0] = -3.0;
   x.xR[1] = -1.5;
   x.xR[2] = -1.0;
   x.xR[3] = -0.5;
   x.xR[4] = 0.5;
   x.xR[5] = 1.0;
   x.xR[6] = 1.5;
   x.xR[7] = 3.0;
   studentttest1(&x, n, 0.0, &tailb, &taill, &tailr);
   waserrors = waserrors || fabs(tailb - 1.00000) > eps;
   waserrors = waserrors || fabs(taill - 0.50000) > eps;
   waserrors = waserrors || fabs(tailr - 0.50000) > eps;
   studentttest1(&x, n, 1.0, &tailb, &taill, &tailr);
   waserrors = waserrors || fabs(tailb - 0.17816) > eps;
   waserrors = waserrors || fabs(taill - 0.08908) > eps;
   waserrors = waserrors || fabs(tailr - 0.91092) > eps;
   studentttest1(&x, n, -1.0, &tailb, &taill, &tailr);
   waserrors = waserrors || fabs(tailb - 0.17816) > eps;
   waserrors = waserrors || fabs(taill - 0.91092) > eps;
   waserrors = waserrors || fabs(tailr - 0.08908) > eps;
   x.xR[0] = 1.1;
   x.xR[1] = 1.1;
   x.xR[2] = 1.1;
   x.xR[3] = 1.1;
   x.xR[4] = 1.1;
   x.xR[5] = 1.1;
   x.xR[6] = 1.1;
   x.xR[7] = 1.1;
   studentttest1(&x, n, 1.1, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 1.0;
   waserrors = waserrors || taill != 1.0;
   waserrors = waserrors || tailr != 1.0;
   studentttest1(&x, n, 0.0, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 0.0;
   waserrors = waserrors || taill != 1.0;
   waserrors = waserrors || tailr != 0.0;
   x.xR[7] = 1.1;
   studentttest1(&x, 1, 1.1, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 1.0;
   waserrors = waserrors || taill != 1.0;
   waserrors = waserrors || tailr != 1.0;
   studentttest1(&x, 1, 0.0, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 0.0;
   waserrors = waserrors || taill != 1.0;
   waserrors = waserrors || tailr != 0.0;
// 2-sample pooled (equal variance) test
   n = 8;
   ae_vector_set_length(&x, 8);
   ae_vector_set_length(&y, 8);
   x.xR[0] = -3.0;
   x.xR[1] = -1.5;
   x.xR[2] = -1.0;
   x.xR[3] = -0.5;
   x.xR[4] = 0.5;
   x.xR[5] = 1.0;
   x.xR[6] = 1.5;
   x.xR[7] = 3.0;
   y.xR[0] = -2.0;
   y.xR[1] = -0.5;
   y.xR[2] = 0.0;
   y.xR[3] = 0.5;
   y.xR[4] = 1.5;
   y.xR[5] = 2.0;
   y.xR[6] = 2.5;
   y.xR[7] = 4.0;
   studentttest2(&x, n, &y, n, &tailb, &taill, &tailr);
   waserrors = waserrors || fabs(tailb - 0.30780) > eps;
   waserrors = waserrors || fabs(taill - 0.15390) > eps;
   waserrors = waserrors || fabs(tailr - 0.84610) > eps;
   studentttest2(&x, n, &y, n - 1, &tailb, &taill, &tailr);
   waserrors = waserrors || fabs(tailb - 0.53853) > eps;
   waserrors = waserrors || fabs(taill - 0.26927) > eps;
   waserrors = waserrors || fabs(tailr - 0.73074) > eps;
   studentttest2(&x, n - 1, &y, n, &tailb, &taill, &tailr);
   waserrors = waserrors || fabs(tailb - 0.13829) > eps;
   waserrors = waserrors || fabs(taill - 0.06915) > eps;
   waserrors = waserrors || fabs(tailr - 0.93086) > eps;
   x.xR[0] = -1.0;
   x.xR[1] = -1.0;
   x.xR[2] = -1.0;
   x.xR[3] = -1.0;
   x.xR[4] = -1.0;
   x.xR[5] = -1.0;
   x.xR[6] = -1.0;
   x.xR[7] = -1.0;
   y.xR[0] = 1.0;
   y.xR[1] = 1.0;
   y.xR[2] = 1.0;
   y.xR[3] = 1.0;
   y.xR[4] = 1.0;
   y.xR[5] = 1.0;
   y.xR[6] = 1.0;
   y.xR[7] = 1.0;
   studentttest2(&x, n, &y, n, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 0.0;
   waserrors = waserrors || taill != 0.0;
   waserrors = waserrors || tailr != 1.0;
   studentttest2(&x, n, &y, n - 1, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 0.0;
   waserrors = waserrors || taill != 0.0;
   waserrors = waserrors || tailr != 1.0;
   studentttest2(&x, n, &y, 1, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 0.0;
   waserrors = waserrors || taill != 0.0;
   waserrors = waserrors || tailr != 1.0;
   studentttest2(&x, n - 1, &y, n, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 0.0;
   waserrors = waserrors || taill != 0.0;
   waserrors = waserrors || tailr != 1.0;
   studentttest2(&x, 1, &y, n, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 0.0;
   waserrors = waserrors || taill != 0.0;
   waserrors = waserrors || tailr != 1.0;
   studentttest2(&x, 1, &y, 1, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 0.0;
   waserrors = waserrors || taill != 0.0;
   waserrors = waserrors || tailr != 1.0;
   studentttest2(&y, 1, &x, 1, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 0.0;
   waserrors = waserrors || taill != 1.0;
   waserrors = waserrors || tailr != 0.0;
   x.xR[0] = 1.1;
   x.xR[1] = 1.1;
   x.xR[2] = 1.1;
   x.xR[3] = 1.1;
   x.xR[4] = 1.1;
   x.xR[5] = 1.1;
   x.xR[6] = 1.1;
   x.xR[7] = 1.1;
   y.xR[0] = 1.1;
   y.xR[1] = 1.1;
   y.xR[2] = 1.1;
   y.xR[3] = 1.1;
   y.xR[4] = 1.1;
   y.xR[5] = 1.1;
   y.xR[6] = 1.1;
   y.xR[7] = 1.1;
   studentttest2(&x, n, &y, n, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 1.0;
   waserrors = waserrors || taill != 1.0;
   waserrors = waserrors || tailr != 1.0;
   studentttest2(&x, n, &y, n - 1, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 1.0;
   waserrors = waserrors || taill != 1.0;
   waserrors = waserrors || tailr != 1.0;
   studentttest2(&x, n, &y, 1, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 1.0;
   waserrors = waserrors || taill != 1.0;
   waserrors = waserrors || tailr != 1.0;
   studentttest2(&x, n - 1, &y, n, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 1.0;
   waserrors = waserrors || taill != 1.0;
   waserrors = waserrors || tailr != 1.0;
   studentttest2(&x, 1, &y, n, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 1.0;
   waserrors = waserrors || taill != 1.0;
   waserrors = waserrors || tailr != 1.0;
   studentttest2(&x, 1, &y, 1, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 1.0;
   waserrors = waserrors || taill != 1.0;
   waserrors = waserrors || tailr != 1.0;
// 2-sample unpooled (unequal variance) test:
// * test on two non-constant samples
// * tests on different combinations of non-constant and constant samples
   n = 8;
   ae_vector_set_length(&xa, 8);
   ae_vector_set_length(&ya, 8);
   ae_vector_set_length(&xb, 8);
   ae_vector_set_length(&yb, 8);
   xa.xR[0] = -3.0;
   xa.xR[1] = -1.5;
   xa.xR[2] = -1.0;
   xa.xR[3] = -0.5;
   xa.xR[4] = 0.5;
   xa.xR[5] = 1.0;
   xa.xR[6] = 1.5;
   xa.xR[7] = 3.0;
   ya.xR[0] = -1.0;
   ya.xR[1] = -0.5;
   ya.xR[2] = 0.0;
   ya.xR[3] = 0.5;
   ya.xR[4] = 1.5;
   ya.xR[5] = 2.0;
   ya.xR[6] = 2.5;
   ya.xR[7] = 3.0;
   xb.xR[0] = -1.1;
   xb.xR[1] = -1.1;
   xb.xR[2] = -1.1;
   xb.xR[3] = -1.1;
   xb.xR[4] = -1.1;
   xb.xR[5] = -1.1;
   xb.xR[6] = -1.1;
   xb.xR[7] = -1.1;
   yb.xR[0] = 1.1;
   yb.xR[1] = 1.1;
   yb.xR[2] = 1.1;
   yb.xR[3] = 1.1;
   yb.xR[4] = 1.1;
   yb.xR[5] = 1.1;
   yb.xR[6] = 1.1;
   yb.xR[7] = 1.1;
   unequalvariancettest(&xa, n, &ya, n, &tailb, &taill, &tailr);
   waserrors = waserrors || fabs(tailb - 0.25791) > eps;
   waserrors = waserrors || fabs(taill - 0.12896) > eps;
   waserrors = waserrors || fabs(tailr - 0.87105) > eps;
   unequalvariancettest(&xa, n, &yb, n, &tailb, &taill, &tailr);
   studentttest1(&xa, n, 1.1, &tailb1, &taill1, &tailr1);
   waserrors = waserrors || fabs(tailb - tailb1) > eps;
   waserrors = waserrors || fabs(taill - taill1) > eps;
   waserrors = waserrors || fabs(tailr - tailr1) > eps;
   unequalvariancettest(&xa, n, &yb, 1, &tailb, &taill, &tailr);
   studentttest1(&xa, n, 1.1, &tailb1, &taill1, &tailr1);
   waserrors = waserrors || fabs(tailb - tailb1) > eps;
   waserrors = waserrors || fabs(taill - taill1) > eps;
   waserrors = waserrors || fabs(tailr - tailr1) > eps;
   unequalvariancettest(&xb, n, &ya, n, &tailb, &taill, &tailr);
   studentttest1(&ya, n, -1.1, &tailb1, &taill1, &tailr1);
   waserrors = waserrors || fabs(tailb - tailb1) > eps;
   waserrors = waserrors || fabs(taill - tailr1) > eps;
   waserrors = waserrors || fabs(tailr - taill1) > eps;
   unequalvariancettest(&xb, 1, &ya, n, &tailb, &taill, &tailr);
   studentttest1(&ya, n, -1.1, &tailb1, &taill1, &tailr1);
   waserrors = waserrors || fabs(tailb - tailb1) > eps;
   waserrors = waserrors || fabs(taill - tailr1) > eps;
   waserrors = waserrors || fabs(tailr - taill1) > eps;
   unequalvariancettest(&xb, 1, &yb, 1, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 0.0;
   waserrors = waserrors || taill != 0.0;
   waserrors = waserrors || tailr != 1.0;
   unequalvariancettest(&yb, 1, &xb, 1, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 0.0;
   waserrors = waserrors || taill != 1.0;
   waserrors = waserrors || tailr != 0.0;
   unequalvariancettest(&xb, 1, &xb, 1, &tailb, &taill, &tailr);
   waserrors = waserrors || tailb != 1.0;
   waserrors = waserrors || taill != 1.0;
   waserrors = waserrors || tailr != 1.0;
// Test for integer overflow in the function: if one crucial
// calculation step is performed in 32-bit integer arithmetics,
// it will return incorrect results.
//
// We use special handcrafted N, such that in 32-bit integer
// arithmetics int32(N*N)<0. Such negative N leads to domain
// error in the incomplete beta function.
   n = 50000;
   ae_vector_set_length(&xa, n);
   ae_vector_set_length(&ya, n);
   for (i = 0; i < n; i++) {
      xa.xR[i] = randomreal();
      ya.xR[i] = randomreal();
   }
   unequalvariancettest(&xa, n, &ya, n, &tailb, &taill, &tailr);
//
   if (!silent) {
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === ratint testing unit ===
static void testratintunit_poldiff2(RVector *x, RVector *f, ae_int_t n, double t, double *p, double *dp, double *d2p) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   DupVector(f);
   *p = 0;
   *dp = 0;
   *d2p = 0;
   NewVector(df, 0, DT_REAL);
   NewVector(d2f, 0, DT_REAL);
   n--;
   ae_vector_set_length(&df, n + 1);
   ae_vector_set_length(&d2f, n + 1);
   for (i = 0; i <= n; i++) {
      d2f.xR[i] = 0.0;
      df.xR[i] = 0.0;
   }
   for (m = 1; m <= n; m++) {
      for (i = 0; i <= n - m; i++) {
         d2f.xR[i] = ((t - x->xR[i + m]) * d2f.xR[i] + (x->xR[i] - t) * d2f.xR[i + 1] + 2 * df.xR[i] - 2 * df.xR[i + 1]) / (x->xR[i] - x->xR[i + m]);
         df.xR[i] = ((t - x->xR[i + m]) * df.xR[i] + f->xR[i] + (x->xR[i] - t) * df.xR[i + 1] - f->xR[i + 1]) / (x->xR[i] - x->xR[i + m]);
         f->xR[i] = ((t - x->xR[i + m]) * f->xR[i] + (x->xR[i] - t) * f->xR[i + 1]) / (x->xR[i] - x->xR[i + m]);
      }
   }
   *p = f->xR[0];
   *dp = df.xR[0];
   *d2p = d2f.xR[0];
   ae_frame_leave();
}

static void testratintunit_brcunset(barycentricinterpolant *b) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   ae_vector_set_length(&x, 1);
   ae_vector_set_length(&y, 1);
   ae_vector_set_length(&w, 1);
   x.xR[0] = 0.0;
   y.xR[0] = 0.0;
   w.xR[0] = 1.0;
   barycentricbuildxyw(&x, &y, &w, 1, b);
   ae_frame_leave();
}

bool testratint(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   bool bcerrors;
   bool nperrors;
   double threshold;
   double lipschitztol;
   ae_int_t passcount;
   double h;
   double s1;
   double s2;
   ae_int_t n;
   ae_int_t n2;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t d;
   ae_int_t pass;
   double maxerr;
   double t;
   double a;
   double b;
   double s;
   double v0;
   double v1;
   double v2;
   double v3;
   double d0;
   double d1;
   double d2;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(barycentricinterpolant, b1);
   NewObj(barycentricinterpolant, b2);
   NewVector(x, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewVector(dc, 0, DT_INT);
   nperrors = false;
   bcerrors = false;
   waserrors = false;
// PassCount        number of repeated passes
// Threshold        error tolerance
// LipschitzTol     Lipschitz constant increase allowed
//                  when calculating constant on a twice denser grid
   passcount = 5;
   threshold = 1000000 * machineepsilon;
   lipschitztol = 1.3;
// Basic barycentric functions
   for (n = 1; n <= 10; n++) {
   // randomized tests
      for (pass = 1; pass <= passcount; pass++) {
      // generate weights from polynomial interpolation
         v0 = 1 + 0.2 * randommid();
         v1 = randommid();
         v2 = randommid();
         v3 = randommid();
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
         ae_vector_set_length(&w, n);
         for (i = 0; i < n; i++) {
            if (n == 1) {
               x.xR[i] = 0.0;
            } else {
               x.xR[i] = v0 * cos(i * pi / (n - 1));
            }
            y.xR[i] = sin(v1 * x.xR[i]) + cos(v2 * x.xR[i]) + exp(v3 * x.xR[i]);
         }
         for (j = 0; j < n; j++) {
            w.xR[j] = 1.0;
            for (k = 0; k < n; k++) {
               if (k != j) {
                  w.xR[j] /= x.xR[j] - x.xR[k];
               }
            }
         }
         barycentricbuildxyw(&x, &y, &w, n, &b1);
      // unpack, then pack again and compare
         testratintunit_brcunset(&b2);
         barycentricunpack(&b1, &n2, &x2, &y2, &w2);
         bcerrors = bcerrors || n2 != n;
         barycentricbuildxyw(&x2, &y2, &w2, n2, &b2);
         t = randommid();
         bcerrors = bcerrors || fabs(barycentriccalc(&b1, t) - barycentriccalc(&b2, t)) > threshold;
      // copy, compare
         testratintunit_brcunset(&b2);
         barycentriccopy(&b1, &b2);
         t = randommid();
         bcerrors = bcerrors || fabs(barycentriccalc(&b1, t) - barycentriccalc(&b2, t)) > threshold;
      // test interpolation properties
         for (i = 0; i < n; i++) {
         // test interpolation at nodes
            bcerrors = bcerrors || fabs(barycentriccalc(&b1, x.xR[i]) - y.xR[i]) > threshold * fabs(y.xR[i]);
         // compare with polynomial interpolation
            t = randommid();
            testratintunit_poldiff2(&x, &y, n, t, &v0, &v1, &v2);
            bcerrors = bcerrors || fabs(barycentriccalc(&b1, t) - v0) > threshold * rmax2(fabs(v0), 1.0);
         // test continuity between nodes
         // calculate Lipschitz constant on two grids -
         // dense and even more dense. If Lipschitz constant
         // on a denser grid is significantly increased,
         // continuity test is failed
            t = 3.0;
            k = 100;
            s1 = 0.0;
            for (j = 0; j < k; j++) {
               v1 = x.xR[i] + (t - x.xR[i]) * j / k;
               v2 = x.xR[i] + (t - x.xR[i]) * (j + 1) / k;
               s1 = rmax2(s1, fabs(barycentriccalc(&b1, v2) - barycentriccalc(&b1, v1)) / fabs(v2 - v1));
            }
            k *= 2;
            s2 = 0.0;
            for (j = 0; j < k; j++) {
               v1 = x.xR[i] + (t - x.xR[i]) * j / k;
               v2 = x.xR[i] + (t - x.xR[i]) * (j + 1) / k;
               s2 = rmax2(s2, fabs(barycentriccalc(&b1, v2) - barycentriccalc(&b1, v1)) / fabs(v2 - v1));
            }
            bcerrors = bcerrors || (s2 > lipschitztol * s1 && s1 > threshold * k);
         }
      // test differentiation properties
         for (i = 0; i < n; i++) {
            t = randommid();
            testratintunit_poldiff2(&x, &y, n, t, &v0, &v1, &v2);
            d0 = 0.0;
            d1 = 0.0;
            d2 = 0.0;
            barycentricdiff1(&b1, t, &d0, &d1);
            bcerrors = bcerrors || fabs(v0 - d0) > threshold * rmax2(fabs(v0), 1.0);
            bcerrors = bcerrors || fabs(v1 - d1) > threshold * rmax2(fabs(v1), 1.0);
            d0 = 0.0;
            d1 = 0.0;
            d2 = 0.0;
            barycentricdiff2(&b1, t, &d0, &d1, &d2);
            bcerrors = bcerrors || fabs(v0 - d0) > threshold * rmax2(fabs(v0), 1.0);
            bcerrors = bcerrors || fabs(v1 - d1) > threshold * rmax2(fabs(v1), 1.0);
            bcerrors = bcerrors || fabs(v2 - d2) > sqrt(threshold) * rmax2(fabs(v2), 1.0);
         }
      // test linear translation
         t = randommid();
         a = randommid();
         b = randommid();
         testratintunit_brcunset(&b2);
         barycentriccopy(&b1, &b2);
         barycentriclintransx(&b2, a, b);
         bcerrors = bcerrors || fabs(barycentriccalc(&b1, a * t + b) - barycentriccalc(&b2, t)) > threshold;
         a = 0.0;
         b = randommid();
         testratintunit_brcunset(&b2);
         barycentriccopy(&b1, &b2);
         barycentriclintransx(&b2, a, b);
         bcerrors = bcerrors || fabs(barycentriccalc(&b1, a * t + b) - barycentriccalc(&b2, t)) > threshold;
         a = randommid();
         b = randommid();
         testratintunit_brcunset(&b2);
         barycentriccopy(&b1, &b2);
         barycentriclintransy(&b2, a, b);
         bcerrors = bcerrors || fabs(a * barycentriccalc(&b1, t) + b - barycentriccalc(&b2, t)) > threshold;
      }
   }
   for (pass = 0; pass <= 3; pass++) {
   // Crash-test: small numbers, large numbers
      ae_vector_set_length(&x, 4);
      ae_vector_set_length(&y, 4);
      ae_vector_set_length(&w, 4);
      h = 1.0;
      if (pass % 2 == 0) {
         h = 100 * minrealnumber;
      }
      if (pass % 2 == 1) {
         h = 0.01 * maxrealnumber;
      }
      x.xR[0] = 0 * h;
      x.xR[1] = 1 * h;
      x.xR[2] = 2 * h;
      x.xR[3] = 3 * h;
      y.xR[0] = 0 * h;
      y.xR[1] = 1 * h;
      y.xR[2] = 2 * h;
      y.xR[3] = 3 * h;
      w.xR[0] = -1 / (x.xR[1] - x.xR[0]);
      w.xR[1] = 1 * (1 / (x.xR[1] - x.xR[0]) + 1 / (x.xR[2] - x.xR[1]));
      w.xR[2] = -1 * (1 / (x.xR[2] - x.xR[1]) + 1 / (x.xR[3] - x.xR[2]));
      w.xR[3] = 1 / (x.xR[3] - x.xR[2]);
      v0 = 0.0;
      if (pass / 2 == 0) {
         v0 = 0.0;
      }
      if (pass / 2 == 1) {
         v0 = 0.6 * h;
      }
      barycentricbuildxyw(&x, &y, &w, 4, &b1);
      t = barycentriccalc(&b1, v0);
      d0 = 0.0;
      d1 = 0.0;
      d2 = 0.0;
      barycentricdiff1(&b1, v0, &d0, &d1);
      bcerrors = bcerrors || fabs(t - v0) > threshold * v0;
      bcerrors = bcerrors || fabs(d0 - v0) > threshold * v0;
      bcerrors = bcerrors || fabs(d1 - 1) > 1000 * threshold;
   }
// crash test: large abscissas, small argument
//
// test for errors in D0 is not very strict
// because renormalization used in Diff1()
// destroys part of precision.
   ae_vector_set_length(&x, 4);
   ae_vector_set_length(&y, 4);
   ae_vector_set_length(&w, 4);
   h = 0.01 * maxrealnumber;
   x.xR[0] = 0 * h;
   x.xR[1] = 1 * h;
   x.xR[2] = 2 * h;
   x.xR[3] = 3 * h;
   y.xR[0] = 0 * h;
   y.xR[1] = 1 * h;
   y.xR[2] = 2 * h;
   y.xR[3] = 3 * h;
   w.xR[0] = -1 / (x.xR[1] - x.xR[0]);
   w.xR[1] = 1 * (1 / (x.xR[1] - x.xR[0]) + 1 / (x.xR[2] - x.xR[1]));
   w.xR[2] = -1 * (1 / (x.xR[2] - x.xR[1]) + 1 / (x.xR[3] - x.xR[2]));
   w.xR[3] = 1 / (x.xR[3] - x.xR[2]);
   v0 = 100 * minrealnumber;
   barycentricbuildxyw(&x, &y, &w, 4, &b1);
   t = barycentriccalc(&b1, v0);
   d0 = 0.0;
   d1 = 0.0;
   d2 = 0.0;
   barycentricdiff1(&b1, v0, &d0, &d1);
   bcerrors = bcerrors || fabs(t) > v0 * (1 + threshold);
   bcerrors = bcerrors || fabs(d0) > v0 * (1 + threshold);
   bcerrors = bcerrors || fabs(d1 - 1) > 1000 * threshold;
// crash test: test safe barycentric formula
   ae_vector_set_length(&x, 4);
   ae_vector_set_length(&y, 4);
   ae_vector_set_length(&w, 4);
   h = 2 * minrealnumber;
   x.xR[0] = 0 * h;
   x.xR[1] = 1 * h;
   x.xR[2] = 2 * h;
   x.xR[3] = 3 * h;
   y.xR[0] = 0 * h;
   y.xR[1] = 1 * h;
   y.xR[2] = 2 * h;
   y.xR[3] = 3 * h;
   w.xR[0] = -1 / (x.xR[1] - x.xR[0]);
   w.xR[1] = 1 * (1 / (x.xR[1] - x.xR[0]) + 1 / (x.xR[2] - x.xR[1]));
   w.xR[2] = -1 * (1 / (x.xR[2] - x.xR[1]) + 1 / (x.xR[3] - x.xR[2]));
   w.xR[3] = 1 / (x.xR[3] - x.xR[2]);
   v0 = minrealnumber;
   barycentricbuildxyw(&x, &y, &w, 4, &b1);
   t = barycentriccalc(&b1, v0);
   bcerrors = bcerrors || fabs(t - v0) / v0 > threshold;
// Testing "No Poles" interpolation
   maxerr = 0.0;
   for (pass = 1; pass < passcount; pass++) {
      ae_vector_set_length(&x, 1);
      ae_vector_set_length(&y, 1);
      x.xR[0] = randommid();
      y.xR[0] = randommid();
      barycentricbuildfloaterhormann(&x, &y, 1, 1, &b1);
      maxerr = rmax2(maxerr, fabs(barycentriccalc(&b1, randommid()) - y.xR[0]));
   }
   for (n = 2; n <= 10; n++) {
   // compare interpolant built by subroutine
   // with interpolant built by hands
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      ae_vector_set_length(&w, n);
      ae_vector_set_length(&w2, n);
   // D=1, non-equidistant nodes
      for (pass = 1; pass <= passcount; pass++) {
      // Initialize X, Y, W
         a = -1 - 1 * randomreal();
         b = 1 + 1 * randomreal();
         for (i = 0; i < n; i++) {
            x.xR[i] = atan((b - a) * i / (n - 1) + a);
         }
         for (i = 0; i < n; i++) {
            y.xR[i] = randommid();
         }
         w.xR[0] = -1 / (x.xR[1] - x.xR[0]);
         s = 1.0;
         for (i = 1; i < n - 1; i++) {
            w.xR[i] = s * (1 / (x.xR[i] - x.xR[i - 1]) + 1 / (x.xR[i + 1] - x.xR[i]));
            s = -s;
         }
         w.xR[n - 1] = s / (x.xR[n - 1] - x.xR[n - 2]);
         for (i = 0; i < n; i++) {
            k = randominteger(n);
            if (k != i) {
               t = x.xR[i];
               x.xR[i] = x.xR[k];
               x.xR[k] = t;
               t = y.xR[i];
               y.xR[i] = y.xR[k];
               y.xR[k] = t;
               t = w.xR[i];
               w.xR[i] = w.xR[k];
               w.xR[k] = t;
            }
         }
      // Build and test
         barycentricbuildfloaterhormann(&x, &y, n, 1, &b1);
         barycentricbuildxyw(&x, &y, &w, n, &b2);
         for (i = 1; i <= 2 * n; i++) {
            t = a + (b - a) * randomreal();
            maxerr = rmax2(maxerr, fabs(barycentriccalc(&b1, t) - barycentriccalc(&b2, t)));
         }
      }
   // D = 0, 1, 2. Equidistant nodes.
      for (d = 0; d <= 2; d++) {
         for (pass = 1; pass <= passcount; pass++) {
         // Skip incorrect (N,D) pairs
            if (n < 2 * d) {
               continue;
            }
         // Initialize X, Y, W
            a = -1 - 1 * randomreal();
            b = 1 + 1 * randomreal();
            for (i = 0; i < n; i++) {
               x.xR[i] = (b - a) * i / (n - 1) + a;
            }
            for (i = 0; i < n; i++) {
               y.xR[i] = randommid();
            }
            s = 1.0;
            if (d == 0) {
               for (i = 0; i < n; i++) {
                  w.xR[i] = s;
                  s = -s;
               }
            }
            if (d == 1) {
               w.xR[0] = -s;
               for (i = 1; i < n - 1; i++) {
                  w.xR[i] = 2 * s;
                  s = -s;
               }
               w.xR[n - 1] = s;
            }
            if (d == 2) {
               w.xR[0] = s;
               w.xR[1] = -3 * s;
               for (i = 2; i < n - 2; i++) {
                  w.xR[i] = 4 * s;
                  s = -s;
               }
               w.xR[n - 2] = 3 * s;
               w.xR[n - 1] = -s;
            }
         // Mix
            for (i = 0; i < n; i++) {
               k = randominteger(n);
               if (k != i) {
                  t = x.xR[i];
                  x.xR[i] = x.xR[k];
                  x.xR[k] = t;
                  t = y.xR[i];
                  y.xR[i] = y.xR[k];
                  y.xR[k] = t;
                  t = w.xR[i];
                  w.xR[i] = w.xR[k];
                  w.xR[k] = t;
               }
            }
         // Build and test
            barycentricbuildfloaterhormann(&x, &y, n, d, &b1);
            barycentricbuildxyw(&x, &y, &w, n, &b2);
            for (i = 1; i <= 2 * n; i++) {
               t = a + (b - a) * randomreal();
               maxerr = rmax2(maxerr, fabs(barycentriccalc(&b1, t) - barycentriccalc(&b2, t)));
            }
         }
      }
   }
   if (maxerr > threshold) {
      nperrors = true;
   }
// report
   waserrors = bcerrors || nperrors;
   if (!silent) {
      printf("TESTING RATIONAL INTERPOLATION\n");
      printf("BASIC BARYCENTRIC FUNCTIONS:             ");
      if (bcerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("FLOATER-HORMANN:                         ");
      if (nperrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
// end
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === idw testing unit ===
// Testing continuity properties: C0 (D=0) or C1 (D=1) continuity.
//
// Error flag is modified on failure, unchanged on success.
static void testidwunit_testcontinuity(idwmodel *model, ae_int_t nx, ae_int_t ny, RVector *x0, RVector *x1, ae_int_t nsteps, ae_int_t d, bool *err) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t cidx;
   double t;
   double lc1;
   double lc2;
   ae_frame_make(&_frame_block);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewMatrix(yy, 0, 0, DT_REAL);
   ae_assert(nsteps >= 10, "TestContinuity: NSteps is too small");
   ae_assert(d == 0 || d == 1, "TestContinuity: incorrect D");
// Compute sequence of function values
   ae_vector_set_length(&xc, nx);
   ae_matrix_set_length(&yy, nsteps, ny);
   for (i = 0; i < nsteps; i++) {
      t = (double)i / (nsteps - 1);
      for (j = 0; j < nx; j++) {
         xc.xR[j] = x0->xR[j] * t + x1->xR[j] * (1 - t);
      }
      idwcalcbuf(model, &xc, &yc);
      for (j = 0; j < ny; j++) {
         yy.xyR[i][j] = yc.xR[j];
      }
   }
// Evaluate all differentiability levels (C0, C1) requested by user
   for (cidx = 0; cidx <= d; cidx++) {
   // Compute Lipschitz constant for original and increased steps
      lc1 = 0.0;
      lc2 = 0.0;
      for (i = 0; i < nsteps - 2; i++) {
         for (j = 0; j < ny; j++) {
            lc1 = rmax2(lc1, fabs(yy.xyR[i][j] - yy.xyR[i + 1][j]));
            lc2 = rmax2(lc2, fabs(yy.xyR[i][j] - yy.xyR[i + 2][j]) / 2);
         }
      }
      set_error_flag(err, lc2 > 1.0E-4 && lc1 > 1.750 * lc2, __FILE__, __LINE__, "testidwunit.ap:67");
   // Differentiate function, repeat one more time
      for (i = 0; i < nsteps - 1; i++) {
         for (j = 0; j < ny; j++) {
            yy.xyR[i][j] = yy.xyR[i + 1][j] - yy.xyR[i][j];
         }
      }
      nsteps--;
   }
   ae_frame_leave();
}

// Test MSTAB; Err is set to True on failure, unchanged otherwise.
static void testidwunit_testcommon(bool *err) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t algotype;
   ae_int_t i;
   ae_int_t i0;
   ae_int_t i1;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   double v;
   double vv;
   bool initdone;
   double shepardp;
   double rbase;
   double tol;
   double mindistinf;
   double refrms;
   double refavg;
   double refmax;
   double refr2;
   double refrss;
   double reftss;
   ae_int_t nx;
   ae_int_t ny;
   double x0;
   double x1;
   double x2;
   ae_int_t continuitytesting;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(idwmodel, model);
   NewObj(idwmodel, model1);
   NewObj(idwbuilder, builder);
   NewObj(idwreport, rep);
   NewObj(idwcalcbuffer, buffer);
   NewObj(hqrndstate, rs);
   NewVector(x, 0, DT_REAL);
   NewVector(xx, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(meany, 0, DT_REAL);
   hqrndrandomize(&rs);
   tol = 1.0E-10;
   mindistinf = 0.05;
// Try all algorithms
   for (algotype = 0; algotype <= 2; algotype++) {
   // Test empty dataset
      for (nx = 1; nx <= 5; nx++) {
         for (ny = 1; ny <= 5; ny++) {
            initdone = false;
            idwbuildercreate(nx, ny, &builder);
            if (algotype == 0) {
               initdone = true;
               shepardp = 1 + (nx + 1) * hqrnduniformr(&rs);
               idwbuildersetalgotextbookshepard(&builder, shepardp);
            }
            if (algotype == 1) {
               initdone = true;
               rbase = pow(2.0, 4 * hqrnduniformr(&rs) - 2);
               idwbuildersetalgotextbookmodshepard(&builder, rbase);
            }
            if (algotype == 2) {
               initdone = true;
               rbase = pow(2.0, 4 * hqrnduniformr(&rs) - 2);
               idwbuildersetalgomstab(&builder, rbase);
            }
            ae_assert(initdone, "TestCommon: unexpected AlgoType");
            if (hqrndnormal(&rs) > 0.0) {
            // Fit and store result directly into the variable
               idwfit(&builder, &model, &rep);
            } else {
            // Fit, store result to temporary, pass through the serializer
               idwfit(&builder, &model1, &rep);
               {
               // This code passes data structure through serializers
               // (serializes it to string and loads back)
                  ae_int_t _local_ssize;
                  ae_frame _local_frame_block;
                  ae_frame_make(&_local_frame_block);
                  NewSerializer(_local_serializer);
                  ae_serializer_alloc_start(&_local_serializer);
                  idwalloc(&_local_serializer, &model1);
                  _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                  NewBlock(_local_dynamic_block, _local_ssize + 1);
                  ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  idwserialize(&_local_serializer, &model1);
                  ae_serializer_stop(&_local_serializer);
                  ae_serializer_init(&_local_serializer);
                  ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  idwunserialize(&_local_serializer, &model);
                  ae_serializer_stop(&_local_serializer);
                  ae_frame_leave();
               }
            }
            idwcreatecalcbuffer(&model, &buffer);
         // Test report
            set_error_flag(err, rep.rmserror != 0.0, __FILE__, __LINE__, "testidwunit.ap:169");
            set_error_flag(err, rep.avgerror != 0.0, __FILE__, __LINE__, "testidwunit.ap:170");
            set_error_flag(err, rep.maxerror != 0.0, __FILE__, __LINE__, "testidwunit.ap:171");
            set_error_flag(err, rep.r2 != 1.0, __FILE__, __LINE__, "testidwunit.ap:172");
         // Test simplified evaluation
            x0 = hqrndnormal(&rs);
            x1 = hqrndnormal(&rs);
            x2 = hqrndnormal(&rs);
            if (nx == 1 && ny == 1) {
               set_error_flag(err, idwcalc1(&model, x0) != 0.0, __FILE__, __LINE__, "testidwunit.ap:181");
            }
            if (nx == 2 && ny == 1) {
               set_error_flag(err, idwcalc2(&model, x0, x1) != 0.0, __FILE__, __LINE__, "testidwunit.ap:183");
            }
            if (nx == 3 && ny == 1) {
               set_error_flag(err, idwcalc3(&model, x0, x1, x2) != 0.0, __FILE__, __LINE__, "testidwunit.ap:185");
            }
         // Test generic evaluation
            ae_vector_set_length(&x, nx);
            for (i = 0; i < nx; i++) {
               x.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&y, 0);
            idwcalc(&model, &x, &y);
            set_error_flag(err, y.cnt != ny, __FILE__, __LINE__, "testidwunit.ap:195");
            if (*err) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < ny; i++) {
               set_error_flag(err, y.xR[i] != 0.0, __FILE__, __LINE__, "testidwunit.ap:199");
            }
            ae_vector_set_length(&y, 0);
            idwcalcbuf(&model, &x, &y);
            set_error_flag(err, y.cnt != ny, __FILE__, __LINE__, "testidwunit.ap:202");
            if (*err) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < ny; i++) {
               set_error_flag(err, y.xR[i] != 0.0, __FILE__, __LINE__, "testidwunit.ap:206");
            }
            ae_vector_set_length(&y, 0);
            idwtscalcbuf(&model, &buffer, &x, &y);
            set_error_flag(err, y.cnt != ny, __FILE__, __LINE__, "testidwunit.ap:209");
            if (*err) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < ny; i++) {
               set_error_flag(err, y.xR[i] != 0.0, __FILE__, __LINE__, "testidwunit.ap:213");
            }
         }
      }
   // Generate random dataset with distinct points, test interpolation
   // properties (target function is reproduced almost exactly, the model
   // is continuous)
      for (pass = 1; pass <= 20; pass++) {
         n = 1 + hqrnduniformi(&rs, 25);
         nx = 1 + hqrnduniformi(&rs, 4);
         ny = 1 + hqrnduniformi(&rs, 4);
         ae_vector_set_length(&x, nx);
         ae_vector_set_length(&xx, nx);
         ae_vector_set_length(&y, ny);
      // Generate dataset with distinct points
         ae_matrix_set_length(&xy, n, nx + ny);
         ae_vector_set_length(&meany, ny);
         for (j = 0; j < ny; j++) {
            meany.xR[j] = 0.0;
         }
         i = 0;
         while (i < n) {
         // Generate random point
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = hqrndnormal(&rs);
            }
         // Test distance between newly generated point and other ones.
         // Repeat point generation if it is too close to some other point.
            v = maxrealnumber;
            for (i0 = 0; i0 < i; i0++) {
               vv = 0.0;
               for (j = 0; j < nx; j++) {
                  vv = rmax2(vv, fabs(xy.xyR[i][j] - xy.xyR[i0][j]));
               }
               v = rmin2(v, vv);
            }
            if (v < mindistinf) {
               continue;
            }
         // Point is accepted
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = hqrndnormal(&rs);
               meany.xR[j] += xy.xyR[i][nx + j] / n;
            }
            i++;
         }
      // Build IDW model
         initdone = false;
         idwbuildercreate(nx, ny, &builder);
         if (algotype == 0) {
            initdone = true;
            shepardp = 1 + (nx + 1) * hqrnduniformr(&rs);
            idwbuildersetalgotextbookshepard(&builder, shepardp);
         }
         if (algotype == 1) {
            initdone = true;
            rbase = pow(2.0, 4 * hqrnduniformr(&rs) - 2);
            idwbuildersetalgotextbookmodshepard(&builder, rbase);
         }
         if (algotype == 2) {
            initdone = true;
            rbase = pow(2.0, 4 * hqrnduniformr(&rs) - 2);
            idwbuildersetalgomstab(&builder, rbase);
         }
         ae_assert(initdone, "TestCommon: unexpected AlgoType");
         idwbuildersetpoints(&builder, &xy, n);
         if (hqrndnormal(&rs) > 0.0) {
         // Fit and store result directly into the variable
            idwfit(&builder, &model, &rep);
         } else {
         // Fit, store result to temporary, pass through the serializer
            idwfit(&builder, &model1, &rep);
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_int_t _local_ssize;
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               idwalloc(&_local_serializer, &model1);
               _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               idwserialize(&_local_serializer, &model1);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               idwunserialize(&_local_serializer, &model);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
         }
         idwcreatecalcbuffer(&model, &buffer);
      // Test error metrics
      //
      // NOTE: we expect that dataset is reproduced exactly
         set_error_flag(err, fabs(rep.rmserror) > tol, __FILE__, __LINE__, "testidwunit.ap:320");
         set_error_flag(err, fabs(rep.avgerror) > tol, __FILE__, __LINE__, "testidwunit.ap:321");
         set_error_flag(err, fabs(rep.maxerror) > tol, __FILE__, __LINE__, "testidwunit.ap:322");
         set_error_flag(err, fabs(rep.r2) < 1 - tol, __FILE__, __LINE__, "testidwunit.ap:323");
      // Test that dataset is actually exactly reproduced
         for (i = 0; i < n; i++) {
         // Test generic evaluation
            for (j = 0; j < nx; j++) {
               x.xR[j] = xy.xyR[i][j];
            }
            ae_vector_set_length(&y, 0);
            idwcalc(&model, &x, &y);
            set_error_flag(err, y.cnt != ny, __FILE__, __LINE__, "testidwunit.ap:337");
            for (j = 0; j < ny; j++) {
               set_error_flag(err, fabs(y.xR[j] - xy.xyR[i][nx + j]) > tol, __FILE__, __LINE__, "testidwunit.ap:339");
            }
            k = hqrnduniformi(&rs, 2 * ny + 1);
            ae_vector_set_length(&y, k);
            for (j = 0; j < y.cnt; j++) {
               y.xR[j] = 0.0;
            }
            idwcalcbuf(&model, &x, &y);
            set_error_flag(err, y.cnt != imax2(ny, k), __FILE__, __LINE__, "testidwunit.ap:346");
            for (j = 0; j < ny; j++) {
               set_error_flag(err, fabs(y.xR[j] - xy.xyR[i][nx + j]) > tol, __FILE__, __LINE__, "testidwunit.ap:348");
            }
            k = hqrnduniformi(&rs, 2 * ny + 1);
            ae_vector_set_length(&y, k);
            for (j = 0; j < y.cnt; j++) {
               y.xR[j] = 0.0;
            }
            idwtscalcbuf(&model, &buffer, &x, &y);
            set_error_flag(err, y.cnt != imax2(ny, k), __FILE__, __LINE__, "testidwunit.ap:355");
            for (j = 0; j < ny; j++) {
               set_error_flag(err, fabs(y.xR[j] - xy.xyR[i][nx + j]) > tol, __FILE__, __LINE__, "testidwunit.ap:357");
            }
         // Specialized 1, 2, 3-dimensional cases
            if (ny == 1) {
               if (nx == 1) {
                  set_error_flag(err, fabs(idwcalc1(&model, x.xR[0]) - xy.xyR[i][nx]) > tol, __FILE__, __LINE__, "testidwunit.ap:366");
               }
               if (nx == 2) {
                  set_error_flag(err, fabs(idwcalc2(&model, x.xR[0], x.xR[1]) - xy.xyR[i][nx]) > tol, __FILE__, __LINE__, "testidwunit.ap:368");
               }
               if (nx == 3) {
                  set_error_flag(err, fabs(idwcalc3(&model, x.xR[0], x.xR[1], x.xR[2]) - xy.xyR[i][nx]) > tol, __FILE__, __LINE__, "testidwunit.ap:370");
               }
            }
         }
      // Test continuity properties:
      // * continuity is guaranteed for original Shepard's method, MSTAB and MSMOOTH
      // * modified Shepard method does not guarantee continuity of the model, but
      //   we can be sure that model is continuous along line connecting two nearest
      //   points
         for (k = 0; k <= 1; k++) {
            i0 = hqrnduniformi(&rs, n);
            for (j = 0; j < nx; j++) {
               x.xR[j] = xy.xyR[i0][j];
            }
            i1 = -1;
            v = maxrealnumber;
            for (i = 0; i < n; i++) {
               vv = 0.0;
               for (j = 0; j < nx; j++) {
                  vv += sqr(x.xR[j] - xy.xyR[i][j]);
               }
               if (vv < v && vv > 0.0) {
                  i1 = i;
                  for (j = 0; j < nx; j++) {
                     xx.xR[j] = xy.xyR[i][j];
                  }
                  v = vv;
               }
            }
            if (i1 < 0) {
               i1 = hqrnduniformi(&rs, n);
               for (j = 0; j < nx; j++) {
                  xx.xR[j] = xy.xyR[i1][j];
               }
            }
            continuitytesting = 1;
            if (algotype == 0) {
               continuitytesting = 0;
            }
            if (algotype == 1) {
               continuitytesting = -1;
            }
            if (continuitytesting >= 0) {
               testidwunit_testcontinuity(&model, nx, ny, &x, &xx, 10000, continuitytesting, err);
            }
         }
      // Test evaluation at remote points
         ae_vector_set_length(&x, nx);
         for (j = 0; j < nx; j++) {
            x.xR[j] = 1.0E20 * (2 * hqrnduniformi(&rs, 2) - 1);
         }
         idwcalc(&model, &x, &y);
         for (j = 0; j < ny; j++) {
            set_error_flag(err, fabs(y.xR[j] - meany.xR[j]) > tol, __FILE__, __LINE__, "testidwunit.ap:424");
         }
      }
   // Generate random dataset with NONDISTINCT points, test approximation
   // properties and error reports.
      for (pass = 1; pass <= 20; pass++) {
         n = 2 * (1 + hqrnduniformi(&rs, 10));
         nx = 1 + hqrnduniformi(&rs, 4);
         ny = 1 + hqrnduniformi(&rs, 4);
         ae_vector_set_length(&x, nx);
         ae_vector_set_length(&xx, nx);
         ae_vector_set_length(&y, ny);
         ae_vector_set_length(&meany, ny);
      // Generate dataset with nondistinct points, each point is repeated;
      // compute reference values of the error metrics
         ae_matrix_set_length(&xy, n, nx + ny);
         refrms = 0.0;
         refavg = 0.0;
         refmax = 0.0;
         refrss = 0.0;
         reftss = 0.0;
         for (j = 0; j < ny; j++) {
            meany.xR[j] = 0.0;
         }
         i = 0;
         while (i < n / 2) {
         // Generate two copies of the same point
            for (j = 0; j < nx + ny; j++) {
               v = hqrndnormal(&rs);
               xy.xyR[2 * i + 0][j] = v;
               xy.xyR[2 * i + 1][j] = v;
            }
         // Test distance between newly generated point and other ones.
         // Repeat point generation if it is too close to some other point.
            v = maxrealnumber;
            for (i0 = 0; i0 < 2 * i; i0++) {
               vv = 0.0;
               for (j = 0; j < nx; j++) {
                  vv = rmax2(vv, fabs(xy.xyR[2 * i + 0][j] - xy.xyR[i0][j]));
               }
               v = rmin2(v, vv);
            }
            if (v < mindistinf) {
               continue;
            }
         // Update meanY
            for (j = 0; j < ny; j++) {
               meany.xR[j] += (xy.xyR[2 * i + 0][nx + j] + xy.xyR[2 * i + 1][nx + j]) / n;
            }
         // Apply perturbation to the target value
            for (j = 0; j < ny; j++) {
               v = pow(2.0, hqrndnormal(&rs));
               xy.xyR[2 * i + 0][nx + j] += v;
               xy.xyR[2 * i + 1][nx + j] -= v;
               v = fabs(v);
               refrms += 2 * v * v;
               refavg += 2 * v;
               refmax = rmax2(refmax, v);
               refrss += 2 * v * v;
            }
         // Next I
            i++;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < ny; j++) {
               reftss += sqr(xy.xyR[i][nx + j] - meany.xR[j]);
            }
         }
         refrms = sqrt(refrms / (n * ny));
         refavg /= n * ny;
         refr2 = 1.0 - refrss / coalesce(reftss, 1.0);
      // Build IDW model
         initdone = false;
         idwbuildercreate(nx, ny, &builder);
         if (algotype == 0) {
            initdone = true;
            shepardp = nx * (1 + hqrnduniformr(&rs));
            idwbuildersetalgotextbookshepard(&builder, shepardp);
         }
         if (algotype == 1) {
            initdone = true;
            rbase = pow(2.0, 4 * hqrnduniformr(&rs) - 2);
            idwbuildersetalgotextbookmodshepard(&builder, rbase);
         }
         if (algotype == 2) {
            initdone = true;
            rbase = pow(2.0, 4 * hqrnduniformr(&rs) - 2);
            idwbuildersetalgomstab(&builder, rbase);
         }
         ae_assert(initdone, "TestCommon: unexpected AlgoType");
         idwbuildersetpoints(&builder, &xy, n);
         if (hqrndnormal(&rs) > 0.0) {
         // Fit and store result directly into the variable
            idwfit(&builder, &model, &rep);
         } else {
         // Fit, store result to temporary, pass through the serializer
            idwfit(&builder, &model1, &rep);
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_int_t _local_ssize;
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               idwalloc(&_local_serializer, &model1);
               _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               idwserialize(&_local_serializer, &model1);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               idwunserialize(&_local_serializer, &model);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
         }
         idwcreatecalcbuffer(&model, &buffer);
      // Test error metrics
         set_error_flag(err, fabs(rep.rmserror - refrms) > tol, __FILE__, __LINE__, "testidwunit.ap:562");
         set_error_flag(err, fabs(rep.avgerror - refavg) > tol, __FILE__, __LINE__, "testidwunit.ap:563");
         set_error_flag(err, fabs(rep.maxerror - refmax) > tol, __FILE__, __LINE__, "testidwunit.ap:564");
         set_error_flag(err, fabs(rep.r2 - refr2) > tol, __FILE__, __LINE__, "testidwunit.ap:565");
      // Test ability to reproduce mean over non-distinct points
      //
      // NOTE: we do not test all evaluation functions, just IDWCalc()
         for (i = 0; i < n / 2; i++) {
            for (j = 0; j < nx; j++) {
               x.xR[j] = xy.xyR[2 * i + 0][j];
            }
            idwcalc(&model, &x, &y);
            for (j = 0; j < ny; j++) {
               set_error_flag(err, fabs(y.xR[j] - 0.5 * (xy.xyR[2 * i + 0][nx + j] + xy.xyR[2 * i + 1][nx + j])) > tol, __FILE__, __LINE__, "testidwunit.ap:578");
            }
         }
      // Test continuity properties:
      // * continuity is guaranteed for original Shepard's method, MSTAB and MSMOOTH
      // * modified Shepard method does not guarantee continuity of the model, but
      //   we can be sure that model is continuous along line connecting two nearest
      //   points
         for (k = 0; k <= 1; k++) {
            i0 = hqrnduniformi(&rs, n);
            for (j = 0; j < nx; j++) {
               x.xR[j] = xy.xyR[i0][j];
            }
            i1 = -1;
            v = maxrealnumber;
            for (i = 0; i < n; i++) {
               vv = 0.0;
               for (j = 0; j < nx; j++) {
                  vv += sqr(x.xR[j] - xy.xyR[i][j]);
               }
               if (vv < v && vv > 0.0) {
                  i1 = i;
                  for (j = 0; j < nx; j++) {
                     xx.xR[j] = xy.xyR[i][j];
                  }
                  v = vv;
               }
            }
            if (i1 < 0) {
               i1 = hqrnduniformi(&rs, n);
               for (j = 0; j < nx; j++) {
                  xx.xR[j] = xy.xyR[i1][j];
               }
            }
            continuitytesting = 1;
            if (algotype == 0) {
               continuitytesting = 0;
            }
            if (algotype == 1) {
               continuitytesting = -1;
            }
            if (continuitytesting >= 0) {
               testidwunit_testcontinuity(&model, nx, ny, &x, &xx, 10000, continuitytesting, err);
            }
         }
      }
   // Test correct handling of the prior term
      n = 10;
      for (pass = 1; pass <= 20; pass++) {
         nx = 1 + hqrnduniformi(&rs, 4);
         ny = 1 + hqrnduniformi(&rs, 4);
         ae_vector_set_length(&x, nx);
         ae_vector_set_length(&y, ny);
         ae_matrix_set_length(&xy, n, nx + ny);
         ae_vector_set_length(&meany, ny);
         for (j = 0; j < ny; j++) {
            meany.xR[j] = 0.0;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = hqrndnormal(&rs);
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = hqrndnormal(&rs);
               meany.xR[j] += xy.xyR[i][nx + j] / n;
            }
         }
         initdone = false;
         idwbuildercreate(nx, ny, &builder);
         if (algotype == 0) {
            initdone = true;
            shepardp = 1 + (nx + 1) * hqrnduniformr(&rs);
            idwbuildersetalgotextbookshepard(&builder, shepardp);
         }
         if (algotype == 1) {
            initdone = true;
            rbase = pow(2.0, 4 * hqrnduniformr(&rs) - 2);
            idwbuildersetalgotextbookmodshepard(&builder, rbase);
         }
         if (algotype == 2) {
            initdone = true;
            rbase = pow(2.0, 4 * hqrnduniformr(&rs) - 2);
            idwbuildersetalgomstab(&builder, rbase);
         }
         ae_assert(initdone, "TestCommon: unexpected AlgoType (prior test)");
         idwbuildersetpoints(&builder, &xy, n);
      // Zero prior (not tested with textbook Shepard method)
         if (algotype != 0) {
            idwbuildersetzeroterm(&builder);
            idwfit(&builder, &model, &rep);
            for (j = 0; j < nx; j++) {
               x.xR[j] = 1.0E20 * (2 * hqrnduniformi(&rs, 2) - 1);
            }
            idwcalc(&model, &x, &y);
            for (j = 0; j < ny; j++) {
               set_error_flag(err, fabs(y.xR[j]) > tol, __FILE__, __LINE__, "testidwunit.ap:684");
            }
         }
      // Mean prior
         idwbuildersetconstterm(&builder);
         idwfit(&builder, &model, &rep);
         for (j = 0; j < nx; j++) {
            x.xR[j] = 1.0E20 * (2 * hqrnduniformi(&rs, 2) - 1);
         }
         idwcalc(&model, &x, &y);
         for (j = 0; j < ny; j++) {
            set_error_flag(err, fabs(y.xR[j] - meany.xR[j]) > tol, __FILE__, __LINE__, "testidwunit.ap:696");
         }
      // User-specified prior (not tested with textbook Shepard method)
         if (algotype != 0) {
            v = hqrndnormal(&rs);
            idwbuildersetuserterm(&builder, v);
            idwfit(&builder, &model, &rep);
            for (j = 0; j < nx; j++) {
               x.xR[j] = 1.0E20 * (2 * hqrnduniformi(&rs, 2) - 1);
            }
            idwcalc(&model, &x, &y);
            for (j = 0; j < ny; j++) {
               set_error_flag(err, fabs(y.xR[j] - v) > tol, __FILE__, __LINE__, "testidwunit.ap:710");
            }
         }
      }
   }
   ae_frame_leave();
}

// Test MSTAB; Err is set to True on failure, unchanged otherwise.
static void testidwunit_testmstab(bool *err) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t n;
   double v;
   double vv;
   double x0;
   double x1;
   double rbase;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(idwmodel, model);
   NewObj(idwbuilder, builder);
   NewObj(idwreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Basic test #1: nonzero derivative
// * XY = [[-1,-1],[0,0,],[1,1]]
// * RBase >= 2
// * derivative at x=0 must be positive and bigger than 0.1
   ae_matrix_set_length(&xy, 3, 2);
   for (i = 0; i <= 2; i++) {
      xy.xyR[i][0] = (double)(i - 1);
      xy.xyR[i][1] = (double)(i - 1);
   }
   idwbuildercreate(1, 1, &builder);
   rbase = pow(2.0, 1.0 + hqrnduniformr(&rs));
   idwbuildersetalgomstab(&builder, rbase);
   idwbuildersetpoints(&builder, &xy, 3);
   idwfit(&builder, &model, &rep);
   v = 0.01;
   set_error_flag(err, (idwcalc1(&model, v) - idwcalc1(&model, -v)) / (2 * v) < 0.1, __FILE__, __LINE__, "testidwunit.ap:758");
// Basic test #2: good smoothness
// * 2D task, dataset is composed from 3 parallel lines
//   along y=-0.1, y=0, y=+0.1, with outer lines having
//   constant zero target value, inner line having constant
//   target equal to 1
// * RBase=1 is used
// * we test that function value does not change significantly
//   along the line
   n = 100;
   ae_matrix_set_length(&xy, 3 * n, 3);
   for (i = 0; i < n; i++) {
      xy.xyR[3 * i + 0][0] = (double)i / (n - 1);
      xy.xyR[3 * i + 0][1] = -0.1;
      xy.xyR[3 * i + 0][2] = 0.0;
      xy.xyR[3 * i + 1][0] = (double)i / (n - 1);
      xy.xyR[3 * i + 1][1] = 0.0;
      xy.xyR[3 * i + 1][2] = 1.0;
      xy.xyR[3 * i + 2][0] = (double)i / (n - 1);
      xy.xyR[3 * i + 2][1] = 0.1;
      xy.xyR[3 * i + 2][2] = 0.0;
   }
   rbase = 1.0;
   idwbuildercreate(2, 1, &builder);
   idwbuildersetalgomstab(&builder, rbase);
   idwbuildersetpoints(&builder, &xy, 3 * n);
   idwfit(&builder, &model, &rep);
   v = 0.0;
   for (i = 0; i <= 1000; i++) {
      v = rmax2(v, fabs(idwcalc2(&model, hqrnduniformr(&rs), -0.1)));
      v = rmax2(v, fabs(idwcalc2(&model, hqrnduniformr(&rs), 0.1)));
      v = rmax2(v, fabs(idwcalc2(&model, hqrnduniformr(&rs), 0.0) - 1));
   }
   set_error_flag(err, v > 0.001, __FILE__, __LINE__, "testidwunit.ap:796");
// Continuity when moving away from the dataset
   ae_matrix_set_length(&xy, 1, 2);
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = 1.0;
   rbase = 1.0;
   idwbuildercreate(1, 1, &builder);
   idwbuildersetalgomstab(&builder, rbase);
   idwbuildersetpoints(&builder, &xy, 1);
   idwbuildersetzeroterm(&builder);
   idwfit(&builder, &model, &rep);
   set_error_flag(err, idwcalc1(&model, 100000.0) != 0.0, __FILE__, __LINE__, "testidwunit.ap:810");
   v = 0.0;
   for (i = 0; i <= 500; i++) {
      x0 = 1.2 * rbase * ((double)i / 500.0);
      x1 = 1.2 * rbase * ((double)(i + 1) / 500.0);
      v = rmax2(v, fabs((idwcalc1(&model, x1) - idwcalc1(&model, x0)) / (x1 - x0)));
   }
   vv = 0.0;
   for (i = 0; i <= 1000; i++) {
      x0 = 1.2 * rbase * ((double)i / 1000.0);
      x1 = 1.2 * rbase * ((double)(i + 1) / 1000.0);
      vv = rmax2(vv, fabs((idwcalc1(&model, x1) - idwcalc1(&model, x0)) / (x1 - x0)));
   }
   set_error_flag(err, vv / v > 1.333, __FILE__, __LINE__, "testidwunit.ap:825");
   ae_frame_leave();
}

// Testing IDW interpolation
bool testidw(bool silent) {
   bool waserrors;
   bool commonerrors;
   bool mstaberrors;
   bool result;
   commonerrors = false;
   mstaberrors = false;
   testidwunit_testcommon(&commonerrors);
   testidwunit_testmstab(&mstaberrors);
   waserrors = commonerrors || mstaberrors;
   if (!silent) {
      printf("TESTING INVERSE DISTANCE WEIGHTING\n");
      printf("* common properties                      ");
      if (!commonerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* MSTAB-specific tests                   ");
      if (!mstaberrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === polint testing unit ===
static double testpolintunit_internalpolint(RVector *x, RVector *f, ae_int_t n, double t) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double result;
   ae_frame_make(&_frame_block);
   DupVector(f);
   n--;
   for (j = 0; j < n; j++) {
      for (i = j + 1; i <= n; i++) {
         f->xR[i] = ((t - x->xR[j]) * f->xR[i] - (t - x->xR[i]) * f->xR[j]) / (x->xR[i] - x->xR[j]);
      }
   }
   result = f->xR[n];
   ae_frame_leave();
   return result;
}

static void testpolintunit_brcunset(barycentricinterpolant *b) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   ae_vector_set_length(&x, 1);
   ae_vector_set_length(&y, 1);
   ae_vector_set_length(&w, 1);
   x.xR[0] = 0.0;
   y.xR[0] = 0.0;
   w.xR[0] = 1.0;
   barycentricbuildxyw(&x, &y, &w, 1, b);
   ae_frame_leave();
}

// Unit test
bool testpolint(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   bool interrors;
   double threshold;
   double a;
   double b;
   double t;
   ae_int_t i;
   ae_int_t k;
   double v;
   double v0;
   double v1;
   double v2;
   double v3;
   double v4;
   double pscale;
   double poffset;
   double eps;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t pass;
   ae_int_t passcount;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(c, 0, DT_REAL);
   NewVector(c0, 0, DT_REAL);
   NewVector(c1, 0, DT_REAL);
   NewVector(c2, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(xfull, 0, DT_REAL);
   NewVector(yfull, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewVector(dc, 0, DT_INT);
   NewObj(barycentricinterpolant, p);
   NewObj(barycentricinterpolant, p1);
   NewObj(barycentricinterpolant, p2);
   waserrors = false;
   interrors = false;
   maxn = 5;
   passcount = 20;
   threshold = 1.0E8 * machineepsilon;
// Test equidistant interpolation
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
      // prepare task:
      // * equidistant points
      // * random Y
      // * T in [A,B] or near (within 10% of its width)
         do {
            a = randommid();
            b = randommid();
         } while (fabs(a - b) <= 0.2);
         t = a + (1.2 * randomreal() - 0.1) * (b - a);
         taskgenint1dequidist(a, b, n, &x, &y);
      // test "fast" equidistant interpolation (no barycentric model)
         interrors = interrors || fabs(polynomialcalceqdist(a, b, &y, n, t) - testpolintunit_internalpolint(&x, &y, n, t)) > threshold;
      // test "slow" equidistant interpolation (create barycentric model)
         testpolintunit_brcunset(&p);
         polynomialbuild(&x, &y, n, &p);
         interrors = interrors || fabs(barycentriccalc(&p, t) - testpolintunit_internalpolint(&x, &y, n, t)) > threshold;
      // test "fast" interpolation (create "fast" barycentric model)
         testpolintunit_brcunset(&p);
         polynomialbuildeqdist(a, b, &y, n, &p);
         interrors = interrors || fabs(barycentriccalc(&p, t) - testpolintunit_internalpolint(&x, &y, n, t)) > threshold;
      }
   }
// Test Chebyshev-1 interpolation
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
      // prepare task:
      // * equidistant points
      // * random Y
      // * T in [A,B] or near (within 10% of its width)
         do {
            a = randommid();
            b = randommid();
         } while (fabs(a - b) <= 0.2);
         t = a + (1.2 * randomreal() - 0.1) * (b - a);
         taskgenint1dcheb1(a, b, n, &x, &y);
      // test "fast" interpolation (no barycentric model)
         interrors = interrors || fabs(polynomialcalccheb1(a, b, &y, n, t) - testpolintunit_internalpolint(&x, &y, n, t)) > threshold;
      // test "slow" interpolation (create barycentric model)
         testpolintunit_brcunset(&p);
         polynomialbuild(&x, &y, n, &p);
         interrors = interrors || fabs(barycentriccalc(&p, t) - testpolintunit_internalpolint(&x, &y, n, t)) > threshold;
      // test "fast" interpolation (create "fast" barycentric model)
         testpolintunit_brcunset(&p);
         polynomialbuildcheb1(a, b, &y, n, &p);
         interrors = interrors || fabs(barycentriccalc(&p, t) - testpolintunit_internalpolint(&x, &y, n, t)) > threshold;
      }
   }
// Test Chebyshev-2 interpolation
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
      // prepare task:
      // * equidistant points
      // * random Y
      // * T in [A,B] or near (within 10% of its width)
         do {
            a = randommid();
            b = randommid();
         } while (fabs(a - b) <= 0.2);
         t = a + (1.2 * randomreal() - 0.1) * (b - a);
         taskgenint1dcheb2(a, b, n, &x, &y);
      // test "fast" interpolation (no barycentric model)
         interrors = interrors || fabs(polynomialcalccheb2(a, b, &y, n, t) - testpolintunit_internalpolint(&x, &y, n, t)) > threshold;
      // test "slow" interpolation (create barycentric model)
         testpolintunit_brcunset(&p);
         polynomialbuild(&x, &y, n, &p);
         interrors = interrors || fabs(barycentriccalc(&p, t) - testpolintunit_internalpolint(&x, &y, n, t)) > threshold;
      // test "fast" interpolation (create "fast" barycentric model)
         testpolintunit_brcunset(&p);
         polynomialbuildcheb2(a, b, &y, n, &p);
         interrors = interrors || fabs(barycentriccalc(&p, t) - testpolintunit_internalpolint(&x, &y, n, t)) > threshold;
      }
   }
// Testing conversion Barycentric<->Chebyshev
   for (pass = 1; pass <= passcount; pass++) {
      for (k = 1; k <= 3; k++) {
      // Allocate
         ae_vector_set_length(&x, k);
         ae_vector_set_length(&y, k);
      // Generate problem
         a = randommid();
         b = a + (0.1 + randomreal()) * (2 * randominteger(2) - 1);
         v0 = randommid();
         v1 = randommid();
         v2 = randommid();
         if (k == 1) {
            x.xR[0] = 0.5 * (a + b);
            y.xR[0] = v0;
         }
         if (k == 2) {
            x.xR[0] = a;
            y.xR[0] = v0 - v1;
            x.xR[1] = b;
            y.xR[1] = v0 + v1;
         }
         if (k == 3) {
            x.xR[0] = a;
            y.xR[0] = v0 - v1 + v2;
            x.xR[1] = 0.5 * (a + b);
            y.xR[1] = v0 - v2;
            x.xR[2] = b;
            y.xR[2] = v0 + v1 + v2;
         }
      // Test forward conversion
         polynomialbuild(&x, &y, k, &p);
         ae_vector_set_length(&c, 1);
         polynomialbar2cheb(&p, a, b, &c);
         interrors = interrors || c.cnt != k;
         if (k >= 1) {
            interrors = interrors || fabs(c.xR[0] - v0) > threshold;
         }
         if (k >= 2) {
            interrors = interrors || fabs(c.xR[1] - v1) > threshold;
         }
         if (k >= 3) {
            interrors = interrors || fabs(c.xR[2] - v2) > threshold;
         }
      // Test backward conversion
         polynomialcheb2bar(&c, k, a, b, &p2);
         v = a + randomreal() * (b - a);
         interrors = interrors || fabs(barycentriccalc(&p, v) - barycentriccalc(&p2, v)) > threshold;
      }
   }
// Testing conversion Barycentric<->Power
   for (pass = 1; pass <= passcount; pass++) {
      for (k = 1; k <= 5; k++) {
      // Allocate
         ae_vector_set_length(&x, k);
         ae_vector_set_length(&y, k);
      // Generate problem
         poffset = randommid();
         pscale = (0.1 + randomreal()) * (2 * randominteger(2) - 1);
         v0 = randommid();
         v1 = randommid();
         v2 = randommid();
         v3 = randommid();
         v4 = randommid();
         if (k == 1) {
            x.xR[0] = poffset;
            y.xR[0] = v0;
         }
         if (k == 2) {
            x.xR[0] = poffset - pscale;
            y.xR[0] = v0 - v1;
            x.xR[1] = poffset + pscale;
            y.xR[1] = v0 + v1;
         }
         if (k == 3) {
            x.xR[0] = poffset - pscale;
            y.xR[0] = v0 - v1 + v2;
            x.xR[1] = poffset;
            y.xR[1] = v0;
            x.xR[2] = poffset + pscale;
            y.xR[2] = v0 + v1 + v2;
         }
         if (k == 4) {
            x.xR[0] = poffset - pscale;
            y.xR[0] = v0 - v1 + v2 - v3;
            x.xR[1] = poffset - 0.5 * pscale;
            y.xR[1] = v0 - 0.5 * v1 + 0.25 * v2 - 0.125 * v3;
            x.xR[2] = poffset + 0.5 * pscale;
            y.xR[2] = v0 + 0.5 * v1 + 0.25 * v2 + 0.125 * v3;
            x.xR[3] = poffset + pscale;
            y.xR[3] = v0 + v1 + v2 + v3;
         }
         if (k == 5) {
            x.xR[0] = poffset - pscale;
            y.xR[0] = v0 - v1 + v2 - v3 + v4;
            x.xR[1] = poffset - 0.5 * pscale;
            y.xR[1] = v0 - 0.5 * v1 + 0.25 * v2 - 0.125 * v3 + 0.0625 * v4;
            x.xR[2] = poffset;
            y.xR[2] = v0;
            x.xR[3] = poffset + 0.5 * pscale;
            y.xR[3] = v0 + 0.5 * v1 + 0.25 * v2 + 0.125 * v3 + 0.0625 * v4;
            x.xR[4] = poffset + pscale;
            y.xR[4] = v0 + v1 + v2 + v3 + v4;
         }
      // Test forward conversion
         polynomialbuild(&x, &y, k, &p);
         ae_vector_set_length(&c, 1);
         polynomialbar2pow(&p, poffset, pscale, &c);
         interrors = interrors || c.cnt != k;
         if (k >= 1) {
            interrors = interrors || fabs(c.xR[0] - v0) > threshold;
         }
         if (k >= 2) {
            interrors = interrors || fabs(c.xR[1] - v1) > threshold;
         }
         if (k >= 3) {
            interrors = interrors || fabs(c.xR[2] - v2) > threshold;
         }
         if (k >= 4) {
            interrors = interrors || fabs(c.xR[3] - v3) > threshold;
         }
         if (k >= 5) {
            interrors = interrors || fabs(c.xR[4] - v4) > threshold;
         }
      // Test backward conversion
         polynomialpow2bar(&c, k, poffset, pscale, &p2);
         v = poffset + randommid() * pscale;
         interrors = interrors || fabs(barycentriccalc(&p, v) - barycentriccalc(&p2, v)) > threshold;
      }
   }
// crash-test: ability to solve tasks which will overflow/underflow
// weights with straightforward implementation
   for (n = 1; n <= 20; n++) {
      a = -0.1 * maxrealnumber;
      b = 0.1 * maxrealnumber;
      taskgenint1dequidist(a, b, n, &x, &y);
      polynomialbuild(&x, &y, n, &p);
      for (i = 0; i < n; i++) {
         interrors = interrors || p.w.xR[i] == 0.0;
      }
   }
// Test issue #634: instability in PolynomialBar2Pow().
//
// Function returns incorrect coefficients when called with
// approximately-unit scale for data which have significantly
// non-unit scale.
   n = 7;
   eps = 1.0E-8;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&x2, n);
   ae_vector_set_length(&y, n);
   x.xR[0] = randomreal() - 0.5;
   y.xR[0] = randomreal() - 0.5;
   for (i = 1; i < n; i++) {
      x.xR[i] = x.xR[i - 1] + randomreal() + 0.1;
      y.xR[i] = randomreal() - 0.5;
   }
   polynomialbuild(&x, &y, n, &p);
   polynomialbar2pow(&p, 0.0, 1.0, &c0);
   pscale = 1.0E-10;
   for (i = 0; i < n; i++) {
      x2.xR[i] = x.xR[i] * pscale;
   }
   polynomialbuild(&x2, &y, n, &p);
   polynomialbar2pow(&p, 0.0, 1.0, &c1);
   for (i = 0; i < n; i++) {
      set_error_flag(&interrors, fabs(c0.xR[i] - c1.xR[i] * pow(pscale, (double)i)) > eps, __FILE__, __LINE__, "testpolintunit.ap:395");
   }
   pscale = 1.0E10;
   for (i = 0; i < n; i++) {
      x2.xR[i] = x.xR[i] * pscale;
   }
   polynomialbuild(&x2, &y, n, &p);
   polynomialbar2pow(&p, 0.0, 1.0, &c2);
   for (i = 0; i < n; i++) {
      set_error_flag(&interrors, fabs(c0.xR[i] - c2.xR[i] * pow(pscale, (double)i)) > eps, __FILE__, __LINE__, "testpolintunit.ap:402");
   }
// report
   waserrors = interrors;
   if (!silent) {
      printf("TESTING POLYNOMIAL INTERPOLATION\n");
   // Normal tests
      printf("INTERPOLATION TEST:                      ");
      if (interrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
// end
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === spline1d testing unit ===
// Lipschitz constants for spline itself, first and second derivatives.
static void testspline1dunit_lconst(double a, double b, spline1dinterpolant *c, double lstep, double *l0, double *l1, double *l2) {
   double t;
   double vl;
   double vm;
   double vr;
   double prevf;
   double prevd;
   double prevd2;
   double f;
   double d;
   double d2;
   *l0 = 0;
   *l1 = 0;
   *l2 = 0;
   *l0 = 0.0;
   *l1 = 0.0;
   *l2 = 0.0;
   t = a - 0.1;
   vl = spline1dcalc(c, t - 2 * lstep);
   vm = spline1dcalc(c, t - lstep);
   vr = spline1dcalc(c, t);
   f = vm;
   d = (vr - vl) / (2 * lstep);
   d2 = (vr - 2 * vm + vl) / sqr(lstep);
   while (t <= b + 0.1) {
      prevf = f;
      prevd = d;
      prevd2 = d2;
      vl = vm;
      vm = vr;
      vr = spline1dcalc(c, t + lstep);
      f = vm;
      d = (vr - vl) / (2 * lstep);
      d2 = (vr - 2 * vm + vl) / sqr(lstep);
      *l0 = rmax2(*l0, fabs((f - prevf) / lstep));
      *l1 = rmax2(*l1, fabs((d - prevd) / lstep));
      *l2 = rmax2(*l2, fabs((d2 - prevd2) / lstep));
      t += lstep;
   }
}

// This function is used to enumerate all spline types  which  can  be  built
// from given dataset. It should be used as follows:
//
// >
// > init X, Y, N
// > SplineIndex:=0;
// > while EnumerateAllSplines(X, Y, N, SplineIndex, S) do
// > begin
// >     do something with S
// > end;
// >
//
// On initial call EnumerateAllSplines accepts:
// * dataset X, Y, number of points N (N >= 2)
// * SplineIndex, equal to 0
//
// It returns:
// * True, in case there is a spline type which corresponds to SplineIndex.
//   In this case S contains spline which was built using X/Y and spline type,
//   as specified by input value of SplineIndex. SplineIndex is advanced to
//   the next value.
// * False, in case SplineIndex contains past-the-end value, spline is not built.
//
// This function tries different variants of linear/cubic, periodic/nonperiodic
// splines.
static bool testspline1dunit_enumerateallsplines(RVector *x, RVector *y, ae_int_t n, ae_int_t *splineindex, spline1dinterpolant *s) {
   ae_int_t idxoffs;
   bool result;
   SetObj(spline1dinterpolant, s);
   ae_assert(*splineindex >= 0, "Assertion failed");
   result = false;
   if (*splineindex == 0) {
   // Linear spline
      spline1dbuildlinear(x, y, n, s);
      ++*splineindex;
      result = true;
      return result;
   } else {
      if (*splineindex >= 1 && *splineindex < 11) {
      // Cubic spline, either periodic or non-periodic
         idxoffs = *splineindex - 1;
         if (idxoffs == 9) {
         // Periodic spline
            spline1dbuildcubic(x, y, n, -1, 0.0, -1, 0.0, s);
         } else {
         // Non-periodic spline
            spline1dbuildcubic(x, y, n, idxoffs / 3, randommid(), idxoffs % 3, randommid(), s);
         }
         ++*splineindex;
         result = true;
         return result;
      }
   }
   return result;
}

// Unpack testing
static bool testspline1dunit_testunpack(spline1dinterpolant *c, RVector *x) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t n;
   double err;
   double t;
   double v1;
   double v2;
   ae_int_t pass;
   ae_int_t passcount;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(tbl, 0, 0, DT_REAL);
   passcount = 20;
   err = 0.0;
   spline1dunpack(c, &n, &tbl);
   for (i = 0; i < n - 1; i++) {
      for (pass = 1; pass <= passcount; pass++) {
         t = randomreal() * (tbl.xyR[i][1] - tbl.xyR[i][0]);
         v1 = tbl.xyR[i][2] + t * tbl.xyR[i][3] + sqr(t) * tbl.xyR[i][4] + t * sqr(t) * tbl.xyR[i][5];
         v2 = spline1dcalc(c, tbl.xyR[i][0] + t);
         err = rmax2(err, fabs(v1 - v2));
      }
   }
   for (i = 0; i < n - 1; i++) {
      err = rmax2(err, fabs(x->xR[i] - tbl.xyR[i][0]));
   }
   for (i = 0; i < n - 1; i++) {
      err = rmax2(err, fabs(x->xR[i + 1] - tbl.xyR[i][1]));
   }
   result = err < 100 * machineepsilon;
   ae_frame_leave();
   return result;
}

// Unset spline, i.e. initialize it with random garbage
static void testspline1dunit_unsetspline1d(spline1dinterpolant *c) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   SetObj(spline1dinterpolant, c);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   ae_vector_set_length(&x, 2);
   ae_vector_set_length(&y, 2);
   ae_vector_set_length(&d, 2);
   x.xR[0] = -1.0;
   y.xR[0] = randomreal();
   d.xR[0] = randomreal();
   x.xR[1] = 1.0;
   y.xR[1] = randomreal();
   d.xR[1] = randomreal();
   spline1dbuildhermite(&x, &y, &d, 2, c);
   ae_frame_leave();
}

// Unset spline, i.e. initialize it with random garbage
static void testspline1dunit_unsetreport(spline1dfitreport *rep) {
   SetObj(spline1dfitreport, rep);
   rep->taskrcond = randomreal();
   rep->rmserror = randomreal();
   rep->avgerror = randomreal();
   rep->avgrelerror = randomreal();
   rep->maxerror = randomreal();
}

// Tests that built spline is monotone.
static bool testspline1dunit_testmonotonespline() {
   ae_frame _frame_block;
   double c0;
   double c1;
   ae_int_t m;
   ae_int_t alln;
   ae_int_t shift;
   double sign0;
   double sign1;
   double r;
   double st;
   double eps;
   double delta;
   double v;
   double dv;
   double d2v;
   ae_int_t nseg;
   ae_int_t npoints;
   ae_int_t tp;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t kmax;
   ae_int_t l;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(spline1dinterpolant, c);
   NewObj(spline1dinterpolant, s2);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(n, 0, DT_INT);
   eps = 100 * machineepsilon;
// Special test - N=2.
//
// Following properties are tested:
// * monotone spline must be equal to the Hermite spline with
//   zero derivative at the ends
// * monotone spline is constant beyond left/right boundaries
   ae_vector_set_length(&x, 2);
   ae_vector_set_length(&y, 2);
   ae_vector_set_length(&d, 2);
   x.xR[0] = -0.1 - randomreal();
   y.xR[0] = randommid();
   d.xR[0] = 0.0;
   x.xR[1] = 0.1 + randomreal();
   y.xR[1] = y.xR[0];
   d.xR[1] = 0.0;
   spline1dbuildmonotone(&x, &y, 2, &c);
   spline1dbuildhermite(&x, &y, &d, 2, &s2);
   v = randommid();
   if (fabs(spline1dcalc(&c, v) - spline1dcalc(&s2, v)) > eps) {
      result = true;
      ae_frame_leave();
      return result;
   }
   if (spline1dcalc(&c, -5.0) != y.xR[0]) {
      result = true;
      ae_frame_leave();
      return result;
   }
   if (spline1dcalc(&c, 5.0) != y.xR[0]) {
      result = true;
      ae_frame_leave();
      return result;
   }
// Special test - N=3, x=[0,1,2], y=[0,1,0].
// Monotone spline must be equal to the Hermite spline with
// zero derivative at all points.
   ae_vector_set_length(&x, 3);
   ae_vector_set_length(&y, 3);
   ae_vector_set_length(&d, 3);
   x.xR[0] = 0.0;
   y.xR[0] = 0.0;
   d.xR[0] = 0.0;
   x.xR[1] = 1.0;
   y.xR[1] = 1.0;
   d.xR[1] = 0.0;
   x.xR[2] = 2.0;
   y.xR[2] = 0.0;
   d.xR[2] = 0.0;
   spline1dbuildmonotone(&x, &y, 3, &c);
   spline1dbuildhermite(&x, &y, &d, 3, &s2);
   for (i = 0; i <= 10; i++) {
      v = x.xR[0] + (double)i / 10.0 *(x.xR[2] - x.xR[0]);
      if (fabs(spline1dcalc(&c, v) - spline1dcalc(&s2, v)) > eps) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
// Special test - N=5, x=[0,1,2,3,4], y=[0,1,1,2,3].
//
// 1) spline passes through all prescribed points
// 2) spline derivative at all points except x=3 is exactly zero
// 3) spline derivative at x=3 is 1.0 (within machine epsilon)
   ae_vector_set_length(&x, 5);
   ae_vector_set_length(&y, 5);
   x.xR[0] = 0.0;
   y.xR[0] = 0.0;
   x.xR[1] = 1.0;
   y.xR[1] = 1.0;
   x.xR[2] = 2.0;
   y.xR[2] = 1.0;
   x.xR[3] = 3.0;
   y.xR[3] = 2.0;
   x.xR[4] = 4.0;
   y.xR[4] = 3.0;
   spline1dbuildmonotone(&x, &y, 5, &c);
   for (i = 0; i <= 4; i++) {
      spline1ddiff(&c, x.xR[i], &v, &dv, &d2v);
      if (fabs(v - y.xR[i]) > eps) {
         result = true;
         ae_frame_leave();
         return result;
      }
      if (x.xR[i] == 3.0 ? fabs(dv - 1.0) > eps : dv != 0.0) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
// Special test:
// * N=4
// * three fixed points - (0,0), (1,1), (2,0)
// * one special point (x,y) with x in [0.1,0.9], y in [0.1,0.9]
// * monotonicity of the interpolant at [0,1] is checked with very small step 1/KMax
   ae_vector_set_length(&x, 4);
   ae_vector_set_length(&y, 4);
   x.xR[0] = 0.0;
   y.xR[0] = 0.0;
   x.xR[2] = 1.0;
   y.xR[2] = 1.0;
   x.xR[3] = 2.0;
   y.xR[3] = 0.0;
   for (i = 1; i <= 9; i++) {
      for (j = 1; j <= 9; j++) {
         x.xR[1] = (double)i / 10.0;
         y.xR[1] = (double)j / 10.0;
         spline1dbuildmonotone(&x, &y, 4, &c);
         kmax = 1000;
         for (k = 0; k < kmax; k++) {
            if (spline1dcalc(&c, (double)k / kmax) > spline1dcalc(&c, (double)(k + 1) / kmax)) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
// General case
   delta = 0.0;
   nseg = 10;
   npoints = 15;
   passcount = 30;
   for (pass = 1; pass <= passcount; pass++) {
      tp = randominteger(6) + 4;
      r = (double)(randominteger(76) + 25);
      m = randominteger(nseg) + 1;
      ae_vector_set_length(&n, m);
      alln = 0;
      for (i = 0; i < m; i++) {
         n.xZ[i] = randominteger(npoints) + 2;
         alln += n.xZ[i];
      }
      ae_vector_set_length(&x, alln);
      ae_vector_set_length(&y, alln);
      x.xR[0] = r * randommid();
      y.xR[0] = r * randommid();
   // Builds monotone function
      st = 0.1 + 0.7 * randomreal();
      shift = 0;
      sign0 = pow(-1.0, 0.0);
      for (i = 0; i < m; i++) {
         for (j = 1; j < n.xZ[i]; j++) {
            x.xR[shift + j] = x.xR[shift + j - 1] + st + randomreal();
            delta = rmax2(delta, x.xR[shift + j] - x.xR[shift + j - 1]);
            y.xR[shift + j] = y.xR[shift + j - 1] + sign0 * (st + randomreal());
         }
         shift += n.xZ[i];
         if (i != m - 1) {
            sign0 = pow(-1.0, (double)(i + 1));
            x.xR[shift] = x.xR[shift - 1] + st + randomreal();
            y.xR[shift] = y.xR[shift - 1] + sign0 * randomreal();
         }
      }
      delta *= 3;
      spline1dbuildmonotone(&x, &y, alln, &c);
   // Check that built function is monotone
      shift = 0;
      for (i = 0; i < m; i++) {
         for (j = 1; j < n.xZ[i]; j++) {
            st = (x.xR[shift + j] - x.xR[shift + j - 1]) / tp;
            sign0 = y.xR[shift + j] - y.xR[shift + j - 1];
            if (sign0 != 0.0) {
               sign0 /= fabs(sign0);
            }
            for (l = 0; l < tp; l++) {
               c0 = spline1dcalc(&c, x.xR[shift + j - 1] + l * st);
               c1 = spline1dcalc(&c, x.xR[shift + j - 1] + (l + 1) * st);
               sign1 = c1 - c0;
               if (sign1 != 0.0) {
                  sign1 /= fabs(sign1);
               }
               if (sign0 * sign1 < 0.0) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         }
      }
      c0 = spline1dcalc(&c, x.xR[0] - delta);
      c1 = spline1dcalc(&c, x.xR[0]);
      if (fabs(c0 - c1) > eps) {
         result = true;
         ae_frame_leave();
         return result;
      }
      c0 = spline1dcalc(&c, x.xR[alln - 1]);
      c1 = spline1dcalc(&c, x.xR[alln - 1] + delta);
      if (fabs(c0 - c1) > eps) {
         result = true;
         ae_frame_leave();
         return result;
      }
   // Builds constant function
      y.xR[0] = r * randommid();
      for (i = 1; i < alln; i++) {
         y.xR[i] = y.xR[0];
      }
      spline1dbuildmonotone(&x, &y, alln, &c);
      shift = 0;
      for (i = 0; i < m; i++) {
         for (j = 1; j < n.xZ[i]; j++) {
            st = (x.xR[shift + j] - x.xR[shift + j - 1]) / tp;
            sign0 = y.xR[shift + j] - y.xR[shift + j - 1];
            for (l = 0; l < tp; l++) {
               c0 = spline1dcalc(&c, x.xR[shift + j - 1] + l * st);
               c1 = spline1dcalc(&c, x.xR[shift + j - 1] + (l + 1) * st);
               sign1 = c1 - c0;
               if (sign0 > eps || sign1 > eps) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

static void testspline1dunit_testsplinefitting(bool *fiterrors) {
   ae_frame _frame_block;
   double threshold;
   double nonstrictthreshold;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t k;
   ae_int_t pass;
   double s;
   double v;
   double v1;
   double v2;
   double u;
   double u1;
   double u2;
   double a;
   double b;
   double refrms;
   double refavg;
   double refavgrel;
   double refmax;
   double rho;
   double prevresiduals;
   double prevpenalty;
   double residuals;
   double penalty;
   double mxd2;
   ae_int_t testtype;
   double lipschitzeps;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(dc, 0, DT_INT);
   NewObj(spline1dinterpolant, c);
   NewObj(spline1dinterpolant, c2);
   NewObj(spline1dfitreport, rep);
   NewObj(spline1dfitreport, rep2);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Values:
// * pass count
// * threshold - for tests which must be satisfied exactly
// * nonstrictthreshold - for approximate tests
   passcount = 20;
   threshold = 10000 * machineepsilon;
   nonstrictthreshold = 1.0E-6;
   lipschitzeps = 1.0E-6;
   *fiterrors = false;
// check basic properties of penalized splines which are
// preserved independently of Rho parameter.
   for (m = 4; m <= 10; m++) {
      for (k = -5; k <= 5; k++) {
         rho = (double)k;
      // when we have two points (even with different weights),
      // resulting spline must be equal to the straight line
         ae_vector_set_length(&x, 2);
         ae_vector_set_length(&y, 2);
         ae_vector_set_length(&w, 2);
         x.xR[0] = -0.5 - randomreal();
         y.xR[0] = 0.5 + randomreal();
         w.xR[0] = 1 + randomreal();
         x.xR[1] = 0.5 + randomreal();
         y.xR[1] = 0.5 + randomreal();
         w.xR[1] = 1 + randomreal();
         testspline1dunit_unsetspline1d(&c);
         testspline1dunit_unsetreport(&rep);
         spline1dfit(&x, &y, 2, m, pow(10.0, rho), &c, &rep);
         v = randommid();
         v1 = (v - x.xR[0]) / (x.xR[1] - x.xR[0]) * y.xR[1] + (v - x.xR[1]) / (x.xR[0] - x.xR[1]) * y.xR[0];
         set_error_flag(fiterrors, fabs(v1 - spline1dcalc(&c, v)) > threshold, __FILE__, __LINE__, "testspline1dunit.ap:1509");
         set_error_flag(fiterrors, rep.rmserror > threshold, __FILE__, __LINE__, "testspline1dunit.ap:1510");
         set_error_flag(fiterrors, rep.avgerror > threshold, __FILE__, __LINE__, "testspline1dunit.ap:1511");
         set_error_flag(fiterrors, rep.maxerror > threshold, __FILE__, __LINE__, "testspline1dunit.ap:1512");
      }
   }
// Test spline ability to reproduce target:
// * a penalized spline with M=N and nearly zero Rho must pass
//   through all points on equidistant grid
// * a penalized spline with M about 5*N and sufficiently small
//   Rho must pass through all points on equidistant grid
// In both cases spline must be C0, C1 and C2 continuous.
   for (n = 2; n <= 20; n++) {
   // Fit
      m = n;
      rho = -15.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = (double)i / (n - 1);
         y.xR[i] = randomreal() - 0.5;
      }
      testspline1dunit_unsetspline1d(&c);
      testspline1dunit_unsetreport(&rep);
      spline1dfit(&x, &y, n, m, pow(10.0, rho), &c, &rep);
   // Test that spline passes through all the points
      for (i = 0; i < n; i++) {
         set_error_flag(fiterrors, fabs(y.xR[i] - spline1dcalc(&c, x.xR[i])) > nonstrictthreshold, __FILE__, __LINE__, "testspline1dunit.ap:1545");
      }
      set_error_flag(fiterrors, rep.rmserror > nonstrictthreshold, __FILE__, __LINE__, "testspline1dunit.ap:1546");
      set_error_flag(fiterrors, rep.avgerror > nonstrictthreshold, __FILE__, __LINE__, "testspline1dunit.ap:1547");
      set_error_flag(fiterrors, rep.maxerror > nonstrictthreshold, __FILE__, __LINE__, "testspline1dunit.ap:1548");
   // Test continuity properties
      s = 0.01 * (1.0 / m);
      testspline1dunit_lconst(0.0, 1.0, &c, s, &u, &u1, &u2);
      testspline1dunit_lconst(0.0, 1.0, &c, s / 2, &v, &v1, &v2);
      set_error_flag(fiterrors, v / (u + lipschitzeps) > 1.2, __FILE__, __LINE__, "testspline1dunit.ap:1557");
      set_error_flag(fiterrors, v1 / (u1 + lipschitzeps * m) > 1.2, __FILE__, __LINE__, "testspline1dunit.ap:1558");
      set_error_flag(fiterrors, v2 / (u2 + lipschitzeps * sqr((double)m)) > 1.2, __FILE__, __LINE__, "testspline1dunit.ap:1559");
   }
   for (n = 2; n <= 20; n++) {
      m = 5 * n;
      rho = -10.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      ae_vector_set_length(&w, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = (double)i / (n - 1);
         y.xR[i] = randomreal();
         w.xR[i] = 0.1 + randomreal();
      }
      testspline1dunit_unsetspline1d(&c);
      testspline1dunit_unsetreport(&rep);
      spline1dfit(&x, &y, n, m, pow(10.0, rho), &c, &rep);
      for (i = 0; i < n; i++) {
         set_error_flag(fiterrors, fabs(y.xR[i] - spline1dcalc(&c, x.xR[i])) > nonstrictthreshold, __FILE__, __LINE__, "testspline1dunit.ap:1578");
      }
      set_error_flag(fiterrors, rep.rmserror > nonstrictthreshold, __FILE__, __LINE__, "testspline1dunit.ap:1579");
      set_error_flag(fiterrors, rep.avgerror > nonstrictthreshold, __FILE__, __LINE__, "testspline1dunit.ap:1580");
      set_error_flag(fiterrors, rep.maxerror > nonstrictthreshold, __FILE__, __LINE__, "testspline1dunit.ap:1581");
   // Test continuity properties
      s = 0.01 * (1.0 / m);
      testspline1dunit_lconst(0.0, 1.0, &c, s, &u, &u1, &u2);
      testspline1dunit_lconst(0.0, 1.0, &c, s / 2, &v, &v1, &v2);
      set_error_flag(fiterrors, v / (u + lipschitzeps) > 1.2, __FILE__, __LINE__, "testspline1dunit.ap:1590");
      set_error_flag(fiterrors, v1 / (u1 + lipschitzeps * m) > 1.2, __FILE__, __LINE__, "testspline1dunit.ap:1591");
      set_error_flag(fiterrors, v2 / (u2 + lipschitzeps * sqr((double)m)) > 1.2, __FILE__, __LINE__, "testspline1dunit.ap:1592");
   }
// Test smoothing properties: a sequence of problems with increasing Rho
// results in residuals monotonically increasing and nonlinearity penalty
// monotonically decreasing.
//
// This test is performed twice: first time for M<<N, second time for M>>N
   for (testtype = 0; testtype <= 1; testtype++) {
      if (testtype == 0) {
         n = 100;
         m = 10;
      } else {
         n = 10;
         m = 100;
      }
      ae_vector_set_length(&x, n);
      x.xR[0] = hqrndnormal(&rs);
      for (i = 1; i < n; i++) {
         x.xR[i] = x.xR[i - 1] + 0.25 + hqrnduniformr(&rs);
      }
      for (i = 0; i < n; i++) {
         k = i + hqrnduniformi(&rs, n - i);
         v = x.xR[i];
         x.xR[i] = x.xR[k];
         x.xR[k] = v;
      }
      ae_vector_set_length(&y, n);
      for (i = 0; i < n; i++) {
         y.xR[i] = hqrndnormal(&rs);
      }
      a = x.xR[0];
      b = x.xR[0];
      for (i = 1; i < n; i++) {
         a = rmin2(a, x.xR[i]);
         b = rmax2(b, x.xR[i]);
      }
      prevresiduals = 0.0;
      prevpenalty = maxrealnumber;
      rho = -3.0;
      while (rho <= 4.0) {
      // Fit spline
         testspline1dunit_unsetspline1d(&c);
         testspline1dunit_unsetreport(&rep);
         spline1dfit(&x, &y, n, m, pow(10.0, rho), &c, &rep);
      // Test continuity properties
         s = 0.01 * ((b - a) / m);
         testspline1dunit_lconst(a, b, &c, s, &u, &u1, &u2);
         testspline1dunit_lconst(a, b, &c, s / 2, &v, &v1, &v2);
         set_error_flag(fiterrors, v / (u + lipschitzeps) > 1.2, __FILE__, __LINE__, "testspline1dunit.ap:1654");
         set_error_flag(fiterrors, v1 / (u1 + lipschitzeps * m) > 1.2, __FILE__, __LINE__, "testspline1dunit.ap:1655");
         set_error_flag(fiterrors, v2 / (u2 + lipschitzeps * sqr((double)m)) > 1.2, __FILE__, __LINE__, "testspline1dunit.ap:1656");
      // Compute residuals and penalty
         residuals = 0.0;
         for (i = 0; i < n; i++) {
            residuals += sqr(spline1dcalc(&c, x.xR[i]) - y.xR[i]);
         }
         residuals /= n;
         penalty = 0.0;
         mxd2 = 0.0;
         k = 100 * m;
         for (i = 0; i <= k; i++) {
            spline1ddiff(&c, a + (b - a) * i / k, &v, &v1, &v2);
            penalty += sqr(v2);
            mxd2 = rmax2(mxd2, fabs(v2));
         }
         penalty /= k + 1;
      // Compare with previous, update previous, update Rho
      //
      // Write('M=%i    N=%i    %.15e    %.15e    %.15e\n', M, N, Residuals, Penalty, MxD2);
         set_error_flag(fiterrors, residuals <= prevresiduals, __FILE__, __LINE__, "testspline1dunit.ap:1682");
         set_error_flag(fiterrors, penalty >= prevpenalty, __FILE__, __LINE__, "testspline1dunit.ap:1683");
         prevresiduals = residuals;
         prevpenalty = penalty;
         rho++;
      }
      set_error_flag(fiterrors, penalty >= 1.0E-6, __FILE__, __LINE__, "testspline1dunit.ap:1688");
      set_error_flag(fiterrors, mxd2 >= 1.0E-3, __FILE__, __LINE__, "testspline1dunit.ap:1689");
   }
// Special test which allows to distinguish "true smoothing" from
// basic regularization enforced upon spline coefficients.
   n = 4;
   m = 100;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&y, n);
   x.xR[0] = -2.0;
   x.xR[1] = -1.0;
   x.xR[2] = 1.0;
   x.xR[3] = 2.0;
   y.xR[0] = -1.0;
   y.xR[1] = 1.0;
   y.xR[2] = 1.0;
   y.xR[3] = -1.0;
   rho = -5.0;
   spline1dfit(&x, &y, n, m, pow(10.0, rho), &c, &rep);
   for (i = 0; i < n; i++) {
      set_error_flag(fiterrors, fabs(spline1dcalc(&c, x.xR[i]) - y.xR[i]) > 0.0001, __FILE__, __LINE__, "testspline1dunit.ap:1711");
   }
   set_error_flag(fiterrors, spline1dcalc(&c, 0.0) < 1.000, __FILE__, __LINE__, "testspline1dunit.ap:1712");
// Check correctness of error reports
   for (pass = 1; pass <= passcount; pass++) {
      ae_assert(passcount >= 2, "PassCount should be 2 or greater!");
   // solve simple task (all X[] are the same, Y[] are specially
   // calculated to ensure simple form of all types of errors)
   // and check correctness of the errors calculated by subroutines
   //
   // First pass is done with zero Y[], other passes - with random Y[].
   // It should test both ability to correctly calculate errors and
   // ability to not fail while working with zeros :)
      n = 4;
      if (pass == 1) {
         v1 = 0.0;
         v2 = 0.0;
         v = 0.0;
      } else {
         v1 = randomreal();
         v2 = randomreal();
         v = 1 + randomreal();
      }
      ae_vector_set_length(&x, 4);
      ae_vector_set_length(&y, 4);
      ae_vector_set_length(&w, 4);
      x.xR[0] = 0.0;
      y.xR[0] = v - v2;
      w.xR[0] = 1.0;
      x.xR[1] = 0.0;
      y.xR[1] = v - v1;
      w.xR[1] = 1.0;
      x.xR[2] = 0.0;
      y.xR[2] = v + v1;
      w.xR[2] = 1.0;
      x.xR[3] = 0.0;
      y.xR[3] = v + v2;
      w.xR[3] = 1.0;
      refrms = sqrt((sqr(v1) + sqr(v2)) / 2);
      refavg = (fabs(v1) + fabs(v2)) / 2;
      if (pass == 1) {
         refavgrel = 0.0;
      } else {
         refavgrel = 0.25 * (fabs(v2) / fabs(v - v2) + fabs(v1) / fabs(v - v1) + fabs(v1) / fabs(v + v1) + fabs(v2) / fabs(v + v2));
      }
      refmax = rmax2(v1, v2);
      spline1dfit(&x, &y, 4, 4, 0.0, &c, &rep);
      s = spline1dcalc(&c, 0.0);
      set_error_flag(fiterrors, fabs(s - v) > threshold, __FILE__, __LINE__, "testspline1dunit.ap:1767");
      set_error_flag(fiterrors, fabs(rep.rmserror - refrms) > threshold, __FILE__, __LINE__, "testspline1dunit.ap:1768");
      set_error_flag(fiterrors, fabs(rep.avgerror - refavg) > threshold, __FILE__, __LINE__, "testspline1dunit.ap:1769");
      set_error_flag(fiterrors, fabs(rep.avgrelerror - refavgrel) > threshold, __FILE__, __LINE__, "testspline1dunit.ap:1770");
      set_error_flag(fiterrors, fabs(rep.maxerror - refmax) > threshold, __FILE__, __LINE__, "testspline1dunit.ap:1771");
   }
   ae_frame_leave();
}

bool testspline1d(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   bool crserrors;
   bool cserrors;
   bool hserrors;
   bool aserrors;
   bool lserrors;
   bool dserrors;
   bool uperrors;
   bool cperrors;
   bool lterrors;
   bool ierrors;
   bool monotoneerr;
   bool fiterr;
   double threshold;
   ae_int_t passcount;
   double lstep;
   double h;
   ae_int_t maxn;
   ae_int_t bltype;
   ae_int_t brtype;
   bool periodiccond;
   ae_int_t n;
   ae_int_t i;
   ae_int_t k;
   ae_int_t pass;
   ae_int_t n2;
   double a;
   double b;
   double bl;
   double br;
   double t;
   double sa;
   double sb;
   double v;
   double l10;
   double l11;
   double l12;
   double l20;
   double l21;
   double l22;
   double p0;
   double p1;
   double p2;
   double s;
   double ds;
   double d2s;
   double s2;
   double ds2;
   double d2s2;
   double vl;
   double vm;
   double vr;
   double err;
   double tension;
   double intab;
   ae_int_t splineindex;
   double lipschitzeps;
   double lipschitztol;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(yp, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewVector(xtest, 0, DT_REAL);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(tmp1, 0, DT_REAL);
   NewVector(tmp2, 0, DT_REAL);
   NewVector(tmpx, 0, DT_REAL);
   NewVector(dc, 0, DT_INT);
   NewObj(spline1dinterpolant, c);
   NewObj(spline1dinterpolant, c2);
   waserrors = false;
   passcount = 20;
   lstep = 0.005;
   h = 0.00001;
   maxn = 10;
   lipschitzeps = 1.0E-5;
   lipschitztol = 1.25;
   threshold = 10000 * machineepsilon;
   lserrors = false;
   cserrors = false;
   crserrors = false;
   hserrors = false;
   aserrors = false;
   dserrors = false;
   cperrors = false;
   uperrors = false;
   lterrors = false;
   ierrors = false;
   fiterr = false;
// General test: linear, cubic, Hermite, Akima
   for (n = 2; n <= maxn; n++) {
      ae_vector_set_length(&x, n - 1 + 1);
      ae_vector_set_length(&y, n - 1 + 1);
      ae_vector_set_length(&yp, n - 1 + 1);
      ae_vector_set_length(&d, n - 1 + 1);
      for (pass = 1; pass <= passcount; pass++) {
      // Prepare task:
      // * X contains abscissas from [A,B]
      // * Y contains function values
      // * YP contains periodic function values
         a = -1 - randomreal();
         b = 1 + randomreal();
         bl = randommid();
         br = randommid();
         for (i = 0; i < n; i++) {
            x.xR[i] = 0.5 * (b + a) + 0.5 * (b - a) * cos(pi * (2 * i + 1) / (2 * n));
            if (i == 0) {
               x.xR[i] = a;
            }
            if (i == n - 1) {
               x.xR[i] = b;
            }
            y.xR[i] = cos(1.3 * pi * x.xR[i] + 0.4);
            yp.xR[i] = y.xR[i];
            d.xR[i] = -1.3 * pi * sin(1.3 * pi * x.xR[i] + 0.4);
         }
         yp.xR[n - 1] = yp.xR[0];
         for (i = 0; i < n; i++) {
            k = randominteger(n);
            if (k != i) {
               t = x.xR[i];
               x.xR[i] = x.xR[k];
               x.xR[k] = t;
               t = y.xR[i];
               y.xR[i] = y.xR[k];
               y.xR[k] = t;
               t = yp.xR[i];
               yp.xR[i] = yp.xR[k];
               yp.xR[k] = t;
               t = d.xR[i];
               d.xR[i] = d.xR[k];
               d.xR[k] = t;
            }
         }
      // Build linear spline
      // Test for general interpolation scheme properties:
      // * values at nodes
      // * continuous function
      // Test for specific properties is implemented below.
         spline1dbuildlinear(&x, &y, n, &c);
         err = 0.0;
         for (i = 0; i < n; i++) {
            err = rmax2(err, fabs(y.xR[i] - spline1dcalc(&c, x.xR[i])));
         }
         lserrors = lserrors || err > threshold;
         testspline1dunit_lconst(a, b, &c, lstep, &l10, &l11, &l12);
         testspline1dunit_lconst(a, b, &c, lstep / 3, &l20, &l21, &l22);
         lserrors = lserrors || l20 / l10 > lipschitztol;
      // Build cubic spline.
      // Test for interpolation scheme properties:
      // * values at nodes
      // * boundary conditions
      // * continuous function
      // * continuous first derivative
      // * continuous second derivative
      // * periodicity properties
      // * Spline1DGridDiff(), Spline1DGridDiff2() and Spline1DDiff()
      //   calls must return same results
         for (bltype = -1; bltype <= 2; bltype++) {
            for (brtype = -1; brtype <= 2; brtype++) {
            // skip meaningless combination of boundary conditions
            // (one condition is periodic, another is not)
               periodiccond = bltype == -1 || brtype == -1;
               if (periodiccond && bltype != brtype) {
                  continue;
               }
            // build
               if (periodiccond) {
                  spline1dbuildcubic(&x, &yp, n, bltype, bl, brtype, br, &c);
               } else {
                  spline1dbuildcubic(&x, &y, n, bltype, bl, brtype, br, &c);
               }
            // interpolation properties
               err = 0.0;
               if (periodiccond) {
               // * check values at nodes; spline is periodic so
               //   we add random number of periods to nodes
               // * we also test for periodicity of derivatives
                  for (i = 0; i < n; i++) {
                     v = x.xR[i];
                     vm = v + (b - a) * (randominteger(5) - 2);
                     t = yp.xR[i] - spline1dcalc(&c, vm);
                     err = rmax2(err, fabs(t));
                     spline1ddiff(&c, v, &s, &ds, &d2s);
                     spline1ddiff(&c, vm, &s2, &ds2, &d2s2);
                     err = rmax2(err, fabs(s - s2));
                     err = rmax2(err, fabs(ds - ds2));
                     err = rmax2(err, fabs(d2s - d2s2));
                  }
               // periodicity between nodes
                  v = a + (b - a) * randomreal();
                  vm = v + (b - a) * (randominteger(5) - 2);
                  err = rmax2(err, fabs(spline1dcalc(&c, v) - spline1dcalc(&c, vm)));
                  spline1ddiff(&c, v, &s, &ds, &d2s);
                  spline1ddiff(&c, vm, &s2, &ds2, &d2s2);
                  err = rmax2(err, fabs(s - s2));
                  err = rmax2(err, fabs(ds - ds2));
                  err = rmax2(err, fabs(d2s - d2s2));
               } else {
               // * check values at nodes
                  for (i = 0; i < n; i++) {
                     err = rmax2(err, fabs(y.xR[i] - spline1dcalc(&c, x.xR[i])));
                  }
               }
               set_error_flag(&cserrors, err > threshold, __FILE__, __LINE__, "testspline1dunit.ap:223");
            // check boundary conditions
               err = 0.0;
               if (bltype == 0) {
                  spline1ddiff(&c, a - h, &s, &ds, &d2s);
                  spline1ddiff(&c, a + h, &s2, &ds2, &d2s2);
                  t = (d2s2 - d2s) / (2 * h);
                  err = rmax2(err, fabs(t));
               }
               if (bltype == 1) {
                  t = (spline1dcalc(&c, a + h) - spline1dcalc(&c, a - h)) / (2 * h);
                  err = rmax2(err, fabs(bl - t));
               }
               if (bltype == 2) {
                  t = (spline1dcalc(&c, a + h) - 2 * spline1dcalc(&c, a) + spline1dcalc(&c, a - h)) / sqr(h);
                  err = rmax2(err, fabs(bl - t));
               }
               if (brtype == 0) {
                  spline1ddiff(&c, b - h, &s, &ds, &d2s);
                  spline1ddiff(&c, b + h, &s2, &ds2, &d2s2);
                  t = (d2s2 - d2s) / (2 * h);
                  err = rmax2(err, fabs(t));
               }
               if (brtype == 1) {
                  t = (spline1dcalc(&c, b + h) - spline1dcalc(&c, b - h)) / (2 * h);
                  err = rmax2(err, fabs(br - t));
               }
               if (brtype == 2) {
                  t = (spline1dcalc(&c, b + h) - 2 * spline1dcalc(&c, b) + spline1dcalc(&c, b - h)) / sqr(h);
                  err = rmax2(err, fabs(br - t));
               }
               if (bltype == -1 || brtype == -1) {
                  spline1ddiff(&c, a + 100 * machineepsilon, &s, &ds, &d2s);
                  spline1ddiff(&c, b - 100 * machineepsilon, &s2, &ds2, &d2s2);
                  err = rmax2(err, fabs(s - s2));
                  err = rmax2(err, fabs(ds - ds2));
                  err = rmax2(err, fabs(d2s - d2s2));
               }
               set_error_flag(&cserrors, err > 1.0E-3, __FILE__, __LINE__, "testspline1dunit.ap:271");
            // Check Lipschitz continuity
               testspline1dunit_lconst(a, b, &c, lstep, &l10, &l11, &l12);
               testspline1dunit_lconst(a, b, &c, lstep / 3, &l20, &l21, &l22);
               if (l10 > lipschitzeps) {
                  set_error_flag(&cserrors, l20 / (l10 + lipschitzeps) > lipschitztol, __FILE__, __LINE__, "testspline1dunit.ap:279");
               }
               if (l11 > lipschitzeps) {
                  set_error_flag(&cserrors, l21 / (l11 + lipschitzeps) > lipschitztol, __FILE__, __LINE__, "testspline1dunit.ap:281");
               }
               if (l12 > lipschitzeps) {
                  set_error_flag(&cserrors, l22 / (l12 + lipschitzeps) > lipschitztol, __FILE__, __LINE__, "testspline1dunit.ap:283");
               }
            // compare spline1dgriddiff() and spline1ddiff() results
               err = 0.0;
               if (periodiccond) {
                  spline1dgriddiffcubic(&x, &yp, n, bltype, bl, brtype, br, &tmp1);
               } else {
                  spline1dgriddiffcubic(&x, &y, n, bltype, bl, brtype, br, &tmp1);
               }
               ae_assert(tmp1.cnt >= n, "Assertion failed");
               for (i = 0; i < n; i++) {
                  spline1ddiff(&c, x.xR[i], &s, &ds, &d2s);
                  err = rmax2(err, fabs(ds - tmp1.xR[i]));
               }
               if (periodiccond) {
                  spline1dgriddiff2cubic(&x, &yp, n, bltype, bl, brtype, br, &tmp1, &tmp2);
               } else {
                  spline1dgriddiff2cubic(&x, &y, n, bltype, bl, brtype, br, &tmp1, &tmp2);
               }
               for (i = 0; i < n; i++) {
                  spline1ddiff(&c, x.xR[i], &s, &ds, &d2s);
                  err = rmax2(err, fabs(ds - tmp1.xR[i]));
                  err = rmax2(err, fabs(d2s - tmp2.xR[i]));
               }
               set_error_flag(&cserrors, err > threshold, __FILE__, __LINE__, "testspline1dunit.ap:309");
            // compare spline1dconv()/convdiff()/convdiff2() and spline1ddiff() results
               n2 = 2 + randominteger(2 * n);
               ae_vector_set_length(&tmpx, n2);
               for (i = 0; i < n2; i++) {
                  tmpx.xR[i] = 0.5 * (a + b) + (a - b) * randommid();
               }
               err = 0.0;
               if (periodiccond) {
                  spline1dconvcubic(&x, &yp, n, bltype, bl, brtype, br, &tmpx, n2, &tmp0);
               } else {
                  spline1dconvcubic(&x, &y, n, bltype, bl, brtype, br, &tmpx, n2, &tmp0);
               }
               for (i = 0; i < n2; i++) {
                  spline1ddiff(&c, tmpx.xR[i], &s, &ds, &d2s);
                  err = rmax2(err, fabs(s - tmp0.xR[i]));
               }
               if (periodiccond) {
                  spline1dconvdiffcubic(&x, &yp, n, bltype, bl, brtype, br, &tmpx, n2, &tmp0, &tmp1);
               } else {
                  spline1dconvdiffcubic(&x, &y, n, bltype, bl, brtype, br, &tmpx, n2, &tmp0, &tmp1);
               }
               for (i = 0; i < n2; i++) {
                  spline1ddiff(&c, tmpx.xR[i], &s, &ds, &d2s);
                  err = rmax2(err, fabs(s - tmp0.xR[i]));
                  err = rmax2(err, fabs(ds - tmp1.xR[i]));
               }
               if (periodiccond) {
                  spline1dconvdiff2cubic(&x, &yp, n, bltype, bl, brtype, br, &tmpx, n2, &tmp0, &tmp1, &tmp2);
               } else {
                  spline1dconvdiff2cubic(&x, &y, n, bltype, bl, brtype, br, &tmpx, n2, &tmp0, &tmp1, &tmp2);
               }
               for (i = 0; i < n2; i++) {
                  spline1ddiff(&c, tmpx.xR[i], &s, &ds, &d2s);
                  err = rmax2(err, fabs(s - tmp0.xR[i]));
                  err = rmax2(err, fabs(ds - tmp1.xR[i]));
                  err = rmax2(err, fabs(d2s - tmp2.xR[i]));
               }
               set_error_flag(&cserrors, err > threshold, __FILE__, __LINE__, "testspline1dunit.ap:353");
            }
         }
      // Build Catmull-Rom spline.
      // Test for interpolation scheme properties:
      // * values at nodes
      // * boundary conditions
      // * continuous function
      // * continuous first derivative
      // * periodicity properties
         for (bltype = -1; bltype <= 0; bltype++) {
            periodiccond = bltype == -1;
         // select random tension value, then build
            if (randombool()) {
               if (randombool()) {
                  tension = 0.0;
               } else {
                  tension = 1.0;
               }
            } else {
               tension = randomreal();
            }
            if (periodiccond) {
               spline1dbuildcatmullrom(&x, &yp, n, bltype, tension, &c);
            } else {
               spline1dbuildcatmullrom(&x, &y, n, bltype, tension, &c);
            }
         // interpolation properties
            err = 0.0;
            if (periodiccond) {
            // * check values at nodes; spline is periodic so
            //   we add random number of periods to nodes
            // * we also test for periodicity of first derivative
               for (i = 0; i < n; i++) {
                  v = x.xR[i];
                  vm = v + (b - a) * (randominteger(5) - 2);
                  t = yp.xR[i] - spline1dcalc(&c, vm);
                  err = rmax2(err, fabs(t));
                  spline1ddiff(&c, v, &s, &ds, &d2s);
                  spline1ddiff(&c, vm, &s2, &ds2, &d2s2);
                  err = rmax2(err, fabs(s - s2));
                  err = rmax2(err, fabs(ds - ds2));
               }
            // periodicity between nodes
               v = a + (b - a) * randomreal();
               vm = v + (b - a) * (randominteger(5) - 2);
               err = rmax2(err, fabs(spline1dcalc(&c, v) - spline1dcalc(&c, vm)));
               spline1ddiff(&c, v, &s, &ds, &d2s);
               spline1ddiff(&c, vm, &s2, &ds2, &d2s2);
               err = rmax2(err, fabs(s - s2));
               err = rmax2(err, fabs(ds - ds2));
            } else {
            // * check values at nodes
               for (i = 0; i < n; i++) {
                  err = rmax2(err, fabs(y.xR[i] - spline1dcalc(&c, x.xR[i])));
               }
            }
            crserrors = crserrors || err > threshold;
         // check boundary conditions
            err = 0.0;
            if (bltype == 0) {
               spline1ddiff(&c, a - h, &s, &ds, &d2s);
               spline1ddiff(&c, a + h, &s2, &ds2, &d2s2);
               t = (d2s2 - d2s) / (2 * h);
               err = rmax2(err, fabs(t));
               spline1ddiff(&c, b - h, &s, &ds, &d2s);
               spline1ddiff(&c, b + h, &s2, &ds2, &d2s2);
               t = (d2s2 - d2s) / (2 * h);
               err = rmax2(err, fabs(t));
            }
            if (bltype == -1) {
               spline1ddiff(&c, a + 100 * machineepsilon, &s, &ds, &d2s);
               spline1ddiff(&c, b - 100 * machineepsilon, &s2, &ds2, &d2s2);
               err = rmax2(err, fabs(s - s2));
               err = rmax2(err, fabs(ds - ds2));
            }
            crserrors = crserrors || err > 1.0E-3;
         // Check Lipschitz continuity
            testspline1dunit_lconst(a, b, &c, lstep, &l10, &l11, &l12);
            testspline1dunit_lconst(a, b, &c, lstep / 3, &l20, &l21, &l22);
            if (l10 > 1.0E-6) {
               crserrors = crserrors || l20 / l10 > lipschitztol;
            }
            if (l11 > 1.0E-6) {
               crserrors = crserrors || l21 / l11 > lipschitztol;
            }
         }
      // Build Hermite spline.
      // Test for interpolation scheme properties:
      // * values and derivatives at nodes
      // * continuous function
      // * continuous first derivative
         spline1dbuildhermite(&x, &y, &d, n, &c);
         err = 0.0;
         for (i = 0; i < n; i++) {
            err = rmax2(err, fabs(y.xR[i] - spline1dcalc(&c, x.xR[i])));
         }
         set_error_flag(&hserrors, err > threshold, __FILE__, __LINE__, "testspline1dunit.ap:478");
         err = 0.0;
         for (i = 0; i < n; i++) {
            t = (spline1dcalc(&c, x.xR[i] + h) - spline1dcalc(&c, x.xR[i] - h)) / (2 * h);
            err = rmax2(err, fabs(d.xR[i] - t));
         }
         set_error_flag(&hserrors, err > 1.0E-3, __FILE__, __LINE__, "testspline1dunit.ap:485");
         testspline1dunit_lconst(a, b, &c, lstep, &l10, &l11, &l12);
         testspline1dunit_lconst(a, b, &c, lstep / 3, &l20, &l21, &l22);
         set_error_flag(&hserrors, l20 / (l10 + lipschitzeps) > lipschitztol, __FILE__, __LINE__, "testspline1dunit.ap:488");
         set_error_flag(&hserrors, l21 / (l11 + lipschitzeps) > lipschitztol, __FILE__, __LINE__, "testspline1dunit.ap:489");
      // Build Akima spline
      // Test for general interpolation scheme properties:
      // * values at nodes
      // * continuous function
      // * continuous first derivative
      // Test for Akima-specific properties is implemented below.
         spline1dbuildakima(&x, &y, n, &c);
         err = 0.0;
         for (i = 0; i < n; i++) {
            err = rmax2(err, fabs(y.xR[i] - spline1dcalc(&c, x.xR[i])));
         }
         aserrors = aserrors || err > threshold;
         testspline1dunit_lconst(a, b, &c, lstep, &l10, &l11, &l12);
         testspline1dunit_lconst(a, b, &c, lstep / 3, &l20, &l21, &l22);
         set_error_flag(&aserrors, l20 / (l10 + lipschitzeps) > lipschitztol, __FILE__, __LINE__, "testspline1dunit.ap:506");
         set_error_flag(&aserrors, l21 / (l11 + lipschitzeps) > lipschitztol, __FILE__, __LINE__, "testspline1dunit.ap:507");
      }
   }
// Special linear spline test:
// test for linearity between x[i] and x[i+1]
   for (n = 2; n <= maxn; n++) {
      ae_vector_set_length(&x, n - 1 + 1);
      ae_vector_set_length(&y, n - 1 + 1);
   // Prepare task
      a = -1.0;
      b = 1.0;
      for (i = 0; i < n; i++) {
         x.xR[i] = a + (b - a) * i / (n - 1);
         y.xR[i] = randommid();
      }
      spline1dbuildlinear(&x, &y, n, &c);
   // Test
      err = 0.0;
      for (k = 0; k < n - 1; k++) {
         a = x.xR[k];
         b = x.xR[k + 1];
         for (pass = 1; pass <= passcount; pass++) {
            t = a + (b - a) * randomreal();
            v = y.xR[k] + (t - a) / (b - a) * (y.xR[k + 1] - y.xR[k]);
            err = rmax2(err, fabs(spline1dcalc(&c, t) - v));
         }
      }
      lserrors = lserrors || err > threshold;
   }
// Special Akima test: test outlier sensitivity
// Spline value at (x[i], x[i+1]) should depend from
// f[i-2], f[i-1], f[i], f[i+1], f[i+2], f[i+3] only.
   for (n = 5; n <= maxn; n++) {
      ae_vector_set_length(&x, n - 1 + 1);
      ae_vector_set_length(&y, n - 1 + 1);
      ae_vector_set_length(&y2, n - 1 + 1);
   // Prepare unperturbed Akima spline
      a = -1.0;
      b = 1.0;
      for (i = 0; i < n; i++) {
         x.xR[i] = a + (b - a) * i / (n - 1);
         y.xR[i] = cos(1.3 * pi * x.xR[i] + 0.4);
      }
      spline1dbuildakima(&x, &y, n, &c);
   // Process perturbed tasks
      err = 0.0;
      for (k = 0; k < n; k++) {
         ae_v_move(y2.xR, 1, y.xR, 1, n);
         y2.xR[k] = 5.0;
         spline1dbuildakima(&x, &y2, n, &c2);
      // Test left part independence
         if (k - 3 >= 1) {
            a = -1.0;
            b = x.xR[k - 3];
            for (pass = 1; pass <= passcount; pass++) {
               t = a + (b - a) * randomreal();
               err = rmax2(err, fabs(spline1dcalc(&c, t) - spline1dcalc(&c2, t)));
            }
         }
      // Test right part independence
         if (k + 3 < n - 1) {
            a = x.xR[k + 3];
            b = 1.0;
            for (pass = 1; pass <= passcount; pass++) {
               t = a + (b - a) * randomreal();
               err = rmax2(err, fabs(spline1dcalc(&c, t) - spline1dcalc(&c2, t)));
            }
         }
      }
      aserrors = aserrors || err > threshold;
   }
// Differentiation, copy/unpack test
   for (n = 2; n <= maxn; n++) {
      ae_vector_set_length(&x, n - 1 + 1);
      ae_vector_set_length(&y, n - 1 + 1);
   // Prepare cubic spline
      a = -1 - randomreal();
      b = 1 + randomreal();
      for (i = 0; i < n; i++) {
         x.xR[i] = a + (b - a) * i / (n - 1);
         y.xR[i] = cos(1.3 * pi * x.xR[i] + 0.4);
      }
      spline1dbuildcubic(&x, &y, n, 2, 0.0, 2, 0.0, &c);
   // Test diff
      err = 0.0;
      for (pass = 1; pass <= passcount; pass++) {
         t = a + (b - a) * randomreal();
         spline1ddiff(&c, t, &s, &ds, &d2s);
         vl = spline1dcalc(&c, t - h);
         vm = spline1dcalc(&c, t);
         vr = spline1dcalc(&c, t + h);
         err = rmax2(err, fabs(s - vm));
         err = rmax2(err, fabs(ds - (vr - vl) / (2 * h)));
         err = rmax2(err, fabs(d2s - (vr - 2 * vm + vl) / sqr(h)));
      }
      dserrors = dserrors || err > 0.001;
   // Test copy
      testspline1dunit_unsetspline1d(&c2);
      spline1dcopy(&c, &c2);
      err = 0.0;
      for (pass = 1; pass <= passcount; pass++) {
         t = a + (b - a) * randomreal();
         err = rmax2(err, fabs(spline1dcalc(&c, t) - spline1dcalc(&c2, t)));
      }
      cperrors = cperrors || err > threshold;
   // Test unpack
      uperrors = uperrors || !testspline1dunit_testunpack(&c, &x);
   }
// Linear translation errors
   for (n = 2; n <= maxn; n++) {
   // Prepare:
   // * X, Y - grid points
   // * XTest - test points
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      a = -1 - randomreal();
      b = 1 + randomreal();
      for (i = 0; i < n; i++) {
         x.xR[i] = a + (b - a) * (i + 0.1 * randommid()) / (n - 1);
         y.xR[i] = randommid();
      }
      ae_vector_set_length(&xtest, 5 * n + 2);
      for (i = 0; i < xtest.cnt; i++) {
         xtest.xR[i] = a + (b - a) * (i - 1) / (xtest.cnt - 3);
      }
      splineindex = 0;
      while (testspline1dunit_enumerateallsplines(&x, &y, n, &splineindex, &c)) {
      // LinTransX, general A
         sa = 2.0 * randommid();
         sb = randommid();
         spline1dcopy(&c, &c2);
         spline1dlintransx(&c2, sa, sb);
         for (i = 0; i < xtest.cnt; i++) {
            lterrors = lterrors || fabs(spline1dcalc(&c, xtest.xR[i]) - spline1dcalc(&c2, (xtest.xR[i] - sb) / sa)) > threshold;
         }
      // LinTransX, special case: A=0
         sb = randommid();
         spline1dcopy(&c, &c2);
         spline1dlintransx(&c2, 0.0, sb);
         for (i = 0; i < xtest.cnt; i++) {
            lterrors = lterrors || fabs(spline1dcalc(&c, sb) - spline1dcalc(&c2, xtest.xR[i])) > threshold;
         }
      // LinTransY
         sa = randommid();
         sb = randommid();
         spline1dcopy(&c, &c2);
         spline1dlintransy(&c2, sa, sb);
         for (i = 0; i < xtest.cnt; i++) {
            lterrors = lterrors || fabs(sa * spline1dcalc(&c, xtest.xR[i]) + sb - spline1dcalc(&c2, xtest.xR[i])) > threshold;
         }
      }
   }
// Testing integration.
// Three tests are performed:
//
// * approximate test (well behaved smooth function, many points,
//   integration inside [a,b]), non-periodic spline
//
// * exact test (integration of parabola, outside of [a,b], non-periodic spline
//
// * approximate test for periodic splines. F(x)=cos(2*pi*x)+1.
//   Period length is equals to 1.0, so all operations with
//   multiples of period are done exactly. For each value of PERIOD
//   we calculate and test integral at four points:
//   -   0 < t0 < PERIOD
//   -   t1 = PERIOD-eps
//   -   t2 = PERIOD
//   -   t3 = PERIOD+eps
   err = 0.0;
   for (n = 20; n <= 35; n++) {
      ae_vector_set_length(&x, n - 1 + 1);
      ae_vector_set_length(&y, n - 1 + 1);
      for (pass = 1; pass <= passcount; pass++) {
      // Prepare cubic spline
         a = -1 - 0.2 * randomreal();
         b = 1 + 0.2 * randomreal();
         for (i = 0; i < n; i++) {
            x.xR[i] = a + (b - a) * i / (n - 1);
            y.xR[i] = sin(pi * x.xR[i] + 0.4) + exp(x.xR[i]);
         }
         bl = pi * cos(pi * a + 0.4) + exp(a);
         br = pi * cos(pi * b + 0.4) + exp(b);
         spline1dbuildcubic(&x, &y, n, 1, bl, 1, br, &c);
      // Test
         t = a + (b - a) * randomreal();
         v = -cos(pi * a + 0.4) / pi + exp(a);
         v = -cos(pi * t + 0.4) / pi + exp(t) - v;
         v -= spline1dintegrate(&c, t);
         err = rmax2(err, fabs(v));
      }
   }
   ierrors = ierrors || err > 0.001;
   p0 = randommid();
   p1 = randommid();
   p2 = randommid();
   a = -randomreal() - 0.5;
   b = randomreal() + 0.5;
   n = 2;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&y, n);
   ae_vector_set_length(&d, n);
   x.xR[0] = a;
   y.xR[0] = p0 + p1 * a + p2 * sqr(a);
   d.xR[0] = p1 + 2 * p2 * a;
   x.xR[1] = b;
   y.xR[1] = p0 + p1 * b + p2 * sqr(b);
   d.xR[1] = p1 + 2 * p2 * b;
   spline1dbuildhermite(&x, &y, &d, n, &c);
   bl = rmin2(a, b) - fabs(b - a);
   br = rmin2(a, b) + fabs(b - a);
   err = 0.0;
   for (pass = 1; pass <= 100; pass++) {
      t = bl + (br - bl) * randomreal();
      v = p0 * t + p1 * sqr(t) / 2 + p2 * sqr(t) * t / 3 - (p0 * a + p1 * sqr(a) / 2 + p2 * sqr(a) * a / 3);
      v -= spline1dintegrate(&c, t);
      err = rmax2(err, fabs(v));
   }
   ierrors = ierrors || err > threshold;
   n = 100;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&y, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = (double)i / (n - 1);
      y.xR[i] = cos(2 * pi * x.xR[i]) + 1;
   }
   y.xR[0] = 2.0;
   y.xR[n - 1] = 2.0;
   spline1dbuildcubic(&x, &y, n, -1, 0.0, -1, 0.0, &c);
   intab = spline1dintegrate(&c, 1.0);
   v = randomreal();
   vr = spline1dintegrate(&c, v);
   ierrors = ierrors || fabs(intab - 1) > 0.001;
   for (i = -10; i <= 10; i++) {
      ierrors = ierrors || fabs(spline1dintegrate(&c, i + v) - (i * intab + vr)) > 0.001;
      ierrors = ierrors || fabs(spline1dintegrate(&c, i - 1000 * machineepsilon) - i * intab) > 0.001;
      ierrors = ierrors || fabs(spline1dintegrate(&c, (double)i) - i * intab) > 0.001;
      ierrors = ierrors || fabs(spline1dintegrate(&c, i + 1000 * machineepsilon) - i * intab) > 0.001;
   }
// Test monotone cubic Hermit interpolation
   monotoneerr = testspline1dunit_testmonotonespline();
// Test fitting errors
   testspline1dunit_testsplinefitting(&fiterr);
// report
   waserrors = ((((((((((lserrors || cserrors) || crserrors) || hserrors) || aserrors) || dserrors) || cperrors) || uperrors) || lterrors) || ierrors) || monotoneerr) || fiterr;
   if (!silent) {
      printf("TESTING SPLINE INTERPOLATION\n");
   // Normal tests
      printf("INTERPOLATION:\n");
      printf("* LINEAR SPLINE                          ");
      if (lserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* CUBIC SPLINE                           ");
      if (cserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* CATMULL-ROM SPLINE                     ");
      if (crserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* HERMITE SPLINE                         ");
      if (hserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* AKIMA SPLINE                           ");
      if (aserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* MONOTONE SPLINE                        ");
      if (monotoneerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("FITTING:                                 ");
      if (fiterr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("DIFFERENTIATION TEST:                    ");
      if (dserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("COPY/SERIALIZATION TEST:                 ");
      if (cperrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("UNPACK TEST:                             ");
      if (uperrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("LIN.TRANS. TEST:                         ");
      if (lterrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("INTEGRATION TEST:                        ");
      if (ierrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
// end
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === lsfit testing unit ===
// Unit test
static void testlsfitunit_testpolynomialfitting(bool *fiterrors) {
   ae_frame _frame_block;
   double threshold;
   double t;
   ae_int_t i;
   ae_int_t k;
   ae_int_t info;
   ae_int_t info2;
   double v;
   double v0;
   double v1;
   double v2;
   double s;
   double xmin;
   double xmax;
   double refrms;
   double refavg;
   double refavgrel;
   double refmax;
   ae_int_t n;
   ae_int_t m;
   ae_int_t maxn;
   ae_int_t pass;
   ae_int_t passcount;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(xfull, 0, DT_REAL);
   NewVector(yfull, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewVector(dc, 0, DT_INT);
   NewObj(barycentricinterpolant, p);
   NewObj(barycentricinterpolant, p1);
   NewObj(barycentricinterpolant, p2);
   NewObj(polynomialfitreport, rep);
   NewObj(polynomialfitreport, rep2);
   *fiterrors = false;
   maxn = 5;
   passcount = 20;
   threshold = 1.0E8 * machineepsilon;
// Test polynomial fitting
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
      // N=M+K fitting (i.e. interpolation)
         for (k = 0; k < n; k++) {
            taskgenint1d(-1.0, 1.0, n, &xfull, &yfull);
            ae_vector_set_length(&x, n - k);
            ae_vector_set_length(&y, n - k);
            ae_vector_set_length(&w, n - k);
            if (k > 0) {
               ae_vector_set_length(&xc, k);
               ae_vector_set_length(&yc, k);
               ae_vector_set_length(&dc, k);
            }
            for (i = 0; i < n - k; i++) {
               x.xR[i] = xfull.xR[i];
               y.xR[i] = yfull.xR[i];
               w.xR[i] = 1 + randomreal();
            }
            for (i = 0; i < k; i++) {
               xc.xR[i] = xfull.xR[n - k + i];
               yc.xR[i] = yfull.xR[n - k + i];
               dc.xZ[i] = 0;
            }
            polynomialfitwc(&x, &y, &w, n - k, &xc, &yc, &dc, k, n, &info, &p1, &rep);
            if (info <= 0) {
               *fiterrors = true;
            } else {
               for (i = 0; i < n - k; i++) {
                  *fiterrors = *fiterrors || fabs(barycentriccalc(&p1, x.xR[i]) - y.xR[i]) > threshold;
               }
               for (i = 0; i < k; i++) {
                  *fiterrors = *fiterrors || fabs(barycentriccalc(&p1, xc.xR[i]) - yc.xR[i]) > threshold;
               }
            }
         }
      // Testing constraints on derivatives.
      // Special tasks which will always have solution:
      // 1. P(0)=YC[0]
      // 2. P(0)=YC[0], P'(0)=YC[1]
         if (n > 1) {
            for (m = 3; m <= 5; m++) {
               for (k = 1; k <= 2; k++) {
                  taskgenint1d(-1.0, 1.0, n, &x, &y);
                  ae_vector_set_length(&w, n);
                  ae_vector_set_length(&xc, 2);
                  ae_vector_set_length(&yc, 2);
                  ae_vector_set_length(&dc, 2);
                  for (i = 0; i < n; i++) {
                     w.xR[i] = 1 + randomreal();
                  }
                  xc.xR[0] = 0.0;
                  yc.xR[0] = randommid();
                  dc.xZ[0] = 0;
                  xc.xR[1] = 0.0;
                  yc.xR[1] = randommid();
                  dc.xZ[1] = 1;
                  polynomialfitwc(&x, &y, &w, n, &xc, &yc, &dc, k, m, &info, &p1, &rep);
                  if (info <= 0) {
                     *fiterrors = true;
                  } else {
                     barycentricdiff1(&p1, 0.0, &v0, &v1);
                     *fiterrors = *fiterrors || fabs(v0 - yc.xR[0]) > threshold;
                     if (k == 2) {
                        *fiterrors = *fiterrors || fabs(v1 - yc.xR[1]) > threshold;
                     }
                  }
               }
            }
         }
      }
   }
   for (m = 2; m <= 8; m++) {
      for (pass = 1; pass <= passcount; pass++) {
      // General fitting
      //
      // interpolating function through M nodes should have
      // greater RMS error than fitting it through the same M nodes
         n = 100;
         ae_vector_set_length(&x2, n);
         ae_vector_set_length(&y2, n);
         ae_vector_set_length(&w2, n);
         xmin = 0.0;
         xmax = 2 * pi;
         for (i = 0; i < n; i++) {
            x2.xR[i] = 2 * pi * randomreal();
            y2.xR[i] = sin(x2.xR[i]);
            w2.xR[i] = 1.0;
         }
         ae_vector_set_length(&x, m);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            x.xR[i] = xmin + (xmax - xmin) * i / (m - 1);
            y.xR[i] = sin(x.xR[i]);
         }
         polynomialbuild(&x, &y, m, &p1);
         polynomialfitwc(&x2, &y2, &w2, n, &xc, &yc, &dc, 0, m, &info, &p2, &rep);
         if (info <= 0) {
            *fiterrors = true;
         } else {
         // calculate P1 (interpolant) RMS error, compare with P2 error
            v1 = 0.0;
            v2 = 0.0;
            for (i = 0; i < n; i++) {
               v1 += sqr(barycentriccalc(&p1, x2.xR[i]) - y2.xR[i]);
               v2 += sqr(barycentriccalc(&p2, x2.xR[i]) - y2.xR[i]);
            }
            v1 = sqrt(v1 / n);
            v2 = sqrt(v2 / n);
            *fiterrors = *fiterrors || v2 > v1;
            *fiterrors = *fiterrors || fabs(v2 - rep.rmserror) > threshold;
         }
      // compare weighted and non-weighted
         n = 20;
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
         ae_vector_set_length(&w, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = i + (randomreal() - 0.5);
            y.xR[i] = randommid();
            w.xR[i] = 1.0;
         }
         polynomialfitwc(&x, &y, &w, n, &xc, &yc, &dc, 0, m, &info, &p1, &rep);
         polynomialfit(&x, &y, n, m, &info2, &p2, &rep2);
         if (info <= 0 || info2 <= 0) {
            *fiterrors = true;
         } else {
         // calculate P1 (interpolant), compare with P2 error
         // compare RMS errors
            t = randommid();
            v1 = barycentriccalc(&p1, t);
            v2 = barycentriccalc(&p2, t);
            *fiterrors = *fiterrors || !approxequal(v2, v1, 1.0E-12);
            *fiterrors = *fiterrors || !approxequal(rep.rmserror, rep2.rmserror, 1.0E-12 * rmax3(1.0, rep.rmserror, rep2.rmserror));
            *fiterrors = *fiterrors || !approxequal(rep.avgerror, rep2.avgerror, 1.0E-12 * rmax3(1.0, rep.avgerror, rep2.avgerror));
            *fiterrors = *fiterrors || !approxequal(rep.avgrelerror, rep2.avgrelerror, 1.0E-12 * rmax3(1.0, rep.avgrelerror, rep2.avgrelerror));
            *fiterrors = *fiterrors || !approxequal(rep.maxerror, rep2.maxerror, 1.0E-12 * rmax3(1.0, rep.maxerror, rep2.maxerror));
         }
      }
   }
   for (m = 1; m <= maxn; m++) {
      for (pass = 1; pass <= passcount; pass++) {
         ae_assert(passcount >= 2, "PassCount should be 2 or greater!");
      // solve simple task (all X[] are the same, Y[] are specially
      // calculated to ensure simple form of all types of errors)
      // and check correctness of the errors calculated by subroutines
      //
      // First pass is done with zero Y[], other passes - with random Y[].
      // It should test both ability to correctly calculate errors and
      // ability to not fail while working with zeros :)
         n = 4 * maxn;
         if (pass == 1) {
            v1 = 0.0;
            v2 = 0.0;
            v = 0.0;
         } else {
            v1 = randomreal();
            v2 = randomreal();
            v = 1 + randomreal();
         }
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
         ae_vector_set_length(&w, n);
         for (i = 0; i < maxn; i++) {
            x.xR[4 * i + 0] = (double)i;
            y.xR[4 * i + 0] = v - v2;
            w.xR[4 * i + 0] = 1.0;
            x.xR[4 * i + 1] = (double)i;
            y.xR[4 * i + 1] = v - v1;
            w.xR[4 * i + 1] = 1.0;
            x.xR[4 * i + 2] = (double)i;
            y.xR[4 * i + 2] = v + v1;
            w.xR[4 * i + 2] = 1.0;
            x.xR[4 * i + 3] = (double)i;
            y.xR[4 * i + 3] = v + v2;
            w.xR[4 * i + 3] = 1.0;
         }
         refrms = sqrt((sqr(v1) + sqr(v2)) / 2);
         refavg = (fabs(v1) + fabs(v2)) / 2;
         if (pass == 1) {
            refavgrel = 0.0;
         } else {
            refavgrel = 0.25 * (fabs(v2) / fabs(v - v2) + fabs(v1) / fabs(v - v1) + fabs(v1) / fabs(v + v1) + fabs(v2) / fabs(v + v2));
         }
         refmax = rmax2(v1, v2);
      // Test errors correctness
         polynomialfit(&x, &y, n, m, &info, &p, &rep);
         if (info <= 0) {
            *fiterrors = true;
         } else {
            s = barycentriccalc(&p, 0.0);
            *fiterrors = *fiterrors || fabs(s - v) > threshold;
            *fiterrors = *fiterrors || fabs(rep.rmserror - refrms) > threshold;
            *fiterrors = *fiterrors || fabs(rep.avgerror - refavg) > threshold;
            *fiterrors = *fiterrors || fabs(rep.avgrelerror - refavgrel) > threshold;
            *fiterrors = *fiterrors || fabs(rep.maxerror - refmax) > threshold;
         }
      }
   }
   ae_frame_leave();
}

static void testlsfitunit_testrationalfitting(bool *fiterrors) {
   ae_frame _frame_block;
   double threshold;
   ae_int_t maxn;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t k;
   ae_int_t pass;
   double t;
   double s;
   double v;
   double v0;
   double v1;
   double v2;
   ae_int_t info;
   ae_int_t info2;
   double xmin;
   double xmax;
   double refrms;
   double refavg;
   double refavgrel;
   double refmax;
   ae_frame_make(&_frame_block);
   NewObj(barycentricinterpolant, b1);
   NewObj(barycentricinterpolant, b2);
   NewVector(x, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewVector(dc, 0, DT_INT);
   NewObj(barycentricfitreport, rep);
   NewObj(barycentricfitreport, rep2);
   *fiterrors = false;
// PassCount        number of repeated passes
// Threshold        error tolerance
// LipschitzTol     Lipschitz constant increase allowed
//                  when calculating constant on a twice denser grid
   passcount = 5;
   maxn = 15;
   threshold = 1000000 * machineepsilon;
// Test rational fitting:
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 2; n <= maxn; n++) {
      // N=M+K fitting (i.e. interpolation)
         for (k = 0; k < n; k++) {
            ae_vector_set_length(&x, n - k);
            ae_vector_set_length(&y, n - k);
            ae_vector_set_length(&w, n - k);
            if (k > 0) {
               ae_vector_set_length(&xc, k);
               ae_vector_set_length(&yc, k);
               ae_vector_set_length(&dc, k);
            }
            for (i = 0; i < n - k; i++) {
               x.xR[i] = (double)i / (n - 1);
               y.xR[i] = randommid();
               w.xR[i] = 1 + randomreal();
            }
            for (i = 0; i < k; i++) {
               xc.xR[i] = (double)(n - k + i) / (n - 1);
               yc.xR[i] = randommid();
               dc.xZ[i] = 0;
            }
            barycentricfitfloaterhormannwc(&x, &y, &w, n - k, &xc, &yc, &dc, k, n, &info, &b1, &rep);
            if (info <= 0) {
               *fiterrors = true;
            } else {
               for (i = 0; i < n - k; i++) {
                  *fiterrors = *fiterrors || fabs(barycentriccalc(&b1, x.xR[i]) - y.xR[i]) > threshold;
               }
               for (i = 0; i < k; i++) {
                  *fiterrors = *fiterrors || fabs(barycentriccalc(&b1, xc.xR[i]) - yc.xR[i]) > threshold;
               }
            }
         }
      // Testing constraints on derivatives:
      // * several M's are tried
      // * several K's are tried - 1, 2.
      // * constraints at the ends of the interval
         for (m = 3; m <= 5; m++) {
            for (k = 1; k <= 2; k++) {
               ae_vector_set_length(&x, n);
               ae_vector_set_length(&y, n);
               ae_vector_set_length(&w, n);
               ae_vector_set_length(&xc, 2);
               ae_vector_set_length(&yc, 2);
               ae_vector_set_length(&dc, 2);
               for (i = 0; i < n; i++) {
                  x.xR[i] = randommid();
                  y.xR[i] = randommid();
                  w.xR[i] = 1 + randomreal();
               }
               xc.xR[0] = -1.0;
               yc.xR[0] = randommid();
               dc.xZ[0] = 0;
               xc.xR[1] = 1.0;
               yc.xR[1] = randommid();
               dc.xZ[1] = 0;
               barycentricfitfloaterhormannwc(&x, &y, &w, n, &xc, &yc, &dc, k, m, &info, &b1, &rep);
               if (info <= 0) {
                  *fiterrors = true;
               } else {
                  for (i = 0; i < k; i++) {
                     barycentricdiff1(&b1, xc.xR[i], &v0, &v1);
                     *fiterrors = *fiterrors || fabs(v0 - yc.xR[i]) > threshold;
                  }
               }
            }
         }
      }
   }
   for (m = 2; m <= 8; m++) {
      for (pass = 1; pass <= passcount; pass++) {
      // General fitting
      //
      // interpolating function through M nodes should have
      // greater RMS error than fitting it through the same M nodes
         n = 100;
         ae_vector_set_length(&x2, n);
         ae_vector_set_length(&y2, n);
         ae_vector_set_length(&w2, n);
         xmin = maxrealnumber;
         xmax = -maxrealnumber;
         for (i = 0; i < n; i++) {
            x2.xR[i] = 2 * pi * randomreal();
            y2.xR[i] = sin(x2.xR[i]);
            w2.xR[i] = 1.0;
            xmin = rmin2(xmin, x2.xR[i]);
            xmax = rmax2(xmax, x2.xR[i]);
         }
         ae_vector_set_length(&x, m);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            x.xR[i] = xmin + (xmax - xmin) * i / (m - 1);
            y.xR[i] = sin(x.xR[i]);
         }
         barycentricbuildfloaterhormann(&x, &y, m, 3, &b1);
         barycentricfitfloaterhormannwc(&x2, &y2, &w2, n, &xc, &yc, &dc, 0, m, &info, &b2, &rep);
         if (info <= 0) {
            *fiterrors = true;
         } else {
         // calculate B1 (interpolant) RMS error, compare with B2 error
            v1 = 0.0;
            v2 = 0.0;
            for (i = 0; i < n; i++) {
               v1 += sqr(barycentriccalc(&b1, x2.xR[i]) - y2.xR[i]);
               v2 += sqr(barycentriccalc(&b2, x2.xR[i]) - y2.xR[i]);
            }
            v1 = sqrt(v1 / n);
            v2 = sqrt(v2 / n);
            *fiterrors = *fiterrors || v2 > v1;
            *fiterrors = *fiterrors || fabs(v2 - rep.rmserror) > threshold;
         }
      // compare weighted and non-weighted
         n = 20;
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
         ae_vector_set_length(&w, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = i + (randomreal() - 0.5);
            y.xR[i] = randommid();
            w.xR[i] = 1.0;
         }
         barycentricfitfloaterhormannwc(&x, &y, &w, n, &xc, &yc, &dc, 0, m, &info, &b1, &rep);
         barycentricfitfloaterhormann(&x, &y, n, m, &info2, &b2, &rep2);
         if (info <= 0 || info2 <= 0) {
            *fiterrors = true;
         } else {
         // calculate B1 (interpolant), compare with B2
         // compare RMS errors
            t = randommid();
            v1 = barycentriccalc(&b1, t);
            v2 = barycentriccalc(&b2, t);
            *fiterrors = *fiterrors || !approxequal(v2, v1, 1.0E-12);
            *fiterrors = *fiterrors || !approxequal(rep.rmserror, rep2.rmserror, 1.0E-12 * rmax3(1.0, rep.rmserror, rep2.rmserror));
            *fiterrors = *fiterrors || !approxequal(rep.avgerror, rep2.avgerror, 1.0E-12 * rmax3(1.0, rep.avgerror, rep2.avgerror));
            *fiterrors = *fiterrors || !approxequal(rep.avgrelerror, rep2.avgrelerror, 1.0E-12 * rmax3(1.0, rep.avgrelerror, rep2.avgrelerror));
            *fiterrors = *fiterrors || !approxequal(rep.maxerror, rep2.maxerror, 1.0E-12 * rmax3(1.0, rep.maxerror, rep2.maxerror));
         }
      }
   }
   for (pass = 1; pass <= passcount; pass++) {
      ae_assert(passcount >= 2, "PassCount should be 2 or greater!");
   // solve simple task (all X[] are the same, Y[] are specially
   // calculated to ensure simple form of all types of errors)
   // and check correctness of the errors calculated by subroutines
   //
   // First pass is done with zero Y[], other passes - with random Y[].
   // It should test both ability to correctly calculate errors and
   // ability to not fail while working with zeros :)
      n = 4;
      if (pass == 1) {
         v1 = 0.0;
         v2 = 0.0;
         v = 0.0;
      } else {
         v1 = randomreal();
         v2 = randomreal();
         v = 1 + randomreal();
      }
      ae_vector_set_length(&x, 4);
      ae_vector_set_length(&y, 4);
      ae_vector_set_length(&w, 4);
      x.xR[0] = 0.0;
      y.xR[0] = v - v2;
      w.xR[0] = 1.0;
      x.xR[1] = 0.0;
      y.xR[1] = v - v1;
      w.xR[1] = 1.0;
      x.xR[2] = 0.0;
      y.xR[2] = v + v1;
      w.xR[2] = 1.0;
      x.xR[3] = 0.0;
      y.xR[3] = v + v2;
      w.xR[3] = 1.0;
      refrms = sqrt((sqr(v1) + sqr(v2)) / 2);
      refavg = (fabs(v1) + fabs(v2)) / 2;
      if (pass == 1) {
         refavgrel = 0.0;
      } else {
         refavgrel = 0.25 * (fabs(v2) / fabs(v - v2) + fabs(v1) / fabs(v - v1) + fabs(v1) / fabs(v + v1) + fabs(v2) / fabs(v + v2));
      }
      refmax = rmax2(v1, v2);
   // Test errors correctness
      barycentricfitfloaterhormann(&x, &y, 4, 2, &info, &b1, &rep);
      if (info <= 0) {
         *fiterrors = true;
      } else {
         s = barycentriccalc(&b1, 0.0);
         *fiterrors = *fiterrors || fabs(s - v) > threshold;
         *fiterrors = *fiterrors || fabs(rep.rmserror - refrms) > threshold;
         *fiterrors = *fiterrors || fabs(rep.avgerror - refavg) > threshold;
         *fiterrors = *fiterrors || fabs(rep.avgrelerror - refavgrel) > threshold;
         *fiterrors = *fiterrors || fabs(rep.maxerror - refmax) > threshold;
      }
   }
   ae_frame_leave();
}

static void testlsfitunit_testsplinefitting(bool *fiterrors) {
   ae_frame _frame_block;
   double threshold;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t k;
   ae_int_t pass;
   double sa;
   double sb;
   ae_int_t info;
   ae_int_t info1;
   ae_int_t info2;
   double s;
   double ds;
   double d2s;
   ae_int_t stype;
   double t;
   double v;
   double v1;
   double v2;
   double refrms;
   double refavg;
   double refavgrel;
   double refmax;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(xc, 0, DT_REAL);
   NewVector(yc, 0, DT_REAL);
   NewVector(d, 0, DT_REAL);
   NewVector(dc, 0, DT_INT);
   NewObj(spline1dinterpolant, c);
   NewObj(spline1dinterpolant, c2);
   NewObj(spline1dfitreport, rep);
   NewObj(spline1dfitreport, rep2);
// Valyes:
// * pass count
// * threshold - for tests which must be satisfied exactly
   passcount = 20;
   threshold = 10000 * machineepsilon;
   *fiterrors = false;
// Test fitting by Cubic and Hermite splines (obsolete, but still supported)
   for (pass = 1; pass <= passcount; pass++) {
   // Cubic splines
   // Ability to handle boundary constraints (1-4 constraints on F, dF/dx).
      for (m = 4; m <= 8; m++) {
         for (k = 1; k <= 4; k++) {
            if (k >= m) {
               continue;
            }
            n = 100;
            ae_vector_set_length(&x, n);
            ae_vector_set_length(&y, n);
            ae_vector_set_length(&w, n);
            ae_vector_set_length(&xc, 4);
            ae_vector_set_length(&yc, 4);
            ae_vector_set_length(&dc, 4);
            sa = 1 + randomreal();
            sb = randommid();
            for (i = 0; i < n; i++) {
               x.xR[i] = sa * randomreal() + sb;
               y.xR[i] = randommid();
               w.xR[i] = 1 + randomreal();
            }
            xc.xR[0] = sb;
            yc.xR[0] = randommid();
            dc.xZ[0] = 0;
            xc.xR[1] = sb;
            yc.xR[1] = randommid();
            dc.xZ[1] = 1;
            xc.xR[2] = sa + sb;
            yc.xR[2] = randommid();
            dc.xZ[2] = 0;
            xc.xR[3] = sa + sb;
            yc.xR[3] = randommid();
            dc.xZ[3] = 1;
            spline1dfitcubicwc(&x, &y, &w, n, &xc, &yc, &dc, k, m, &info, &c, &rep);
            if (info <= 0) {
               *fiterrors = true;
            } else {
            // Check that constraints are satisfied
               for (i = 0; i < k; i++) {
                  spline1ddiff(&c, xc.xR[i], &s, &ds, &d2s);
                  if (dc.xZ[i] == 0) {
                     *fiterrors = *fiterrors || fabs(s - yc.xR[i]) > threshold;
                  }
                  if (dc.xZ[i] == 1) {
                     *fiterrors = *fiterrors || fabs(ds - yc.xR[i]) > threshold;
                  }
                  if (dc.xZ[i] == 2) {
                     *fiterrors = *fiterrors || fabs(d2s - yc.xR[i]) > threshold;
                  }
               }
            }
         }
      }
   // Cubic splines
   // Ability to handle one internal constraint
      for (m = 4; m <= 8; m++) {
         n = 100;
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
         ae_vector_set_length(&w, n);
         ae_vector_set_length(&xc, 1);
         ae_vector_set_length(&yc, 1);
         ae_vector_set_length(&dc, 1);
         sa = 1 + randomreal();
         sb = randommid();
         for (i = 0; i < n; i++) {
            x.xR[i] = sa * randomreal() + sb;
            y.xR[i] = randommid();
            w.xR[i] = 1 + randomreal();
         }
         xc.xR[0] = sa * randomreal() + sb;
         yc.xR[0] = randommid();
         dc.xZ[0] = randominteger(2);
         spline1dfitcubicwc(&x, &y, &w, n, &xc, &yc, &dc, 1, m, &info, &c, &rep);
         if (info <= 0) {
            *fiterrors = true;
         } else {
         // Check that constraints are satisfied
            spline1ddiff(&c, xc.xR[0], &s, &ds, &d2s);
            if (dc.xZ[0] == 0) {
               *fiterrors = *fiterrors || fabs(s - yc.xR[0]) > threshold;
            }
            if (dc.xZ[0] == 1) {
               *fiterrors = *fiterrors || fabs(ds - yc.xR[0]) > threshold;
            }
            if (dc.xZ[0] == 2) {
               *fiterrors = *fiterrors || fabs(d2s - yc.xR[0]) > threshold;
            }
         }
      }
   // Hermite splines
   // Ability to handle boundary constraints (1-4 constraints on F, dF/dx).
      for (m = 4; m <= 8; m++) {
         for (k = 1; k <= 4; k++) {
            if (k >= m) {
               continue;
            }
            if (m % 2 != 0) {
               continue;
            }
            n = 100;
            ae_vector_set_length(&x, n);
            ae_vector_set_length(&y, n);
            ae_vector_set_length(&w, n);
            ae_vector_set_length(&xc, 4);
            ae_vector_set_length(&yc, 4);
            ae_vector_set_length(&dc, 4);
            sa = 1 + randomreal();
            sb = randommid();
            for (i = 0; i < n; i++) {
               x.xR[i] = sa * randomreal() + sb;
               y.xR[i] = randommid();
               w.xR[i] = 1 + randomreal();
            }
            xc.xR[0] = sb;
            yc.xR[0] = randommid();
            dc.xZ[0] = 0;
            xc.xR[1] = sb;
            yc.xR[1] = randommid();
            dc.xZ[1] = 1;
            xc.xR[2] = sa + sb;
            yc.xR[2] = randommid();
            dc.xZ[2] = 0;
            xc.xR[3] = sa + sb;
            yc.xR[3] = randommid();
            dc.xZ[3] = 1;
            spline1dfithermitewc(&x, &y, &w, n, &xc, &yc, &dc, k, m, &info, &c, &rep);
            if (info <= 0) {
               *fiterrors = true;
            } else {
            // Check that constraints are satisfied
               for (i = 0; i < k; i++) {
                  spline1ddiff(&c, xc.xR[i], &s, &ds, &d2s);
                  if (dc.xZ[i] == 0) {
                     *fiterrors = *fiterrors || fabs(s - yc.xR[i]) > threshold;
                  }
                  if (dc.xZ[i] == 1) {
                     *fiterrors = *fiterrors || fabs(ds - yc.xR[i]) > threshold;
                  }
                  if (dc.xZ[i] == 2) {
                     *fiterrors = *fiterrors || fabs(d2s - yc.xR[i]) > threshold;
                  }
               }
            }
         }
      }
   // Hermite splines
   // Ability to handle one internal constraint
      for (m = 4; m <= 8; m++) {
         if (m % 2 != 0) {
            continue;
         }
         n = 100;
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
         ae_vector_set_length(&w, n);
         ae_vector_set_length(&xc, 1);
         ae_vector_set_length(&yc, 1);
         ae_vector_set_length(&dc, 1);
         sa = 1 + randomreal();
         sb = randommid();
         for (i = 0; i < n; i++) {
            x.xR[i] = sa * randomreal() + sb;
            y.xR[i] = randommid();
            w.xR[i] = 1 + randomreal();
         }
         xc.xR[0] = sa * randomreal() + sb;
         yc.xR[0] = randommid();
         dc.xZ[0] = randominteger(2);
         spline1dfithermitewc(&x, &y, &w, n, &xc, &yc, &dc, 1, m, &info, &c, &rep);
         if (info <= 0) {
            *fiterrors = true;
         } else {
         // Check that constraints are satisfied
            spline1ddiff(&c, xc.xR[0], &s, &ds, &d2s);
            if (dc.xZ[0] == 0) {
               *fiterrors = *fiterrors || fabs(s - yc.xR[0]) > threshold;
            }
            if (dc.xZ[0] == 1) {
               *fiterrors = *fiterrors || fabs(ds - yc.xR[0]) > threshold;
            }
            if (dc.xZ[0] == 2) {
               *fiterrors = *fiterrors || fabs(d2s - yc.xR[0]) > threshold;
            }
         }
      }
   }
   for (m = 4; m <= 8; m++) {
      for (stype = 0; stype <= 1; stype++) {
         for (pass = 1; pass <= passcount; pass++) {
            if (stype == 1 && m % 2 != 0) {
               continue;
            }
         // cubic/Hermite spline fitting:
         // * generate "template spline" C2
         // * generate 2*N points from C2, such that result of
         //   ideal fit should be equal to C2
         // * fit, store in C
         // * compare C and C2
            sa = 1 + randomreal();
            sb = randommid();
            if (stype == 0) {
               ae_vector_set_length(&x, m - 2);
               ae_vector_set_length(&y, m - 2);
               for (i = 0; i < m - 2; i++) {
                  x.xR[i] = sa * i / (m - 2 - 1) + sb;
                  y.xR[i] = randommid();
               }
               spline1dbuildcubic(&x, &y, m - 2, 1, randommid(), 1, randommid(), &c2);
            }
            if (stype == 1) {
               ae_vector_set_length(&x, m / 2);
               ae_vector_set_length(&y, m / 2);
               ae_vector_set_length(&d, m / 2);
               for (i = 0; i < m / 2; i++) {
                  x.xR[i] = sa * i / (m / 2 - 1) + sb;
                  y.xR[i] = randommid();
                  d.xR[i] = randommid();
               }
               spline1dbuildhermite(&x, &y, &d, m / 2, &c2);
            }
            n = 50;
            ae_vector_set_length(&x, 2 * n);
            ae_vector_set_length(&y, 2 * n);
            ae_vector_set_length(&w, 2 * n);
            for (i = 0; i < n; i++) {
            // "if i=0" and "if i=1" are needed to
            // synchronize interval size for C2 and
            // spline being fitted (i.e. C).
               t = randomreal();
               x.xR[i] = sa * randomreal() + sb;
               if (i == 0) {
                  x.xR[i] = sb;
               }
               if (i == 1) {
                  x.xR[i] = sa + sb;
               }
               v = spline1dcalc(&c2, x.xR[i]);
               y.xR[i] = v + t;
               w.xR[i] = 1 + randomreal();
               x.xR[n + i] = x.xR[i];
               y.xR[n + i] = v - t;
               w.xR[n + i] = w.xR[i];
            }
            info = -1;
            if (stype == 0) {
               spline1dfitcubicwc(&x, &y, &w, 2 * n, &xc, &yc, &dc, 0, m, &info, &c, &rep);
            }
            if (stype == 1) {
               spline1dfithermitewc(&x, &y, &w, 2 * n, &xc, &yc, &dc, 0, m, &info, &c, &rep);
            }
            if (info <= 0) {
               *fiterrors = true;
            } else {
               for (i = 0; i < n; i++) {
                  v = sa * randomreal() + sb;
                  *fiterrors = *fiterrors || fabs(spline1dcalc(&c, v) - spline1dcalc(&c2, v)) > threshold;
               }
            }
         }
      }
   }
   for (m = 4; m <= 8; m++) {
      for (pass = 1; pass <= passcount; pass++) {
      // prepare points/weights
         n = 10 + randominteger(10);
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, n);
         ae_vector_set_length(&w, n);
         for (i = 0; i < n; i++) {
            x.xR[i] = i + (randomreal() - 0.5);
            y.xR[i] = randommid();
            w.xR[i] = 1.0;
         }
      // Fit cubic with unity weights, without weights, then compare
         if (m >= 4) {
            spline1dfitcubicwc(&x, &y, &w, n, &xc, &yc, &dc, 0, m, &info1, &c, &rep);
            spline1dfitcubic(&x, &y, n, m, &info2, &c2, &rep2);
            if (info1 <= 0 || info2 <= 0) {
               *fiterrors = true;
            } else {
               for (i = 0; i < n; i++) {
                  v = randomreal() * (n - 1);
                  *fiterrors = *fiterrors || !approxequal(spline1dcalc(&c, v), spline1dcalc(&c2, v), 1.0E-12);
                  *fiterrors = *fiterrors || !approxequal(rep.taskrcond, rep2.taskrcond, 1.0E-12 * rmax3(1.0, rep.taskrcond, rep2.taskrcond));
                  *fiterrors = *fiterrors || !approxequal(rep.rmserror, rep2.rmserror, 1.0E-12 * rmax3(1.0, rep.rmserror, rep2.rmserror));
                  *fiterrors = *fiterrors || !approxequal(rep.avgerror, rep2.avgerror, 1.0E-12 * rmax3(1.0, rep.avgerror, rep2.avgerror));
                  *fiterrors = *fiterrors || !approxequal(rep.avgrelerror, rep2.avgrelerror, 1.0E-12 * rmax3(1.0, rep.avgrelerror, rep2.avgrelerror));
                  *fiterrors = *fiterrors || !approxequal(rep.maxerror, rep2.maxerror, 1.0E-12 * rmax3(1.0, rep.maxerror, rep2.maxerror));
               }
            }
         }
      // Fit Hermite with unity weights, without weights, then compare
         if (m >= 4 && m % 2 == 0) {
            spline1dfithermitewc(&x, &y, &w, n, &xc, &yc, &dc, 0, m, &info1, &c, &rep);
            spline1dfithermite(&x, &y, n, m, &info2, &c2, &rep2);
            if (info1 <= 0 || info2 <= 0) {
               *fiterrors = true;
            } else {
               for (i = 0; i < n; i++) {
                  v = randomreal() * (n - 1);
                  *fiterrors = *fiterrors || !approxequal(spline1dcalc(&c, v), spline1dcalc(&c2, v), 1.0E-12);
                  *fiterrors = *fiterrors || !approxequal(rep.taskrcond, rep2.taskrcond, 1.0E-12 * rmax3(1.0, rep.taskrcond, rep2.taskrcond));
                  *fiterrors = *fiterrors || !approxequal(rep.rmserror, rep2.rmserror, 1.0E-12 * rmax3(1.0, rep.rmserror, rep2.rmserror));
                  *fiterrors = *fiterrors || !approxequal(rep.avgerror, rep2.avgerror, 1.0E-12 * rmax3(1.0, rep.avgerror, rep2.avgerror));
                  *fiterrors = *fiterrors || !approxequal(rep.avgrelerror, rep2.avgrelerror, 1.0E-12 * rmax3(1.0, rep.avgrelerror, rep2.avgrelerror));
                  *fiterrors = *fiterrors || !approxequal(rep.maxerror, rep2.maxerror, 1.0E-12 * rmax3(1.0, rep.maxerror, rep2.maxerror));
               }
            }
         }
      }
   }
// Check correctness of error reports
   for (pass = 1; pass <= passcount; pass++) {
      ae_assert(passcount >= 2, "PassCount should be 2 or greater!");
   // solve simple task (all X[] are the same, Y[] are specially
   // calculated to ensure simple form of all types of errors)
   // and check correctness of the errors calculated by subroutines
   //
   // First pass is done with zero Y[], other passes - with random Y[].
   // It should test both ability to correctly calculate errors and
   // ability to not fail while working with zeros :)
      n = 4;
      if (pass == 1) {
         v1 = 0.0;
         v2 = 0.0;
         v = 0.0;
      } else {
         v1 = randomreal();
         v2 = randomreal();
         v = 1 + randomreal();
      }
      ae_vector_set_length(&x, 4);
      ae_vector_set_length(&y, 4);
      ae_vector_set_length(&w, 4);
      x.xR[0] = 0.0;
      y.xR[0] = v - v2;
      w.xR[0] = 1.0;
      x.xR[1] = 0.0;
      y.xR[1] = v - v1;
      w.xR[1] = 1.0;
      x.xR[2] = 0.0;
      y.xR[2] = v + v1;
      w.xR[2] = 1.0;
      x.xR[3] = 0.0;
      y.xR[3] = v + v2;
      w.xR[3] = 1.0;
      refrms = sqrt((sqr(v1) + sqr(v2)) / 2);
      refavg = (fabs(v1) + fabs(v2)) / 2;
      if (pass == 1) {
         refavgrel = 0.0;
      } else {
         refavgrel = 0.25 * (fabs(v2) / fabs(v - v2) + fabs(v1) / fabs(v - v1) + fabs(v1) / fabs(v + v1) + fabs(v2) / fabs(v + v2));
      }
      refmax = rmax2(v1, v2);
   // Test cubic fitting
      spline1dfitcubic(&x, &y, 4, 4, &info, &c, &rep);
      if (info <= 0) {
         *fiterrors = true;
      } else {
         s = spline1dcalc(&c, 0.0);
         *fiterrors = *fiterrors || fabs(s - v) > threshold;
         *fiterrors = *fiterrors || fabs(rep.rmserror - refrms) > threshold;
         *fiterrors = *fiterrors || fabs(rep.avgerror - refavg) > threshold;
         *fiterrors = *fiterrors || fabs(rep.avgrelerror - refavgrel) > threshold;
         *fiterrors = *fiterrors || fabs(rep.maxerror - refmax) > threshold;
      }
   // Test Hermite fitting
      spline1dfithermite(&x, &y, 4, 4, &info, &c, &rep);
      if (info <= 0) {
         *fiterrors = true;
      } else {
         s = spline1dcalc(&c, 0.0);
         *fiterrors = *fiterrors || fabs(s - v) > threshold;
         *fiterrors = *fiterrors || fabs(rep.rmserror - refrms) > threshold;
         *fiterrors = *fiterrors || fabs(rep.avgerror - refavg) > threshold;
         *fiterrors = *fiterrors || fabs(rep.avgrelerror - refavgrel) > threshold;
         *fiterrors = *fiterrors || fabs(rep.maxerror - refmax) > threshold;
      }
   }
   ae_frame_leave();
}

// Test function 1:
//
//     F(K, X, Z) = SUM( (power(z_j,3)+alpha*z_j)*x_ij )
//
// here X is a space of points, Z is a space of parameters
static void testlsfitunit_testfunc1(ae_int_t k, RVector *x, RVector *z, double *f, bool needf, RVector *g, bool needg) {
   ae_int_t j;
   double v;
   double alpha;
   alpha = 0.01;
   v = 0.0;
   for (j = 0; j < k; j++) {
      v += (alpha * z->xR[j] + pow(z->xR[j], 3.0)) * x->xR[j];
      if (needg) {
         g->xR[j] = (alpha + 3 * pow(z->xR[j], 2.0)) * x->xR[j];
      }
   }
   if (needf) {
      *f = v;
   }
}

// Test function 2:
//
//     F(X|C) = c_0
//
// here X is a space of points, C is a space of parameters
static void testlsfitunit_testfunc2(RVector *x, ae_int_t nx, RVector *c, ae_int_t nc, double *f, bool needf, RVector *g, bool needg) {
   ae_assert(nc == 1, "TestFunc2: integrity check failure");
   if (needf) {
      *f = c->xR[0];
   }
   if (needg) {
      g->xR[0] = 1.0;
   }
}

// Test function 3:
//
//     F(X|C) = c_0 + c_1*x0 + c_2*x0^2 + ...
//
// here X is a space of points, C is a space of parameters
static void testlsfitunit_testfunc3(RVector *x, ae_int_t nx, RVector *c, ae_int_t nc, double *f, bool needf, RVector *g, bool needg) {
   double v;
   ae_int_t i;
   ae_assert(nx == 1, "TestFunc3: integrity check failure");
   v = 0.0;
   for (i = 0; i < nc; i++) {
      v += c->xR[i] * pow(x->xR[0], (double)i);
      if (needg) {
         g->xR[i] = pow(x->xR[0], (double)i);
      }
   }
   if (needf) {
      *f = v;
   }
}

// Test for box constrained problemsNLS.
// On failure sets error flag, leaves it unchanged on success.
static void testlsfitunit_testbcnls(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t nc;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ii;
   double v;
   double h;
   double epsx;
   double f0;
   double f1;
   ae_int_t tmpkind;
   ae_int_t terminationtype;
   double relaxationshift;
   ae_frame_make(&_frame_block);
   NewObj(lsfitstate, state);
   NewObj(lsfitreport, rep);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(c0, 0, DT_REAL);
   NewVector(c1, 0, DT_REAL);
   NewVector(c2, 0, DT_REAL);
   NewMatrix(xx, 0, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Fit
//
//                 [                              ]
//    f(X|C)= SUM_j[ (alpha*c_j+power(c_j,3))*x_j ]
//                 [                              ]
//
// subject to non-negativity constraints on c_j
   epsx = 1.0E-9;
   for (tmpkind = 0; tmpkind <= 1; tmpkind++) {
      for (nc = 1; nc <= 20; nc++) {
         nx = nc;
         m = nc + hqrnduniformi(&rs, nc);
         ae_vector_set_length(&bl, nc);
         ae_vector_set_length(&bu, nc);
         ae_vector_set_length(&c0, nc);
         ae_vector_set_length(&x, nx);
         for (i = 0; i < nc; i++) {
            bl.xR[i] = 0.0;
            bu.xR[i] = +INFINITY;
            c0.xR[i] = 1 + hqrnduniformr(&rs);
         }
         ae_matrix_set_length(&xx, m, nx);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < nx; j++) {
               xx.xyR[i][j] = hqrndnormal(&rs);
            }
            y.xR[i] = hqrndnormal(&rs);
         }
         if (tmpkind == 0) {
            lsfitcreatef(&xx, &y, &c0, m, nx, nc, 10 * epsx, &state);
         }
         if (tmpkind == 1) {
            lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
         }
         lsfitsetcond(&state, epsx, 0);
         lsfitsetbc(&state, &bl, &bu);
         while (lsfititeration(&state)) {
            for (i = 0; i < nc; i++) {
               set_error_flag(errorflag, state.c.xR[i] < bl.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2604");
               set_error_flag(errorflag, state.c.xR[i] > bu.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2605");
            }
            if (state.needf) {
               testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, false);
               continue;
            }
            if (state.needfg) {
               testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, true);
               continue;
            }
            ae_assert(false, "minlm test: integrity check failed");
         }
         lsfitresults(&state, &terminationtype, &c1, &rep);
         set_error_flag(errorflag, terminationtype <= 0, __FILE__, __LINE__, "testlsfitunit.ap:2620");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         f0 = 0.0;
         for (ii = 0; ii < m; ii++) {
            ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
            testlsfitunit_testfunc1(nx, &x, &c1, &v, true, &state.g, false);
            f0 += sqr(v - y.xR[ii]);
         }
         h = 0.001;
         ae_vector_set_length(&c2, nc);
         for (i = 0; i < nc; i++) {
            set_error_flag(errorflag, c1.xR[i] < bl.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2637");
            set_error_flag(errorflag, c1.xR[i] > bu.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2638");
            if (c1.xR[i] + h >= bl.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] += h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc1(nx, &x, &c2, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               set_error_flag(errorflag, f1 < f0, __FILE__, __LINE__, "testlsfitunit.ap:2653");
            }
            if (c1.xR[i] - h >= bl.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] -= h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc1(nx, &x, &c2, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               set_error_flag(errorflag, f1 < f0, __FILE__, __LINE__, "testlsfitunit.ap:2669");
            }
         }
      }
   }
// Fit
//
//                 [                              ]
//    f(X|C)= SUM_j[ (alpha*c_j+power(c_j,3))*x_j ]
//                 [                              ]
//
// subject to random box constraints on c_j
   epsx = 1.0E-9;
   for (tmpkind = 0; tmpkind <= 1; tmpkind++) {
      for (nc = 1; nc <= 20; nc++) {
         nx = nc;
         m = nc + hqrnduniformi(&rs, nc);
         ae_vector_set_length(&bl, nc);
         ae_vector_set_length(&bu, nc);
         ae_vector_set_length(&c0, nc);
         ae_vector_set_length(&x, nx);
         for (i = 0; i < nc; i++) {
            bl.xR[i] = hqrndnormal(&rs);
            bu.xR[i] = bl.xR[i] + hqrnduniformr(&rs);
            c0.xR[i] = 1 + hqrnduniformr(&rs);
         }
         ae_matrix_set_length(&xx, m, nx);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < nx; j++) {
               xx.xyR[i][j] = hqrndnormal(&rs);
            }
            y.xR[i] = hqrndnormal(&rs);
         }
         if (tmpkind == 0) {
            lsfitcreatef(&xx, &y, &c0, m, nx, nc, 10 * epsx, &state);
         }
         if (tmpkind == 1) {
            lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
         }
         lsfitsetcond(&state, epsx, 0);
         lsfitsetbc(&state, &bl, &bu);
         while (lsfititeration(&state)) {
            for (i = 0; i < nc; i++) {
               set_error_flag(errorflag, state.c.xR[i] < bl.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2718");
               set_error_flag(errorflag, state.c.xR[i] > bu.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2719");
            }
            if (state.needf) {
               testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, false);
               continue;
            }
            if (state.needfg) {
               testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, true);
               continue;
            }
            ae_assert(false, "minlm test: integrity check failed");
         }
         lsfitresults(&state, &terminationtype, &c1, &rep);
         set_error_flag(errorflag, terminationtype <= 0, __FILE__, __LINE__, "testlsfitunit.ap:2734");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
      // evaluate value at C1 and compare with value at trial points
         f0 = 0.0;
         for (ii = 0; ii < m; ii++) {
            ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
            testlsfitunit_testfunc1(nx, &x, &c1, &v, true, &state.g, false);
            f0 += sqr(v - y.xR[ii]);
         }
         h = 0.001;
         relaxationshift = rmax2(fabs(f0), 1.0) * sqrt(machineepsilon);
         ae_vector_set_length(&c2, nc);
         for (i = 0; i < nc; i++) {
            set_error_flag(errorflag, c1.xR[i] < bl.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2754");
            set_error_flag(errorflag, c1.xR[i] > bu.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2755");
            if (c1.xR[i] + h >= bl.xR[i] && c1.xR[i] + h <= bu.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] += h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc1(nx, &x, &c2, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               set_error_flag(errorflag, f1 < f0 - relaxationshift, __FILE__, __LINE__, "testlsfitunit.ap:2770");
            }
            if (c1.xR[i] - h >= bl.xR[i] && c1.xR[i] - h <= bu.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] -= h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc1(nx, &x, &c2, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               set_error_flag(errorflag, f1 < f0 - relaxationshift, __FILE__, __LINE__, "testlsfitunit.ap:2786");
            }
         }
      }
   }
// Fit
//
//
//    f(X|C)= c_0
//
//
// subject to random box constraints on c_0, where X is N-dimensional vector
// (f does not depend on X, and it is not an error! we just test that sizes
// of X and C are correctly handled).
   epsx = 1.0E-9;
   for (tmpkind = 0; tmpkind <= 1; tmpkind++) {
      for (nx = 1; nx <= 20; nx++) {
         nc = 1;
         m = nx + hqrnduniformi(&rs, nx);
         ae_vector_set_length(&bl, nc);
         ae_vector_set_length(&bu, nc);
         ae_vector_set_length(&c0, nc);
         ae_vector_set_length(&x, nx);
         for (i = 0; i < nc; i++) {
            bl.xR[i] = hqrndnormal(&rs);
            bu.xR[i] = bl.xR[i] + hqrnduniformr(&rs);
            c0.xR[i] = 1 + hqrnduniformr(&rs);
         }
         ae_matrix_set_length(&xx, m, nx);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < nx; j++) {
               xx.xyR[i][j] = hqrndnormal(&rs);
            }
            y.xR[i] = hqrndnormal(&rs);
         }
         if (tmpkind == 0) {
            lsfitcreatef(&xx, &y, &c0, m, nx, nc, 10 * epsx, &state);
         }
         if (tmpkind == 1) {
            lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
         }
         lsfitsetcond(&state, epsx, 0);
         lsfitsetbc(&state, &bl, &bu);
         while (lsfititeration(&state)) {
            for (i = 0; i < nc; i++) {
               set_error_flag(errorflag, state.c.xR[i] < bl.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2837");
               set_error_flag(errorflag, state.c.xR[i] > bu.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2838");
            }
            if (state.needf) {
               testlsfitunit_testfunc2(&state.x, nx, &state.c, nc, &state.f, true, &state.g, false);
               continue;
            }
            if (state.needfg) {
               testlsfitunit_testfunc2(&state.x, nx, &state.c, nc, &state.f, true, &state.g, true);
               continue;
            }
            ae_assert(false, "minlm test: integrity check failed");
         }
         lsfitresults(&state, &terminationtype, &c1, &rep);
         set_error_flag(errorflag, terminationtype <= 0, __FILE__, __LINE__, "testlsfitunit.ap:2853");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         f0 = 0.0;
         for (ii = 0; ii < m; ii++) {
            ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
            testlsfitunit_testfunc2(&x, nx, &c1, nc, &v, true, &state.g, false);
            f0 += sqr(v - y.xR[ii]);
         }
         h = 0.001;
         ae_vector_set_length(&c2, nc);
         for (i = 0; i < nc; i++) {
            set_error_flag(errorflag, c1.xR[i] < bl.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2870");
            set_error_flag(errorflag, c1.xR[i] > bu.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2871");
            if (c1.xR[i] + h >= bl.xR[i] && c1.xR[i] + h <= bu.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] += h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc2(&x, nx, &c2, nc, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               set_error_flag(errorflag, f1 < f0, __FILE__, __LINE__, "testlsfitunit.ap:2886");
            }
            if (c1.xR[i] - h >= bl.xR[i] && c1.xR[i] - h <= bu.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] -= h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc2(&x, nx, &c2, nc, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               set_error_flag(errorflag, f1 < f0, __FILE__, __LINE__, "testlsfitunit.ap:2902");
            }
         }
      }
   }
// Fit
//
//
//    f(X|C)= c_0 + c_1*x0 + c_2*x0^2 + ...
//
//
// subject to random box constraints on c.
   epsx = 1.0E-9;
   for (tmpkind = 0; tmpkind <= 1; tmpkind++) {
      for (nc = 1; nc <= 5; nc++) {
         nx = 1;
         m = 10 + nc + hqrnduniformi(&rs, nc);
         ae_vector_set_length(&bl, nc);
         ae_vector_set_length(&bu, nc);
         ae_vector_set_length(&c0, nc);
         ae_vector_set_length(&x, nx);
         for (i = 0; i < nc; i++) {
            bl.xR[i] = hqrndnormal(&rs);
            bu.xR[i] = bl.xR[i] + hqrnduniformr(&rs);
            c0.xR[i] = hqrndnormal(&rs);
         }
         ae_matrix_set_length(&xx, m, nx);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < nx; j++) {
               xx.xyR[i][j] = hqrndnormal(&rs);
            }
            y.xR[i] = hqrndnormal(&rs);
         }
         if (tmpkind == 0) {
            lsfitcreatef(&xx, &y, &c0, m, nx, nc, 10 * epsx, &state);
         }
         if (tmpkind == 1) {
            lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
         }
         lsfitsetcond(&state, epsx, 0);
         lsfitsetbc(&state, &bl, &bu);
         while (lsfititeration(&state)) {
            for (i = 0; i < nc; i++) {
               set_error_flag(errorflag, state.c.xR[i] < bl.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2951");
               set_error_flag(errorflag, state.c.xR[i] > bu.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2952");
            }
            if (state.needf) {
               testlsfitunit_testfunc3(&state.x, nx, &state.c, nc, &state.f, true, &state.g, false);
               continue;
            }
            if (state.needfg) {
               testlsfitunit_testfunc3(&state.x, nx, &state.c, nc, &state.f, true, &state.g, true);
               continue;
            }
            ae_assert(false, "minlm test: integrity check failed");
         }
         lsfitresults(&state, &terminationtype, &c1, &rep);
         set_error_flag(errorflag, terminationtype <= 0, __FILE__, __LINE__, "testlsfitunit.ap:2967");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         f0 = 0.0;
         for (ii = 0; ii < m; ii++) {
            ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
            testlsfitunit_testfunc3(&x, nx, &c1, nc, &v, true, &state.g, false);
            f0 += sqr(v - y.xR[ii]);
         }
         h = 0.001;
         ae_vector_set_length(&c2, nc);
         for (i = 0; i < nc; i++) {
            set_error_flag(errorflag, c1.xR[i] < bl.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2984");
            set_error_flag(errorflag, c1.xR[i] > bu.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:2985");
            if (c1.xR[i] + h >= bl.xR[i] && c1.xR[i] + h <= bu.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] += h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc3(&x, nx, &c2, nc, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               set_error_flag(errorflag, f1 < f0, __FILE__, __LINE__, "testlsfitunit.ap:3000");
            }
            if (c1.xR[i] - h >= bl.xR[i] && c1.xR[i] - h <= bu.xR[i]) {
               for (j = 0; j < nc; j++) {
                  c2.xR[j] = c1.xR[j];
               }
               c2.xR[i] -= h;
               f1 = 0.0;
               for (ii = 0; ii < m; ii++) {
                  ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
                  testlsfitunit_testfunc3(&x, nx, &c2, nc, &v, true, &state.g, false);
                  f1 += sqr(v - y.xR[ii]);
               }
               set_error_flag(errorflag, f1 < f0, __FILE__, __LINE__, "testlsfitunit.ap:3016");
            }
         }
      }
   }
   ae_frame_leave();
}

// Test for linearly constrained NLS problems.
// On failure sets error flag, leaves it unchanged on success.
static void testlsfitunit_testlcnls(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t nc;
   ae_int_t m;
   ae_int_t rawccnt;
   ae_int_t trialidx;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ii;
   double v;
   double h;
   ae_int_t optkind;
   double epsx;
   double xtol;
   double f0;
   double f1;
   bool bflag;
   ae_int_t terminationtype;
   ae_frame_make(&_frame_block);
   NewObj(lsfitstate, state);
   NewObj(lsfitreport, rep);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(c0, 0, DT_REAL);
   NewVector(c1, 0, DT_REAL);
   NewVector(c2, 0, DT_REAL);
   NewMatrix(rawc, 0, 0, DT_REAL);
   NewVector(rawct, 0, DT_INT);
   NewMatrix(xx, 0, 0, DT_REAL);
   NewMatrix(xx12, 0, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Minimize
//
//          [      [                             ]2  ]
//     SUM_i[ SUM_j[ (0.1*x_j+power(x_j,3))*c_ij ]   ]
//          [      [                             ]   ]
//
// subject to mix of box and linear inequality constraints on x_j
//
// We check correctness of solution by sampling a few random points
// around one returned by optimizer, and comparing function value
// with target. Sampling is performed with respect to inequality
// constraints.
   epsx = 1.0E-12;
   xtol = 1.0E-8;
   optkind = 1;
   for (nc = 5; nc <= 20; nc++) {
   // Generate problem
      nx = nc;
      m = nc + hqrnduniformi(&rs, nc);
      ae_vector_set_length(&bl, nc);
      ae_vector_set_length(&bu, nc);
      ae_vector_set_length(&c0, nc);
      ae_vector_set_length(&x, nx);
      for (i = 0; i < nc; i++) {
         bl.xR[i] = hqrndnormal(&rs);
         bu.xR[i] = bl.xR[i] + 0.01 + hqrnduniformr(&rs);
         c0.xR[i] = bl.xR[i] + (bu.xR[i] - bl.xR[i]) * hqrnduniformr(&rs);
      }
      ae_matrix_set_length(&xx, m, nx);
      ae_vector_set_length(&y, m);
      for (i = 0; i < m; i++) {
         for (j = 0; j < nx; j++) {
            xx.xyR[i][j] = hqrndnormal(&rs);
         }
         y.xR[i] = hqrndnormal(&rs);
      }
      ae_assert(nc >= 5, "Assertion failed");
      rawccnt = 3;
      ae_matrix_set_length(&rawc, rawccnt, nc + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         v = 0.0;
         for (j = 0; j < nc; j++) {
            rawc.xyR[i][j] = hqrndnormal(&rs);
            v += c0.xR[j] * rawc.xyR[i][j];
         }
         rawc.xyR[i][nc] = v;
         rawct.xZ[i] = 2 * hqrnduniformi(&rs, 2) - 1;
      }
   // Solve
      if (optkind == 0) {
         lsfitcreatef(&xx, &y, &c0, m, nx, nc, 1.0E-6, &state);
      }
      if (optkind == 1) {
         lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
      }
      lsfitsetcond(&state, epsx, 0);
      lsfitsetbc(&state, &bl, &bu);
      lsfitsetlc(&state, &rawc, &rawct, rawccnt);
      while (lsfititeration(&state)) {
         for (i = 0; i < nc; i++) {
            set_error_flag(errorflag, state.c.xR[i] < bl.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:3125");
            set_error_flag(errorflag, state.c.xR[i] > bu.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:3126");
         }
         if (state.needf) {
            testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, false);
            continue;
         }
         if (state.needfg) {
            testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, true);
            continue;
         }
         ae_assert(false, "lsfit test: integrity check failed");
      }
      lsfitresults(&state, &terminationtype, &c1, &rep);
      set_error_flag(errorflag, terminationtype <= 0, __FILE__, __LINE__, "testlsfitunit.ap:3141");
      if (*errorflag) {
         ae_frame_leave();
         return;
      }
   // Test feasibility w.r.t. box and linear inequality constraints
      for (i = 0; i < nc; i++) {
         set_error_flag(errorflag, c1.xR[i] < bl.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:3150");
         set_error_flag(errorflag, c1.xR[i] > bu.xR[i], __FILE__, __LINE__, "testlsfitunit.ap:3151");
      }
      for (i = 0; i < rawccnt; i++) {
         v = ae_v_dotproduct(rawc.xyR[i], 1, c1.xR, 1, nc);
         v -= rawc.xyR[i][nc];
         if (rawct.xZ[i] > 0) {
            set_error_flag(errorflag, v < -xtol, __FILE__, __LINE__, "testlsfitunit.ap:3158");
         }
         if (rawct.xZ[i] < 0) {
            set_error_flag(errorflag, v > xtol, __FILE__, __LINE__, "testlsfitunit.ap:3160");
         }
      }
   // Make several random trial steps and:
   // 0) generate small random trial step
   // 1) if step is infeasible, skip to next trial
   // 2) compare function value in the trial point against one in other points
      f0 = 0.0;
      for (ii = 0; ii < m; ii++) {
         ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
         testlsfitunit_testfunc1(nx, &x, &c1, &v, true, &state.g, false);
         f0 += sqr(v - y.xR[ii]);
      }
      ae_vector_set_length(&c2, nc);
      for (trialidx = 0; trialidx <= 10 * nc; trialidx++) {
         h = 0.001;
         for (i = 0; i < nc; i++) {
            do {
               c2.xR[i] = c1.xR[i] + (hqrnduniformr(&rs) * 2 - 1) * h;
            } while (!(c2.xR[i] >= bl.xR[i] && c2.xR[i] <= bu.xR[i]));
         }
         bflag = false;
         for (i = 0; i < rawccnt; i++) {
            ae_assert(rawct.xZ[i] != 0, "Assertion failed");
            v = ae_v_dotproduct(rawc.xyR[i], 1, c2.xR, 1, nc);
            v -= rawc.xyR[i][nc];
            bflag = bflag || (rawct.xZ[i] > 0 && v < 0.0);
            bflag = bflag || (rawct.xZ[i] < 0 && v > 0.0);
         }
         if (bflag) {
            continue;
         }
         f1 = 0.0;
         for (ii = 0; ii < m; ii++) {
            ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
            testlsfitunit_testfunc1(nx, &x, &c2, &v, true, &state.g, false);
            f1 += sqr(v - y.xR[ii]);
         }
         set_error_flag(errorflag, f1 < f0, __FILE__, __LINE__, "testlsfitunit.ap:3209");
      }
   }
// Minimize
//
//          [      [                             ]2  ]
//     SUM_i[ SUM_j[ (0.1*x_j+power(x_j,3))*c_ij ]   ]
//          [      [                             ]   ]
//
// subject to linear EQUALITY constraints on x_j.
//
// We check correctness of solution by sampling a few random points
// around one returned by optimizer, and comparing function value
// with target. Sampling is performed with respect to equality
// constraints. In order to simplify algorithm we use orthogonal
// equality constraints.
//
// NOTE: we solve problem using VJ mode (analytic Jacobian) because
//       roundoff errors from numerical differentiation sometimes
//       prevent us from converging with good precision.
   epsx = 1.0E-12;
   xtol = 1.0E-8;
   optkind = 1;
   for (nc = 10; nc <= 20; nc++) {
   // Generate problem
      nx = nc;
      m = nc + hqrnduniformi(&rs, nc);
      ae_vector_set_length(&c0, nc);
      for (i = 0; i < nc; i++) {
         c0.xR[i] = hqrndnormal(&rs);
      }
      ae_matrix_set_length(&xx, m, nx);
      ae_vector_set_length(&y, m);
      for (i = 0; i < m; i++) {
         for (j = 0; j < nx; j++) {
            xx.xyR[i][j] = hqrndnormal(&rs);
         }
         y.xR[i] = hqrndnormal(&rs);
      }
      ae_assert(nc >= 10, "Assertion failed");
      rawccnt = 1 + hqrnduniformi(&rs, 5);
      rmatrixrndorthogonal(nc, &z);
      ae_matrix_set_length(&rawc, rawccnt, nc + 1);
      ae_vector_set_length(&rawct, rawccnt);
      for (i = 0; i < rawccnt; i++) {
         v = 0.0;
         for (j = 0; j < nc; j++) {
            rawc.xyR[i][j] = z.xyR[i][j];
            v += c0.xR[j] * rawc.xyR[i][j];
         }
         rawc.xyR[i][nc] = v;
         rawct.xZ[i] = 0;
      }
   // Solve
      if (optkind == 0) {
         lsfitcreatef(&xx, &y, &c0, m, nx, nc, 1.0E-6, &state);
      }
      if (optkind == 1) {
         lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
      }
      lsfitsetcond(&state, epsx, 0);
      lsfitsetlc(&state, &rawc, &rawct, rawccnt);
      while (lsfititeration(&state)) {
         if (state.needf) {
            testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, false);
            continue;
         }
         if (state.needfg) {
            testlsfitunit_testfunc1(nx, &state.x, &state.c, &state.f, true, &state.g, true);
            continue;
         }
         ae_assert(false, "lsfit test: integrity check failed");
      }
      lsfitresults(&state, &terminationtype, &c1, &rep);
      set_error_flag(errorflag, terminationtype <= 0, __FILE__, __LINE__, "testlsfitunit.ap:3295");
      if (*errorflag) {
         ae_frame_leave();
         return;
      }
   // Test feasibility w.r.t. linear equality constraints
      for (i = 0; i < rawccnt; i++) {
         v = ae_v_dotproduct(rawc.xyR[i], 1, c1.xR, 1, nc);
         v -= rawc.xyR[i][nc];
         set_error_flag(errorflag, fabs(v) > xtol, __FILE__, __LINE__, "testlsfitunit.ap:3306");
      }
   // Make several random trial steps and:
   // 0) generate small random trial step
   // 1) project it onto equality constrained subspace
   // 2) compare function value in the trial point against one in other points
      f0 = 0.0;
      for (ii = 0; ii < m; ii++) {
         ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
         testlsfitunit_testfunc1(nx, &x, &c1, &v, true, &state.g, false);
         f0 += sqr(v - y.xR[ii]);
      }
      ae_vector_set_length(&c2, nc);
      for (trialidx = 0; trialidx <= nc; trialidx++) {
         h = 0.001;
         for (i = 0; i < nc; i++) {
            c2.xR[i] = hqrndnormal(&rs);
         }
         for (i = 0; i < rawccnt; i++) {
            v = ae_v_dotproduct(rawc.xyR[i], 1, c2.xR, 1, nc);
            ae_v_subd(c2.xR, 1, rawc.xyR[i], 1, nc, v);
         }
         v = ae_v_dotproduct(c2.xR, 1, c2.xR, 1, nc);
         ae_assert(v > 0.0, "Assertion failed");
         v = h / sqrt(v);
         ae_v_muld(c2.xR, 1, nc, v);
         ae_v_add(c2.xR, 1, c1.xR, 1, nc);
         f1 = 0.0;
         for (ii = 0; ii < m; ii++) {
            ae_v_move(x.xR, 1, xx.xyR[ii], 1, nx);
            testlsfitunit_testfunc1(nx, &x, &c2, &v, true, &state.g, false);
            f1 += sqr(v - y.xR[ii]);
         }
         set_error_flag(errorflag, f1 < f0, __FILE__, __LINE__, "testlsfitunit.ap:3348");
      }
   }
// Fit
//
//
//    f(X|C)= c_0
//
//
// subject to single general linear equality constraint on c_0.
//
// Here X has dimensionality NX, and C has dimensionality 1.
//
// We do not test convergence to solution, only feasibility of constraint.
// The aim of this test is to assert that optimizer correctly handles
// situations when dimensions of X and C differ.
   epsx = 1.0E-9;
   for (optkind = 0; optkind <= 1; optkind++) {
      for (nx = 1; nx <= 20; nx++) {
         nc = 1;
         m = nx + hqrnduniformi(&rs, nx);
         ae_vector_set_length(&c0, nc);
         for (i = 0; i < nc; i++) {
            c0.xR[i] = hqrndnormal(&rs);
         }
         ae_matrix_set_length(&xx, m, nx);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < nx; j++) {
               xx.xyR[i][j] = hqrndnormal(&rs);
            }
            y.xR[i] = hqrndnormal(&rs);
         }
         ae_assert(nc == 1, "Assertion failed");
         rawccnt = 1;
         ae_matrix_set_length(&rawc, 1, 2);
         ae_vector_set_length(&rawct, 1);
         rawc.xyR[0][0] = 1.0;
         rawc.xyR[0][1] = hqrndnormal(&rs);
         rawct.xZ[0] = 0;
         if (optkind == 0) {
            lsfitcreatef(&xx, &y, &c0, m, nx, nc, 10 * epsx, &state);
         }
         if (optkind == 1) {
            lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
         }
         lsfitsetcond(&state, epsx, 0);
         lsfitsetlc(&state, &rawc, &rawct, rawccnt);
         while (lsfititeration(&state)) {
            if (state.needf) {
               testlsfitunit_testfunc2(&state.x, nx, &state.c, nc, &state.f, true, &state.g, false);
               continue;
            }
            if (state.needfg) {
               testlsfitunit_testfunc2(&state.x, nx, &state.c, nc, &state.f, true, &state.g, true);
               continue;
            }
            ae_assert(false, "minlm test: integrity check failed");
         }
         lsfitresults(&state, &terminationtype, &c1, &rep);
         set_error_flag(errorflag, terminationtype <= 0, __FILE__, __LINE__, "testlsfitunit.ap:3413");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         set_error_flag(errorflag, fabs(c1.xR[0] - rawc.xyR[0][1]) > 1.0E-6, __FILE__, __LINE__, "testlsfitunit.ap:3418");
      }
   }
// Fit
//
//
//    f(X|C)= c_0 + c_1*x0 + c_2*x0^2 + ...
//
//
// subject to single general linear equality constraint on c.
//
// Here X has dimensionality 1, and C has dimensionality NC.
//
// We do not test convergence to solution, only feasibility of constraint.
// The aim of this test is to assert that optimizer correctly handles
// situations when dimensions of X and C differ.
   epsx = 1.0E-9;
   for (optkind = 0; optkind <= 1; optkind++) {
      for (nc = 1; nc <= 5; nc++) {
         nx = 1;
         m = 10 + nc + hqrnduniformi(&rs, nc);
         ae_vector_set_length(&c0, nc);
         for (i = 0; i < nc; i++) {
            c0.xR[i] = hqrndnormal(&rs);
         }
         ae_matrix_set_length(&xx, m, nx);
         ae_vector_set_length(&y, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < nx; j++) {
               xx.xyR[i][j] = hqrndnormal(&rs);
            }
            y.xR[i] = hqrndnormal(&rs);
         }
         rawccnt = 1;
         ae_matrix_set_length(&rawc, 1, nc + 1);
         ae_vector_set_length(&rawct, 1);
         for (j = 0; j <= nc; j++) {
            rawc.xyR[0][j] = (2 * hqrnduniformi(&rs, 2) - 1) * (0.1 + hqrnduniformr(&rs));
         }
         rawct.xZ[0] = 0;
         if (optkind == 0) {
            lsfitcreatef(&xx, &y, &c0, m, nx, nc, 10 * epsx, &state);
         }
         if (optkind == 1) {
            lsfitcreatefg(&xx, &y, &c0, m, nx, nc, hqrndnormal(&rs) > 0.0, &state);
         }
         lsfitsetcond(&state, epsx, 0);
         lsfitsetlc(&state, &rawc, &rawct, rawccnt);
         while (lsfititeration(&state)) {
            if (state.needf) {
               testlsfitunit_testfunc3(&state.x, nx, &state.c, nc, &state.f, true, &state.g, false);
               continue;
            }
            if (state.needfg) {
               testlsfitunit_testfunc3(&state.x, nx, &state.c, nc, &state.f, true, &state.g, true);
               continue;
            }
            ae_assert(false, "minlm test: integrity check failed");
         }
         lsfitresults(&state, &terminationtype, &c1, &rep);
         set_error_flag(errorflag, terminationtype <= 0, __FILE__, __LINE__, "testlsfitunit.ap:3481");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         v = -rawc.xyR[0][nc];
         for (j = 0; j < nc; j++) {
            v += rawc.xyR[0][j] * c1.xR[j];
         }
         set_error_flag(errorflag, fabs(v) > 1.0E-6, __FILE__, __LINE__, "testlsfitunit.ap:3489");
      }
   }
   ae_frame_leave();
}

// Tests whether C is solution of LLS problem
static double testlsfitunit_getglserror(ae_int_t n, ae_int_t m, RVector *y, RVector *w, RMatrix *fmatrix, RVector *c) {
   ae_int_t i;
   double v;
   double result;
   result = 0.0;
   for (i = 0; i < n; i++) {
      v = ae_v_dotproduct(fmatrix->xyR[i], 1, c->xR, 1, m);
      result += sqr(w->xR[i] * (v - y->xR[i]));
   }
   return result;
}

// Tests whether C is solution of (possibly) constrained LLS problem
static bool testlsfitunit_isglssolution(ae_int_t n, ae_int_t m, ae_int_t k, RVector *y, RVector *w, RMatrix *fmatrix, RMatrix *cmatrix, RVector *c) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   double s1;
   double s2;
   double s3;
   double delta;
   double threshold;
   double shift;
   bool result;
   ae_frame_make(&_frame_block);
   DupVector(c);
   NewVector(c2, 0, DT_REAL);
   NewVector(sv, 0, DT_REAL);
   NewVector(deltac, 0, DT_REAL);
   NewVector(deltaproj, 0, DT_REAL);
   NewMatrix(u, 0, 0, DT_REAL);
   NewMatrix(vt, 0, 0, DT_REAL);
// Setup.
// Threshold is small because CMatrix may be ill-conditioned
   delta = 0.001;
   threshold = sqrt(machineepsilon);
   shift = 10000 * machineepsilon;
   ae_vector_set_length(&c2, m);
   ae_vector_set_length(&deltac, m);
   ae_vector_set_length(&deltaproj, m);
// test whether C is feasible point or not (projC must be close to C)
   for (i = 0; i < k; i++) {
      v = ae_v_dotproduct(cmatrix->xyR[i], 1, c->xR, 1, m);
      if (fabs(v - cmatrix->xyR[i][m]) > threshold) {
         result = false;
         ae_frame_leave();
         return result;
      }
   }
// find orthogonal basis of Null(CMatrix) (stored in rows from K to M-1)
   if (k > 0) {
      rmatrixsvd(cmatrix, k, m, 0, 2, 2, &sv, &u, &vt);
   }
// Test result
   result = true;
   s1 = testlsfitunit_getglserror(n, m, y, w, fmatrix, c);
   for (j = 0; j < m; j++) {
   // prepare modification of C which leave us in the feasible set.
   //
   // let deltaC be increment on Jth coordinate, then project
   // deltaC in the Null(CMatrix) and store result in DeltaProj
      ae_v_move(c2.xR, 1, c->xR, 1, m);
      for (i = 0; i < m; i++) {
         if (i == j) {
            deltac.xR[i] = delta;
         } else {
            deltac.xR[i] = 0.0;
         }
      }
      if (k == 0) {
         ae_v_move(deltaproj.xR, 1, deltac.xR, 1, m);
      } else {
         for (i = 0; i < m; i++) {
            deltaproj.xR[i] = 0.0;
         }
         for (i = k; i < m; i++) {
            v = ae_v_dotproduct(vt.xyR[i], 1, deltac.xR, 1, m);
            ae_v_addd(deltaproj.xR, 1, vt.xyR[i], 1, m, v);
         }
      }
   // now we have DeltaProj such that if C is feasible,
   // then C+DeltaProj is feasible too
      ae_v_move(c2.xR, 1, c->xR, 1, m);
      ae_v_add(c2.xR, 1, deltaproj.xR, 1, m);
      s2 = testlsfitunit_getglserror(n, m, y, w, fmatrix, &c2);
      ae_v_move(c2.xR, 1, c->xR, 1, m);
      ae_v_sub(c2.xR, 1, deltaproj.xR, 1, m);
      s3 = testlsfitunit_getglserror(n, m, y, w, fmatrix, &c2);
      result = (result && s2 >= s1 / (1 + threshold) - shift) && s3 >= s1 / (1 + threshold) - shift;
   }
   ae_frame_leave();
   return result;
}

// Subroutine for nonlinear fitting of linear problem
//
// DerAvailable:
// * 0     when only function value should be used
// * 1     when we can provide gradient/function
// * 2     when we can provide Hessian/gradient/function
//
// When something which is not permitted by DerAvailable is requested,
// this function sets NLSErrors to True.
static void testlsfitunit_fitlinearnonlinear(ae_int_t m, ae_int_t deravailable, RMatrix *xy, lsfitstate *state, bool *nlserrors) {
   ae_int_t i;
   ae_int_t j;
   double v;
   while (lsfititeration(state)) {
   // assume that one and only one of flags is set
   // test that we didn't request hessian in hessian-free setting
      if (deravailable < 1 && state->needfg) {
         *nlserrors = true;
      }
      if (deravailable < 2 && state->needfgh) {
         *nlserrors = true;
      }
      i = 0;
      if (state->needf) {
         i++;
      }
      if (state->needfg) {
         i++;
      }
      if (state->needfgh) {
         i++;
      }
      if (i != 1) {
         *nlserrors = true;
      }
   // test that PointIndex is consistent with actual point passed
      for (i = 0; i < m; i++) {
         *nlserrors = *nlserrors || xy->xyR[state->pointindex][i] != state->x.xR[i];
      }
   // calculate
      if (state->needf) {
         v = ae_v_dotproduct(state->x.xR, 1, state->c.xR, 1, m);
         state->f = v;
         continue;
      }
      if (state->needfg) {
         v = ae_v_dotproduct(state->x.xR, 1, state->c.xR, 1, m);
         state->f = v;
         ae_v_move(state->g.xR, 1, state->x.xR, 1, m);
         continue;
      }
      if (state->needfgh) {
         v = ae_v_dotproduct(state->x.xR, 1, state->c.xR, 1, m);
         state->f = v;
         ae_v_move(state->g.xR, 1, state->x.xR, 1, m);
         for (i = 0; i < m; i++) {
            for (j = 0; j < m; j++) {
               state->h.xyR[i][j] = 0.0;
            }
         }
         continue;
      }
   }
}

static void testlsfitunit_testgeneralfitting(bool *llserrors, bool *nlserrors) {
   ae_frame _frame_block;
   double threshold;
   double nlthreshold;
   ae_int_t maxn;
   ae_int_t maxm;
   ae_int_t skind;
   ae_int_t pkind;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t m;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t pass;
   double xscale;
   double cscale;
   double wscale;
   double noiselevel;
   double tol;
   double diffstep;
   double v;
   double v1;
   double v2;
   ae_int_t info;
   ae_int_t info2;
   double refrms;
   double refavg;
   double refavgrel;
   double refmax;
   double avgdeviationpar;
   double avgdeviationcurve;
   double avgdeviationnoise;
   double adccnt;
   double adpcnt;
   double adncnt;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(w, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(c, 0, DT_REAL);
   NewVector(cstart, 0, DT_REAL);
   NewVector(cend, 0, DT_REAL);
   NewVector(c2, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewMatrix(cm, 0, 0, DT_REAL);
   NewObj(lsfitreport, rep);
   NewObj(lsfitreport, rep2);
   NewObj(lsfitstate, state);
   *llserrors = false;
   *nlserrors = false;
   threshold = 10000 * machineepsilon;
   nlthreshold = 0.00001;
   diffstep = 0.0001;
   maxn = 6;
   maxm = 6;
   passcount = 4;
// Test constrained NLS problems
   testlsfitunit_testbcnls(nlserrors);
   testlsfitunit_testlcnls(nlserrors);
// Testing unconstrained least squares (linear/nonlinear)
   for (n = 1; n <= maxn; n++) {
      for (m = 1; m <= maxm; m++) {
         for (pass = 1; pass <= passcount; pass++) {
         // Solve non-degenerate linear least squares task
         // Use Chebyshev basis. Its condition number is very good.
            ae_matrix_set_length(&a, n, m);
            ae_vector_set_length(&x, n);
            ae_vector_set_length(&y, n);
            ae_vector_set_length(&w, n);
            xscale = 0.9 + 0.1 * randomreal();
            for (i = 0; i < n; i++) {
               if (n == 1) {
                  x.xR[i] = randommid();
               } else {
                  x.xR[i] = xscale * ((double)(2 * i) / (n - 1) - 1);
               }
               y.xR[i] = 3 * x.xR[i] + exp(x.xR[i]);
               w.xR[i] = 1 + randomreal();
               a.xyR[i][0] = 1.0;
               if (m > 1) {
                  a.xyR[i][1] = x.xR[i];
               }
               for (j = 2; j < m; j++) {
                  a.xyR[i][j] = 2 * x.xR[i] * a.xyR[i][j - 1] - a.xyR[i][j - 2];
               }
            }
         // 1. test weighted fitting (optimality)
         // 2. Solve degenerate least squares task built on the basis
         //    of previous task
            lsfitlinearw(&y, &w, &a, n, m, &info, &c, &rep);
            if (info <= 0) {
               set_error_flag(llserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1106");
            } else {
               set_error_flag(llserrors, !testlsfitunit_isglssolution(n, m, 0, &y, &w, &a, &cm, &c), __FILE__, __LINE__, "testlsfitunit.ap:1108");
            }
            ae_matrix_set_length(&a2, n, 2 * m);
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  a2.xyR[i][2 * j + 0] = a.xyR[i][j];
                  a2.xyR[i][2 * j + 1] = a.xyR[i][j];
               }
            }
            lsfitlinearw(&y, &w, &a2, n, 2 * m, &info, &c2, &rep);
            if (info <= 0) {
               set_error_flag(llserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1118");
            } else {
            // test answer correctness using design matrix properties
            // and previous task solution
               for (j = 0; j < m; j++) {
                  set_error_flag(llserrors, fabs(c2.xR[2 * j + 0] + c2.xR[2 * j + 1] - c.xR[j]) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1126");
               }
            }
         // test non-weighted fitting
            ae_vector_set_length(&w2, n);
            for (i = 0; i < n; i++) {
               w2.xR[i] = 1.0;
            }
            lsfitlinearw(&y, &w2, &a, n, m, &info, &c, &rep);
            lsfitlinear(&y, &a, n, m, &info2, &c2, &rep2);
            if (info <= 0 || info2 <= 0) {
               set_error_flag(llserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1138");
            } else {
            // test answer correctness
               for (j = 0; j < m; j++) {
                  set_error_flag(llserrors, fabs(c.xR[j] - c2.xR[j]) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1145");
               }
               set_error_flag(llserrors, fabs(rep.taskrcond - rep2.taskrcond) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1146");
            }
         // test nonlinear fitting on the linear task
         // (only non-degenerate tasks are tested)
         // and compare with answer from linear fitting subroutine
            if (n >= m) {
               ae_vector_set_length(&c2, m);
            // test function/gradient/Hessian-based weighted fitting
               lsfitlinearw(&y, &w, &a, n, m, &info, &c, &rep);
               for (i = 0; i < m; i++) {
                  c2.xR[i] = randommid();
               }
               lsfitcreatewf(&a, &y, &w, &c2, n, m, m, diffstep, &state);
               lsfitsetcond(&state, nlthreshold, 0);
               testlsfitunit_fitlinearnonlinear(m, 0, &a, &state, nlserrors);
               lsfitresults(&state, &info, &c2, &rep2);
               if (info <= 0) {
                  set_error_flag(nlserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1170");
               } else {
                  for (i = 0; i < m; i++) {
                     set_error_flag(nlserrors, fabs(c.xR[i] - c2.xR[i]) > 100 * nlthreshold, __FILE__, __LINE__, "testlsfitunit.ap:1174");
                  }
               }
               for (i = 0; i < m; i++) {
                  c2.xR[i] = randommid();
               }
               lsfitcreatewfg(&a, &y, &w, &c2, n, m, m, randombool(), &state);
               lsfitsetcond(&state, nlthreshold, 0);
               testlsfitunit_fitlinearnonlinear(m, 1, &a, &state, nlserrors);
               lsfitresults(&state, &info, &c2, &rep2);
               if (info <= 0) {
                  set_error_flag(nlserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1184");
               } else {
                  for (i = 0; i < m; i++) {
                     set_error_flag(nlserrors, fabs(c.xR[i] - c2.xR[i]) > 100 * nlthreshold, __FILE__, __LINE__, "testlsfitunit.ap:1188");
                  }
               }
               for (i = 0; i < m; i++) {
                  c2.xR[i] = randommid();
               }
               lsfitcreatewfgh(&a, &y, &w, &c2, n, m, m, &state);
               lsfitsetcond(&state, nlthreshold, 0);
               testlsfitunit_fitlinearnonlinear(m, 2, &a, &state, nlserrors);
               lsfitresults(&state, &info, &c2, &rep2);
               if (info <= 0) {
                  set_error_flag(nlserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1198");
               } else {
                  for (i = 0; i < m; i++) {
                     set_error_flag(nlserrors, fabs(c.xR[i] - c2.xR[i]) > 100 * nlthreshold, __FILE__, __LINE__, "testlsfitunit.ap:1202");
                  }
               }
            // test gradient-only or Hessian-based fitting without weights
               lsfitlinear(&y, &a, n, m, &info, &c, &rep);
               for (i = 0; i < m; i++) {
                  c2.xR[i] = randommid();
               }
               lsfitcreatef(&a, &y, &c2, n, m, m, diffstep, &state);
               lsfitsetcond(&state, nlthreshold, 0);
               testlsfitunit_fitlinearnonlinear(m, 0, &a, &state, nlserrors);
               lsfitresults(&state, &info, &c2, &rep2);
               if (info <= 0) {
                  set_error_flag(nlserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1217");
               } else {
                  for (i = 0; i < m; i++) {
                     set_error_flag(nlserrors, fabs(c.xR[i] - c2.xR[i]) > 100 * nlthreshold, __FILE__, __LINE__, "testlsfitunit.ap:1221");
                  }
               }
               for (i = 0; i < m; i++) {
                  c2.xR[i] = randommid();
               }
               lsfitcreatefg(&a, &y, &c2, n, m, m, randombool(), &state);
               lsfitsetcond(&state, nlthreshold, 0);
               testlsfitunit_fitlinearnonlinear(m, 1, &a, &state, nlserrors);
               lsfitresults(&state, &info, &c2, &rep2);
               if (info <= 0) {
                  set_error_flag(nlserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1231");
               } else {
                  for (i = 0; i < m; i++) {
                     set_error_flag(nlserrors, fabs(c.xR[i] - c2.xR[i]) > 100 * nlthreshold, __FILE__, __LINE__, "testlsfitunit.ap:1235");
                  }
               }
               for (i = 0; i < m; i++) {
                  c2.xR[i] = randommid();
               }
               lsfitcreatefgh(&a, &y, &c2, n, m, m, &state);
               lsfitsetcond(&state, nlthreshold, 0);
               testlsfitunit_fitlinearnonlinear(m, 2, &a, &state, nlserrors);
               lsfitresults(&state, &info, &c2, &rep2);
               if (info <= 0) {
                  set_error_flag(nlserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1245");
               } else {
                  for (i = 0; i < m; i++) {
                     set_error_flag(nlserrors, fabs(c.xR[i] - c2.xR[i]) > 100 * nlthreshold, __FILE__, __LINE__, "testlsfitunit.ap:1249");
                  }
               }
            }
         }
      }
   // test correctness of the RCond field
      ae_matrix_set_length(&a, n - 1 + 1, n - 1 + 1);
      ae_vector_set_length(&x, n - 1 + 1);
      ae_vector_set_length(&y, n - 1 + 1);
      ae_vector_set_length(&w, n - 1 + 1);
      v1 = maxrealnumber;
      v2 = minrealnumber;
      for (i = 0; i < n; i++) {
         x.xR[i] = 0.1 + 0.9 * randomreal();
         y.xR[i] = 0.1 + 0.9 * randomreal();
         w.xR[i] = 1.0;
         for (j = 0; j < n; j++) {
            if (i == j) {
               a.xyR[i][i] = 0.1 + 0.9 * randomreal();
               v1 = rmin2(v1, a.xyR[i][i]);
               v2 = rmax2(v2, a.xyR[i][i]);
            } else {
               a.xyR[i][j] = 0.0;
            }
         }
      }
      lsfitlinearw(&y, &w, &a, n, n, &info, &c, &rep);
      if (info <= 0) {
         set_error_flag(llserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1281");
      } else {
         set_error_flag(llserrors, fabs(rep.taskrcond - v1 / v2) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1283");
      }
   }
// Test constrained least squares
   for (pass = 1; pass <= passcount; pass++) {
      for (n = 1; n <= maxn; n++) {
         for (m = 1; m <= maxm; m++) {
         // test for K != 0
            for (k = 1; k < m; k++) {
            // Prepare Chebyshev basis. Its condition number is very good.
            // Prepare constraints (random numbers)
               ae_matrix_set_length(&a, n, m);
               ae_vector_set_length(&x, n);
               ae_vector_set_length(&y, n);
               ae_vector_set_length(&w, n);
               xscale = 0.9 + 0.1 * randomreal();
               for (i = 0; i < n; i++) {
                  if (n == 1) {
                     x.xR[i] = randommid();
                  } else {
                     x.xR[i] = xscale * ((double)(2 * i) / (n - 1) - 1);
                  }
                  y.xR[i] = 3 * x.xR[i] + exp(x.xR[i]);
                  w.xR[i] = 1 + randomreal();
                  a.xyR[i][0] = 1.0;
                  if (m > 1) {
                     a.xyR[i][1] = x.xR[i];
                  }
                  for (j = 2; j < m; j++) {
                     a.xyR[i][j] = 2 * x.xR[i] * a.xyR[i][j - 1] - a.xyR[i][j - 2];
                  }
               }
               ae_matrix_set_length(&cm, k, m + 1);
               for (i = 0; i < k; i++) {
                  for (j = 0; j <= m; j++) {
                     cm.xyR[i][j] = randommid();
                  }
               }
            // Solve constrained task
               lsfitlinearwc(&y, &w, &a, &cm, n, m, k, &info, &c, &rep);
               if (info <= 0) {
                  set_error_flag(llserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1331");
               } else {
                  set_error_flag(llserrors, !testlsfitunit_isglssolution(n, m, k, &y, &w, &a, &cm, &c), __FILE__, __LINE__, "testlsfitunit.ap:1333");
               }
            // test non-weighted fitting
               ae_vector_set_length(&w2, n);
               for (i = 0; i < n; i++) {
                  w2.xR[i] = 1.0;
               }
               lsfitlinearwc(&y, &w2, &a, &cm, n, m, k, &info, &c, &rep);
               lsfitlinearc(&y, &a, &cm, n, m, k, &info2, &c2, &rep2);
               if (info <= 0 || info2 <= 0) {
                  set_error_flag(llserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1345");
               } else {
               // test answer correctness
                  for (j = 0; j < m; j++) {
                     set_error_flag(llserrors, fabs(c.xR[j] - c2.xR[j]) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1352");
                  }
                  set_error_flag(llserrors, fabs(rep.taskrcond - rep2.taskrcond) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1353");
               }
            }
         }
      }
   }
// nonlinear task for nonlinear fitting:
//
//     f(X,C) = 1/(1+C*X^2),
//     C(true) = 2.
   n = 100;
   ae_vector_set_length(&c, 1);
   c.xR[0] = 1 + 2 * randomreal();
   ae_matrix_set_length(&a, n, 1);
   ae_vector_set_length(&y, n);
   for (i = 0; i < n; i++) {
      a.xyR[i][0] = 2.0 * randommid();
      y.xR[i] = 1 / (1 + 2 * sqr(a.xyR[i][0]));
   }
   lsfitcreatefg(&a, &y, &c, n, 1, 1, true, &state);
   lsfitsetcond(&state, nlthreshold, 0);
   while (lsfititeration(&state)) {
      if (state.needf) {
         state.f = 1 / (1 + state.c.xR[0] * sqr(state.x.xR[0]));
      }
      if (state.needfg) {
         state.f = 1 / (1 + state.c.xR[0] * sqr(state.x.xR[0]));
         state.g.xR[0] = -sqr(state.x.xR[0]) / sqr(1 + state.c.xR[0] * sqr(state.x.xR[0]));
      }
   }
   lsfitresults(&state, &info, &c, &rep);
   if (info <= 0) {
      set_error_flag(nlserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1389");
   } else {
      set_error_flag(nlserrors, fabs(c.xR[0] - 2) > 100 * nlthreshold, __FILE__, __LINE__, "testlsfitunit.ap:1391");
   }
// solve simple task (fitting by constant function) and check
// correctness of the errors calculated by subroutines
   for (pass = 1; pass <= passcount; pass++) {
   // test on task with non-zero Yi
      n = 4;
      v1 = randomreal();
      v2 = randomreal();
      v = 1 + randomreal();
      ae_vector_set_length(&c, 1);
      c.xR[0] = 1 + 2 * randomreal();
      ae_matrix_set_length(&a, 4, 1);
      ae_vector_set_length(&y, 4);
      a.xyR[0][0] = 1.0;
      y.xR[0] = v - v2;
      a.xyR[1][0] = 1.0;
      y.xR[1] = v - v1;
      a.xyR[2][0] = 1.0;
      y.xR[2] = v + v1;
      a.xyR[3][0] = 1.0;
      y.xR[3] = v + v2;
      refrms = sqrt((sqr(v1) + sqr(v2)) / 2);
      refavg = (fabs(v1) + fabs(v2)) / 2;
      refavgrel = 0.25 * (fabs(v2) / fabs(v - v2) + fabs(v1) / fabs(v - v1) + fabs(v1) / fabs(v + v1) + fabs(v2) / fabs(v + v2));
      refmax = rmax2(v1, v2);
   // Test LLS
      lsfitlinear(&y, &a, 4, 1, &info, &c, &rep);
      if (info <= 0) {
         set_error_flag(llserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1429");
      } else {
         set_error_flag(llserrors, fabs(c.xR[0] - v) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1432");
         set_error_flag(llserrors, fabs(rep.rmserror - refrms) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1433");
         set_error_flag(llserrors, fabs(rep.avgerror - refavg) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1434");
         set_error_flag(llserrors, fabs(rep.avgrelerror - refavgrel) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1435");
         set_error_flag(llserrors, fabs(rep.maxerror - refmax) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1436");
      }
   // Test NLS
      lsfitcreatefg(&a, &y, &c, 4, 1, 1, true, &state);
      lsfitsetcond(&state, nlthreshold, 0);
      while (lsfititeration(&state)) {
         if (state.needf) {
            state.f = state.c.xR[0];
         }
         if (state.needfg) {
            state.f = state.c.xR[0];
            state.g.xR[0] = 1.0;
         }
      }
      lsfitresults(&state, &info, &c, &rep);
      if (info <= 0) {
         set_error_flag(nlserrors, true, __FILE__, __LINE__, "testlsfitunit.ap:1456");
      } else {
         set_error_flag(nlserrors, fabs(c.xR[0] - v) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1459");
         set_error_flag(nlserrors, fabs(rep.rmserror - refrms) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1460");
         set_error_flag(nlserrors, fabs(rep.avgerror - refavg) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1461");
         set_error_flag(nlserrors, fabs(rep.avgrelerror - refavgrel) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1462");
         set_error_flag(nlserrors, fabs(rep.maxerror - refmax) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1463");
      }
   }
// Check covariance matrix, errors-in-parameters.
//
// We test three different solvers:
// * nonlinear solver
// * unconstrained linear solver
// * constrained linear solver with empty set of constrains
// on two random problems:
// * problem with known prior, noise, unit weights
// * problem with known prior, noise, non-unit weights
//
// We test that:
// * rep.ErrPar=sqrt(diag(Rep.CovPar))
// * Rep.ErrPar is not too optimistic  - average value of ratio
//   between  |c_fit-c_prior| and ErrPar[] is less than TOL
// * Rep.ErrPar is not too pessimistic - average value of ratio
//   is larger than 1/TOL
// * similarly, Rep.ErrCurve gives good estimate of |A*c_fit - A*c_prior|
//   - not optimistic, not pessimistic.
// * similarly, per-point noise estimates are good enough (we use
//   slightly different tolerances, though)
// In order to have these estimates we perform many different tests
// and calculate average deviation divided by ErrPar/ErrCurve. Then
// we perform test.
//
// Due to stochastic nature of the test it is not good idea to
// consider each case individually - it is better to average over
// many runs.
//
   tol = 10.0;
   for (n = 1; n <= 10; n++) {
      for (skind = 0; skind <= 2; skind++) {
         for (pkind = 0; pkind <= 1; pkind++) {
         // Generate problem:
         // * PKind=0 - unit weights
         // * PKind=1 - non-unit weights, exact estimate of noise at I-th point
         //
         // We generate:
         // * C      -   prior values of parameters
         // * CStart -   random initial point
         // * A      -   function matrix
         // * Y      -   noisy version of A*C
         // * W      -   weights vector
         // * S      -   vector of per-point estimates of noise
            cscale = pow(10.0, 2 * randomnormal());
            xscale = pow(10.0, 2 * randomnormal());
            noiselevel = 0.01 * cscale * xscale;
            ae_vector_set_length(&c, n);
            ae_vector_set_length(&cstart, n);
            for (i = 0; i < n; i++) {
               c.xR[i] = cscale * randomnormal();
               cstart.xR[i] = cscale * randomnormal();
            }
            ae_matrix_set_length(&a, 1000, n);
            ae_vector_set_length(&y, a.rows);
            ae_vector_set_length(&w, a.rows);
            ae_vector_set_length(&s, a.rows);
            for (i = 0; i < a.rows; i++) {
               for (j = 0; j < n; j++) {
                  a.xyR[i][j] = xscale * randomnormal();
               }
               v = ae_v_dotproduct(a.xyR[i], 1, c.xR, 1, n);
               if (pkind == 0) {
                  w.xR[i] = 1.0;
                  s.xR[i] = noiselevel;
                  y.xR[i] = v + s.xR[i] * randomnormal();
               }
               if (pkind == 1) {
                  w.xR[i] = 1 / noiselevel;
                  s.xR[i] = noiselevel;
                  y.xR[i] = v + s.xR[i] * randomnormal();
               }
            }
         // Test different solvers:
         // * SKind=0 - nonlinear solver
         // * SKind=1 - linear unconstrained
         // * SKind=2 - linear constrained with empty set of constraints
            info = -1;
            if (skind == 0) {
               if (randombool()) {
                  lsfitcreatefg(&a, &y, &cstart, a.rows, n, n, true, &state);
               } else {
                  lsfitcreatef(&a, &y, &cstart, a.rows, n, n, 0.001 * cscale, &state);
               }
               lsfitsetcond(&state, 0.0, 10);
               while (lsfititeration(&state)) {
                  if (state.needf) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += state.c.xR[i] * state.x.xR[i];
                     }
                  }
                  if (state.needfg) {
                     state.f = 0.0;
                     for (i = 0; i < n; i++) {
                        state.f += state.c.xR[i] * state.x.xR[i];
                        state.g.xR[i] = state.x.xR[i];
                     }
                  }
               }
               lsfitresults(&state, &info, &cend, &rep);
            }
            if (skind == 1) {
               if (pkind == 0) {
                  lsfitlinear(&y, &a, a.rows, n, &info, &cend, &rep);
               } else {
                  lsfitlinearw(&y, &w, &a, a.rows, n, &info, &cend, &rep);
               }
            }
            if (skind == 2) {
               if (pkind == 0) {
                  lsfitlinearc(&y, &a, &a2, a.rows, n, 0, &info, &cend, &rep);
               } else {
                  lsfitlinearwc(&y, &w, &a, &a2, a.rows, n, 0, &info, &cend, &rep);
               }
            }
         // Tests:
         // * check relation between CovPar and ErrPar
         // * accumulate average deviation in parameters
         // * accumulate average deviation in curve fit
         // * accumulate average deviation in noise estimate
            avgdeviationpar = 0.0;
            adpcnt = 0.0;
            avgdeviationcurve = 0.0;
            adccnt = 0.0;
            avgdeviationnoise = 0.0;
            adncnt = 0.0;
            for (i = 0; i < n; i++) {
               set_error_flag(llserrors, fabs(rep.covpar.xyR[i][i] - sqr(rep.errpar.xR[i])) > 100 * machineepsilon * rmax2(sqr(rep.errpar.xR[i]), rep.covpar.xyR[i][i]), __FILE__, __LINE__, "testlsfitunit.ap:1612");
            }
            for (i = 0; i < n; i++) {
               avgdeviationpar = (avgdeviationpar * adpcnt + fabs(c.xR[i] - cend.xR[i]) / rep.errpar.xR[i]) / (adpcnt + 1);
               adpcnt++;
            }
            for (i = 0; i < a.rows; i++) {
               v1 = ae_v_dotproduct(c.xR, 1, a.xyR[i], 1, n);
               v2 = ae_v_dotproduct(cend.xR, 1, a.xyR[i], 1, n);
               avgdeviationcurve = (avgdeviationcurve * adccnt + fabs(v1 - v2) / rep.errcurve.xR[i]) / (adccnt + 1);
               adccnt++;
               avgdeviationnoise = (avgdeviationnoise * adncnt + rep.noise.xR[i] / s.xR[i]) / (adncnt + 1);
               adncnt++;
            }
         // Check that estimates are not too optimistic.
         // This test is performed always.
            set_error_flag(llserrors, avgdeviationpar > tol, __FILE__, __LINE__, "testlsfitunit.ap:1632");
            set_error_flag(llserrors, avgdeviationcurve > tol, __FILE__, __LINE__, "testlsfitunit.ap:1633");
            set_error_flag(llserrors, avgdeviationnoise > 1.50, __FILE__, __LINE__, "testlsfitunit.ap:1634");
            set_error_flag(llserrors, avgdeviationnoise < 0.66, __FILE__, __LINE__, "testlsfitunit.ap:1635");
         // Test for estimates being too pessimistic is performed only
         // when we have more than 4 parameters.
            set_error_flag(llserrors, n >= 5 && avgdeviationcurve < 0.01, __FILE__, __LINE__, "testlsfitunit.ap:1641");
            set_error_flag(llserrors, n >= 5 && avgdeviationpar < 0.01, __FILE__, __LINE__, "testlsfitunit.ap:1642");
         }
      }
   }
// Check special property of the LSFit solver: it does not include points with
// zero weight in the estimate of the noise level. Such property seems to be
// quite natural, but in fact it requires some additional code in order to
// ignore such points.
//
// In order to test it we solve two problems: one 300xN, with 150 non-zero
// weights and 150 zero weights - and another one with only 150 points with
// non-zero weights. Both problems should give us same covariance matrix.
   tol = 10.0;
   for (n = 1; n <= 10; n++) {
   // Generate N-dimensional linear problem with 300 points:
   // * y = c'*x + noise
   // * prior values of coefficients C has scale CScale
   // * coordinates X has scale XScale
   // * noise in I-th point has magnitude 0.1*CScale*XScale*WScale/W[i]
      cscale = pow(10.0, 2 * randomnormal());
      xscale = pow(10.0, 2 * randomnormal());
      wscale = pow(10.0, 2 * randomnormal());
      noiselevel = 0.1 * cscale * xscale;
      ae_vector_set_length(&c, n);
      ae_vector_set_length(&cstart, n);
      for (i = 0; i < n; i++) {
         c.xR[i] = cscale * randomnormal();
         cstart.xR[i] = cscale * randomnormal();
      }
      ae_matrix_set_length(&a, 300, n);
      ae_vector_set_length(&y, a.rows);
      ae_vector_set_length(&w, a.rows);
      for (i = 0; i < a.rows; i++) {
         for (j = 0; j < n; j++) {
            a.xyR[i][j] = xscale * randomnormal();
         }
         v = ae_v_dotproduct(a.xyR[i], 1, c.xR, 1, n);
         if (i < a.rows / 2) {
            w.xR[i] = pow(10.0, randomnormal()) * wscale;
            y.xR[i] = v + noiselevel / w.xR[i] * randomnormal();
         } else {
            w.xR[i] = 0.0;
            y.xR[i] = v + noiselevel * randomnormal();
         }
      }
   // Solve problem #1 (with zero weights).
   // We randomly choose between analytic gradient and numerical differentiation.
      if (randombool()) {
         lsfitcreatewfg(&a, &y, &w, &cstart, a.rows, n, n, true, &state);
      } else {
         lsfitcreatewf(&a, &y, &w, &cstart, a.rows, n, n, 0.001 * cscale, &state);
      }
      lsfitsetcond(&state, 0.0, 10);
      while (lsfititeration(&state)) {
         if (state.needf) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += state.c.xR[i] * state.x.xR[i];
            }
         }
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += state.c.xR[i] * state.x.xR[i];
               state.g.xR[i] = state.x.xR[i];
            }
         }
      }
      lsfitresults(&state, &info, &c2, &rep);
   // Solve problem #2 (only points with non-zero weights).
   // We randomly choose between analytic gradient and numerical differentiation.
      if (randombool()) {
         lsfitcreatewfg(&a, &y, &w, &cstart, a.rows / 2, n, n, true, &state);
      } else {
         lsfitcreatewf(&a, &y, &w, &cstart, a.rows / 2, n, n, 0.001 * cscale, &state);
      }
      lsfitsetcond(&state, 0.0, 10);
      while (lsfititeration(&state)) {
         if (state.needf) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += state.c.xR[i] * state.x.xR[i];
            }
         }
         if (state.needfg) {
            state.f = 0.0;
            for (i = 0; i < n; i++) {
               state.f += state.c.xR[i] * state.x.xR[i];
               state.g.xR[i] = state.x.xR[i];
            }
         }
      }
      lsfitresults(&state, &info, &c2, &rep2);
   // Compare covariance matrices, it should be enough to test algorithm
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            set_error_flag(nlserrors, fabs(rep.covpar.xyR[i][j] - rep2.covpar.xyR[i][j]) > 1.0E-4 * rmax2(rep.covpar.xyR[i][i], rep.covpar.xyR[j][j]), __FILE__, __LINE__, "testlsfitunit.ap:1762");
         }
      }
   }
// Check correctness of Rep.R2
// Solve several problems with different values of R2.
//
// NOTE: we check only LSFitLinear() because other functions should use same algorithm
//       for calculation of Rep.R2
   n = 4;
   ae_matrix_set_length(&a, 4, 2);
   ae_vector_set_length(&y, 4);
   a.xyR[0][0] = 1.0;
   a.xyR[0][1] = -2.0;
   y.xR[0] = -2.0;
   a.xyR[1][0] = 1.0;
   a.xyR[1][1] = -1.0;
   y.xR[1] = -1.0;
   a.xyR[2][0] = 1.0;
   a.xyR[2][1] = 1.0;
   y.xR[2] = 1.0;
   a.xyR[3][0] = 1.0;
   a.xyR[3][1] = 2.0;
   y.xR[3] = 2.0;
   lsfitlinear(&y, &a, 4, 1, &info, &c, &rep);
   set_error_flag(llserrors, info <= 0 || fabs(rep.r2 - 0) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1788");
   lsfitlinear(&y, &a, 4, 2, &info, &c, &rep);
   set_error_flag(llserrors, info <= 0 || fabs(rep.r2 - 1) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1790");
   a.xyR[0][0] = 1.0;
   a.xyR[0][1] = -1.0;
   y.xR[0] = -1.0;
   a.xyR[1][0] = 1.0;
   a.xyR[1][1] = -1.0;
   y.xR[1] = 0.0;
   a.xyR[2][0] = 1.0;
   a.xyR[2][1] = 1.0;
   y.xR[2] = 1.0;
   a.xyR[3][0] = 1.0;
   a.xyR[3][1] = 1.0;
   y.xR[3] = 0.0;
   lsfitlinear(&y, &a, 4, 2, &info, &c, &rep);
   set_error_flag(llserrors, info <= 0 || fabs(rep.r2 - 0.5) > threshold, __FILE__, __LINE__, "testlsfitunit.ap:1804");
   n = 3;
   ae_matrix_set_length(&a, 3, 1);
   ae_vector_set_length(&y, 3);
   a.xyR[0][0] = 0.0;
   y.xR[0] = 0.0;
   a.xyR[1][0] = 0.0;
   y.xR[1] = 0.0;
   a.xyR[2][0] = 0.0;
   y.xR[2] = 0.0;
   lsfitlinear(&y, &a, 3, 1, &info, &c, &rep);
   set_error_flag(llserrors, (info <= 0 || !isfinite(rep.r2)) || rep.r2 != 1.0, __FILE__, __LINE__, "testlsfitunit.ap:1815");
   ae_frame_leave();
}

// This function tests RDP functionality. On error sets FitErrors flag variable;
// on success - flag is not changed.
static void testlsfitunit_testrdp(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t nsections;
   ae_int_t nsections3;
   double eps;
   double v;
   ae_int_t i;
   ae_int_t k;
   ae_int_t n;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(e, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(x3, 0, DT_REAL);
   NewVector(y3, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewMatrix(xy3, 0, 0, DT_REAL);
   NewVector(idx2, 0, DT_INT);
   NewVector(idx3, 0, DT_INT);
   NewObj(spline1dinterpolant, s);
   hqrndrandomize(&rs);
// Non-parametric, single section basic test (fixed)
   ae_vector_set_length(&x, 2);
   ae_vector_set_length(&y, 2);
   x.xR[0] = 0.0;
   x.xR[1] = 1.5;
   y.xR[0] = 2.0;
   y.xR[1] = 3.0;
   lstfitpiecewiselinearrdpfixed(&x, &y, 2, 1, &x2, &y2, &nsections);
   set_error_flag(errorflag, nsections != 1, __FILE__, __LINE__, "testlsfitunit.ap:1850");
   if (nsections == 1) {
      set_error_flag(errorflag, x2.xR[0] != 0.0, __FILE__, __LINE__, "testlsfitunit.ap:1853");
      set_error_flag(errorflag, x2.xR[1] != 1.5, __FILE__, __LINE__, "testlsfitunit.ap:1854");
      set_error_flag(errorflag, y2.xR[0] != 2.0, __FILE__, __LINE__, "testlsfitunit.ap:1855");
      set_error_flag(errorflag, y2.xR[1] != 3.0, __FILE__, __LINE__, "testlsfitunit.ap:1856");
   }
// Non-parametric, single section tied test (fixed)
   ae_vector_set_length(&x, 5);
   ae_vector_set_length(&y, 5);
   x.xR[0] = 0.0;
   x.xR[1] = 1.5;
   x.xR[2] = 0.0;
   x.xR[3] = 0.0;
   x.xR[4] = 1.5;
   y.xR[0] = 2.0;
   y.xR[1] = 1.0;
   y.xR[2] = 3.0;
   y.xR[3] = 1.0;
   y.xR[4] = 5.0;
   lstfitpiecewiselinearrdpfixed(&x, &y, 5, 1, &x2, &y2, &nsections);
   set_error_flag(errorflag, nsections != 1, __FILE__, __LINE__, "testlsfitunit.ap:1875");
   if (nsections == 1) {
      set_error_flag(errorflag, x2.xR[0] != 0.0, __FILE__, __LINE__, "testlsfitunit.ap:1878");
      set_error_flag(errorflag, x2.xR[1] != 1.5, __FILE__, __LINE__, "testlsfitunit.ap:1879");
      set_error_flag(errorflag, y2.xR[0] != 2.0, __FILE__, __LINE__, "testlsfitunit.ap:1880");
      set_error_flag(errorflag, y2.xR[1] != 3.0, __FILE__, __LINE__, "testlsfitunit.ap:1881");
   }
// Non-parametric, two-section test (fixed)
   ae_vector_set_length(&x, 5);
   ae_vector_set_length(&y, 5);
   x.xR[0] = 0.0;
   x.xR[1] = 0.5;
   x.xR[2] = 1.0;
   x.xR[3] = 1.75;
   x.xR[4] = 2.0;
   y.xR[0] = 1.0;
   y.xR[1] = 2.1;
   y.xR[2] = 3.0;
   y.xR[3] = 5.21;
   y.xR[4] = 6.0;
   lstfitpiecewiselinearrdpfixed(&x, &y, 5, 2, &x2, &y2, &nsections);
   set_error_flag(errorflag, nsections != 2, __FILE__, __LINE__, "testlsfitunit.ap:1900");
   if (nsections == 2) {
      set_error_flag(errorflag, x2.xR[0] != 0.0, __FILE__, __LINE__, "testlsfitunit.ap:1903");
      set_error_flag(errorflag, x2.xR[1] != 1.0, __FILE__, __LINE__, "testlsfitunit.ap:1904");
      set_error_flag(errorflag, x2.xR[2] != 2.0, __FILE__, __LINE__, "testlsfitunit.ap:1905");
      set_error_flag(errorflag, y2.xR[0] != 1.0, __FILE__, __LINE__, "testlsfitunit.ap:1906");
      set_error_flag(errorflag, y2.xR[1] != 3.0, __FILE__, __LINE__, "testlsfitunit.ap:1907");
      set_error_flag(errorflag, y2.xR[2] != 6.0, __FILE__, __LINE__, "testlsfitunit.ap:1908");
   }
// Non-parametric, variable precision test (non-fixed), results are compared against fixed-section test
   eps = 10.0;
   n = 100;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&y, n);
   while (eps >= 0.0001) {
   // Generate set of randomly rearranged points
      for (i = 0; i < n; i++) {
         x.xR[i] = pi * i / (n - 1);
         y.xR[i] = sin(x.xR[i]) + 0.01 * (hqrnduniformr(&rs) - 0.5);
      }
      for (i = 0; i < n - 1; i++) {
         k = i + hqrnduniformi(&rs, n - i);
         v = x.xR[i];
         x.xR[i] = x.xR[k];
         x.xR[k] = v;
         v = y.xR[i];
         y.xR[i] = y.xR[k];
         y.xR[k] = v;
      }
   // Perform run of eps-based RDP algorithm
      lstfitpiecewiselinearrdp(&x, &y, n, eps, &x2, &y2, &nsections);
      set_error_flag(errorflag, nsections == 0, __FILE__, __LINE__, "testlsfitunit.ap:1943");
      if (nsections == 0) {
         ae_frame_leave();
         return;
      }
   // Check properties
      for (i = 0; i < nsections; i++) {
         set_error_flag(errorflag, x2.xR[i] > x2.xR[i + 1], __FILE__, __LINE__, "testlsfitunit.ap:1951");
      }
      spline1dbuildlinear(&x2, &y2, nsections + 1, &s);
      for (i = 0; i < n; i++) {
         set_error_flag(errorflag, fabs(spline1dcalc(&s, x.xR[i]) - y.xR[i]) > eps, __FILE__, __LINE__, "testlsfitunit.ap:1954");
      }
   // compare results with values returned by section-based algorithm
      lstfitpiecewiselinearrdpfixed(&x, &y, n, nsections, &x3, &y3, &nsections3);
      set_error_flag(errorflag, nsections3 != nsections, __FILE__, __LINE__, "testlsfitunit.ap:1960");
      if (*errorflag) {
         ae_frame_leave();
         return;
      }
      for (i = 0; i < nsections; i++) {
         set_error_flag(errorflag, fabs(x2.xR[i] - x3.xR[i]) > 1000 * machineepsilon, __FILE__, __LINE__, "testlsfitunit.ap:1965");
         set_error_flag(errorflag, fabs(y2.xR[i] - y3.xR[i]) > 1000 * machineepsilon, __FILE__, __LINE__, "testlsfitunit.ap:1966");
      }
   // Next epsilon
      eps *= 0.5;
   }
// Test that non-parametric RDP correctly handles requests for more than N-1 section
   n = 100;
   ae_vector_set_length(&x, n);
   ae_vector_set_length(&y, n);
   for (i = 0; i < n; i++) {
      x.xR[i] = pi * hqrnduniformr(&rs);
      y.xR[i] = sin(x.xR[i]) + 0.01 * (hqrnduniformr(&rs) - 0.5);
   }
   lstfitpiecewiselinearrdpfixed(&x, &y, n, n, &x2, &y2, &nsections);
   set_error_flag(errorflag, nsections > n - 1, __FILE__, __LINE__, "testlsfitunit.ap:1987");
   ae_frame_leave();
}

// Appends 10 elements to the array
static void testlsfitunit_append10(RVector *x, double v0, double v1, double v2, double v3, double v4, double v5, double v6, double v7, double v8, double v9) {
   rvectorresize(x, x->cnt + 10);
   x->xR[x->cnt - 10] = v0;
   x->xR[x->cnt - 9] = v1;
   x->xR[x->cnt - 8] = v2;
   x->xR[x->cnt - 7] = v3;
   x->xR[x->cnt - 6] = v4;
   x->xR[x->cnt - 5] = v5;
   x->xR[x->cnt - 4] = v6;
   x->xR[x->cnt - 3] = v7;
   x->xR[x->cnt - 2] = v8;
   x->xR[x->cnt - 1] = v9;
}

// This function tests 4PL/5PL fitting. On error sets FitErrors flag variable;
// on success - flag is not changed.
static void testlsfitunit_testlogisticfitting(bool *fiterrors) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nz;
   ae_int_t ntotal;
   ae_int_t i;
   ae_int_t k;
   double v;
   double vv;
   ae_int_t k0;
   ae_int_t k1;
   double v0;
   double v1;
   ae_int_t pass;
   ae_int_t idxa;
   ae_int_t idxb;
   ae_int_t idxc;
   ae_int_t idxd;
   ae_int_t idxg;
   ae_int_t idxx;
   double a;
   double b;
   double c;
   double d;
   double g;
   double ae;
   double be;
   double ce;
   double de;
   double ge;
   double scalex;
   double scaley;
   double noise;
   double tol;
   double er2;
   double erms;
   double eavg;
   double eavgrel;
   double emax;
   double rss;
   double tss;
   double meany;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(lsfitreport, rep);
   NewObj(lsfitreport, rep2);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// 4PL/5PL calculation
   tol = 1.0E-6;
   for (idxa = -4; idxa <= 4; idxa++) {
      for (idxb = -3; idxb <= 3; idxb++) {
         for (idxc = -4; idxc <= 4; idxc++) {
            for (idxd = -4; idxd <= 4; idxd++) {
               for (idxg = -4; idxg <= 4; idxg++) {
                  for (idxx = -4; idxx <= 4; idxx++) {
                  // Convert Idx* to corresponding parameter value
                     a = (double)idxa;
                     b = (double)idxb;
                     c = pow(2.0, (double)idxc);
                     d = (double)idxd;
                     g = pow(2.0, (double)idxg);
                     if (idxx != 0) {
                        v = pow(2.0, (double)idxx);
                     } else {
                        v = 0.0;
                     }
                  // Test 4PL calculation
                     vv = 0.0;
                     if (v != 0.0) {
                        vv = d + (a - d) / (1 + pow(v / c, b));
                     } else {
                        if (b > 0.0) {
                           vv = a;
                        }
                        if (b < 0.0) {
                           vv = d;
                        }
                        if (b == 0.0) {
                           vv = 0.5 * (a + d);
                        }
                     }
                     v0 = logisticcalc4(v, a, b, c, d);
                     set_error_flag(fiterrors, fabs(vv - v0) > tol, __FILE__, __LINE__, "testlsfitunit.ap:2057");
                  // Test 5PL calculation
                     if (v != 0.0) {
                        vv = d + (a - d) / pow(1 + pow(v / c, b), g);
                     } else {
                        if (b > 0.0) {
                           vv = a;
                        }
                        if (b < 0.0) {
                           vv = d;
                        }
                        if (b == 0.0) {
                           vv = d + (a - d) / pow(2.0, g);
                        }
                     }
                     v0 = logisticcalc5(v, a, b, c, d, g);
                     set_error_flag(fiterrors, fabs(vv - v0) > tol, __FILE__, __LINE__, "testlsfitunit.ap:2074");
                  }
               }
            }
         }
      }
   }
// 4PL fitting
//
// Generate random AE/BE/CE/DE, generate random set of points and for
// each point generate two function values: F(x)+eps and F(x)-eps.
// Such problem has solution which is exactly AE/BE/CE/DE which were
// used to generate points.
//
// This test checks both unconstrained and constrained fitting (latter
// one is performed with A constrained to AE, B constrained to BE).
   tol = 1.0E-6;
   for (pass = 1; pass <= 30; pass++) {
   // Generate 2*N points with non-zero X and 2*NZ points with
   // zero X. In most cases we choose N != 0 and NZ != 0, but in
   // some cases either N or NZ (but not both) is zero.
   //
   // X-values have scale equal to ScaleX
      scalex = pow(10.0, 30 * hqrnduniformr(&rs) - 15);
      n = 40 + hqrnduniformi(&rs, 40);
      nz = 4 + hqrnduniformi(&rs, 4);
      if (hqrnduniformr(&rs) < 0.1) {
         if (hqrnduniformr(&rs) < 0.5) {
            n = 0;
         } else {
            nz = 0;
         }
      }
      ntotal = 2 * (n + nz);
      ae_vector_set_length(&x, ntotal);
      for (i = 0; i < n; i++) {
         v = scalex * exp(log(5.0) * (2 * hqrnduniformr(&rs) - 1));
         x.xR[2 * i + 0] = v;
         x.xR[2 * i + 1] = v;
      }
      for (i = 0; i < nz; i++) {
         x.xR[2 * n + 2 * i + 0] = 0.0;
         x.xR[2 * n + 2 * i + 1] = 0.0;
      }
   // Fenerate A/B/C/D:
   // * A/D are random with scale equal to ScaleY
   // * B is in +-[0.25,4.0]
   // * for C we choose one of X[], if N>0;
   //   if N=0, we set C=1.
      scaley = pow(10.0, 30 * hqrnduniformr(&rs) - 15);
      ae = scaley * (hqrnduniformr(&rs) - 0.5);
      be = (2 * hqrnduniformi(&rs, 2) - 1) * exp(log(4.0) * (2 * hqrnduniformr(&rs) - 1));
      ce = scalex * exp(log(2.0) * (2 * hqrnduniformr(&rs) - 1));
      de = ae + scaley * (2 * hqrnduniformi(&rs, 2) - 1) * (hqrnduniformr(&rs) + 0.5);
   // Choose noise level and generate Y[].
      noise = 0.05 * scaley;
      ae_vector_set_length(&y, ntotal);
      for (i = 0; i < ntotal / 2; i++) {
         if (x.xR[2 * i + 0] != 0.0) {
            v = de + (ae - de) / (1.0 + pow(x.xR[2 * i + 0] / ce, be));
         } else {
            if (be >= 0.0) {
               v = ae;
            } else {
               v = de;
            }
         }
         y.xR[2 * i + 0] = v + noise;
         y.xR[2 * i + 1] = v - noise;
      }
   // Unconstrained fit and test
   //
   // NOTE: we test that B >= 0 is returned. If BE<0, we use
   //       symmetry property of 4PL model.
      logisticfit4(&x, &y, ntotal, &a, &b, &c, &d, &rep);
      set_error_flag(fiterrors, !isfinite(a), __FILE__, __LINE__, "testlsfitunit.ap:2162");
      set_error_flag(fiterrors, !isfinite(b), __FILE__, __LINE__, "testlsfitunit.ap:2163");
      set_error_flag(fiterrors, !isfinite(c), __FILE__, __LINE__, "testlsfitunit.ap:2164");
      set_error_flag(fiterrors, !isfinite(d), __FILE__, __LINE__, "testlsfitunit.ap:2165");
      set_error_flag(fiterrors, b < 0.0, __FILE__, __LINE__, "testlsfitunit.ap:2166");
      v = 0.0;
      for (i = 0; i < ntotal; i++) {
         if (x.xR[i] != 0.0) {
            vv = d + (a - d) / (1.0 + pow(x.xR[i] / c, b));
         } else {
            vv = a;
         }
         v += sqr(y.xR[i] - vv);
      }
      v = sqrt(v / ntotal);
      set_error_flag(fiterrors, v > (1 + tol) * noise, __FILE__, __LINE__, "testlsfitunit.ap:2177");
   // Constrained fit and test
   //
   // NOTE: we test that B >= 0 is returned. If BE<0, we use
   //       symmetry property of 4PL model.
      for (k0 = 0; k0 <= 1; k0++) {
         for (k1 = 0; k1 <= 1; k1++) {
         // Choose constraints.
            if (k0 == 0) {
               v0 = NAN;
            } else {
               if (be >= 0.0) {
                  v0 = ae;
               } else {
                  v0 = de;
               }
            }
            if (k1 == 0) {
               v1 = NAN;
            } else {
               if (be >= 0.0) {
                  v1 = de;
               } else {
                  v1 = ae;
               }
            }
         // Fit
            logisticfit4ec(&x, &y, ntotal, v0, v1, &a, &b, &c, &d, &rep);
         // Check
            set_error_flag(fiterrors, !isfinite(a), __FILE__, __LINE__, "testlsfitunit.ap:2218");
            set_error_flag(fiterrors, !isfinite(b), __FILE__, __LINE__, "testlsfitunit.ap:2219");
            set_error_flag(fiterrors, !isfinite(c), __FILE__, __LINE__, "testlsfitunit.ap:2220");
            set_error_flag(fiterrors, !isfinite(d), __FILE__, __LINE__, "testlsfitunit.ap:2221");
            set_error_flag(fiterrors, b < 0.0, __FILE__, __LINE__, "testlsfitunit.ap:2222");
            set_error_flag(fiterrors, k0 != 0 && a != v0, __FILE__, __LINE__, "testlsfitunit.ap:2223");
            set_error_flag(fiterrors, k1 != 0 && d != v1, __FILE__, __LINE__, "testlsfitunit.ap:2224");
            v = 0.0;
            for (i = 0; i < ntotal; i++) {
               if (x.xR[i] != 0.0) {
                  vv = d + (a - d) / (1.0 + pow(x.xR[i] / c, b));
               } else {
                  if (b >= 0.0) {
                     vv = a;
                  } else {
                     vv = d;
                  }
               }
               v += sqr(y.xR[i] - vv);
            }
            v = sqrt(v / ntotal);
            set_error_flag(fiterrors, v > (1 + tol) * noise, __FILE__, __LINE__, "testlsfitunit.ap:2240");
         }
      }
   }
// 5PL fitting
//
// Generate random AE/BE/CE/DE/GE, generate random set of points and for
// each point generate two function values: F(x)+eps and F(x)-eps.
// Such problem has solution which is exactly AE/BE/CE/DE which were
// used to generate points.
//
// NOTE: because problem has higher condition number, we use lower
//       tolerance for power parameters B and G.
//
// This test checks both unconstrained and constrained fitting.
   tol = 1.0E-6;
   for (pass = 1; pass <= 10; pass++) {
   // Generate N points, N-1 of them with non-zero X and
   // last one with zero X.
   // X-values have scale equal to ScaleX
      scalex = pow(10.0, 30 * hqrnduniformr(&rs) - 15);
      k = 50;
      n = 2 * k + 1;
      ae_vector_set_length(&x, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = scalex * pow(2.0, (double)(2 * (i - k)) / k);
      }
      x.xR[n - 1] = 0.0;
   // Generate A/B/C/D/G:
   // * A/D are random with scale equal to ScaleY
   // * B is in +-[0.25,4.0]
   // * G is in   [0.25,4.0]
   // * C is in   [0.25,4.0]*ScaleX
   //   if N=0, we set C=1.
   // Generate Y[].
      scaley = pow(10.0, 30 * hqrnduniformr(&rs) - 15);
      ae = scaley * (hqrnduniformr(&rs) - 0.5);
      be = (2 * hqrnduniformi(&rs, 2) - 1) * exp(log(2.0) * (2 * hqrnduniformr(&rs) - 1));
      ce = scalex * exp(log(2.0) * (2 * hqrnduniformr(&rs) - 1));
      de = ae + scaley * (2 * hqrnduniformi(&rs, 2) - 1) * (hqrnduniformr(&rs) + 0.5);
      ge = exp(log(2.0) * (2 * hqrnduniformr(&rs) - 1));
      ae_vector_set_length(&y, n);
      for (i = 0; i < n; i++) {
         if (x.xR[i] != 0.0) {
            v = de + (ae - de) / pow(1.0 + pow(x.xR[i] / ce, be), ge);
         } else {
            if (be >= 0.0) {
               v = ae;
            } else {
               v = de;
            }
         }
         y.xR[i] = v;
      }
   // Unconstrained fit and test
   //
   // NOTE: we test that B >= 0 is returned. If BE<0, we use
   //       symmetry property of 4PL model.
      logisticfit5(&x, &y, n, &a, &b, &c, &d, &g, &rep);
      v = 0.0;
      for (i = 0; i < n; i++) {
         if (x.xR[i] != 0.0) {
            vv = d + (a - d) / pow(1.0 + pow(x.xR[i] / c, b), g);
         } else {
            if (b >= 0.0) {
               vv = a;
            } else {
               vv = d;
            }
         }
         v += sqr(y.xR[i] - vv);
      }
      v = sqrt(v / n);
      set_error_flag(fiterrors, v > scaley * tol, __FILE__, __LINE__, "testlsfitunit.ap:2325");
   // Constrained fit and test
      for (k0 = 0; k0 <= 1; k0++) {
         for (k1 = 0; k1 <= 1; k1++) {
         // Choose constraints.
            if (k0 == 0) {
               v0 = NAN;
            } else {
               if (be >= 0.0) {
                  v0 = ae;
               } else {
                  v0 = de;
               }
            }
            if (k1 == 0) {
               v1 = NAN;
            } else {
               if (be >= 0.0) {
                  v1 = de;
               } else {
                  v1 = ae;
               }
            }
         // Fit
            logisticfit5ec(&x, &y, n, v0, v1, &a, &b, &c, &d, &g, &rep);
            set_error_flag(fiterrors, !isfinite(a), __FILE__, __LINE__, "testlsfitunit.ap:2359");
            set_error_flag(fiterrors, !isfinite(b), __FILE__, __LINE__, "testlsfitunit.ap:2360");
            set_error_flag(fiterrors, !isfinite(c), __FILE__, __LINE__, "testlsfitunit.ap:2361");
            set_error_flag(fiterrors, !isfinite(d), __FILE__, __LINE__, "testlsfitunit.ap:2362");
            if (b > 0.0) {
               set_error_flag(fiterrors, k0 != 0 && a != v0, __FILE__, __LINE__, "testlsfitunit.ap:2365");
               set_error_flag(fiterrors, k1 != 0 && d != v1, __FILE__, __LINE__, "testlsfitunit.ap:2366");
            } else {
               set_error_flag(fiterrors, k0 != 0 && d != v0, __FILE__, __LINE__, "testlsfitunit.ap:2370");
               set_error_flag(fiterrors, k1 != 0 && a != v1, __FILE__, __LINE__, "testlsfitunit.ap:2371");
            }
            v = 0.0;
            for (i = 0; i < n; i++) {
               if (x.xR[i] != 0.0) {
                  vv = d + (a - d) / pow(1.0 + pow(x.xR[i] / c, b), g);
               } else {
                  if (b >= 0.0) {
                     vv = a;
                  } else {
                     vv = d;
                  }
               }
               v += sqr(y.xR[i] - vv);
            }
            v = sqrt(v / n);
            set_error_flag(fiterrors, v > scaley * tol, __FILE__, __LINE__, "testlsfitunit.ap:2388");
         }
      }
   }
// Test correctness of errors
   tol = 1.0E-6;
   for (pass = 1; pass <= 20; pass++) {
      n = 10;
      meany = 0.0;
      ae_vector_set_length(&x, n);
      ae_vector_set_length(&y, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = (double)i;
         y.xR[i] = hqrnduniformr(&rs) - 0.5;
         meany += y.xR[i];
      }
      meany /= n;
      x.xR[1] = 0.0;
   // Choose model fitting function to test
      k = hqrnduniformi(&rs, 4);
      a = 0.0;
      d = 0.0;
      c = 1.0;
      b = 1.0;
      g = 1.0;
      if (k == 0) {
         logisticfit4(&x, &y, n, &a, &b, &c, &d, &rep);
         g = 1.0;
      }
      if (k == 1) {
         logisticfit4ec(&x, &y, n, hqrnduniformr(&rs) - 0.5, hqrnduniformr(&rs) - 0.5, &a, &b, &c, &d, &rep);
         g = 1.0;
      }
      if (k == 2) {
         logisticfit5(&x, &y, n, &a, &b, &c, &d, &g, &rep);
      }
      if (k == 3) {
         logisticfit5ec(&x, &y, n, hqrnduniformr(&rs) - 0.5, hqrnduniformr(&rs) - 0.5, &a, &b, &c, &d, &g, &rep);
      }
      k = 0;
      erms = 0.0;
      eavg = 0.0;
      eavgrel = 0.0;
      emax = 0.0;
      rss = 0.0;
      tss = 0.0;
      for (i = 0; i < n; i++) {
         if (x.xR[i] != 0.0) {
            v = d + (a - d) / pow(1.0 + pow(x.xR[i] / c, b), g);
         } else {
            if (b >= 0.0) {
               v = a;
            } else {
               v = d;
            }
         }
         v -= y.xR[i];
         rss += v * v;
         tss += sqr(y.xR[i] - meany);
         erms += sqr(v);
         eavg += fabs(v);
         if (y.xR[i] != 0.0) {
            eavgrel += fabs(v / y.xR[i]);
            k++;
         }
         emax = rmax2(emax, fabs(v));
      }
      er2 = 1.0 - rss / tss;
      erms = sqrt(erms / n);
      eavg /= n;
      if (k > 0) {
         eavgrel /= k;
      }
      set_error_flag(fiterrors, fabs(erms - rep.rmserror) > tol, __FILE__, __LINE__, "testlsfitunit.ap:2477");
      set_error_flag(fiterrors, fabs(eavg - rep.avgerror) > tol, __FILE__, __LINE__, "testlsfitunit.ap:2478");
      set_error_flag(fiterrors, fabs(emax - rep.maxerror) > tol, __FILE__, __LINE__, "testlsfitunit.ap:2479");
      set_error_flag(fiterrors, fabs(eavgrel - rep.avgrelerror) > tol, __FILE__, __LINE__, "testlsfitunit.ap:2480");
      set_error_flag(fiterrors, fabs(er2 - rep.r2) > tol, __FILE__, __LINE__, "testlsfitunit.ap:2481");
   }
// Test previously fixed bug #834
   ae_vector_set_length(&x, 0);
   testlsfitunit_append10(&x, 0.019556, 0.093533, 0.13780, 0.25210, 0.46373, 0.23997, 0.52861, 0.50526, 0.43401, 0.82270);
   testlsfitunit_append10(&x, 0.65746, 0.76479, 0.81512, 0.89031, 1.1959, 1.2032, 1.0671, 1.2350, 1.2954, 1.5422);
   testlsfitunit_append10(&x, 1.4306, 1.5628, 1.6774, 1.8053, 1.9866, 2.1446, 2.1740, 2.2574, 2.2662, 2.4035);
   testlsfitunit_append10(&x, 2.7225, 2.6500, 2.7752, 2.9126, 2.8962, 3.0439, 3.1260, 3.2458, 3.3613, 3.3728);
   testlsfitunit_append10(&x, 3.5641, 3.5168, 3.6975, 3.7848, 3.8421, 3.9058, 4.0292, 4.1111, 4.0835, 4.3436);
   testlsfitunit_append10(&x, 4.3982, 4.6098, 4.3606, 4.5595, 4.7099, 4.8806, 4.9779, 4.9909, 5.0121, 5.2571);
   testlsfitunit_append10(&x, 5.3663, 5.4739, 5.5818, 5.5224, 5.7895, 5.9141, 6.0897, 6.1476, 6.2491, 6.3541);
   testlsfitunit_append10(&x, 6.4007, 6.5969, 6.6530, 6.7837, 6.8692, 6.9383, 7.0344, 7.1702, 7.3118, 7.3728);
   testlsfitunit_append10(&x, 7.4589, 7.6068, 7.6290, 7.8139, 7.9891, 8.0425, 8.1817, 8.3442, 8.3772, 8.4691);
   testlsfitunit_append10(&x, 8.5864, 8.7201, 8.9721, 8.9208, 9.0603, 9.1961, 9.3344, 9.3738, 9.4808, 9.6527);
   testlsfitunit_append10(&x, 9.7197, 9.8180, 10.034, 10.155, 10.205, 10.323, 10.421, 10.571, 10.723, 10.795);
   testlsfitunit_append10(&x, 11.000, 10.977, 11.145, 11.249, 11.425, 11.495, 11.598, 11.723, 11.787, 12.001);
   testlsfitunit_append10(&x, 12.005, 12.136, 12.312, 12.381, 12.417, 12.645, 12.766, 12.864, 12.889, 13.017);
   testlsfitunit_append10(&x, 13.171, 13.323, 13.406, 13.451, 13.551, 13.732, 13.735, 13.909, 14.075, 14.150);
   testlsfitunit_append10(&x, 14.265, 14.365, 14.524, 14.541, 14.679, 14.836, 14.998, 15.071, 15.170, 15.238);
   testlsfitunit_append10(&x, 15.327, 15.388, 15.614, 15.729, 15.671, 15.858, 15.984, 16.008, 16.219, 16.231);
   testlsfitunit_append10(&x, 16.424, 16.642, 16.784, 16.837, 16.959, 17.000, 17.088, 17.162, 17.210, 17.460);
   testlsfitunit_append10(&x, 17.597, 17.698, 17.679, 17.962, 17.974, 17.966, 18.240, 18.240, 18.521, 18.645);
   testlsfitunit_append10(&x, 18.739, 18.830, 18.749, 19.062, 19.062, 19.160, 19.224, 19.334, 19.395, 19.567);
   ae_vector_set_length(&y, 0);
   testlsfitunit_append10(&y, 0.096932, 0.099305, 0.098981, 0.098981, 0.099898, 0.096879, 0.098334, 0.097525, 0.097418, 0.098065);
   testlsfitunit_append10(&y, 0.098334, 0.096016, 0.098172, 0.096339, 0.098550, 0.098927, 0.099898, 0.098927, 0.097472, 0.097418);
   testlsfitunit_append10(&y, 0.098604, 0.097849, 0.096932, 0.098765, 0.097957, 0.099143, 0.097795, 0.098819, 0.098550, 0.098658);
   testlsfitunit_append10(&y, 0.099143, 0.096609, 0.099358, 0.099358, 0.100110, 0.098819, 0.097148, 0.098604, 0.095692, 0.097849);
   testlsfitunit_append10(&y, 0.098172, 0.097957, 0.099898, 0.097687, 0.097364, 0.098226, 0.098280, 0.099844, 0.099143, 0.098765);
   testlsfitunit_append10(&y, 0.099412, 0.098442, 0.100110, 0.098172, 0.098334, 0.096932, 0.097687, 0.098981, 0.098873, 0.096501);
   testlsfitunit_append10(&y, 0.098550, 0.099682, 0.100170, 0.098927, 0.099628, 0.099628, 0.099197, 0.099089, 0.098550, 0.098819);
   testlsfitunit_append10(&y, 0.099035, 0.097202, 0.099736, 0.099628, 0.099035, 0.099035, 0.099305, 0.097795, 0.099143, 0.100060);
   testlsfitunit_append10(&y, 0.098442, 0.099951, 0.098065, 0.099628, 0.098388, 0.099898, 0.098873, 0.099520, 0.097795, 0.097687);
   testlsfitunit_append10(&y, 0.098658, 0.098765, 0.099628, 0.099736, 0.098388, 0.099628, 0.099251, 0.098334, 0.097903, 0.099682);
   testlsfitunit_append10(&y, 0.097094, 0.098765, 0.098765, 0.098981, 0.099574, 0.099736, 0.098280, 0.099520, 0.099466, 0.099790);
   testlsfitunit_append10(&y, 0.099358, 0.098873, 0.097579, 0.099143, 0.099951, 0.099035, 0.097256, 0.098765, 0.099520, 0.099790);
   testlsfitunit_append10(&y, 0.097094, 0.099520, 0.099305, 0.098765, 0.098604, 0.099790, 0.098226, 0.099251, 0.098819, 0.099574);
   testlsfitunit_append10(&y, 0.099682, 0.099951, 0.098119, 0.100220, 0.099197, 0.098334, 0.099035, 0.098927, 0.099628, 0.10076);
   testlsfitunit_append10(&y, 0.10081, 0.10351, 0.10367, 0.10405, 0.10502, 0.10815, 0.11208, 0.11451, 0.11467, 0.11639);
   testlsfitunit_append10(&y, 0.11839, 0.12195, 0.12378, 0.12577, 0.12755, 0.12842, 0.13262, 0.13747, 0.14486, 0.15483);
   testlsfitunit_append10(&y, 0.17554, 0.20422, 0.23796, 0.27581, 0.31495, 0.35576, 0.39857, 0.44374, 0.48946, 0.53475);
   testlsfitunit_append10(&y, 0.57766, 0.61960, 0.65400, 0.68936, 0.72268, 0.75573, 0.78446, 0.81169, 0.83185, 0.86247);
   testlsfitunit_append10(&y, 0.88797, 0.91083, 0.93142, 0.94916, 0.96463, 0.97881, 0.98809, 0.99774, 0.99844, 1.00000);
   logisticfit4(&x, &y, 190, &a, &b, &c, &d, &rep);
   set_error_flag(fiterrors, b < 31.90 || b > 32.00, __FILE__, __LINE__, "testlsfitunit.ap:2528");
   set_error_flag(fiterrors, rep.rmserror > 0.02, __FILE__, __LINE__, "testlsfitunit.ap:2529");
   logisticfit5(&x, &y, 190, &a, &b, &c, &d, &g, &rep2);
   set_error_flag(fiterrors, rep2.rmserror > 0.95 * rep.rmserror, __FILE__, __LINE__, "testlsfitunit.ap:2531");
   ae_frame_leave();
}

// This function return function's value(F=F(X,C)) and it derivatives(DF=dF/dC).
// Function dimension is M. Length(C) is K.
//     Function's list:
//         * funcType=1:
//             K>M:
//             F(X)=C0^2*(X0-CX0)^2+C1^2*(X1-CX1)^2+...+CM^2*(XM-CXM)^2
//                 +C(M+1)^2+...+CK^2;
//             K<M:
//             F(X)=C0^2*(X0-CX0)^2+C1^2*(X1-CX1)^2+...+CK^2*(XK-CXK)^2
//                 +(X(K+1)-CX(K+1))^2+...+(XM-CXM)^2;
//         * funcType=2:
//             K>M:
//             F(X)=C0*sin(X0-CX0)^2+C1*sin(X1-CX1)^2+...+CM*sin(XM-CXM)^2
//                 +C(M+1)^3+...+CK^3;
//             K<M
//             F(X)=C0*sin(X0-CX0)^2+C1*sin(X1-CX1)^2+...+CK*sin(XK-CXK)^2
//                 +sin(X(K+1)-CX(K+1))^2+...+sin(XM-CXM)^2;
//         * funcType=3:
//             F(X)=C0^2+C1^2+...+CK^2+(X0-CX0)^2+(X1-CX1)^2+...+(XM-CXM)^2.
static void testlsfitunit_funcderiv(RVector *c, RVector *x, RVector *x0, ae_int_t k, ae_int_t m, ae_int_t functype, double *f, RVector *g) {
   ae_int_t i;
   ae_assert(functype >= 1 && functype <= 3, "FuncDeriv: incorrect funcType(funcType<1 or funcType>3).");
   ae_assert(k > 0, "FuncDeriv: K <= 0");
   ae_assert(m > 0, "FuncDeriv: M <= 0");
   ae_assert(x->cnt >= m, "FuncDeriv: Length(X)<M");
   ae_assert(isfinitevector(x, m), "FuncDeriv: X contains NaN or Infinite.");
   ae_assert(x0->cnt >= m, "FuncDeriv: Length(X0)<M");
   ae_assert(isfinitevector(x0, m), "FuncDeriv: X0 contains NaN or Infinite.");
   ae_assert(c->cnt >= k, "FuncDeriv: Length(X)<K");
   ae_assert(isfinitevector(c, k), "FuncDeriv: C contains NaN or Infinite.");
   if (functype == 1) {
      *f = 0.0;
      for (i = 0; i < imin2(m, k); i++) {
         *f += sqr(c->xR[i] * (x->xR[i] - x0->xR[i]));
         g->xR[i] = 2 * c->xR[i] * sqr(x->xR[i] - x0->xR[i]);
      }
      if (k > m) {
         for (i = m; i < k; i++) {
            *f += sqr(c->xR[i]);
            g->xR[i] = 2 * c->xR[i];
         }
      }
      if (k < m) {
         for (i = k; i < m; i++) {
            *f += sqr(x->xR[i] - x0->xR[i]);
         }
      }
      return;
   }
   if (functype == 2) {
      *f = 0.0;
      for (i = 0; i < imin2(m, k); i++) {
         *f += c->xR[i] * sqr(sin(x->xR[i] - x0->xR[i]));
         g->xR[i] = sqr(sin(x->xR[i] - x0->xR[i]));
      }
      if (k > m) {
         for (i = m; i < k; i++) {
            *f += c->xR[i] * c->xR[i] * c->xR[i];
            g->xR[i] = 3 * sqr(c->xR[i]);
         }
      }
      if (k < m) {
         for (i = k; i < m; i++) {
            *f += sqr(sin(x->xR[i] - x0->xR[i]));
         }
      }
      return;
   }
   if (functype == 3) {
      *f = 0.0;
      for (i = 0; i < m; i++) {
         *f += sqr(x->xR[i] - x0->xR[i]);
      }
      for (i = 0; i < k; i++) {
         *f += c->xR[i] * c->xR[i];
      }
      for (i = 0; i < k; i++) {
         g->xR[i] = 2 * c->xR[i];
      }
      return;
   }
}

// This function tests, that gradient verified correctly.
// On failure sets error flag, on success does not modify it.
static void testlsfitunit_testgradientcheck(bool *testg) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t k;
   ae_int_t info;
   ae_int_t infcomp;
   double teststep;
   double noise;
   ae_int_t nbrcomp;
   double spp;
   ae_int_t func;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(&_frame_block);
   NewObj(lsfitstate, state);
   NewObj(lsfitreport, rep);
   NewVector(c, 0, DT_REAL);
   NewVector(cres, 0, DT_REAL);
   NewMatrix(x, 0, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(bl, 0, DT_REAL);
   NewVector(bu, 0, DT_REAL);
   passcount = 35;
   spp = 1.0;
   teststep = 0.001;
   for (pass = 1; pass <= passcount; pass++) {
      m = randominteger(5) + 1;
      ae_vector_set_length(&x0, m);
      k = randominteger(5) + 1;
      ae_vector_set_length(&c, k);
      ae_vector_set_length(&bl, k);
      ae_vector_set_length(&bu, k);
   // Prepare test's parameters
      func = randominteger(3) + 1;
      n = randominteger(8) + 3;
      ae_matrix_set_length(&x, n, m);
      ae_vector_set_length(&y, n);
      nbrcomp = randominteger(k);
      noise = (double)(2 * randominteger(2) - 1);
   // Prepare function's parameters
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            x.xyR[i][j] = spp * randommid();
         }
         y.xR[i] = spp * randommid();
      }
      for (i = 0; i < k; i++) {
         c.xR[i] = spp * randommid();
      }
      for (i = 0; i < m; i++) {
         x0.xR[i] = 10 * randommid();
      }
   // Prepare boundary parameters
      for (i = 0; i < k; i++) {
         bl.xR[i] = -randomreal() - spp;
         bu.xR[i] = randomreal() + spp;
      }
      infcomp = randominteger(k + 1);
      if (infcomp < k) {
         bl.xR[infcomp] = -INFINITY;
      }
      infcomp = randominteger(k + 1);
      if (infcomp < k) {
         bu.xR[infcomp] = +INFINITY;
      }
      lsfitcreatefg(&x, &y, &c, n, m, k, true, &state);
      lsfitsetgradientcheck(&state, teststep);
      lsfitsetcond(&state, 0.0, 100);
      lsfitsetbc(&state, &bl, &bu);
   // Check that the criterion passes a derivative if it is correct
      while (lsfititeration(&state)) {
         if (state.needfg) {
            testlsfitunit_funcderiv(&state.c, &state.x, &x0, k, m, func, &state.f, &state.g);
         }
      }
      lsfitresults(&state, &info, &cres, &rep);
   // Check that error code does not equal to -7 and parameter .VarIdx
   // equal to -1.
      if (info == -7 || rep.varidx != -1) {
         set_error_flag(testg, true, __FILE__, __LINE__, "testlsfitunit.ap:3923");
         ae_frame_leave();
         return;
      }
   // Create again and...
      lsfitcreatefg(&x, &y, &c, n, m, k, true, &state);
      lsfitsetgradientcheck(&state, teststep);
      lsfitsetcond(&state, 0.0, 100);
      lsfitsetbc(&state, &bl, &bu);
   // Check that the criterion does not miss a derivative if
   // it is incorrect
      while (lsfititeration(&state)) {
         if (state.needfg) {
            testlsfitunit_funcderiv(&state.c, &state.x, &x0, k, m, func, &state.f, &state.g);
            state.g.xR[nbrcomp] += noise;
         }
      }
      lsfitresults(&state, &info, &cres, &rep);
   // Check that error code equal to -7 and parameter .VarIdx
   // equal to number of incorrect component.
      if (info != -7 || rep.varidx != nbrcomp) {
         set_error_flag(testg, true, __FILE__, __LINE__, "testlsfitunit.ap:3955");
         ae_frame_leave();
         return;
      }
   }
   ae_frame_leave();
}

bool testlsfit(bool silent) {
   bool waserrors;
   bool llserrors;
   bool nlserrors;
   bool polfiterrors;
   bool ratfiterrors;
   bool splfiterrors;
   bool graderrors;
   bool logisticerrors;
   bool rdperrors;
   bool result;
   waserrors = false;
   polfiterrors = false;
   ratfiterrors = false;
   splfiterrors = false;
   llserrors = false;
   nlserrors = false;
   graderrors = false;
   logisticerrors = false;
   rdperrors = false;
   testlsfitunit_testrdp(&rdperrors);
   testlsfitunit_testlogisticfitting(&logisticerrors);
   testlsfitunit_testpolynomialfitting(&polfiterrors);
   testlsfitunit_testrationalfitting(&ratfiterrors);
   testlsfitunit_testsplinefitting(&splfiterrors);
   testlsfitunit_testgeneralfitting(&llserrors, &nlserrors);
   testlsfitunit_testgradientcheck(&graderrors);
// report
   waserrors = ((((((llserrors || nlserrors) || polfiterrors) || ratfiterrors) || splfiterrors) || graderrors) || logisticerrors) || rdperrors;
   if (!silent) {
      printf("TESTING LEAST SQUARES\n");
      printf("POLYNOMIAL LEAST SQUARES:                ");
      if (polfiterrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("RATIONAL LEAST SQUARES:                  ");
      if (ratfiterrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("SPLINE LEAST SQUARES:                    ");
      if (splfiterrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("LINEAR LEAST SQUARES:                    ");
      if (llserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("NON-LINEAR LEAST SQUARES:                ");
      if (nlserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("TEST FOR VERIFICATION OF THE GRADIENT:   ");
      if (graderrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("LOGISTIC FITTING (4PL/5PL):              ");
      if (logisticerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("RDP ALGORITHM:                           ");
      if (rdperrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
// end
   result = !waserrors;
   return result;
}

// === fitsphere testing unit ===
// Used to calculate RLo/Rhi given XY and center position
static void testfitsphereunit_calcradii(RMatrix *xy, ae_int_t npoints, ae_int_t nx, RVector *cx, double *rlo, double *rhi) {
   ae_int_t i;
   ae_int_t j;
   double v;
   *rlo = 0;
   *rhi = 0;
   *rlo = maxrealnumber;
   *rhi = 0.0;
   for (i = 0; i < npoints; i++) {
      v = 0.0;
      for (j = 0; j < nx; j++) {
         v += sqr(xy->xyR[i][j] - cx->xR[j]);
      }
      v = sqrt(v);
      *rhi = rmax2(*rhi, v);
      *rlo = rmin2(*rlo, v);
   }
}

// Used to calculate least squares error given XY and center position
static void testfitsphereunit_calclserror(RMatrix *xy, ae_int_t npoints, ae_int_t nx, RVector *cx, double *err) {
   ae_int_t i;
   ae_int_t j;
   double v;
   double rad;
   *err = 0;
   rad = 0.0;
   for (i = 0; i < npoints; i++) {
      v = 0.0;
      for (j = 0; j < nx; j++) {
         v += sqr(cx->xR[j] - xy->xyR[i][j]);
      }
      rad += sqrt(v) / npoints;
   }
   *err = 0.0;
   for (i = 0; i < npoints; i++) {
      v = 0.0;
      for (j = 0; j < nx; j++) {
         v += sqr(cx->xR[j] - xy->xyR[i][j]);
      }
      *err += sqr(rad - sqrt(v));
   }
}

// This function tests least squares (LS) sphere fitting using generic
// synthetic datasets
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testfitsphereunit_testspherefittingls(bool *err) {
   ae_frame _frame_block;
   double xtol;
   ae_int_t npoints;
   ae_int_t nx;
   double rlo;
   double rhi;
   double ftol;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   double v0;
   double v1;
   ae_int_t problemtype;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(cx, 0, DT_REAL);
   NewVector(cy, 0, DT_REAL);
   hqrndrandomize(&rs);
   xtol = 1.0E-5;
// Generate random problem
   for (nx = 1; nx <= 4; nx++) {
   // Generate synthetic dataset, at least 5 points
      npoints = 5 + 2 * nx + hqrnduniformi(&rs, 50 + iround(pow(4.0, (double)nx)));
      ae_matrix_set_length(&xy, npoints, nx);
      for (i = 0; i < npoints; i++) {
         v = 0.0;
         for (j = 0; j < nx; j++) {
            vv = hqrndnormal(&rs);
            v += sqr(vv);
            xy.xyR[i][j] = vv;
         }
         ae_assert(v > 0.0, "Assertion failed");
         v = (1 + 0.1 * hqrnduniformr(&rs)) / sqrt(v);
         for (j = 0; j < nx; j++) {
            xy.xyR[i][j] *= v;
         }
      }
   // Solve with generic solver, check
      SetVector(&cx);
      rlo = 0.0;
      rhi = 0.0;
      problemtype = 0;
      fitspherex(&xy, npoints, nx, problemtype, 0.0, 0, 0.0, &cx, &rlo, &rhi);
      set_error_flag(err, rlo != rhi, __FILE__, __LINE__, "testfitsphereunit.ap:109");
      vv = 0.0;
      for (i = 0; i < npoints; i++) {
         v = 0.0;
         for (j = 0; j < nx; j++) {
            v += sqr(cx.xR[j] - xy.xyR[i][j]);
         }
         vv += sqrt(v) / npoints;
      }
      set_error_flag(err, fabs(vv - rlo) > xtol, __FILE__, __LINE__, "testfitsphereunit.ap:118");
      testfitsphereunit_calclserror(&xy, npoints, nx, &cx, &v0);
   // Check that small perturbations to center position increase target function
   //
   // NOTE: in fact, we do allow small increase in target function - but no more
   //       than FTol=1E-6*XTol. It helps to avoid spurious error reports in
   //       degenerate cases.
      ftol = 1.0E-6 * xtol;
      ae_vector_set_length(&cy, nx);
      for (j = 0; j < nx; j++) {
         for (k = 0; k < nx; k++) {
            cy.xR[k] = cx.xR[k];
         }
         cy.xR[j] = cx.xR[j] + xtol;
         testfitsphereunit_calclserror(&xy, npoints, nx, &cy, &v1);
         set_error_flag(err, v1 < v0 - ftol, __FILE__, __LINE__, "testfitsphereunit.ap:137");
         for (k = 0; k < nx; k++) {
            cy.xR[k] = cx.xR[k];
         }
         cy.xR[j] = cx.xR[j] - xtol;
         testfitsphereunit_calclserror(&xy, npoints, nx, &cy, &v1);
         set_error_flag(err, v1 < v0 - ftol, __FILE__, __LINE__, "testfitsphereunit.ap:144");
      }
   // Compare against results returned by specific solver
      fitspherels(&xy, npoints, nx, &cy, &v);
      set_error_flag(err, v != rlo, __FILE__, __LINE__, "testfitsphereunit.ap:151");
      for (j = 0; j < nx; j++) {
         set_error_flag(err, cy.xR[j] != cx.xR[j], __FILE__, __LINE__, "testfitsphereunit.ap:153");
      }
   }
   ae_frame_leave();
}

// This function tests sphere fitting using generic synthetic datasets and
// non-smooth target functions (MC, MI, MZ fitting)
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testfitsphereunit_testspherefittingns(bool *err) {
   ae_frame _frame_block;
   ae_int_t npoints;
   ae_int_t nx;
   double rlo;
   double rhi;
   double rlo2;
   double rhi2;
   double xtol;
   double ftol;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   ae_int_t problemtype;
   double vlo;
   double vhi;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(cx, 0, DT_REAL);
   NewVector(cy, 0, DT_REAL);
   hqrndrandomize(&rs);
   xtol = 1.0E-5;
// Generate random problem
   for (nx = 1; nx <= 4; nx++) {
   // Generate synthetic dataset
      npoints = 50 + iround(pow(4.0, (double)nx));
      ae_matrix_set_length(&xy, npoints, nx);
      for (i = 0; i < npoints; i++) {
         v = 0.0;
         for (j = 0; j < nx; j++) {
            vv = hqrndnormal(&rs);
            v += sqr(vv);
            xy.xyR[i][j] = vv;
         }
         ae_assert(v > 0.0, "Assertion failed");
         v = (1 + 0.1 * hqrnduniformr(&rs)) / sqrt(v);
         for (j = 0; j < nx; j++) {
            xy.xyR[i][j] *= v;
         }
      }
   // Perform various kinds of fit, NLC solver is used
      for (problemtype = 1; problemtype <= 3; problemtype++) {
      // Solve with generic solver
         SetVector(&cx);
         rlo = 0.0;
         rhi = 0.0;
         fitspherex(&xy, npoints, nx, problemtype, 0.0, 0, 0.0, &cx, &rlo, &rhi);
      // Check that small perturbations to center position increase target function
      //
      // NOTE: in fact, we do allow small increase in target function - but no more
      //       than FTol=1E-6*XTol. It helps to avoid spurious error reports in
      //       degenerate cases.
         ftol = 1.0E-6 * xtol;
         ae_vector_set_length(&cy, nx);
         if (problemtype == 2 || problemtype == 3) {
            vlo = 1.0;
         } else {
            vlo = 0.0;
         }
         if (problemtype == 1 || problemtype == 3) {
            vhi = 1.0;
         } else {
            vhi = 0.0;
         }
         for (j = 0; j < nx; j++) {
            for (k = 0; k < nx; k++) {
               cy.xR[k] = cx.xR[k];
            }
            cy.xR[j] = cx.xR[j] + xtol;
            testfitsphereunit_calcradii(&xy, npoints, nx, &cy, &rlo2, &rhi2);
            set_error_flag(err, rhi2 * vhi - rlo2 * vlo < rhi * vhi - rlo * vlo - ftol, __FILE__, __LINE__, "testfitsphereunit.ap:245");
            for (k = 0; k < nx; k++) {
               cy.xR[k] = cx.xR[k];
            }
            cy.xR[j] = cx.xR[j] - xtol;
            testfitsphereunit_calcradii(&xy, npoints, nx, &cy, &rlo2, &rhi2);
            set_error_flag(err, rhi2 * vhi - rlo2 * vlo < rhi * vhi - rlo * vlo - ftol, __FILE__, __LINE__, "testfitsphereunit.ap:252");
         }
      // Compare against results returned by specific solver
         if (problemtype == 1) {
            fitspheremc(&xy, npoints, nx, &cy, &rhi2);
            set_error_flag(err, rhi2 != rhi, __FILE__, __LINE__, "testfitsphereunit.ap:261");
            for (j = 0; j < nx; j++) {
               set_error_flag(err, cy.xR[j] != cx.xR[j], __FILE__, __LINE__, "testfitsphereunit.ap:263");
            }
         }
         if (problemtype == 2) {
            fitspheremi(&xy, npoints, nx, &cy, &rlo2);
            set_error_flag(err, rlo2 != rlo, __FILE__, __LINE__, "testfitsphereunit.ap:268");
            for (j = 0; j < nx; j++) {
               set_error_flag(err, cy.xR[j] != cx.xR[j], __FILE__, __LINE__, "testfitsphereunit.ap:270");
            }
         }
         if (problemtype == 3) {
            fitspheremz(&xy, npoints, nx, &cy, &rlo2, &rhi2);
            set_error_flag(err, rlo2 != rlo, __FILE__, __LINE__, "testfitsphereunit.ap:275");
            set_error_flag(err, rhi2 != rhi, __FILE__, __LINE__, "testfitsphereunit.ap:276");
            for (j = 0; j < nx; j++) {
               set_error_flag(err, cy.xR[j] != cx.xR[j], __FILE__, __LINE__, "testfitsphereunit.ap:278");
            }
         }
      }
   }
   ae_frame_leave();
}

// Used to initialize dynamic array with constant values
static void testfitsphereunit_addvalue(RMatrix *xy, ae_int_t *cnt, double v) {
   xy->xyR[*cnt / xy->cols][*cnt % xy->cols] = v;
   ++*cnt;
}

// This function tests sphere fitting
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testfitsphereunit_testspherefittingvosswinkel2(bool *err) {
   ae_frame _frame_block;
   ae_int_t cnt;
   double rlo;
   double rhi;
   double tol;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(cx, 0, DT_REAL);
   hqrndrandomize(&rs);
// Test problem #2 by Vosswinkel GmbH
   ae_matrix_set_length(&xy, 40, 2);
   cnt = 0;
   testfitsphereunit_addvalue(&xy, &cnt, 0.1026);
   testfitsphereunit_addvalue(&xy, &cnt, 0.000036);
   testfitsphereunit_addvalue(&xy, &cnt, 0.101119);
   testfitsphereunit_addvalue(&xy, &cnt, 0.016144);
   testfitsphereunit_addvalue(&xy, &cnt, 0.096754);
   testfitsphereunit_addvalue(&xy, &cnt, 0.031654);
   testfitsphereunit_addvalue(&xy, &cnt, 0.088981);
   testfitsphereunit_addvalue(&xy, &cnt, 0.045634);
   testfitsphereunit_addvalue(&xy, &cnt, 0.082056);
   testfitsphereunit_addvalue(&xy, &cnt, 0.06008);
   testfitsphereunit_addvalue(&xy, &cnt, 0.074966);
   testfitsphereunit_addvalue(&xy, &cnt, 0.075647);
   testfitsphereunit_addvalue(&xy, &cnt, 0.065);
   testfitsphereunit_addvalue(&xy, &cnt, 0.090471);
   testfitsphereunit_addvalue(&xy, &cnt, 0.052411);
   testfitsphereunit_addvalue(&xy, &cnt, 0.104381);
   testfitsphereunit_addvalue(&xy, &cnt, 0.036436);
   testfitsphereunit_addvalue(&xy, &cnt, 0.114859);
   testfitsphereunit_addvalue(&xy, &cnt, 0.019034);
   testfitsphereunit_addvalue(&xy, &cnt, 0.126577);
   testfitsphereunit_addvalue(&xy, &cnt, -0.001191);
   testfitsphereunit_addvalue(&xy, &cnt, 0.139295);
   testfitsphereunit_addvalue(&xy, &cnt, -0.024689);
   testfitsphereunit_addvalue(&xy, &cnt, 0.147143);
   testfitsphereunit_addvalue(&xy, &cnt, -0.049729);
   testfitsphereunit_addvalue(&xy, &cnt, 0.147861);
   testfitsphereunit_addvalue(&xy, &cnt, -0.076402);
   testfitsphereunit_addvalue(&xy, &cnt, 0.145907);
   testfitsphereunit_addvalue(&xy, &cnt, -0.103928);
   testfitsphereunit_addvalue(&xy, &cnt, 0.139553);
   testfitsphereunit_addvalue(&xy, &cnt, -0.133726);
   testfitsphereunit_addvalue(&xy, &cnt, 0.130429);
   testfitsphereunit_addvalue(&xy, &cnt, -0.159051);
   testfitsphereunit_addvalue(&xy, &cnt, 0.112298);
   testfitsphereunit_addvalue(&xy, &cnt, -0.179496);
   testfitsphereunit_addvalue(&xy, &cnt, 0.08821);
   testfitsphereunit_addvalue(&xy, &cnt, -0.194562);
   testfitsphereunit_addvalue(&xy, &cnt, 0.059989);
   testfitsphereunit_addvalue(&xy, &cnt, -0.204838);
   testfitsphereunit_addvalue(&xy, &cnt, 0.029135);
   testfitsphereunit_addvalue(&xy, &cnt, -0.206971);
   testfitsphereunit_addvalue(&xy, &cnt, -0.00349);
   testfitsphereunit_addvalue(&xy, &cnt, -0.206207);
   testfitsphereunit_addvalue(&xy, &cnt, -0.036427);
   testfitsphereunit_addvalue(&xy, &cnt, -0.197079);
   testfitsphereunit_addvalue(&xy, &cnt, -0.06806);
   testfitsphereunit_addvalue(&xy, &cnt, -0.180492);
   testfitsphereunit_addvalue(&xy, &cnt, -0.096353);
   testfitsphereunit_addvalue(&xy, &cnt, -0.158203);
   testfitsphereunit_addvalue(&xy, &cnt, -0.119891);
   testfitsphereunit_addvalue(&xy, &cnt, -0.132669);
   testfitsphereunit_addvalue(&xy, &cnt, -0.138375);
   testfitsphereunit_addvalue(&xy, &cnt, -0.105652);
   testfitsphereunit_addvalue(&xy, &cnt, -0.152229);
   testfitsphereunit_addvalue(&xy, &cnt, -0.078587);
   testfitsphereunit_addvalue(&xy, &cnt, -0.16316);
   testfitsphereunit_addvalue(&xy, &cnt, -0.049984);
   testfitsphereunit_addvalue(&xy, &cnt, -0.167084);
   testfitsphereunit_addvalue(&xy, &cnt, -0.022067);
   testfitsphereunit_addvalue(&xy, &cnt, -0.165233);
   testfitsphereunit_addvalue(&xy, &cnt, 0.004002);
   testfitsphereunit_addvalue(&xy, &cnt, -0.16075);
   testfitsphereunit_addvalue(&xy, &cnt, 0.028058);
   testfitsphereunit_addvalue(&xy, &cnt, -0.151829);
   testfitsphereunit_addvalue(&xy, &cnt, 0.050088);
   testfitsphereunit_addvalue(&xy, &cnt, -0.141178);
   testfitsphereunit_addvalue(&xy, &cnt, 0.067646);
   testfitsphereunit_addvalue(&xy, &cnt, -0.124169);
   testfitsphereunit_addvalue(&xy, &cnt, 0.081421);
   testfitsphereunit_addvalue(&xy, &cnt, -0.10567);
   testfitsphereunit_addvalue(&xy, &cnt, 0.087305);
   testfitsphereunit_addvalue(&xy, &cnt, -0.082618);
   testfitsphereunit_addvalue(&xy, &cnt, 0.094189);
   testfitsphereunit_addvalue(&xy, &cnt, -0.064399);
   testfitsphereunit_addvalue(&xy, &cnt, 0.099445);
   testfitsphereunit_addvalue(&xy, &cnt, -0.047018);
   testfitsphereunit_addvalue(&xy, &cnt, 0.09936);
   testfitsphereunit_addvalue(&xy, &cnt, -0.028981);
   testfitsphereunit_addvalue(&xy, &cnt, 0.101784);
   testfitsphereunit_addvalue(&xy, &cnt, -0.012918);
   tol = 1.0E-7;
// MZ problem, NLC solver
   SetVector(&cx);
   rlo = 0.0;
   rhi = 0.0;
   fitspheremz(&xy, xy.rows, xy.cols, &cx, &rlo, &rhi);
   set_error_flag(err, cx.cnt != 2, __FILE__, __LINE__, "testfitsphereunit.ap:395");
   if (*err) {
      ae_frame_leave();
      return;
   }
   set_error_flag(err, fabs(cx.xR[0] + 0.050884688) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:398");
   set_error_flag(err, fabs(cx.xR[1] + 0.011472328) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:399");
   set_error_flag(err, fabs(rlo - 0.150973382) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:400");
   set_error_flag(err, fabs(rhi - 0.164374709) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:401");
   SetVector(&cx);
   rlo = 0.0;
   rhi = 0.0;
   fitspherex(&xy, xy.rows, xy.cols, 3, 0.0, 0, 0.0, &cx, &rlo, &rhi);
   set_error_flag(err, cx.cnt != 2, __FILE__, __LINE__, "testfitsphereunit.ap:406");
   if (*err) {
      ae_frame_leave();
      return;
   }
   set_error_flag(err, fabs(cx.xR[0] + 0.050884688) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:409");
   set_error_flag(err, fabs(cx.xR[1] + 0.011472328) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:410");
   set_error_flag(err, fabs(rlo - 0.150973382) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:411");
   set_error_flag(err, fabs(rhi - 0.164374709) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:412");
// MC problem, NLC solver
   SetVector(&cx);
   rlo = 0.0;
   rhi = 0.0;
   fitspheremc(&xy, xy.rows, xy.cols, &cx, &rhi);
   set_error_flag(err, cx.cnt != 2, __FILE__, __LINE__, "testfitsphereunit.ap:421");
   if (*err) {
      ae_frame_leave();
      return;
   }
   set_error_flag(err, fabs(cx.xR[0] + 0.051137580) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:424");
   set_error_flag(err, fabs(cx.xR[1] + 0.011680985) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:425");
   set_error_flag(err, rlo != 0.0, __FILE__, __LINE__, "testfitsphereunit.ap:426");
   set_error_flag(err, fabs(rhi - 0.164365735) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:427");
   SetVector(&cx);
   rlo = 0.0;
   rhi = 0.0;
   fitspherex(&xy, xy.rows, xy.cols, 1, 0.0, 0, 0.0, &cx, &rlo, &rhi);
   set_error_flag(err, cx.cnt != 2, __FILE__, __LINE__, "testfitsphereunit.ap:432");
   if (*err) {
      ae_frame_leave();
      return;
   }
   set_error_flag(err, fabs(cx.xR[0] + 0.051137580) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:435");
   set_error_flag(err, fabs(cx.xR[1] + 0.011680985) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:436");
   set_error_flag(err, rlo != 0.0, __FILE__, __LINE__, "testfitsphereunit.ap:437");
   set_error_flag(err, fabs(rhi - 0.164365735) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:438");
// MI problem, NLC solver
   SetVector(&cx);
   rlo = 0.0;
   rhi = 0.0;
   fitspheremi(&xy, xy.rows, xy.cols, &cx, &rlo);
   set_error_flag(err, cx.cnt != 2, __FILE__, __LINE__, "testfitsphereunit.ap:447");
   if (*err) {
      ae_frame_leave();
      return;
   }
   set_error_flag(err, fabs(cx.xR[0] + 0.054593489) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:450");
   set_error_flag(err, fabs(cx.xR[1] + 0.007459466) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:451");
   set_error_flag(err, fabs(rlo - 0.152429205) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:452");
   set_error_flag(err, rhi != 0.0, __FILE__, __LINE__, "testfitsphereunit.ap:453");
   SetVector(&cx);
   rlo = 0.0;
   rhi = 0.0;
   fitspherex(&xy, xy.rows, xy.cols, 2, 0.0, 0, 0.0, &cx, &rlo, &rhi);
   set_error_flag(err, cx.cnt != 2, __FILE__, __LINE__, "testfitsphereunit.ap:458");
   if (*err) {
      ae_frame_leave();
      return;
   }
   set_error_flag(err, fabs(cx.xR[0] + 0.054593489) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:461");
   set_error_flag(err, fabs(cx.xR[1] + 0.007459466) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:462");
   set_error_flag(err, fabs(rlo - 0.152429205) > tol, __FILE__, __LINE__, "testfitsphereunit.ap:463");
   set_error_flag(err, rhi != 0.0, __FILE__, __LINE__, "testfitsphereunit.ap:464");
   ae_frame_leave();
}

bool testfitsphere(bool silent) {
   bool nserrors;
   bool lserrors;
   bool wereerrors;
   bool result;
   nserrors = false;
   lserrors = false;
// Sphere fitting, several different test suites
   testfitsphereunit_testspherefittingls(&lserrors);
   testfitsphereunit_testspherefittingns(&nserrors);
   testfitsphereunit_testspherefittingvosswinkel2(&nserrors);
// report
   wereerrors = nserrors || lserrors;
   if (!silent) {
      printf("TESTING FITSPHERE\n");
      printf("* LEAST SQUARES CIRCLE FITTING            ");
      if (lserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* NON-SMOOTH FITTING (MC, MI, MZ)         ");
      if (nserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (wereerrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !wereerrors;
   return result;
}

// === parametric testing unit ===
// This function tests 4PL/5PL fitting. On error sets FitErrors flag variable;
// on success - flag is not changed.
static void testparametricunit_testrdp(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t nsections;
   ae_int_t nsections3;
   double eps;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t d;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(e, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(x3, 0, DT_REAL);
   NewVector(y3, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewMatrix(xy3, 0, 0, DT_REAL);
   NewVector(idx2, 0, DT_INT);
   NewVector(idx3, 0, DT_INT);
   NewObj(spline1dinterpolant, s);
   hqrndrandomize(&rs);
// Parametric test 1: non-closed curve
   ae_matrix_set_length(&xy, 4, 2);
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = 0.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[1][1] = 2.0;
   xy.xyR[2][0] = 3.0;
   xy.xyR[2][1] = 1.0;
   xy.xyR[3][0] = 3.0;
   xy.xyR[3][1] = 3.0;
   parametricrdpfixed(&xy, 4, 2, 0, sqrt(2.0) + 0.001, &xy2, &idx2, &nsections);
   set_error_flag(errorflag, nsections != 1, __FILE__, __LINE__, "testparametricunit.ap:41");
   if (nsections == 1) {
      set_error_flag(errorflag, xy2.xyR[0][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:44");
      set_error_flag(errorflag, xy2.xyR[0][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:45");
      set_error_flag(errorflag, idx2.xZ[0] != 0, __FILE__, __LINE__, "testparametricunit.ap:46");
      set_error_flag(errorflag, xy2.xyR[1][0] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:47");
      set_error_flag(errorflag, xy2.xyR[1][1] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:48");
      set_error_flag(errorflag, idx2.xZ[1] != 3, __FILE__, __LINE__, "testparametricunit.ap:49");
   }
   parametricrdpfixed(&xy, 4, 2, 0, sqrt(2.0) - 0.001, &xy2, &idx2, &nsections);
   set_error_flag(errorflag, nsections != 3, __FILE__, __LINE__, "testparametricunit.ap:52");
   if (nsections == 3) {
      set_error_flag(errorflag, xy2.xyR[0][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:55");
      set_error_flag(errorflag, xy2.xyR[0][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:56");
      set_error_flag(errorflag, idx2.xZ[0] != 0, __FILE__, __LINE__, "testparametricunit.ap:57");
      set_error_flag(errorflag, xy2.xyR[1][0] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:58");
      set_error_flag(errorflag, xy2.xyR[1][1] != 2.0, __FILE__, __LINE__, "testparametricunit.ap:59");
      set_error_flag(errorflag, idx2.xZ[1] != 1, __FILE__, __LINE__, "testparametricunit.ap:60");
      set_error_flag(errorflag, xy2.xyR[2][0] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:61");
      set_error_flag(errorflag, xy2.xyR[2][1] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:62");
      set_error_flag(errorflag, idx2.xZ[2] != 2, __FILE__, __LINE__, "testparametricunit.ap:63");
      set_error_flag(errorflag, xy2.xyR[3][0] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:64");
      set_error_flag(errorflag, xy2.xyR[3][1] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:65");
      set_error_flag(errorflag, idx2.xZ[3] != 3, __FILE__, __LINE__, "testparametricunit.ap:66");
   }
   parametricrdpfixed(&xy, 4, 2, 1, 0.0, &xy2, &idx2, &nsections);
   set_error_flag(errorflag, nsections != 1, __FILE__, __LINE__, "testparametricunit.ap:69");
   if (nsections == 1) {
      set_error_flag(errorflag, xy2.xyR[0][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:72");
      set_error_flag(errorflag, xy2.xyR[0][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:73");
      set_error_flag(errorflag, idx2.xZ[0] != 0, __FILE__, __LINE__, "testparametricunit.ap:74");
      set_error_flag(errorflag, xy2.xyR[1][0] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:75");
      set_error_flag(errorflag, xy2.xyR[1][1] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:76");
      set_error_flag(errorflag, idx2.xZ[1] != 3, __FILE__, __LINE__, "testparametricunit.ap:77");
   }
   parametricrdpfixed(&xy, 4, 2, 2, 0.0, &xy2, &idx2, &nsections);
   set_error_flag(errorflag, nsections != 2, __FILE__, __LINE__, "testparametricunit.ap:80");
   if (nsections == 2) {
      set_error_flag(errorflag, xy2.xyR[0][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:83");
      set_error_flag(errorflag, xy2.xyR[0][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:84");
      set_error_flag(errorflag, idx2.xZ[0] != 0, __FILE__, __LINE__, "testparametricunit.ap:85");
      set_error_flag(errorflag, xy2.xyR[1][0] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:86");
      set_error_flag(errorflag, xy2.xyR[1][1] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:87");
      set_error_flag(errorflag, idx2.xZ[1] != 2, __FILE__, __LINE__, "testparametricunit.ap:88");
      set_error_flag(errorflag, xy2.xyR[2][0] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:89");
      set_error_flag(errorflag, xy2.xyR[2][1] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:90");
      set_error_flag(errorflag, idx2.xZ[2] != 3, __FILE__, __LINE__, "testparametricunit.ap:91");
   }
   parametricrdpfixed(&xy, 4, 2, 3, 0.0, &xy2, &idx2, &nsections);
   set_error_flag(errorflag, nsections != 3, __FILE__, __LINE__, "testparametricunit.ap:94");
   if (nsections == 3) {
      set_error_flag(errorflag, xy2.xyR[0][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:97");
      set_error_flag(errorflag, xy2.xyR[0][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:98");
      set_error_flag(errorflag, idx2.xZ[0] != 0, __FILE__, __LINE__, "testparametricunit.ap:99");
      set_error_flag(errorflag, xy2.xyR[1][0] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:100");
      set_error_flag(errorflag, xy2.xyR[1][1] != 2.0, __FILE__, __LINE__, "testparametricunit.ap:101");
      set_error_flag(errorflag, idx2.xZ[1] != 1, __FILE__, __LINE__, "testparametricunit.ap:102");
      set_error_flag(errorflag, xy2.xyR[2][0] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:103");
      set_error_flag(errorflag, xy2.xyR[2][1] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:104");
      set_error_flag(errorflag, idx2.xZ[2] != 2, __FILE__, __LINE__, "testparametricunit.ap:105");
      set_error_flag(errorflag, xy2.xyR[3][0] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:106");
      set_error_flag(errorflag, xy2.xyR[3][1] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:107");
      set_error_flag(errorflag, idx2.xZ[3] != 3, __FILE__, __LINE__, "testparametricunit.ap:108");
   }
   parametricrdpfixed(&xy, 4, 2, 4, 0.0, &xy2, &idx2, &nsections);
   set_error_flag(errorflag, nsections != 3, __FILE__, __LINE__, "testparametricunit.ap:111");
   if (nsections == 3) {
      set_error_flag(errorflag, xy2.xyR[0][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:114");
      set_error_flag(errorflag, xy2.xyR[0][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:115");
      set_error_flag(errorflag, idx2.xZ[0] != 0, __FILE__, __LINE__, "testparametricunit.ap:116");
      set_error_flag(errorflag, xy2.xyR[1][0] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:117");
      set_error_flag(errorflag, xy2.xyR[1][1] != 2.0, __FILE__, __LINE__, "testparametricunit.ap:118");
      set_error_flag(errorflag, idx2.xZ[1] != 1, __FILE__, __LINE__, "testparametricunit.ap:119");
      set_error_flag(errorflag, xy2.xyR[2][0] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:120");
      set_error_flag(errorflag, xy2.xyR[2][1] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:121");
      set_error_flag(errorflag, idx2.xZ[2] != 2, __FILE__, __LINE__, "testparametricunit.ap:122");
      set_error_flag(errorflag, xy2.xyR[3][0] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:123");
      set_error_flag(errorflag, xy2.xyR[3][1] != 3.0, __FILE__, __LINE__, "testparametricunit.ap:124");
      set_error_flag(errorflag, idx2.xZ[3] != 3, __FILE__, __LINE__, "testparametricunit.ap:125");
   }
// Parametric test 2: closed curve
   ae_matrix_set_length(&xy, 5, 2);
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = 0.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[1][1] = 0.0;
   xy.xyR[2][0] = 1.0;
   xy.xyR[2][1] = 1.0;
   xy.xyR[3][0] = 0.0;
   xy.xyR[3][1] = 1.0;
   xy.xyR[4][0] = 0.0;
   xy.xyR[4][1] = 0.0;
   parametricrdpfixed(&xy, 5, 2, 0, sqrt(2.0) + 0.001, &xy2, &idx2, &nsections);
   set_error_flag(errorflag, nsections != 1, __FILE__, __LINE__, "testparametricunit.ap:144");
   if (nsections == 1) {
      set_error_flag(errorflag, xy2.xyR[0][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:147");
      set_error_flag(errorflag, xy2.xyR[0][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:148");
      set_error_flag(errorflag, idx2.xZ[0] != 0, __FILE__, __LINE__, "testparametricunit.ap:149");
      set_error_flag(errorflag, xy2.xyR[1][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:150");
      set_error_flag(errorflag, xy2.xyR[1][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:151");
      set_error_flag(errorflag, idx2.xZ[1] != 4, __FILE__, __LINE__, "testparametricunit.ap:152");
   }
   parametricrdpfixed(&xy, 5, 2, 0, sqrt(2.0) - 0.001, &xy2, &idx2, &nsections);
   set_error_flag(errorflag, nsections != 2, __FILE__, __LINE__, "testparametricunit.ap:155");
   if (nsections == 2) {
      set_error_flag(errorflag, xy2.xyR[0][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:158");
      set_error_flag(errorflag, xy2.xyR[0][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:159");
      set_error_flag(errorflag, idx2.xZ[0] != 0, __FILE__, __LINE__, "testparametricunit.ap:160");
      set_error_flag(errorflag, xy2.xyR[1][0] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:161");
      set_error_flag(errorflag, xy2.xyR[1][1] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:162");
      set_error_flag(errorflag, idx2.xZ[1] != 2, __FILE__, __LINE__, "testparametricunit.ap:163");
      set_error_flag(errorflag, xy2.xyR[2][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:164");
      set_error_flag(errorflag, xy2.xyR[2][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:165");
      set_error_flag(errorflag, idx2.xZ[2] != 4, __FILE__, __LINE__, "testparametricunit.ap:166");
   }
   parametricrdpfixed(&xy, 5, 2, 0, sqrt(2.0) / 2 + 0.001, &xy2, &idx2, &nsections);
   set_error_flag(errorflag, nsections != 2, __FILE__, __LINE__, "testparametricunit.ap:169");
   if (nsections == 2) {
      set_error_flag(errorflag, xy2.xyR[0][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:172");
      set_error_flag(errorflag, xy2.xyR[0][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:173");
      set_error_flag(errorflag, idx2.xZ[0] != 0, __FILE__, __LINE__, "testparametricunit.ap:174");
      set_error_flag(errorflag, xy2.xyR[1][0] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:175");
      set_error_flag(errorflag, xy2.xyR[1][1] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:176");
      set_error_flag(errorflag, idx2.xZ[1] != 2, __FILE__, __LINE__, "testparametricunit.ap:177");
      set_error_flag(errorflag, xy2.xyR[2][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:178");
      set_error_flag(errorflag, xy2.xyR[2][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:179");
      set_error_flag(errorflag, idx2.xZ[2] != 4, __FILE__, __LINE__, "testparametricunit.ap:180");
   }
   parametricrdpfixed(&xy, 5, 2, 0, sqrt(2.0) / 2 - 0.001, &xy2, &idx2, &nsections);
   set_error_flag(errorflag, nsections != 4, __FILE__, __LINE__, "testparametricunit.ap:183");
   if (nsections == 4) {
      set_error_flag(errorflag, xy2.xyR[0][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:186");
      set_error_flag(errorflag, xy2.xyR[0][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:187");
      set_error_flag(errorflag, idx2.xZ[0] != 0, __FILE__, __LINE__, "testparametricunit.ap:188");
      set_error_flag(errorflag, xy2.xyR[1][0] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:189");
      set_error_flag(errorflag, xy2.xyR[1][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:190");
      set_error_flag(errorflag, idx2.xZ[1] != 1, __FILE__, __LINE__, "testparametricunit.ap:191");
      set_error_flag(errorflag, xy2.xyR[2][0] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:192");
      set_error_flag(errorflag, xy2.xyR[2][1] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:193");
      set_error_flag(errorflag, idx2.xZ[2] != 2, __FILE__, __LINE__, "testparametricunit.ap:194");
      set_error_flag(errorflag, xy2.xyR[3][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:195");
      set_error_flag(errorflag, xy2.xyR[3][1] != 1.0, __FILE__, __LINE__, "testparametricunit.ap:196");
      set_error_flag(errorflag, idx2.xZ[3] != 3, __FILE__, __LINE__, "testparametricunit.ap:197");
      set_error_flag(errorflag, xy2.xyR[4][0] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:198");
      set_error_flag(errorflag, xy2.xyR[4][1] != 0.0, __FILE__, __LINE__, "testparametricunit.ap:199");
      set_error_flag(errorflag, idx2.xZ[4] != 4, __FILE__, __LINE__, "testparametricunit.ap:200");
   }
// Parametric, variable precision test (non-fixed), results are compared against fixed-section test
   eps = 10.0;
   n = 100;
   while (eps >= 0.0001) {
   // Try different dimension counts
      for (d = 1; d <= 5; d++) {
      // Generate dataset
         ae_matrix_set_length(&xy, n, d);
         for (i = 0; i < n; i++) {
            v = pi * i / (n - 1);
            for (j = 0; j < d; j++) {
               xy.xyR[i][j] = pow(sin(v), (double)(j + 1)) + 0.01 * (hqrnduniformr(&rs) - 0.5);
            }
         }
      // Perform run of eps-based RDP algorithm
         parametricrdpfixed(&xy, n, d, 0, eps, &xy2, &idx2, &nsections);
         set_error_flag(errorflag, nsections == 0, __FILE__, __LINE__, "testparametricunit.ap:231");
         if (nsections == 0) {
            ae_frame_leave();
            return;
         }
      // Check properties
         set_error_flag(errorflag, idx2.xZ[0] != 0, __FILE__, __LINE__, "testparametricunit.ap:238");
         for (i = 0; i < nsections; i++) {
            set_error_flag(errorflag, idx2.xZ[i] >= idx2.xZ[i + 1], __FILE__, __LINE__, "testparametricunit.ap:240");
         }
         set_error_flag(errorflag, idx2.xZ[nsections] != n - 1, __FILE__, __LINE__, "testparametricunit.ap:241");
         for (i = 0; i <= nsections; i++) {
            for (j = 0; j < d; j++) {
               set_error_flag(errorflag, xy2.xyR[i][j] != xy.xyR[idx2.xZ[i]][j], __FILE__, __LINE__, "testparametricunit.ap:244");
            }
         }
         ae_vector_set_length(&x, nsections + 1);
         ae_vector_set_length(&y, nsections + 1);
         ae_vector_set_length(&e, n);
         for (i = 0; i < n; i++) {
            e.xR[i] = 0.0;
         }
         for (j = 0; j < d; j++) {
            for (i = 0; i <= nsections; i++) {
               x.xR[i] = (double)idx2.xZ[i];
               y.xR[i] = xy2.xyR[i][j];
            }
            spline1dbuildlinear(&x, &y, nsections + 1, &s);
            for (i = 0; i < n; i++) {
               e.xR[i] += sqr(spline1dcalc(&s, (double)i) - xy.xyR[i][j]);
            }
         }
         for (i = 0; i < n; i++) {
            set_error_flag(errorflag, sqrt(e.xR[i]) > eps, __FILE__, __LINE__, "testparametricunit.ap:262");
         }
      // compare results with values returned by section-based algorithm
         parametricrdpfixed(&xy, n, d, nsections, 0.0, &xy3, &idx3, &nsections3);
         set_error_flag(errorflag, nsections3 != nsections, __FILE__, __LINE__, "testparametricunit.ap:268");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i <= nsections; i++) {
            set_error_flag(errorflag, idx2.xZ[i] != idx3.xZ[i], __FILE__, __LINE__, "testparametricunit.ap:273");
            for (j = 0; j < d; j++) {
               set_error_flag(errorflag, fabs(xy2.xyR[i][j] - xy3.xyR[i][j]) > 1000 * machineepsilon, __FILE__, __LINE__, "testparametricunit.ap:275");
            }
         }
      }
   // Next epsilon
      eps *= 0.5;
   }
   ae_frame_leave();
}

// Unset spline, i.e. initialize it with random garbage
static void testparametricunit_unsetp2(pspline2interpolant *p) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   SetObj(pspline2interpolant, p);
   NewMatrix(xy, 0, 0, DT_REAL);
   ae_matrix_set_length(&xy, 2, 2);
   xy.xyR[0][0] = -1.0;
   xy.xyR[0][1] = -1.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[1][1] = 1.0;
   pspline2build(&xy, 2, 1, 0, p);
   ae_frame_leave();
}

// Unset spline, i.e. initialize it with random garbage
static void testparametricunit_unsetp3(pspline3interpolant *p) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   SetObj(pspline3interpolant, p);
   NewMatrix(xy, 0, 0, DT_REAL);
   ae_matrix_set_length(&xy, 2, 3);
   xy.xyR[0][0] = -1.0;
   xy.xyR[0][1] = -1.0;
   xy.xyR[0][2] = -1.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[1][1] = 1.0;
   xy.xyR[1][2] = 1.0;
   pspline3build(&xy, 2, 1, 0, p);
   ae_frame_leave();
}

bool testparametric(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   bool p2errors;
   bool p3errors;
   bool rdperrors;
   double nonstrictthreshold;
   double threshold;
   ae_int_t maxn;
   ae_int_t periodicity;
   ae_int_t skind;
   ae_int_t pkind;
   bool periodic;
   double a;
   double b;
   ae_int_t n;
   ae_int_t tmpn;
   ae_int_t i;
   double vx;
   double vy;
   double vz;
   double vx2;
   double vy2;
   double vz2;
   double vdx;
   double vdy;
   double vdz;
   double vdx2;
   double vdy2;
   double vdz2;
   double vd2x;
   double vd2y;
   double vd2z;
   double vd2x2;
   double vd2y2;
   double vd2z2;
   double v0;
   double v1;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(z, 0, DT_REAL);
   NewVector(t, 0, DT_REAL);
   NewVector(t2, 0, DT_REAL);
   NewVector(t3, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xyz, 0, 0, DT_REAL);
   NewObj(pspline2interpolant, p2);
   NewObj(pspline3interpolant, p3);
   NewObj(spline1dinterpolant, s);
   waserrors = false;
   maxn = 10;
   threshold = 10000 * machineepsilon;
   nonstrictthreshold = 0.00001;
   p2errors = false;
   p3errors = false;
   rdperrors = false;
   testparametricunit_testrdp(&rdperrors);
// Test basic properties of 2- and 3-dimensional splines:
// * PSpline2ParameterValues() properties
// * values at nodes
// * for periodic splines - periodicity properties
//
// Variables used:
// * N              points count
// * SKind          spline
// * PKind          parameterization
// * Periodicity    whether we have periodic spline or not
   for (n = 2; n <= maxn; n++) {
      for (skind = 0; skind <= 2; skind++) {
         for (pkind = 0; pkind <= 2; pkind++) {
            for (periodicity = 0; periodicity <= 1; periodicity++) {
               periodic = periodicity == 1;
            // skip unsupported combinations of parameters
               if (periodic && n < 3) {
                  continue;
               }
               if (periodic && skind == 0) {
                  continue;
               }
               if (n < 5 && skind == 0) {
                  continue;
               }
            // init
               ae_matrix_set_length(&xy, n, 2);
               ae_matrix_set_length(&xyz, n, 3);
               taskgenint1dequidist(-1.0, 1.0, n, &t2, &x);
               ae_v_move(xy.xyR[0], xy.stride, x.xR, 1, n);
               ae_v_move(xyz.xyR[0], xyz.stride, x.xR, 1, n);
               taskgenint1dequidist(-1.0, 1.0, n, &t2, &y);
               ae_v_move(&xy.xyR[0][1], xy.stride, y.xR, 1, n);
               ae_v_move(&xyz.xyR[0][1], xyz.stride, y.xR, 1, n);
               taskgenint1dequidist(-1.0, 1.0, n, &t2, &z);
               ae_v_move(&xyz.xyR[0][2], xyz.stride, z.xR, 1, n);
               testparametricunit_unsetp2(&p2);
               testparametricunit_unsetp3(&p3);
               if (periodic) {
                  pspline2buildperiodic(&xy, n, skind, pkind, &p2);
                  pspline3buildperiodic(&xyz, n, skind, pkind, &p3);
               } else {
                  pspline2build(&xy, n, skind, pkind, &p2);
                  pspline3build(&xyz, n, skind, pkind, &p3);
               }
            // PSpline2ParameterValues() properties
               pspline2parametervalues(&p2, &tmpn, &t2);
               if (tmpn != n) {
                  p2errors = true;
                  continue;
               }
               pspline3parametervalues(&p3, &tmpn, &t3);
               if (tmpn != n) {
                  p3errors = true;
                  continue;
               }
               p2errors = p2errors || t2.xR[0] != 0.0;
               p3errors = p3errors || t3.xR[0] != 0.0;
               for (i = 1; i < n; i++) {
                  p2errors = p2errors || t2.xR[i] <= t2.xR[i - 1];
                  p3errors = p3errors || t3.xR[i] <= t3.xR[i - 1];
               }
               if (periodic) {
                  p2errors = p2errors || t2.xR[n - 1] >= 1.0;
                  p3errors = p3errors || t3.xR[n - 1] >= 1.0;
               } else {
                  p2errors = p2errors || t2.xR[n - 1] != 1.0;
                  p3errors = p3errors || t3.xR[n - 1] != 1.0;
               }
            // Now we have parameter values stored at T,
            // and want to test whether the actully correspond to
            // points
               for (i = 0; i < n; i++) {
               // 2-dimensional test
                  pspline2calc(&p2, t2.xR[i], &vx, &vy);
                  p2errors = p2errors || fabs(vx - x.xR[i]) > threshold;
                  p2errors = p2errors || fabs(vy - y.xR[i]) > threshold;
               // 3-dimensional test
                  pspline3calc(&p3, t3.xR[i], &vx, &vy, &vz);
                  p3errors = p3errors || fabs(vx - x.xR[i]) > threshold;
                  p3errors = p3errors || fabs(vy - y.xR[i]) > threshold;
                  p3errors = p3errors || fabs(vz - z.xR[i]) > threshold;
               }
            // Test periodicity (if needed)
               if (periodic) {
               // periodicity at nodes
                  for (i = 0; i < n; i++) {
                  // 2-dimensional test
                     pspline2calc(&p2, t2.xR[i] + randominteger(10) - 5, &vx, &vy);
                     p2errors = p2errors || fabs(vx - x.xR[i]) > threshold;
                     p2errors = p2errors || fabs(vy - y.xR[i]) > threshold;
                     pspline2diff(&p2, t2.xR[i] + randominteger(10) - 5, &vx, &vdx, &vy, &vdy);
                     p2errors = p2errors || fabs(vx - x.xR[i]) > threshold;
                     p2errors = p2errors || fabs(vy - y.xR[i]) > threshold;
                     pspline2diff2(&p2, t2.xR[i] + randominteger(10) - 5, &vx, &vdx, &vd2x, &vy, &vdy, &vd2y);
                     p2errors = p2errors || fabs(vx - x.xR[i]) > threshold;
                     p2errors = p2errors || fabs(vy - y.xR[i]) > threshold;
                  // 3-dimensional test
                     pspline3calc(&p3, t3.xR[i] + randominteger(10) - 5, &vx, &vy, &vz);
                     p3errors = p3errors || fabs(vx - x.xR[i]) > threshold;
                     p3errors = p3errors || fabs(vy - y.xR[i]) > threshold;
                     p3errors = p3errors || fabs(vz - z.xR[i]) > threshold;
                     pspline3diff(&p3, t3.xR[i] + randominteger(10) - 5, &vx, &vdx, &vy, &vdy, &vz, &vdz);
                     p3errors = p3errors || fabs(vx - x.xR[i]) > threshold;
                     p3errors = p3errors || fabs(vy - y.xR[i]) > threshold;
                     p3errors = p3errors || fabs(vz - z.xR[i]) > threshold;
                     pspline3diff2(&p3, t3.xR[i] + randominteger(10) - 5, &vx, &vdx, &vd2x, &vy, &vdy, &vd2y, &vz, &vdz, &vd2z);
                     p3errors = p3errors || fabs(vx - x.xR[i]) > threshold;
                     p3errors = p3errors || fabs(vy - y.xR[i]) > threshold;
                     p3errors = p3errors || fabs(vz - z.xR[i]) > threshold;
                  }
               // periodicity between nodes
                  v0 = randomreal();
                  pspline2calc(&p2, v0, &vx, &vy);
                  pspline2calc(&p2, v0 + randominteger(10) - 5, &vx2, &vy2);
                  p2errors = p2errors || fabs(vx - vx2) > threshold;
                  p2errors = p2errors || fabs(vy - vy2) > threshold;
                  pspline3calc(&p3, v0, &vx, &vy, &vz);
                  pspline3calc(&p3, v0 + randominteger(10) - 5, &vx2, &vy2, &vz2);
                  p3errors = p3errors || fabs(vx - vx2) > threshold;
                  p3errors = p3errors || fabs(vy - vy2) > threshold;
                  p3errors = p3errors || fabs(vz - vz2) > threshold;
               // near-boundary test for continuity of function values and derivatives:
               // 2-dimensional curve
                  ae_assert(skind == 1 || skind == 2, "TEST: unexpected spline type!");
                  v0 = 100 * machineepsilon;
                  v1 = 1 - v0;
                  pspline2calc(&p2, v0, &vx, &vy);
                  pspline2calc(&p2, v1, &vx2, &vy2);
                  p2errors = p2errors || fabs(vx - vx2) > threshold;
                  p2errors = p2errors || fabs(vy - vy2) > threshold;
                  pspline2diff(&p2, v0, &vx, &vdx, &vy, &vdy);
                  pspline2diff(&p2, v1, &vx2, &vdx2, &vy2, &vdy2);
                  p2errors = p2errors || fabs(vx - vx2) > threshold;
                  p2errors = p2errors || fabs(vy - vy2) > threshold;
                  p2errors = p2errors || fabs(vdx - vdx2) > nonstrictthreshold;
                  p2errors = p2errors || fabs(vdy - vdy2) > nonstrictthreshold;
                  pspline2diff2(&p2, v0, &vx, &vdx, &vd2x, &vy, &vdy, &vd2y);
                  pspline2diff2(&p2, v1, &vx2, &vdx2, &vd2x2, &vy2, &vdy2, &vd2y2);
                  p2errors = p2errors || fabs(vx - vx2) > threshold;
                  p2errors = p2errors || fabs(vy - vy2) > threshold;
                  p2errors = p2errors || fabs(vdx - vdx2) > nonstrictthreshold;
                  p2errors = p2errors || fabs(vdy - vdy2) > nonstrictthreshold;
                  if (skind == 2) {
                  // second derivative test only for cubic splines
                     p2errors = p2errors || fabs(vd2x - vd2x2) > nonstrictthreshold;
                     p2errors = p2errors || fabs(vd2y - vd2y2) > nonstrictthreshold;
                  }
               // near-boundary test for continuity of function values and derivatives:
               // 3-dimensional curve
                  ae_assert(skind == 1 || skind == 2, "TEST: unexpected spline type!");
                  v0 = 100 * machineepsilon;
                  v1 = 1 - v0;
                  pspline3calc(&p3, v0, &vx, &vy, &vz);
                  pspline3calc(&p3, v1, &vx2, &vy2, &vz2);
                  p3errors = p3errors || fabs(vx - vx2) > threshold;
                  p3errors = p3errors || fabs(vy - vy2) > threshold;
                  p3errors = p3errors || fabs(vz - vz2) > threshold;
                  pspline3diff(&p3, v0, &vx, &vdx, &vy, &vdy, &vz, &vdz);
                  pspline3diff(&p3, v1, &vx2, &vdx2, &vy2, &vdy2, &vz2, &vdz2);
                  p3errors = p3errors || fabs(vx - vx2) > threshold;
                  p3errors = p3errors || fabs(vy - vy2) > threshold;
                  p3errors = p3errors || fabs(vz - vz2) > threshold;
                  p3errors = p3errors || fabs(vdx - vdx2) > nonstrictthreshold;
                  p3errors = p3errors || fabs(vdy - vdy2) > nonstrictthreshold;
                  p3errors = p3errors || fabs(vdz - vdz2) > nonstrictthreshold;
                  pspline3diff2(&p3, v0, &vx, &vdx, &vd2x, &vy, &vdy, &vd2y, &vz, &vdz, &vd2z);
                  pspline3diff2(&p3, v1, &vx2, &vdx2, &vd2x2, &vy2, &vdy2, &vd2y2, &vz2, &vdz2, &vd2z2);
                  p3errors = p3errors || fabs(vx - vx2) > threshold;
                  p3errors = p3errors || fabs(vy - vy2) > threshold;
                  p3errors = p3errors || fabs(vz - vz2) > threshold;
                  p3errors = p3errors || fabs(vdx - vdx2) > nonstrictthreshold;
                  p3errors = p3errors || fabs(vdy - vdy2) > nonstrictthreshold;
                  p3errors = p3errors || fabs(vdz - vdz2) > nonstrictthreshold;
                  if (skind == 2) {
                  // second derivative test only for cubic splines
                     p3errors = p3errors || fabs(vd2x - vd2x2) > nonstrictthreshold;
                     p3errors = p3errors || fabs(vd2y - vd2y2) > nonstrictthreshold;
                     p3errors = p3errors || fabs(vd2z - vd2z2) > nonstrictthreshold;
                  }
               }
            }
         }
      }
   }
// Test differentiation, tangents, calculation between nodes.
//
// Because differentiation is done in parameterization/spline/periodicity
// oblivious manner, we don't have to test all possible combinations
// of spline types and parameterizations.
//
// Actually we test special combination with properties which allow us
// to easily solve this problem:
// * 2 (3) variables
// * first variable is sampled from equidistant grid on [0,1]
// * other variables are random
// * uniform parameterization is used
// * periodicity - none
// * spline type - any (we use cubic splines)
// Same problem allows us to test calculation BETWEEN nodes.
   for (n = 2; n <= maxn; n++) {
   // init
      ae_matrix_set_length(&xy, n, 2);
      ae_matrix_set_length(&xyz, n, 3);
      taskgenint1dequidist(0.0, 1.0, n, &t, &x);
      ae_v_move(xy.xyR[0], xy.stride, x.xR, 1, n);
      ae_v_move(xyz.xyR[0], xyz.stride, x.xR, 1, n);
      taskgenint1dequidist(0.0, 1.0, n, &t, &y);
      ae_v_move(&xy.xyR[0][1], xy.stride, y.xR, 1, n);
      ae_v_move(&xyz.xyR[0][1], xyz.stride, y.xR, 1, n);
      taskgenint1dequidist(0.0, 1.0, n, &t, &z);
      ae_v_move(&xyz.xyR[0][2], xyz.stride, z.xR, 1, n);
      testparametricunit_unsetp2(&p2);
      testparametricunit_unsetp3(&p3);
      pspline2build(&xy, n, 2, 0, &p2);
      pspline3build(&xyz, n, 2, 0, &p3);
   // Test 2D/3D spline:
   // * build non-parametric cubic spline from T and X/Y
   // * calculate its value and derivatives at V0
   // * compare with Spline2Calc/Spline2Diff/Spline2Diff2
   // Because of task properties both variants should
   // return same answer.
      v0 = randomreal();
      spline1dbuildcubic(&t, &x, n, 0, 0.0, 0, 0.0, &s);
      spline1ddiff(&s, v0, &vx2, &vdx2, &vd2x2);
      spline1dbuildcubic(&t, &y, n, 0, 0.0, 0, 0.0, &s);
      spline1ddiff(&s, v0, &vy2, &vdy2, &vd2y2);
      spline1dbuildcubic(&t, &z, n, 0, 0.0, 0, 0.0, &s);
      spline1ddiff(&s, v0, &vz2, &vdz2, &vd2z2);
   // 2D test
      pspline2calc(&p2, v0, &vx, &vy);
      p2errors = p2errors || fabs(vx - vx2) > threshold;
      p2errors = p2errors || fabs(vy - vy2) > threshold;
      pspline2diff(&p2, v0, &vx, &vdx, &vy, &vdy);
      p2errors = p2errors || fabs(vx - vx2) > threshold;
      p2errors = p2errors || fabs(vy - vy2) > threshold;
      p2errors = p2errors || fabs(vdx - vdx2) > threshold;
      p2errors = p2errors || fabs(vdy - vdy2) > threshold;
      pspline2diff2(&p2, v0, &vx, &vdx, &vd2x, &vy, &vdy, &vd2y);
      p2errors = p2errors || fabs(vx - vx2) > threshold;
      p2errors = p2errors || fabs(vy - vy2) > threshold;
      p2errors = p2errors || fabs(vdx - vdx2) > threshold;
      p2errors = p2errors || fabs(vdy - vdy2) > threshold;
      p2errors = p2errors || fabs(vd2x - vd2x2) > threshold;
      p2errors = p2errors || fabs(vd2y - vd2y2) > threshold;
   // 3D test
      pspline3calc(&p3, v0, &vx, &vy, &vz);
      p3errors = p3errors || fabs(vx - vx2) > threshold;
      p3errors = p3errors || fabs(vy - vy2) > threshold;
      p3errors = p3errors || fabs(vz - vz2) > threshold;
      pspline3diff(&p3, v0, &vx, &vdx, &vy, &vdy, &vz, &vdz);
      p3errors = p3errors || fabs(vx - vx2) > threshold;
      p3errors = p3errors || fabs(vy - vy2) > threshold;
      p3errors = p3errors || fabs(vz - vz2) > threshold;
      p3errors = p3errors || fabs(vdx - vdx2) > threshold;
      p3errors = p3errors || fabs(vdy - vdy2) > threshold;
      p3errors = p3errors || fabs(vdz - vdz2) > threshold;
      pspline3diff2(&p3, v0, &vx, &vdx, &vd2x, &vy, &vdy, &vd2y, &vz, &vdz, &vd2z);
      p3errors = p3errors || fabs(vx - vx2) > threshold;
      p3errors = p3errors || fabs(vy - vy2) > threshold;
      p3errors = p3errors || fabs(vz - vz2) > threshold;
      p3errors = p3errors || fabs(vdx - vdx2) > threshold;
      p3errors = p3errors || fabs(vdy - vdy2) > threshold;
      p3errors = p3errors || fabs(vdz - vdz2) > threshold;
      p3errors = p3errors || fabs(vd2x - vd2x2) > threshold;
      p3errors = p3errors || fabs(vd2y - vd2y2) > threshold;
      p3errors = p3errors || fabs(vd2z - vd2z2) > threshold;
   // Test tangents for 2D/3D
      pspline2tangent(&p2, v0, &vx, &vy);
      p2errors = p2errors || fabs(vx - vdx2 / safepythag2(vdx2, vdy2)) > threshold;
      p2errors = p2errors || fabs(vy - vdy2 / safepythag2(vdx2, vdy2)) > threshold;
      pspline3tangent(&p3, v0, &vx, &vy, &vz);
      p3errors = p3errors || fabs(vx - vdx2 / safepythag3(vdx2, vdy2, vdz2)) > threshold;
      p3errors = p3errors || fabs(vy - vdy2 / safepythag3(vdx2, vdy2, vdz2)) > threshold;
      p3errors = p3errors || fabs(vz - vdz2 / safepythag3(vdx2, vdy2, vdz2)) > threshold;
   }
// Arc length test.
//
// Simple problem with easy solution (points on a straight line with
// uniform parameterization).
   for (n = 2; n <= maxn; n++) {
      ae_matrix_set_length(&xy, n, 2);
      ae_matrix_set_length(&xyz, n, 3);
      for (i = 0; i < n; i++) {
         xy.xyR[i][0] = (double)i;
         xy.xyR[i][1] = (double)i;
         xyz.xyR[i][0] = (double)i;
         xyz.xyR[i][1] = (double)i;
         xyz.xyR[i][2] = (double)i;
      }
      pspline2build(&xy, n, 1, 0, &p2);
      pspline3build(&xyz, n, 1, 0, &p3);
      a = randomreal();
      b = randomreal();
      p2errors = p2errors || fabs(pspline2arclength(&p2, a, b) - (b - a) * sqrt(2.0) * (n - 1)) > nonstrictthreshold;
      p3errors = p3errors || fabs(pspline3arclength(&p3, a, b) - (b - a) * sqrt(3.0) * (n - 1)) > nonstrictthreshold;
   }
// report
   waserrors = (p2errors || p3errors) || rdperrors;
   if (!silent) {
      printf("TESTING PARAMETRIC INTERPOLATION\n");
   // Normal tests
      printf("2D SPLINES:                              ");
      if (p2errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("3D SPLINES:                              ");
      if (p3errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("RDP:                                     ");
      if (rdperrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
// end
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === spline2d testing unit ===
// Numerical differentiation.
static void testspline2dunit_twodnumder(spline2dinterpolant *c, double x, double y, double h, double *f, double *fx, double *fy, double *fxy) {
   *f = 0;
   *fx = 0;
   *fy = 0;
   *fxy = 0;
   *f = spline2dcalc(c, x, y);
   *fx = (spline2dcalc(c, x + h, y) - spline2dcalc(c, x - h, y)) / (2 * h);
   *fy = (spline2dcalc(c, x, y + h) - spline2dcalc(c, x, y - h)) / (2 * h);
   *fxy = (spline2dcalc(c, x + h, y + h) - spline2dcalc(c, x - h, y + h) - spline2dcalc(c, x + h, y - h) + spline2dcalc(c, x - h, y - h)) / sqr(2 * h);
}

// Lipschitz constants for spline inself, first and second derivatives.
static void testspline2dunit_lconst(spline2dinterpolant *c, RVector *lx, RVector *ly, ae_int_t m, ae_int_t n, double lstep, double *lc, double *lcx, double *lcy, double *lcxy) {
   ae_int_t i;
   ae_int_t j;
   double f1;
   double f2;
   double f3;
   double f4;
   double fx1;
   double fx2;
   double fx3;
   double fx4;
   double fy1;
   double fy2;
   double fy3;
   double fy4;
   double fxy1;
   double fxy2;
   double fxy3;
   double fxy4;
   double s2lstep;
   *lc = 0;
   *lcx = 0;
   *lcy = 0;
   *lcxy = 0;
   *lc = 0.0;
   *lcx = 0.0;
   *lcy = 0.0;
   *lcxy = 0.0;
   s2lstep = sqrt(2.0) * lstep;
   for (i = 0; i < m; i++) {
      for (j = 0; j < n; j++) {
      // Calculate
         testspline2dunit_twodnumder(c, lx->xR[j] - lstep / 2, ly->xR[i] - lstep / 2, lstep / 4, &f1, &fx1, &fy1, &fxy1);
         testspline2dunit_twodnumder(c, lx->xR[j] + lstep / 2, ly->xR[i] - lstep / 2, lstep / 4, &f2, &fx2, &fy2, &fxy2);
         testspline2dunit_twodnumder(c, lx->xR[j] + lstep / 2, ly->xR[i] + lstep / 2, lstep / 4, &f3, &fx3, &fy3, &fxy3);
         testspline2dunit_twodnumder(c, lx->xR[j] - lstep / 2, ly->xR[i] + lstep / 2, lstep / 4, &f4, &fx4, &fy4, &fxy4);
      // Lipschitz constant for the function itself
         *lc = rmax2(*lc, fabs((f1 - f2) / lstep));
         *lc = rmax2(*lc, fabs((f2 - f3) / lstep));
         *lc = rmax2(*lc, fabs((f3 - f4) / lstep));
         *lc = rmax2(*lc, fabs((f4 - f1) / lstep));
         *lc = rmax2(*lc, fabs((f1 - f3) / s2lstep));
         *lc = rmax2(*lc, fabs((f2 - f4) / s2lstep));
      // Lipschitz constant for the first derivative
         *lcx = rmax2(*lcx, fabs((fx1 - fx2) / lstep));
         *lcx = rmax2(*lcx, fabs((fx2 - fx3) / lstep));
         *lcx = rmax2(*lcx, fabs((fx3 - fx4) / lstep));
         *lcx = rmax2(*lcx, fabs((fx4 - fx1) / lstep));
         *lcx = rmax2(*lcx, fabs((fx1 - fx3) / s2lstep));
         *lcx = rmax2(*lcx, fabs((fx2 - fx4) / s2lstep));
      // Lipschitz constant for the first derivative
         *lcy = rmax2(*lcy, fabs((fy1 - fy2) / lstep));
         *lcy = rmax2(*lcy, fabs((fy2 - fy3) / lstep));
         *lcy = rmax2(*lcy, fabs((fy3 - fy4) / lstep));
         *lcy = rmax2(*lcy, fabs((fy4 - fy1) / lstep));
         *lcy = rmax2(*lcy, fabs((fy1 - fy3) / s2lstep));
         *lcy = rmax2(*lcy, fabs((fy2 - fy4) / s2lstep));
      // Lipschitz constant for the cross-derivative
         *lcxy = rmax2(*lcxy, fabs((fxy1 - fxy2) / lstep));
         *lcxy = rmax2(*lcxy, fabs((fxy2 - fxy3) / lstep));
         *lcxy = rmax2(*lcxy, fabs((fxy3 - fxy4) / lstep));
         *lcxy = rmax2(*lcxy, fabs((fxy4 - fxy1) / lstep));
         *lcxy = rmax2(*lcxy, fabs((fxy1 - fxy3) / s2lstep));
         *lcxy = rmax2(*lcxy, fabs((fxy2 - fxy4) / s2lstep));
      }
   }
}

// Unpack test
static bool testspline2dunit_testunpack(spline2dinterpolant *c, RVector *lx, RVector *ly) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t n;
   ae_int_t m;
   ae_int_t ci;
   ae_int_t cj;
   ae_int_t p;
   double err;
   double tx;
   double ty;
   double v1;
   double v2;
   ae_int_t pass;
   ae_int_t passcount;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(tbl, 0, 0, DT_REAL);
   passcount = 20;
   err = 0.0;
   spline2dunpack(c, &m, &n, &tbl);
   for (i = 0; i < m - 1; i++) {
      for (j = 0; j < n - 1; j++) {
         for (pass = 1; pass <= passcount; pass++) {
            p = (n - 1) * i + j;
            tx = (0.001 + 0.999 * randomreal()) * (tbl.xyR[p][1] - tbl.xyR[p][0]);
            ty = (0.001 + 0.999 * randomreal()) * (tbl.xyR[p][3] - tbl.xyR[p][2]);
         // Interpolation properties
            v1 = 0.0;
            for (ci = 0; ci <= 3; ci++) {
               for (cj = 0; cj <= 3; cj++) {
                  v1 += tbl.xyR[p][4 + ci * 4 + cj] * pow(tx, (double)ci) * pow(ty, (double)cj);
               }
            }
            v2 = spline2dcalc(c, tbl.xyR[p][0] + tx, tbl.xyR[p][2] + ty);
            err = rmax2(err, fabs(v1 - v2));
         // Grid correctness
            err = rmax2(err, fabs(lx->xR[2 * j] - tbl.xyR[p][0]));
            err = rmax2(err, fabs(lx->xR[2 * (j + 1)] - tbl.xyR[p][1]));
            err = rmax2(err, fabs(ly->xR[2 * i] - tbl.xyR[p][2]));
            err = rmax2(err, fabs(ly->xR[2 * (i + 1)] - tbl.xyR[p][3]));
         }
      }
   }
   result = err < 10000 * machineepsilon;
   ae_frame_leave();
   return result;
}

// LinTrans test for scalar
static bool testspline2dunit_testlintrans(spline2dinterpolant *c, ae_int_t d, double ax, double bx, double ay, double by) {
   ae_frame _frame_block;
   double err;
   double a1;
   double a2;
   double b1;
   double b2;
   double tx;
   double ty;
   double vx;
   double vy;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t xjob;
   ae_int_t yjob;
   ae_int_t di;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(v1, 0, DT_REAL);
   NewVector(v2, 0, DT_REAL);
   NewObj(spline2dinterpolant, c2);
   passcount = 5;
   err = 0.0;
   for (xjob = 0; xjob <= 1; xjob++) {
      for (yjob = 0; yjob <= 1; yjob++) {
         for (pass = 1; pass <= passcount; pass++) {
         // Prepare
            do {
               a1 = randommid();
            } while (a1 == 0.0);
            a1 *= xjob;
            b1 = randommid();
            do {
               a2 = randommid();
            } while (a2 == 0.0);
            a2 *= yjob;
            b2 = randommid();
         // Test XY
            spline2dcopy(c, &c2);
            spline2dlintransxy(&c2, a1, b1, a2, b2);
            tx = ax + randomreal() * (bx - ax);
            ty = ay + randomreal() * (by - ay);
            if (xjob == 0) {
               tx = b1;
               vx = ax + randomreal() * (bx - ax);
            } else {
               vx = (tx - b1) / a1;
            }
            if (yjob == 0) {
               ty = b2;
               vy = ay + randomreal() * (by - ay);
            } else {
               vy = (ty - b2) / a2;
            }
            spline2dcalcv(c, tx, ty, &v1);
            spline2dcalcv(&c2, vx, vy, &v2);
            for (di = 0; di < d; di++) {
               err = rmax2(err, fabs(v1.xR[di] - v2.xR[di]));
            }
         // Test F
            spline2dcopy(c, &c2);
            spline2dlintransf(&c2, a1, b1);
            tx = ax + randomreal() * (bx - ax);
            ty = ay + randomreal() * (by - ay);
            spline2dcalcv(c, tx, ty, &v1);
            spline2dcalcv(&c2, tx, ty, &v2);
            for (di = 0; di < d; di++) {
               err = rmax2(err, fabs(a1 * v1.xR[di] + b1 - v2.xR[di]));
            }
         }
      }
   }
   result = err < 10000 * machineepsilon;
   ae_frame_leave();
   return result;
}

// Unset spline, i.e. initialize it with random garbage
static void testspline2dunit_unsetspline2d(spline2dinterpolant *c) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   SetObj(spline2dinterpolant, c);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(f, 0, 0, DT_REAL);
   ae_vector_set_length(&x, 2);
   ae_vector_set_length(&y, 2);
   ae_matrix_set_length(&f, 2, 2);
   x.xR[0] = -1.0;
   x.xR[1] = 1.0;
   y.xR[0] = -1.0;
   y.xR[1] = 1.0;
   f.xyR[0][0] = 0.0;
   f.xyR[0][1] = 0.0;
   f.xyR[1][0] = 0.0;
   f.xyR[1][1] = 0.0;
   spline2dbuildbilinear(&x, &y, &f, 2, 2, c);
   ae_frame_leave();
}

// The function check, that follow functions works correctly:
//     Spline2DBilinearV, Spline2DBicubicV, Spline2DCalcV, Spline2DCalcVI,
//     Spline2DDiffVI and Spline2DUnpackV.
static bool testspline2dunit_testspline2dvf(bool silent) {
   ae_frame _frame_block;
   double range;
   double rndx;
   double rndy;
   double resef;
   ae_int_t m;
   ae_int_t n;
   ae_int_t d;
   ae_int_t tstn;
   ae_int_t tstm;
   ae_int_t tstd;
   double eps;
   double st;
   ae_int_t p0;
   ae_int_t p1;
   ae_int_t variant;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t i0;
   ae_int_t j0;
   double xmin;
   double xmax;
   double ymin;
   double ymax;
   double vi;
   double vxi;
   double vyi;
   double vxyi;
   double si;
   double sxi;
   double syi;
   double sxyi;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(spline2dinterpolant, vc);
   NewObj(spline2dinterpolant, sc);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(f, 0, DT_REAL);
   NewVector(resf, 0, DT_REAL);
   NewMatrix(ef, 0, 0, DT_REAL);
   NewMatrix(tsttbl0, 0, 0, DT_REAL);
   NewMatrix(tsttbl1, 0, 0, DT_REAL);
   eps = 10000.0 * machineepsilon;
   st = 0.1;
   passcount = 5;
   result = false;
   for (pass = 1; pass <= passcount; pass++) {
      for (variant = 1; variant <= 2; variant++) {
         range = (double)(randominteger(71) + 30);
         m = randominteger(4) + 2;
         n = randominteger(4) + 2;
         d = randominteger(3) + 1;
         vectorsetlengthatleast(&x, n);
         vectorsetlengthatleast(&y, m);
         vectorsetlengthatleast(&f, n * m * d);
         matrixsetlengthatleast(&ef, m, n);
      // Build a grid for spline
         x.xR[0] = range * randommid();
         y.xR[0] = range * randommid();
         for (i = 1; i < n; i++) {
            x.xR[i] = x.xR[i - 1] + st + randomreal();
         }
         for (i = 1; i < m; i++) {
            y.xR[i] = y.xR[i - 1] + st + randomreal();
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
               for (k = 0; k < d; k++) {
                  f.xR[d * (n * j + i) + k] = range * randommid();
               }
            }
         }
         xmin = x.xR[0];
         xmax = x.xR[n - 1];
         ymin = y.xR[0];
         ymax = y.xR[m - 1];
      // Build a spline
         if (variant == 1) {
            spline2dbuildbilinearv(&x, n, &y, m, &f, d, &vc);
         }
         if (variant == 2) {
            spline2dbuildbicubicv(&x, n, &y, m, &f, d, &vc);
         }
      // Part of test, which shows that Spline2DBuildBilinearV function
      // works correctly.
      // And there is test for Spline2DUnpackV.
         spline2dunpackv(&vc, &tstm, &tstn, &tstd, &tsttbl1);
         if ((tstm != m || tstn != n) || tstd != d) {
            if (!silent) {
               printf("TestSpline2DVF fail Spline2DUnpack:\n");
               printf("    TstM=%0d; M=%0d;\n    TstN=%0d; N=%0d;\n    TstD=%0d; D=%0d.\n", (int)tstm, (int)m, (int)tstn, (int)n, (int)tstd, (int)d);
            }
            result = true;
            ae_frame_leave();
            return result;
         }
         for (k = 0; k < d; k++) {
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  ef.xyR[i][j] = f.xR[d * (i * n + j) + k];
               }
            }
            if (variant == 1) {
               spline2dbuildbilinear(&x, &y, &ef, m, n, &sc);
            }
            if (variant == 2) {
               spline2dbuildbicubic(&x, &y, &ef, m, n, &sc);
            }
            spline2dunpack(&sc, &tstm, &tstn, &tsttbl0);
            if (tstm != m || tstn != n) {
               if (!silent) {
                  printf("TestSpline2DVF fail Spline2DUnpack:\n");
                  printf("    TstM=%0d; M=%0d;\n    TstN=%0d; N=%0d.\n", (int)tstm, (int)m, (int)tstn, (int)n);
               }
               result = true;
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < m - 1; i++) {
               for (j = 0; j < n - 1; j++) {
                  p0 = i * (n - 1) + j;
                  p1 = d * p0;
                  for (i0 = 0; i0 <= 19; i0++) {
                     if (tsttbl1.xyR[p1 + k][i0] != tsttbl0.xyR[p0][i0]) {
                        if (!silent) {
                           printf("TestSpline2DVF: Tbl error\n");
                        }
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  }
               }
            }
         }
      // Part of test, which shows that functions Spline2DCalcVBuf, Spline2DDiffVI,
      // Spline2DCalcVI and Spline2DCalcV work correctly
         for (k = 0; k < d; k++) {
         // Build 1D spline corresponding to selected dimension (already tested)
            for (i0 = 0; i0 < m; i0++) {
               for (j0 = 0; j0 < n; j0++) {
                  ef.xyR[i0][j0] = f.xR[d * (i0 * n + j0) + k];
               }
            }
            if (variant == 1) {
               spline2dbuildbilinear(&x, &y, &ef, m, n, &sc);
            }
            if (variant == 2) {
               spline2dbuildbicubic(&x, &y, &ef, m, n, &sc);
            }
         // test at grid points
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
               // Test calculation at grid points
                  spline2dcalcv(&vc, x.xR[i], y.xR[j], &resf);
                  resef = spline2dcalc(&sc, x.xR[i], y.xR[j]);
                  set_error_flag(&result, fabs(resf.xR[k] - resef) > eps, __FILE__, __LINE__, "testspline2dunit.ap:914");
                  set_error_flag(&result, fabs(spline2dcalcvi(&vc, x.xR[i], y.xR[j], k) - resef) > eps, __FILE__, __LINE__, "testspline2dunit.ap:915");
               // Test differentiation at grid points
                  spline2ddiffvi(&vc, x.xR[i], y.xR[j], k, &vi, &vxi, &vyi, &vxyi);
                  spline2ddiff(&sc, x.xR[i], y.xR[j], &si, &sxi, &syi, &sxyi);
                  set_error_flag(&result, fabs(vi - si) > eps * (fabs(si) + 1), __FILE__, __LINE__, "testspline2dunit.ap:922");
                  set_error_flag(&result, fabs(vxi - sxi) > eps * (fabs(sxi) + 1), __FILE__, __LINE__, "testspline2dunit.ap:923");
                  set_error_flag(&result, fabs(vyi - syi) > eps * (fabs(syi) + 1), __FILE__, __LINE__, "testspline2dunit.ap:924");
                  set_error_flag(&result, fabs(vxyi - sxyi) > eps * (fabs(sxyi) + 1), __FILE__, __LINE__, "testspline2dunit.ap:925");
               }
            }
         // Test at random points
            for (i = 0; i < n * m; i++) {
               rndx = xmin + (xmax - xmin) * randomreal();
               rndy = ymin + (ymax - ymin) * randomreal();
            // Test calculation at random points
               spline2dcalcv(&vc, rndx, rndy, &resf);
               resef = spline2dcalc(&sc, rndx, rndy);
               set_error_flag(&result, fabs(resf.xR[k] - resef) > eps, __FILE__, __LINE__, "testspline2dunit.ap:941");
               set_error_flag(&result, fabs(spline2dcalcvi(&vc, rndx, rndy, k) - resef) > eps, __FILE__, __LINE__, "testspline2dunit.ap:942");
            // Test differentiation at random points
               spline2ddiffvi(&vc, rndx, rndy, k, &vi, &vxi, &vyi, &vxyi);
               spline2ddiff(&sc, rndx, rndy, &si, &sxi, &syi, &sxyi);
               set_error_flag(&result, fabs(vi - si) > eps * (fabs(si) + 1), __FILE__, __LINE__, "testspline2dunit.ap:949");
               set_error_flag(&result, fabs(vxi - sxi) > eps * (fabs(sxi) + 1), __FILE__, __LINE__, "testspline2dunit.ap:950");
               set_error_flag(&result, fabs(vyi - syi) > eps * (fabs(syi) + 1), __FILE__, __LINE__, "testspline2dunit.ap:951");
               set_error_flag(&result, fabs(vxyi - sxyi) > eps * (fabs(sxyi) + 1), __FILE__, __LINE__, "testspline2dunit.ap:952");
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Fitting, properties of linear prior term
static void testspline2dunit_testfittingprior(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t d;
   ae_int_t kidx;
   ae_int_t areatype;
   ae_int_t solvertype;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double tol;
   ae_int_t kx;
   ae_int_t ky;
   ae_int_t npoints;
   double vprior;
   double v;
   bool bad;
   ae_frame_make(&_frame_block);
   NewVector(kv, 0, DT_INT);
   NewObj(hqrndstate, rs);
   NewObj(spline2dbuilder, state);
   NewObj(spline2dinterpolant, s);
   NewObj(spline2dinterpolant, s2);
   NewObj(spline2dinterpolant, s3);
   NewObj(spline2dfitreport, rep);
   NewObj(spline2dfitreport, rep2);
   NewObj(spline2dfitreport, rep3);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewMatrix(xy3, 0, 0, DT_REAL);
   NewMatrix(vterm, 0, 0, DT_REAL);
   NewVector(meany, 0, DT_REAL);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(tmp1, 0, DT_REAL);
   hqrndrandomize(&rs);
   tol = 1.0E-5;
// Check properties of underlying linear prior.
   ae_vector_set_length(&kv, 3);
   kv.xZ[0] = 5;
   kv.xZ[1] = 10;
   kv.xZ[2] = 16;
   for (kidx = 0; kidx < kv.cnt; kidx++) {
      for (d = 1; d <= 3; d++) {
         for (areatype = 0; areatype <= 0; areatype++) {
            for (solvertype = 1; solvertype <= 2; solvertype++) {
            // Select grid size and create builder
               kx = 1 + hqrnduniformi(&rs, kv.xZ[kidx]);
               ky = 1 + hqrnduniformi(&rs, kv.xZ[kidx]);
               if (hqrndnormal(&rs) > 0.0) {
                  kx = kv.xZ[kidx];
               } else {
                  ky = kv.xZ[kidx];
               }
               spline2dbuildercreate(d, &state);
               spline2dbuildersetgrid(&state, kx, ky);
               if (solvertype == 1) {
                  spline2dbuildersetalgoblocklls(&state, 0.0);
               } else {
                  if (solvertype == 2) {
                     spline2dbuildersetalgonaivells(&state, 0.0);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            // Generate perfectly linear dataset, check against linear prior.
            // At least 8 points is required to get stable results.
            //
            // NOTE: we also check that constant term does NOT work.
               ae_matrix_set_length(&vterm, d, 3);
               for (i = 0; i < d; i++) {
                  for (j = 0; j <= 2; j++) {
                     vterm.xyR[i][j] = hqrndnormal(&rs);
                  }
               }
               npoints = 8 + iround(10 * hqrnduniformr(&rs));
               ae_vector_set_length(&meany, d);
               for (j = 0; j < d; j++) {
                  meany.xR[j] = 0.0;
               }
               ae_matrix_set_length(&xy, npoints, 2 + d);
               for (i = 0; i < npoints; i++) {
                  xy.xyR[i][0] = hqrnduniformr(&rs);
                  xy.xyR[i][1] = hqrnduniformr(&rs);
                  for (j = 0; j < d; j++) {
                     xy.xyR[i][2 + j] = vterm.xyR[j][0] * xy.xyR[i][0] + vterm.xyR[j][1] * xy.xyR[i][1] + vterm.xyR[j][2];
                     meany.xR[j] += xy.xyR[i][2 + j] / npoints;
                  }
               }
               spline2dbuildersetpoints(&state, &xy, npoints);
               spline2dbuildersetlinterm(&state);
               spline2dfit(&state, &s, &rep);
               ae_vector_set_length(&tmp0, 3);
               for (k = 0; k <= 10; k++) {
                  tmp0.xR[0] = 3 * hqrnduniformr(&rs) - 1;
                  tmp0.xR[1] = 3 * hqrnduniformr(&rs) - 1;
                  tmp0.xR[2] = 1.0;
                  spline2dcalcv(&s, tmp0.xR[0], tmp0.xR[1], &tmp1);
                  for (j = 0; j < d; j++) {
                     v = vterm.xyR[j][0] * tmp0.xR[0] + vterm.xyR[j][1] * tmp0.xR[1] + vterm.xyR[j][2];
                     set_error_flag(errorflag, fabs(tmp1.xR[j] - v) / rmax2(fabs(v), 1.0) > tol, __FILE__, __LINE__, "testspline2dunit.ap:1094");
                  }
               }
               set_error_flag(errorflag, rep.rmserror > tol, __FILE__, __LINE__, "testspline2dunit.ap:1097");
               set_error_flag(errorflag, rep.avgerror > tol, __FILE__, __LINE__, "testspline2dunit.ap:1098");
               set_error_flag(errorflag, rep.maxerror > tol, __FILE__, __LINE__, "testspline2dunit.ap:1099");
               spline2dbuildersetconstterm(&state);
               spline2dfit(&state, &s, &rep);
               ae_vector_set_length(&tmp0, 3);
               bad = false;
               for (k = 0; k <= 10; k++) {
                  tmp0.xR[0] = 2 + hqrnduniformr(&rs);
                  tmp0.xR[1] = 2 + hqrnduniformr(&rs);
                  tmp0.xR[2] = 1.0;
                  spline2dcalcv(&s, tmp0.xR[0], tmp0.xR[1], &tmp1);
                  for (j = 0; j < d; j++) {
                     v = vterm.xyR[j][0] * tmp0.xR[0] + vterm.xyR[j][1] * tmp0.xR[1] + vterm.xyR[j][2];
                     bad = bad || fabs(tmp1.xR[j] - v) > tol;
                  }
               }
               set_error_flag(errorflag, !bad, __FILE__, __LINE__, "testspline2dunit.ap:1118");
            // Generate perfectly constant dataset, check against constant prior.
            // At least 8 points is required to get stable results.
               ae_matrix_set_length(&vterm, d, 3);
               for (i = 0; i < d; i++) {
                  for (j = 0; j <= 1; j++) {
                     vterm.xyR[i][j] = 0.0;
                  }
                  vterm.xyR[i][2] = hqrndnormal(&rs);
               }
               npoints = 8 + iround(10 * hqrnduniformr(&rs));
               ae_vector_set_length(&meany, d);
               for (j = 0; j < d; j++) {
                  meany.xR[j] = 0.0;
               }
               ae_matrix_set_length(&xy, npoints, 2 + d);
               for (i = 0; i < npoints; i++) {
                  xy.xyR[i][0] = hqrnduniformr(&rs);
                  xy.xyR[i][1] = hqrnduniformr(&rs);
                  for (j = 0; j < d; j++) {
                     xy.xyR[i][2 + j] = vterm.xyR[j][0] * xy.xyR[i][0] + vterm.xyR[j][1] * xy.xyR[i][1] + vterm.xyR[j][2];
                     meany.xR[j] += xy.xyR[i][2 + j] / npoints;
                  }
               }
               spline2dbuildersetpoints(&state, &xy, npoints);
               spline2dbuildersetconstterm(&state);
               spline2dfit(&state, &s, &rep);
               ae_vector_set_length(&tmp0, 3);
               for (k = 0; k <= 10; k++) {
                  tmp0.xR[0] = 3 * hqrnduniformr(&rs) - 1;
                  tmp0.xR[1] = 3 * hqrnduniformr(&rs) - 1;
                  tmp0.xR[2] = 1.0;
                  spline2dcalcv(&s, tmp0.xR[0], tmp0.xR[1], &tmp1);
                  for (j = 0; j < d; j++) {
                     v = vterm.xyR[j][0] * tmp0.xR[0] + vterm.xyR[j][1] * tmp0.xR[1] + vterm.xyR[j][2];
                     set_error_flag(errorflag, fabs(tmp1.xR[j] - v) / rmax2(fabs(v), 1.0) > tol, __FILE__, __LINE__, "testspline2dunit.ap:1159");
                  }
               }
               set_error_flag(errorflag, rep.rmserror > tol, __FILE__, __LINE__, "testspline2dunit.ap:1162");
               set_error_flag(errorflag, rep.avgerror > tol, __FILE__, __LINE__, "testspline2dunit.ap:1163");
               set_error_flag(errorflag, rep.maxerror > tol, __FILE__, __LINE__, "testspline2dunit.ap:1164");
            // Generate perfectly constant dataset, check against user-defined constant prior.
            // At least 8 points is required to get stable results.
               vprior = hqrndnormal(&rs);
               npoints = 8 + iround(10 * hqrnduniformr(&rs));
               ae_vector_set_length(&meany, d);
               for (j = 0; j < d; j++) {
                  meany.xR[j] = 0.0;
               }
               ae_matrix_set_length(&xy, npoints, 2 + d);
               for (i = 0; i < npoints; i++) {
                  xy.xyR[i][0] = hqrnduniformr(&rs);
                  xy.xyR[i][1] = hqrnduniformr(&rs);
                  for (j = 0; j < d; j++) {
                     xy.xyR[i][2 + j] = vprior;
                     meany.xR[j] += xy.xyR[i][2 + j] / npoints;
                  }
               }
               spline2dbuildersetpoints(&state, &xy, npoints);
               spline2dbuildersetuserterm(&state, vprior);
               spline2dfit(&state, &s, &rep);
               ae_vector_set_length(&tmp0, 3);
               for (k = 0; k <= 10; k++) {
                  tmp0.xR[0] = 3 * hqrnduniformr(&rs) - 1;
                  tmp0.xR[1] = 3 * hqrnduniformr(&rs) - 1;
                  tmp0.xR[2] = 1.0;
                  spline2dcalcv(&s, tmp0.xR[0], tmp0.xR[1], &tmp1);
                  for (j = 0; j < d; j++) {
                     set_error_flag(errorflag, fabs(tmp1.xR[j] - vprior) > tol, __FILE__, __LINE__, "testspline2dunit.ap:1199");
                  }
               }
               set_error_flag(errorflag, rep.rmserror > tol, __FILE__, __LINE__, "testspline2dunit.ap:1201");
               set_error_flag(errorflag, rep.avgerror > tol, __FILE__, __LINE__, "testspline2dunit.ap:1202");
               set_error_flag(errorflag, rep.maxerror > tol, __FILE__, __LINE__, "testspline2dunit.ap:1203");
               spline2dbuildersetuserterm(&state, vprior + (2 * hqrnduniformi(&rs, 2) - 1));
               spline2dfit(&state, &s, &rep);
               ae_vector_set_length(&tmp0, 3);
               for (k = 0; k <= 10; k++) {
                  tmp0.xR[0] = 2 + hqrnduniformr(&rs);
                  tmp0.xR[1] = 2 + hqrnduniformr(&rs);
                  tmp0.xR[2] = 1.0;
                  spline2dcalcv(&s, tmp0.xR[0], tmp0.xR[1], &tmp1);
                  for (j = 0; j < d; j++) {
                     set_error_flag(errorflag, fabs(tmp1.xR[j] - vprior) <= tol, __FILE__, __LINE__, "testspline2dunit.ap:1216");
                  }
               }
            }
         }
      }
   }
   ae_frame_leave();
}

// Nonlinearity penalty test
static void testspline2dunit_testfittingpenalty(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t kidx;
   ae_int_t pidx;
   ae_int_t solvertype;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t d;
   ae_int_t kx;
   ae_int_t ky;
   ae_int_t npoints;
   double rmserror;
   double v;
   double v0;
   double v1;
   double f0;
   double f1;
   double f2;
   double f3;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(spline2dinterpolant, s);
   NewObj(spline2dinterpolant, s2);
   NewObj(spline2dfitreport, rep);
   NewObj(spline2dfitreport, rep2);
   NewObj(hqrndstate, rs);
   NewObj(spline2dbuilder, state);
   NewVector(penalty, 0, DT_REAL);
   NewVector(penalty2, 0, DT_REAL);
   hqrndrandomize(&rs);
// Penalized fitting problem:
// * square KxK grid, K >= 8 (points do not "touch" each other by their far fields)
// * four points in the corners, perfectly linear value
// * zero prior term
//
// Check that:
// * with significant nonlinearity penalty we have nearly-linear fit,
//   central value is an average of corner values
// * without nonlinearity penalty, central value is zero
   for (kidx = 3; kidx <= 4; kidx++) {
      for (solvertype = 1; solvertype <= 2; solvertype++) {
      // Generate dataset
         kx = iround(pow(2.0, (double)kidx));
         ky = kx;
         npoints = 4;
         ae_matrix_set_length(&xy, npoints, 3);
         xy.xyR[0][0] = -1.0;
         xy.xyR[0][1] = -1.0;
         xy.xyR[0][2] = hqrndnormal(&rs);
         xy.xyR[1][0] = 1.0;
         xy.xyR[1][1] = -1.0;
         xy.xyR[1][2] = hqrndnormal(&rs);
         xy.xyR[2][0] = -1.0;
         xy.xyR[2][1] = 1.0;
         xy.xyR[2][2] = hqrndnormal(&rs);
         xy.xyR[3][0] = 1.0;
         xy.xyR[3][1] = 1.0;
         xy.xyR[3][2] = xy.xyR[0][2] + (xy.xyR[1][2] - xy.xyR[0][2]) + (xy.xyR[2][2] - xy.xyR[0][2]);
      // Create solver, set grid, area and other properties
      // according to chosen test mode.
         spline2dbuildercreate(1, &state);
         spline2dbuildersetgrid(&state, kx, ky);
         spline2dbuildersetarea(&state, -1.0, 1.0, -1.0, 1.0);
         spline2dbuildersetpoints(&state, &xy, npoints);
         spline2dbuildersetzeroterm(&state);
      // Check fitting with penalty
         if (solvertype == 1) {
            spline2dbuildersetalgoblocklls(&state, 1.0);
         } else {
            if (solvertype == 2) {
               spline2dbuildersetalgonaivells(&state, 1.0);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
         spline2dfit(&state, &s, &rep);
         set_error_flag(errorflag, fabs(spline2dcalc(&s, 0.0, 0.0) - 0.25 * (xy.xyR[0][2] + xy.xyR[1][2] + xy.xyR[2][2] + xy.xyR[3][2])) > 1.0E-4, __FILE__, __LINE__, "testspline2dunit.ap:1305");
      // Check fitting without penalty
         if (solvertype == 1) {
            spline2dbuildersetalgoblocklls(&state, 0.0);
         } else {
            if (solvertype == 2) {
               spline2dbuildersetalgonaivells(&state, 0.0);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
         spline2dfit(&state, &s2, &rep2);
         set_error_flag(errorflag, fabs(spline2dcalc(&s2, 0.0, 0.0)) > 1.0E-4, __FILE__, __LINE__, "testspline2dunit.ap:1318");
      }
   }
// Solve a sequence of problems with increasing value of penalty coefficient;
// test that increasing penalty coefficient results in:
// * increased residuals
// * decreased value of penalty function
   for (solvertype = 1; solvertype <= 2; solvertype++) {
      for (d = 1; d <= 3; d++) {
      // Prepare solver and dataset
         kx = 6 + hqrnduniformi(&rs, 5);
         ky = 6 + hqrnduniformi(&rs, 5);
         npoints = 3 * (kx + 2) * (ky + 2) + 30;
         ae_matrix_set_length(&xy, npoints, 2 + d);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = hqrnduniformr(&rs);
            xy.xyR[i][1] = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
            }
         }
         spline2dbuildercreate(d, &state);
         spline2dbuildersetgrid(&state, kx, ky);
         if (solvertype == 1) {
            spline2dbuildersetalgoblocklls(&state, 0.0);
         } else {
            if (solvertype == 2) {
               spline2dbuildersetalgonaivells(&state, 0.0);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
         spline2dbuildersetarea(&state, 0.0, 1.0, 0.0, 1.0);
         spline2dbuildersetpoints(&state, &xy, npoints);
         spline2dbuildersetzeroterm(&state);
      // Solve with zero penalty
         spline2dfit(&state, &s, &rep);
         rmserror = rep.rmserror;
         ae_vector_set_length(&penalty, d);
         for (k = 0; k < d; k++) {
            penalty.xR[k] = 0.0;
         }
         v = 1.0E-3;
         for (i = 0; i < kx; i++) {
            for (j = 0; j < ky; j++) {
               v0 = (double)i / (kx - 1);
               v1 = (double)j / (ky - 1);
               for (k = 0; k < d; k++) {
                  f0 = spline2dcalcvi(&s, v0 - v, v1, k);
                  f1 = spline2dcalcvi(&s, v0, v1, k);
                  f2 = spline2dcalcvi(&s, v0 + v, v1, k);
                  penalty.xR[k] += sqr((f0 + f2 - 2 * f1) / sqr(v));
               }
               for (k = 0; k < d; k++) {
                  f0 = spline2dcalcvi(&s, v0, v1 - v, k);
                  f1 = spline2dcalcvi(&s, v0, v1, k);
                  f2 = spline2dcalcvi(&s, v0, v1 + v, k);
                  penalty.xR[k] += sqr((f0 + f2 - 2 * f1) / sqr(v));
               }
               for (k = 0; k < d; k++) {
                  f0 = spline2dcalcvi(&s, v0 - v, v1 - v, k);
                  f1 = spline2dcalcvi(&s, v0 + v, v1 - v, k);
                  f2 = spline2dcalcvi(&s, v0 - v, v1 + v, k);
                  f3 = spline2dcalcvi(&s, v0 + v, v1 + v, k);
                  penalty.xR[k] += 2 * sqr((f3 - f2 - f1 + f0) / sqr(v));
               }
            }
         }
      // Solve with non-zero penalty
         for (pidx = -6; pidx <= 3; pidx++) {
            if (solvertype == 1) {
               spline2dbuildersetalgoblocklls(&state, pow(10.0, (double)pidx / 2.0));
            } else {
               if (solvertype == 2) {
                  spline2dbuildersetalgonaivells(&state, pow(10.0, (double)pidx / 2.0));
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
            spline2dfit(&state, &s, &rep);
            ae_vector_set_length(&penalty2, d);
            for (k = 0; k < d; k++) {
               penalty2.xR[k] = 0.0;
            }
            v = 1.0E-3;
            for (i = 0; i < kx; i++) {
               for (j = 0; j < ky; j++) {
                  v0 = (double)i / (kx - 1);
                  v1 = (double)j / (ky - 1);
                  for (k = 0; k < d; k++) {
                     f0 = spline2dcalcvi(&s, v0 - v, v1, k);
                     f1 = spline2dcalcvi(&s, v0, v1, k);
                     f2 = spline2dcalcvi(&s, v0 + v, v1, k);
                     penalty2.xR[k] += sqr((f0 + f2 - 2 * f1) / sqr(v));
                  }
                  for (k = 0; k < d; k++) {
                     f0 = spline2dcalcvi(&s, v0, v1 - v, k);
                     f1 = spline2dcalcvi(&s, v0, v1, k);
                     f2 = spline2dcalcvi(&s, v0, v1 + v, k);
                     penalty2.xR[k] += sqr((f0 + f2 - 2 * f1) / sqr(v));
                  }
                  for (k = 0; k < d; k++) {
                     f0 = spline2dcalcvi(&s, v0 - v, v1 - v, k);
                     f1 = spline2dcalcvi(&s, v0 + v, v1 - v, k);
                     f2 = spline2dcalcvi(&s, v0 - v, v1 + v, k);
                     f3 = spline2dcalcvi(&s, v0 + v, v1 + v, k);
                     penalty2.xR[k] += 2 * sqr((f3 - f2 - f1 + f0) / sqr(v));
                  }
               }
            }
            set_error_flag(errorflag, rep.rmserror <= rmserror, __FILE__, __LINE__, "testspline2dunit.ap:1448");
            for (k = 0; k < d; k++) {
               set_error_flag(errorflag, penalty2.xR[k] >= penalty.xR[k], __FILE__, __LINE__, "testspline2dunit.ap:1450");
            }
            rmserror = rep.rmserror;
            for (k = 0; k < d; k++) {
               penalty.xR[k] = penalty2.xR[k];
            }
         }
      }
   }
   ae_frame_leave();
}

// Block solver test for fitting functionality
static void testspline2dunit_testfittingblocksolver(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t d;
   ae_int_t kidx;
   ae_int_t areatype;
   ae_int_t gridtype;
   ae_int_t solvertype;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double errtol;
   ae_int_t kx;
   ae_int_t ky;
   double w1;
   double xc;
   double yc;
   ae_int_t npoints;
   ae_int_t priortype;
   double mx;
   double rmserror;
   double avgerror;
   double maxerror;
   double rss;
   double tss;
   double r2;
   double v;
   double v0;
   double v1;
   ae_frame_make(&_frame_block);
   NewVector(kv, 0, DT_INT);
   NewObj(hqrndstate, rs);
   NewObj(spline2dbuilder, state);
   NewObj(spline2dinterpolant, s);
   NewObj(spline2dinterpolant, s2);
   NewObj(spline2dinterpolant, s3);
   NewObj(spline2dfitreport, rep);
   NewObj(spline2dfitreport, rep2);
   NewObj(spline2dfitreport, rep3);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewMatrix(xy3, 0, 0, DT_REAL);
   NewMatrix(vterm, 0, 0, DT_REAL);
   NewVector(meany, 0, DT_REAL);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(tmp1, 0, DT_REAL);
   hqrndrandomize(&rs);
   errtol = 1.0E-6;
// Check that default state (no dataset) results in zero model being returned.
   for (priortype = 0; priortype <= 2; priortype++) {
      for (d = 1; d <= 3; d++) {
         for (areatype = 0; areatype <= 1; areatype++) {
            for (gridtype = 0; gridtype <= 1; gridtype++) {
               for (solvertype = 1; solvertype <= 2; solvertype++) {
               // Create solver, set grid, area and other properties
               // according to chosen test mode.
                  kx = imax2(4, 1 + hqrnduniformi(&rs, 10));
                  ky = imax2(4, 1 + hqrnduniformi(&rs, 10));
                  spline2dbuildercreate(d, &state);
                  if (gridtype == 1) {
                     spline2dbuildersetgrid(&state, kx, ky);
                  }
                  if (solvertype == 1) {
                     spline2dbuildersetalgoblocklls(&state, 0.0);
                  } else {
                     if (solvertype == 2) {
                        spline2dbuildersetalgonaivells(&state, 0.0);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
                  if (areatype == 0) {
                     spline2dbuildersetareaauto(&state);
                  } else {
                     if (areatype == 1) {
                        spline2dbuildersetarea(&state, 0.0, 1.0, 0.0, 1.0);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
                  if (priortype == 0) {
                     spline2dbuildersetlinterm(&state);
                  } else {
                     if (priortype == 1) {
                        spline2dbuildersetconstterm(&state);
                     } else {
                        if (priortype == 2) {
                           spline2dbuildersetzeroterm(&state);
                        } else {
                           ae_assert(false, "Assertion failed");
                        }
                     }
                  }
                  spline2dfit(&state, &s, &rep);
               // Test
                  for (j = 0; j < d; j++) {
                     set_error_flag(errorflag, spline2dcalcvi(&s, hqrndnormal(&rs), hqrndnormal(&rs), j) != 0.0, __FILE__, __LINE__, "testspline2dunit.ap:1550");
                  }
                  set_error_flag(errorflag, rep.rmserror != 0.0, __FILE__, __LINE__, "testspline2dunit.ap:1551");
                  set_error_flag(errorflag, rep.avgerror != 0.0, __FILE__, __LINE__, "testspline2dunit.ap:1552");
                  set_error_flag(errorflag, rep.maxerror != 0.0, __FILE__, __LINE__, "testspline2dunit.ap:1553");
                  set_error_flag(errorflag, rep.r2 != 1.0, __FILE__, __LINE__, "testspline2dunit.ap:1554");
               }
            }
         }
      }
   }
// Check properties of regression spline fitting WITHOUT nonlinearity
// penalty. Absence of penalty term allows us to perform several indirect
// tests which are impossible when working under penalty.
//
// Section below performs following tests on completely random dataset:
// * correctness of report fields
// * indirect tests for fitting solver (fitting on residuals from previous fit)
   ae_vector_set_length(&kv, 5);
   kv.xZ[0] = 4;
   kv.xZ[1] = 5;
   kv.xZ[2] = 10;
   kv.xZ[3] = 12;
   kv.xZ[4] = 15;
   for (kidx = 0; kidx < kv.cnt; kidx++) {
      for (d = 1; d <= 3; d++) {
         for (areatype = 0; areatype <= 1; areatype++) {
            for (gridtype = 1; gridtype <= 1; gridtype++) {
               for (solvertype = 1; solvertype <= 2; solvertype++) {
               // Generate dataset
                  kx = imax2(4, 1 + hqrnduniformi(&rs, kv.xZ[kidx]));
                  ky = imax2(4, 1 + hqrnduniformi(&rs, kv.xZ[kidx]));
                  if (hqrndnormal(&rs) > 0.0) {
                     kx = kv.xZ[kidx];
                  } else {
                     ky = kv.xZ[kidx];
                  }
                  w1 = pow(10.0, hqrndnormal(&rs));
                  xc = w1 * (2 * hqrnduniformr(&rs) - 1);
                  yc = w1 * (2 * hqrnduniformr(&rs) - 1);
                  ae_vector_set_length(&meany, d);
                  for (j = 0; j < d; j++) {
                     meany.xR[j] = 0.0;
                  }
                  npoints = iround((kx + 2) * (ky + 2) * (3 + hqrnduniformr(&rs)));
                  ae_matrix_set_length(&xy, npoints, 2 + d);
                  for (i = 0; i < npoints; i++) {
                     xy.xyR[i][0] = xc + w1 * (2 * hqrnduniformr(&rs) - 1) * kx;
                     xy.xyR[i][1] = yc + w1 * (2 * hqrnduniformr(&rs) - 1) * ky;
                     for (j = 0; j < d; j++) {
                        xy.xyR[i][2 + j] = hqrndnormal(&rs);
                        meany.xR[j] += xy.xyR[i][2 + j] / npoints;
                     }
                  }
               // Create solver, set grid, area and other properties
               // according to chosen test mode.
                  spline2dbuildercreate(d, &state);
                  if (gridtype == 1) {
                     spline2dbuildersetgrid(&state, kx, ky);
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
                  if (solvertype == 1) {
                     spline2dbuildersetalgoblocklls(&state, 0.0);
                  } else {
                     if (solvertype == 2) {
                        spline2dbuildersetalgonaivells(&state, 0.0);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
                  if (areatype == 0) {
                     spline2dbuildersetareaauto(&state);
                  } else {
                     if (areatype == 1) {
                        spline2dbuildersetarea(&state, xc - w1 * kx, xc + w1 * kx, yc - w1 * ky, yc + w1 * ky);
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
                  spline2dbuildersetpoints(&state, &xy, npoints);
                  spline2dfit(&state, &s, &rep);
               // Test report fields
                  rmserror = 0.0;
                  avgerror = 0.0;
                  maxerror = 0.0;
                  rss = 0.0;
                  tss = 0.0;
                  for (i = 0; i < npoints; i++) {
                     spline2dcalcv(&s, xy.xyR[i][0], xy.xyR[i][1], &tmp0);
                     for (j = 0; j < d; j++) {
                        v = xy.xyR[i][2 + j] - tmp0.xR[j];
                        rss += v * v;
                        tss += sqr(xy.xyR[i][2 + j] - meany.xR[j]);
                        rmserror += sqr(v);
                        avgerror += fabs(v) / (npoints * d);
                        maxerror = rmax2(maxerror, fabs(v));
                     }
                  }
                  rmserror = sqrt(rmserror / (npoints * d));
                  r2 = 1.0 - rss / coalesce(tss, 1.0);
                  set_error_flag(errorflag, fabs(rmserror - rep.rmserror) > errtol, __FILE__, __LINE__, "testspline2dunit.ap:1654");
                  set_error_flag(errorflag, fabs(avgerror - rep.avgerror) > errtol, __FILE__, __LINE__, "testspline2dunit.ap:1655");
                  set_error_flag(errorflag, fabs(maxerror - rep.maxerror) > errtol, __FILE__, __LINE__, "testspline2dunit.ap:1656");
                  if (tss > 1.0E-3) {
                     set_error_flag(errorflag, fabs(r2 - rep.r2) > errtol, __FILE__, __LINE__, "testspline2dunit.ap:1658");
                  }
               // Minimalistic test for fitting quality: R2 is better than zero
               // (zero value = fitting by median value).
                  set_error_flag(errorflag, rep.r2 < 0.0, __FILE__, __LINE__, "testspline2dunit.ap:1664");
               // Indirect test for solver: test that fitting on residuals from
               // previous fitting does not significantly decrease residuals.
               //
               // In our test we require that residuals from residuals are
               // greater than 0.8 times original residuals.
               //
               // In the ideal world, fitting on residuals will return same
               // residuals, but during spline construction we made several
               // compromises (regularization, pre-model phase). So, we just
               // check that residuals are weakly decreased.
               //
               // NOTE: this test is performed only for significantly non-zero residuals
                  if (rep.rmserror > 0.05) {
                     ae_matrix_set_length(&xy2, npoints, 2 + d);
                     for (i = 0; i < npoints; i++) {
                        xy2.xyR[i][0] = xy.xyR[i][0];
                        xy2.xyR[i][1] = xy.xyR[i][1];
                        spline2dcalcv(&s, xy.xyR[i][0], xy.xyR[i][1], &tmp1);
                        for (j = 0; j < d; j++) {
                           xy2.xyR[i][2 + j] = xy.xyR[i][2 + j] - tmp1.xR[j];
                        }
                     }
                     spline2dbuildersetpoints(&state, &xy2, npoints);
                     spline2dfit(&state, &s2, &rep2);
                     set_error_flag(errorflag, rep2.rmserror < 0.8 * rep.rmserror, __FILE__, __LINE__, "testspline2dunit.ap:1693");
                  }
               }
            }
         }
      }
   }
// Direct test:
// * points on regular grid which is exactly the same as one used
//   for regression, but with some noise added to point locations
// * we test that without penalty we get nearly-zero RMS error
   ae_vector_set_length(&kv, 5);
   kv.xZ[0] = 4;
   kv.xZ[1] = 5;
   kv.xZ[2] = 6;
   kv.xZ[3] = 8;
   kv.xZ[4] = 12;
   for (kidx = 0; kidx < kv.cnt; kidx++) {
      for (d = 1; d <= 2; d++) {
         for (solvertype = 1; solvertype <= 2; solvertype++) {
         // Generate dataset
            kx = imax2(4, 1 + hqrnduniformi(&rs, kv.xZ[kidx]));
            ky = imax2(4, 1 + hqrnduniformi(&rs, kv.xZ[kidx]));
            if (hqrndnormal(&rs) > 0.0) {
               kx = kv.xZ[kidx];
            } else {
               ky = kv.xZ[kidx];
            }
            npoints = kx * ky;
            ae_matrix_set_length(&xy, npoints, 2 + d);
            for (i = 0; i < npoints; i++) {
               xy.xyR[i][0] = rboundval(i % kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(kx - 1));
               xy.xyR[i][1] = rboundval(i / kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(ky - 1));
               for (j = 0; j < d; j++) {
                  xy.xyR[i][2 + j] = hqrndnormal(&rs);
               }
            }
         // Create solver, set grid, area and other properties
         // according to chosen test mode.
            spline2dbuildercreate(d, &state);
            spline2dbuildersetgrid(&state, kx, ky);
            if (solvertype == 1) {
               spline2dbuildersetalgoblocklls(&state, 0.0);
            } else {
               if (solvertype == 2) {
                  spline2dbuildersetalgonaivells(&state, 0.0);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
            spline2dbuildersetareaauto(&state);
            spline2dbuildersetpoints(&state, &xy, npoints);
            spline2dfit(&state, &s, &rep);
         // Test
            for (i = 0; i < npoints; i++) {
               for (k = 0; k < d; k++) {
                  set_error_flag(errorflag, fabs(spline2dcalcvi(&s, xy.xyR[i][0], xy.xyR[i][1], k) - xy.xyR[i][2 + k]) > 1.0E-6, __FILE__, __LINE__, "testspline2dunit.ap:1754");
               }
            }
         }
      }
   }
// Compare results obtained with block solver vs naive one
   mx = 0.0;
   for (kx = 4; kx <= 8; kx++) {
      for (ky = 4; ky <= 8; ky++) {
         for (d = 1; d <= 2; d++) {
         // Generate dataset
            npoints = 300;
            ae_matrix_set_length(&xy, npoints, 2 + d);
            for (i = 0; i < npoints; i++) {
               xy.xyR[i][0] = (kx - 1) * hqrnduniformr(&rs);
               xy.xyR[i][1] = (ky - 1) * hqrnduniformr(&rs);
               for (j = 0; j < d; j++) {
                  xy.xyR[i][2 + j] = hqrndnormal(&rs);
               }
            }
         // Create solver, set grid, area and other properties
         // according to chosen test mode.
         //
         // NOTE: we perform just one iteration of LSQR in order
         //       to test subtle differences of two implementations -
         //       reference one (NaiveLLS) and high-performance one.
            spline2dbuildercreate(d, &state);
            spline2dbuildersetgrid(&state, kx, ky);
            spline2dbuildersetarea(&state, 0.0, (double)(kx - 1), 0.0, (double)(ky - 1));
            spline2dbuildersetpoints(&state, &xy, npoints);
            state.lsqrcnt = 1;
            spline2dbuildersetalgonaivells(&state, 0.0);
            spline2dfit(&state, &s, &rep);
            spline2dbuildersetalgoblocklls(&state, 0.0);
            spline2dfit(&state, &s2, &rep2);
            for (i = 0; i < npoints; i++) {
               spline2dcalcv(&s, xy.xyR[i][0], xy.xyR[i][1], &tmp0);
               spline2dcalcv(&s2, xy.xyR[i][0], xy.xyR[i][1], &tmp1);
               for (j = 0; j < d; j++) {
                  set_error_flag(errorflag, fabs(tmp0.xR[j] - tmp1.xR[j]) > 1.0E-6, __FILE__, __LINE__, "testspline2dunit.ap:1801");
                  mx = rmax2(mx, fabs(tmp0.xR[j] - tmp1.xR[j]));
               }
            }
         }
      }
   }
// Investigate stability against minor perturbations
   d = 1;
   kx = 20;
   ky = 20;
   npoints = 5 * kx * ky;
   ae_matrix_set_length(&xy, npoints, 2 + d);
   for (i = 0; i < npoints; i++) {
      xy.xyR[i][0] = (kx - 1) * hqrnduniformr(&rs);
      xy.xyR[i][1] = (ky - 1) * hqrnduniformr(&rs);
      xy.xyR[i][2] = hqrndnormal(&rs);
   }
   spline2dbuildercreate(d, &state);
   spline2dbuildersetgrid(&state, kx, ky);
   spline2dbuildersetarea(&state, 0.0, (double)(kx - 1), 0.0, (double)(ky - 1));
   spline2dbuildersetalgoblocklls(&state, 0.001);
   spline2dbuildersetpoints(&state, &xy, npoints);
   spline2dfit(&state, &s, &rep);
   for (i = 0; i < npoints; i++) {
      j = i + hqrnduniformi(&rs, npoints - i);
      swaprows(&xy, i, j, -1);
      xy.xyR[i][2] += machineepsilon * hqrndnormal(&rs);
   }
   spline2dbuildersetpoints(&state, &xy, npoints);
   spline2dfit(&state, &s2, &rep2);
   mx = 0.0;
   maxerror = 0.0;
   for (i = 0; i < npoints; i++) {
      v0 = (kx - 1) * hqrnduniformr(&rs);
      v1 = (ky - 1) * hqrnduniformr(&rs);
      maxerror = rmax2(maxerror, fabs(spline2dcalc(&s, v0, v1) - spline2dcalc(&s2, v0, v1)));
      mx = rmax2(mx, fabs(spline2dcalc(&s, v0, v1)));
   }
   set_error_flag(errorflag, maxerror / mx > 1.0E-12, __FILE__, __LINE__, "testspline2dunit.ap:1846");
   ae_frame_leave();
}

// Block solver test for fitting functionality
static void testspline2dunit_testfittingfastddmsolver(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t tilesize;
   ae_int_t interfacesize;
   ae_int_t npoints;
   ae_int_t d;
   ae_int_t kx;
   ae_int_t ky;
   ae_int_t kxcur;
   ae_int_t kycur;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v0;
   double v1;
   double vx;
   double vy;
   double f0;
   double f1;
   double f2;
   double f3;
   double h;
   double smax;
   double ernd;
   double ept;
   double emax;
   double eavg;
   double vmax;
   ae_int_t padding;
   ae_int_t nlayers;
   double rmserror;
   double avgerror;
   double maxerror;
   double rss;
   double tss;
   double r2;
   double v;
   ae_frame_make(&_frame_block);
   NewObj(hqrndstate, rs);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy1, 0, 0, DT_REAL);
   NewObj(spline2dbuilder, state);
   NewObj(spline2dinterpolant, sa0);
   NewObj(spline2dinterpolant, sa1);
   NewObj(spline2dinterpolant, s1);
   NewObj(spline2dinterpolant, s2);
   NewObj(spline2dfitreport, rep0);
   NewObj(spline2dfitreport, rep1);
   NewObj(spline2dfitreport, rep2);
   NewVector(meany, 0, DT_REAL);
   NewVector(lambdaa, 0, DT_REAL);
   NewVector(penaltya, 0, DT_REAL);
   NewVector(rmsa, 0, DT_REAL);
   hqrndrandomize(&rs);
// Basic test:
// * small grid whose size is TileSize+1 or less
// * random dataset
// * compared with single run of naiveLLS
// * we also test correctness of report fields
   for (pass = 1; pass <= 3; pass++) {
      for (d = 1; d <= 3; d++) {
         tilesize = 8 + hqrnduniformi(&rs, 8);
         kx = imax2(1 + hqrnduniformi(&rs, tilesize + 1), 4);
         ky = imax2(1 + hqrnduniformi(&rs, tilesize + 1), 4);
         npoints = 10 * kx * ky;
         ae_matrix_set_length(&xy, npoints, 2 + d);
         ae_vector_set_length(&meany, d);
         for (j = 0; j < d; j++) {
            meany.xR[j] = 0.0;
         }
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = hqrnduniformr(&rs);
            xy.xyR[i][1] = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
               meany.xR[j] += xy.xyR[i][2 + j] / npoints;
            }
         }
      // Create solver, set grid, area and other properties.
      // Fit with NaiveLLS first.
         spline2dbuildercreate(d, &state);
         spline2dbuildersetarea(&state, 0.0, 1.0, 0.0, 1.0);
         state.maxcoresize = tilesize;
         state.adddegreeoffreedom = false;
         spline2dbuildersetalgonaivells(&state, 0.0);
         spline2dbuildersetpoints(&state, &xy, npoints);
         spline2dbuildersetgrid(&state, kx, ky);
         spline2dfit(&state, &sa0, &rep0);
      // Fit with FastDDM solver with NLayers in [-2,+2]
         spline2dbuildersetpoints(&state, &xy, npoints);
         spline2dbuildersetgrid(&state, kx, ky);
         spline2dbuildersetalgofastddm(&state, hqrnduniformi(&rs, 5) - 2, 0.0);
         spline2dfit(&state, &s1, &rep1);
      // Compare at random locations
         smax = 0.0;
         ernd = 0.0;
         for (k = 0; k < 20 * kx * ky; k++) {
            vx = hqrnduniformr(&rs);
            vy = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               v0 = spline2dcalcvi(&sa0, vx, vy, j);
               v1 = spline2dcalcvi(&s1, vx, vy, j);
               smax = rmax2(smax, fabs(v0));
               ernd = rmax2(ernd, fabs(v0 - v1));
            }
         }
         set_error_flag(errorflag, ernd / smax > 0.001, __FILE__, __LINE__, "testspline2dunit.ap:1964");
      // Test report fields
         rmserror = 0.0;
         avgerror = 0.0;
         maxerror = 0.0;
         rss = 0.0;
         tss = 0.0;
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < d; j++) {
               v = xy.xyR[i][2 + j] - spline2dcalcvi(&s1, xy.xyR[i][0], xy.xyR[i][1], j);
               rss += v * v;
               tss += sqr(xy.xyR[i][2 + j] - meany.xR[j]);
               rmserror += sqr(v);
               avgerror += fabs(v) / (npoints * d);
               maxerror = rmax2(maxerror, fabs(v));
            }
         }
         rmserror = sqrt(rmserror / (npoints * d));
         r2 = 1.0 - rss / coalesce(tss, 1.0);
         set_error_flag(errorflag, fabs(rmserror - rep1.rmserror) > 1.0E-6, __FILE__, __LINE__, "testspline2dunit.ap:1988");
         set_error_flag(errorflag, fabs(avgerror - rep1.avgerror) > 1.0E-6, __FILE__, __LINE__, "testspline2dunit.ap:1989");
         set_error_flag(errorflag, fabs(maxerror - rep1.maxerror) > 1.0E-6, __FILE__, __LINE__, "testspline2dunit.ap:1990");
         if (tss > 1.0E-3) {
            set_error_flag(errorflag, fabs(r2 - rep1.r2) > 1.0E-6, __FILE__, __LINE__, "testspline2dunit.ap:1992");
         }
      }
   }
// Basic test: two-layer task; "reference" model is built by
// subsequent fitting of two "traditional" splines; test model
// is built by FastDDM algorithm.
   tilesize = 15;
   for (d = 1; d <= 2; d++) {
   // Generate dataset
      kx = 2 * tilesize + 1;
      ky = 2 * tilesize + 1;
      npoints = kx * ky;
      ae_matrix_set_length(&xy, npoints, 2 + d);
      for (i = 0; i < npoints; i++) {
         xy.xyR[i][0] = rboundval(i % kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(kx - 1));
         xy.xyR[i][1] = rboundval(i / kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(ky - 1));
         for (j = 0; j < d; j++) {
            xy.xyR[i][2 + j] = hqrndnormal(&rs);
         }
      }
   // Create solver, set grid, area and other properties
      spline2dbuildercreate(d, &state);
      spline2dbuildersetarea(&state, 0.0, (double)(kx - 1), 0.0, (double)(ky - 1));
      state.maxcoresize = tilesize;
   // Fit with BlockLLS solver
      state.adddegreeoffreedom = false;
      spline2dbuildersetalgoblocklls(&state, 0.0);
      spline2dbuildersetpoints(&state, &xy, npoints);
      spline2dbuildersetgrid(&state, (kx - 1) / 2 + 1, (ky - 1) / 2 + 1);
      spline2dfit(&state, &sa0, &rep0);
      ae_matrix_set_length(&xy1, npoints, 2 + d);
      for (i = 0; i < npoints; i++) {
         xy1.xyR[i][0] = xy.xyR[i][0];
         xy1.xyR[i][1] = xy.xyR[i][1];
         for (j = 0; j < d; j++) {
            xy1.xyR[i][2 + j] = xy.xyR[i][2 + j] - spline2dcalcvi(&sa0, xy.xyR[i][0], xy.xyR[i][1], j);
         }
      }
      spline2dbuildersetpoints(&state, &xy1, npoints);
      spline2dbuildersetgrid(&state, kx, ky);
      spline2dfit(&state, &sa1, &rep0);
   // Fit with another solver
      spline2dbuildersetpoints(&state, &xy, npoints);
      spline2dbuildersetgrid(&state, kx, ky);
      spline2dbuildersetalgofastddm(&state, 0, 0.0);
      spline2dfit(&state, &s1, &rep1);
   // Compare
      padding = 0;
      smax = 0.0;
      ernd = 0.0;
      for (k = 0; k < 20 * kx * ky; k++) {
         vx = (kx - 1 - 2 * padding) * hqrnduniformr(&rs) + padding;
         vy = (ky - 1 - 2 * padding) * hqrnduniformr(&rs) + padding;
         for (j = 0; j < d; j++) {
            v0 = spline2dcalcvi(&sa0, vx, vy, j) + spline2dcalcvi(&sa1, vx, vy, j);
            v1 = spline2dcalcvi(&s1, vx, vy, j);
            smax = rmax2(smax, fabs(v0));
            ernd = rmax2(ernd, fabs(v0 - v1));
         }
      }
      set_error_flag(errorflag, ernd / smax > 0.010, __FILE__, __LINE__, "testspline2dunit.ap:2071");
      ept = 0.0;
      for (i = 0; i < npoints; i++) {
         vx = xy.xyR[i][0];
         vy = xy.xyR[i][1];
         for (j = 0; j < d; j++) {
            v0 = spline2dcalcvi(&sa0, vx, vy, j) + spline2dcalcvi(&sa1, vx, vy, j);
            v1 = spline2dcalcvi(&s1, vx, vy, j);
            smax = rmax2(smax, fabs(v0));
            ept = rmax2(ept, fabs(v0 - v1));
         }
      }
      set_error_flag(errorflag, ept / smax > 0.001, __FILE__, __LINE__, "testspline2dunit.ap:2085");
   }
// Test correctness of error reporting in multilevel setting:
// * grid whose size is larger than TileSize+1
// * random dataset
// * we just test correctness of report fields
   for (pass = 1; pass <= 2; pass++) {
      for (d = 1; d <= 2; d++) {
         tilesize = 5 + hqrnduniformi(&rs, 3);
         kx = imax2(1 + hqrnduniformi(&rs, 5 * tilesize + 1), 4);
         ky = imax2(1 + hqrnduniformi(&rs, 5 * tilesize + 1), 4);
         npoints = 10 * kx * ky;
         ae_matrix_set_length(&xy, npoints, 2 + d);
         ae_vector_set_length(&meany, d);
         for (j = 0; j < d; j++) {
            meany.xR[j] = 0.0;
         }
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = hqrnduniformr(&rs);
            xy.xyR[i][1] = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
               meany.xR[j] += xy.xyR[i][2 + j] / npoints;
            }
         }
      // Create solver, set grid, area and other properties.
      // Fit with FastDDM solver
         spline2dbuildercreate(d, &state);
         spline2dbuildersetarea(&state, 0.0, 1.0, 0.0, 1.0);
         state.maxcoresize = tilesize;
         spline2dbuildersetpoints(&state, &xy, npoints);
         spline2dbuildersetgrid(&state, kx, ky);
         spline2dbuildersetalgofastddm(&state, hqrnduniformi(&rs, 5) - 2, 0.0);
         spline2dfit(&state, &s1, &rep1);
      // Test report fields
         rmserror = 0.0;
         avgerror = 0.0;
         maxerror = 0.0;
         rss = 0.0;
         tss = 0.0;
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < d; j++) {
               v = xy.xyR[i][2 + j] - spline2dcalcvi(&s1, xy.xyR[i][0], xy.xyR[i][1], j);
               rss += v * v;
               tss += sqr(xy.xyR[i][2 + j] - meany.xR[j]);
               rmserror += sqr(v);
               avgerror += fabs(v) / (npoints * d);
               maxerror = rmax2(maxerror, fabs(v));
            }
         }
         rmserror = sqrt(rmserror / (npoints * d));
         r2 = 1.0 - rss / coalesce(tss, 1.0);
         set_error_flag(errorflag, fabs(rmserror - rep1.rmserror) > 1.0E-6, __FILE__, __LINE__, "testspline2dunit.ap:2152");
         set_error_flag(errorflag, fabs(avgerror - rep1.avgerror) > 1.0E-6, __FILE__, __LINE__, "testspline2dunit.ap:2153");
         set_error_flag(errorflag, fabs(maxerror - rep1.maxerror) > 1.0E-6, __FILE__, __LINE__, "testspline2dunit.ap:2154");
         if (tss > 1.0E-3) {
            set_error_flag(errorflag, fabs(r2 - rep1.r2) > 1.0E-6, __FILE__, __LINE__, "testspline2dunit.ap:2156");
         }
      }
   }
// Test correctness of handling NLayers>0, NLayers=0 and NLayers<0.
//
// NOTE: we use reduced tile size and interface size, because we do
//       not test model quality, just identity with NLayers <= 0
   d = 1;
   tilesize = 5;
   interfacesize = 2;
   kx = 1 + 4 * (tilesize - hqrnduniformi(&rs, 2));
   ky = 1 + 4 * (tilesize - hqrnduniformi(&rs, 2));
   nlayers = 3;
   npoints = kx * ky;
   ae_matrix_set_length(&xy, npoints, 2 + d);
   for (i = 0; i < npoints; i++) {
      xy.xyR[i][0] = hqrnduniformr(&rs);
      xy.xyR[i][1] = hqrnduniformr(&rs);
      for (j = 0; j < d; j++) {
         xy.xyR[i][2 + j] = hqrndnormal(&rs);
      }
   }
// Create solver, set grid, area and other properties.
   spline2dbuildercreate(d, &state);
   spline2dbuildersetarea(&state, 0.0, 1.0, 0.0, 1.0);
   state.maxcoresize = tilesize;
   state.interfacesize = interfacesize;
   spline2dbuildersetpoints(&state, &xy, npoints);
   spline2dbuildersetgrid(&state, kx, ky);
// Try different NLayers>0, compare with corresponding non-positive values
   for (k = 1; k <= nlayers + 1; k++) {
      spline2dbuildersetalgofastddm(&state, k, 0.0);
      spline2dfit(&state, &s1, &rep1);
      spline2dbuildersetalgofastddm(&state, imin2(k - nlayers, 0), 0.0);
      spline2dfit(&state, &s2, &rep2);
   // Test report fields
      vmax = 0.0;
      for (i = 0; i <= 10; i++) {
         vx = hqrnduniformr(&rs);
         vy = hqrnduniformr(&rs);
         vmax = rmax2(vmax, fabs(spline2dcalc(&s1, vx, vy) - spline2dcalc(&s2, vx, vy)));
      }
      set_error_flag(errorflag, vmax > 1.0E-12, __FILE__, __LINE__, "testspline2dunit.ap:2212");
   }
// Ability to reproduce target function in multilayer setup:
// * small tile size
// * nearly regular KX*KY dataset, for random KX>TileSize, KY>TileSize
// * (2*KX)x(2*KY) grid, flexible enough
//
// We check that maximum and average errors at nodes are small
   vmax = 0.0;
   for (pass = 1; pass <= 10; pass++) {
      d = 1;
      tilesize = 5 + hqrnduniformi(&rs, 4);
      kx = 4 + hqrnduniformi(&rs, 4 * tilesize + 1);
      ky = 4 + hqrnduniformi(&rs, 4 * tilesize + 1);
      npoints = kx * ky;
      ae_matrix_set_length(&xy, npoints, 2 + d);
      for (i = 0; i < npoints; i++) {
         xy.xyR[i][0] = rboundval(i % kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(kx - 1));
         xy.xyR[i][1] = rboundval(i / kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(ky - 1));
         for (j = 0; j < d; j++) {
            xy.xyR[i][2 + j] = hqrndnormal(&rs);
         }
      }
   // Create solver, set grid, area and other properties.
      spline2dbuildercreate(d, &state);
      state.maxcoresize = tilesize;
      spline2dbuildersetpoints(&state, &xy, npoints);
      spline2dbuildersetgrid(&state, iround(2.0 * kx), iround(2.0 * ky));
      spline2dbuildersetarea(&state, 0.0, (double)(kx - 1), 0.0, (double)(ky - 1));
      spline2dbuildersetalgofastddm(&state, 0, 0.0);
      spline2dfit(&state, &s1, &rep1);
   // Compare
      emax = 0.0;
      eavg = 0.0;
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < d; j++) {
            v = fabs(spline2dcalcvi(&s1, xy.xyR[i][0], xy.xyR[i][1], j) - xy.xyR[i][2 + j]);
            emax = rmax2(emax, v);
            eavg += v / (npoints * d);
         }
      }
      set_error_flag(errorflag, emax > 0.00100, __FILE__, __LINE__, "testspline2dunit.ap:2265");
      set_error_flag(errorflag, eavg > 0.00010, __FILE__, __LINE__, "testspline2dunit.ap:2266");
      vmax = rmax2(vmax, fabs(emax));
   }
// Test that increasing LambdaV results in decrease of S'' integral;
// although (unlike BlockLLS) FastDDM does NOT minimize S'' explicitly,
// it shows similar behavior with respect to regularization, so we can
// expect that penalty decreases.
//
// NOTE: we use ultra-small values of tile size and interface size because
//       precision is not important here.
   for (pass = 0; pass <= 2; pass++) {
      d = 1;
      tilesize = 5;
      kx = 1 + 4 * (tilesize - hqrnduniformi(&rs, 2));
      ky = 1 + 4 * (tilesize - hqrnduniformi(&rs, 2));
      npoints = -1;
      vx = 0.0;
      vy = 0.0;
      if (pass == 0) {
         npoints = 1 + iround(0.5 * kx * ky);
         ae_matrix_set_length(&xy, npoints, 2 + d);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = hqrnduniformr(&rs);
            xy.xyR[i][1] = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
            }
         }
         vx = 1.0 / (kx - 1);
         vy = 1.0 / (ky - 1);
      }
      if (pass == 1) {
         npoints = kx * ky;
         ae_matrix_set_length(&xy, npoints, 2 + d);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = rboundval(i % kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(kx - 1));
            xy.xyR[i][1] = rboundval(i / kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(ky - 1));
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
            }
         }
         vx = 1.0;
         vy = 1.0;
      }
      if (pass == 2) {
         npoints = 1 + iround(3.0 * kx * ky);
         ae_matrix_set_length(&xy, npoints, 2 + d);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = hqrnduniformr(&rs);
            xy.xyR[i][1] = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
            }
         }
         vx = 1.0 / (kx - 1);
         vy = 1.0 / (ky - 1);
      }
      ae_assert(vx > 0.0, "Spline2D: unit test failed integrity check");
      ae_assert(vy > 0.0, "Spline2D: unit test failed integrity check");
   // Create solver, set grid, area and other properties.
      spline2dbuildercreate(d, &state);
      spline2dbuildersetarea(&state, 0.0, (double)(kx - 1), 0.0, (double)(ky - 1));
      state.maxcoresize = tilesize;
      spline2dbuildersetpoints(&state, &xy, npoints);
      spline2dbuildersetgrid(&state, kx, ky);
   // Try different values of LambdaV, calculate penalty
      ae_vector_set_length(&lambdaa, 4);
      lambdaa.xR[0] = 0.0;
      lambdaa.xR[1] = 1.0E-1;
      lambdaa.xR[2] = 1.0E+1;
      lambdaa.xR[3] = 1.0E+2;
      ae_vector_set_length(&penaltya, lambdaa.cnt);
      ae_vector_set_length(&rmsa, lambdaa.cnt);
      for (k = 0; k < lambdaa.cnt; k++) {
         spline2dbuildersetalgofastddm(&state, 0, lambdaa.xR[k]);
         spline2dfit(&state, &s1, &rep1);
         h = 1.0E-4;
         v = 0.0;
         for (i = 0; i < kx; i++) {
            for (j = 0; j < ky; j++) {
               v0 = i * vx;
               v1 = j * vy;
               f0 = spline2dcalc(&s1, v0 - h, v1);
               f1 = spline2dcalc(&s1, v0, v1);
               f2 = spline2dcalc(&s1, v0 + h, v1);
               v += sqr((f0 + f2 - 2 * f1) / sqr(h));
               f0 = spline2dcalc(&s1, v0, v1 - h);
               f1 = spline2dcalc(&s1, v0, v1);
               f2 = spline2dcalc(&s1, v0, v1 + h);
               v += sqr((f0 + f2 - 2 * f1) / sqr(h));
               f0 = spline2dcalc(&s1, v0 - h, v1 - h);
               f1 = spline2dcalc(&s1, v0 + h, v1 - h);
               f2 = spline2dcalc(&s1, v0 - h, v1 + h);
               f3 = spline2dcalc(&s1, v0 + h, v1 + h);
               v += 2 * sqr((f3 - f2 - f1 + f0) / sqr(h));
            }
         }
         penaltya.xR[k] = v;
         rmsa.xR[k] = rep1.rmserror;
      }
      for (k = 0; k < lambdaa.cnt - 1; k++) {
         set_error_flag(errorflag, penaltya.xR[k] < penaltya.xR[k + 1], __FILE__, __LINE__, "testspline2dunit.ap:2387");
      }
   }
// Test that refining grid in "K:=2*K-1" fashion results in
// decrease of RMS error; although it seems quite silly test,
// in fact it checks various failures in the algorithm.
//
// NOTE: we set high penalty coefficient in order to avoid nearly
//       precise fits (such fits are hard to test reliably)
//
// NOTE: we use ultra-small values of tile size and interface size because
//       precision is not important here.
   for (pass = 0; pass <= 2; pass++) {
      d = 1;
      tilesize = 5;
      kx = 1 + 4 * tilesize;
      ky = 1 + 4 * tilesize;
      nlayers = 3;
      npoints = -1;
      if (pass == 0) {
         npoints = 1 + iround(0.1 * kx * ky);
         ae_matrix_set_length(&xy, npoints, 2 + d);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = hqrnduniformr(&rs);
            xy.xyR[i][1] = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
            }
         }
         vx = 1.0 / (kx - 1);
         vy = 1.0 / (ky - 1);
      }
      if (pass == 1) {
         npoints = kx * ky;
         ae_matrix_set_length(&xy, npoints, 2 + d);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = rboundval(i % kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(kx - 1));
            xy.xyR[i][1] = rboundval(i / kx + 0.05 * hqrndnormal(&rs), 0.0, (double)(ky - 1));
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
            }
         }
         vx = 1.0;
         vy = 1.0;
      }
      if (pass == 2) {
         npoints = 1 + iround(2.0 * kx * ky);
         ae_matrix_set_length(&xy, npoints, 2 + d);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = hqrnduniformr(&rs);
            xy.xyR[i][1] = hqrnduniformr(&rs);
            for (j = 0; j < d; j++) {
               xy.xyR[i][2 + j] = hqrndnormal(&rs);
            }
         }
         vx = 1.0 / (kx - 1);
         vy = 1.0 / (ky - 1);
      }
   // Create solver, set grid, area and other properties.
      spline2dbuildercreate(d, &state);
      spline2dbuildersetarea(&state, 0.0, (double)(kx - 1), 0.0, (double)(ky - 1));
      state.maxcoresize = tilesize;
      spline2dbuildersetpoints(&state, &xy, npoints);
   // Try different values of LambdaV, calculate penalty
      ae_vector_set_length(&rmsa, nlayers);
      kxcur = tilesize + 1;
      kycur = tilesize + 1;
      for (k = 0; k < rmsa.cnt; k++) {
         spline2dbuildersetgrid(&state, kxcur, kycur);
         spline2dbuildersetalgofastddm(&state, 0, 0.0);
         spline2dfit(&state, &s1, &rep1);
         rmsa.xR[k] = rep1.rmserror;
         kxcur = 2 * kxcur - 1;
         kycur = 2 * kycur - 1;
      }
      for (k = 0; k < rmsa.cnt - 1; k++) {
         set_error_flag(errorflag, rmsa.xR[k] <= rmsa.xR[k + 1], __FILE__, __LINE__, "testspline2dunit.ap:2479");
      }
   }
   ae_frame_leave();
}

bool testspline2d(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   bool blerrors;
   bool bcerrors;
   bool dserrors;
   bool cperrors;
   bool sererrors;
   bool uperrors;
   bool lterrors;
   bool syerrors;
   bool rlerrors;
   bool rcerrors;
   bool vferrors;
   bool fiterrorsfastddmsolver;
   bool fiterrorsblocksolver;
   bool fiterrorspenalty;
   bool fiterrorsprior;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t jobtype;
   double lstep;
   double h;
   double ax;
   double ay;
   double bx;
   double by;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t m;
   ae_int_t d;
   ae_int_t n2;
   ae_int_t m2;
   double err;
   double t;
   double t1;
   double t2;
   double l1;
   double l1x;
   double l1y;
   double l1xy;
   double l2;
   double l2x;
   double l2y;
   double l2xy;
   double fm;
   double f1;
   double f2;
   double f3;
   double f4;
   double v1;
   double v1x;
   double v1y;
   double v1xy;
   double v2;
   double v2x;
   double v2y;
   double v2xy;
   double mf;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(spline2dinterpolant, c);
   NewObj(spline2dinterpolant, c2);
   NewVector(lx, 0, DT_REAL);
   NewVector(ly, 0, DT_REAL);
   NewVector(fv1, 0, DT_REAL);
   NewVector(fvd, 0, DT_REAL);
   NewMatrix(f, 0, 0, DT_REAL);
   NewMatrix(fr, 0, 0, DT_REAL);
   NewMatrix(ft, 0, 0, DT_REAL);
   waserrors = false;
   passcount = 10;
   h = 0.00001;
   lstep = 0.001;
   blerrors = false;
   bcerrors = false;
   dserrors = false;
   cperrors = false;
   sererrors = false;
   uperrors = false;
   lterrors = false;
   syerrors = false;
   rlerrors = false;
   rcerrors = false;
   vferrors = false;
   fiterrorsfastddmsolver = false;
   fiterrorsblocksolver = false;
   fiterrorsprior = false;
   fiterrorspenalty = false;
// Fitting functions
   testspline2dunit_testfittingfastddmsolver(&fiterrorsfastddmsolver);
   testspline2dunit_testfittingprior(&fiterrorsprior);
   testspline2dunit_testfittingblocksolver(&fiterrorsblocksolver);
   testspline2dunit_testfittingpenalty(&fiterrorspenalty);
// Test: bilinear, bicubic
   for (n = 2; n <= 7; n++) {
      for (m = 2; m <= 7; m++) {
         d = randominteger(2) + 2;
         ae_vector_set_length(&x, n);
         ae_vector_set_length(&y, m);
         ae_vector_set_length(&lx, 2 * n - 1);
         ae_vector_set_length(&ly, 2 * m - 1);
         ae_matrix_set_length(&f, m, n);
         ae_vector_set_length(&fv1, m * n);
         ae_vector_set_length(&fvd, m * n * d);
         ae_matrix_set_length(&ft, n, m);
         for (pass = 1; pass <= passcount; pass++) {
         // Prepare task:
         // * X and Y stores grid
         // * F stores function values
         // * LX and LY stores twice dense grid (for Lipschitz testing)
            ax = -1 - randomreal();
            bx = 1 + randomreal();
            ay = -1 - randomreal();
            by = 1 + randomreal();
            for (j = 0; j < n; j++) {
               x.xR[j] = 0.5 * (bx + ax) - 0.5 * (bx - ax) * cos(pi * (2 * j + 1) / (2 * n));
               if (j == 0) {
                  x.xR[j] = ax;
               }
               if (j == n - 1) {
                  x.xR[j] = bx;
               }
               lx.xR[2 * j] = x.xR[j];
               if (j > 0) {
                  lx.xR[2 * j - 1] = 0.5 * (x.xR[j] + x.xR[j - 1]);
               }
            }
            for (j = 0; j < n; j++) {
               k = randominteger(n);
               if (k != j) {
                  t = x.xR[j];
                  x.xR[j] = x.xR[k];
                  x.xR[k] = t;
               }
            }
            for (i = 0; i < m; i++) {
               y.xR[i] = 0.5 * (by + ay) - 0.5 * (by - ay) * cos(pi * (2 * i + 1) / (2 * m));
               if (i == 0) {
                  y.xR[i] = ay;
               }
               if (i == m - 1) {
                  y.xR[i] = by;
               }
               ly.xR[2 * i] = y.xR[i];
               if (i > 0) {
                  ly.xR[2 * i - 1] = 0.5 * (y.xR[i] + y.xR[i - 1]);
               }
            }
            for (i = 0; i < m; i++) {
               k = randominteger(m);
               if (k != i) {
                  t = y.xR[i];
                  y.xR[i] = y.xR[k];
                  y.xR[k] = t;
               }
            }
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  f.xyR[i][j] = exp(0.6 * x.xR[j]) - exp(-0.3 * y.xR[i] + 0.08 * x.xR[j]) + 2 * cos(pi * (x.xR[j] + 1.2 * y.xR[i])) + 0.1 * cos(20 * x.xR[j] + 15 * y.xR[i]);
                  fv1.xR[i * n + j] = f.xyR[i][j];
               }
            }
            for (i = 0; i < n; i++) {
               for (j = 0; j < m; j++) {
                  for (k = 0; k < d; k++) {
                     fvd.xR[d * (n * j + i) + k] = exp(0.6 * x.xR[i]) - exp(-0.3 * y.xR[j] + 0.08 * x.xR[i]) + 2 * cos(pi * (x.xR[i] + 1.2 * y.xR[j] + k)) + 0.1 * cos(20 * x.xR[i] + 15 * y.xR[j] + k);
                  }
               }
            }
         // Test scalar bilinear interpolation:
         // * interpolation at the nodes
         // * linearity
         // * continuity
         // * differentiation in the inner points
            spline2dbuildbilinearv(&x, n, &y, m, &fv1, 1, &c);
            err = 0.0;
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  err = rmax2(err, fabs(f.xyR[i][j] - spline2dcalc(&c, x.xR[j], y.xR[i])));
               }
            }
            blerrors = blerrors || err > 10000 * machineepsilon;
            err = 0.0;
            for (i = 0; i < m - 1; i++) {
               for (j = 0; j < n - 1; j++) {
               // Test for linearity between grid points
               // (test point - geometric center of the cell)
                  fm = spline2dcalc(&c, lx.xR[2 * j + 1], ly.xR[2 * i + 1]);
                  f1 = spline2dcalc(&c, lx.xR[2 * j], ly.xR[2 * i]);
                  f2 = spline2dcalc(&c, lx.xR[2 * j + 2], ly.xR[2 * i]);
                  f3 = spline2dcalc(&c, lx.xR[2 * j + 2], ly.xR[2 * i + 2]);
                  f4 = spline2dcalc(&c, lx.xR[2 * j], ly.xR[2 * i + 2]);
                  err = rmax2(err, fabs(0.25 * (f1 + f2 + f3 + f4) - fm));
               }
            }
            blerrors = blerrors || err > 10000 * machineepsilon;
            testspline2dunit_lconst(&c, &lx, &ly, m, n, lstep, &l1, &l1x, &l1y, &l1xy);
            testspline2dunit_lconst(&c, &lx, &ly, m, n, lstep / 3, &l2, &l2x, &l2y, &l2xy);
            blerrors = blerrors || l2 / l1 > 1.2;
            err = 0.0;
            for (i = 0; i < m - 1; i++) {
               for (j = 0; j < n - 1; j++) {
                  spline2ddiff(&c, lx.xR[2 * j + 1], ly.xR[2 * i + 1], &v1, &v1x, &v1y, &v1xy);
                  testspline2dunit_twodnumder(&c, lx.xR[2 * j + 1], ly.xR[2 * i + 1], h, &v2, &v2x, &v2y, &v2xy);
                  err = rmax2(err, fabs(v1 - v2));
                  err = rmax2(err, fabs(v1x - v2x));
                  err = rmax2(err, fabs(v1y - v2y));
                  err = rmax2(err, fabs(v1xy - v2xy));
               }
            }
            dserrors = dserrors || err > 1.0E-3;
            uperrors = uperrors || !testspline2dunit_testunpack(&c, &lx, &ly);
            lterrors = lterrors || !testspline2dunit_testlintrans(&c, 1, ax, bx, ay, by);
         // Lin.Trans. test for multicomponent vector function
            spline2dbuildbilinearv(&x, n, &y, m, &fvd, d, &c);
            lterrors = lterrors || !testspline2dunit_testlintrans(&c, d, ax, bx, ay, by);
         // Test bicubic interpolation.
         // * interpolation at the nodes
         // * smoothness
         // * differentiation
            spline2dbuildbicubicv(&x, n, &y, m, &fv1, 1, &c);
            err = 0.0;
            for (i = 0; i < m; i++) {
               for (j = 0; j < n; j++) {
                  err = rmax2(err, fabs(f.xyR[i][j] - spline2dcalc(&c, x.xR[j], y.xR[i])));
               }
            }
            bcerrors = bcerrors || err > 10000 * machineepsilon;
            testspline2dunit_lconst(&c, &lx, &ly, m, n, lstep, &l1, &l1x, &l1y, &l1xy);
            testspline2dunit_lconst(&c, &lx, &ly, m, n, lstep / 3, &l2, &l2x, &l2y, &l2xy);
            bcerrors = bcerrors || l2 / l1 > 1.2;
            bcerrors = bcerrors || l2x / l1x > 1.2;
            bcerrors = bcerrors || l2y / l1y > 1.2;
            if (l2xy > 0.01 && l1xy > 0.01) {
            // Cross-derivative continuity is tested only when
            // bigger than 0.01. When the task size is too
            // small, the d2F/dXdY is nearly zero and Lipschitz
            // constant ratio is ill-conditioned.
               bcerrors = bcerrors || l2xy / l1xy > 1.2;
            }
            err = 0.0;
            for (i = 0; i < 2 * m - 1; i++) {
               for (j = 0; j < 2 * n - 1; j++) {
                  spline2ddiff(&c, lx.xR[j], ly.xR[i], &v1, &v1x, &v1y, &v1xy);
                  testspline2dunit_twodnumder(&c, lx.xR[j], ly.xR[i], h, &v2, &v2x, &v2y, &v2xy);
                  err = rmax2(err, fabs(v1 - v2));
                  err = rmax2(err, fabs(v1x - v2x));
                  err = rmax2(err, fabs(v1y - v2y));
                  err = rmax2(err, fabs(v1xy - v2xy));
               }
            }
            dserrors = dserrors || err > 1.0E-3;
            uperrors = uperrors || !testspline2dunit_testunpack(&c, &lx, &ly);
            lterrors = lterrors || !testspline2dunit_testlintrans(&c, 1, ax, bx, ay, by);
         // Lin.Trans. test for vector-function
            spline2dbuildbicubicv(&x, n, &y, m, &fvd, d, &c);
            lterrors = lterrors || !testspline2dunit_testlintrans(&c, d, ax, bx, ay, by);
         // Copy test
            if (randombool()) {
               spline2dbuildbicubic(&x, &y, &f, m, n, &c);
            } else {
               spline2dbuildbilinear(&x, &y, &f, m, n, &c);
            }
            testspline2dunit_unsetspline2d(&c2);
            spline2dcopy(&c, &c2);
            err = 0.0;
            for (i = 1; i <= 5; i++) {
               t1 = ax + (bx - ax) * randomreal();
               t2 = ay + (by - ay) * randomreal();
               err = rmax2(err, fabs(spline2dcalc(&c, t1, t2) - spline2dcalc(&c2, t1, t2)));
            }
            cperrors = cperrors || err > 10000 * machineepsilon;
         // Serialization test
            if (randombool()) {
               spline2dbuildbicubic(&x, &y, &f, m, n, &c);
            } else {
               spline2dbuildbilinear(&x, &y, &f, m, n, &c);
            }
            testspline2dunit_unsetspline2d(&c2);
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_int_t _local_ssize;
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               spline2dalloc(&_local_serializer, &c);
               _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               spline2dserialize(&_local_serializer, &c);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               spline2dunserialize(&_local_serializer, &c2);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
            err = 0.0;
            for (i = 1; i <= 5; i++) {
               t1 = ax + (bx - ax) * randomreal();
               t2 = ay + (by - ay) * randomreal();
               err = rmax2(err, fabs(spline2dcalc(&c, t1, t2) - spline2dcalc(&c2, t1, t2)));
            }
            set_error_flag(&sererrors, err > 10000 * machineepsilon, __FILE__, __LINE__, "testspline2dunit.ap:292");
         // Special symmetry test
            err = 0.0;
            for (jobtype = 0; jobtype <= 1; jobtype++) {
            // Prepare
               for (i = 0; i < m; i++) {
                  for (j = 0; j < n; j++) {
                     ft.xyR[j][i] = f.xyR[i][j];
                  }
               }
               if (jobtype == 0) {
                  spline2dbuildbilinear(&x, &y, &f, m, n, &c);
                  spline2dbuildbilinear(&y, &x, &ft, n, m, &c2);
               } else {
                  spline2dbuildbicubic(&x, &y, &f, m, n, &c);
                  spline2dbuildbicubic(&y, &x, &ft, n, m, &c2);
               }
            // Test
               for (i = 1; i <= 10; i++) {
                  t1 = ax + (bx - ax) * randomreal();
                  t2 = ay + (by - ay) * randomreal();
                  err = rmax2(err, fabs(spline2dcalc(&c, t1, t2) - spline2dcalc(&c2, t2, t1)));
               }
            }
            syerrors = syerrors || err > 10000 * machineepsilon;
         }
      }
   }
// Test resample
   for (m = 2; m <= 6; m++) {
      for (n = 2; n <= 6; n++) {
         ae_matrix_set_length(&f, m - 1 + 1, n - 1 + 1);
         ae_vector_set_length(&x, n - 1 + 1);
         ae_vector_set_length(&y, m - 1 + 1);
         for (j = 0; j < n; j++) {
            x.xR[j] = (double)j / (n - 1);
         }
         for (i = 0; i < m; i++) {
            y.xR[i] = (double)i / (m - 1);
         }
         for (i = 0; i < m; i++) {
            for (j = 0; j < n; j++) {
               f.xyR[i][j] = exp(0.6 * x.xR[j]) - exp(-0.3 * y.xR[i] + 0.08 * x.xR[j]) + 2 * cos(pi * (x.xR[j] + 1.2 * y.xR[i])) + 0.1 * cos(20 * x.xR[j] + 15 * y.xR[i]);
            }
         }
         for (m2 = 2; m2 <= 6; m2++) {
            for (n2 = 2; n2 <= 6; n2++) {
               for (pass = 1; pass <= passcount; pass++) {
                  for (jobtype = 0; jobtype <= 1; jobtype++) {
                     if (jobtype == 0) {
                        spline2dresamplebilinear(&f, m, n, &fr, m2, n2);
                        spline2dbuildbilinear(&x, &y, &f, m, n, &c);
                     }
                     if (jobtype == 1) {
                        spline2dresamplebicubic(&f, m, n, &fr, m2, n2);
                        spline2dbuildbicubic(&x, &y, &f, m, n, &c);
                     }
                     err = 0.0;
                     mf = 0.0;
                     for (i = 0; i < m2; i++) {
                        for (j = 0; j < n2; j++) {
                           v1 = spline2dcalc(&c, (double)j / (n2 - 1), (double)i / (m2 - 1));
                           v2 = fr.xyR[i][j];
                           err = rmax2(err, fabs(v1 - v2));
                           mf = rmax2(mf, fabs(v1));
                        }
                     }
                     if (jobtype == 0) {
                        rlerrors = rlerrors || err / mf > 10000 * machineepsilon;
                     }
                     if (jobtype == 1) {
                        rcerrors = rcerrors || err / mf > 10000 * machineepsilon;
                     }
                  }
               }
            }
         }
      }
   }
// Test for vector-function
   vferrors = testspline2dunit_testspline2dvf(true);
// Report
   waserrors = (((((((((((((blerrors || bcerrors) || dserrors) || cperrors) || sererrors) || uperrors) || lterrors) || syerrors) || rlerrors) || rcerrors) || vferrors) || fiterrorsprior) || fiterrorspenalty) || fiterrorsblocksolver) || fiterrorsfastddmsolver;
   if (!silent) {
      printf("TESTING 2D SPLINE\n");
   // Normal tests
      printf("INTERPOLATION:\n");
      printf("* bilinear                               ");
      if (blerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* bicubic                                ");
      if (bcerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* differentiation                        ");
      if (dserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* copying                                ");
      if (cperrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* serialization                          ");
      if (sererrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* unpacking                              ");
      if (uperrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* lin.trans.                             ");
      if (lterrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* special symmetry props                 ");
      if (syerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* vector spline                          ");
      if (vferrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("FITTING:\n");
      printf("* linear prior term                      ");
      if (fiterrorsprior) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* nonlinearity penalty term              ");
      if (fiterrorspenalty) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* block solver                           ");
      if (fiterrorsblocksolver) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* fast DDM solver                        ");
      if (fiterrorsfastddmsolver) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("RESAMPLING:\n");
      printf("* bilinear                               ");
      if (rlerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* bicubic                                ");
      if (rcerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
   // Summary
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
// end
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === spline3d testing unit ===
// The function does build random function on random grid with random number
// of points:
// * N, M, K   -   random from 2 to 5
// * D         -   1 in case IsVect=False, 1..3 in case IsVect=True
// * X, Y, Z   -   each variable spans from MinV to MaxV, with MinV is random
//                 number from [-1.5,0.5] and MaxV is random number from
//                 [0.5,1.5]. All nodes are well separated. All nodes are
//                 randomly reordered in case Reorder=False. When Reorder=True,
//                 nodes are returned in ascending order.
// * F         -   random values from [-1,+1]
static void testspline3dunit_buildrndgrid(bool isvect, bool reorder, ae_int_t *n, ae_int_t *m, ae_int_t *l, ae_int_t *d, RVector *x, RVector *y, RVector *z, RVector *f) {
   double st;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t di;
   double v;
   double mx;
   double maxv;
   double minv;
   *n = 0;
   *m = 0;
   *l = 0;
   *d = 0;
   SetVector(x);
   SetVector(y);
   SetVector(z);
   SetVector(f);
   st = 0.3;
   *m = randominteger(4) + 2;
   *n = randominteger(4) + 2;
   *l = randominteger(4) + 2;
   if (isvect) {
      *d = randominteger(3) + 1;
   } else {
      *d = 1;
   }
   vectorsetlengthatleast(x, *n);
   vectorsetlengthatleast(y, *m);
   vectorsetlengthatleast(z, *l);
   vectorsetlengthatleast(f, *n * (*m) * (*l) * (*d));
// Fill X
   x->xR[0] = 0.0;
   for (i = 1; i < *n; i++) {
      x->xR[i] = x->xR[i - 1] + st + randomreal();
   }
   minv = -0.5 - randomreal();
   maxv = 0.5 + randomreal();
   mx = x->xR[*n - 1];
   for (i = 0; i < *n; i++) {
      x->xR[i] = x->xR[i] / mx * (maxv - minv) + minv;
   }
   if (reorder) {
      for (i = 0; i < *n; i++) {
         k = randominteger(*n);
         v = x->xR[i];
         x->xR[i] = x->xR[k];
         x->xR[k] = v;
      }
   }
// Fill Y
   y->xR[0] = 0.0;
   for (i = 1; i < *m; i++) {
      y->xR[i] = y->xR[i - 1] + st + randomreal();
   }
   minv = -0.5 - randomreal();
   maxv = 0.5 + randomreal();
   mx = y->xR[*m - 1];
   for (i = 0; i < *m; i++) {
      y->xR[i] = y->xR[i] / mx * (maxv - minv) + minv;
   }
   if (reorder) {
      for (i = 0; i < *m; i++) {
         k = randominteger(*m);
         v = y->xR[i];
         y->xR[i] = y->xR[k];
         y->xR[k] = v;
      }
   }
// Fill Z
   z->xR[0] = 0.0;
   for (i = 1; i < *l; i++) {
      z->xR[i] = z->xR[i - 1] + st + randomreal();
   }
   minv = -0.5 - randomreal();
   maxv = 0.5 + randomreal();
   mx = z->xR[*l - 1];
   for (i = 0; i < *l; i++) {
      z->xR[i] = z->xR[i] / mx * (maxv - minv) + minv;
   }
   if (reorder) {
      for (i = 0; i < *l; i++) {
         k = randominteger(*l);
         v = z->xR[i];
         z->xR[i] = z->xR[k];
         z->xR[k] = v;
      }
   }
// Fill F
   for (i = 0; i < *n; i++) {
      for (j = 0; j < *m; j++) {
         for (k = 0; k < *l; k++) {
            for (di = 0; di < *d; di++) {
               f->xR[*d * (*n * (*m * k + j) + i) + di] = randommid();
            }
         }
      }
   }
}

// The function does test basic functionality.
static bool testspline3dunit_basictest() {
   ae_frame _frame_block;
   double vsf;
   ae_int_t d;
   ae_int_t m;
   ae_int_t n;
   ae_int_t l;
   double eps;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t offs;
   ae_int_t di;
   double ax;
   double ay;
   double az;
   double axy;
   double ayz;
   double vx;
   double vy;
   double vz;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(spline3dinterpolant, c);
   NewObj(spline3dinterpolant, cc);
   NewVector(vvf, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(z, 0, DT_REAL);
   NewVector(sf, 0, DT_REAL);
   NewVector(vf, 0, DT_REAL);
   eps = 1000 * machineepsilon;
// Test spline ability to reproduce D-dimensional vector function
//     f[idx](x,y,z) = idx+AX*x + AY*y + AZ*z + AXY*x*y + AYZ*y*z
// with random AX/AY/...
//
// We generate random test function, build spline, then evaluate
// it in the random test point.
   for (d = 1; d <= 3; d++) {
      n = 2 + randominteger(4);
      m = 2 + randominteger(4);
      l = 2 + randominteger(4);
      ae_vector_set_length(&x, n);
      for (i = 0; i < n; i++) {
         x.xR[i] = (double)i;
      }
      ae_vector_set_length(&y, m);
      for (i = 0; i < m; i++) {
         y.xR[i] = (double)i;
      }
      ae_vector_set_length(&z, l);
      for (i = 0; i < l; i++) {
         z.xR[i] = (double)i;
      }
      ae_vector_set_length(&vf, l * m * n * d);
      offs = 0;
      ax = randommid();
      ay = randommid();
      az = randommid();
      axy = randommid();
      ayz = randommid();
      for (k = 0; k < l; k++) {
         for (j = 0; j < m; j++) {
            for (i = 0; i < n; i++) {
               for (di = 0; di < d; di++) {
                  vf.xR[offs] = di + ax * i + ay * j + az * k + axy * i * j + ayz * j * k;
                  offs++;
               }
            }
         }
      }
      spline3dbuildtrilinearv(&x, n, &y, m, &z, l, &vf, d, &c);
      vx = randomreal() * n;
      vy = randomreal() * m;
      vz = randomreal() * l;
      spline3dcalcv(&c, vx, vy, vz, &vf);
      for (di = 0; di < d; di++) {
         if (fabs(di + ax * vx + ay * vy + az * vz + axy * vx * vy + ayz * vy * vz - vf.xR[di]) > eps) {
            result = true;
            ae_frame_leave();
            return result;
         }
      }
      if (d == 1) {
         vsf = spline3dcalc(&c, vx, vy, vz);
         if (fabs(ax * vx + ay * vy + az * vz + axy * vx * vy + ayz * vy * vz - vsf) > eps) {
            result = true;
            ae_frame_leave();
            return result;
         }
      }
   }
// Generate random grid and test function.
// Test spline ability to reproduce function values at grid nodes.
   passcount = 20;
   for (pass = 1; pass <= passcount; pass++) {
   // Prepare a model and check that functions (Spline3DBuildTrilinear,
   // Spline3DCalc,Spline3DCalcV) work correctly and
      testspline3dunit_buildrndgrid(true, true, &n, &m, &l, &d, &x, &y, &z, &vf);
      vectorsetlengthatleast(&sf, n * m * l);
   // Check that the model's values are equal to the function's values
   // in grid points
      spline3dbuildtrilinearv(&x, n, &y, m, &z, l, &vf, d, &c);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            for (k = 0; k < l; k++) {
               spline3dcalcv(&c, x.xR[i], y.xR[j], z.xR[k], &vvf);
               for (di = 0; di < d; di++) {
                  if (fabs(vf.xR[d * (n * (m * k + j) + i) + di] - vvf.xR[di]) > eps) {
                     result = true;
                     ae_frame_leave();
                     return result;
                  }
               }
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Unpack/UnpackV test
static bool testspline3dunit_testunpack() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t l;
   ae_int_t d;
   ae_int_t sz;
   ae_int_t un;
   ae_int_t um;
   ae_int_t ul;
   ae_int_t ud;
   ae_int_t ust;
   ae_int_t uvn;
   ae_int_t uvm;
   ae_int_t uvl;
   ae_int_t uvd;
   ae_int_t uvst;
   ae_int_t ci;
   ae_int_t cj;
   ae_int_t ck;
   ae_int_t p0;
   ae_int_t p1;
   double tx;
   double ty;
   double tz;
   double v1;
   double v2;
   double err;
   ae_int_t pass;
   ae_int_t passcount;
   bool bperr;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t di;
   ae_int_t i0;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(spline3dinterpolant, c);
   NewMatrix(tbl0, 0, 0, DT_REAL);
   NewMatrix(tbl1, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(z, 0, DT_REAL);
   NewVector(sf, 0, DT_REAL);
   NewVector(vf, 0, DT_REAL);
   passcount = 20;
   err = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
   // generate random grid.
   // NOTE: for this test we need ordered grid, i.e. grid
   //       with nodes in ascending order
      testspline3dunit_buildrndgrid(true, false, &n, &m, &l, &d, &x, &y, &z, &vf);
      sz = n * m * l;
      vectorsetlengthatleast(&sf, sz);
      spline3dbuildtrilinearv(&x, n, &y, m, &z, l, &vf, d, &c);
      spline3dunpackv(&c, &uvn, &uvm, &uvl, &uvd, &uvst, &tbl0);
      for (di = 0; di < d; di++) {
      // DI-th component copy of a vector-function to
      // a scalar function
         for (i = 0; i < sz; i++) {
            sf.xR[i] = vf.xR[d * i + di];
         }
         spline3dbuildtrilinearv(&x, n, &y, m, &z, l, &sf, 1, &c);
         spline3dunpackv(&c, &un, &um, &ul, &ud, &ust, &tbl1);
         for (i = 0; i < n - 1; i++) {
            for (j = 0; j < m - 1; j++) {
               for (k = 0; k < l - 1; k++) {
                  p1 = (n - 1) * ((m - 1) * k + j) + i;
                  p0 = d * p1 + di;
               // Check that all components are correct:
               //  *first check, that unpacked componets are equal
               //   to packed components;
                  bperr = (((((((((((((((((un != n || um != m) || ul != l) || tbl1.xyR[p1][0] != x.xR[i]) || tbl1.xyR[p1][1] != x.xR[i + 1]) || tbl1.xyR[p1][2] != y.xR[j]) || tbl1.xyR[p1][3] != y.xR[j + 1]) || tbl1.xyR[p1][4] != z.xR[k]) || tbl1.xyR[p1][5] != z.xR[k + 1]) || uvn != n) || uvm != m) || uvl != l) || uvd != d) || tbl0.xyR[p0][0] != x.xR[i]) || tbl0.xyR[p0][1] != x.xR[i + 1]) || tbl0.xyR[p0][2] != y.xR[j]) || tbl0.xyR[p0][3] != y.xR[j + 1]) || tbl0.xyR[p0][4] != z.xR[k]) || tbl0.xyR[p0][5] != z.xR[k + 1];
               //  *check, that all components unpacked by Unpack
               //   function are equal to all components unpacked
               //   by UnpackV function.
                  for (i0 = 0; i0 <= 13; i0++) {
                     bperr = bperr || tbl0.xyR[p0][i0] != tbl1.xyR[p1][i0];
                  }
                  if (bperr) {
                     result = true;
                     ae_frame_leave();
                     return result;
                  }
                  tx = (0.001 + 0.999 * randomreal()) * (tbl1.xyR[p1][1] - tbl1.xyR[p1][0]);
                  ty = (0.001 + 0.999 * randomreal()) * (tbl1.xyR[p1][3] - tbl1.xyR[p1][2]);
                  tz = (0.001 + 0.999 * randomreal()) * (tbl1.xyR[p1][5] - tbl1.xyR[p1][4]);
               // Interpolation properties for:
               //  *scalar function;
                  v1 = 0.0;
                  for (ci = 0; ci <= 1; ci++) {
                     for (cj = 0; cj <= 1; cj++) {
                        for (ck = 0; ck <= 1; ck++) {
                           v1 += tbl1.xyR[p1][6 + 2 * (2 * ck + cj) + ci] * pow(tx, (double)ci) * pow(ty, (double)cj) * pow(tz, (double)ck);
                        }
                     }
                  }
                  v2 = spline3dcalc(&c, tbl1.xyR[p1][0] + tx, tbl1.xyR[p1][2] + ty, tbl1.xyR[p1][4] + tz);
                  err = rmax2(err, fabs(v1 - v2));
               //  *component of vector function.
                  v1 = 0.0;
                  for (ci = 0; ci <= 1; ci++) {
                     for (cj = 0; cj <= 1; cj++) {
                        for (ck = 0; ck <= 1; ck++) {
                           v1 += tbl0.xyR[p0][6 + 2 * (2 * ck + cj) + ci] * pow(tx, (double)ci) * pow(ty, (double)cj) * pow(tz, (double)ck);
                        }
                     }
                  }
                  v2 = spline3dcalc(&c, tbl0.xyR[p0][0] + tx, tbl0.xyR[p0][2] + ty, tbl0.xyR[p0][4] + tz);
                  err = rmax2(err, fabs(v1 - v2));
               }
            }
         }
      }
   }
   result = err > 1.0E+5 * machineepsilon;
   ae_frame_leave();
   return result;
}

// LinTrans test
static bool testspline3dunit_testlintrans() {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t l;
   ae_int_t d;
   double a1;
   double a2;
   double a3;
   double b1;
   double b2;
   double b3;
   double tx;
   double ty;
   double tz;
   double vx;
   double vy;
   double vz;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t xjob;
   ae_int_t yjob;
   ae_int_t zjob;
   double err;
   ae_int_t i;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(spline3dinterpolant, c);
   NewObj(spline3dinterpolant, c2);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(z, 0, DT_REAL);
   NewVector(f, 0, DT_REAL);
   NewVector(v1, 0, DT_REAL);
   NewVector(v2, 0, DT_REAL);
   err = 0.0;
   passcount = 15;
   for (pass = 1; pass <= passcount; pass++) {
      testspline3dunit_buildrndgrid(true, false, &n, &m, &l, &d, &x, &y, &z, &f);
      spline3dbuildtrilinearv(&x, n, &y, m, &z, l, &f, d, &c);
      for (xjob = 0; xjob <= 1; xjob++) {
         for (yjob = 0; yjob <= 1; yjob++) {
            for (zjob = 0; zjob <= 1; zjob++) {
            // Prepare
               do {
                  a1 = randommid();
               } while (a1 == 0.0);
               a1 *= xjob;
               b1 = x.xR[0] + randomreal() * (x.xR[n - 1] - x.xR[0] + 2.0) - 1.0;
               do {
                  a2 = randommid();
               } while (a2 == 0.0);
               a2 *= yjob;
               b2 = y.xR[0] + randomreal() * (y.xR[m - 1] - y.xR[0] + 2.0) - 1.0;
               do {
                  a3 = randommid();
               } while (a3 == 0.0);
               a3 *= zjob;
               b3 = z.xR[0] + randomreal() * (z.xR[l - 1] - z.xR[0] + 2.0) - 1.0;
            // Test XYZ
               spline3dcopy(&c, &c2);
               spline3dlintransxyz(&c2, a1, b1, a2, b2, a3, b3);
               tx = x.xR[0] + randomreal() * (x.xR[n - 1] - x.xR[0]);
               ty = y.xR[0] + randomreal() * (y.xR[m - 1] - y.xR[0]);
               tz = z.xR[0] + randomreal() * (z.xR[l - 1] - z.xR[0]);
               if (xjob == 0) {
                  tx = b1;
                  vx = x.xR[0] + randomreal() * (x.xR[n - 1] - x.xR[0]);
               } else {
                  vx = (tx - b1) / a1;
               }
               if (yjob == 0) {
                  ty = b2;
                  vy = y.xR[0] + randomreal() * (y.xR[m - 1] - y.xR[0]);
               } else {
                  vy = (ty - b2) / a2;
               }
               if (zjob == 0) {
                  tz = b3;
                  vz = z.xR[0] + randomreal() * (z.xR[l - 1] - z.xR[0]);
               } else {
                  vz = (tz - b3) / a3;
               }
               spline3dcalcv(&c, tx, ty, tz, &v1);
               spline3dcalcv(&c2, vx, vy, vz, &v2);
               for (i = 0; i < d; i++) {
                  err = rmax2(err, fabs(v1.xR[i] - v2.xR[i]));
               }
               if (err > 1.0E+4 * machineepsilon) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            // Test F
               spline3dcopy(&c, &c2);
               spline3dlintransf(&c2, a1, b1);
               tx = x.xR[0] + randomreal() * (x.xR[n - 1] - x.xR[0]);
               ty = y.xR[0] + randomreal() * (y.xR[m - 1] - y.xR[0]);
               tz = z.xR[0] + randomreal() * (z.xR[l - 1] - z.xR[0]);
               spline3dcalcv(&c, tx, ty, tz, &v1);
               spline3dcalcv(&c2, tx, ty, tz, &v2);
               for (i = 0; i < d; i++) {
                  err = rmax2(err, fabs(a1 * v1.xR[i] + b1 - v2.xR[i]));
               }
            }
         }
      }
   }
   result = err > 1.0E+4 * machineepsilon;
   ae_frame_leave();
   return result;
}

// Resample test
static bool testspline3dunit_testtrilinearresample() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t m;
   ae_int_t l;
   ae_int_t n2;
   ae_int_t m2;
   ae_int_t l2;
   double v1;
   double v2;
   double err;
   double mf;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(spline3dinterpolant, c);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(z, 0, DT_REAL);
   NewVector(f, 0, DT_REAL);
   NewVector(fr, 0, DT_REAL);
   result = false;
   passcount = 20;
   for (pass = 1; pass <= passcount; pass++) {
      n = randominteger(4) + 2;
      m = randominteger(4) + 2;
      l = randominteger(4) + 2;
      n2 = randominteger(4) + 2;
      m2 = randominteger(4) + 2;
      l2 = randominteger(4) + 2;
      vectorsetlengthatleast(&x, n);
      vectorsetlengthatleast(&y, m);
      vectorsetlengthatleast(&z, l);
      vectorsetlengthatleast(&f, n * m * l);
      for (i = 0; i < n; i++) {
         x.xR[i] = (double)i / (n - 1);
      }
      for (i = 0; i < m; i++) {
         y.xR[i] = (double)i / (m - 1);
      }
      for (i = 0; i < l; i++) {
         z.xR[i] = (double)i / (l - 1);
      }
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            for (k = 0; k < l; k++) {
               f.xR[n * (m * k + j) + i] = randommid();
            }
         }
      }
      spline3dresampletrilinear(&f, l, m, n, l2, m2, n2, &fr);
      spline3dbuildtrilinearv(&x, n, &y, m, &z, l, &f, 1, &c);
      err = 0.0;
      mf = 0.0;
      for (i = 0; i < n2; i++) {
         for (j = 0; j < m2; j++) {
            for (k = 0; k < l2; k++) {
               v1 = spline3dcalc(&c, (double)i / (n2 - 1), (double)j / (m2 - 1), (double)k / (l2 - 1));
               v2 = fr.xR[n2 * (m2 * k + j) + i];
               err = rmax2(err, fabs(v1 - v2));
               mf = rmax2(mf, fabs(v1));
            }
         }
      }
      result = result || err / mf > 1.0E+4 * machineepsilon;
      if (result) {
         ae_frame_leave();
         return result;
      }
   }
   ae_frame_leave();
   return result;
}

bool testspline3d(bool silence) {
   bool waserrors;
   bool basicerr;
   bool unpackerr;
   bool lintransferr;
   bool trilinreserr;
   bool result;
   basicerr = testspline3dunit_basictest();
   unpackerr = testspline3dunit_testunpack();
   lintransferr = testspline3dunit_testlintrans();
   trilinreserr = testspline3dunit_testtrilinearresample();
   waserrors = ((basicerr || unpackerr) || lintransferr) || trilinreserr;
   if (!silence) {
      printf("TESTING 3D SPLINE\n");
      printf("BASIC TEST:                              ");
      if (basicerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("UNPACK TEST:                             ");
      if (unpackerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("LIN_TRANSF TEST:                         ");
      if (lintransferr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("TRILINEAR RESAMPLING TEST:               ");
      if (trilinreserr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
   // Summary
      if (waserrors) {
         printf("TEST FAILED");
      } else {
         printf("TEST PASSED");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === rbf testing unit ===
static const double testrbfunit_tol = 1.0E-10;
static const ae_int_t testrbfunit_mxits = 0;
static const double testrbfunit_heps = 1.0E-12;

// The test  has  to  check, that  algorithm can solve problems of matrix are
// degenerate.
//     * used model with linear term;
//     * points locate in a subspace of dimension less than an original space.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
static bool sqrdegmatrixrbftest(bool silent);

// Function for testing basic functionality of RBF module on regular grids with
// multi-layer algorithm in 1D.
// ALGLIB: Copyright 2.03.2012 by Sergey Bochkanov
static bool basicmultilayerrbf1dtest();

// The test  has  to  check, that  algorithm can solve problems of matrix are
// degenerate.
//     * used model with linear term;
//     * points locate in a subspace of dimension less than an original space.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
static bool sqrdegmatrixrbftest(bool silent) {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t np;
   double sx;
   double sy;
   double zx;
   double px;
   double zy;
   double py;
   double q;
   double z;
   ae_int_t gen;
   double pvdnorm;
   double vnorm;
   double dd0;
   double dd1;
   ae_int_t unx;
   ae_int_t uny;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double eps;
   ae_int_t modelversion;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewVector(point, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewVector(d0, 0, DT_REAL);
   NewVector(d1, 0, DT_REAL);
   NewVector(pvd0, 0, DT_REAL);
   NewVector(pvd1, 0, DT_REAL);
   NewMatrix(gp, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(xwr, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   zx = 10.0;
   px = 15.0;
   zy = 10.0;
   py = 15.0;
   eps = 1.0E-6;
   ny = 1;
   for (nx = 2; nx <= 3; nx++) {
   // prepare test problem
      sx = pow(zx, px * (randominteger(3) - 1));
      sy = pow(zy, py * (randominteger(3) - 1));
      ae_vector_set_length(&x, nx);
      ae_vector_set_length(&y, ny);
      ae_vector_set_length(&point, nx);
      rbfcreate(nx, ny, &s);
      rbfsetcond(&s, testrbfunit_heps, testrbfunit_heps, testrbfunit_mxits);
      q = 0.25 + randomreal();
      z = 4.5 + randomreal();
      rbfsetalgoqnn(&s, q, z);
   // start points for grid
      for (i = 0; i < nx; i++) {
         point.xR[i] = sx * randommid();
      }
      if (nx == 2) {
         for (k0 = 2; k0 <= 4; k0++) {
            rmatrixrndorthogonal(nx, &a);
            ae_vector_set_length(&d0, nx);
            ae_v_move(d0.xR, 1, a.xyR[0], a.stride, nx);
            np = k0;
            ae_matrix_set_length(&gp, np, nx + ny);
         // create grid
            for (i = 0; i < k0; i++) {
               gp.xyR[i][0] = point.xR[0] + sx * i * d0.xR[0];
               gp.xyR[i][1] = point.xR[1] + sx * i * d0.xR[1];
               for (k = 0; k < ny; k++) {
                  gp.xyR[i][nx + k] = sy * randommid();
               }
            }
            rbfsetpoints(&s, &gp, np);
            rbfbuildmodel(&s, &rep);
            for (i = 0; i < np; i++) {
               x.xR[0] = gp.xyR[i][0];
               x.xR[1] = gp.xyR[i][1];
               rbfcalc(&s, &x, &y);
               for (j = 0; j < ny; j++) {
                  if (fabs(gp.xyR[i][nx + j] - y.xR[j]) > sy * eps) {
                     result = true;
                     ae_frame_leave();
                     return result;
                  }
               }
            }
         }
      }
      if (nx == 3) {
         for (k0 = 2; k0 <= 4; k0++) {
            for (k1 = 2; k1 <= 4; k1++) {
               for (gen = 1; gen <= 2; gen++) {
                  rmatrixrndorthogonal(nx, &a);
                  ae_vector_set_length(&d0, nx);
                  ae_v_move(d0.xR, 1, a.xyR[0], a.stride, nx);
               // create grid
                  np = -1;
                  if (gen == 1) {
                     np = k0;
                     ae_matrix_set_length(&gp, np, nx + ny);
                     for (i = 0; i < k0; i++) {
                        gp.xyR[i][0] = point.xR[0] + sx * i * d0.xR[0];
                        gp.xyR[i][1] = point.xR[1] + sx * i * d0.xR[1];
                        gp.xyR[i][2] = point.xR[2] + sx * i * d0.xR[2];
                        for (k = 0; k < ny; k++) {
                           gp.xyR[i][nx + k] = sy * randommid();
                        }
                     }
                  }
                  if (gen == 2) {
                     ae_vector_set_length(&d1, nx);
                     ae_v_move(d1.xR, 1, &a.xyR[0][1], a.stride, nx);
                     np = k0 * k1;
                     ae_matrix_set_length(&gp, np, nx + ny);
                     for (i = 0; i < k0; i++) {
                        for (j = 0; j < k1; j++) {
                           gp.xyR[i * k1 + j][0] = sx * i * d0.xR[0] + sx * j * d1.xR[0];
                           gp.xyR[i * k1 + j][1] = sx * i * d0.xR[1] + sx * j * d1.xR[1];
                           gp.xyR[i * k1 + j][2] = sx * i * d0.xR[2] + sx * j * d1.xR[2];
                           for (k = 0; k < ny; k++) {
                              gp.xyR[i * k1 + j][nx + k] = sy * randommid();
                           }
                        }
                     }
                  }
                  ae_assert(np >= 0, "rbf test: integrity error");
                  rbfsetpoints(&s, &gp, np);
                  rbfbuildmodel(&s, &rep);
                  for (i = 0; i < np; i++) {
                     x.xR[0] = gp.xyR[i][0];
                     x.xR[1] = gp.xyR[i][1];
                     x.xR[2] = gp.xyR[i][2];
                     rbfcalc(&s, &x, &y);
                     for (j = 0; j < ny; j++) {
                        if (fabs(gp.xyR[i][nx + j] - y.xR[j]) > sy * eps) {
                           result = true;
                           ae_frame_leave();
                           return result;
                        }
                     }
                  }
                  if (gen == 2) {
                     rbfunpack(&s, &unx, &uny, &xwr, &np, &v, &modelversion);
                     dd0 = (d0.xR[0] * v.xyR[0][0] + d0.xR[1] * v.xyR[0][1] + d0.xR[2] * v.xyR[0][2]) / (d0.xR[0] * d0.xR[0] + d0.xR[1] * d0.xR[1] + d0.xR[2] * d0.xR[2]);
                     dd1 = (d1.xR[0] * v.xyR[0][0] + d1.xR[1] * v.xyR[0][1] + d1.xR[2] * v.xyR[0][2]) / (d1.xR[0] * d1.xR[0] + d1.xR[1] * d1.xR[1] + d1.xR[2] * d1.xR[2]);
                     ae_vector_set_length(&pvd0, nx);
                     ae_vector_set_length(&pvd1, nx);
                     for (i = 0; i < nx; i++) {
                        pvd0.xR[i] = dd0 * d0.xR[i];
                        pvd1.xR[i] = dd1 * d1.xR[i];
                     }
                     pvdnorm = sqrt(sqr(v.xyR[0][0] - pvd0.xR[0] - pvd1.xR[0]) + sqr(v.xyR[0][1] - pvd0.xR[1] - pvd1.xR[1]) + sqr(v.xyR[0][2] - pvd0.xR[2] - pvd1.xR[2]));
                     vnorm = sqrt(sqr(v.xyR[0][0]) + sqr(v.xyR[0][1]) + sqr(v.xyR[0][2]));
                     if (pvdnorm > vnorm * testrbfunit_tol) {
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  }
               }
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

static bool testrbfunit_searcherr(RMatrix *y0, RMatrix *y1, ae_int_t n, ae_int_t ny, ae_int_t errtype, RVector *b1, RVector *delta) {
   ae_frame _frame_block;
   double oralerr;
   double iralerr;
   ae_int_t lb;
   ae_int_t rb;
   ae_int_t i;
   ae_int_t j;
   bool result;
   ae_frame_make(&_frame_block);
   DupMatrix(y0);
   DupMatrix(y1);
   DupVector(b1);
   DupVector(delta);
   NewVector(irerr, 0, DT_REAL);
   NewVector(orerr, 0, DT_REAL);
   ae_assert(n > 0, "SearchErr: invalid parameter N(N <= 0).");
   ae_assert(ny > 0, "SearchErr: invalid parameter NY(NY <= 0).");
   oralerr = 1.0E-1;
   iralerr = 1.0E-2;
   lb = 25;
   rb = 75;
   ae_vector_set_length(&orerr, ny);
   ae_vector_set_length(&irerr, ny);
   for (j = 0; j < ny; j++) {
      orerr.xR[j] = 0.0;
      irerr.xR[j] = 0.0;
   }
   if (errtype == 1) {
      for (i = 0; i < n; i++) {
         for (j = 0; j < ny; j++) {
            if (orerr.xR[j] < fabs(y0->xyR[i][j] - y1->xyR[i][j])) {
               orerr.xR[j] = fabs(y0->xyR[i][j] - y1->xyR[i][j]);
            }
         }
      }
      for (i = 0; i < ny; i++) {
         if (orerr.xR[i] > b1->xR[i] + delta->xR[i] || orerr.xR[i] < b1->xR[i] - delta->xR[i]) {
            result = true;
            ae_frame_leave();
            return result;
         }
      }
   } else {
      if (errtype == 2) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < ny; j++) {
               if (i > lb && i < rb) {
                  if (irerr.xR[j] < fabs(y0->xyR[i][j] - y1->xyR[i][j])) {
                     irerr.xR[j] = fabs(y0->xyR[i][j] - y1->xyR[i][j]);
                  }
               } else {
                  if (orerr.xR[j] < fabs(y0->xyR[i][j] - y1->xyR[i][j])) {
                     orerr.xR[j] = fabs(y0->xyR[i][j] - y1->xyR[i][j]);
                  }
               }
            }
         }
         for (i = 0; i < ny; i++) {
            if (orerr.xR[i] > oralerr || irerr.xR[i] > iralerr) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      } else {
         ae_assert(false, "SearchErr: invalid argument ErrType(ErrType neither 1 nor 2)");
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Function for testing basic functionality of RBF module on regular grids with
// multi-layer algorithm in 1D.
// ALGLIB: Copyright 2.03.2012 by Sergey Bochkanov
static bool basicmultilayerrbf1dtest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t linterm;
   ae_int_t n;
   double q;
   double r;
   ae_int_t errtype;
   ae_int_t nlayers;
   double a;
   double b;
   double f1;
   double f2;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewVector(delta, 0, DT_REAL);
   NewVector(a1, 0, DT_REAL);
   NewVector(b1, 0, DT_REAL);
   NewMatrix(gp, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(mody0, 0, 0, DT_REAL);
   NewMatrix(mody1, 0, 0, DT_REAL);
   NewMatrix(gy, 0, 0, DT_REAL);
   NewVector(gpgx0, 0, DT_REAL);
   NewVector(gpgx1, 0, DT_REAL);
   a = 1.0;
   b = 1.0 / 9.0;
   f1 = 1.0;
   f2 = 10.0;
   passcount = 5;
   n = 100;
   ae_vector_set_length(&gpgx0, n);
   ae_vector_set_length(&gpgx1, n);
   for (i = 0; i < n; i++) {
      gpgx0.xR[i] = (double)i / n;
      gpgx1.xR[i] = 0.0;
   }
   r = 1.0;
   for (pass = 0; pass < passcount; pass++) {
      nx = randominteger(2) + 2;
      ny = randominteger(3) + 1;
      linterm = randominteger(3) + 1;
      ae_vector_set_length(&x, nx);
      ae_vector_set_length(&y, ny);
      ae_vector_set_length(&a1, ny);
      ae_vector_set_length(&b1, ny);
      ae_vector_set_length(&delta, ny);
      ae_matrix_set_length(&mody0, n, ny);
      ae_matrix_set_length(&mody1, n, ny);
      for (i = 0; i < ny; i++) {
         a1.xR[i] = a + 0.01 * a * randommid();
         b1.xR[i] = b + 0.01 * b * randommid();
         delta.xR[i] = 0.35 * b1.xR[i];
      }
      ae_matrix_set_length(&gp, n, nx + ny);
   // create grid
      for (i = 0; i < n; i++) {
         for (j = 0; j < nx; j++) {
            gp.xyR[i][j] = 0.0;
         }
         gp.xyR[i][0] = (double)i / n;
         for (j = 0; j < ny; j++) {
            gp.xyR[i][nx + j] = a1.xR[j] * cos(f1 * 2 * pi * gp.xyR[i][0]) + b1.xR[j] * cos(f2 * 2 * pi * gp.xyR[i][0]);
            mody0.xyR[i][j] = gp.xyR[i][nx + j];
         }
      }
      q = 1.0;
      nlayers = 1;
      errtype = 1;
   // test multilayer algorithm with different parameters
      while (q >= 1 / (2 * f2)) {
         rbfcreate(nx, ny, &s);
         rbfsetalgomultilayer(&s, r, nlayers, 0.0);
         if (linterm == 1) {
            rbfsetlinterm(&s);
         }
         if (linterm == 2) {
            rbfsetconstterm(&s);
         }
         if (linterm == 3) {
            rbfsetzeroterm(&s);
         }
         rbfsetpoints(&s, &gp, n);
         rbfbuildmodel(&s, &rep);
         if (ny == 1) {
            for (i = 0; i < n; i++) {
               for (j = 0; j < nx; j++) {
                  x.xR[j] = gp.xyR[i][j];
               }
               if (nx == 2) {
                  mody1.xyR[i][0] = rbfcalc2(&s, x.xR[0], x.xR[1]);
               } else {
                  if (nx == 3) {
                     mody1.xyR[i][0] = rbfcalc3(&s, x.xR[0], x.xR[1], x.xR[2]);
                  } else {
                     ae_assert(false, "BasicMultiLayerRBFTest1D: Invalid variable NX(NX neither 2 nor 3)");
                  }
               }
            }
            if (testrbfunit_searcherr(&mody0, &mody1, n, ny, errtype, &b1, &delta)) {
               result = true;
               ae_frame_leave();
               return result;
            }
            if (nx == 2) {
               rbfgridcalc2(&s, &gpgx0, n, &gpgx1, n, &gy);
               for (i = 0; i < n; i++) {
                  mody1.xyR[i][0] = gy.xyR[i][0];
               }
            }
            if (testrbfunit_searcherr(&mody0, &mody1, n, ny, errtype, &b1, &delta)) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               x.xR[j] = gp.xyR[i][j];
            }
            rbfcalc(&s, &x, &y);
            for (j = 0; j < ny; j++) {
               mody1.xyR[i][j] = y.xR[j];
            }
         }
         if (testrbfunit_searcherr(&mody0, &mody1, n, ny, errtype, &b1, &delta)) {
            result = true;
            ae_frame_leave();
            return result;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               x.xR[j] = gp.xyR[i][j];
            }
            rbfcalcbuf(&s, &x, &y);
            for (j = 0; j < ny; j++) {
               mody1.xyR[i][j] = y.xR[j];
            }
         }
         if (testrbfunit_searcherr(&mody0, &mody1, n, ny, errtype, &b1, &delta)) {
            result = true;
            ae_frame_leave();
            return result;
         }
         q /= 2;
         nlayers++;
         if (errtype == 1 && q <= 1 / f2) {
            errtype = 2;
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// This function tests special cases:
// * uninitialized RBF model will correctly return zero values
// * RBF correctly handles 1 or 2 distinct points
// * when  we have many uniformly spaced points and one outlier, filter which
//   is applied to radii, makes all radii equal (RBF-QNN).
// * RBF-ML with NLayers=0 gives linear model
// * Hierarchical RBF with NLayers=0 gives linear model
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
static bool testrbfunit_specialtest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t t;
   ae_int_t termtype;
   double errtol;
   ae_int_t tmpnx;
   ae_int_t tmpny;
   ae_int_t tmpnc;
   double sx;
   double z;
   double va;
   double vb;
   double vc;
   double vd;
   ae_int_t modelversion;
   double vv;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(vf, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(xwr, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   errtol = 1.0E-9;
   result = false;
// Create model in the default state (no parameters/points specified).
// With probability 0.5 we do one of the following:
// * test that default state of the model is a zero model (all Calc()
//   functions return zero)
// * call RBFBuildModel() (without specifying anything) and test  that
//   all Calc() functions return zero.
//
// NOTE: because NX varies between 1 and 4, both V1 (old) and V2 RBFs
//       are tested.
   for (nx = 1; nx <= 4; nx++) {
      for (ny = 1; ny <= 3; ny++) {
         rbfcreate(nx, ny, &s);
         if (randombool()) {
            rbfbuildmodel(&s, &rep);
            if (rep.terminationtype <= 0) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:202");
               ae_frame_leave();
               return result;
            }
         }
         ae_vector_set_length(&x, nx);
         ae_vector_set_length(&y, 1);
         for (i = 0; i < nx; i++) {
            x.xR[i] = randommid();
         }
         rbfcalc(&s, &x, &y);
         if (y.cnt != ny) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:213");
            ae_frame_leave();
            return result;
         }
         for (i = 0; i < ny; i++) {
            if (y.xR[i] != 0.0) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:219");
               ae_frame_leave();
               return result;
            }
         }
      }
   }
// Create default model with 1 point and different types of linear term.
// Test algorithm on such dataset.
//
// NOTE: because NX varies between 1 and 4, both V1 (old) and V2 RBFs
//       are tested.
   for (nx = 1; nx <= 4; nx++) {
      for (ny = 1; ny <= 3; ny++) {
         rbfcreate(nx, ny, &s);
         for (termtype = 0; termtype <= 1; termtype++) {
            if (termtype == 0) {
               rbfsetlinterm(&s);
            }
            if (termtype == 1) {
               rbfsetconstterm(&s);
            }
            ae_matrix_set_length(&xy, 1, nx + ny);
            for (i = 0; i < nx + ny; i++) {
               xy.xyR[0][i] = randommid();
            }
            rbfsetpoints(&s, &xy, 1);
            rbfbuildmodel(&s, &rep);
            if (rep.terminationtype <= 0) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:248");
               ae_frame_leave();
               return result;
            }
         // First, test that model exactly reproduces our dataset in the specified point
            ae_vector_set_length(&x, nx);
            for (i = 0; i < nx; i++) {
               x.xR[i] = xy.xyR[0][i];
            }
            rbfcalc(&s, &x, &y);
            if (y.cnt != ny) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:261");
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < ny; i++) {
               if (fabs(y.xR[i] - xy.xyR[0][nx + i]) > errtol) {
                  set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:267");
                  ae_frame_leave();
                  return result;
               }
            }
         // Second, test that model is constant
            for (i = 0; i < nx; i++) {
               x.xR[i] = randommid();
            }
            rbfcalc(&s, &x, &y);
            if (y.cnt != ny) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:279");
               ae_frame_leave();
               return result;
            }
            for (i = 0; i < ny; i++) {
               if (fabs(y.xR[i] - xy.xyR[0][nx + i]) > errtol) {
                  set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:285");
                  ae_frame_leave();
                  return result;
               }
            }
         }
      }
   }
// Create model with 2 points and different types of linear term.
// Test algorithm on such dataset.
   for (nx = 2; nx <= 3; nx++) {
      for (ny = 1; ny <= 3; ny++) {
         rbfcreate(nx, ny, &s);
         for (termtype = 0; termtype <= 1; termtype++) {
            if (termtype == 0) {
               rbfsetlinterm(&s);
            }
            if (termtype == 1) {
               rbfsetconstterm(&s);
            }
            if (termtype == 2) {
               rbfsetzeroterm(&s);
            }
            ae_matrix_set_length(&xy, 2, nx + ny);
            for (i = 0; i < nx + ny; i++) {
               xy.xyR[0][i] = randommid();
            }
            for (i = 0; i < nx + ny; i++) {
               xy.xyR[1][i] = xy.xyR[0][i] + 1.0;
            }
            rbfsetpoints(&s, &xy, 2);
            rbfbuildmodel(&s, &rep);
            if (rep.terminationtype <= 0) {
               result = true;
               ae_frame_leave();
               return result;
            }
            for (j = 0; j <= 1; j++) {
               ae_vector_set_length(&x, nx);
               for (i = 0; i < nx; i++) {
                  x.xR[i] = xy.xyR[j][i];
               }
               rbfcalc(&s, &x, &y);
               if (y.cnt != ny) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
               for (i = 0; i < ny; i++) {
                  if (fabs(y.xR[i] - xy.xyR[j][nx + i]) > errtol) {
                     result = true;
                     ae_frame_leave();
                     return result;
                  }
               }
            }
         }
      }
   }
// Generate a set of points (xi,yi) = (SX*i,0), and one
// outlier (x_far,y_far)=(-1000*SX,0).
//
// Radii filtering should place a bound on the radius of outlier.
   for (nx = 2; nx <= 3; nx++) {
      for (ny = 1; ny <= 3; ny++) {
         sx = exp(-5 + 10 * randomreal());
         rbfcreate(nx, ny, &s);
         ae_matrix_set_length(&xy, 20, nx + ny);
         for (i = 0; i < xy.rows; i++) {
            xy.xyR[i][0] = sx * i;
            for (j = 1; j < nx; j++) {
               xy.xyR[i][j] = 0.0;
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = randomreal();
            }
         }
         xy.xyR[xy.rows - 1][0] = -1000 * sx;
         rbfsetpoints(&s, &xy, xy.rows);
      // Try random Z from [1,5]
         z = 1 + randomreal() * 4;
         rbfsetalgoqnn(&s, 1.0, z);
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            result = true;
            ae_frame_leave();
            return result;
         }
         rbfunpack(&s, &tmpnx, &tmpny, &xwr, &tmpnc, &v, &modelversion);
         if (((((tmpnx != nx || tmpny != ny) || tmpnc != xy.rows) || xwr.cols != nx + ny + 1) || xwr.rows != tmpnc) || modelversion != 1) {
            result = true;
            ae_frame_leave();
            return result;
         }
         for (i = 0; i < tmpnc - 1; i++) {
            if (fabs(xwr.xyR[i][nx + ny] - sx) > errtol) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
         if (fabs(xwr.xyR[tmpnc - 1][nx + ny] - z * sx) > errtol) {
            result = true;
            ae_frame_leave();
            return result;
         }
      }
   }
// RBF-ML with NLayers=0 gives us linear model.
//
// In order to perform this test, we use test function which
// is perfectly linear and see whether RBF model is able to
// reproduce such function.
   n = 5;
   for (ny = 1; ny <= 3; ny++) {
      va = randommid();
      vb = randommid();
      vc = randommid();
      vd = randommid();
   // Test NX=2.
   // Generate linear function using random coefficients VA/VB/VC.
   // Function is K-dimensional vector-valued, each component has slightly
   // different coefficients.
      ae_matrix_set_length(&xy, n * n, 2 + ny);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            xy.xyR[n * i + j][0] = (double)i;
            xy.xyR[n * i + j][1] = (double)j;
            for (k = 0; k < ny; k++) {
               xy.xyR[n * i + j][2 + k] = (va + 0.1 * k) * i + (vb + 0.2 * k) * j + (vc + 0.3 * k);
            }
         }
      }
      rbfcreate(2, ny, &s);
      rbfsetpoints(&s, &xy, n * n);
      rbfsetalgomultilayer(&s, 1.0, 0, 0.01);
      rbfbuildmodel(&s, &rep);
      if (rep.terminationtype <= 0) {
         result = true;
         ae_frame_leave();
         return result;
      }
      ae_vector_set_length(&x, 2);
      x.xR[0] = (n - 1) * randomreal();
      x.xR[1] = (n - 1) * randomreal();
      if (ny == 1 && fabs(rbfcalc2(&s, x.xR[0], x.xR[1]) - (va * x.xR[0] + vb * x.xR[1] + vc)) > errtol) {
         result = true;
         ae_frame_leave();
         return result;
      }
      rbfcalc(&s, &x, &y);
      for (k = 0; k < ny; k++) {
         if (fabs(y.xR[k] - ((va + 0.1 * k) * x.xR[0] + (vb + 0.2 * k) * x.xR[1] + (vc + 0.3 * k))) > errtol) {
            result = true;
            ae_frame_leave();
            return result;
         }
      }
   // Test NX=3.
   // Generate linear function using random coefficients VA/VB/VC/VC.
   // Function is K-dimensional vector-valued, each component has slightly
   // different coefficients.
      ae_matrix_set_length(&xy, n * n * n, 3 + ny);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            for (t = 0; t < n; t++) {
               xy.xyR[n * n * i + n * j + t][0] = (double)i;
               xy.xyR[n * n * i + n * j + t][1] = (double)j;
               xy.xyR[n * n * i + n * j + t][2] = (double)t;
               for (k = 0; k < ny; k++) {
                  xy.xyR[n * n * i + n * j + t][3 + k] = (va + 0.1 * k) * i + (vb + 0.2 * k) * j + (vc + 0.3 * k) * t + (vd + 0.4 * k);
               }
            }
         }
      }
      rbfcreate(3, ny, &s);
      rbfsetpoints(&s, &xy, n * n * n);
      rbfsetalgomultilayer(&s, 1.0, 0, 0.01);
      rbfbuildmodel(&s, &rep);
      if (rep.terminationtype <= 0) {
         result = true;
         ae_frame_leave();
         return result;
      }
      ae_vector_set_length(&x, 3);
      x.xR[0] = (n - 1) * randomreal();
      x.xR[1] = (n - 1) * randomreal();
      x.xR[2] = (n - 1) * randomreal();
      if (ny == 1 && fabs(rbfcalc3(&s, x.xR[0], x.xR[1], x.xR[2]) - (va * x.xR[0] + vb * x.xR[1] + vc * x.xR[2] + vd)) > errtol) {
         result = true;
         ae_frame_leave();
         return result;
      }
      rbfcalc(&s, &x, &y);
      for (k = 0; k < ny; k++) {
         if (fabs(y.xR[k] - ((va + 0.1 * k) * x.xR[0] + (vb + 0.2 * k) * x.xR[1] + (vc + 0.3 * k) * x.xR[2] + (vd + 0.4 * k))) > errtol) {
            result = true;
            ae_frame_leave();
            return result;
         }
      }
   }
// HierarchicalRBF with NLayers=0 gives us linear model.
//
// In order to perform this test, we use test function which
// is perfectly linear and see whether RBF model is able to
// reproduce such function.
   n = 15;
   for (nx = 1; nx <= 5; nx++) {
      for (ny = 1; ny <= 3; ny++) {
         ae_matrix_set_length(&vf, ny, nx + 1);
         for (i = 0; i < ny; i++) {
            for (j = 0; j <= nx; j++) {
               vf.xyR[i][j] = randommid();
            }
         }
         ae_matrix_set_length(&xy, n, nx + ny);
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = randomreal();
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = vf.xyR[j][nx];
               for (k = 0; k < nx; k++) {
                  xy.xyR[i][nx + j] += vf.xyR[j][k] * xy.xyR[i][k];
               }
            }
         }
         rbfcreate(nx, ny, &s);
         rbfsetpoints(&s, &xy, n);
         rbfsetalgohierarchical(&s, 1.0, 0, 0.0);
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:525");
            ae_frame_leave();
            return result;
         }
         ae_vector_set_length(&x, nx);
         for (i = 0; i < nx; i++) {
            x.xR[i] = randomreal();
         }
         rbfcalc(&s, &x, &y);
         for (k = 0; k < ny; k++) {
            vv = vf.xyR[k][nx];
            for (j = 0; j < nx; j++) {
               vv += vf.xyR[k][j] * x.xR[j];
            }
            set_error_flag(&result, fabs(vv - y.xR[k]) > errtol, __FILE__, __LINE__, "testrbfunit.ap:537");
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Function for testing basic functionality of RBF module on regular grids.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
static bool testrbfunit_basicrbftest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t k2;
   ae_int_t linterm;
   ae_int_t np;
   double sx;
   double sy;
   double zx;
   double px;
   double zy;
   double py;
   double q;
   double z;
   ae_int_t unx;
   ae_int_t uny;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   ae_int_t fidx;
   double eps;
   ae_int_t modelversion;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewObj(rbfcalcbuffer, calcbuf);
   NewVector(point, 0, DT_REAL);
   NewMatrix(gp, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(gy, 0, 0, DT_REAL);
   NewMatrix(xwr, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewVector(gpgx0, 0, DT_REAL);
   NewVector(gpgx1, 0, DT_REAL);
   zx = 10.0;
   px = 15.0;
   zy = 10.0;
   py = 15.0;
   eps = 1.0E-6;
// Problem types:
// * 2 and 3-dimensional problems
// * problems with zero, constant, linear terms
// * different scalings of X and Y values (1.0, 1E-15, 1E+15)
// * regular grids different grid sizes (from 2 to 4 points for each dimension)
//
// We check that:
// * RBF model correctly reproduces function value (testes with different Calc() functions)
// * unpacked model containt correct radii
// * linear term has correct form
   for (nx = 2; nx <= 3; nx++) {
      for (ny = 1; ny <= 3; ny++) {
         for (linterm = 1; linterm <= 3; linterm++) {
         // prepare test problem
            sx = pow(zx, px * (randominteger(3) - 1));
            sy = pow(zy, py * (randominteger(3) - 1));
            ae_vector_set_length(&x, nx);
            ae_vector_set_length(&y, ny);
            ae_vector_set_length(&point, nx);
            rbfcreate(nx, ny, &s);
            rbfsetcond(&s, testrbfunit_heps, testrbfunit_heps, testrbfunit_mxits);
            q = 0.25 + randomreal();
            z = 4.5 + randomreal();
            rbfsetalgoqnn(&s, q, z);
            if (linterm == 1) {
               rbfsetlinterm(&s);
            }
            if (linterm == 2) {
               rbfsetconstterm(&s);
            }
            if (linterm == 3) {
               rbfsetzeroterm(&s);
            }
         // start points for grid
            for (i = 0; i < nx; i++) {
               point.xR[i] = sx * randommid();
            }
         // 2-dimensional test problem
            if (nx == 2) {
               for (k0 = 2; k0 <= 4; k0++) {
                  for (k1 = 2; k1 <= 4; k1++) {
                     np = k0 * k1;
                     ae_matrix_set_length(&gp, np, nx + ny);
                  // create grid
                     for (i = 0; i < k0; i++) {
                        for (j = 0; j < k1; j++) {
                           gp.xyR[i * k1 + j][0] = point.xR[0] + sx * i;
                           gp.xyR[i * k1 + j][1] = point.xR[1] + sx * j;
                           for (k = 0; k < ny; k++) {
                              gp.xyR[i * k1 + j][nx + k] = sy * randommid();
                           }
                        }
                     }
                     rbfsetpoints(&s, &gp, np);
                     rbfbuildmodel(&s, &rep);
                     rbfcreatecalcbuffer(&s, &calcbuf);
                     if (ny == 1) {
                        ae_vector_set_length(&gpgx0, k0);
                        ae_vector_set_length(&gpgx1, k1);
                        for (i = 0; i < k0; i++) {
                           gpgx0.xR[i] = point.xR[0] + sx * i;
                        }
                        for (i = 0; i < k1; i++) {
                           gpgx1.xR[i] = point.xR[1] + sx * i;
                        }
                        rbfgridcalc2(&s, &gpgx0, k0, &gpgx1, k1, &gy);
                        for (i = 0; i < k0; i++) {
                           for (j = 0; j < k1; j++) {
                              if (fabs(gy.xyR[i][j] - gp.xyR[i * k1 + j][nx]) > sy * eps) {
                                 result = true;
                                 ae_frame_leave();
                                 return result;
                              }
                           }
                        }
                     }
                     for (i = 0; i < np; i++) {
                     // For each row we randomly choose a function to test
                     // and call it. We do not call multiple functions per
                     // row because carry-over effects may mask errors in
                     // some function (say, it is possible that function
                     // simply returns results from previous call of some
                     // other function which were stored in the RBF model;
                     // in this case, previous call with same parameters
                     // may hide deficiencies in the function).
                        x.xR[0] = gp.xyR[i][0];
                        x.xR[1] = gp.xyR[i][1];
                        fidx = randominteger(4);
                        if (fidx == 0 && ny == 1) {
                           y.xR[0] = rbfcalc2(&s, x.xR[0], x.xR[1]);
                           if (fabs(gp.xyR[i][nx] - y.xR[0]) > sy * eps) {
                              result = true;
                              ae_frame_leave();
                              return result;
                           }
                        }
                        if (fidx == 1) {
                           rbfcalc(&s, &x, &y);
                           for (j = 0; j < ny; j++) {
                              if (fabs(gp.xyR[i][nx + j] - y.xR[j]) > sy * eps) {
                                 result = true;
                                 ae_frame_leave();
                                 return result;
                              }
                           }
                        }
                        if (fidx == 2) {
                           rbfcalcbuf(&s, &x, &y);
                           for (j = 0; j < ny; j++) {
                              if (fabs(gp.xyR[i][nx + j] - y.xR[j]) > sy * eps) {
                                 result = true;
                                 ae_frame_leave();
                                 return result;
                              }
                           }
                        }
                        if (fidx == 3) {
                           rbftscalcbuf(&s, &calcbuf, &x, &y);
                           for (j = 0; j < ny; j++) {
                              if (fabs(gp.xyR[i][nx + j] - y.xR[j]) > sy * eps) {
                                 result = true;
                                 ae_frame_leave();
                                 return result;
                              }
                           }
                        }
                     }
                  // test for RBFUnpack
                     rbfunpack(&s, &unx, &uny, &xwr, &np, &v, &modelversion);
                     if ((((((nx != unx || ny != uny) || xwr.rows != np) || xwr.cols != nx + ny + 1) || v.rows != ny) || v.cols != nx + 1) || modelversion != 1) {
                        set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:735");
                        ae_frame_leave();
                        return result;
                     }
                     for (i = 0; i < np; i++) {
                        if (fabs(xwr.xyR[i][unx + uny] - q * sx) > sx * eps) {
                           result = true;
                           ae_frame_leave();
                           return result;
                        }
                     }
                     if (linterm == 2) {
                        for (i = 0; i < unx; i++) {
                           for (j = 0; j < uny; j++) {
                              if (v.xyR[j][i] != 0.0) {
                                 result = true;
                                 ae_frame_leave();
                                 return result;
                              }
                           }
                        }
                     }
                     if (linterm == 3) {
                        for (i = 0; i <= unx; i++) {
                           for (j = 0; j < uny; j++) {
                              if (v.xyR[j][i] != 0.0) {
                                 result = true;
                                 ae_frame_leave();
                                 return result;
                              }
                           }
                        }
                     }
                  }
               }
            }
         // 3-dimensional test problems
            if (nx == 3) {
               for (k0 = 2; k0 <= 4; k0++) {
                  for (k1 = 2; k1 <= 4; k1++) {
                     for (k2 = 2; k2 <= 4; k2++) {
                        np = k0 * k1 * k2;
                        ae_matrix_set_length(&gp, np, nx + ny);
                     // create grid
                        for (i = 0; i < k0; i++) {
                           for (j = 0; j < k1; j++) {
                              for (k = 0; k < k2; k++) {
                                 gp.xyR[(i * k1 + j) * k2 + k][0] = point.xR[0] + sx * i;
                                 gp.xyR[(i * k1 + j) * k2 + k][1] = point.xR[1] + sx * j;
                                 gp.xyR[(i * k1 + j) * k2 + k][2] = point.xR[2] + sx * k;
                                 for (l = 0; l < ny; l++) {
                                    gp.xyR[(i * k1 + j) * k2 + k][nx + l] = sy * randommid();
                                 }
                              }
                           }
                        }
                        rbfsetpoints(&s, &gp, np);
                        rbfbuildmodel(&s, &rep);
                        rbfcreatecalcbuffer(&s, &calcbuf);
                        for (i = 0; i < np; i++) {
                        // For each row we randomly choose a function to test
                        // and call it. We do not call multiple functions per
                        // row because carry-over effects may mask errors in
                        // some function (say, it is possible that function
                        // simply returns results from previous call of some
                        // other function which were stored in the RBF model;
                        // in this case, previous call with same parameters
                        // may hide deficiencies in the function).
                           x.xR[0] = gp.xyR[i][0];
                           x.xR[1] = gp.xyR[i][1];
                           x.xR[2] = gp.xyR[i][2];
                           fidx = randominteger(4);
                           if (fidx == 0 && ny == 1) {
                              y.xR[0] = rbfcalc3(&s, x.xR[0], x.xR[1], x.xR[2]);
                              if (fabs(gp.xyR[i][nx] - y.xR[0]) > sy * eps) {
                                 result = true;
                                 ae_frame_leave();
                                 return result;
                              }
                           }
                           if (fidx == 1) {
                              rbfcalc(&s, &x, &y);
                              for (j = 0; j < ny; j++) {
                                 if (fabs(gp.xyR[i][nx + j] - y.xR[j]) > sy * eps) {
                                    result = true;
                                    ae_frame_leave();
                                    return result;
                                 }
                              }
                           }
                           if (fidx == 2) {
                              rbfcalcbuf(&s, &x, &y);
                              for (j = 0; j < ny; j++) {
                                 if (fabs(gp.xyR[i][nx + j] - y.xR[j]) > sy * eps) {
                                    result = true;
                                    ae_frame_leave();
                                    return result;
                                 }
                              }
                           }
                           if (fidx == 3) {
                              rbftscalcbuf(&s, &calcbuf, &x, &y);
                              for (j = 0; j < ny; j++) {
                                 if (fabs(gp.xyR[i][nx + j] - y.xR[j]) > sy * eps) {
                                    result = true;
                                    ae_frame_leave();
                                    return result;
                                 }
                              }
                           }
                        }
                     // test for RBFUnpack
                        rbfunpack(&s, &unx, &uny, &xwr, &np, &v, &modelversion);
                        if ((((((nx != unx || ny != uny) || xwr.rows != np) || xwr.cols != nx + ny + 1) || v.rows != ny) || v.cols != nx + 1) || modelversion != 1) {
                           set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:852");
                           ae_frame_leave();
                           return result;
                        }
                        for (i = 0; i < np; i++) {
                           if (fabs(xwr.xyR[i][unx + uny] - q * sx) > sx * eps) {
                              result = true;
                              ae_frame_leave();
                              return result;
                           }
                        }
                        if (linterm == 2) {
                           for (i = 0; i < unx; i++) {
                              for (j = 0; j < uny; j++) {
                                 if (v.xyR[j][i] != 0.0) {
                                    result = true;
                                    ae_frame_leave();
                                    return result;
                                 }
                              }
                           }
                        }
                        if (linterm == 3) {
                           for (i = 0; i <= unx; i++) {
                              for (j = 0; j < uny; j++) {
                                 if (v.xyR[j][i] != 0.0) {
                                    result = true;
                                    ae_frame_leave();
                                    return result;
                                 }
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// Function for testing RBF module on irregular grids.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
static bool testrbfunit_irregularrbftest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t k2;
   ae_int_t linterm;
   ae_int_t np;
   double sx;
   double sy;
   double zx;
   double px;
   double zy;
   double py;
   double q;
   double z;
   double noiselevel;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   double eps;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewVector(point, 0, DT_REAL);
   NewMatrix(gp, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(gy, 0, 0, DT_REAL);
   zx = 10.0;
   px = 15.0;
   zy = 10.0;
   py = 15.0;
   noiselevel = 0.1;
   eps = 1.0E-6;
// Problem types:
// * 2 and 3-dimensional problems
// * problems with zero, constant, linear terms
// * different scalings of X and Y values (1.0, 1E-15, 1E+15)
// * noisy grids, which are just regular grids with different grid sizes
//   (from 2 to 4 points for each dimension) and moderate amount of random
//   noise added to all node positions.
//
// We check that:
// * RBF model correctly reproduces function value (testes with different Calc() functions)
   for (nx = 2; nx <= 3; nx++) {
      for (ny = 1; ny <= 3; ny++) {
         for (linterm = 1; linterm <= 3; linterm++) {
         // prepare test problem
            sx = pow(zx, px * (randominteger(3) - 1));
            sy = pow(zy, py * (randominteger(3) - 1));
            ae_vector_set_length(&x, nx);
            ae_vector_set_length(&y, ny);
            ae_vector_set_length(&point, nx);
            rbfcreate(nx, ny, &s);
            rbfsetcond(&s, testrbfunit_heps, testrbfunit_heps, testrbfunit_mxits);
            q = 0.25 + randomreal();
            z = 4.5 + randomreal();
            rbfsetalgoqnn(&s, q, z);
            if (linterm == 1) {
               rbfsetlinterm(&s);
            }
            if (linterm == 2) {
               rbfsetconstterm(&s);
            }
            if (linterm == 3) {
               rbfsetzeroterm(&s);
            }
         // start points for grid
            for (i = 0; i < nx; i++) {
               point.xR[i] = sx * randommid();
            }
         // 2-dimensional test problems
            if (nx == 2) {
               for (k0 = 2; k0 <= 4; k0++) {
                  for (k1 = 2; k1 <= 4; k1++) {
                     np = k0 * k1;
                     ae_matrix_set_length(&gp, np, nx + ny);
                  // create grid
                     for (i = 0; i < k0; i++) {
                        for (j = 0; j < k1; j++) {
                           gp.xyR[i * k1 + j][0] = point.xR[0] + sx * i + noiselevel * sx * randommid();
                           gp.xyR[i * k1 + j][1] = point.xR[1] + sx * j + noiselevel * sx * randommid();
                           for (k = 0; k < ny; k++) {
                              gp.xyR[i * k1 + j][nx + k] = sy * randommid();
                           }
                        }
                     }
                     rbfsetpoints(&s, &gp, np);
                     rbfbuildmodel(&s, &rep);
                     for (i = 0; i < np; i++) {
                        x.xR[0] = gp.xyR[i][0];
                        x.xR[1] = gp.xyR[i][1];
                        if (ny == 1) {
                           y.xR[0] = rbfcalc2(&s, x.xR[0], x.xR[1]);
                           if (fabs(gp.xyR[i][nx] - y.xR[0]) > sy * eps) {
                              result = true;
                              ae_frame_leave();
                              return result;
                           }
                        }
                        rbfcalc(&s, &x, &y);
                        for (j = 0; j < ny; j++) {
                           if (fabs(gp.xyR[i][nx + j] - y.xR[j]) > sy * eps) {
                              result = true;
                              ae_frame_leave();
                              return result;
                           }
                        }
                        rbfcalcbuf(&s, &x, &y);
                        for (j = 0; j < ny; j++) {
                           if (fabs(gp.xyR[i][nx + j] - y.xR[j]) > sy * eps) {
                              result = true;
                              ae_frame_leave();
                              return result;
                           }
                        }
                     }
                  }
               }
            }
         // 2-dimensional test problems
            if (nx == 3) {
               for (k0 = 2; k0 <= 4; k0++) {
                  for (k1 = 2; k1 <= 4; k1++) {
                     for (k2 = 2; k2 <= 4; k2++) {
                        np = k0 * k1 * k2;
                        ae_matrix_set_length(&gp, np, nx + ny);
                     // create grid
                        for (i = 0; i < k0; i++) {
                           for (j = 0; j < k1; j++) {
                              for (k = 0; k < k2; k++) {
                                 gp.xyR[(i * k1 + j) * k2 + k][0] = point.xR[0] + sx * i + noiselevel * sx * randommid();
                                 gp.xyR[(i * k1 + j) * k2 + k][1] = point.xR[1] + sx * j + noiselevel * sx * randommid();
                                 gp.xyR[(i * k1 + j) * k2 + k][2] = point.xR[2] + sx * k + noiselevel * sx * randommid();
                                 for (l = 0; l < ny; l++) {
                                    gp.xyR[(i * k1 + j) * k2 + k][nx + l] = sy * randommid();
                                 }
                              }
                           }
                        }
                        rbfsetpoints(&s, &gp, np);
                        rbfbuildmodel(&s, &rep);
                        for (i = 0; i < np; i++) {
                           x.xR[0] = gp.xyR[i][0];
                           x.xR[1] = gp.xyR[i][1];
                           x.xR[2] = gp.xyR[i][2];
                           if (ny == 1) {
                              y.xR[0] = rbfcalc3(&s, x.xR[0], x.xR[1], x.xR[2]);
                              if (fabs(gp.xyR[i][nx] - y.xR[0]) > sy * eps) {
                                 result = true;
                                 ae_frame_leave();
                                 return result;
                              }
                           }
                           rbfcalc(&s, &x, &y);
                           for (j = 0; j < ny; j++) {
                              if (fabs(gp.xyR[i][nx + j] - y.xR[j]) > sy * eps) {
                                 result = true;
                                 ae_frame_leave();
                                 return result;
                              }
                           }
                           rbfcalcbuf(&s, &x, &y);
                           for (j = 0; j < ny; j++) {
                              if (fabs(gp.xyR[i][nx + j] - y.xR[j]) > sy * eps) {
                                 result = true;
                                 ae_frame_leave();
                                 return result;
                              }
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// The test does  check, that  algorithm  can build linear model for the data
// sets, when Y depends on X linearly.
// ALGLIB: Copyright 13.12.2011 by Sergey Bochkanov
static bool testrbfunit_linearitymodelrbftest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t k2;
   ae_int_t linterm;
   ae_int_t np;
   double sx;
   double sy;
   double zx;
   double px;
   double zy;
   double py;
   double q;
   double z;
   ae_int_t unx;
   ae_int_t uny;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   ae_int_t modelversion;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewVector(point, 0, DT_REAL);
   NewVector(a, 0, DT_REAL);
   NewMatrix(gp, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(xwr, 0, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   zx = 10.0;
   px = 15.0;
   zy = 10.0;
   py = 15.0;
   ny = 1;
   for (nx = 2; nx <= 3; nx++) {
      for (linterm = 1; linterm <= 3; linterm++) {
      // prepare test problem
         sx = pow(zx, px * (randominteger(3) - 1));
         sy = pow(zy, py * (randominteger(3) - 1));
         ae_vector_set_length(&x, nx);
         ae_vector_set_length(&y, ny);
         ae_vector_set_length(&point, nx);
         rbfcreate(nx, ny, &s);
         q = 0.25 + randomreal();
         z = 4.5 + randomreal();
         rbfsetalgoqnn(&s, q, z);
         ae_vector_set_length(&a, nx + 1);
         if (linterm == 1) {
            rbfsetlinterm(&s);
            for (i = 0; i < nx; i++) {
               a.xR[i] = sy * randommid() / sx;
            }
            a.xR[nx] = sy * randommid();
         }
         if (linterm == 2) {
            rbfsetconstterm(&s);
            for (i = 0; i < nx; i++) {
               a.xR[i] = 0.0;
            }
            a.xR[nx] = sy * randommid();
         }
         if (linterm == 3) {
            rbfsetzeroterm(&s);
            for (i = 0; i <= nx; i++) {
               a.xR[i] = 0.0;
            }
         }
      // start points for grid
         for (i = 0; i < nx; i++) {
            point.xR[i] = sx * randommid();
         }
         if (nx == 2) {
            for (k0 = 2; k0 <= 4; k0++) {
               for (k1 = 2; k1 <= 4; k1++) {
                  np = k0 * k1;
                  ae_matrix_set_length(&gp, np, nx + ny);
               // create grid
                  for (i = 0; i < k0; i++) {
                     for (j = 0; j < k1; j++) {
                        gp.xyR[i * k1 + j][0] = point.xR[0] + sx * i;
                        gp.xyR[i * k1 + j][1] = point.xR[1] + sx * j;
                        gp.xyR[i * k1 + j][nx] = a.xR[nx];
                        for (k = 0; k < nx; k++) {
                           gp.xyR[i * k1 + j][nx] += gp.xyR[i * k1 + j][k] * a.xR[k];
                        }
                     }
                  }
                  rbfsetpoints(&s, &gp, np);
                  rbfbuildmodel(&s, &rep);
               // test for RBFUnpack
                  rbfunpack(&s, &unx, &uny, &xwr, &np, &v, &modelversion);
                  if ((((((nx != unx || ny != uny) || xwr.rows != np) || xwr.cols != nx + ny + 1) || v.rows != ny) || v.cols != nx + 1) || modelversion != 1) {
                     result = true;
                     ae_frame_leave();
                     return result;
                  }
                  for (i = 0; i < nx; i++) {
                     if (fabs(v.xyR[0][i] - a.xR[i]) > sy / sx * testrbfunit_tol) {
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  }
                  if (fabs(v.xyR[0][nx] - a.xR[nx]) > sy * testrbfunit_tol) {
                     result = true;
                     ae_frame_leave();
                     return result;
                  }
                  for (i = 0; i < np; i++) {
                     if (fabs(xwr.xyR[i][unx]) > sy * testrbfunit_tol) {
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                  }
               }
            }
         }
         if (nx == 3) {
            for (k0 = 2; k0 <= 4; k0++) {
               for (k1 = 2; k1 <= 4; k1++) {
                  for (k2 = 2; k2 <= 4; k2++) {
                     np = k0 * k1 * k2;
                     ae_matrix_set_length(&gp, np, nx + ny);
                  // create grid
                     for (i = 0; i < k0; i++) {
                        for (j = 0; j < k1; j++) {
                           for (k = 0; k < k2; k++) {
                              gp.xyR[(i * k1 + j) * k2 + k][0] = point.xR[0] + sx * i;
                              gp.xyR[(i * k1 + j) * k2 + k][1] = point.xR[1] + sx * j;
                              gp.xyR[(i * k1 + j) * k2 + k][2] = point.xR[2] + sx * k;
                              gp.xyR[(i * k1 + j) * k2 + k][nx] = a.xR[nx];
                              for (l = 0; l < nx; l++) {
                                 gp.xyR[(i * k1 + j) * k2 + k][nx] += gp.xyR[(i * k1 + j) * k2 + k][l] * a.xR[l];
                              }
                           }
                        }
                     }
                     rbfsetpoints(&s, &gp, np);
                     rbfbuildmodel(&s, &rep);
                  // test for RBFUnpack
                     rbfunpack(&s, &unx, &uny, &xwr, &np, &v, &modelversion);
                     if ((((((nx != unx || ny != uny) || xwr.rows != np) || xwr.cols != nx + ny + 1) || v.rows != ny) || v.cols != nx + 1) || modelversion != 1) {
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                     for (i = 0; i < nx; i++) {
                        if (fabs(v.xyR[0][i] - a.xR[i]) > sy / sx * testrbfunit_tol) {
                           result = true;
                           ae_frame_leave();
                           return result;
                        }
                     }
                     if (fabs(v.xyR[0][nx] - a.xR[nx]) > sy * testrbfunit_tol) {
                        result = true;
                        ae_frame_leave();
                        return result;
                     }
                     for (i = 0; i < np; i++) {
                        if (fabs(xwr.xyR[i][unx]) > sy * testrbfunit_tol) {
                           result = true;
                           ae_frame_leave();
                           return result;
                        }
                     }
                  }
               }
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// This function tests serialization
// ALGLIB: Copyright 02.02.2012 by Sergey Bochkanov
static bool testrbfunit_serializationtest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t k2;
   ae_int_t i;
   ae_int_t i0;
   ae_int_t i1;
   ae_int_t i2;
   ae_int_t j;
   ae_int_t k;
   double rbase;
   ae_int_t nlayers;
   ae_int_t bf;
   ae_int_t gridsize;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfmodel, s2);
   NewObj(rbfreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(testpoint, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(scalevec, 0, DT_REAL);
   result = false;
// This function generates random 2 or 3 dimensional problem,
// builds RBF model (QNN is used), serializes/unserializes it, then compares
// models by calculating model value at some random point.
//
// Additionally we test that new model (one which was restored
// after serialization) has lost all model construction settings,
// i.e. if we call RBFBuildModel() on a NEW model, we will get
// empty (zero) model.
   for (nx = 2; nx <= 3; nx++) {
      for (ny = 1; ny <= 2; ny++) {
      // prepare test problem
         rbfcreate(nx, ny, &s);
         rbfsetalgoqnn(&s, 1.0, 5.0);
         rbfsetlinterm(&s);
         if (nx == 2) {
         // 2-dimensional problem
            k0 = 2 + randominteger(4);
            k1 = 2 + randominteger(4);
            ae_matrix_set_length(&xy, k0 * k1, nx + ny);
            for (i0 = 0; i0 < k0; i0++) {
               for (i1 = 0; i1 < k1; i1++) {
                  xy.xyR[i0 * k1 + i1][0] = i0 + 0.1 * randommid();
                  xy.xyR[i0 * k1 + i1][1] = i1 + 0.1 * randommid();
                  for (j = 0; j < ny; j++) {
                     xy.xyR[i0 * k1 + i1][nx + j] = randommid();
                  }
               }
            }
            ae_vector_set_length(&testpoint, nx);
            testpoint.xR[0] = randomreal() * (k0 - 1);
            testpoint.xR[1] = randomreal() * (k1 - 1);
         } else {
         // 3-dimensional problem
            k0 = 2 + randominteger(4);
            k1 = 2 + randominteger(4);
            k2 = 2 + randominteger(4);
            ae_matrix_set_length(&xy, k0 * k1 * k2, nx + ny);
            for (i0 = 0; i0 < k0; i0++) {
               for (i1 = 0; i1 < k1; i1++) {
                  for (i2 = 0; i2 < k2; i2++) {
                     xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][0] = i0 + 0.1 * randommid();
                     xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][1] = i1 + 0.1 * randommid();
                     xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][2] = i2 + 0.1 * randommid();
                     for (j = 0; j < ny; j++) {
                        xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][nx + j] = randommid();
                     }
                  }
               }
            }
            ae_vector_set_length(&testpoint, nx);
            testpoint.xR[0] = randomreal() * (k0 - 1);
            testpoint.xR[1] = randomreal() * (k1 - 1);
            testpoint.xR[2] = randomreal() * (k2 - 1);
         }
         rbfsetpoints(&s, &xy, xy.rows);
      // Build model, serialize, compare
         rbfbuildmodel(&s, &rep);
         {
         // This code passes data structure through serializers
         // (serializes it to string and loads back)
            ae_int_t _local_ssize;
            ae_frame _local_frame_block;
            ae_frame_make(&_local_frame_block);
            NewSerializer(_local_serializer);
            ae_serializer_alloc_start(&_local_serializer);
            rbfalloc(&_local_serializer, &s);
            _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
            NewBlock(_local_dynamic_block, _local_ssize + 1);
            ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            rbfserialize(&_local_serializer, &s);
            ae_serializer_stop(&_local_serializer);
            ae_serializer_init(&_local_serializer);
            ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            rbfunserialize(&_local_serializer, &s2);
            ae_serializer_stop(&_local_serializer);
            ae_frame_leave();
         }
         rbfcalc(&s, &testpoint, &y0);
         rbfcalc(&s2, &testpoint, &y1);
         if (y0.cnt != ny || y1.cnt != ny) {
            result = true;
            ae_frame_leave();
            return result;
         }
         for (j = 0; j < ny; j++) {
            if (y0.xR[j] != y1.xR[j]) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      // Check that calling RBFBuildModel() on S2 (new model)
      // will result in construction of zero model, i.e. test
      // that serialization restores model, but not dataset
      // which was used to build model.
         rbfbuildmodel(&s2, &rep);
         rbfcalc(&s2, &testpoint, &y1);
         if (y1.cnt != ny) {
            result = true;
            ae_frame_leave();
            return result;
         }
         for (j = 0; j < ny; j++) {
            if (y1.xR[j] != 0.0) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
// This function generates random 2 or 3 dimensional problem,
// builds model using RBF-ML algo, serializes/unserializes it,
// then compares models by calculating model value at some
// random point.
//
// Additionally we test that new model (one which was restored
// after serialization) has lost all model construction settings,
// i.e. if we call RBFBuildModel() on a NEW model, we will get
// empty (zero) model.
   for (nx = 2; nx <= 3; nx++) {
      for (ny = 1; ny <= 2; ny++) {
      // prepare test problem
         rbfcreate(nx, ny, &s);
         rbfsetalgomultilayer(&s, 5.0, 5, 1.0E-3);
         rbfsetlinterm(&s);
         if (nx == 2) {
         // 2-dimensional problem
            k0 = 2 + randominteger(4);
            k1 = 2 + randominteger(4);
            ae_matrix_set_length(&xy, k0 * k1, nx + ny);
            for (i0 = 0; i0 < k0; i0++) {
               for (i1 = 0; i1 < k1; i1++) {
                  xy.xyR[i0 * k1 + i1][0] = i0 + 0.1 * randommid();
                  xy.xyR[i0 * k1 + i1][1] = i1 + 0.1 * randommid();
                  for (j = 0; j < ny; j++) {
                     xy.xyR[i0 * k1 + i1][nx + j] = randommid();
                  }
               }
            }
            ae_vector_set_length(&testpoint, nx);
            testpoint.xR[0] = randomreal() * (k0 - 1);
            testpoint.xR[1] = randomreal() * (k1 - 1);
         } else {
         // 3-dimensional problem
            k0 = 2 + randominteger(4);
            k1 = 2 + randominteger(4);
            k2 = 2 + randominteger(4);
            ae_matrix_set_length(&xy, k0 * k1 * k2, nx + ny);
            for (i0 = 0; i0 < k0; i0++) {
               for (i1 = 0; i1 < k1; i1++) {
                  for (i2 = 0; i2 < k2; i2++) {
                     xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][0] = i0 + 0.1 * randommid();
                     xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][1] = i1 + 0.1 * randommid();
                     xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][2] = i2 + 0.1 * randommid();
                     for (j = 0; j < ny; j++) {
                        xy.xyR[i0 * k1 * k2 + i1 * k2 + i2][nx + j] = randommid();
                     }
                  }
               }
            }
            ae_vector_set_length(&testpoint, nx);
            testpoint.xR[0] = randomreal() * (k0 - 1);
            testpoint.xR[1] = randomreal() * (k1 - 1);
            testpoint.xR[2] = randomreal() * (k2 - 1);
         }
         rbfsetpoints(&s, &xy, xy.rows);
      // Build model, serialize, compare
         rbfbuildmodel(&s, &rep);
         {
         // This code passes data structure through serializers
         // (serializes it to string and loads back)
            ae_int_t _local_ssize;
            ae_frame _local_frame_block;
            ae_frame_make(&_local_frame_block);
            NewSerializer(_local_serializer);
            ae_serializer_alloc_start(&_local_serializer);
            rbfalloc(&_local_serializer, &s);
            _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
            NewBlock(_local_dynamic_block, _local_ssize + 1);
            ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            rbfserialize(&_local_serializer, &s);
            ae_serializer_stop(&_local_serializer);
            ae_serializer_init(&_local_serializer);
            ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            rbfunserialize(&_local_serializer, &s2);
            ae_serializer_stop(&_local_serializer);
            ae_frame_leave();
         }
         rbfcalc(&s, &testpoint, &y0);
         rbfcalc(&s2, &testpoint, &y1);
         if (y0.cnt != ny || y1.cnt != ny) {
            result = true;
            ae_frame_leave();
            return result;
         }
         for (j = 0; j < ny; j++) {
            if (y0.xR[j] != y1.xR[j]) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      // Check that calling RBFBuildModel() on S2 (new model)
      // will result in construction of zero model, i.e. test
      // that serialization restores model, but not dataset
      // which was used to build model.
         rbfbuildmodel(&s2, &rep);
         rbfcalc(&s2, &testpoint, &y1);
         if (y1.cnt != ny) {
            result = true;
            ae_frame_leave();
            return result;
         }
         for (j = 0; j < ny; j++) {
            if (y1.xR[j] != 0.0) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
// This function generates random 1...4-dimensional problem,
// builds model using RBF-H algo, serializes/unserializes it,
// then compares models by calculating model value at some
// random point.
//
// NOTE: we choose at random whether to use default scaling -
//       or user-supplied one.
//
// Additionally we test that new model (one which was restored
// after serialization) has lost all model construction settings,
// i.e. if we call RBFBuildModel() on a NEW model, we will get
// empty (zero) model.
   for (nx = 1; nx <= 4; nx++) {
      for (ny = 1; ny <= 2; ny++) {
      // problem setup
         n = 150;
         rbase = 0.33;
         nlayers = 5;
         gridsize = iround(pow((double)n, 1.0 / nx)) + 1;
         bf = randominteger(2);
         n = iround(pow((double)gridsize, (double)nx));
         ae_matrix_set_length(&xy, n, nx + ny);
         ae_assert(gridsize > 1, "Assertion failed");
         ae_assert((double)n == pow((double)gridsize, (double)nx), "Assertion failed");
         for (i = 0; i < n; i++) {
            k = i;
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = (double)(k % gridsize) / (gridsize - 1);
               k /= gridsize;
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = randomreal() - 0.5;
            }
         }
         ae_vector_set_length(&testpoint, nx);
         for (j = 0; j < nx; j++) {
            testpoint.xR[j] = randomreal();
         }
         ae_vector_set_length(&scalevec, nx);
         for (j = 0; j < nx; j++) {
            scalevec.xR[j] = pow(2.0, randommid());
         }
      // prepare test problem
         rbfcreate(nx, ny, &s);
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase, nlayers, 0.0);
         rbfsetlinterm(&s);
         if (randombool()) {
            rbfsetpoints(&s, &xy, xy.rows);
         } else {
            rbfsetpointsandscales(&s, &xy, xy.rows, &scalevec);
         }
      // Build model, serialize, compare
         rbfbuildmodel(&s, &rep);
         {
         // This code passes data structure through serializers
         // (serializes it to string and loads back)
            ae_int_t _local_ssize;
            ae_frame _local_frame_block;
            ae_frame_make(&_local_frame_block);
            NewSerializer(_local_serializer);
            ae_serializer_alloc_start(&_local_serializer);
            rbfalloc(&_local_serializer, &s);
            _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
            NewBlock(_local_dynamic_block, _local_ssize + 1);
            ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            rbfserialize(&_local_serializer, &s);
            ae_serializer_stop(&_local_serializer);
            ae_serializer_init(&_local_serializer);
            ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            rbfunserialize(&_local_serializer, &s2);
            ae_serializer_stop(&_local_serializer);
            ae_frame_leave();
         }
         rbfcalc(&s, &testpoint, &y0);
         rbfcalc(&s2, &testpoint, &y1);
         if (y0.cnt != ny || y1.cnt != ny) {
            result = true;
            ae_frame_leave();
            return result;
         }
         for (j = 0; j < ny; j++) {
            if (y0.xR[j] != y1.xR[j]) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      // Check that calling RBFBuildModel() on S2 (new model)
      // will result in construction of zero model, i.e. test
      // that serialization restores model, but not dataset
      // which was used to build model.
         rbfbuildmodel(&s2, &rep);
         rbfcalc(&s2, &testpoint, &y1);
         if (y1.cnt != ny) {
            result = true;
            ae_frame_leave();
            return result;
         }
         for (j = 0; j < ny; j++) {
            if (y1.xR[j] != 0.0) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Function for testing basic functionality of RBF module on regular grids with
// multi-layer algorithm in 2-3D.
// ALGLIB: Copyright 2.03.2012 by Sergey Bochkanov
static bool testrbfunit_basicmultilayerrbftest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t k0;
   ae_int_t k1;
   ae_int_t k2;
   ae_int_t linterm;
   ae_int_t np;
   double q;
   ae_int_t layers;
   double eps;
   ae_int_t range;
   double s1;
   double s2;
   double gstep;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   ae_int_t fidx;
   double r0;
   ae_int_t margin;
   ae_int_t gridsize;
   double threshold;
   double v;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewObj(rbfcalcbuffer, calcbuf);
   NewVector(point, 0, DT_REAL);
   NewMatrix(gp, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewMatrix(gy, 0, 0, DT_REAL);
   NewVector(gpgx0, 0, DT_REAL);
   NewVector(gpgx1, 0, DT_REAL);
   NewVector(gpgx2, 0, DT_REAL);
   NewVector(gcy, 0, DT_REAL);
   result = false;
   range = 10;
   passcount = 10;
   eps = 1.0E-6;
// Test that RBF model with sufficient layers will exactly reproduce
// target function.
   for (pass = 0; pass < passcount; pass++) {
   // prepare test problem
      k0 = 6 + randominteger(3);
      k1 = 6 + randominteger(3);
      k2 = 6 + randominteger(3);
      s1 = pow((double)range, (double)(randominteger(3) - 1));
      s2 = pow((double)range, (double)(randominteger(3) - 1));
      nx = randominteger(2) + 2;
      ny = randominteger(2) + 1;
      linterm = randominteger(3) + 1;
      layers = 5;
      gstep = s1 / 6;
      q = s1;
   // Create RBF structure and auxiliary structures
      ae_vector_set_length(&x, nx);
      ae_vector_set_length(&y, ny);
      ae_vector_set_length(&point, nx);
      rbfcreate(nx, ny, &s);
      rbfsetalgomultilayer(&s, q, layers, 0.0);
      if (linterm == 1) {
         rbfsetlinterm(&s);
      }
      if (linterm == 2) {
         rbfsetconstterm(&s);
      }
      if (linterm == 3) {
         rbfsetzeroterm(&s);
      }
      for (i = 0; i < nx; i++) {
         point.xR[i] = s1 * randommid();
      }
   // 2-dimensional test problem
      if (nx == 2) {
         np = k0 * k1;
         ae_matrix_set_length(&gp, np, nx + ny);
      // create grid
         for (i = 0; i < k0; i++) {
            for (j = 0; j < k1; j++) {
               gp.xyR[i * k1 + j][0] = point.xR[0] + gstep * i;
               gp.xyR[i * k1 + j][1] = point.xR[1] + gstep * j;
               for (k = 0; k < ny; k++) {
                  gp.xyR[i * k1 + j][nx + k] = s2 * randommid();
               }
            }
         }
         rbfsetpoints(&s, &gp, np);
         rbfbuildmodel(&s, &rep);
         rbfcreatecalcbuffer(&s, &calcbuf);
         if (ny == 1) {
            ae_vector_set_length(&gpgx0, k0);
            ae_vector_set_length(&gpgx1, k1);
            for (i = 0; i < k0; i++) {
               gpgx0.xR[i] = point.xR[0] + gstep * i;
            }
            for (i = 0; i < k1; i++) {
               gpgx1.xR[i] = point.xR[1] + gstep * i;
            }
            rbfgridcalc2(&s, &gpgx0, k0, &gpgx1, k1, &gy);
            for (i = 0; i < k0; i++) {
               for (j = 0; j < k1; j++) {
                  set_error_flag(&result, fabs(gy.xyR[i][j] - gp.xyR[i * k1 + j][nx]) > s2 * eps, __FILE__, __LINE__, "testrbfunit.ap:2216");
               }
            }
         }
         for (i = 0; i < np; i++) {
         // For each row we randomly choose a function to test
         // and call it. We do not call multiple functions per
         // row because carry-over effects may mask errors in
         // some function (say, it is possible that function
         // simply returns results from previous call of some
         // other function which were stored in the RBF model;
         // in this case, previous call with same parameters
         // may hide deficiencies in the function).
            x.xR[0] = gp.xyR[i][0];
            x.xR[1] = gp.xyR[i][1];
            fidx = randominteger(4);
            if (fidx == 0 && ny != 1) {
               continue;
            }
            if (fidx == 0) {
               y.xR[0] = rbfcalc2(&s, x.xR[0], x.xR[1]);
            }
            if (fidx == 1) {
               rbfcalc(&s, &x, &y);
            }
            if (fidx == 2) {
               rbfcalcbuf(&s, &x, &y);
            }
            if (fidx == 3) {
               rbftscalcbuf(&s, &calcbuf, &x, &y);
            }
            for (j = 0; j < ny; j++) {
               set_error_flag(&result, fabs(gp.xyR[i][nx + j] - y.xR[j]) > s2 * eps, __FILE__, __LINE__, "testrbfunit.ap:2244");
            }
         }
      }
   // 3-dimensional test problems
      if (nx == 3) {
         np = k0 * k1 * k2;
         ae_matrix_set_length(&gp, np, nx + ny);
      // create grid, build model
         ae_vector_set_length(&gpgx0, k0);
         ae_vector_set_length(&gpgx1, k1);
         ae_vector_set_length(&gpgx2, k2);
         for (i = 0; i < k0; i++) {
            gpgx0.xR[i] = point.xR[0] + gstep * i;
         }
         for (i = 0; i < k1; i++) {
            gpgx1.xR[i] = point.xR[1] + gstep * i;
         }
         for (i = 0; i < k2; i++) {
            gpgx2.xR[i] = point.xR[2] + gstep * i;
         }
         for (i = 0; i < k0; i++) {
            for (j = 0; j < k1; j++) {
               for (k = 0; k < k2; k++) {
                  gp.xyR[(i * k1 + j) * k2 + k][0] = gpgx0.xR[i];
                  gp.xyR[(i * k1 + j) * k2 + k][1] = gpgx1.xR[j];
                  gp.xyR[(i * k1 + j) * k2 + k][2] = gpgx2.xR[k];
                  for (l = 0; l < ny; l++) {
                     gp.xyR[(i * k1 + j) * k2 + k][nx + l] = s2 * randommid();
                  }
               }
            }
         }
         rbfsetpoints(&s, &gp, np);
         rbfbuildmodel(&s, &rep);
         rbfcreatecalcbuffer(&s, &calcbuf);
      // Test RBFCalc3(), RBFCalc() and RBFCalcBuf() vs expected values on the grid (we expect good fit).
         for (i = 0; i < np; i++) {
         // For each row we randomly choose a function to test
         // and call it. We do not call multiple functions per
         // row because carry-over effects may mask errors in
         // some function (say, it is possible that function
         // simply returns results from previous call of some
         // other function which were stored in the RBF model;
         // in this case, previous call with same parameters
         // may hide deficiencies in the function).
            x.xR[0] = gp.xyR[i][0];
            x.xR[1] = gp.xyR[i][1];
            x.xR[2] = gp.xyR[i][2];
            fidx = randominteger(4);
            if (fidx == 0 && ny != 1) {
               continue;
            }
            if (fidx == 0) {
               y.xR[0] = rbfcalc3(&s, x.xR[0], x.xR[1], x.xR[2]);
            }
            if (fidx == 1) {
               rbfcalc(&s, &x, &y);
            }
            if (fidx == 2) {
               rbfcalcbuf(&s, &x, &y);
            }
            if (fidx == 3) {
               rbftscalcbuf(&s, &calcbuf, &x, &y);
            }
            for (j = 0; j < ny; j++) {
               set_error_flag(&result, fabs(gp.xyR[i][nx + j] - y.xR[j]) > s2 * eps, __FILE__, __LINE__, "testrbfunit.ap:2312");
            }
         }
      // Test RBFGridCalc3V vs RBFCalc()
         rbfgridcalc3v(&s, &gpgx0, k0, &gpgx1, k1, &gpgx2, k2, &gcy);
         for (i = 0; i < k0; i++) {
            for (j = 0; j < k1; j++) {
               for (k = 0; k < k2; k++) {
                  x.xR[0] = gpgx0.xR[i];
                  x.xR[1] = gpgx1.xR[j];
                  x.xR[2] = gpgx2.xR[k];
                  rbfcalcbuf(&s, &x, &y);
                  for (l = 0; l < ny; l++) {
                     set_error_flag(&result, fabs(y.xR[l] - gcy.xR[l + ny * (i + j * k0 + k * k0 * k1)]) > 1.0E-9 * s2, __FILE__, __LINE__, "testrbfunit.ap:2329");
                  }
               }
            }
         }
      }
   }
// Test smoothing properties of RBF model: model with just one layer
// and large initial radius will produce "average" value of neighbors.
//
// In order to test it we create regular grid, fill it with regular
// +1/-1 pattern, and test model values in the inner points. Model
// values should be around zero (we use handcrafted threshold to test
// it). Radius is chosen to be several times larger than grid step.
//
// We perform test for 2D model, because same behavior is expected
// regardless of dimensionality.
   r0 = 3.0;
   margin = 5;
   gridsize = 2 * margin + 20;
   threshold = 0.1;
   nx = 2;
   ny = 1;
   rbfcreate(nx, ny, &s);
   rbfsetalgomultilayer(&s, r0, 1, 0.0);
   rbfsetzeroterm(&s);
   ae_matrix_set_length(&gp, gridsize * gridsize, nx + ny);
   for (i = 0; i < gridsize; i++) {
      for (j = 0; j < gridsize; j++) {
         gp.xyR[i * gridsize + j][0] = (double)i;
         gp.xyR[i * gridsize + j][1] = (double)j;
         gp.xyR[i * gridsize + j][2] = 0.05 * randommid() + (2 * ((i + j) % 2) - 1);
      }
   }
   rbfsetpoints(&s, &gp, gridsize * gridsize);
   rbfbuildmodel(&s, &rep);
   v = 0.0;
   for (i = margin; i < gridsize - margin; i++) {
      for (j = margin; j < gridsize - margin; j++) {
         v = rmax2(v, fabs(rbfcalc2(&s, (double)i, (double)j)));
      }
   }
   set_error_flag(&result, v > threshold, __FILE__, __LINE__, "testrbfunit.ap:2376");
   ae_frame_leave();
   return result;
}

// Function for testing basic functionality of RBF module on regular grids with
// multi-layer algorithm in 2-3D.
// ALGLIB: Copyright 2.03.2012 by Sergey Bochkanov
static void testrbfunit_gridcalc23test(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t l;
   double perturbation;
   double sx;
   double sy;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t linterm;
   ae_int_t layers;
   ae_int_t npoints;
   double sparsity;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewObj(hqrndstate, rs);
   NewVector(kx, 0, DT_INT);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(gf, 0, DT_BOOL);
   NewVector(rf, 0, DT_BOOL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(gy, 0, DT_REAL);
   NewVector(gy2, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   hqrndrandomize(&rs);
   for (pass = 0; pass <= 24; pass++) {
   // prepare test problem
      ae_vector_set_length(&kx, 3);
      for (i = 0; i <= 2; i++) {
      // 66% of cases - large grid
         if (hqrnduniformi(&rs, 3) == 0) {
            kx.xZ[i] = iround(10 * pow(10.0, hqrnduniformr(&rs)));
            continue;
         }
      // 33% of cases - small grid
         k = hqrnduniformi(&rs, 3);
         if (k == 0) {
            kx.xZ[i] = 1;
         }
         if (k == 1) {
            kx.xZ[i] = 2;
         }
         if (k == 2) {
            kx.xZ[i] = 10;
         }
      }
      sx = pow(10.0, (double)(hqrnduniformi(&rs, 3) - 1));
      sy = pow(10.0, (double)(hqrnduniformi(&rs, 3) - 1));
      nx = 3;
      ny = 1 + hqrnduniformi(&rs, 5);
      linterm = hqrnduniformi(&rs, 3) + 1;
      layers = hqrnduniformi(&rs, 3) + 1;
      npoints = 100;
      ae_matrix_set_length(&xy, npoints, nx + ny);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nx; j++) {
            xy.xyR[i][j] = hqrnduniformr(&rs) * sx;
         }
         for (j = 0; j < ny; j++) {
            xy.xyR[i][nx + j] = hqrnduniformr(&rs) * sy;
         }
      }
   // Create RBF model
      rbfcreate(nx, ny, &s);
      rbfsetalgomultilayer(&s, 0.1 * sx, layers, 0.0);
      if (linterm == 1) {
         rbfsetlinterm(&s);
      }
      if (linterm == 2) {
         rbfsetconstterm(&s);
      }
      if (linterm == 3) {
         rbfsetzeroterm(&s);
      }
      rbfsetpoints(&s, &xy, npoints);
      rbfbuildmodel(&s, &rep);
      set_error_flag(errorflag, rep.terminationtype <= 0, __FILE__, __LINE__, "testrbfunit.ap:2473");
      if (*errorflag) {
         ae_frame_leave();
         return;
      }
   // Prepare test grid
      ae_vector_set_length(&x0, kx.xZ[0]);
      for (i = 0; i < kx.xZ[0]; i++) {
         perturbation = 0.5 * (hqrnduniformr(&rs) - 0.5);
         x0.xR[i] = sx * (i + perturbation) / kx.xZ[0];
      }
      ae_vector_set_length(&x1, kx.xZ[1]);
      for (i = 0; i < kx.xZ[1]; i++) {
         perturbation = 0.5 * (hqrnduniformr(&rs) - 0.5);
         x1.xR[i] = sx * (i + perturbation) / kx.xZ[1];
      }
      ae_vector_set_length(&x2, kx.xZ[2]);
      for (i = 0; i < kx.xZ[2]; i++) {
         perturbation = 0.5 * (hqrnduniformr(&rs) - 0.5);
         x2.xR[i] = sx * (i + perturbation) / kx.xZ[2];
      }
   // Test calculation on grid
      ae_vector_set_length(&x, nx);
      ae_vector_set_length(&y, ny);
      SetVector(&gy);
      rbfgridcalc3v(&s, &x0, kx.xZ[0], &x1, kx.xZ[1], &x2, kx.xZ[2], &gy);
      for (i = 0; i < kx.xZ[0]; i++) {
         for (j = 0; j < kx.xZ[1]; j++) {
            for (k = 0; k < kx.xZ[2]; k++) {
               x.xR[0] = x0.xR[i];
               x.xR[1] = x1.xR[j];
               x.xR[2] = x2.xR[k];
               rbfcalcbuf(&s, &x, &y);
               for (l = 0; l < ny; l++) {
                  set_error_flag(errorflag, fabs(y.xR[l] - gy.xR[l + ny * (i + j * kx.xZ[0] + k * kx.xZ[0] * kx.xZ[1])]) > 1.0E-9 * sy, __FILE__, __LINE__, "testrbfunit.ap:2516");
               }
            }
         }
      }
   // Test calculation on subset of regular grid:
   // * select sparsity coefficient (from 1.0 to 0.001)
   // * fill bitmap array
   // * Test 1: compare full and subset versions
   // * Test 2: check sparsity. Subset function may perform additional
   //   evaluations because it processes data micro-row by micro-row.
   //   So, we can't check that all elements which were not flagged
   //   are zero - some of them may become non-zero. However, if entire
   //   row is empty, we can reasonably expect (informal guarantee)
   //   that it is not processed. So, we check empty (completely
   //   unflagged) rows
   //
      sparsity = pow(10.0, (double)-hqrnduniformi(&rs, 4));
      ae_vector_set_length(&gf, kx.xZ[0] * kx.xZ[1] * kx.xZ[2]);
      ae_vector_set_length(&rf, kx.xZ[1] * kx.xZ[2]);
      for (i = 0; i < kx.xZ[1] * kx.xZ[2]; i++) {
         rf.xB[i] = false;
      }
      for (i = 0; i < kx.xZ[0] * kx.xZ[1] * kx.xZ[2]; i++) {
         gf.xB[i] = hqrnduniformr(&rs) < sparsity;
         if (gf.xB[i]) {
            rf.xB[i / kx.xZ[0]] = true;
         }
      }
      ae_vector_set_length(&x, nx);
      ae_vector_set_length(&y, ny);
      SetVector(&gy);
      SetVector(&gy2);
      rbfgridcalc3vsubset(&s, &x0, kx.xZ[0], &x1, kx.xZ[1], &x2, kx.xZ[2], &gf, &gy);
      rbfgridcalc3v(&s, &x0, kx.xZ[0], &x1, kx.xZ[1], &x2, kx.xZ[2], &gy2);
      for (i = 0; i < ny * kx.xZ[0] * kx.xZ[1] * kx.xZ[2]; i++) {
         set_error_flag(errorflag, gf.xB[i / ny] && fabs(gy.xR[i] - gy2.xR[i]) > 1.0E-9 * sy, __FILE__, __LINE__, "testrbfunit.ap:2558");
         set_error_flag(errorflag, !rf.xB[i / (ny * kx.xZ[0])] && gy.xR[i] != 0.0, __FILE__, __LINE__, "testrbfunit.ap:2559");
      }
   }
   ae_frame_leave();
}

// Function for testing basic functionality of RBF module with hierarchical
// algorithm.
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static bool testrbfunit_basichrbftest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t linterm;
   ae_int_t bf;
   double rbase;
   ae_int_t nlayers;
   double errtol;
   double scalefactor;
   ae_int_t n;
   ae_int_t ntest;
   ae_int_t gridsize;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double r0;
   ae_int_t margin;
   double threshold;
   double v;
   ae_int_t functype;
   ae_int_t densitytype;
   double width;
   double lowprec;
   double highprec;
   ae_int_t modeltype;
   ae_int_t shaketype;
   double maxerr;
   bool fractionalerror;
   ae_int_t unx;
   ae_int_t uny;
   ae_int_t unc;
   ae_int_t modelversion;
   bool hasscale;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfmodel, s2);
   NewObj(rbfreport, rep);
   NewObj(rbfcalcbuffer, tsbuf);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xytest, 0, 0, DT_REAL);
   NewMatrix(uxwr, 0, 0, DT_REAL);
   NewMatrix(uv, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(xzero, 0, DT_REAL);
   NewVector(yref, 0, DT_REAL);
   NewVector(scalevec, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   result = false;
// First test - random problem, ability to build model
// which reproduces function value in all points with
// good precision.
//
// We also test properties of the linear term - that
// model value in far away points is either constant
// or exactly zero (for corresponding kinds of linear
// term).
//
// All dataset points are located in unit cube on
// regular grid. We do not use smoothing for this test.
//
// We use/test following functions:
// * RBFCalc()
// * RBFCalc2()
// * RBFCalc3()
// * RBFCalcBuf()
// * RBFTsCalcBuf()
   errtol = 1.0E-6;
   for (nx = 1; nx <= 4; nx++) {
      for (ny = 1; ny <= 3; ny++) {
      // problem setup
         n = 150;
         rbase = 0.33;
         nlayers = 10;
         gridsize = iround(pow((double)n, 1.0 / nx)) + 1;
         linterm = 1 + randominteger(3);
         bf = randominteger(2);
         n = iround(pow((double)gridsize, (double)nx));
         ae_matrix_set_length(&xy, n, nx + ny);
         ae_assert(gridsize > 1, "Assertion failed");
         ae_assert((double)n == pow((double)gridsize, (double)nx), "Assertion failed");
         for (i = 0; i < n; i++) {
            k = i;
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = (double)(k % gridsize) / (gridsize - 1);
               k /= gridsize;
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = randomreal() - 0.5;
            }
         }
      // Build model
         rbfcreate(nx, ny, &s);
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase, nlayers, 0.0);
         if (linterm == 1) {
            rbfsetlinterm(&s);
         }
         if (linterm == 2) {
            rbfsetconstterm(&s);
         }
         if (linterm == 3) {
            rbfsetzeroterm(&s);
         }
         rbfsetpoints(&s, &xy, n);
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:2683");
            ae_frame_leave();
            return result;
         }
         rbfcreatecalcbuffer(&s, &tsbuf);
      // Test ability to reproduce function value
      //
      // NOTE: we use RBFCalc(XZero) to guarantee that internal state of
      //       RBF model is "reset" between subsequent calls of different
      //       functions. It allows us to make sure that we have no bug
      //       like function simply returning latest result
         ae_vector_set_length(&x, nx);
         ae_vector_set_length(&xzero, nx);
         ae_vector_set_length(&y, ny);
         for (j = 0; j < nx; j++) {
            xzero.xR[j] = 0.0;
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               x.xR[j] = xy.xyR[i][j];
            }
            rbfcalc(&s, &xzero, &y);
            if (randombool()) {
               ae_vector_set_length(&yref, ny + 1);
            }
            rbfcalc(&s, &x, &yref);
            for (j = 0; j < ny; j++) {
               set_error_flag(&result, fabs(yref.xR[j] - xy.xyR[i][nx + j]) > errtol, __FILE__, __LINE__, "testrbfunit.ap:2712");
            }
            set_error_flag(&result, yref.cnt != ny, __FILE__, __LINE__, "testrbfunit.ap:2713");
            if (nx == 1 && ny == 1) {
               rbfcalc(&s, &xzero, &y);
               set_error_flag(&result, rbfcalc1(&s, x.xR[0]) != yref.xR[0], __FILE__, __LINE__, "testrbfunit.ap:2719");
            }
            if (nx == 2 && ny == 1) {
               rbfcalc(&s, &xzero, &y);
               set_error_flag(&result, rbfcalc2(&s, x.xR[0], x.xR[1]) != yref.xR[0], __FILE__, __LINE__, "testrbfunit.ap:2726");
            }
            if (nx == 3 && ny == 1) {
               rbfcalc(&s, &xzero, &y);
               set_error_flag(&result, rbfcalc3(&s, x.xR[0], x.xR[1], x.xR[2]) != yref.xR[0], __FILE__, __LINE__, "testrbfunit.ap:2733");
            }
            rbfcalc(&s, &xzero, &y);
            if (randombool()) {
               ae_vector_set_length(&y, ny + 1);
               rbfcalcbuf(&s, &x, &y);
               set_error_flag(&result, y.cnt != ny + 1, __FILE__, __LINE__, "testrbfunit.ap:2742");
            } else {
               ae_vector_set_length(&y, ny - 1);
               rbfcalcbuf(&s, &x, &y);
               set_error_flag(&result, y.cnt != ny, __FILE__, __LINE__, "testrbfunit.ap:2748");
            }
            for (j = 0; j < ny; j++) {
               set_error_flag(&result, y.xR[j] != yref.xR[j], __FILE__, __LINE__, "testrbfunit.ap:2751");
            }
            rbfcalc(&s, &xzero, &y);
            if (randombool()) {
               ae_vector_set_length(&y, ny + 1);
               rbftscalcbuf(&s, &tsbuf, &x, &y);
               set_error_flag(&result, y.cnt != ny + 1, __FILE__, __LINE__, "testrbfunit.ap:2759");
            } else {
               ae_vector_set_length(&y, ny - 1);
               rbftscalcbuf(&s, &tsbuf, &x, &y);
               set_error_flag(&result, y.cnt != ny, __FILE__, __LINE__, "testrbfunit.ap:2765");
            }
            for (j = 0; j < ny; j++) {
               set_error_flag(&result, y.xR[j] != yref.xR[j], __FILE__, __LINE__, "testrbfunit.ap:2768");
            }
         }
      // Test that:
      // a) model with zero linear term is zero far away from dataset
      // b) model with constant linear term is constant far away from dataset
         ae_vector_set_length(&x, nx);
         if (linterm == 2) {
            for (j = 0; j < nx; j++) {
               if (randombool()) {
                  x.xR[j] = 1 + 1000 * rbase;
               } else {
                  x.xR[j] = 0 - 1000 * rbase;
               }
            }
            rbfcalc(&s, &x, &y);
            for (j = 0; j < nx; j++) {
               if (randombool()) {
                  x.xR[j] = 1 + 1000 * rbase;
               } else {
                  x.xR[j] = 0 - 1000 * rbase;
               }
            }
            rbfcalc(&s, &x, &y2);
            for (j = 0; j < ny; j++) {
               set_error_flag(&result, y.xR[j] != y2.xR[j], __FILE__, __LINE__, "testrbfunit.ap:2792");
            }
         }
         if (linterm == 3) {
            for (j = 0; j < nx; j++) {
               if (randombool()) {
                  x.xR[j] = 1 + 1000 * rbase;
               } else {
                  x.xR[j] = 0 - 1000 * rbase;
               }
            }
            rbfcalc(&s, &x, &y);
            for (j = 0; j < ny; j++) {
               set_error_flag(&result, y.xR[j] != 0.0, __FILE__, __LINE__, "testrbfunit.ap:2803");
            }
         }
      }
   }
// Test rbfunpack()
   for (nx = 1; nx <= 2; nx++) {
      for (ny = 1; ny <= 2; ny++) {
      // problem setup
         n = 150;
         rbase = 0.33;
         nlayers = 5;
         gridsize = iround(pow((double)n, 1.0 / nx)) + 1;
         linterm = 1 + randominteger(3);
         bf = randominteger(2);
         n = iround(pow((double)gridsize, (double)nx));
         ae_matrix_set_length(&xy, n, nx + ny);
         ae_assert(gridsize > 1, "Assertion failed");
         ae_assert((double)n == pow((double)gridsize, (double)nx), "Assertion failed");
         for (i = 0; i < n; i++) {
            k = i;
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = (double)(k % gridsize) / (gridsize - 1);
               k /= gridsize;
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = randomreal() - 0.5;
            }
         }
         hasscale = randominteger(2) == 0;
         ae_vector_set_length(&scalevec, nx);
         if (hasscale) {
            for (j = 0; j < nx; j++) {
               scalevec.xR[j] = pow(2.0, randommid());
            }
         }
      // Build model
         rbfcreate(nx, ny, &s);
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase, nlayers, 0.0);
         if (linterm == 1) {
            rbfsetlinterm(&s);
         }
         if (linterm == 2) {
            rbfsetconstterm(&s);
         }
         if (linterm == 3) {
            rbfsetzeroterm(&s);
         }
         if (hasscale) {
            rbfsetpointsandscales(&s, &xy, n, &scalevec);
         } else {
            rbfsetpoints(&s, &xy, n);
         }
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:2864");
            ae_frame_leave();
            return result;
         }
      // Test RBFUnpack()
         rbfunpack(&s, &unx, &uny, &uxwr, &unc, &uv, &modelversion);
         if (modelversion != 2) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:2874");
            ae_frame_leave();
            return result;
         }
         if (unx != nx || uny != ny) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:2879");
            ae_frame_leave();
            return result;
         }
         if (uv.cols != nx + 1 || uv.rows != ny) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:2884");
            ae_frame_leave();
            return result;
         }
         if (linterm == 2) {
            for (i = 0; i < ny; i++) {
               for (j = 0; j < nx; j++) {
                  set_error_flag(&result, uv.xyR[i][j] != 0.0, __FILE__, __LINE__, "testrbfunit.ap:2891");
               }
            }
         }
         if (linterm == 3) {
            for (i = 0; i < ny; i++) {
               for (j = 0; j <= nx; j++) {
                  set_error_flag(&result, uv.xyR[i][j] != 0.0, __FILE__, __LINE__, "testrbfunit.ap:2897");
               }
            }
         }
         ae_vector_set_length(&x, nx);
         ae_vector_set_length(&y, ny);
         for (i = 0; i <= 9; i++) {
            for (j = 0; j < nx; j++) {
               x.xR[j] = randomreal();
            }
            rbfcalc(&s, &x, &yref);
            for (j = 0; j < ny; j++) {
               y.xR[j] = uv.xyR[j][nx];
               for (k = 0; k < nx; k++) {
                  y.xR[j] += x.xR[k] * uv.xyR[j][k];
               }
            }
            for (k = 0; k < unc; k++) {
               v = 0.0;
               for (j = 0; j < nx; j++) {
                  v += sqr(uxwr.xyR[k][j] - x.xR[j]) / sqr(uxwr.xyR[k][nx + ny + j]);
               }
               if (v < rbfv2farradius(bf) * rbfv2farradius(bf)) {
                  v = rbfv2basisfunc(bf, v);
               } else {
                  v = 0.0;
               }
               for (j = 0; j < ny; j++) {
                  y.xR[j] += v * uxwr.xyR[k][nx + j];
               }
            }
            for (j = 0; j < ny; j++) {
               set_error_flag(&result, fabs(y.xR[j] - yref.xR[j]) > 1.0E-9, __FILE__, __LINE__, "testrbfunit.ap:2932");
            }
         }
      }
   }
// Test that smooth 1D function is reproduced (between nodes)
// with good precision. We test two model types: model with
// three layers and moderate initial radius, and model with
// large initial radius and large number of layers.
//
// This test:
// * generates test function on [-Width,+Width]. Two sets of
//   nodes are generated - "model" ones and "test" ones.
// * builds RBF model using "model" dataset
// * test model using "test" dataset. Test points are more
//   dense and are spread in [-0.9*Width, +0.9*Width] (reduced
//   interval is used because RBF models are too bad near the
//   boundaries).
//
// NOTE: we calculate maximum error for given function type
//       and grid density over all modifications of the task,
//       and only after that we perform comparison with tolerance
//       level. It allows easier debugging.
   for (functype = 0; functype <= 2; functype++) {
      for (densitytype = 0; densitytype <= 1; densitytype++) {
      // Select tolerance
         lowprec = -999999.0;
         highprec = -999999.0;
         if (functype == 0) {
            lowprec = 1.0E-2;
            highprec = 1.0E-3;
         } else {
            if (functype == 1) {
               lowprec = 1.0E-1;
               highprec = 1.0E-2;
            } else {
               if (functype == 2) {
                  lowprec = 1.0E-3;
                  highprec = 1.0E-4;
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         if (densitytype == 0) {
            errtol = lowprec;
         } else {
            errtol = highprec;
         }
      // Test
         maxerr = 0.0;
         for (modeltype = 0; modeltype <= 1; modeltype++) {
            for (shaketype = 0; shaketype <= 1; shaketype++) {
            // Generate grid
               width = 1.0;
               fractionalerror = false;
               if (functype == 0) {
               // sin(x) on [-2*pi,+2*pi]
                  n = 17 * iround(pow(4.0, (double)densitytype));
                  width = pi;
                  fractionalerror = false;
               } else {
                  if (functype == 1) {
                  // exp(x) on [-3,+3]
                     n = 50 * iround(pow(4.0, (double)densitytype));
                     width = 3.0;
                     fractionalerror = true;
                  } else {
                     if (functype == 2) {
                     // 1/(1+x^2) on [-3,+3]
                        n = 20 * iround(pow(4.0, (double)densitytype));
                        width = 3.0;
                        fractionalerror = false;
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
               }
               ae_matrix_set_length(&xy, n, 2);
               for (i = 0; i < n; i++) {
                  v = shaketype * 0.25 * (randomreal() - 0.5);
                  v = (i + v) / (n - 1);
                  v = 2 * v - 1;
                  xy.xyR[i][0] = width * v;
               }
               ntest = n * 10;
               ae_matrix_set_length(&xytest, ntest, 2);
               for (i = 0; i < ntest; i++) {
                  xytest.xyR[i][0] = 0.9 * width * ((double)(2 * i) / (ntest - 1) - 1);
               }
            // Evaluate function
               if (functype == 0) {
               // sin(x)
                  for (i = 0; i < n; i++) {
                     xy.xyR[i][1] = sin(xy.xyR[i][0]);
                  }
                  for (i = 0; i < ntest; i++) {
                     xytest.xyR[i][1] = sin(xytest.xyR[i][0]);
                  }
               } else {
                  if (functype == 1) {
                  // exp(x)
                     for (i = 0; i < n; i++) {
                        xy.xyR[i][1] = exp(xy.xyR[i][0]);
                     }
                     for (i = 0; i < ntest; i++) {
                        xytest.xyR[i][1] = exp(xytest.xyR[i][0]);
                     }
                  } else {
                     if (functype == 2) {
                     // 1/(1+x^2)
                        for (i = 0; i < n; i++) {
                           xy.xyR[i][1] = 1 / (1 + sqr(xy.xyR[i][0]));
                        }
                        for (i = 0; i < ntest; i++) {
                           xytest.xyR[i][1] = 1 / (1 + sqr(xytest.xyR[i][0]));
                        }
                     } else {
                        ae_assert(false, "Assertion failed");
                     }
                  }
               }
            // Select model properties and precision
               if (modeltype == 0) {
                  rbase = 4.0 * (2 * width / n);
                  nlayers = 3;
               } else {
                  if (modeltype == 1) {
                     rbase = 16.0 * (2 * width / n);
                     nlayers = 6;
                  } else {
                     ae_assert(false, "Assertion failed");
                  }
               }
            // Build model
               bf = randominteger(2);
               rbfcreate(1, 1, &s);
               rbfsetv2bf(&s, bf);
               rbfsetalgohierarchical(&s, rbase, nlayers, 0.0);
               rbfsetpoints(&s, &xy, n);
               rbfbuildmodel(&s, &rep);
               if (rep.terminationtype <= 0) {
                  set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:3106");
                  ae_frame_leave();
                  return result;
               }
            // Check
               ae_vector_set_length(&x, 1);
               for (i = 0; i < ntest; i++) {
                  x.xR[0] = xytest.xyR[i][0];
                  rbfcalc(&s, &x, &y);
                  if (fractionalerror) {
                     maxerr = rmax2(maxerr, fabs(y.xR[0] - xytest.xyR[i][1]) / fabs(xytest.xyR[i][1]));
                  } else {
                     maxerr = rmax2(maxerr, fabs(y.xR[0] - xytest.xyR[i][1]));
                  }
               }
            }
         }
      // Check error
         set_error_flag(&result, maxerr > errtol, __FILE__, __LINE__, "testrbfunit.ap:3128");
      }
   }
// Scaling test - random problem, we test that after
// scaling of all variables and radius by 2^K (for some K)
// we will get exactly same results (up to the last bit of
// mantissa).
//
// It is very strong requirement for algorithm stability,
// but it is satisfiable in most implementations of RBFs,
// because all operations involving spatial values are usually
// followed by division by radius, and using multiplier which
// is exactly power of 2 results in no changes in numbers
// being returned.
//
// It allows to test different scale-related bugs
// (say, situation when deep in kd-tree search code we compare
// against R instead of R^2).
//
// All dataset points are located in unit cube on
// regular grid.
//
// We do not use smoothing for this test.
   for (nx = 1; nx <= 4; nx++) {
   // problem setup
      n = 150;
      rbase = 0.33;
      nlayers = randominteger(4);
      scalefactor = pow(1024.0, (double)(2 * randominteger(2) - 1));
      gridsize = iround(pow((double)n, 1.0 / nx)) + 1;
      ny = 1 + randominteger(3);
      linterm = 1 + randominteger(3);
      bf = randominteger(2);
      n = iround(pow((double)gridsize, (double)nx));
      ae_matrix_set_length(&xy, n, nx + ny);
      ae_matrix_set_length(&xy2, n, nx + ny);
      ae_assert(gridsize > 1, "Assertion failed");
      ae_assert((double)n == pow((double)gridsize, (double)nx), "Assertion failed");
      for (i = 0; i < n; i++) {
         k = i;
         for (j = 0; j < nx; j++) {
            xy.xyR[i][j] = (double)(k % gridsize) / (gridsize - 1);
            xy2.xyR[i][j] = xy.xyR[i][j] * scalefactor;
            k /= gridsize;
         }
         for (j = 0; j < ny; j++) {
            xy.xyR[i][nx + j] = randomreal() - 0.5;
            xy2.xyR[i][nx + j] = xy.xyR[i][nx + j];
         }
      }
   // Build model 1
      rbfcreate(nx, ny, &s);
      rbfsetv2bf(&s, bf);
      rbfsetalgohierarchical(&s, rbase, nlayers, 0.0);
      if (linterm == 1) {
         rbfsetlinterm(&s);
      }
      if (linterm == 2) {
         rbfsetconstterm(&s);
      }
      if (linterm == 3) {
         rbfsetzeroterm(&s);
      }
      rbfsetpoints(&s, &xy, n);
      rbfbuildmodel(&s, &rep);
      if (rep.terminationtype <= 0) {
         set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:3204");
         ae_frame_leave();
         return result;
      }
   // Build model 2
      rbfcreate(nx, ny, &s2);
      rbfsetv2bf(&s2, bf);
      rbfsetalgohierarchical(&s2, rbase * scalefactor, nlayers, 0.0);
      if (linterm == 1) {
         rbfsetlinterm(&s2);
      }
      if (linterm == 2) {
         rbfsetconstterm(&s2);
      }
      if (linterm == 3) {
         rbfsetzeroterm(&s2);
      }
      rbfsetpoints(&s2, &xy2, n);
      rbfbuildmodel(&s2, &rep);
      if (rep.terminationtype <= 0) {
         set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:3224");
         ae_frame_leave();
         return result;
      }
   // Compare models
      ae_vector_set_length(&x, nx);
      ae_vector_set_length(&y, ny);
      ae_vector_set_length(&y2, ny);
      for (i = 0; i < n; i++) {
         for (j = 0; j < nx; j++) {
            x.xR[j] = xy.xyR[i][j];
         }
         rbfcalc(&s, &x, &y);
         for (j = 0; j < nx; j++) {
            x.xR[j] = xy2.xyR[i][j];
         }
         rbfcalc(&s2, &x, &y2);
         for (j = 0; j < ny; j++) {
            set_error_flag(&result, y.xR[j] != y2.xR[j], __FILE__, __LINE__, "testrbfunit.ap:3243");
         }
      }
   }
// Test that passing scaled dataset automatically results in V2 model
// being built (even when algorithm type is not set explicitly).
   for (nx = 1; nx <= 4; nx++) {
      for (ny = 1; ny <= 3; ny++) {
      // problem setup
         n = 10;
         ae_matrix_set_length(&xy, n, nx + ny);
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx + ny; j++) {
               xy.xyR[i][j] = randomreal() - 0.5;
            }
         }
         ae_vector_set_length(&scalevec, nx);
         for (j = 0; j < nx; j++) {
            scalevec.xR[j] = pow(2.0, randommid());
         }
      // prepare test problem
         rbfcreate(nx, ny, &s);
         rbfsetpointsandscales(&s, &xy, xy.rows, &scalevec);
      // Build model, check model version
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:3279");
            ae_frame_leave();
            return result;
         }
         set_error_flag(&result, rbfgetmodelversion(&s) != 2, __FILE__, __LINE__, "testrbfunit.ap:3282");
      }
   }
// Test smoothing properties of RBF model: model with just one layer
// and large initial radius will produce "average" value of neighbors.
//
// In order to test it we create regular grid, fill it with regular
// +1/-1 pattern, and test model values in the inner points. Model
// values should be around zero (we use handcrafted threshold to test
// it). Radius is chosen to be several times larger than grid step.
//
// We perform test for 2D model, because same behavior is expected
// regardless of dimensionality.
   r0 = 6.0;
   margin = 10;
   threshold = 0.005;
   gridsize = 2 * margin + 10;
   nx = 2;
   ny = 1;
   for (bf = 0; bf <= 1; bf++) {
      rbfcreate(nx, ny, &s);
      rbfsetv2bf(&s, bf);
      rbfsetalgohierarchical(&s, r0, 1, 1.0E-1);
      rbfsetzeroterm(&s);
      ae_matrix_set_length(&xy, gridsize * gridsize, nx + ny);
      for (i = 0; i < gridsize; i++) {
         for (j = 0; j < gridsize; j++) {
            xy.xyR[i * gridsize + j][0] = (double)i;
            xy.xyR[i * gridsize + j][1] = (double)j;
            xy.xyR[i * gridsize + j][2] = 0.01 * (randomreal() - 0.5) + (2 * ((i + j) % 2) - 1);
         }
      }
      rbfsetpoints(&s, &xy, gridsize * gridsize);
      rbfbuildmodel(&s, &rep);
      if (rep.terminationtype <= 0) {
         set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:3322");
         ae_frame_leave();
         return result;
      }
      v = 0.0;
      for (i = margin; i < gridsize - margin; i++) {
         for (j = margin; j < gridsize - margin; j++) {
            v = rmax2(v, fabs(rbfcalc2(&s, (double)i, (double)j)));
         }
      }
      set_error_flag(&result, v > threshold, __FILE__, __LINE__, "testrbfunit.ap:3329");
   }
   ae_frame_leave();
   return result;
}

// Function for testing scaling-related functionality of RBF module with
// hierarchical algorithm.
//
// Returns True on failure (error flag is set).
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static bool testrbfunit_scaledhrbftest() {
   ae_frame _frame_block;
   ae_int_t nx;
   ae_int_t ny;
   ae_int_t linterm;
   ae_int_t bf;
   double rbase;
   ae_int_t nlayers;
   double errtol;
   ae_int_t n;
   ae_int_t gridsize;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t strictness;
   double lambdav;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfmodel, s2);
   NewObj(rbfreport, rep);
   NewObj(rbfcalcbuffer, tsbuf);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(xzero, 0, DT_REAL);
   NewVector(yref, 0, DT_REAL);
   NewVector(scalex, 0, DT_REAL);
   NewVector(scaley, 0, DT_REAL);
   NewVector(c0, 0, DT_REAL);
   NewVector(c1, 0, DT_REAL);
   result = false;
// First test - random problem, test that using scaling
// does not change model significantly (except for
// rounding-related errors).
//
// We test two kinds of scaling:
// * "strict", which is scaling by some power of 2, and
//   which should result in bit-to-bit equivalence of results
// * "non-strict", which is scaling by random number, and
//   which should result in approximate equivalence
//
// We also apply scaling to Y, in order to test that it
// is correctly handled too.
   for (strictness = 0; strictness <= 1; strictness++) {
      for (nx = 1; nx <= 2; nx++) {
         for (ny = 1; ny <= 2; ny++) {
         // problem setup
            if (strictness == 1) {
               errtol = 0.0;
               ae_vector_set_length(&scalex, nx);
               for (i = 0; i < nx; i++) {
                  scalex.xR[i] = pow(16.0, (double)(randominteger(3) - 1));
               }
               ae_vector_set_length(&scaley, ny);
               for (i = 0; i < ny; i++) {
                  scaley.xR[i] = pow(16.0, (double)(randominteger(3) - 1));
               }
            } else {
               errtol = 1.0E-3;
               ae_vector_set_length(&scalex, nx);
               for (i = 0; i < nx; i++) {
                  scalex.xR[i] = pow(4.0, randommid());
               }
               ae_vector_set_length(&scaley, ny);
               for (i = 0; i < ny; i++) {
                  scaley.xR[i] = pow(4.0, randommid());
               }
            }
            n = 150;
            rbase = 0.33;
            nlayers = 2;
            gridsize = iround(pow((double)n, 1.0 / nx)) + 1;
            linterm = 1 + randominteger(3);
            bf = randominteger(2);
            lambdav = 1.0E-3 * randominteger(2);
            n = iround(pow((double)gridsize, (double)nx));
            ae_matrix_set_length(&xy, n, nx + ny);
            ae_assert(gridsize > 1, "Assertion failed");
            ae_assert((double)n == pow((double)gridsize, (double)nx), "Assertion failed");
            ae_vector_set_length(&c0, nx);
            for (j = 0; j < nx; j++) {
               c0.xR[j] = randomreal() - 0.5;
            }
            ae_vector_set_length(&c1, ny);
            for (j = 0; j < ny; j++) {
               c1.xR[j] = randomreal() - 0.5;
            }
            for (i = 0; i < n; i++) {
               k = i;
               for (j = 0; j < nx; j++) {
                  xy.xyR[i][j] = (double)(k % gridsize) / (gridsize - 1);
                  k /= gridsize;
               }
               for (j = 0; j < ny; j++) {
                  xy.xyR[i][nx + j] = 0.0;
                  for (k = 0; k < nx; k++) {
                     xy.xyR[i][nx + j] += c0.xR[k] * cos(pi * (1 + k) * xy.xyR[i][k]);
                  }
                  xy.xyR[i][nx + j] *= c1.xR[j];
               }
            }
            ae_matrix_set_length(&xy2, n, nx + ny);
            for (i = 0; i < n; i++) {
               for (j = 0; j < nx; j++) {
                  xy2.xyR[i][j] = xy.xyR[i][j] * scalex.xR[j];
               }
               for (j = 0; j < ny; j++) {
                  xy2.xyR[i][nx + j] = xy.xyR[i][nx + j] * scaley.xR[j];
               }
            }
         // Build models
            rbfcreate(nx, ny, &s);
            rbfsetv2bf(&s, bf);
            rbfsetalgohierarchical(&s, rbase, nlayers, lambdav);
            if (linterm == 1) {
               rbfsetlinterm(&s);
            }
            if (linterm == 2) {
               rbfsetconstterm(&s);
            }
            if (linterm == 3) {
               rbfsetzeroterm(&s);
            }
            rbfsetpoints(&s, &xy, n);
            rbfbuildmodel(&s, &rep);
            if (rep.terminationtype <= 0) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:3472");
               ae_frame_leave();
               return result;
            }
            rbfcreate(nx, ny, &s2);
            rbfsetv2bf(&s2, bf);
            rbfsetalgohierarchical(&s2, rbase, nlayers, lambdav);
            if (linterm == 1) {
               rbfsetlinterm(&s2);
            }
            if (linterm == 2) {
               rbfsetconstterm(&s2);
            }
            if (linterm == 3) {
               rbfsetzeroterm(&s2);
            }
            rbfsetpointsandscales(&s2, &xy2, n, &scalex);
            rbfbuildmodel(&s2, &rep);
            if (rep.terminationtype <= 0) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:3488");
               ae_frame_leave();
               return result;
            }
         // Compare model values in grid points
            ae_vector_set_length(&x, nx);
            for (i = 0; i < n; i++) {
               for (j = 0; j < nx; j++) {
                  x.xR[j] = xy.xyR[i][j];
               }
               rbfcalc(&s, &x, &y);
               for (j = 0; j < nx; j++) {
                  x.xR[j] = xy2.xyR[i][j];
               }
               rbfcalc(&s2, &x, &y2);
               for (j = 0; j < ny; j++) {
                  set_error_flag(&result, fabs(y.xR[j] - y2.xR[j] / scaley.xR[j]) > errtol, __FILE__, __LINE__, "testrbfunit.ap:3505");
               }
            }
         // Compare model values in random points
            ae_vector_set_length(&x, nx);
            for (i = 0; i < n; i++) {
               for (j = 0; j < nx; j++) {
                  x.xR[j] = randomreal();
               }
               rbfcalc(&s, &x, &y);
               for (j = 0; j < nx; j++) {
                  x.xR[j] *= scalex.xR[j];
               }
               rbfcalc(&s2, &x, &y2);
               for (j = 0; j < ny; j++) {
                  set_error_flag(&result, fabs(y.xR[j] - y2.xR[j] / scaley.xR[j]) > errtol, __FILE__, __LINE__, "testrbfunit.ap:3521");
               }
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Test special properties of hierarchical RBFs.
// Returns True on errors.
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static bool testrbfunit_spechrbftest() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nx;
   ae_int_t ny;
   double rbase;
   ae_int_t nlayers;
   ae_int_t i;
   ae_int_t j;
   double vdiff;
   double d2;
   ae_int_t v2its;
   double vref;
   double vfunc;
   double maxerr;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s0);
   NewObj(rbfmodel, s1);
   NewObj(rbfreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   result = false;
// Test properties of RBF basis functions - we compare values
// returned by RBFV2BasisFunc() against analytic expressions
// which are approximately modeled by RBFV2BasisFunc().
   d2 = 0.0;
   while (d2 < 100.0) {
      vref = exp(-d2);
      vfunc = rbfv2basisfunc(0, d2);
      set_error_flag(&result, fabs(vref - vfunc) > 1.0E-9 * vref, __FILE__, __LINE__, "testrbfunit.ap:3563");
      d2 += 1.0 / 64.0;
   }
   d2 = 0.0;
   maxerr = 0.0;
   while (d2 < 16.0) {
      vref = rmax2(1 - d2 / 9, 0.0) * exp(-d2);
      vfunc = rbfv2basisfunc(1, d2);
      maxerr = rmax2(maxerr, fabs(vref - vfunc));
      set_error_flag(&result, fabs(vref - vfunc) > 0.005, __FILE__, __LINE__, "testrbfunit.ap:3573");
      d2 += 1.0 / 64.0;
   }
// Test that tiny changes in dataset points introduce tiny
// numerical noise. The noise magnitude depends on the
// properties of the linear solver being used. We compare
// noise magnitude against hard-coded values.
//
// Test sequence:
// * create model #1
// * create model #2 using slightly modified dataset
   nx = 2;
   ny = 1;
   n = 20;
   rbase = 2.0;
   nlayers = 1;
   v2its = 50;
   ae_matrix_set_length(&xy, n * n, nx + ny);
   for (i = 0; i < n * n; i++) {
      xy.xyR[i][0] = (double)(i % n);
      xy.xyR[i][1] = (double)(i / n);
      xy.xyR[i][2] = sin((double)i);
   }
   rbfcreate(nx, ny, &s0);
   rbfsetalgohierarchical(&s0, rbase, nlayers, 0.0);
   rbfsetv2its(&s0, v2its);
   rbfsetpoints(&s0, &xy, n * n);
   rbfbuildmodel(&s0, &rep);
   if (rep.terminationtype <= 0) {
      set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:3608");
      ae_frame_leave();
      return result;
   }
   for (i = 0; i < n * n; i++) {
      xy.xyR[i][0] += 1.0E-14 * sin((double)(3 * i));
      xy.xyR[i][1] += 1.0E-14 * sin((double)(7 * i * i));
   }
   rbfcreate(nx, ny, &s1);
   rbfsetalgohierarchical(&s1, rbase, nlayers, 0.0);
   rbfsetv2its(&s1, v2its);
   rbfsetpoints(&s1, &xy, n * n);
   rbfbuildmodel(&s1, &rep);
   if (rep.terminationtype <= 0) {
      set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:3623");
      ae_frame_leave();
      return result;
   }
   vdiff = 0.0;
   for (i = 0; i < n - 1; i++) {
      for (j = 0; j < n - 1; j++) {
         vdiff += fabs(rbfcalc2(&s0, 0.5 + i, 0.5 + j) - rbfcalc2(&s1, 0.5 + i, 0.5 + j)) / sqr((double)(n - 1));
      }
   }
   set_error_flag(&result, vdiff > 0.00200 || vdiff < 0.00001, __FILE__, __LINE__, "testrbfunit.ap:3630");
// Test progress reports: progress before model construction is
// zero, progress after model is built is 1. More detailed tests
// are performed in the multithreaded TestHRBFProgress().
   nx = 2;
   ny = 1;
   n = 20;
   rbase = 1.0;
   nlayers = 3;
   ae_matrix_set_length(&xy, n, nx + ny);
   for (i = 0; i < n; i++) {
      for (j = 0; j <= nx; j++) {
         xy.xyR[i][j] = hqrndnormal(&rs);
      }
   }
   rbfcreate(nx, ny, &s0);
   rbfsetalgohierarchical(&s0, rbase, nlayers, 0.0);
   set_error_flag(&result, rbfpeekprogress(&s0) != 0.0, __FILE__, __LINE__, "testrbfunit.ap:3652");
   rbfbuildmodel(&s0, &rep);
   set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testrbfunit.ap:3654");
   set_error_flag(&result, rbfpeekprogress(&s0) != 1.0, __FILE__, __LINE__, "testrbfunit.ap:3655");
   rbfcreate(nx, ny, &s0);
   rbfsetpoints(&s0, &xy, n);
   rbfsetalgohierarchical(&s0, rbase, 0, 0.0);
   set_error_flag(&result, rbfpeekprogress(&s0) != 0.0, __FILE__, __LINE__, "testrbfunit.ap:3661");
   rbfbuildmodel(&s0, &rep);
   set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testrbfunit.ap:3663");
   set_error_flag(&result, rbfpeekprogress(&s0) != 1.0, __FILE__, __LINE__, "testrbfunit.ap:3664");
   rbfcreate(nx, ny, &s0);
   rbfsetpoints(&s0, &xy, n);
   rbfsetalgohierarchical(&s0, rbase, nlayers, 0.0);
   set_error_flag(&result, rbfpeekprogress(&s0) != 0.0, __FILE__, __LINE__, "testrbfunit.ap:3670");
   rbfbuildmodel(&s0, &rep);
   set_error_flag(&result, rep.terminationtype <= 0, __FILE__, __LINE__, "testrbfunit.ap:3672");
   set_error_flag(&result, rbfpeekprogress(&s0) != 1.0, __FILE__, __LINE__, "testrbfunit.ap:3673");
   ae_frame_leave();
   return result;
}

// Test gridded evaluation of hierarchical RBFs.
// Returns True on errors.
// ALGLIB: Copyright 20.06.2016 by Sergey Bochkanov
static bool testrbfunit_gridhrbftest() {
   ae_frame _frame_block;
   ae_int_t linterm;
   ae_int_t bf;
   double rbase;
   ae_int_t nlayers;
   ae_int_t nx;
   ae_int_t ny;
   bool hasscale;
   double errtol;
   ae_int_t n;
   ae_int_t n0;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t nkind;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t i0;
   ae_int_t i1;
   ae_int_t i2;
   double scalefactor;
   double lambdav;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(rbfmodel, s);
   NewObj(rbfreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewMatrix(y2, 0, 0, DT_REAL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(x02, 0, DT_REAL);
   NewVector(x12, 0, DT_REAL);
   NewVector(x22, 0, DT_REAL);
   NewVector(scalevec, 0, DT_REAL);
   NewVector(scalevec2, 0, DT_REAL);
   NewVector(needy, 0, DT_BOOL);
   NewVector(rowflags, 0, DT_BOOL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(yv, 0, DT_REAL);
   NewVector(yv2, 0, DT_REAL);
   result = false;
// Test 2-dimensional grid calculation
   errtol = 1.0E-12;
   nx = 2;
   for (ny = 1; ny <= 4; ny++) {
      for (nkind = 0; nkind <= 2; nkind++) {
      // problem setup
         n = 150;
         rbase = 0.10;
         nlayers = randominteger(3);
         linterm = 1 + randominteger(3);
         lambdav = 1.0E-3 * randominteger(2);
         bf = randominteger(2);
         ae_matrix_set_length(&xy, n, nx + ny);
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = randomreal();
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = randomreal() - 0.5;
            }
         }
         hasscale = randominteger(2) == 0;
         if (hasscale) {
            ae_vector_set_length(&scalevec, nx);
            for (j = 0; j < nx; j++) {
               scalevec.xR[j] = pow(2.0, randommid());
            }
         }
      // Build model
         rbfcreate(nx, ny, &s);
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase, nlayers, lambdav);
         if (linterm == 1) {
            rbfsetlinterm(&s);
         }
         if (linterm == 2) {
            rbfsetconstterm(&s);
         }
         if (linterm == 3) {
            rbfsetzeroterm(&s);
         }
         if (hasscale) {
            rbfsetpointsandscales(&s, &xy, n, &scalevec);
         } else {
            rbfsetpoints(&s, &xy, n);
         }
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:3765");
            ae_frame_leave();
            return result;
         }
      // Prepare grid to test
         n0 = 1 + randominteger(50);
         n1 = 1 + randominteger(50);
         if (nkind == 1) {
            k = randominteger(2);
            if (k == 0) {
               n0 = 1;
            }
            if (k == 1) {
               n1 = 1;
            }
         } else {
            if (nkind == 2) {
               n0 = 1;
               n1 = 1;
            } else {
               ae_assert(nkind == 0, "Assertion failed");
            }
         }
         ae_vector_set_length(&x0, n0);
         x0.xR[0] = randomreal();
         for (i = 1; i < n0; i++) {
            x0.xR[i] = x0.xR[i - 1] + randomreal() / n0;
         }
         ae_vector_set_length(&x1, n1);
         x1.xR[0] = randomreal();
         for (i = 1; i < n1; i++) {
            x1.xR[i] = x1.xR[i - 1] + randomreal() / n1;
         }
         ae_vector_set_length(&needy, n0 * n1);
         v = pow(10.0, -3 * randomreal());
         for (i = 0; i < n0 * n1; i++) {
            needy.xB[i] = randombool(v);
         }
      // Test at grid
         ae_vector_set_length(&x, nx);
         rbfgridcalc2v(&s, &x0, n0, &x1, n1, &yv);
         for (i0 = 0; i0 < n0; i0++) {
            for (i1 = 0; i1 < n1; i1++) {
               x.xR[0] = x0.xR[i0];
               x.xR[1] = x1.xR[i1];
               rbfcalc(&s, &x, &y);
               for (i = 0; i < ny; i++) {
                  set_error_flag(&result, fabs(y.xR[i] - yv.xR[i + ny * (i0 + i1 * n0)]) > errtol, __FILE__, __LINE__, "testrbfunit.ap:3814");
               }
            }
         }
      // Test calculation on subset of regular grid:
      // * Test 1: compare full and subset versions
      // * Test 2: check sparsity. Subset function may perform additional
      //   evaluations because it processes data micro-row by micro-row.
      //   So, we can't check that all elements which were not flagged
      //   are zero - some of them may become non-zero. However, if entire
      //   row is empty, we can reasonably expect (informal guarantee)
      //   that it is not processed. So, we check empty (completely
      //   unflagged) rows
      //
         SetVector(&yv2);
         rbfgridcalc2vsubset(&s, &x0, n0, &x1, n1, &needy, &yv2);
         for (i = 0; i < ny * n0 * n1; i++) {
            set_error_flag(&result, needy.xB[i / ny] && fabs(yv.xR[i] - yv2.xR[i]) > errtol, __FILE__, __LINE__, "testrbfunit.ap:3833");
         }
      // Test legacy function
         rbfgridcalc2(&s, &x0, n0, &x1, n1, &y2);
         for (i = 0; i < n0 * n1; i++) {
            if (ny == 1) {
               set_error_flag(&result, fabs(yv.xR[i] - y2.xyR[i % n0][i / n0]) > errtol, __FILE__, __LINE__, "testrbfunit.ap:3843");
            } else {
               set_error_flag(&result, y2.xyR[i % n0][i / n0] != 0.0, __FILE__, __LINE__, "testrbfunit.ap:3845");
            }
         }
      // Test that scaling RBase, XY, X0, X1 by some power of 2
      // does not change values at grid (quite a strict requirement, but
      // ALGLIB implementation of RBF may deal with it).
         scalefactor = pow(1024.0, (double)(2 * randominteger(2) - 1));
         ae_matrix_set_length(&xy2, n, nx + ny);
         ae_vector_set_length(&x02, n0);
         ae_vector_set_length(&x12, n1);
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               xy2.xyR[i][j] = xy.xyR[i][j] * scalefactor;
            }
            for (j = 0; j < ny; j++) {
               xy2.xyR[i][nx + j] = xy.xyR[i][nx + j];
            }
         }
         for (i = 0; i < n0; i++) {
            x02.xR[i] = x0.xR[i] * scalefactor;
         }
         for (i = 0; i < n1; i++) {
            x12.xR[i] = x1.xR[i] * scalefactor;
         }
         if (hasscale) {
            rbfsetpointsandscales(&s, &xy2, n, &scalevec);
         } else {
            rbfsetpoints(&s, &xy2, n);
         }
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase * scalefactor, nlayers, lambdav);
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:3877");
            ae_frame_leave();
            return result;
         }
         SetVector(&yv2);
         rbfgridcalc2v(&s, &x02, n0, &x12, n1, &yv2);
         for (i = 0; i < ny * n0 * n1; i++) {
            set_error_flag(&result, yv.xR[i] != yv2.xR[i], __FILE__, __LINE__, "testrbfunit.ap:3883");
         }
      // Test that scaling RBase and scale vector by some power of 2
      // (increase RBase and decreasing scale, or vice versa) does not
      // change values at grid (quite a strict requirement, but
      // ALGLIB implementation of RBF may deal with it).
         scalefactor = pow(1024.0, (double)(2 * randominteger(2) - 1));
         ae_vector_set_length(&scalevec2, nx);
         for (i = 0; i < nx; i++) {
            if (hasscale) {
               scalevec2.xR[i] = scalevec.xR[i];
            } else {
               scalevec2.xR[i] = 1.0;
            }
            scalevec2.xR[i] /= scalefactor;
         }
         rbfsetpointsandscales(&s, &xy, n, &scalevec2);
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase * scalefactor, nlayers, lambdav);
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:3907");
            ae_frame_leave();
            return result;
         }
         SetVector(&yv2);
         rbfgridcalc2v(&s, &x0, n0, &x1, n1, &yv2);
         for (i = 0; i < ny * n0 * n1; i++) {
            set_error_flag(&result, fabs(yv.xR[i] - yv2.xR[i]) > 100 * machineepsilon * rmax3(fabs(yv.xR[i]), fabs(yv2.xR[i]), 1.0), __FILE__, __LINE__, "testrbfunit.ap:3913");
         }
      }
   }
// Test 3-dimensional grid calculation
   errtol = 1.0E-12;
   nx = 3;
   for (ny = 1; ny <= 4; ny++) {
      for (nkind = 0; nkind <= 2; nkind++) {
      // problem setup
         n = 150;
         rbase = 0.10;
         lambdav = 1.0E-3 * randominteger(2);
         nlayers = randominteger(3);
         linterm = 1 + randominteger(3);
         bf = randominteger(2);
         ae_matrix_set_length(&xy, n, nx + ny);
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               xy.xyR[i][j] = randomreal();
            }
            for (j = 0; j < ny; j++) {
               xy.xyR[i][nx + j] = randomreal() - 0.5;
            }
         }
         hasscale = randominteger(2) == 0;
         if (hasscale) {
            ae_vector_set_length(&scalevec, nx);
            for (j = 0; j < nx; j++) {
               scalevec.xR[j] = pow(2.0, randommid());
            }
         }
      // Build model
         rbfcreate(nx, ny, &s);
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase, nlayers, lambdav);
         if (linterm == 1) {
            rbfsetlinterm(&s);
         }
         if (linterm == 2) {
            rbfsetconstterm(&s);
         }
         if (linterm == 3) {
            rbfsetzeroterm(&s);
         }
         if (hasscale) {
            rbfsetpointsandscales(&s, &xy, n, &scalevec);
         } else {
            rbfsetpoints(&s, &xy, n);
         }
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:3968");
            ae_frame_leave();
            return result;
         }
      // Prepare grid to test
         n0 = 1 + randominteger(50);
         n1 = 1 + randominteger(50);
         n2 = 1 + randominteger(50);
         if (nkind == 1) {
            k = randominteger(3);
            if (k == 0) {
               n0 = 1;
            }
            if (k == 1) {
               n1 = 1;
            }
            if (k == 2) {
               n2 = 1;
            }
         } else {
            if (nkind == 2) {
               n0 = 1;
               n1 = 1;
               n2 = 1;
            } else {
               ae_assert(nkind == 0, "Assertion failed");
            }
         }
         ae_vector_set_length(&x0, n0);
         x0.xR[0] = randomreal();
         for (i = 1; i < n0; i++) {
            x0.xR[i] = x0.xR[i - 1] + randomreal() / n0;
         }
         ae_vector_set_length(&x1, n1);
         x1.xR[0] = randomreal();
         for (i = 1; i < n1; i++) {
            x1.xR[i] = x1.xR[i - 1] + randomreal() / n1;
         }
         ae_vector_set_length(&x2, n2);
         x2.xR[0] = randomreal();
         for (i = 1; i < n2; i++) {
            x2.xR[i] = x2.xR[i - 1] + randomreal() / n2;
         }
         ae_vector_set_length(&needy, n0 * n1 * n2);
         v = pow(10.0, -3 * randomreal());
         for (i = 0; i < n0 * n1 * n2; i++) {
            needy.xB[i] = randombool(v);
         }
      // Test at grid
         ae_vector_set_length(&x, nx);
         rbfgridcalc3v(&s, &x0, n0, &x1, n1, &x2, n2, &yv);
         for (i0 = 0; i0 < n0; i0++) {
            for (i1 = 0; i1 < n1; i1++) {
               for (i2 = 0; i2 < n2; i2++) {
                  x.xR[0] = x0.xR[i0];
                  x.xR[1] = x1.xR[i1];
                  x.xR[2] = x2.xR[i2];
                  rbfcalc(&s, &x, &y);
                  for (i = 0; i < ny; i++) {
                     set_error_flag(&result, fabs(y.xR[i] - yv.xR[i + ny * (i0 + i1 * n0 + i2 * n0 * n1)]) > errtol, __FILE__, __LINE__, "testrbfunit.ap:4027");
                  }
               }
            }
         }
      // Test calculation on subset of regular grid:
      // * Test 1: compare full and subset versions
      // * Test 2: check sparsity. Subset function may perform additional
      //   evaluations because it processes data micro-row by micro-row.
      //   So, we can't check that all elements which were not flagged
      //   are zero - some of them may become non-zero. However, if entire
      //   row is empty, we can reasonably expect (informal guarantee)
      //   that it is not processed. So, we check empty (completely
      //   unflagged) rows
      //
         ae_vector_set_length(&rowflags, n1 * n2);
         for (i = 0; i < n1 * n2; i++) {
            rowflags.xB[i] = false;
         }
         for (i = 0; i < n0 * n1 * n2; i++) {
            if (needy.xB[i]) {
               rowflags.xB[i / n0] = true;
            }
         }
         SetVector(&yv2);
         rbfgridcalc3vsubset(&s, &x0, n0, &x1, n1, &x2, n2, &needy, &yv2);
         for (i = 0; i < ny * n0 * n1 * n2; i++) {
            set_error_flag(&result, needy.xB[i / ny] && fabs(yv.xR[i] - yv2.xR[i]) > errtol, __FILE__, __LINE__, "testrbfunit.ap:4054");
            set_error_flag(&result, !rowflags.xB[i / (ny * n0)] && yv2.xR[i] != 0.0, __FILE__, __LINE__, "testrbfunit.ap:4055");
         }
      // Test that scaling RBase, XY, X0, X1 and X2 by some power of 2
      // does not change values at grid (quite a strict requirement, but
      // ALGLIB implementation of RBF may deal with it).
         scalefactor = pow(1024.0, (double)(2 * randominteger(2) - 1));
         ae_matrix_set_length(&xy2, n, nx + ny);
         ae_vector_set_length(&x02, n0);
         ae_vector_set_length(&x12, n1);
         ae_vector_set_length(&x22, n2);
         for (i = 0; i < n; i++) {
            for (j = 0; j < nx; j++) {
               xy2.xyR[i][j] = xy.xyR[i][j] * scalefactor;
            }
            for (j = 0; j < ny; j++) {
               xy2.xyR[i][nx + j] = xy.xyR[i][nx + j];
            }
         }
         for (i = 0; i < n0; i++) {
            x02.xR[i] = x0.xR[i] * scalefactor;
         }
         for (i = 0; i < n1; i++) {
            x12.xR[i] = x1.xR[i] * scalefactor;
         }
         for (i = 0; i < n2; i++) {
            x22.xR[i] = x2.xR[i] * scalefactor;
         }
         if (hasscale) {
            rbfsetpointsandscales(&s, &xy2, n, &scalevec);
         } else {
            rbfsetpoints(&s, &xy2, n);
         }
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase * scalefactor, nlayers, lambdav);
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:4090");
            ae_frame_leave();
            return result;
         }
         SetVector(&yv2);
         rbfgridcalc3v(&s, &x02, n0, &x12, n1, &x22, n2, &yv2);
         for (i = 0; i < ny * n0 * n1 * n2; i++) {
            set_error_flag(&result, yv.xR[i] != yv2.xR[i], __FILE__, __LINE__, "testrbfunit.ap:4096");
         }
      // Test that scaling RBase and scale vector by some power of 2
      // (increase RBase and decreasing scale, or vice versa) does not
      // change values at grid (quite a strict requirement, but
      // ALGLIB implementation of RBF may deal with it).
         scalefactor = pow(1024.0, (double)(2 * randominteger(2) - 1));
         ae_vector_set_length(&scalevec2, nx);
         for (i = 0; i < nx; i++) {
            if (hasscale) {
               scalevec2.xR[i] = scalevec.xR[i];
            } else {
               scalevec2.xR[i] = 1.0;
            }
            scalevec2.xR[i] /= scalefactor;
         }
         rbfsetpointsandscales(&s, &xy, n, &scalevec2);
         rbfsetv2bf(&s, bf);
         rbfsetalgohierarchical(&s, rbase * scalefactor, nlayers, lambdav);
         rbfbuildmodel(&s, &rep);
         if (rep.terminationtype <= 0) {
            set_error_flag(&result, true, __FILE__, __LINE__, "testrbfunit.ap:4120");
            ae_frame_leave();
            return result;
         }
         SetVector(&yv2);
         rbfgridcalc3v(&s, &x0, n0, &x1, n1, &x2, n2, &yv2);
         for (i = 0; i < ny * n0 * n1 * n2; i++) {
            set_error_flag(&result, fabs(yv.xR[i] - yv2.xR[i]) > 100 * machineepsilon * rmax3(fabs(yv.xR[i]), fabs(yv2.xR[i]), 1.0), __FILE__, __LINE__, "testrbfunit.ap:4126");
         }
      }
   }
   ae_frame_leave();
   return result;
}

bool testrbf(bool silent) {
   bool specialerrors;
   bool basicrbferrors;
   bool irregularrbferrors;
   bool linearitymodelrbferr;
   bool sqrdegmatrixrbferr;
   bool sererrors;
   bool multilayerrbf1derrors;
   bool multilayerrbferrors;
   bool gridcalc23errors;
   bool hrbfbasicerrors;
   bool hrbfscaleerrors;
   bool hrbfspecerrors;
   bool hrbfgriderrors;
   bool hrbferrors;
   bool waserrors;
   bool result;
// HRBF tests
   hrbfbasicerrors = testrbfunit_basichrbftest();
   hrbfspecerrors = testrbfunit_spechrbftest();
   hrbfscaleerrors = testrbfunit_scaledhrbftest();
   hrbfgriderrors = testrbfunit_gridhrbftest();
   hrbferrors = ((hrbfbasicerrors || hrbfspecerrors) || hrbfscaleerrors) || hrbfgriderrors;
// Other tests
   specialerrors = testrbfunit_specialtest();
   basicrbferrors = testrbfunit_basicrbftest();
   irregularrbferrors = testrbfunit_irregularrbftest();
   linearitymodelrbferr = testrbfunit_linearitymodelrbftest();
   sqrdegmatrixrbferr = sqrdegmatrixrbftest(true);
   multilayerrbf1derrors = false;
   multilayerrbferrors = testrbfunit_basicmultilayerrbftest();
   sererrors = testrbfunit_serializationtest();
   gridcalc23errors = false;
   testrbfunit_gridcalc23test(&gridcalc23errors);
// report
   waserrors = ((((((((specialerrors || basicrbferrors) || irregularrbferrors) || linearitymodelrbferr) || sqrdegmatrixrbferr) || sererrors) || multilayerrbf1derrors) || multilayerrbferrors) || gridcalc23errors) || hrbferrors;
   if (!silent) {
      printf("TESTING RBF\n");
      printf("GENERAL TESTS:\n");
      printf("* serialization test:                              ");
      if (sererrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* special properties:                              ");
      if (specialerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("RBF-V2:\n");
      printf("* basic HRBF test:                                 ");
      if (hrbfbasicerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* scale-related tests:                             ");
      if (hrbfscaleerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* grid calculation tests:                          ");
      if (hrbfgriderrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* special properties:                              ");
      if (hrbfspecerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("RBF-V1:\n");
      printf("* basicRBFTest:                                    ");
      if (basicrbferrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* irregularRBFTest:                                ");
      if (irregularrbferrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* linearity test:                                  ");
      if (linearitymodelrbferr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* SqrDegMatrixRBFTest:                             ");
      if (sqrdegmatrixrbferr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* MultiLayerRBFErrors in 1D test:                  ");
      if (multilayerrbf1derrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* MultiLayerRBFErrors in 2-3D test:                ");
      if (multilayerrbferrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* GridCalc2/3V:                                    ");
      if (gridcalc23errors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
   // was errors?
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === fft testing unit ===
// Internal complex FFT stub.
// Uses straightforward formula with O(N^2) complexity.
static void testfftunit_refinternalcfft(RVector *a, ae_int_t nn, bool inversefft) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t k;
   double hre;
   double him;
   double c;
   double s;
   double re;
   double im;
   ae_frame_make(&_frame_block);
   NewVector(tmp, 0, DT_REAL);
   ae_vector_set_length(&tmp, 2 * nn - 1 + 1);
   if (!inversefft) {
      for (i = 0; i < nn; i++) {
         hre = 0.0;
         him = 0.0;
         for (k = 0; k < nn; k++) {
            re = a->xR[2 * k];
            im = a->xR[2 * k + 1];
            c = cos(-2 * pi * k * i / nn);
            s = sin(-2 * pi * k * i / nn);
            hre += c * re - s * im;
            him += c * im + s * re;
         }
         tmp.xR[2 * i] = hre;
         tmp.xR[2 * i + 1] = him;
      }
      for (i = 0; i < 2 * nn; i++) {
         a->xR[i] = tmp.xR[i];
      }
   } else {
      for (k = 0; k < nn; k++) {
         hre = 0.0;
         him = 0.0;
         for (i = 0; i < nn; i++) {
            re = a->xR[2 * i];
            im = a->xR[2 * i + 1];
            c = cos(2 * pi * k * i / nn);
            s = sin(2 * pi * k * i / nn);
            hre += c * re - s * im;
            him += c * im + s * re;
         }
         tmp.xR[2 * k] = hre / nn;
         tmp.xR[2 * k + 1] = him / nn;
      }
      for (i = 0; i < 2 * nn; i++) {
         a->xR[i] = tmp.xR[i];
      }
   }
   ae_frame_leave();
}

// Internal real FFT stub.
// Uses straightforward formula with O(N^2) complexity.
static void testfftunit_refinternalrfft(RVector *a, ae_int_t nn, CVector *f) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   SetVector(f);
   NewVector(tmp, 0, DT_REAL);
   ae_vector_set_length(&tmp, 2 * nn - 1 + 1);
   for (i = 0; i < nn; i++) {
      tmp.xR[2 * i] = a->xR[i];
      tmp.xR[2 * i + 1] = 0.0;
   }
   testfftunit_refinternalcfft(&tmp, nn, false);
   ae_vector_set_length(f, nn);
   for (i = 0; i < nn; i++) {
      f->xC[i] = complex_from_d(tmp.xR[2 * i + 0], tmp.xR[2 * i + 1]);
   }
   ae_frame_leave();
}

// Reference FFT
static void testfftunit_reffftc1d(CVector *a, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewVector(buf, 0, DT_REAL);
   ae_assert(n > 0, "FFTC1D: incorrect N!");
   ae_vector_set_length(&buf, 2 * n);
   for (i = 0; i < n; i++) {
      buf.xR[2 * i + 0] = a->xC[i].x;
      buf.xR[2 * i + 1] = a->xC[i].y;
   }
   testfftunit_refinternalcfft(&buf, n, false);
   for (i = 0; i < n; i++) {
      a->xC[i] = complex_from_d(buf.xR[2 * i + 0], buf.xR[2 * i + 1]);
   }
   ae_frame_leave();
}

// Reference inverse FFT
static void testfftunit_reffftc1dinv(CVector *a, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewVector(buf, 0, DT_REAL);
   ae_assert(n > 0, "FFTC1DInv: incorrect N!");
   ae_vector_set_length(&buf, 2 * n);
   for (i = 0; i < n; i++) {
      buf.xR[2 * i + 0] = a->xC[i].x;
      buf.xR[2 * i + 1] = a->xC[i].y;
   }
   testfftunit_refinternalcfft(&buf, n, true);
   for (i = 0; i < n; i++) {
      a->xC[i] = complex_from_d(buf.xR[2 * i + 0], buf.xR[2 * i + 1]);
   }
   ae_frame_leave();
}

// This function performs real/complex FFT of given length on random data,
// selects K random components and compares them with values calculated by
// DFT definition.
//
// It updates RefErr and RefRErr as follows:
//     RefErr:=  max(RefErr, error_of_complex_FFT)
//     RefRErr:= max(RefRErr,error_of_real_FFT)
//
static void testfftunit_quicktest(ae_int_t n, double *referr, double *refrerr) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t idx;
   complex v;
   double c;
   double s;
   double re;
   double im;
   ae_frame_make(&_frame_block);
   NewVector(a0, 0, DT_COMPLEX);
   NewVector(a1, 0, DT_COMPLEX);
   k = 10;
// Complex FFT - forward and inverse
   ae_vector_set_length(&a0, n);
   ae_vector_set_length(&a1, n);
   for (i = 0; i < n; i++) {
      a0.xC[i] = complex_from_d(randommid(), randommid());
      a1.xC[i] = a0.xC[i];
   }
   fftc1d(&a0, n);
   for (i = 0; i < k; i++) {
      idx = randominteger(n);
      v = complex_from_i(0);
      for (j = 0; j < n; j++) {
         re = a1.xC[j].x;
         im = a1.xC[j].y;
         c = cos(-2 * pi * j * idx / n);
         s = sin(-2 * pi * j * idx / n);
         v.x += c * re - s * im;
         v.y += c * im + s * re;
      }
      *referr = rmax2(*referr, abscomplex(ae_c_sub(v, a0.xC[idx])));
   }
   fftc1dinv(&a0, n);
   for (i = 0; i < n; i++) {
      *referr = rmax2(*referr, abscomplex(ae_c_sub(a0.xC[i], a1.xC[i])));
   }
   ae_frame_leave();
}

// Test
bool testfft(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t k;
   ae_int_t maxsmalln;
   double bidierr;
   double bidirerr;
   double referr;
   double refrerr;
   double reinterr;
   double errtol;
   bool referrors;
   bool bidierrors;
   bool refrerrors;
   bool bidirerrors;
   bool reinterrors;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(a1, 0, DT_COMPLEX);
   NewVector(a2, 0, DT_COMPLEX);
   NewVector(a3, 0, DT_COMPLEX);
   NewVector(r1, 0, DT_REAL);
   NewVector(r2, 0, DT_REAL);
   NewVector(buf, 0, DT_REAL);
   NewObj(fasttransformplan, plan);
   maxsmalln = 128;
   errtol = 100000 * pow((double)maxsmalln, 3.0 / 2.0) * machineepsilon;
   bidierrors = false;
   referrors = false;
   bidirerrors = false;
   refrerrors = false;
   reinterrors = false;
   waserrors = false;
// Test bi-directional error: norm(x-invFFT(FFT(x)))
   bidierr = 0.0;
   bidirerr = 0.0;
   for (n = 1; n <= maxsmalln; n++) {
   // Complex FFT/invFFT
      ae_vector_set_length(&a1, n);
      ae_vector_set_length(&a2, n);
      ae_vector_set_length(&a3, n);
      for (i = 0; i < n; i++) {
         a1.xC[i] = complex_from_d(randommid(), randommid());
         a2.xC[i] = a1.xC[i];
         a3.xC[i] = a1.xC[i];
      }
      fftc1d(&a2, n);
      fftc1dinv(&a2, n);
      fftc1dinv(&a3, n);
      fftc1d(&a3, n);
      for (i = 0; i < n; i++) {
         bidierr = rmax2(bidierr, abscomplex(ae_c_sub(a1.xC[i], a2.xC[i])));
         bidierr = rmax2(bidierr, abscomplex(ae_c_sub(a1.xC[i], a3.xC[i])));
      }
   // Real
      ae_vector_set_length(&r1, n);
      ae_vector_set_length(&r2, n);
      for (i = 0; i < n; i++) {
         r1.xR[i] = randommid();
         r2.xR[i] = r1.xR[i];
      }
      fftr1d(&r2, n, &a1);
      ae_v_muld(r2.xR, 1, n, 0);
      fftr1dinv(&a1, n, &r2);
      for (i = 0; i < n; i++) {
         bidirerr = rmax2(bidirerr, abscomplex(complex_from_d(r1.xR[i] - r2.xR[i])));
      }
   }
   bidierrors = bidierrors || bidierr > errtol;
   bidirerrors = bidirerrors || bidirerr > errtol;
// Test against reference O(N^2) implementation for small N's
// (we do not test large N's because reference implementation will be too slow).
   referr = 0.0;
   refrerr = 0.0;
   for (n = 1; n <= maxsmalln; n++) {
   // Complex FFT
      ae_vector_set_length(&a1, n);
      ae_vector_set_length(&a2, n);
      for (i = 0; i < n; i++) {
         a1.xC[i] = complex_from_d(randommid(), randommid());
         a2.xC[i] = a1.xC[i];
      }
      fftc1d(&a1, n);
      testfftunit_reffftc1d(&a2, n);
      for (i = 0; i < n; i++) {
         referr = rmax2(referr, abscomplex(ae_c_sub(a1.xC[i], a2.xC[i])));
      }
   // Complex inverse FFT
      ae_vector_set_length(&a1, n);
      ae_vector_set_length(&a2, n);
      for (i = 0; i < n; i++) {
         a1.xC[i] = complex_from_d(randommid(), randommid());
         a2.xC[i] = a1.xC[i];
      }
      fftc1dinv(&a1, n);
      testfftunit_reffftc1dinv(&a2, n);
      for (i = 0; i < n; i++) {
         referr = rmax2(referr, abscomplex(ae_c_sub(a1.xC[i], a2.xC[i])));
      }
   // Real forward/inverse FFT:
   // * calculate and check forward FFT
   // * use precalculated FFT to check backward FFT
   //   fill unused parts of frequencies array with random numbers
   //   to ensure that they are not really used
      ae_vector_set_length(&r1, n);
      ae_vector_set_length(&r2, n);
      for (i = 0; i < n; i++) {
         r1.xR[i] = randommid();
         r2.xR[i] = r1.xR[i];
      }
      fftr1d(&r1, n, &a1);
      testfftunit_refinternalrfft(&r2, n, &a2);
      for (i = 0; i < n; i++) {
         refrerr = rmax2(refrerr, abscomplex(ae_c_sub(a1.xC[i], a2.xC[i])));
      }
      ae_vector_set_length(&a3, n / 2 + 1);
      for (i = 0; i <= n / 2; i++) {
         a3.xC[i] = a2.xC[i];
      }
      a3.xC[0].y = randommid();
      if (n % 2 == 0) {
         a3.xC[n / 2].y = randommid();
      }
      for (i = 0; i < n; i++) {
         r1.xR[i] = 0.0;
      }
      fftr1dinv(&a3, n, &r1);
      for (i = 0; i < n; i++) {
         refrerr = rmax2(refrerr, fabs(r2.xR[i] - r1.xR[i]));
      }
   }
   referrors = referrors || referr > errtol;
   refrerrors = refrerrors || refrerr > errtol;
// Test for large N's:
// * we perform FFT
// * we selectively calculate K (small number) of DFT components (using reference formula)
//   and compare them with ones calculated by fast implementation
// * K components to test are chosen at random (random sampling with possible repetitions)
// * overall complexity of the test is O(N*logN+K*N)
// Several N's are tested, with different kinds of factorizations
   referr = 0.0;
   refrerr = 0.0;
   testfftunit_quicktest(1000, &referr, &refrerr);
   testfftunit_quicktest(1024, &referr, &refrerr);
   testfftunit_quicktest(1025, &referr, &refrerr);
   testfftunit_quicktest(2000, &referr, &refrerr);
   testfftunit_quicktest(2048, &referr, &refrerr);
   testfftunit_quicktest(6535, &referr, &refrerr);
   testfftunit_quicktest(65536, &referr, &refrerr);
   testfftunit_quicktest(104729, &referr, &refrerr);
   testfftunit_quicktest(139129, &referr, &refrerr);
   testfftunit_quicktest(141740, &referr, &refrerr);
   referrors = referrors || referr > errtol;
   refrerrors = refrerrors || refrerr > errtol;
// test internal real even FFT
   reinterr = 0.0;
   for (k = 1; k <= maxsmalln / 2; k++) {
      n = 2 * k;
   // Real forward FFT
      ae_vector_set_length(&r1, n);
      ae_vector_set_length(&r2, n);
      for (i = 0; i < n; i++) {
         r1.xR[i] = randommid();
         r2.xR[i] = r1.xR[i];
      }
      ftcomplexfftplan(n / 2, 1, &plan);
      ae_vector_set_length(&buf, n);
      fftr1dinternaleven(&r1, n, &buf, &plan);
      testfftunit_refinternalrfft(&r2, n, &a2);
      reinterr = rmax2(reinterr, fabs(r1.xR[0] - a2.xC[0].x));
      reinterr = rmax2(reinterr, fabs(r1.xR[1] - a2.xC[n / 2].x));
      for (i = 1; i < n / 2; i++) {
         reinterr = rmax2(reinterr, fabs(r1.xR[2 * i + 0] - a2.xC[i].x));
         reinterr = rmax2(reinterr, fabs(r1.xR[2 * i + 1] - a2.xC[i].y));
      }
   // Real backward FFT
      ae_vector_set_length(&r1, n);
      for (i = 0; i < n; i++) {
         r1.xR[i] = randommid();
      }
      ae_vector_set_length(&a2, n / 2 + 1);
      a2.xC[0] = complex_from_d(r1.xR[0]);
      for (i = 1; i < n / 2; i++) {
         a2.xC[i] = complex_from_d(r1.xR[2 * i + 0], r1.xR[2 * i + 1]);
      }
      a2.xC[n / 2] = complex_from_d(r1.xR[1]);
      ftcomplexfftplan(n / 2, 1, &plan);
      ae_vector_set_length(&buf, n);
      fftr1dinvinternaleven(&r1, n, &buf, &plan);
      fftr1dinv(&a2, n, &r2);
      for (i = 0; i < n; i++) {
         reinterr = rmax2(reinterr, fabs(r1.xR[i] - r2.xR[i]));
      }
   }
   reinterrors = reinterrors || reinterr > errtol;
// end
   waserrors = (((bidierrors || bidirerrors) || referrors) || refrerrors) || reinterrors;
   if (!silent) {
      printf("TESTING FFT\n");
      printf("FINAL RESULT:                             ");
      if (waserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* BI-DIRECTIONAL COMPLEX TEST:            ");
      if (bidierrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* AGAINST REFERENCE COMPLEX FFT:          ");
      if (referrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* BI-DIRECTIONAL REAL TEST:               ");
      if (bidirerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* AGAINST REFERENCE REAL FFT:             ");
      if (refrerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* INTERNAL EVEN FFT:                      ");
      if (reinterrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === fht testing unit ===
// Reference FHT
static void testfhtunit_reffhtr1d(RVector *a, ae_int_t n) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_frame_make(&_frame_block);
   NewVector(buf, 0, DT_REAL);
   ae_assert(n > 0, "RefFHTR1D: incorrect N!");
   ae_vector_set_length(&buf, n);
   for (i = 0; i < n; i++) {
      v = 0.0;
      for (j = 0; j < n; j++) {
         v += a->xR[j] * (cos(2 * pi * i * j / n) + sin(2 * pi * i * j / n));
      }
      buf.xR[i] = v;
   }
   for (i = 0; i < n; i++) {
      a->xR[i] = buf.xR[i];
   }
   ae_frame_leave();
}

// Reference inverse FHT
static void testfhtunit_reffhtr1dinv(RVector *a, ae_int_t n) {
   ae_int_t i;
   ae_assert(n > 0, "RefFHTR1DInv: incorrect N!");
   testfhtunit_reffhtr1d(a, n);
   for (i = 0; i < n; i++) {
      a->xR[i] /= n;
   }
}

// Test
bool testfht(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t maxn;
   double bidierr;
   double referr;
   double errtol;
   bool referrors;
   bool bidierrors;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(r1, 0, DT_REAL);
   NewVector(r2, 0, DT_REAL);
   NewVector(r3, 0, DT_REAL);
   maxn = 128;
   errtol = 100000 * pow((double)maxn, 3.0 / 2.0) * machineepsilon;
   bidierrors = false;
   referrors = false;
   waserrors = false;
// Test bi-directional error: norm(x-invFHT(FHT(x)))
   bidierr = 0.0;
   for (n = 1; n <= maxn; n++) {
   // FHT/invFHT
      ae_vector_set_length(&r1, n);
      ae_vector_set_length(&r2, n);
      ae_vector_set_length(&r3, n);
      for (i = 0; i < n; i++) {
         r1.xR[i] = randommid();
         r2.xR[i] = r1.xR[i];
         r3.xR[i] = r1.xR[i];
      }
      fhtr1d(&r2, n);
      fhtr1dinv(&r2, n);
      fhtr1dinv(&r3, n);
      fhtr1d(&r3, n);
      for (i = 0; i < n; i++) {
         bidierr = rmax2(bidierr, fabs(r1.xR[i] - r2.xR[i]));
         bidierr = rmax2(bidierr, fabs(r1.xR[i] - r3.xR[i]));
      }
   }
   bidierrors = bidierrors || bidierr > errtol;
// Test against reference O(N^2) implementation
   referr = 0.0;
   for (n = 1; n <= maxn; n++) {
   // FHT
      ae_vector_set_length(&r1, n);
      ae_vector_set_length(&r2, n);
      for (i = 0; i < n; i++) {
         r1.xR[i] = randommid();
         r2.xR[i] = r1.xR[i];
      }
      fhtr1d(&r1, n);
      testfhtunit_reffhtr1d(&r2, n);
      for (i = 0; i < n; i++) {
         referr = rmax2(referr, fabs(r1.xR[i] - r2.xR[i]));
      }
   // inverse FHT
      ae_vector_set_length(&r1, n);
      ae_vector_set_length(&r2, n);
      for (i = 0; i < n; i++) {
         r1.xR[i] = randommid();
         r2.xR[i] = r1.xR[i];
      }
      fhtr1dinv(&r1, n);
      testfhtunit_reffhtr1dinv(&r2, n);
      for (i = 0; i < n; i++) {
         referr = rmax2(referr, fabs(r1.xR[i] - r2.xR[i]));
      }
   }
   referrors = referrors || referr > errtol;
// end
   waserrors = bidierrors || referrors;
   if (!silent) {
      printf("TESTING FHT\n");
      printf("FINAL RESULT:                             ");
      if (waserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* BI-DIRECTIONAL TEST:                    ");
      if (bidierrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* AGAINST REFERENCE FHT:                  ");
      if (referrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === conv testing unit ===
// Reference FFT
static void testconvunit_refconvr1d(RVector *a, ae_int_t m, RVector *b, ae_int_t n, RVector *r) {
   ae_int_t i;
   double v;
   SetVector(r);
   ae_vector_set_length(r, m + n - 1);
   for (i = 0; i < m + n - 1; i++) {
      r->xR[i] = 0.0;
   }
   for (i = 0; i < m; i++) {
      v = a->xR[i];
      ae_v_addd(&r->xR[i], 1, b->xR, 1, n, v);
   }
}

// Reference implementation
static void testconvunit_refconvc1d(CVector *a, ae_int_t m, CVector *b, ae_int_t n, CVector *r) {
   ae_int_t i;
   complex v;
   SetVector(r);
   ae_vector_set_length(r, m + n - 1);
   for (i = 0; i < m + n - 1; i++) {
      r->xC[i] = complex_from_i(0);
   }
   for (i = 0; i < m; i++) {
      v = a->xC[i];
      ae_v_caddc(&r->xC[i], 1, b->xC, 1, "N", n, v);
   }
}

// Reference implementation
static void testconvunit_refconvr1dcircular(RVector *a, ae_int_t m, RVector *b, ae_int_t n, RVector *r) {
   ae_frame _frame_block;
   ae_int_t i1;
   ae_int_t i2;
   ae_int_t j2;
   ae_frame_make(&_frame_block);
   SetVector(r);
   NewVector(buf, 0, DT_REAL);
   testconvunit_refconvr1d(a, m, b, n, &buf);
   ae_vector_set_length(r, m);
   ae_v_move(r->xR, 1, buf.xR, 1, m);
   i1 = m;
   while (i1 < m + n - 1) {
      i2 = imin2(i1 + m - 1, m + n - 2);
      j2 = i2 - i1;
      ae_v_add(r->xR, 1, &buf.xR[i1], 1, j2 + 1);
      i1 += m;
   }
   ae_frame_leave();
}

// Reference implementation
static void testconvunit_refconvc1dcircular(CVector *a, ae_int_t m, CVector *b, ae_int_t n, CVector *r) {
   ae_frame _frame_block;
   ae_int_t i1;
   ae_int_t i2;
   ae_int_t j2;
   ae_frame_make(&_frame_block);
   SetVector(r);
   NewVector(buf, 0, DT_COMPLEX);
   testconvunit_refconvc1d(a, m, b, n, &buf);
   ae_vector_set_length(r, m);
   ae_v_cmove(r->xC, 1, buf.xC, 1, "N", m);
   i1 = m;
   while (i1 < m + n - 1) {
      i2 = imin2(i1 + m - 1, m + n - 2);
      j2 = i2 - i1;
      ae_v_cadd(r->xC, 1, &buf.xC[i1], 1, "N", j2 + 1);
      i1 += m;
   }
   ae_frame_leave();
}

// Test
bool testconv(bool silent) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t i;
   ae_int_t rkind;
   ae_int_t circkind;
   ae_int_t maxn;
   double referr;
   double refrerr;
   double inverr;
   double invrerr;
   double errtol;
   bool referrors;
   bool refrerrors;
   bool inverrors;
   bool invrerrors;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(ra, 0, DT_REAL);
   NewVector(rb, 0, DT_REAL);
   NewVector(rr1, 0, DT_REAL);
   NewVector(rr2, 0, DT_REAL);
   NewVector(ca, 0, DT_COMPLEX);
   NewVector(cb, 0, DT_COMPLEX);
   NewVector(cr1, 0, DT_COMPLEX);
   NewVector(cr2, 0, DT_COMPLEX);
   maxn = 32;
   errtol = 100000 * pow((double)maxn, 3.0 / 2.0) * machineepsilon;
   referrors = false;
   refrerrors = false;
   inverrors = false;
   invrerrors = false;
   waserrors = false;
// Test against reference O(N^2) implementation.
//
// Automatic ConvC1D() and different algorithms of ConvC1DX() are tested.
   referr = 0.0;
   refrerr = 0.0;
   for (m = 1; m <= maxn; m++) {
      for (n = 1; n <= maxn; n++) {
         for (circkind = 0; circkind <= 1; circkind++) {
            for (rkind = -3; rkind <= 1; rkind++) {
            // skip impossible combinations of parameters:
            // * circular convolution, M<N, RKind != -3 - internal subroutine does not support M<N.
               if ((circkind != 0 && m < n) && rkind != -3) {
                  continue;
               }
            // Complex convolution
               ae_vector_set_length(&ca, m);
               for (i = 0; i < m; i++) {
                  ca.xC[i] = complex_from_d(randommid(), randommid());
               }
               ae_vector_set_length(&cb, n);
               for (i = 0; i < n; i++) {
                  cb.xC[i] = complex_from_d(randommid(), randommid());
               }
               ae_vector_set_length(&cr1, 1);
               if (rkind == -3) {
               // test wrapper subroutine:
               // * circular/non-circular
                  if (circkind == 0) {
                     convc1d(&ca, m, &cb, n, &cr1);
                  } else {
                     convc1dcircular(&ca, m, &cb, n, &cr1);
                  }
               } else {
               // test internal subroutine
                  if (m >= n) {
                  // test internal subroutine:
                  // * circular/non-circular mode
                     convc1dx(&ca, m, &cb, n, circkind != 0, rkind, 0, &cr1);
                  } else {
                  // test internal subroutine - circular mode only
                     ae_assert(circkind == 0, "Convolution test: internal error!");
                     convc1dx(&cb, n, &ca, m, false, rkind, 0, &cr1);
                  }
               }
               if (circkind == 0) {
                  testconvunit_refconvc1d(&ca, m, &cb, n, &cr2);
               } else {
                  testconvunit_refconvc1dcircular(&ca, m, &cb, n, &cr2);
               }
               if (circkind == 0) {
                  for (i = 0; i < m + n - 1; i++) {
                     referr = rmax2(referr, abscomplex(ae_c_sub(cr1.xC[i], cr2.xC[i])));
                  }
               } else {
                  for (i = 0; i < m; i++) {
                     referr = rmax2(referr, abscomplex(ae_c_sub(cr1.xC[i], cr2.xC[i])));
                  }
               }
            // Real convolution
               ae_vector_set_length(&ra, m);
               for (i = 0; i < m; i++) {
                  ra.xR[i] = randommid();
               }
               ae_vector_set_length(&rb, n);
               for (i = 0; i < n; i++) {
                  rb.xR[i] = randommid();
               }
               ae_vector_set_length(&rr1, 1);
               if (rkind == -3) {
               // test wrapper subroutine:
               // * circular/non-circular
                  if (circkind == 0) {
                     convr1d(&ra, m, &rb, n, &rr1);
                  } else {
                     convr1dcircular(&ra, m, &rb, n, &rr1);
                  }
               } else {
                  if (m >= n) {
                  // test internal subroutine:
                  // * circular/non-circular mode
                     convr1dx(&ra, m, &rb, n, circkind != 0, rkind, 0, &rr1);
                  } else {
                  // test internal subroutine - non-circular mode only
                     convr1dx(&rb, n, &ra, m, circkind != 0, rkind, 0, &rr1);
                  }
               }
               if (circkind == 0) {
                  testconvunit_refconvr1d(&ra, m, &rb, n, &rr2);
               } else {
                  testconvunit_refconvr1dcircular(&ra, m, &rb, n, &rr2);
               }
               if (circkind == 0) {
                  for (i = 0; i < m + n - 1; i++) {
                     refrerr = rmax2(refrerr, fabs(rr1.xR[i] - rr2.xR[i]));
                  }
               } else {
                  for (i = 0; i < m; i++) {
                     refrerr = rmax2(refrerr, fabs(rr1.xR[i] - rr2.xR[i]));
                  }
               }
            }
         }
      }
   }
   referrors = referrors || referr > errtol;
   refrerrors = refrerrors || refrerr > errtol;
// Test inverse convolution
   inverr = 0.0;
   invrerr = 0.0;
   for (m = 1; m <= maxn; m++) {
      for (n = 1; n <= maxn; n++) {
      // Complex circilar and non-circular
         ae_vector_set_length(&ca, m);
         for (i = 0; i < m; i++) {
            ca.xC[i] = complex_from_d(randommid(), randommid());
         }
         ae_vector_set_length(&cb, n);
         for (i = 0; i < n; i++) {
            cb.xC[i] = complex_from_d(randommid(), randommid());
         }
         ae_vector_set_length(&cr1, 1);
         ae_vector_set_length(&cr2, 1);
         convc1d(&ca, m, &cb, n, &cr2);
         convc1dinv(&cr2, m + n - 1, &cb, n, &cr1);
         for (i = 0; i < m; i++) {
            inverr = rmax2(inverr, abscomplex(ae_c_sub(cr1.xC[i], ca.xC[i])));
         }
         ae_vector_set_length(&cr1, 1);
         ae_vector_set_length(&cr2, 1);
         convc1dcircular(&ca, m, &cb, n, &cr2);
         convc1dcircularinv(&cr2, m, &cb, n, &cr1);
         for (i = 0; i < m; i++) {
            inverr = rmax2(inverr, abscomplex(ae_c_sub(cr1.xC[i], ca.xC[i])));
         }
      // Real circilar and non-circular
         ae_vector_set_length(&ra, m);
         for (i = 0; i < m; i++) {
            ra.xR[i] = randommid();
         }
         ae_vector_set_length(&rb, n);
         for (i = 0; i < n; i++) {
            rb.xR[i] = randommid();
         }
         ae_vector_set_length(&rr1, 1);
         ae_vector_set_length(&rr2, 1);
         convr1d(&ra, m, &rb, n, &rr2);
         convr1dinv(&rr2, m + n - 1, &rb, n, &rr1);
         for (i = 0; i < m; i++) {
            invrerr = rmax2(invrerr, fabs(rr1.xR[i] - ra.xR[i]));
         }
         ae_vector_set_length(&rr1, 1);
         ae_vector_set_length(&rr2, 1);
         convr1dcircular(&ra, m, &rb, n, &rr2);
         convr1dcircularinv(&rr2, m, &rb, n, &rr1);
         for (i = 0; i < m; i++) {
            invrerr = rmax2(invrerr, fabs(rr1.xR[i] - ra.xR[i]));
         }
      }
   }
   inverrors = inverrors || inverr > errtol;
   invrerrors = invrerrors || invrerr > errtol;
// end
   waserrors = ((referrors || refrerrors) || inverrors) || invrerrors;
   if (!silent) {
      printf("TESTING CONVOLUTION\n");
      printf("FINAL RESULT:                             ");
      if (waserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* AGAINST REFERENCE COMPLEX CONV:         ");
      if (referrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* AGAINST REFERENCE REAL CONV:            ");
      if (refrerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* COMPLEX INVERSE:                        ");
      if (inverrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* REAL INVERSE:                           ");
      if (invrerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === corr testing unit ===
// Reference implementation
static void testcorrunit_refcorrr1d(RVector *signal, ae_int_t n, RVector *pattern, ae_int_t m, RVector *r) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   ae_frame_make(&_frame_block);
   SetVector(r);
   NewVector(s, 0, DT_REAL);
   ae_vector_set_length(&s, m + n - 1);
   ae_v_move(s.xR, 1, signal->xR, 1, n);
   for (i = n; i < m + n - 1; i++) {
      s.xR[i] = 0.0;
   }
   ae_vector_set_length(r, m + n - 1);
   for (i = 0; i < n; i++) {
      v = 0.0;
      for (j = 0; j < m; j++) {
         if (i + j >= n) {
            break;
         }
         v += pattern->xR[j] * s.xR[i + j];
      }
      r->xR[i] = v;
   }
   for (i = 1; i < m; i++) {
      v = 0.0;
      for (j = i; j < m; j++) {
         v += pattern->xR[j] * s.xR[-i + j];
      }
      r->xR[m + n - 1 - i] = v;
   }
   ae_frame_leave();
}

// Reference implementation
static void testcorrunit_refcorrc1d(CVector *signal, ae_int_t n, CVector *pattern, ae_int_t m, CVector *r) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   complex v;
   ae_frame_make(&_frame_block);
   SetVector(r);
   NewVector(s, 0, DT_COMPLEX);
   ae_vector_set_length(&s, m + n - 1);
   ae_v_cmove(s.xC, 1, signal->xC, 1, "N", n);
   for (i = n; i < m + n - 1; i++) {
      s.xC[i] = complex_from_i(0);
   }
   ae_vector_set_length(r, m + n - 1);
   for (i = 0; i < n; i++) {
      v = complex_from_i(0);
      for (j = 0; j < m; j++) {
         if (i + j >= n) {
            break;
         }
         v = ae_c_add(v, ae_c_mul(conj(pattern->xC[j]), s.xC[i + j]));
      }
      r->xC[i] = v;
   }
   for (i = 1; i < m; i++) {
      v = complex_from_i(0);
      for (j = i; j < m; j++) {
         v = ae_c_add(v, ae_c_mul(conj(pattern->xC[j]), s.xC[j - i]));
      }
      r->xC[m + n - 1 - i] = v;
   }
   ae_frame_leave();
}

// Reference implementation
static void testcorrunit_refcorrr1dcircular(RVector *signal, ae_int_t n, RVector *pattern, ae_int_t m, RVector *r) {
   ae_int_t i;
   ae_int_t j;
   double v;
   SetVector(r);
   ae_vector_set_length(r, n);
   for (i = 0; i < n; i++) {
      v = 0.0;
      for (j = 0; j < m; j++) {
         v += pattern->xR[j] * signal->xR[(i + j) % n];
      }
      r->xR[i] = v;
   }
}

// Reference implementation
static void testcorrunit_refcorrc1dcircular(CVector *signal, ae_int_t n, CVector *pattern, ae_int_t m, CVector *r) {
   ae_int_t i;
   ae_int_t j;
   complex v;
   SetVector(r);
   ae_vector_set_length(r, n);
   for (i = 0; i < n; i++) {
      v = complex_from_i(0);
      for (j = 0; j < m; j++) {
         v = ae_c_add(v, ae_c_mul(conj(pattern->xC[j]), signal->xC[(i + j) % n]));
      }
      r->xC[i] = v;
   }
}

// Test
bool testcorr(bool silent) {
   ae_frame _frame_block;
   ae_int_t m;
   ae_int_t n;
   ae_int_t i;
   ae_int_t maxn;
   double referr;
   double refrerr;
   double errtol;
   bool referrors;
   bool refrerrors;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(ra, 0, DT_REAL);
   NewVector(rb, 0, DT_REAL);
   NewVector(rr1, 0, DT_REAL);
   NewVector(rr2, 0, DT_REAL);
   NewVector(ca, 0, DT_COMPLEX);
   NewVector(cb, 0, DT_COMPLEX);
   NewVector(cr1, 0, DT_COMPLEX);
   NewVector(cr2, 0, DT_COMPLEX);
   maxn = 32;
   errtol = 100000 * pow((double)maxn, 3.0 / 2.0) * machineepsilon;
   referrors = false;
   refrerrors = false;
   waserrors = false;
// Test against reference O(N^2) implementation.
   referr = 0.0;
   refrerr = 0.0;
   for (m = 1; m <= maxn; m++) {
      for (n = 1; n <= maxn; n++) {
      // Complex correlation
         ae_vector_set_length(&ca, m);
         for (i = 0; i < m; i++) {
            ca.xC[i] = complex_from_d(randommid(), randommid());
         }
         ae_vector_set_length(&cb, n);
         for (i = 0; i < n; i++) {
            cb.xC[i] = complex_from_d(randommid(), randommid());
         }
         ae_vector_set_length(&cr1, 1);
         corrc1d(&ca, m, &cb, n, &cr1);
         testcorrunit_refcorrc1d(&ca, m, &cb, n, &cr2);
         for (i = 0; i < m + n - 1; i++) {
            referr = rmax2(referr, abscomplex(ae_c_sub(cr1.xC[i], cr2.xC[i])));
         }
         ae_vector_set_length(&cr1, 1);
         corrc1dcircular(&ca, m, &cb, n, &cr1);
         testcorrunit_refcorrc1dcircular(&ca, m, &cb, n, &cr2);
         for (i = 0; i < m; i++) {
            referr = rmax2(referr, abscomplex(ae_c_sub(cr1.xC[i], cr2.xC[i])));
         }
      // Real correlation
         ae_vector_set_length(&ra, m);
         for (i = 0; i < m; i++) {
            ra.xR[i] = randommid();
         }
         ae_vector_set_length(&rb, n);
         for (i = 0; i < n; i++) {
            rb.xR[i] = randommid();
         }
         ae_vector_set_length(&rr1, 1);
         corrr1d(&ra, m, &rb, n, &rr1);
         testcorrunit_refcorrr1d(&ra, m, &rb, n, &rr2);
         for (i = 0; i < m + n - 1; i++) {
            refrerr = rmax2(refrerr, fabs(rr1.xR[i] - rr2.xR[i]));
         }
         ae_vector_set_length(&rr1, 1);
         corrr1dcircular(&ra, m, &rb, n, &rr1);
         testcorrunit_refcorrr1dcircular(&ra, m, &rb, n, &rr2);
         for (i = 0; i < m; i++) {
            refrerr = rmax2(refrerr, fabs(rr1.xR[i] - rr2.xR[i]));
         }
      }
   }
   referrors = referrors || referr > errtol;
   refrerrors = refrerrors || refrerr > errtol;
// end
   waserrors = referrors || refrerrors;
   if (!silent) {
      printf("TESTING CORRELATION\n");
      printf("FINAL RESULT:                             ");
      if (waserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* AGAINST REFERENCE COMPLEX CORR:         ");
      if (referrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("* AGAINST REFERENCE REAL CORR:            ");
      if (refrerrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === chebyshev testing unit ===
bool testchebyshev(bool silent) {
   ae_frame _frame_block;
   double err;
   double sumerr;
   double cerr;
   double ferr;
   double threshold;
   double x;
   double v;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t n;
   ae_int_t maxn;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(c, 0, DT_REAL);
   NewVector(p1, 0, DT_REAL);
   NewVector(p2, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   err = 0.0;
   sumerr = 0.0;
   cerr = 0.0;
   ferr = 0.0;
   threshold = 1.0E-9;
   waserrors = false;
// Testing Chebyshev polynomials of the first kind
   err = rmax2(err, fabs(chebyshevcalculate(1, 0, 0.00) - 1));
   err = rmax2(err, fabs(chebyshevcalculate(1, 0, 0.33) - 1));
   err = rmax2(err, fabs(chebyshevcalculate(1, 0, -0.42) - 1));
   x = 0.2;
   err = rmax2(err, fabs(chebyshevcalculate(1, 1, x) - 0.2));
   x = 0.4;
   err = rmax2(err, fabs(chebyshevcalculate(1, 1, x) - 0.4));
   x = 0.6;
   err = rmax2(err, fabs(chebyshevcalculate(1, 1, x) - 0.6));
   x = 0.8;
   err = rmax2(err, fabs(chebyshevcalculate(1, 1, x) - 0.8));
   x = 1.0;
   err = rmax2(err, fabs(chebyshevcalculate(1, 1, x) - 1.0));
   x = 0.2;
   err = rmax2(err, fabs(chebyshevcalculate(1, 2, x) + 0.92));
   x = 0.4;
   err = rmax2(err, fabs(chebyshevcalculate(1, 2, x) + 0.68));
   x = 0.6;
   err = rmax2(err, fabs(chebyshevcalculate(1, 2, x) + 0.28));
   x = 0.8;
   err = rmax2(err, fabs(chebyshevcalculate(1, 2, x) - 0.28));
   x = 1.0;
   err = rmax2(err, fabs(chebyshevcalculate(1, 2, x) - 1.00));
   n = 10;
   err = rmax2(err, fabs(chebyshevcalculate(1, n, 0.2) - 0.4284556288));
   n = 11;
   err = rmax2(err, fabs(chebyshevcalculate(1, n, 0.2) + 0.7996160205));
   n = 12;
   err = rmax2(err, fabs(chebyshevcalculate(1, n, 0.2) + 0.7483020370));
// Testing Chebyshev polynomials of the second kind
   n = 0;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) - 1.0000000000));
   n = 1;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) - 0.4000000000));
   n = 2;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) + 0.8400000000));
   n = 3;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) + 0.7360000000));
   n = 4;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) - 0.5456000000));
   n = 10;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) - 0.6128946176));
   n = 11;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) + 0.6770370970));
   n = 12;
   err = rmax2(err, fabs(chebyshevcalculate(2, n, 0.2) + 0.8837094564));
// Testing Clenshaw summation
   maxn = 20;
   ae_vector_set_length(&c, maxn + 1);
   for (k = 1; k <= 2; k++) {
      for (pass = 1; pass <= 10; pass++) {
         x = randommid();
         v = 0.0;
         for (n = 0; n <= maxn; n++) {
            c.xR[n] = randommid();
            v += chebyshevcalculate(k, n, x) * c.xR[n];
            sumerr = rmax2(sumerr, fabs(v - chebyshevsum(&c, k, n, x)));
         }
      }
   }
// Testing coefficients
   chebyshevcoefficients(0, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 1));
   chebyshevcoefficients(1, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 1));
   chebyshevcoefficients(2, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] + 1));
   cerr = rmax2(cerr, fabs(c.xR[1] - 0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 2));
   chebyshevcoefficients(3, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 3));
   cerr = rmax2(cerr, fabs(c.xR[2] - 0));
   cerr = rmax2(cerr, fabs(c.xR[3] - 4));
   chebyshevcoefficients(4, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 1));
   cerr = rmax2(cerr, fabs(c.xR[1] - 0));
   cerr = rmax2(cerr, fabs(c.xR[2] + 8));
   cerr = rmax2(cerr, fabs(c.xR[3] - 0));
   cerr = rmax2(cerr, fabs(c.xR[4] - 8));
   chebyshevcoefficients(9, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 9));
   cerr = rmax2(cerr, fabs(c.xR[2] - 0));
   cerr = rmax2(cerr, fabs(c.xR[3] + 120));
   cerr = rmax2(cerr, fabs(c.xR[4] - 0));
   cerr = rmax2(cerr, fabs(c.xR[5] - 432));
   cerr = rmax2(cerr, fabs(c.xR[6] - 0));
   cerr = rmax2(cerr, fabs(c.xR[7] + 576));
   cerr = rmax2(cerr, fabs(c.xR[8] - 0));
   cerr = rmax2(cerr, fabs(c.xR[9] - 256));
// Testing FromChebyshev
   maxn = 10;
   ae_matrix_set_length(&a, maxn + 1, maxn + 1);
   for (i = 0; i <= maxn; i++) {
      for (j = 0; j <= maxn; j++) {
         a.xyR[i][j] = 0.0;
      }
      chebyshevcoefficients(i, &c);
      ae_v_move(a.xyR[i], 1, c.xR, 1, i + 1);
   }
   ae_vector_set_length(&c, maxn + 1);
   ae_vector_set_length(&p1, maxn + 1);
   for (n = 0; n <= maxn; n++) {
      for (pass = 1; pass <= 10; pass++) {
         for (i = 0; i <= n; i++) {
            p1.xR[i] = 0.0;
         }
         for (i = 0; i <= n; i++) {
            c.xR[i] = randommid();
            v = c.xR[i];
            ae_v_addd(p1.xR, 1, a.xyR[i], 1, i + 1, v);
         }
         fromchebyshev(&c, n, &p2);
         for (i = 0; i <= n; i++) {
            ferr = rmax2(ferr, fabs(p1.xR[i] - p2.xR[i]));
         }
      }
   }
// Reporting
   waserrors = ((err > threshold || sumerr > threshold) || cerr > threshold) || ferr > threshold;
   if (!silent) {
      printf("TESTING CALCULATION OF THE CHEBYSHEV POLYNOMIALS\n");
      printf("Max error against table                   %5.2e\n", err);
      printf("Summation error                           %5.2e\n", sumerr);
      printf("Coefficients error                        %5.2e\n", cerr);
      printf("FrobChebyshev error                       %5.2e\n", ferr);
      printf("Threshold                                 %5.2e\n", threshold);
      if (!waserrors) {
         printf("TEST PASSED\n");
      } else {
         printf("TEST FAILED\n");
      }
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === hermite testing unit ===
bool testhermite(bool silent) {
   ae_frame _frame_block;
   double err;
   double sumerr;
   double cerr;
   double threshold;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t pass;
   double x;
   double v;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(c, 0, DT_REAL);
   err = 0.0;
   sumerr = 0.0;
   cerr = 0.0;
   threshold = 1.0E-9;
   waserrors = false;
// Testing Hermite polynomials
   n = 0;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) - 1));
   n = 1;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) - 2));
   n = 2;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) - 2));
   n = 3;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) + 4));
   n = 4;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) + 20));
   n = 5;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) + 8));
   n = 6;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) - 184));
   n = 7;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) - 464));
   n = 11;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) - 230848));
   n = 12;
   err = rmax2(err, fabs(hermitecalculate(n, 1.0) - 280768));
// Testing Clenshaw summation
   maxn = 10;
   ae_vector_set_length(&c, maxn + 1);
   for (pass = 1; pass <= 10; pass++) {
      x = randommid();
      v = 0.0;
      for (n = 0; n <= maxn; n++) {
         c.xR[n] = randommid();
         v += hermitecalculate(n, x) * c.xR[n];
         sumerr = rmax2(sumerr, fabs(v - hermitesum(&c, n, x)));
      }
   }
// Testing coefficients
   hermitecoefficients(0, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 1));
   hermitecoefficients(1, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 2));
   hermitecoefficients(2, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] + 2));
   cerr = rmax2(cerr, fabs(c.xR[1] - 0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 4));
   hermitecoefficients(3, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 12));
   cerr = rmax2(cerr, fabs(c.xR[2] - 0));
   cerr = rmax2(cerr, fabs(c.xR[3] - 8));
   hermitecoefficients(4, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 12));
   cerr = rmax2(cerr, fabs(c.xR[1] - 0));
   cerr = rmax2(cerr, fabs(c.xR[2] + 48));
   cerr = rmax2(cerr, fabs(c.xR[3] - 0));
   cerr = rmax2(cerr, fabs(c.xR[4] - 16));
   hermitecoefficients(5, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 120));
   cerr = rmax2(cerr, fabs(c.xR[2] - 0));
   cerr = rmax2(cerr, fabs(c.xR[3] + 160));
   cerr = rmax2(cerr, fabs(c.xR[4] - 0));
   cerr = rmax2(cerr, fabs(c.xR[5] - 32));
   hermitecoefficients(6, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] + 120));
   cerr = rmax2(cerr, fabs(c.xR[1] - 0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 720));
   cerr = rmax2(cerr, fabs(c.xR[3] - 0));
   cerr = rmax2(cerr, fabs(c.xR[4] + 480));
   cerr = rmax2(cerr, fabs(c.xR[5] - 0));
   cerr = rmax2(cerr, fabs(c.xR[6] - 64));
// Reporting
   waserrors = (err > threshold || sumerr > threshold) || cerr > threshold;
   if (!silent) {
      printf("TESTING CALCULATION OF THE HERMITE POLYNOMIALS\n");
      printf("Max error                                 %5.2e\n", err);
      printf("Summation error                           %5.2e\n", sumerr);
      printf("Coefficients error                        %5.2e\n", cerr);
      printf("Threshold                                 %5.2e\n", threshold);
      if (!waserrors) {
         printf("TEST PASSED\n");
      } else {
         printf("TEST FAILED\n");
      }
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === legendre testing unit ===
bool testlegendre(bool silent) {
   ae_frame _frame_block;
   double err;
   double sumerr;
   double cerr;
   double threshold;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t i;
   ae_int_t pass;
   double x;
   double v;
   double t;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(c, 0, DT_REAL);
   err = 0.0;
   sumerr = 0.0;
   cerr = 0.0;
   threshold = 1.0E-9;
   waserrors = false;
// Testing Legendre polynomials values
   for (n = 0; n <= 10; n++) {
      legendrecoefficients(n, &c);
      for (pass = 1; pass <= 10; pass++) {
         x = randommid();
         v = legendrecalculate(n, x);
         t = 1.0;
         for (i = 0; i <= n; i++) {
            v -= c.xR[i] * t;
            t *= x;
         }
         err = rmax2(err, fabs(v));
      }
   }
// Testing Clenshaw summation
   maxn = 20;
   ae_vector_set_length(&c, maxn + 1);
   for (pass = 1; pass <= 10; pass++) {
      x = randommid();
      v = 0.0;
      for (n = 0; n <= maxn; n++) {
         c.xR[n] = randommid();
         v += legendrecalculate(n, x) * c.xR[n];
         sumerr = rmax2(sumerr, fabs(v - legendresum(&c, n, x)));
      }
   }
// Testing coefficients
   legendrecoefficients(0, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 1));
   legendrecoefficients(1, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 1));
   legendrecoefficients(2, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] + 1.0 / 2.0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 3.0 / 2.0));
   legendrecoefficients(3, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 3.0 / 2.0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 0));
   cerr = rmax2(cerr, fabs(c.xR[3] - 5.0 / 2.0));
   legendrecoefficients(4, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 3.0 / 8.0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 0));
   cerr = rmax2(cerr, fabs(c.xR[2] + 30.0 / 8.0));
   cerr = rmax2(cerr, fabs(c.xR[3] - 0));
   cerr = rmax2(cerr, fabs(c.xR[4] - 35.0 / 8.0));
   legendrecoefficients(9, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 0));
   cerr = rmax2(cerr, fabs(c.xR[1] - 315.0 / 128.0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 0));
   cerr = rmax2(cerr, fabs(c.xR[3] + 4620.0 / 128.0));
   cerr = rmax2(cerr, fabs(c.xR[4] - 0));
   cerr = rmax2(cerr, fabs(c.xR[5] - 18018.0 / 128.0));
   cerr = rmax2(cerr, fabs(c.xR[6] - 0));
   cerr = rmax2(cerr, fabs(c.xR[7] + 25740.0 / 128.0));
   cerr = rmax2(cerr, fabs(c.xR[8] - 0));
   cerr = rmax2(cerr, fabs(c.xR[9] - 12155.0 / 128.0));
// Reporting
   waserrors = (err > threshold || sumerr > threshold) || cerr > threshold;
   if (!silent) {
      printf("TESTING CALCULATION OF THE LEGENDRE POLYNOMIALS\n");
      printf("Max error                                 %5.2e\n", err);
      printf("Summation error                           %5.2e\n", sumerr);
      printf("Coefficients error                        %5.2e\n", cerr);
      printf("Threshold                                 %5.2e\n", threshold);
      if (!waserrors) {
         printf("TEST PASSED\n");
      } else {
         printf("TEST FAILED\n");
      }
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === laguerre testing unit ===
bool testlaguerre(bool silent) {
   ae_frame _frame_block;
   double err;
   double sumerr;
   double cerr;
   double threshold;
   ae_int_t n;
   ae_int_t maxn;
   ae_int_t pass;
   double x;
   double v;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(c, 0, DT_REAL);
   err = 0.0;
   sumerr = 0.0;
   cerr = 0.0;
   threshold = 1.0E-9;
   waserrors = false;
// Testing Laguerre polynomials
   n = 0;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) - 1.0000000000));
   n = 1;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) - 0.5000000000));
   n = 2;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) - 0.1250000000));
   n = 3;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.1458333333));
   n = 4;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.3307291667));
   n = 5;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.4455729167));
   n = 6;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.5041449653));
   n = 7;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.5183392237));
   n = 8;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.4983629984));
   n = 9;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.4529195204));
   n = 10;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.3893744141));
   n = 11;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.3139072988));
   n = 12;
   err = rmax2(err, fabs(laguerrecalculate(n, 0.5) + 0.2316496389));
// Testing Clenshaw summation
   maxn = 20;
   ae_vector_set_length(&c, maxn + 1);
   for (pass = 1; pass <= 10; pass++) {
      x = randommid();
      v = 0.0;
      for (n = 0; n <= maxn; n++) {
         c.xR[n] = randommid();
         v += laguerrecalculate(n, x) * c.xR[n];
         sumerr = rmax2(sumerr, fabs(v - laguerresum(&c, n, x)));
      }
   }
// Testing coefficients
   laguerrecoefficients(0, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 1));
   laguerrecoefficients(1, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 1));
   cerr = rmax2(cerr, fabs(c.xR[1] + 1));
   laguerrecoefficients(2, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 2.0 / 2.0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 4.0 / 2.0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 1.0 / 2.0));
   laguerrecoefficients(3, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 6.0 / 6.0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 18.0 / 6.0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 9.0 / 6.0));
   cerr = rmax2(cerr, fabs(c.xR[3] + 1.0 / 6.0));
   laguerrecoefficients(4, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 24.0 / 24.0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 96.0 / 24.0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 72.0 / 24.0));
   cerr = rmax2(cerr, fabs(c.xR[3] + 16.0 / 24.0));
   cerr = rmax2(cerr, fabs(c.xR[4] - 1.0 / 24.0));
   laguerrecoefficients(5, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 120.0 / 120.0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 600.0 / 120.0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 600.0 / 120.0));
   cerr = rmax2(cerr, fabs(c.xR[3] + 200.0 / 120.0));
   cerr = rmax2(cerr, fabs(c.xR[4] - 25.0 / 120.0));
   cerr = rmax2(cerr, fabs(c.xR[5] + 1.0 / 120.0));
   laguerrecoefficients(6, &c);
   cerr = rmax2(cerr, fabs(c.xR[0] - 720.0 / 720.0));
   cerr = rmax2(cerr, fabs(c.xR[1] + 4320.0 / 720.0));
   cerr = rmax2(cerr, fabs(c.xR[2] - 5400.0 / 720.0));
   cerr = rmax2(cerr, fabs(c.xR[3] + 2400.0 / 720.0));
   cerr = rmax2(cerr, fabs(c.xR[4] - 450.0 / 720.0));
   cerr = rmax2(cerr, fabs(c.xR[5] + 36.0 / 720.0));
   cerr = rmax2(cerr, fabs(c.xR[6] - 1.0 / 720.0));
// Reporting
   waserrors = (err > threshold || sumerr > threshold) || cerr > threshold;
   if (!silent) {
      printf("TESTING CALCULATION OF THE LAGUERRE POLYNOMIALS\n");
      printf("Max error                                 %5.2e\n", err);
      printf("Summation error                           %5.2e\n", sumerr);
      printf("Coefficients error                        %5.2e\n", cerr);
      printf("Threshold                                 %5.2e\n", threshold);
      if (!waserrors) {
         printf("TEST PASSED\n");
      } else {
         printf("TEST FAILED\n");
      }
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === pca testing unit ===
// Moments estimates and their errors
static void testpcaunit_calculatemv(RVector *x, ae_int_t n, double *mean, double *means, double *stddev, double *stddevs) {
   ae_int_t i;
   double v1;
   double v2;
   double variance;
   *mean = 0;
   *means = 0;
   *stddev = 0;
   *stddevs = 0;
   *mean = 0.0;
   *means = 1.0;
   *stddev = 0.0;
   *stddevs = 1.0;
   variance = 0.0;
   if (n <= 1) {
      return;
   }
// Mean
   for (i = 0; i < n; i++) {
      *mean += x->xR[i];
   }
   *mean /= n;
// Variance (using corrected two-pass algorithm)
   if (n != 1) {
      v1 = 0.0;
      for (i = 0; i < n; i++) {
         v1 += sqr(x->xR[i] - (*mean));
      }
      v2 = 0.0;
      for (i = 0; i < n; i++) {
         v2 += (x->xR[i] - (*mean));
      }
      v2 = sqr(v2) / n;
      variance = (v1 - v2) / n;
      if (variance < 0.0) {
         variance = 0.0;
      }
      *stddev = sqrt(variance);
   }
// Errors
   *means = *stddev / sqrt((double)n);
   *stddevs = *stddev * sqrt(2.0) / sqrt((double)(n - 1));
}

bool testpca(bool silent) {
   ae_frame _frame_block;
   ae_int_t maxn;
   ae_int_t maxm;
   double threshold;
   ae_int_t m;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t info;
   double t;
   double h;
   double tmean;
   double tmeans;
   double tstddev;
   double tstddevs;
   double tmean2;
   double tmeans2;
   double tstddev2;
   double tstddevs2;
   ae_int_t requested;
   double tolreduced;
   double varcomplete;
   double varreduced;
   ae_int_t pass;
   bool pcaconverrors;
   bool pcaorterrors;
   bool pcavarerrors;
   bool pcaopterrors;
   bool pcadensesubspaceerrors;
   bool pcasparsesubspaceerrors;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(means, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(s2, 0, DT_REAL);
   NewVector(t2, 0, DT_REAL);
   NewVector(t3, 0, DT_REAL);
   NewMatrix(v, 0, 0, DT_REAL);
   NewMatrix(v2, 0, 0, DT_REAL);
   NewMatrix(x, 0, 0, DT_REAL);
   NewObj(sparsematrix, xsparse);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Primary settings
   maxm = 10;
   maxn = 100;
   threshold = 1.0E5 * machineepsilon;
   waserrors = false;
   pcaconverrors = false;
   pcaorterrors = false;
   pcavarerrors = false;
   pcaopterrors = false;
   pcadensesubspaceerrors = false;
   pcasparsesubspaceerrors = false;
// Test 1: N random points in M-dimensional space, full PCA.
   for (m = 1; m <= maxm; m++) {
      for (n = 1; n <= maxn; n++) {
      // Generate task
         ae_matrix_set_length(&x, n - 1 + 1, m - 1 + 1);
         ae_vector_set_length(&means, m - 1 + 1);
         for (j = 0; j < m; j++) {
            means.xR[j] = 0.75 * randommid();
         }
         for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
               x.xyR[i][j] = means.xR[j] + randommid();
            }
         }
      // Solve
         pcabuildbasis(&x, n, m, &info, &s, &v);
         if (info != 1) {
            pcaconverrors = true;
            continue;
         }
      // Orthogonality test
         for (i = 0; i < m; i++) {
            for (j = 0; j < m; j++) {
               t = ae_v_dotproduct(&v.xyR[0][i], v.stride, &v.xyR[0][j], v.stride, m);
               if (i == j) {
                  t--;
               }
               pcaorterrors = pcaorterrors || fabs(t) > threshold;
            }
         }
      // Variance test
         ae_vector_set_length(&t2, n - 1 + 1);
         for (k = 0; k < m; k++) {
            for (i = 0; i < n; i++) {
               t = ae_v_dotproduct(x.xyR[i], 1, &v.xyR[0][k], v.stride, m);
               t2.xR[i] = t;
            }
            testpcaunit_calculatemv(&t2, n, &tmean, &tmeans, &tstddev, &tstddevs);
            if (n != 1) {
               t = sqr(tstddev) * n / (n - 1);
            } else {
               t = 0.0;
            }
            pcavarerrors = pcavarerrors || fabs(t - s.xR[k]) > threshold;
         }
         for (k = 0; k < m - 1; k++) {
            pcavarerrors = pcavarerrors || s.xR[k] < s.xR[k + 1];
         }
      // Optimality: different perturbations in V[..,0] can't
      // increase variance of projection - can only decrease.
         ae_vector_set_length(&t2, n - 1 + 1);
         ae_vector_set_length(&t3, n - 1 + 1);
         for (i = 0; i < n; i++) {
            t = ae_v_dotproduct(x.xyR[i], 1, v.xyR[0], v.stride, m);
            t2.xR[i] = t;
         }
         testpcaunit_calculatemv(&t2, n, &tmean, &tmeans, &tstddev, &tstddevs);
         for (k = 0; k < 2 * m; k++) {
            h = 0.001;
            if (k % 2 != 0) {
               h = -h;
            }
            ae_v_move(t3.xR, 1, t2.xR, 1, n);
            ae_v_addd(t3.xR, 1, &x.xyR[0][k / 2], x.stride, n, h);
            t = 0.0;
            for (j = 0; j < m; j++) {
               if (j != k / 2) {
                  t += sqr(v.xyR[j][0]);
               } else {
                  t += sqr(v.xyR[j][0] + h);
               }
            }
            t = 1 / sqrt(t);
            ae_v_muld(t3.xR, 1, n, t);
            testpcaunit_calculatemv(&t3, n, &tmean2, &tmeans2, &tstddev2, &tstddevs2);
            pcaopterrors = pcaopterrors || tstddev2 > tstddev + threshold;
         }
      }
   }
// Special test for N=0
   for (m = 1; m <= maxm; m++) {
   // Solve
      pcabuildbasis(&x, 0, m, &info, &s, &v);
      if (info != 1) {
         pcaconverrors = true;
         continue;
      }
   // Orthogonality test
      for (i = 0; i < m; i++) {
         for (j = 0; j < m; j++) {
            t = ae_v_dotproduct(&v.xyR[0][i], v.stride, &v.xyR[0][j], v.stride, m);
            if (i == j) {
               t--;
            }
            pcaorterrors = pcaorterrors || fabs(t) > threshold;
         }
      }
   }
// Test dense reduced subspace PCA on randomly generated matrix. Because
// matrix is random, it may have bad spectral properties, so large
// number of iterations is performed.
//
// Following properties are tested:
// * principal vectors are orthogonal
// * variance values are computed correctly
// * variance values are decreasing
// * variance by inexact reduced PCA deviates from variance explained
//   by top REQUESTED vectors of complete PCA by at most TolReduced.
   tolreduced = 1.0E-3;
   for (m = 1; m <= maxm; m++) {
      for (n = 1; n <= maxn; n++) {
      // Generate task
         requested = 1 + hqrnduniformi(&rs, m);
         ae_vector_set_length(&means, m);
         for (j = 0; j < m; j++) {
            means.xR[j] = 100 * hqrndnormal(&rs);
         }
         ae_matrix_set_length(&x, n, m);
         for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
               x.xyR[i][j] = hqrndnormal(&rs) + means.xR[j];
            }
         }
      // Solve
         pcatruncatedsubspace(&x, n, m, requested, 1.0E-9, 0, &s, &v);
      // Orthogonality test
         for (i = 0; i < requested; i++) {
            for (j = 0; j < requested; j++) {
               t = ae_v_dotproduct(&v.xyR[0][i], v.stride, &v.xyR[0][j], v.stride, m);
               if (i == j) {
                  t--;
               }
               set_error_flag(&pcadensesubspaceerrors, fabs(t) > threshold, __FILE__, __LINE__, "testpcaunit.ap:217");
            }
         }
      // Variance test
         ae_vector_set_length(&t2, n);
         for (k = 0; k < requested; k++) {
            for (i = 0; i < n; i++) {
               t = ae_v_dotproduct(x.xyR[i], 1, &v.xyR[0][k], v.stride, m);
               t2.xR[i] = t;
            }
            testpcaunit_calculatemv(&t2, n, &tmean, &tmeans, &tstddev, &tstddevs);
            if (n != 1) {
               t = sqr(tstddev) * n / (n - 1);
            } else {
               t = 0.0;
            }
            set_error_flag(&pcadensesubspaceerrors, fabs(t - s.xR[k]) > threshold, __FILE__, __LINE__, "testpcaunit.ap:236");
         }
         for (k = 0; k < requested - 1; k++) {
            set_error_flag(&pcadensesubspaceerrors, fabs(s.xR[k]) < fabs(s.xR[k + 1]), __FILE__, __LINE__, "testpcaunit.ap:239");
         }
         for (k = 0; k < requested; k++) {
            set_error_flag(&pcadensesubspaceerrors, s.xR[k] <= 0.0 && fabs(s.xR[k]) > 1000 * machineepsilon * fabs(s.xR[0]), __FILE__, __LINE__, "testpcaunit.ap:241");
         }
      // Compare variance explained by top REQUESTED vectors from
      // full PCA and variance explained by reduced PCA.
         pcabuildbasis(&x, n, m, &info, &s2, &v2);
         ae_assert(info > 0, "PCA error: solver nonconvergence");
         varcomplete = 0.0;
         varreduced = 0.0;
         for (k = 0; k < requested; k++) {
            varreduced += s.xR[k];
            varcomplete += s2.xR[k];
         }
         set_error_flag(&pcadensesubspaceerrors, (varreduced - varcomplete) / varcomplete < -tolreduced, __FILE__, __LINE__, "testpcaunit.ap:256");
         set_error_flag(&pcadensesubspaceerrors, (varreduced - varcomplete) / varcomplete > 1.0E5 * machineepsilon, __FILE__, __LINE__, "testpcaunit.ap:257");
      }
   }
// Test dense subspace reduced PCA on specially designed problem with good
// spectral properties. Only limited number of iterations is performed,
// and we expect fast convergence.
   for (pass = 0; pass <= 3; pass++) {
   // Generate task
      m = -1;
      requested = -1;
      if (pass == 0) {
         m = 50 + hqrnduniformi(&rs, 50);
         requested = 1 + hqrnduniformi(&rs, 10);
      }
      if (pass == 1) {
         m = 100 + hqrnduniformi(&rs, 50);
         requested = 1 + hqrnduniformi(&rs, 10);
      }
      if (pass == 2) {
         m = 100 + hqrnduniformi(&rs, 50);
         requested = 25 + hqrnduniformi(&rs, 10);
      }
      if (pass == 3) {
         m = 200 + hqrnduniformi(&rs, 200);
         requested = 1 + hqrnduniformi(&rs, 10);
      }
      ae_assert(m > 0 && requested > 0, "PCA test: integrity failure");
      n = 2 * m;
      tolreduced = 1.0E-3;
      ae_matrix_set_length(&x, n, m);
      for (i = 0; i < n; i++) {
         for (j = 0; j < m; j++) {
            x.xyR[i][j] = 0.0;
         }
      }
      x.xyR[0][0] = 1.0;
      for (i = 1; i < m; i++) {
         x.xyR[i][i] = x.xyR[i - 1][i - 1] * (1 / 1.05);
      }
      rmatrixrndorthogonalfromtheleft(&x, n, m);
      rmatrixrndorthogonalfromtheright(&x, n, m);
   // Solve
      if (hqrnduniformr(&rs) > 0.5) {
         pcatruncatedsubspace(&x, n, m, requested, 0.0, 20, &s, &v);
      } else {
         pcatruncatedsubspace(&x, n, m, requested, 0.0, 0, &s, &v);
      }
   // Orthogonality test
      for (i = 0; i < requested; i++) {
         for (j = 0; j < requested; j++) {
            t = ae_v_dotproduct(&v.xyR[0][i], v.stride, &v.xyR[0][j], v.stride, m);
            if (i == j) {
               t--;
            }
            set_error_flag(&pcadensesubspaceerrors, fabs(t) > threshold, __FILE__, __LINE__, "testpcaunit.ap:323");
         }
      }
   // Variance test
      ae_vector_set_length(&t2, n);
      for (k = 0; k < requested; k++) {
         for (i = 0; i < n; i++) {
            t = ae_v_dotproduct(x.xyR[i], 1, &v.xyR[0][k], v.stride, m);
            t2.xR[i] = t;
         }
         testpcaunit_calculatemv(&t2, n, &tmean, &tmeans, &tstddev, &tstddevs);
         if (n != 1) {
            t = sqr(tstddev) * n / (n - 1);
         } else {
            t = 0.0;
         }
         set_error_flag(&pcadensesubspaceerrors, fabs(t - s.xR[k]) > threshold, __FILE__, __LINE__, "testpcaunit.ap:342");
      }
      for (k = 0; k < requested - 1; k++) {
         set_error_flag(&pcadensesubspaceerrors, s.xR[k] < s.xR[k + 1], __FILE__, __LINE__, "testpcaunit.ap:345");
      }
   // Compare variance explained by top REQUESTED vectors from
   // full PCA and variance explained by reduced PCA.
      pcabuildbasis(&x, n, m, &info, &s2, &v2);
      ae_assert(info > 0, "PCA error: solver nonconvergence");
      varcomplete = 0.0;
      varreduced = 0.0;
      for (k = 0; k < requested; k++) {
         varreduced += s.xR[k];
         varcomplete += s2.xR[k];
      }
      set_error_flag(&pcadensesubspaceerrors, (varreduced - varcomplete) / varcomplete < -tolreduced, __FILE__, __LINE__, "testpcaunit.ap:360");
      set_error_flag(&pcadensesubspaceerrors, (varreduced - varcomplete) / varcomplete > 1.0E5 * machineepsilon, __FILE__, __LINE__, "testpcaunit.ap:361");
   }
// Test sparse reduced subspace PCA on randomly generated matrix with
// two non-zero elements at each row. Because matrix is random, it may
// have bad spectral properties, so large number of iterations is performed.
//
// Following properties are tested:
// * principal vectors are orthogonal
// * variance values are computed correctly
// * variance values are decreasing
// * variance by inexact reduced PCA deviates from variance explained
//   by top REQUESTED vectors of complete PCA by at most TolReduced.
   tolreduced = 1.0E-3;
   for (m = 1; m <= maxm; m++) {
      for (n = 1; n <= maxn; n++) {
      // Generate task
         requested = 1 + hqrnduniformi(&rs, m);
         ae_vector_set_length(&means, m);
         for (j = 0; j < m; j++) {
            means.xR[j] = 100 * hqrndnormal(&rs);
         }
         sparsecreate(n, m, 0, &xsparse);
         for (i = 0; i < n; i++) {
            j = hqrnduniformi(&rs, m);
            sparseset(&xsparse, i, j, hqrndnormal(&rs) + means.xR[j]);
            j = hqrnduniformi(&rs, m);
            sparseset(&xsparse, i, j, hqrndnormal(&rs) + means.xR[j]);
         }
         if (hqrndnormal(&rs) > 0.0) {
            sparseconverttocrs(&xsparse);
         }
         ae_matrix_set_length(&x, n, m);
         for (i = 0; i < n; i++) {
            for (j = 0; j < m; j++) {
               x.xyR[i][j] = sparseget(&xsparse, i, j);
            }
         }
      // Solve
         pcatruncatedsubspacesparse(&xsparse, n, m, requested, 1.0E-9, 0, &s, &v);
      // Orthogonality test
         for (i = 0; i < requested; i++) {
            for (j = 0; j < requested; j++) {
               t = ae_v_dotproduct(&v.xyR[0][i], v.stride, &v.xyR[0][j], v.stride, m);
               if (i == j) {
                  t--;
               }
               set_error_flag(&pcasparsesubspaceerrors, fabs(t) > threshold, __FILE__, __LINE__, "testpcaunit.ap:417");
            }
         }
      // Variance test
         ae_vector_set_length(&t2, n);
         for (k = 0; k < requested; k++) {
            for (i = 0; i < n; i++) {
               t = ae_v_dotproduct(x.xyR[i], 1, &v.xyR[0][k], v.stride, m);
               t2.xR[i] = t;
            }
            testpcaunit_calculatemv(&t2, n, &tmean, &tmeans, &tstddev, &tstddevs);
            if (n != 1) {
               t = sqr(tstddev) * n / (n - 1);
            } else {
               t = 0.0;
            }
            set_error_flag(&pcasparsesubspaceerrors, fabs(t - s.xR[k]) > threshold * rmaxabs3(t, s.xR[k], 1.0), __FILE__, __LINE__, "testpcaunit.ap:436");
         }
         for (k = 0; k < requested - 1; k++) {
            set_error_flag(&pcasparsesubspaceerrors, fabs(s.xR[k]) < fabs(s.xR[k + 1]), __FILE__, __LINE__, "testpcaunit.ap:439");
         }
         for (k = 0; k < requested; k++) {
            set_error_flag(&pcasparsesubspaceerrors, s.xR[k] <= 0.0 && fabs(s.xR[k]) > 1000 * machineepsilon * rmax2(fabs(s.xR[0]), 1.0), __FILE__, __LINE__, "testpcaunit.ap:441");
         }
      // Compare variance explained by top REQUESTED vectors from
      // full PCA and variance explained by reduced PCA.
         pcabuildbasis(&x, n, m, &info, &s2, &v2);
         ae_assert(info > 0, "PCA error: solver nonconvergence");
         varcomplete = 0.0;
         varreduced = 0.0;
         for (k = 0; k < requested; k++) {
            varreduced += s.xR[k];
            varcomplete += s2.xR[k];
         }
         set_error_flag(&pcasparsesubspaceerrors, (varreduced - varcomplete) / rmax2(varcomplete, 1.0) < -tolreduced, __FILE__, __LINE__, "testpcaunit.ap:456");
         set_error_flag(&pcasparsesubspaceerrors, (varreduced - varcomplete) / rmax2(varcomplete, 1.0) > 1.0E5 * machineepsilon, __FILE__, __LINE__, "testpcaunit.ap:457");
      }
   }
// Final report
   waserrors = ((((pcaconverrors || pcaorterrors) || pcavarerrors) || pcaopterrors) || pcadensesubspaceerrors) || pcasparsesubspaceerrors;
   if (!silent) {
      printf("PCA TEST\n");
      printf("COMPLETE PCA:\n");
      printf("* CONVERGENCE                            ");
      if (!pcaconverrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* ORTOGONALITY                           ");
      if (!pcaorterrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* VARIANCE REPORT                        ");
      if (!pcavarerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* OPTIMALITY                             ");
      if (!pcaopterrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("SUBSPACE PCA:\n");
      printf("* DENSE SUBSPACE PCA                     ");
      if (!pcadensesubspaceerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* SPARSE SUBSPACE PCA                    ");
      if (!pcasparsesubspaceerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST SUMMARY: FAILED\n");
      } else {
         printf("TEST SUMMARY: PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === bdss testing unit ===
// Unsets 1D array.
static void testbdssunit_unset1di(ZVector *a) {
   ae_vector_set_length(a, 0 + 1);
   a->xZ[0] = randominteger(3) - 1;
}

// Testing BDSS operations
bool testbdss(bool silent) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t maxn;
   ae_int_t maxnq;
   ae_int_t ni;
   ae_int_t tiecount;
   ae_int_t c1;
   ae_int_t c0;
   ae_int_t nc;
   double pal;
   double pbl;
   double par;
   double pbr;
   double cve;
   double cvr;
   ae_int_t info;
   double threshold;
   double rms;
   double cvrms;
   bool waserrors;
   bool tieserrors;
   bool split2errors;
   bool optimalsplitkerrors;
   bool splitkerrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(a, 0, DT_REAL);
   NewVector(a0, 0, DT_REAL);
   NewVector(at, 0, DT_REAL);
   NewMatrix(p, 0, 0, DT_REAL);
   NewVector(thresholds, 0, DT_REAL);
   NewVector(c, 0, DT_INT);
   NewVector(p1, 0, DT_INT);
   NewVector(p2, 0, DT_INT);
   NewVector(ties, 0, DT_INT);
   NewVector(pt1, 0, DT_INT);
   NewVector(pt2, 0, DT_INT);
   NewVector(tmp, 0, DT_REAL);
   NewVector(sortrbuf, 0, DT_REAL);
   NewVector(sortrbuf2, 0, DT_REAL);
   NewVector(sortibuf, 0, DT_INT);
   NewVector(tiebuf, 0, DT_INT);
   NewVector(cntbuf, 0, DT_INT);
   waserrors = false;
   tieserrors = false;
   split2errors = false;
   splitkerrors = false;
   optimalsplitkerrors = false;
   maxn = 100;
   maxnq = 49;
   passcount = 10;
// Test ties
   for (n = 1; n <= maxn; n++) {
      for (pass = 1; pass <= passcount; pass++) {
      // untied data, test DSTie
         testbdssunit_unset1di(&p1);
         testbdssunit_unset1di(&p2);
         testbdssunit_unset1di(&pt1);
         testbdssunit_unset1di(&pt2);
         ae_vector_set_length(&a, n - 1 + 1);
         ae_vector_set_length(&a0, n - 1 + 1);
         ae_vector_set_length(&at, n - 1 + 1);
         ae_vector_set_length(&tmp, n - 1 + 1);
         a.xR[0] = randommid();
         tmp.xR[0] = randomreal();
         for (i = 1; i < n; i++) {
         // A is randomly permuted
            a.xR[i] = a.xR[i - 1] + 0.1 * randomreal() + 0.1;
            tmp.xR[i] = randomreal();
         }
         tagsortfastr(&tmp, &a, &sortrbuf, &sortrbuf2, n);
         for (i = 0; i < n; i++) {
            a0.xR[i] = a.xR[i];
            at.xR[i] = a.xR[i];
         }
         dstie(&a0, n, &ties, &tiecount, &p1, &p2);
         tagsort(&at, n, &pt1, &pt2);
         for (i = 0; i < n; i++) {
            tieserrors = tieserrors || p1.xZ[i] != pt1.xZ[i];
            tieserrors = tieserrors || p2.xZ[i] != pt2.xZ[i];
         }
         tieserrors = tieserrors || tiecount != n;
         if (tiecount == n) {
            for (i = 0; i <= n; i++) {
               tieserrors = tieserrors || ties.xZ[i] != i;
            }
         }
      // tied data, test DSTie
         testbdssunit_unset1di(&p1);
         testbdssunit_unset1di(&p2);
         testbdssunit_unset1di(&pt1);
         testbdssunit_unset1di(&pt2);
         ae_vector_set_length(&a, n - 1 + 1);
         ae_vector_set_length(&a0, n - 1 + 1);
         ae_vector_set_length(&at, n - 1 + 1);
         c1 = 0;
         c0 = 0;
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)randominteger(2);
            if (a.xR[i] == 0.0) {
               c0++;
            } else {
               c1++;
            }
            a0.xR[i] = a.xR[i];
            at.xR[i] = a.xR[i];
         }
         dstie(&a0, n, &ties, &tiecount, &p1, &p2);
         tagsort(&at, n, &pt1, &pt2);
         for (i = 0; i < n; i++) {
            tieserrors = tieserrors || p1.xZ[i] != pt1.xZ[i];
            tieserrors = tieserrors || p2.xZ[i] != pt2.xZ[i];
         }
         if (c0 == 0 || c1 == 0) {
            tieserrors = tieserrors || tiecount != 1;
            if (tiecount == 1) {
               tieserrors = tieserrors || ties.xZ[0] != 0;
               tieserrors = tieserrors || ties.xZ[1] != n;
            }
         } else {
            tieserrors = tieserrors || tiecount != 2;
            if (tiecount == 2) {
               tieserrors = tieserrors || ties.xZ[0] != 0;
               tieserrors = tieserrors || ties.xZ[1] != c0;
               tieserrors = tieserrors || ties.xZ[2] != n;
            }
         }
      }
   }
// split-2
// General tests for different N's
   for (n = 1; n <= maxn; n++) {
      ae_vector_set_length(&a, n - 1 + 1);
      ae_vector_set_length(&c, n - 1 + 1);
   // one-tie test
      if (n % 2 == 0) {
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)n;
            c.xZ[i] = i % 2;
         }
         dsoptimalsplit2(&a, &c, n, &info, &threshold, &pal, &pbl, &par, &pbr, &cve);
         if (info != -3) {
            split2errors = true;
            continue;
         }
      }
   // two-tie test
   // test #1
      if (n > 1) {
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)(i / ((n + 1) / 2));
            c.xZ[i] = i / ((n + 1) / 2);
         }
         dsoptimalsplit2(&a, &c, n, &info, &threshold, &pal, &pbl, &par, &pbr, &cve);
         if (info != 1) {
            split2errors = true;
            continue;
         }
         split2errors = split2errors || fabs(threshold - 0.5) > 100 * machineepsilon;
         split2errors = split2errors || fabs(pal - 1) > 100 * machineepsilon;
         split2errors = split2errors || fabs(pbl - 0) > 100 * machineepsilon;
         split2errors = split2errors || fabs(par - 0) > 100 * machineepsilon;
         split2errors = split2errors || fabs(pbr - 1) > 100 * machineepsilon;
      }
   }
// Special "CREDIT"-test (transparency coefficient)
   n = 110;
   ae_vector_set_length(&a, n - 1 + 1);
   ae_vector_set_length(&c, n - 1 + 1);
   a.xR[0] = 0.000;
   c.xZ[0] = 0;
   a.xR[1] = 0.000;
   c.xZ[1] = 0;
   a.xR[2] = 0.000;
   c.xZ[2] = 0;
   a.xR[3] = 0.000;
   c.xZ[3] = 0;
   a.xR[4] = 0.000;
   c.xZ[4] = 0;
   a.xR[5] = 0.000;
   c.xZ[5] = 0;
   a.xR[6] = 0.000;
   c.xZ[6] = 0;
   a.xR[7] = 0.000;
   c.xZ[7] = 1;
   a.xR[8] = 0.000;
   c.xZ[8] = 0;
   a.xR[9] = 0.000;
   c.xZ[9] = 1;
   a.xR[10] = 0.000;
   c.xZ[10] = 0;
   a.xR[11] = 0.000;
   c.xZ[11] = 0;
   a.xR[12] = 0.000;
   c.xZ[12] = 0;
   a.xR[13] = 0.000;
   c.xZ[13] = 0;
   a.xR[14] = 0.000;
   c.xZ[14] = 0;
   a.xR[15] = 0.000;
   c.xZ[15] = 0;
   a.xR[16] = 0.000;
   c.xZ[16] = 0;
   a.xR[17] = 0.000;
   c.xZ[17] = 0;
   a.xR[18] = 0.000;
   c.xZ[18] = 0;
   a.xR[19] = 0.000;
   c.xZ[19] = 0;
   a.xR[20] = 0.000;
   c.xZ[20] = 0;
   a.xR[21] = 0.000;
   c.xZ[21] = 0;
   a.xR[22] = 0.000;
   c.xZ[22] = 1;
   a.xR[23] = 0.000;
   c.xZ[23] = 0;
   a.xR[24] = 0.000;
   c.xZ[24] = 0;
   a.xR[25] = 0.000;
   c.xZ[25] = 0;
   a.xR[26] = 0.000;
   c.xZ[26] = 0;
   a.xR[27] = 0.000;
   c.xZ[27] = 1;
   a.xR[28] = 0.000;
   c.xZ[28] = 0;
   a.xR[29] = 0.000;
   c.xZ[29] = 1;
   a.xR[30] = 0.000;
   c.xZ[30] = 0;
   a.xR[31] = 0.000;
   c.xZ[31] = 1;
   a.xR[32] = 0.000;
   c.xZ[32] = 0;
   a.xR[33] = 0.000;
   c.xZ[33] = 1;
   a.xR[34] = 0.000;
   c.xZ[34] = 0;
   a.xR[35] = 0.030;
   c.xZ[35] = 0;
   a.xR[36] = 0.030;
   c.xZ[36] = 0;
   a.xR[37] = 0.050;
   c.xZ[37] = 0;
   a.xR[38] = 0.070;
   c.xZ[38] = 1;
   a.xR[39] = 0.110;
   c.xZ[39] = 0;
   a.xR[40] = 0.110;
   c.xZ[40] = 1;
   a.xR[41] = 0.120;
   c.xZ[41] = 0;
   a.xR[42] = 0.130;
   c.xZ[42] = 0;
   a.xR[43] = 0.140;
   c.xZ[43] = 0;
   a.xR[44] = 0.140;
   c.xZ[44] = 0;
   a.xR[45] = 0.140;
   c.xZ[45] = 0;
   a.xR[46] = 0.150;
   c.xZ[46] = 0;
   a.xR[47] = 0.150;
   c.xZ[47] = 0;
   a.xR[48] = 0.170;
   c.xZ[48] = 0;
   a.xR[49] = 0.190;
   c.xZ[49] = 1;
   a.xR[50] = 0.200;
   c.xZ[50] = 0;
   a.xR[51] = 0.200;
   c.xZ[51] = 0;
   a.xR[52] = 0.250;
   c.xZ[52] = 0;
   a.xR[53] = 0.250;
   c.xZ[53] = 0;
   a.xR[54] = 0.260;
   c.xZ[54] = 0;
   a.xR[55] = 0.270;
   c.xZ[55] = 0;
   a.xR[56] = 0.280;
   c.xZ[56] = 0;
   a.xR[57] = 0.310;
   c.xZ[57] = 0;
   a.xR[58] = 0.310;
   c.xZ[58] = 0;
   a.xR[59] = 0.330;
   c.xZ[59] = 0;
   a.xR[60] = 0.330;
   c.xZ[60] = 0;
   a.xR[61] = 0.340;
   c.xZ[61] = 0;
   a.xR[62] = 0.340;
   c.xZ[62] = 0;
   a.xR[63] = 0.370;
   c.xZ[63] = 0;
   a.xR[64] = 0.380;
   c.xZ[64] = 1;
   a.xR[65] = 0.380;
   c.xZ[65] = 0;
   a.xR[66] = 0.410;
   c.xZ[66] = 0;
   a.xR[67] = 0.460;
   c.xZ[67] = 0;
   a.xR[68] = 0.520;
   c.xZ[68] = 0;
   a.xR[69] = 0.530;
   c.xZ[69] = 0;
   a.xR[70] = 0.540;
   c.xZ[70] = 0;
   a.xR[71] = 0.560;
   c.xZ[71] = 0;
   a.xR[72] = 0.560;
   c.xZ[72] = 0;
   a.xR[73] = 0.570;
   c.xZ[73] = 0;
   a.xR[74] = 0.600;
   c.xZ[74] = 0;
   a.xR[75] = 0.600;
   c.xZ[75] = 0;
   a.xR[76] = 0.620;
   c.xZ[76] = 0;
   a.xR[77] = 0.650;
   c.xZ[77] = 0;
   a.xR[78] = 0.660;
   c.xZ[78] = 0;
   a.xR[79] = 0.680;
   c.xZ[79] = 0;
   a.xR[80] = 0.700;
   c.xZ[80] = 0;
   a.xR[81] = 0.750;
   c.xZ[81] = 0;
   a.xR[82] = 0.770;
   c.xZ[82] = 0;
   a.xR[83] = 0.770;
   c.xZ[83] = 0;
   a.xR[84] = 0.770;
   c.xZ[84] = 0;
   a.xR[85] = 0.790;
   c.xZ[85] = 0;
   a.xR[86] = 0.810;
   c.xZ[86] = 0;
   a.xR[87] = 0.840;
   c.xZ[87] = 0;
   a.xR[88] = 0.860;
   c.xZ[88] = 0;
   a.xR[89] = 0.870;
   c.xZ[89] = 0;
   a.xR[90] = 0.890;
   c.xZ[90] = 0;
   a.xR[91] = 0.900;
   c.xZ[91] = 1;
   a.xR[92] = 0.900;
   c.xZ[92] = 0;
   a.xR[93] = 0.910;
   c.xZ[93] = 0;
   a.xR[94] = 0.940;
   c.xZ[94] = 0;
   a.xR[95] = 0.950;
   c.xZ[95] = 0;
   a.xR[96] = 0.952;
   c.xZ[96] = 0;
   a.xR[97] = 0.970;
   c.xZ[97] = 0;
   a.xR[98] = 0.970;
   c.xZ[98] = 0;
   a.xR[99] = 0.980;
   c.xZ[99] = 0;
   a.xR[100] = 1.000;
   c.xZ[100] = 0;
   a.xR[101] = 1.000;
   c.xZ[101] = 0;
   a.xR[102] = 1.000;
   c.xZ[102] = 0;
   a.xR[103] = 1.000;
   c.xZ[103] = 0;
   a.xR[104] = 1.000;
   c.xZ[104] = 0;
   a.xR[105] = 1.020;
   c.xZ[105] = 0;
   a.xR[106] = 1.090;
   c.xZ[106] = 0;
   a.xR[107] = 1.130;
   c.xZ[107] = 0;
   a.xR[108] = 1.840;
   c.xZ[108] = 0;
   a.xR[109] = 2.470;
   c.xZ[109] = 0;
   dsoptimalsplit2(&a, &c, n, &info, &threshold, &pal, &pbl, &par, &pbr, &cve);
   if (info != 1) {
      split2errors = true;
   } else {
      split2errors = split2errors || fabs(threshold - 0.195) > 100 * machineepsilon;
      split2errors = split2errors || fabs(pal - 0.80) > 0.02;
      split2errors = split2errors || fabs(pbl - 0.20) > 0.02;
      split2errors = split2errors || fabs(par - 0.97) > 0.02;
      split2errors = split2errors || fabs(pbr - 0.03) > 0.02;
   }
// split-2 fast
// General tests for different N's
   for (n = 1; n <= maxn; n++) {
      ae_vector_set_length(&a, n - 1 + 1);
      ae_vector_set_length(&c, n - 1 + 1);
      ae_vector_set_length(&tiebuf, n + 1);
      ae_vector_set_length(&cntbuf, 3 + 1);
   // one-tie test
      if (n % 2 == 0) {
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)n;
            c.xZ[i] = i % 2;
         }
         dsoptimalsplit2fast(&a, &c, &tiebuf, &cntbuf, &sortrbuf, &sortibuf, n, 2, 0.00, &info, &threshold, &rms, &cvrms);
         if (info != -3) {
            split2errors = true;
            continue;
         }
      }
   // two-tie test
   // test #1
      if (n > 1) {
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)(i / ((n + 1) / 2));
            c.xZ[i] = i / ((n + 1) / 2);
         }
         dsoptimalsplit2fast(&a, &c, &tiebuf, &cntbuf, &sortrbuf, &sortibuf, n, 2, 0.00, &info, &threshold, &rms, &cvrms);
         if (info != 1) {
            split2errors = true;
            continue;
         }
         split2errors = split2errors || fabs(threshold - 0.5) > 100 * machineepsilon;
         split2errors = split2errors || fabs(rms - 0) > 100 * machineepsilon;
         if (n == 2) {
            split2errors = split2errors || fabs(cvrms - 0.5) > 100 * machineepsilon;
         } else {
            if (n == 3) {
               split2errors = split2errors || fabs(cvrms - sqrt((2 * 0 + 2 * 0 + 2 * 0.25) / 6)) > 100 * machineepsilon;
            } else {
               split2errors = split2errors || fabs(cvrms) > 100 * machineepsilon;
            }
         }
      }
   }
// special tests
   n = 10;
   ae_vector_set_length(&a, n - 1 + 1);
   ae_vector_set_length(&c, n - 1 + 1);
   ae_vector_set_length(&tiebuf, n + 1);
   ae_vector_set_length(&cntbuf, 2 * 3 - 1 + 1);
   for (i = 0; i < n; i++) {
      a.xR[i] = (double)i;
      if (i < n - 2) {
         c.xZ[i] = 0;
      } else {
         c.xZ[i] = i - (n - 3);
      }
   }
   dsoptimalsplit2fast(&a, &c, &tiebuf, &cntbuf, &sortrbuf, &sortibuf, n, 3, 0.00, &info, &threshold, &rms, &cvrms);
   if (info != 1) {
      split2errors = true;
   } else {
      split2errors = split2errors || fabs(threshold - (n - 2.5)) > 100 * machineepsilon;
      split2errors = split2errors || fabs(rms - sqrt((0.25 + 0.25 + 0.25 + 0.25) / (3 * n))) > 100 * machineepsilon;
      split2errors = split2errors || fabs(cvrms - sqrt((double)(1 + 1 + 1 + 1) / (3 * n))) > 100 * machineepsilon;
   }
// Optimal split-K
// General tests for different N's
   for (n = 1; n <= maxnq; n++) {
      ae_vector_set_length(&a, n - 1 + 1);
      ae_vector_set_length(&c, n - 1 + 1);
   // one-tie test
      if (n % 2 == 0) {
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)n;
            c.xZ[i] = i % 2;
         }
         dsoptimalsplitk(&a, &c, n, 2, 2 + randominteger(5), &info, &thresholds, &ni, &cve);
         if (info != -3) {
            optimalsplitkerrors = true;
            continue;
         }
      }
   // two-tie test
   // test #1
      if (n > 1) {
         c0 = 0;
         c1 = 0;
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)(i / ((n + 1) / 2));
            c.xZ[i] = i / ((n + 1) / 2);
            if (c.xZ[i] == 0) {
               c0++;
            }
            if (c.xZ[i] == 1) {
               c1++;
            }
         }
         dsoptimalsplitk(&a, &c, n, 2, 2 + randominteger(5), &info, &thresholds, &ni, &cve);
         if (info != 1) {
            optimalsplitkerrors = true;
            continue;
         }
         optimalsplitkerrors = optimalsplitkerrors || ni != 2;
         optimalsplitkerrors = optimalsplitkerrors || fabs(thresholds.xR[0] - 0.5) > 100 * machineepsilon;
         optimalsplitkerrors = optimalsplitkerrors || fabs(cve - (-c0 * log((double)c0 / (c0 + 1)) - c1 * log((double)c1 / (c1 + 1)))) > 100 * machineepsilon;
      }
   // test #2
      if (n > 2) {
         c0 = 1 + randominteger(n - 1);
         c1 = n - c0;
         for (i = 0; i < n; i++) {
            if (i < c0) {
               a.xR[i] = 0.0;
               c.xZ[i] = 0;
            } else {
               a.xR[i] = 1.0;
               c.xZ[i] = 1;
            }
         }
         dsoptimalsplitk(&a, &c, n, 2, 2 + randominteger(5), &info, &thresholds, &ni, &cve);
         if (info != 1) {
            optimalsplitkerrors = true;
            continue;
         }
         optimalsplitkerrors = optimalsplitkerrors || ni != 2;
         optimalsplitkerrors = optimalsplitkerrors || fabs(thresholds.xR[0] - 0.5) > 100 * machineepsilon;
         optimalsplitkerrors = optimalsplitkerrors || fabs(cve - (-c0 * log((double)c0 / (c0 + 1)) - c1 * log((double)c1 / (c1 + 1)))) > 100 * machineepsilon;
      }
   // multi-tie test
      if (n >= 16) {
      // Multi-tie test.
      //
      // First NC-1 ties have C0 entries, remaining NC-th tie
      // have C1 entries.
         nc = iround(sqrt((double)n));
         c0 = n / nc;
         c1 = n - c0 * (nc - 1);
         for (i = 0; i < nc - 1; i++) {
            for (j = c0 * i; j < c0 * (i + 1); j++) {
               a.xR[j] = (double)j;
               c.xZ[j] = i;
            }
         }
         for (j = c0 * (nc - 1); j < n; j++) {
            a.xR[j] = (double)j;
            c.xZ[j] = nc - 1;
         }
         dsoptimalsplitk(&a, &c, n, nc, nc + randominteger(nc), &info, &thresholds, &ni, &cve);
         if (info != 1) {
            optimalsplitkerrors = true;
            continue;
         }
         optimalsplitkerrors = optimalsplitkerrors || ni != nc;
         if (ni == nc) {
            for (i = 0; i < nc - 1; i++) {
               optimalsplitkerrors = optimalsplitkerrors || fabs(thresholds.xR[i] - (c0 * (i + 1) - 1 + 0.5)) > 100 * machineepsilon;
            }
            cvr = -((nc - 1) * c0 * log((double)c0 / (c0 + nc - 1)) + c1 * log((double)c1 / (c1 + nc - 1)));
            optimalsplitkerrors = optimalsplitkerrors || fabs(cve - cvr) > 100 * machineepsilon;
         }
      }
   }
// Non-optimal split-K
// General tests for different N's
   for (n = 1; n <= maxnq; n++) {
      ae_vector_set_length(&a, n - 1 + 1);
      ae_vector_set_length(&c, n - 1 + 1);
   // one-tie test
      if (n % 2 == 0) {
         for (i = 0; i < n; i++) {
            a.xR[i] = 99.0;
            c.xZ[i] = i % 2;
         }
         dssplitk(&a, &c, n, 2, 2 + randominteger(5), &info, &thresholds, &ni, &cve);
         if (info != -3) {
            splitkerrors = true;
            continue;
         }
      }
   // two-tie test
   // test #1
      if (n > 1) {
         c0 = 0;
         c1 = 0;
         for (i = 0; i < n; i++) {
            a.xR[i] = (double)(i / ((n + 1) / 2));
            c.xZ[i] = i / ((n + 1) / 2);
            if (c.xZ[i] == 0) {
               c0++;
            }
            if (c.xZ[i] == 1) {
               c1++;
            }
         }
         dssplitk(&a, &c, n, 2, 2 + randominteger(5), &info, &thresholds, &ni, &cve);
         if (info != 1) {
            splitkerrors = true;
            continue;
         }
         splitkerrors = splitkerrors || ni != 2;
         if (ni == 2) {
            splitkerrors = splitkerrors || fabs(thresholds.xR[0] - 0.5) > 100 * machineepsilon;
            splitkerrors = splitkerrors || fabs(cve - (-c0 * log((double)c0 / (c0 + 1)) - c1 * log((double)c1 / (c1 + 1)))) > 100 * machineepsilon;
         }
      }
   // test #2
      if (n > 2) {
         c0 = 1 + randominteger(n - 1);
         c1 = n - c0;
         for (i = 0; i < n; i++) {
            if (i < c0) {
               a.xR[i] = 0.0;
               c.xZ[i] = 0;
            } else {
               a.xR[i] = 1.0;
               c.xZ[i] = 1;
            }
         }
         dssplitk(&a, &c, n, 2, 2 + randominteger(5), &info, &thresholds, &ni, &cve);
         if (info != 1) {
            splitkerrors = true;
            continue;
         }
         splitkerrors = splitkerrors || ni != 2;
         if (ni == 2) {
            splitkerrors = splitkerrors || fabs(thresholds.xR[0] - 0.5) > 100 * machineepsilon;
            splitkerrors = splitkerrors || fabs(cve - (-c0 * log((double)c0 / (c0 + 1)) - c1 * log((double)c1 / (c1 + 1)))) > 100 * machineepsilon;
         }
      }
   // multi-tie test
      for (c0 = 4; c0 <= n; c0++) {
         if ((n % c0 == 0 && n / c0 <= c0) && n / c0 > 1) {
            nc = n / c0;
            for (i = 0; i < nc; i++) {
               for (j = c0 * i; j < c0 * (i + 1); j++) {
                  a.xR[j] = (double)j;
                  c.xZ[j] = i;
               }
            }
            dssplitk(&a, &c, n, nc, nc + randominteger(nc), &info, &thresholds, &ni, &cve);
            if (info != 1) {
               splitkerrors = true;
               continue;
            }
            splitkerrors = splitkerrors || ni != nc;
            if (ni == nc) {
               for (i = 0; i < nc - 1; i++) {
                  splitkerrors = splitkerrors || fabs(thresholds.xR[i] - (c0 * (i + 1) - 1 + 0.5)) > 100 * machineepsilon;
               }
               cvr = -nc * c0 * log((double)c0 / (c0 + nc - 1));
               splitkerrors = splitkerrors || fabs(cve - cvr) > 100 * machineepsilon;
            }
         }
      }
   }
// report
   waserrors = ((tieserrors || split2errors) || optimalsplitkerrors) || splitkerrors;
   if (!silent) {
      printf("TESTING BASIC DATASET SUBROUTINES\n");
      printf("TIES:                               ");
      if (!tieserrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("SPLIT-2:                            ");
      if (!split2errors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("OPTIMAL SPLIT-K:                    ");
      if (!optimalsplitkerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("SPLIT-K:                            ");
      if (!splitkerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === mlpbase testing unit ===
// This function compares vectors G0 and G1 and returns
//     ||G0-G1||/max(||G0||,||G1||,S)
//
// For zero G0, G1 and S (all three quantities are zero) it returns zero.
static double testmlpbaseunit_vectordiff(RVector *g0, RVector *g1, ae_int_t n, double s) {
   ae_int_t i;
   double norm0;
   double norm1;
   double diff;
   double result;
   norm0 = 0.0;
   norm1 = 0.0;
   diff = 0.0;
   for (i = 0; i < n; i++) {
      norm0 += sqr(g0->xR[i]);
      norm1 += sqr(g1->xR[i]);
      diff += sqr(g0->xR[i] - g1->xR[i]);
   }
   norm0 = sqrt(norm0);
   norm1 = sqrt(norm1);
   diff = sqrt(diff);
   if ((norm0 != 0.0 || norm1 != 0.0) || s != 0.0) {
      diff /= rmax2(rmax2(norm0, norm1), s);
   } else {
      diff = 0.0;
   }
   result = diff;
   return result;
}

// Network creation
//
// This function creates network with desired structure.
//
// Network is created using one of the three methods:
// a) straightforward creation using MLPCreate???()
// b) MLPCreate???() for proxy object, which is copied with PassThroughSerializer()
// c) MLPCreate???() for proxy object, which is copied with MLPCopy()
//
// One of these methods is chosen at random.
static void testmlpbaseunit_createnetwork(multilayerperceptron *network, ae_int_t nkind, double a1, double a2, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout) {
   ae_frame _frame_block;
   ae_int_t mkind;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, tmp);
   ae_assert(((nin > 0 && nhid1 >= 0) && nhid2 >= 0) && nout > 0, "CreateNetwork error");
   ae_assert(nhid1 != 0 || nhid2 == 0, "CreateNetwork error");
   ae_assert(nkind != 1 || nout >= 2, "CreateNetwork error");
   mkind = randominteger(3);
   if (nhid1 == 0) {
   // No hidden layers
      if (nkind == 0) {
         if (mkind == 0) {
            mlpcreate0(nin, nout, network);
         }
         if (mkind == 1) {
            mlpcreate0(nin, nout, &tmp);
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_int_t _local_ssize;
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               mlpalloc(&_local_serializer, &tmp);
               _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpserialize(&_local_serializer, &tmp);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpunserialize(&_local_serializer, network);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
         }
         if (mkind == 2) {
            mlpcreate0(nin, nout, &tmp);
            mlpcopy(&tmp, network);
         }
      } else {
         if (nkind == 1) {
            if (mkind == 0) {
               mlpcreatec0(nin, nout, network);
            }
            if (mkind == 1) {
               mlpcreatec0(nin, nout, &tmp);
               {
               // This code passes data structure through serializers
               // (serializes it to string and loads back)
                  ae_int_t _local_ssize;
                  ae_frame _local_frame_block;
                  ae_frame_make(&_local_frame_block);
                  NewSerializer(_local_serializer);
                  ae_serializer_alloc_start(&_local_serializer);
                  mlpalloc(&_local_serializer, &tmp);
                  _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                  NewBlock(_local_dynamic_block, _local_ssize + 1);
                  ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  mlpserialize(&_local_serializer, &tmp);
                  ae_serializer_stop(&_local_serializer);
                  ae_serializer_init(&_local_serializer);
                  ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  mlpunserialize(&_local_serializer, network);
                  ae_serializer_stop(&_local_serializer);
                  ae_frame_leave();
               }
            }
            if (mkind == 2) {
               mlpcreatec0(nin, nout, &tmp);
               mlpcopy(&tmp, network);
            }
         } else {
            if (nkind == 2) {
               if (mkind == 0) {
                  mlpcreateb0(nin, nout, a1, a2, network);
               }
               if (mkind == 1) {
                  mlpcreateb0(nin, nout, a1, a2, &tmp);
                  {
                  // This code passes data structure through serializers
                  // (serializes it to string and loads back)
                     ae_int_t _local_ssize;
                     ae_frame _local_frame_block;
                     ae_frame_make(&_local_frame_block);
                     NewSerializer(_local_serializer);
                     ae_serializer_alloc_start(&_local_serializer);
                     mlpalloc(&_local_serializer, &tmp);
                     _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                     NewBlock(_local_dynamic_block, _local_ssize + 1);
                     ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                     mlpserialize(&_local_serializer, &tmp);
                     ae_serializer_stop(&_local_serializer);
                     ae_serializer_init(&_local_serializer);
                     ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                     mlpunserialize(&_local_serializer, network);
                     ae_serializer_stop(&_local_serializer);
                     ae_frame_leave();
                  }
               }
               if (mkind == 2) {
                  mlpcreateb0(nin, nout, a1, a2, &tmp);
                  mlpcopy(&tmp, network);
               }
            } else {
               if (nkind == 3) {
                  if (mkind == 0) {
                     mlpcreater0(nin, nout, a1, a2, network);
                  }
                  if (mkind == 1) {
                     mlpcreater0(nin, nout, a1, a2, &tmp);
                     {
                     // This code passes data structure through serializers
                     // (serializes it to string and loads back)
                        ae_int_t _local_ssize;
                        ae_frame _local_frame_block;
                        ae_frame_make(&_local_frame_block);
                        NewSerializer(_local_serializer);
                        ae_serializer_alloc_start(&_local_serializer);
                        mlpalloc(&_local_serializer, &tmp);
                        _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                        NewBlock(_local_dynamic_block, _local_ssize + 1);
                        ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                        mlpserialize(&_local_serializer, &tmp);
                        ae_serializer_stop(&_local_serializer);
                        ae_serializer_init(&_local_serializer);
                        ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                        mlpunserialize(&_local_serializer, network);
                        ae_serializer_stop(&_local_serializer);
                        ae_frame_leave();
                     }
                  }
                  if (mkind == 2) {
                     mlpcreater0(nin, nout, a1, a2, &tmp);
                     mlpcopy(&tmp, network);
                  }
               }
            }
         }
      }
      mlprandomizefull(network);
      ae_frame_leave();
      return;
   }
   if (nhid2 == 0) {
   // One hidden layer
      if (nkind == 0) {
         if (mkind == 0) {
            mlpcreate1(nin, nhid1, nout, network);
         }
         if (mkind == 1) {
            mlpcreate1(nin, nhid1, nout, &tmp);
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_int_t _local_ssize;
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               mlpalloc(&_local_serializer, &tmp);
               _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpserialize(&_local_serializer, &tmp);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpunserialize(&_local_serializer, network);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
         }
         if (mkind == 2) {
            mlpcreate1(nin, nhid1, nout, &tmp);
            mlpcopy(&tmp, network);
         }
      } else {
         if (nkind == 1) {
            if (mkind == 0) {
               mlpcreatec1(nin, nhid1, nout, network);
            }
            if (mkind == 1) {
               mlpcreatec1(nin, nhid1, nout, &tmp);
               {
               // This code passes data structure through serializers
               // (serializes it to string and loads back)
                  ae_int_t _local_ssize;
                  ae_frame _local_frame_block;
                  ae_frame_make(&_local_frame_block);
                  NewSerializer(_local_serializer);
                  ae_serializer_alloc_start(&_local_serializer);
                  mlpalloc(&_local_serializer, &tmp);
                  _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                  NewBlock(_local_dynamic_block, _local_ssize + 1);
                  ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  mlpserialize(&_local_serializer, &tmp);
                  ae_serializer_stop(&_local_serializer);
                  ae_serializer_init(&_local_serializer);
                  ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  mlpunserialize(&_local_serializer, network);
                  ae_serializer_stop(&_local_serializer);
                  ae_frame_leave();
               }
            }
            if (mkind == 2) {
               mlpcreatec1(nin, nhid1, nout, &tmp);
               mlpcopy(&tmp, network);
            }
         } else {
            if (nkind == 2) {
               if (mkind == 0) {
                  mlpcreateb1(nin, nhid1, nout, a1, a2, network);
               }
               if (mkind == 1) {
                  mlpcreateb1(nin, nhid1, nout, a1, a2, &tmp);
                  {
                  // This code passes data structure through serializers
                  // (serializes it to string and loads back)
                     ae_int_t _local_ssize;
                     ae_frame _local_frame_block;
                     ae_frame_make(&_local_frame_block);
                     NewSerializer(_local_serializer);
                     ae_serializer_alloc_start(&_local_serializer);
                     mlpalloc(&_local_serializer, &tmp);
                     _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                     NewBlock(_local_dynamic_block, _local_ssize + 1);
                     ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                     mlpserialize(&_local_serializer, &tmp);
                     ae_serializer_stop(&_local_serializer);
                     ae_serializer_init(&_local_serializer);
                     ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                     mlpunserialize(&_local_serializer, network);
                     ae_serializer_stop(&_local_serializer);
                     ae_frame_leave();
                  }
               }
               if (mkind == 2) {
                  mlpcreateb1(nin, nhid1, nout, a1, a2, &tmp);
                  mlpcopy(&tmp, network);
               }
            } else {
               if (nkind == 3) {
                  if (mkind == 0) {
                     mlpcreater1(nin, nhid1, nout, a1, a2, network);
                  }
                  if (mkind == 1) {
                     mlpcreater1(nin, nhid1, nout, a1, a2, &tmp);
                     {
                     // This code passes data structure through serializers
                     // (serializes it to string and loads back)
                        ae_int_t _local_ssize;
                        ae_frame _local_frame_block;
                        ae_frame_make(&_local_frame_block);
                        NewSerializer(_local_serializer);
                        ae_serializer_alloc_start(&_local_serializer);
                        mlpalloc(&_local_serializer, &tmp);
                        _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                        NewBlock(_local_dynamic_block, _local_ssize + 1);
                        ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                        mlpserialize(&_local_serializer, &tmp);
                        ae_serializer_stop(&_local_serializer);
                        ae_serializer_init(&_local_serializer);
                        ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                        mlpunserialize(&_local_serializer, network);
                        ae_serializer_stop(&_local_serializer);
                        ae_frame_leave();
                     }
                  }
                  if (mkind == 2) {
                     mlpcreater1(nin, nhid1, nout, a1, a2, &tmp);
                     mlpcopy(&tmp, network);
                  }
               }
            }
         }
      }
      mlprandomizefull(network);
      ae_frame_leave();
      return;
   }
// Two hidden layers
   if (nkind == 0) {
      if (mkind == 0) {
         mlpcreate2(nin, nhid1, nhid2, nout, network);
      }
      if (mkind == 1) {
         mlpcreate2(nin, nhid1, nhid2, nout, &tmp);
         {
         // This code passes data structure through serializers
         // (serializes it to string and loads back)
            ae_int_t _local_ssize;
            ae_frame _local_frame_block;
            ae_frame_make(&_local_frame_block);
            NewSerializer(_local_serializer);
            ae_serializer_alloc_start(&_local_serializer);
            mlpalloc(&_local_serializer, &tmp);
            _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
            NewBlock(_local_dynamic_block, _local_ssize + 1);
            ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            mlpserialize(&_local_serializer, &tmp);
            ae_serializer_stop(&_local_serializer);
            ae_serializer_init(&_local_serializer);
            ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            mlpunserialize(&_local_serializer, network);
            ae_serializer_stop(&_local_serializer);
            ae_frame_leave();
         }
      }
      if (mkind == 2) {
         mlpcreate2(nin, nhid1, nhid2, nout, &tmp);
         mlpcopy(&tmp, network);
      }
   } else {
      if (nkind == 1) {
         if (mkind == 0) {
            mlpcreatec2(nin, nhid1, nhid2, nout, network);
         }
         if (mkind == 1) {
            mlpcreatec2(nin, nhid1, nhid2, nout, &tmp);
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_int_t _local_ssize;
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               mlpalloc(&_local_serializer, &tmp);
               _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpserialize(&_local_serializer, &tmp);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpunserialize(&_local_serializer, network);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
         }
         if (mkind == 2) {
            mlpcreatec2(nin, nhid1, nhid2, nout, &tmp);
            mlpcopy(&tmp, network);
         }
      } else {
         if (nkind == 2) {
            if (mkind == 0) {
               mlpcreateb2(nin, nhid1, nhid2, nout, a1, a2, network);
            }
            if (mkind == 1) {
               mlpcreateb2(nin, nhid1, nhid2, nout, a1, a2, &tmp);
               {
               // This code passes data structure through serializers
               // (serializes it to string and loads back)
                  ae_int_t _local_ssize;
                  ae_frame _local_frame_block;
                  ae_frame_make(&_local_frame_block);
                  NewSerializer(_local_serializer);
                  ae_serializer_alloc_start(&_local_serializer);
                  mlpalloc(&_local_serializer, &tmp);
                  _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                  NewBlock(_local_dynamic_block, _local_ssize + 1);
                  ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  mlpserialize(&_local_serializer, &tmp);
                  ae_serializer_stop(&_local_serializer);
                  ae_serializer_init(&_local_serializer);
                  ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                  mlpunserialize(&_local_serializer, network);
                  ae_serializer_stop(&_local_serializer);
                  ae_frame_leave();
               }
            }
            if (mkind == 2) {
               mlpcreateb2(nin, nhid1, nhid2, nout, a1, a2, &tmp);
               mlpcopy(&tmp, network);
            }
         } else {
            if (nkind == 3) {
               if (mkind == 0) {
                  mlpcreater2(nin, nhid1, nhid2, nout, a1, a2, network);
               }
               if (mkind == 1) {
                  mlpcreater2(nin, nhid1, nhid2, nout, a1, a2, &tmp);
                  {
                  // This code passes data structure through serializers
                  // (serializes it to string and loads back)
                     ae_int_t _local_ssize;
                     ae_frame _local_frame_block;
                     ae_frame_make(&_local_frame_block);
                     NewSerializer(_local_serializer);
                     ae_serializer_alloc_start(&_local_serializer);
                     mlpalloc(&_local_serializer, &tmp);
                     _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
                     NewBlock(_local_dynamic_block, _local_ssize + 1);
                     ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                     mlpserialize(&_local_serializer, &tmp);
                     ae_serializer_stop(&_local_serializer);
                     ae_serializer_init(&_local_serializer);
                     ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
                     mlpunserialize(&_local_serializer, network);
                     ae_serializer_stop(&_local_serializer);
                     ae_frame_leave();
                  }
               }
               if (mkind == 2) {
                  mlpcreater2(nin, nhid1, nhid2, nout, a1, a2, &tmp);
                  mlpcopy(&tmp, network);
               }
            }
         }
      }
   }
   mlprandomizefull(network);
   ae_frame_leave();
}

// Unsets network (initialize it to smallest network possible
static void testmlpbaseunit_unsetnetwork(multilayerperceptron *network) {
   mlpcreate0(1, 1, network);
}

// Informational functions test
static void testmlpbaseunit_testinformational(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t passcount, bool *err) {
   ae_frame _frame_block;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t wcount;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double threshold;
   ae_int_t nlayers;
   ae_int_t nmax;
   double mean;
   double sigma;
   ae_int_t fkind;
   double c;
   double f;
   double df;
   double d2f;
   double s;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewMatrix(neurons, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   threshold = 100000 * machineepsilon;
   testmlpbaseunit_createnetwork(&network, nkind, 0.0, 0.0, nin, nhid1, nhid2, nout);
// test MLPProperties()
   mlpproperties(&network, &n1, &n2, &wcount);
   *err = ((*err || n1 != nin) || n2 != nout) || wcount <= 0;
   *err = ((*err || mlpgetinputscount(&network) != nin) || mlpgetoutputscount(&network) != nout) || mlpgetweightscount(&network) != wcount;
// Test network geometry functions
//
// In order to do this we calculate neural network output using
// informational functions only, and compare results with ones
// obtained with MLPProcess():
// 1. we allocate 2-dimensional array of neurons and fill it by zeros
// 2. we full first layer of neurons by input values
// 3. we move through array, calculating values of subsequent layers
// 4. if we have classification network, we SOFTMAX-normalize output layer
// 5. we apply scaling to the outputs
// 6. we compare results with ones obtained by MLPProcess()
//
// NOTE: it is important to do (4) before (5), because on SOFTMAX network
//       MLPGetOutputScaling() must return Mean=0 and Sigma=1. In order
//       to test it implicitly, we apply it to the classifier results
//       (already normalized). If one of the coefficients deviates from
//       expected values, we will get error during (6).
   nlayers = 2;
   nmax = imax2(nin, nout);
   if (nhid1 != 0) {
      nlayers = 3;
      nmax = imax2(nmax, nhid1);
   }
   if (nhid2 != 0) {
      nlayers = 4;
      nmax = imax2(nmax, nhid2);
   }
   ae_matrix_set_length(&neurons, nlayers, nmax);
   for (i = 0; i < nlayers; i++) {
      for (j = 0; j < nmax; j++) {
         neurons.xyR[i][j] = 0.0;
      }
   }
   ae_vector_set_length(&x, nin);
   for (i = 0; i < nin; i++) {
      x.xR[i] = randommid();
   }
   ae_vector_set_length(&y, nout);
   for (i = 0; i < nout; i++) {
      y.xR[i] = randommid();
   }
   for (j = 0; j < nin; j++) {
      mlpgetinputscaling(&network, j, &mean, &sigma);
      neurons.xyR[0][j] = (x.xR[j] - mean) / sigma;
   }
   for (i = 1; i < nlayers; i++) {
      for (j = 0; j < mlpgetlayersize(&network, i); j++) {
         for (k = 0; k < mlpgetlayersize(&network, i - 1); k++) {
            neurons.xyR[i][j] += mlpgetweight(&network, i - 1, k, i, j) * neurons.xyR[i - 1][k];
         }
         mlpgetneuroninfo(&network, i, j, &fkind, &c);
         mlpactivationfunction(neurons.xyR[i][j] - c, fkind, &f, &df, &d2f);
         neurons.xyR[i][j] = f;
      }
   }
   if (nkind == 1) {
      s = 0.0;
      for (j = 0; j < nout; j++) {
         s += exp(neurons.xyR[nlayers - 1][j]);
      }
      for (j = 0; j < nout; j++) {
         neurons.xyR[nlayers - 1][j] = exp(neurons.xyR[nlayers - 1][j]) / s;
      }
   }
   for (j = 0; j < nout; j++) {
      mlpgetoutputscaling(&network, j, &mean, &sigma);
      neurons.xyR[nlayers - 1][j] = neurons.xyR[nlayers - 1][j] * sigma + mean;
   }
   mlpprocess(&network, &x, &y);
   for (j = 0; j < nout; j++) {
      *err = *err || fabs(neurons.xyR[nlayers - 1][j] - y.xR[j]) > threshold;
   }
   ae_frame_leave();
}

// Processing functions test
static void testmlpbaseunit_testprocessing(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t passcount, bool *err) {
   ae_frame _frame_block;
   ae_int_t npoints;
   ae_int_t subnp;
   bool iscls;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t wcount;
   bool zeronet;
   double a1;
   double a2;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   bool allsame;
   ae_int_t pcount;
   double v;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewObj(multilayerperceptron, network2);
   NewObj(sparsematrix, sparsexy);
   NewMatrix(densexy, 0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(p0, 0, DT_REAL);
   NewVector(p1, 0, DT_REAL);
   ae_assert(passcount >= 2, "PassCount<2!");
// Prepare network
   a1 = 0.0;
   a2 = 0.0;
   if (nkind == 2) {
      a1 = 500.0 * randommid();
      a2 = randommid();
   }
   if (nkind == 3) {
      a1 = 500.0 * randommid();
      a2 = a1 + (2 * randominteger(2) - 1) * (0.1 + 0.9 * randomreal());
   }
   testmlpbaseunit_createnetwork(&network, nkind, a1, a2, nin, nhid1, nhid2, nout);
   mlpproperties(&network, &n1, &n2, &wcount);
   iscls = mlpissoftmax(&network);
// Initialize arrays
   ae_vector_set_length(&x1, nin);
   ae_vector_set_length(&x2, nin);
   ae_vector_set_length(&y1, nout);
   ae_vector_set_length(&y2, nout);
// Initialize sets
   npoints = randominteger(11) + 10;
   if (iscls) {
      ae_matrix_set_length(&densexy, npoints, nin + 1);
      sparsecreate(npoints, nin + 1, npoints, &sparsexy);
   } else {
      ae_matrix_set_length(&densexy, npoints, nin + nout);
      sparsecreate(npoints, nin + nout, npoints, &sparsexy);
   }
   sparseconverttocrs(&sparsexy);
// Main cycle
   for (pass = 1; pass <= passcount; pass++) {
   // Last run is made on zero network
      mlprandomizefull(&network);
      zeronet = false;
      if (pass == passcount) {
         ae_v_muld(network.weights.xR, 1, wcount, 0);
         zeronet = true;
      }
   // Same inputs leads to same outputs
      for (i = 0; i < nin; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nout; i++) {
         y1.xR[i] = randommid();
         y2.xR[i] = randommid();
      }
      mlpprocess(&network, &x1, &y1);
      mlpprocess(&network, &x2, &y2);
      set_error_flag(err, testmlpbaseunit_vectordiff(&y1, &y2, nout, 1.0) != 0.0, __FILE__, __LINE__, "testmlpbaseunit.ap:513");
   // Same inputs on original network leads to same outputs
   // on copy created:
   // * using MLPCopy
   // * using MLPCopyShared
      for (i = 0; i < nin; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nout; i++) {
         y1.xR[i] = randommid();
      }
      for (i = 0; i < nout; i++) {
         y2.xR[i] = randommid();
      }
      testmlpbaseunit_unsetnetwork(&network2);
      mlpcopy(&network, &network2);
      mlpprocess(&network, &x1, &y1);
      mlpprocess(&network2, &x2, &y2);
      set_error_flag(err, testmlpbaseunit_vectordiff(&y1, &y2, nout, 1.0) != 0.0, __FILE__, __LINE__, "testmlpbaseunit.ap:534");
      for (i = 0; i < nout; i++) {
         y2.xR[i] = randommid();
      }
      testmlpbaseunit_unsetnetwork(&network2);
      mlpcopyshared(&network, &network2);
      mlpprocess(&network, &x1, &y1);
      mlpprocess(&network2, &x2, &y2);
      set_error_flag(err, testmlpbaseunit_vectordiff(&y1, &y2, nout, 1.0) != 0.0, __FILE__, __LINE__, "testmlpbaseunit.ap:541");
   // Additionally we tests functions for copying of tunable
   // parameters by:
   // * copying network using MLPCopy
   // * randomizing tunable parameters with MLPRandomizeFull()
   // * copying tunable parameters with:
   //   a) MLPCopyTunableParameters
   //   b) combination of MLPExportTunableParameters and
   //      MLPImportTunableParameters - we export parameters
   //      to P1, copy PCount elements to P2, then test import.
      for (i = 0; i < nin; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nout; i++) {
         y1.xR[i] = randommid();
      }
      for (i = 0; i < nout; i++) {
         y2.xR[i] = randommid();
      }
      testmlpbaseunit_unsetnetwork(&network2);
      mlpcopy(&network, &network2);
      mlprandomizefull(&network2);
      mlpcopytunableparameters(&network, &network2);
      mlpprocess(&network, &x1, &y1);
      mlpprocess(&network2, &x2, &y2);
      set_error_flag(err, testmlpbaseunit_vectordiff(&y1, &y2, nout, 1.0) != 0.0, __FILE__, __LINE__, "testmlpbaseunit.ap:571");
      for (i = 0; i < nout; i++) {
         y2.xR[i] = randommid();
      }
      testmlpbaseunit_unsetnetwork(&network2);
      mlpcopy(&network, &network2);
      mlprandomizefull(&network2);
      mlpexporttunableparameters(&network, &p0, &pcount);
      ae_vector_set_length(&p1, pcount);
      for (i = 0; i < pcount; i++) {
         p1.xR[i] = p0.xR[i];
      }
      mlpimporttunableparameters(&network2, &p1);
      mlpprocess(&network, &x1, &y1);
      mlpprocess(&network2, &x2, &y2);
      set_error_flag(err, testmlpbaseunit_vectordiff(&y1, &y2, nout, 1.0) != 0.0, __FILE__, __LINE__, "testmlpbaseunit.ap:585");
   // Same inputs on original network leads to same outputs
   // on copy created using MLPSerialize
      testmlpbaseunit_unsetnetwork(&network2);
      {
      // This code passes data structure through serializers
      // (serializes it to string and loads back)
         ae_int_t _local_ssize;
         ae_frame _local_frame_block;
         ae_frame_make(&_local_frame_block);
         NewSerializer(_local_serializer);
         ae_serializer_alloc_start(&_local_serializer);
         mlpalloc(&_local_serializer, &network);
         _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
         NewBlock(_local_dynamic_block, _local_ssize + 1);
         ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
         mlpserialize(&_local_serializer, &network);
         ae_serializer_stop(&_local_serializer);
         ae_serializer_init(&_local_serializer);
         ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
         mlpunserialize(&_local_serializer, &network2);
         ae_serializer_stop(&_local_serializer);
         ae_frame_leave();
      }
      for (i = 0; i < nin; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nout; i++) {
         y1.xR[i] = randommid();
         y2.xR[i] = randommid();
      }
      mlpprocess(&network, &x1, &y1);
      mlpprocess(&network2, &x2, &y2);
      allsame = true;
      for (i = 0; i < nout; i++) {
         allsame = allsame && y1.xR[i] == y2.xR[i];
      }
      *err = *err || !allsame;
   // Different inputs leads to different outputs (non-zero network)
      if (!zeronet) {
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = randommid();
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = y1.xR[i];
         }
         mlpprocess(&network, &x1, &y1);
         mlpprocess(&network, &x2, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         *err = *err || allsame;
      }
   // Randomization changes outputs (when inputs are unchanged, non-zero network)
      if (!zeronet) {
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = randommid();
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = y1.xR[i];
         }
         mlpcopy(&network, &network2);
         mlprandomize(&network2);
         mlpprocess(&network, &x1, &y1);
         mlpprocess(&network2, &x1, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         *err = *err || allsame;
      }
   // Full randomization changes outputs (when inputs are unchanged, non-zero network)
      if (!zeronet) {
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = randommid();
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = y1.xR[i];
         }
         mlpcopy(&network, &network2);
         mlprandomizefull(&network2);
         mlpprocess(&network, &x1, &y1);
         mlpprocess(&network2, &x1, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         *err = *err || allsame;
      }
   // Normalization properties
      if (nkind == 1) {
      // Classifier network outputs are normalized
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
         }
         mlpprocess(&network, &x1, &y1);
         v = 0.0;
         for (i = 0; i < nout; i++) {
            v += y1.xR[i];
            *err = *err || y1.xR[i] < 0.0;
         }
         *err = *err || fabs(v - 1) > 1000 * machineepsilon;
      }
      if (nkind == 2) {
      // B-type network outputs are bounded from above/below
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
         }
         mlpprocess(&network, &x1, &y1);
         for (i = 0; i < nout; i++) {
            if (a2 >= 0.0) {
               *err = *err || y1.xR[i] < a1;
            } else {
               *err = *err || y1.xR[i] > a1;
            }
         }
      }
      if (nkind == 3) {
      // R-type network outputs are within [A1,A2] (or [A2,A1])
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
         }
         mlpprocess(&network, &x1, &y1);
         for (i = 0; i < nout; i++) {
            *err = (*err || y1.xR[i] < rmin2(a1, a2)) || y1.xR[i] > rmax2(a1, a2);
         }
      }
   // Comperison MLPInitPreprocessor results with
   // MLPInitPreprocessorSparse results
      sparseconverttohash(&sparsexy);
      if (iscls) {
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nin; j++) {
               densexy.xyR[i][j] = randommid();
               sparseset(&sparsexy, i, j, densexy.xyR[i][j]);
            }
            densexy.xyR[i][nin] = (double)randominteger(nout);
            sparseset(&sparsexy, i, j, densexy.xyR[i][nin]);
         }
      } else {
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nin + nout; j++) {
               densexy.xyR[i][j] = randommid();
               sparseset(&sparsexy, i, j, densexy.xyR[i][j]);
            }
         }
      }
      sparseconverttocrs(&sparsexy);
      mlpcopy(&network, &network2);
      mlpinitpreprocessor(&network, &densexy, npoints);
      mlpinitpreprocessorsparse(&network2, &sparsexy, npoints);
      subnp = randominteger(npoints);
      for (i = 0; i < subnp; i++) {
         for (j = 0; j < nin; j++) {
            x1.xR[j] = randommid();
         }
         mlpprocess(&network, &x1, &y1);
         mlpprocess(&network2, &x1, &y2);
         for (j = 0; j < nout; j++) {
            *err = *err || fabs(y1.xR[j] - y2.xR[j]) > 1.0E-6;
         }
      }
   }
   ae_frame_leave();
}

// Gradient functions test
static void testmlpbaseunit_testgradient(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t passcount, ae_int_t sizemin, ae_int_t sizemax, bool *err) {
   ae_frame _frame_block;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t wcount;
   double h;
   double etol;
   double escale;
   double gscale;
   double nonstricttolerance;
   double a1;
   double a2;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t ssize;
   ae_int_t subsetsize;
   ae_int_t rowsize;
   double v;
   double e;
   double e1;
   double e2;
   double esp;
   double v1;
   double v2;
   double v3;
   double v4;
   double wprev;
   double referencee;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewObj(sparsematrix, sparsexy);
   NewObj(sparsematrix, sparsexy2);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewVector(grad1, 0, DT_REAL);
   NewVector(grad2, 0, DT_REAL);
   NewVector(gradsp, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(idx, 0, DT_INT);
   NewVector(referenceg, 0, DT_REAL);
   a1 = 0.0;
   a2 = 0.0;
   if (nkind == 2) {
      a1 = 500.0 * randommid();
      a2 = randommid();
   }
   if (nkind == 3) {
      a1 = 500.0 * randommid();
      a2 = a1 + (2 * randominteger(2) - 1) * (0.1 + 0.9 * randomreal());
   }
   testmlpbaseunit_createnetwork(&network, nkind, a1, a2, nin, nhid1, nhid2, nout);
   mlpproperties(&network, &n1, &n2, &wcount);
   h = 0.0001;
   etol = 1.0E-2;
   escale = 1.0E-2;
   gscale = 1.0E-2;
   nonstricttolerance = 0.01;
// Initialize
   ae_vector_set_length(&x, nin);
   ae_vector_set_length(&x1, nin);
   ae_vector_set_length(&x2, nin);
   ae_vector_set_length(&y, nout);
   ae_vector_set_length(&y1, nout);
   ae_vector_set_length(&y2, nout);
   ae_vector_set_length(&referenceg, wcount);
   ae_vector_set_length(&grad1, wcount);
   ae_vector_set_length(&grad2, wcount);
// Process
   for (pass = 1; pass <= passcount; pass++) {
   // Randomize network, then re-randomaze weights manually.
   //
   // NOTE: weights magnitude is chosen to be small, about 0.1,
   //       which allows us to avoid oversaturated network.
   //       In 10% of cases we use zero weights.
      mlprandomizefull(&network);
      if (randombool(0.1)) {
         for (i = 0; i < wcount; i++) {
            network.weights.xR[i] = 0.0;
         }
      } else {
         for (i = 0; i < wcount; i++) {
            network.weights.xR[i] = 0.1 * randommid();
         }
      }
   // Test MLPError(), MLPErrorSparse(), MLPGrad() for single-element dataset:
   // * generate input X, output Y, combine them in dataset XY
   // * calculate "reference" error on dataset manually (call MLPProcess and evaluate sum-of-squared errors)
   // * calculate "reference" gradient by performing numerical differentiation of "reference" error
   //   using 4-point differentiation formula
   // * test error/gradient returned by MLPGrad(), MLPError(), MLPErrorSparse()
      ae_matrix_set_length(&xy, 1, nin + nout);
      sparsecreate(1, nin + nout, nin + nout, &sparsexy);
      for (i = 0; i < nin; i++) {
         x.xR[i] = 2.0 * randommid();
      }
      ae_v_move(xy.xyR[0], 1, x.xR, 1, nin);
      for (i = 0; i < nin; i++) {
         sparseset(&sparsexy, 0, i, x.xR[i]);
      }
      if (mlpissoftmax(&network)) {
         for (i = 0; i < nout; i++) {
            y.xR[i] = 0.0;
         }
         xy.xyR[0][nin] = (double)randominteger(nout);
         sparseset(&sparsexy, 0, nin, xy.xyR[0][nin]);
         y.xR[iround(xy.xyR[0][nin])] = 1.0;
      } else {
         for (i = 0; i < nout; i++) {
            y.xR[i] = 2.0 * randommid();
            sparseset(&sparsexy, 0, nin + i, y.xR[i]);
         }
         ae_v_move(&xy.xyR[0][nin], 1, y.xR, 1, nout);
      }
      sparseconverttocrs(&sparsexy);
      mlpprocess(&network, &x, &y2);
      ae_v_sub(y2.xR, 1, y.xR, 1, nout);
      referencee = ae_v_dotproduct(y2.xR, 1, y2.xR, 1, nout);
      referencee /= 2;
      for (i = 0; i < wcount; i++) {
         wprev = network.weights.xR[i];
         network.weights.xR[i] = wprev - 2 * h;
         mlpprocess(&network, &x, &y1);
         ae_v_sub(y1.xR, 1, y.xR, 1, nout);
         v1 = ae_v_dotproduct(y1.xR, 1, y1.xR, 1, nout);
         v1 /= 2;
         network.weights.xR[i] = wprev - h;
         mlpprocess(&network, &x, &y1);
         ae_v_sub(y1.xR, 1, y.xR, 1, nout);
         v2 = ae_v_dotproduct(y1.xR, 1, y1.xR, 1, nout);
         v2 /= 2;
         network.weights.xR[i] = wprev + h;
         mlpprocess(&network, &x, &y1);
         ae_v_sub(y1.xR, 1, y.xR, 1, nout);
         v3 = ae_v_dotproduct(y1.xR, 1, y1.xR, 1, nout);
         v3 /= 2;
         network.weights.xR[i] = wprev + 2 * h;
         mlpprocess(&network, &x, &y1);
         ae_v_sub(y1.xR, 1, y.xR, 1, nout);
         v4 = ae_v_dotproduct(y1.xR, 1, y1.xR, 1, nout);
         v4 /= 2;
         network.weights.xR[i] = wprev;
         referenceg.xR[i] = (v1 - 8 * v2 + 8 * v3 - v4) / (12 * h);
      }
      mlpgrad(&network, &x, &y, &e, &grad2);
      seterrorflagdiff(err, e, referencee, etol, escale);
      seterrorflagdiff(err, mlperror(&network, &xy, 1), referencee, etol, escale);
      seterrorflagdiff(err, mlperrorsparse(&network, &sparsexy, 1), referencee, etol, escale);
      set_error_flag(err, testmlpbaseunit_vectordiff(&referenceg, &grad2, wcount, gscale) > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:948");
   // Test MLPErrorN(), MLPGradN() for single-element dataset:
   // * generate input X, output Y, combine them in dataset XY
   // * calculate "reference" error on dataset manually (call MLPProcess and evaluate sum-of-squared errors)
   // * calculate "reference" gradient by performing numerical differentiation of "reference" error
   // * test error/gradient returned by MLPGradN(), MLPErrorN()
   //
   // NOTE: because we use inexact 2-point formula, we perform gradient test with NonStrictTolerance
      ae_matrix_set_length(&xy, 1, nin + nout);
      for (i = 0; i < nin; i++) {
         x.xR[i] = 2.0 * randommid();
      }
      ae_v_move(xy.xyR[0], 1, x.xR, 1, nin);
      if (mlpissoftmax(&network)) {
         for (i = 0; i < nout; i++) {
            y.xR[i] = 0.0;
         }
         xy.xyR[0][nin] = (double)randominteger(nout);
         y.xR[iround(xy.xyR[0][nin])] = 1.0;
      } else {
         for (i = 0; i < nout; i++) {
            y.xR[i] = 2.0 * randommid();
         }
         ae_v_move(&xy.xyR[0][nin], 1, y.xR, 1, nout);
      }
      mlpprocess(&network, &x, &y2);
      referencee = 0.0;
      if (nkind != 1) {
         for (i = 0; i < nout; i++) {
            referencee += 0.5 * sqr(y2.xR[i] - y.xR[i]);
         }
      } else {
         for (i = 0; i < nout; i++) {
            if (y.xR[i] != 0.0) {
               if (y2.xR[i] == 0.0) {
                  referencee += y.xR[i] * log(maxrealnumber);
               } else {
                  referencee += y.xR[i] * log(y.xR[i] / y2.xR[i]);
               }
            }
         }
      }
      for (i = 0; i < wcount; i++) {
         wprev = network.weights.xR[i];
         network.weights.xR[i] = wprev + h;
         mlpprocess(&network, &x, &y2);
         network.weights.xR[i] = wprev - h;
         mlpprocess(&network, &x, &y1);
         network.weights.xR[i] = wprev;
         v = 0.0;
         if (nkind != 1) {
            for (j = 0; j < nout; j++) {
               v += 0.5 * (sqr(y2.xR[j] - y.xR[j]) - sqr(y1.xR[j] - y.xR[j])) / (2 * h);
            }
         } else {
            for (j = 0; j < nout; j++) {
               if (y.xR[j] != 0.0) {
                  if (y2.xR[j] == 0.0) {
                     v += y.xR[j] * log(maxrealnumber);
                  } else {
                     v += y.xR[j] * log(y.xR[j] / y2.xR[j]);
                  }
                  if (y1.xR[j] == 0.0) {
                     v -= y.xR[j] * log(maxrealnumber);
                  } else {
                     v -= y.xR[j] * log(y.xR[j] / y1.xR[j]);
                  }
               }
            }
            v /= 2 * h;
         }
         referenceg.xR[i] = v;
      }
      mlpgradn(&network, &x, &y, &e, &grad2);
      seterrorflagdiff(err, e, referencee, etol, escale);
      seterrorflagdiff(err, mlperrorn(&network, &xy, 1), referencee, etol, escale);
      set_error_flag(err, testmlpbaseunit_vectordiff(&referenceg, &grad2, wcount, gscale) > nonstricttolerance, __FILE__, __LINE__, "testmlpbaseunit.ap:1029");
   // Test that gradient calculation functions automatically allocate
   // space for gradient, if needed.
   //
   // NOTE: we perform test with empty dataset.
      sparsecreate(1, nin + nout, 0, &sparsexy);
      sparseconverttocrs(&sparsexy);
      ae_vector_set_length(&grad1, 1);
      mlpgradbatch(&network, &xy, 0, &e1, &grad1);
      set_error_flag(err, grad1.cnt != wcount, __FILE__, __LINE__, "testmlpbaseunit.ap:1042");
      ae_vector_set_length(&grad1, 1);
      mlpgradbatchsparse(&network, &sparsexy, 0, &e1, &grad1);
      set_error_flag(err, grad1.cnt != wcount, __FILE__, __LINE__, "testmlpbaseunit.ap:1045");
      ae_vector_set_length(&grad1, 1);
      mlpgradbatchsubset(&network, &xy, 0, &idx, 0, &e1, &grad1);
      set_error_flag(err, grad1.cnt != wcount, __FILE__, __LINE__, "testmlpbaseunit.ap:1048");
      ae_vector_set_length(&grad1, 1);
      mlpgradbatchsparsesubset(&network, &sparsexy, 0, &idx, 0, &e1, &grad1);
      set_error_flag(err, grad1.cnt != wcount, __FILE__, __LINE__, "testmlpbaseunit.ap:1051");
   // Test MLPError(), MLPErrorSparse(), MLPGradBatch(), MLPGradBatchSparse() for many-element dataset:
   // * generate random dataset XY
   // * calculate "reference" error/gradient using MLPGrad(), which was tested in previous
   //   section and is assumed to work correctly
   // * test results returned by MLPGradBatch/MLPGradBatchSparse against reference ones
   //
   // NOTE: about 10% of tests are performed with zero SSize
      ssize = sizemin + randominteger(sizemax - sizemin + 1);
      ae_matrix_set_length(&xy, imax2(ssize, 1), nin + nout);
      sparsecreate(imax2(ssize, 1), nin + nout, ssize * (nin + nout), &sparsexy);
      for (i = 0; i < wcount; i++) {
         referenceg.xR[i] = 0.0;
      }
      referencee = 0.0;
      for (i = 0; i < ssize; i++) {
         for (j = 0; j < nin; j++) {
            x1.xR[j] = 2.0 * randommid();
            sparseset(&sparsexy, i, j, x1.xR[j]);
         }
         ae_v_move(xy.xyR[i], 1, x1.xR, 1, nin);
         if (mlpissoftmax(&network)) {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 0.0;
            }
            xy.xyR[i][nin] = (double)randominteger(nout);
            sparseset(&sparsexy, i, nin, xy.xyR[i][nin]);
            y1.xR[iround(xy.xyR[i][nin])] = 1.0;
         } else {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 2.0 * randommid();
               sparseset(&sparsexy, i, nin + j, y1.xR[j]);
            }
            ae_v_move(&xy.xyR[i][nin], 1, y1.xR, 1, nout);
         }
         mlpgrad(&network, &x1, &y1, &v, &grad2);
         referencee += v;
         ae_v_add(referenceg.xR, 1, grad2.xR, 1, wcount);
      }
      sparseconverttocrs(&sparsexy);
      e2 = mlperror(&network, &xy, ssize);
      seterrorflagdiff(err, e2, referencee, etol, escale);
      e2 = mlperrorsparse(&network, &sparsexy, ssize);
      seterrorflagdiff(err, e2, referencee, etol, escale);
      mlpgradbatch(&network, &xy, ssize, &e2, &grad2);
      seterrorflagdiff(err, e2, referencee, etol, escale);
      set_error_flag(err, testmlpbaseunit_vectordiff(&referenceg, &grad2, wcount, gscale) > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:1104");
      mlpgradbatchsparse(&network, &sparsexy, ssize, &esp, &gradsp);
      seterrorflagdiff(err, esp, referencee, etol, escale);
      set_error_flag(err, testmlpbaseunit_vectordiff(&referenceg, &gradsp, wcount, gscale) > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:1107");
   // Test MLPErrorSubset(), MLPGradBatchSubset(), MLPErrorSparseSubset(), MLPGradBatchSparseSubset()
   // for many-element dataset with different types of subsets:
   // * generate random dataset XY
   // * "reference" error/gradient are calculated with MLPGradBatch(),
   //   which was tested in previous section and is assumed to work correctly
   // * we perform tests for different subsets:
   //   * SubsetSize<0 - subset is a full dataset
   //   * SubsetSize=0 - subset is empty
   //   * SubsetSize>0 - random subset
      ssize = sizemin + randominteger(sizemax - sizemin + 1);
      ae_matrix_set_length(&xy, imax2(ssize, 1), nin + nout);
      sparsecreate(imax2(ssize, 1), nin + nout, ssize * (nin + nout), &sparsexy);
      for (i = 0; i < ssize; i++) {
         for (j = 0; j < nin; j++) {
            x1.xR[j] = 2.0 * randommid();
            sparseset(&sparsexy, i, j, x1.xR[j]);
         }
         ae_v_move(xy.xyR[i], 1, x1.xR, 1, nin);
         if (mlpissoftmax(&network)) {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 0.0;
            }
            xy.xyR[i][nin] = (double)randominteger(nout);
            sparseset(&sparsexy, i, nin, xy.xyR[i][nin]);
            y1.xR[iround(xy.xyR[i][nin])] = 1.0;
         } else {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 2.0 * randommid();
               sparseset(&sparsexy, i, nin + j, y1.xR[j]);
            }
            ae_v_move(&xy.xyR[i][nin], 1, y1.xR, 1, nout);
         }
      }
      sparseconverttocrs(&sparsexy);
      if (ssize > 0) {
         subsetsize = 1 + randominteger(10);
         ae_matrix_set_length(&xy2, subsetsize, nin + nout);
         ae_vector_set_length(&idx, subsetsize);
         sparsecreate(subsetsize, nin + nout, subsetsize * (nin + nout), &sparsexy2);
         if (mlpissoftmax(&network)) {
            rowsize = nin + 1;
         } else {
            rowsize = nin + nout;
         }
         for (i = 0; i < subsetsize; i++) {
            k = randominteger(ssize);
            idx.xZ[i] = k;
            for (j = 0; j < rowsize; j++) {
               xy2.xyR[i][j] = xy.xyR[k][j];
               sparseset(&sparsexy2, i, j, sparseget(&sparsexy, k, j));
            }
         }
         sparseconverttocrs(&sparsexy2);
      } else {
         subsetsize = 0;
         ae_matrix_set_length(&xy2, 0, 0);
         ae_vector_set_length(&idx, 0);
         sparsecreate(1, nin + nout, 0, &sparsexy2);
         sparseconverttocrs(&sparsexy2);
      }
      mlpgradbatch(&network, &xy, ssize, &referencee, &referenceg);
      e2 = mlperrorsubset(&network, &xy, ssize, &idx, -1);
      esp = mlperrorsparsesubset(&network, &sparsexy, ssize, &idx, -1);
      seterrorflagdiff(err, e2, referencee, etol, escale);
      seterrorflagdiff(err, esp, referencee, etol, escale);
      mlpgradbatchsubset(&network, &xy, ssize, &idx, -1, &e2, &grad2);
      mlpgradbatchsparsesubset(&network, &sparsexy, ssize, &idx, -1, &esp, &gradsp);
      seterrorflagdiff(err, e2, referencee, etol, escale);
      seterrorflagdiff(err, esp, referencee, etol, escale);
      set_error_flag(err, testmlpbaseunit_vectordiff(&referenceg, &grad2, wcount, gscale) > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:1192");
      set_error_flag(err, testmlpbaseunit_vectordiff(&referenceg, &gradsp, wcount, gscale) > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:1193");
      mlpgradbatch(&network, &xy, 0, &referencee, &referenceg);
      e2 = mlperrorsubset(&network, &xy, ssize, &idx, 0);
      esp = mlperrorsparsesubset(&network, &sparsexy, ssize, &idx, 0);
      seterrorflagdiff(err, e2, referencee, etol, escale);
      seterrorflagdiff(err, esp, referencee, etol, escale);
      mlpgradbatchsubset(&network, &xy, ssize, &idx, 0, &e2, &grad2);
      mlpgradbatchsparsesubset(&network, &sparsexy, ssize, &idx, 0, &esp, &gradsp);
      seterrorflagdiff(err, e2, referencee, etol, escale);
      seterrorflagdiff(err, esp, referencee, etol, escale);
      set_error_flag(err, testmlpbaseunit_vectordiff(&referenceg, &grad2, wcount, gscale) > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:1205");
      set_error_flag(err, testmlpbaseunit_vectordiff(&referenceg, &gradsp, wcount, gscale) > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:1206");
      mlpgradbatch(&network, &xy2, subsetsize, &referencee, &referenceg);
      e2 = mlperrorsubset(&network, &xy, ssize, &idx, subsetsize);
      esp = mlperrorsparsesubset(&network, &sparsexy, ssize, &idx, subsetsize);
      seterrorflagdiff(err, e2, referencee, etol, escale);
      seterrorflagdiff(err, esp, referencee, etol, escale);
      mlpgradbatchsubset(&network, &xy, ssize, &idx, subsetsize, &e2, &grad2);
      mlpgradbatchsparsesubset(&network, &sparsexy, ssize, &idx, subsetsize, &esp, &gradsp);
      seterrorflagdiff(err, e2, referencee, etol, escale);
      seterrorflagdiff(err, esp, referencee, etol, escale);
      set_error_flag(err, testmlpbaseunit_vectordiff(&referenceg, &grad2, wcount, gscale) > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:1218");
      set_error_flag(err, testmlpbaseunit_vectordiff(&referenceg, &gradsp, wcount, gscale) > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:1219");
   // Test MLPGradNBatch() for many-element dataset:
   // * generate random dataset XY
   // * calculate "reference" error/gradient using MLPGrad(), which was tested in previous
   //   section and is assumed to work correctly
   // * test results returned by MLPGradNBatch against reference ones
      ssize = sizemin + randominteger(sizemax - sizemin + 1);
      ae_matrix_set_length(&xy, ssize, nin + nout);
      for (i = 0; i < wcount; i++) {
         referenceg.xR[i] = 0.0;
      }
      referencee = 0.0;
      for (i = 0; i < ssize; i++) {
         for (j = 0; j < nin; j++) {
            x1.xR[j] = 2.0 * randommid();
         }
         ae_v_move(xy.xyR[i], 1, x1.xR, 1, nin);
         if (mlpissoftmax(&network)) {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 0.0;
            }
            xy.xyR[i][nin] = (double)randominteger(nout);
            y1.xR[iround(xy.xyR[i][nin])] = 1.0;
         } else {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 2.0 * randommid();
            }
            ae_v_move(&xy.xyR[i][nin], 1, y1.xR, 1, nout);
         }
         mlpgradn(&network, &x1, &y1, &v, &grad2);
         referencee += v;
         ae_v_add(referenceg.xR, 1, grad2.xR, 1, wcount);
      }
      mlpgradnbatch(&network, &xy, ssize, &e2, &grad2);
      seterrorflagdiff(err, e2, referencee, etol, escale);
      set_error_flag(err, testmlpbaseunit_vectordiff(&referenceg, &grad2, wcount, gscale) > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:1258");
   }
   ae_frame_leave();
}

// Hessian functions test
static void testmlpbaseunit_testhessian(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t passcount, bool *err) {
   ae_frame _frame_block;
   ae_int_t hkind;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t wcount;
   double h;
   double etol;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ssize;
   double a1;
   double a2;
   double v;
   double e1;
   double e2;
   double wprev;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(h1, 0, 0, DT_REAL);
   NewMatrix(h2, 0, 0, DT_REAL);
   NewVector(grad1, 0, DT_REAL);
   NewVector(grad2, 0, DT_REAL);
   NewVector(grad3, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   ae_assert(passcount >= 2, "PassCount<2!");
   a1 = 0.0;
   a2 = 0.0;
   if (nkind == 2) {
      a1 = 500.0 * randommid();
      a2 = randommid();
   }
   if (nkind == 3) {
      a1 = 500.0 * randommid();
      a2 = a1 + (2 * randominteger(2) - 1) * (0.1 + 0.9 * randomreal());
   }
   testmlpbaseunit_createnetwork(&network, nkind, a1, a2, nin, nhid1, nhid2, nout);
   mlpproperties(&network, &n1, &n2, &wcount);
   h = 0.00001;
   etol = 0.05;
// Initialize
   ae_vector_set_length(&x, nin - 1 + 1);
   ae_vector_set_length(&x1, nin - 1 + 1);
   ae_vector_set_length(&x2, nin - 1 + 1);
   ae_vector_set_length(&y, nout - 1 + 1);
   ae_vector_set_length(&y1, nout - 1 + 1);
   ae_vector_set_length(&y2, nout - 1 + 1);
   ae_vector_set_length(&grad1, wcount - 1 + 1);
   ae_vector_set_length(&grad2, wcount - 1 + 1);
   ae_vector_set_length(&grad3, wcount - 1 + 1);
   ae_matrix_set_length(&h1, wcount - 1 + 1, wcount - 1 + 1);
   ae_matrix_set_length(&h2, wcount - 1 + 1, wcount - 1 + 1);
// Process
   for (pass = 1; pass <= passcount; pass++) {
      mlprandomizefull(&network);
   // Test hessian calculation .
   // E1 contains total error (calculated using MLPGrad/MLPGradN)
   // Grad1 contains total gradient (calculated using MLPGrad/MLPGradN)
   // H1 contains Hessian calculated using differences of gradients
   //
   // E2, Grad2 and H2 contains corresponing values calculated using MLPHessianBatch/MLPHessianNBatch
      for (hkind = 0; hkind <= 1; hkind++) {
         ssize = 1 + randominteger(10);
         ae_matrix_set_length(&xy, ssize - 1 + 1, nin + nout - 1 + 1);
         for (i = 0; i < wcount; i++) {
            grad1.xR[i] = 0.0;
         }
         for (i = 0; i < wcount; i++) {
            for (j = 0; j < wcount; j++) {
               h1.xyR[i][j] = 0.0;
            }
         }
         e1 = 0.0;
         for (i = 0; i < ssize; i++) {
         // X, Y
            for (j = 0; j < nin; j++) {
               x1.xR[j] = 2.0 * randommid();
            }
            ae_v_move(xy.xyR[i], 1, x1.xR, 1, nin);
            if (mlpissoftmax(&network)) {
               for (j = 0; j < nout; j++) {
                  y1.xR[j] = 0.0;
               }
               xy.xyR[i][nin] = (double)randominteger(nout);
               y1.xR[iround(xy.xyR[i][nin])] = 1.0;
            } else {
               for (j = 0; j < nout; j++) {
                  y1.xR[j] = 2.0 * randommid();
               }
               ae_v_move(&xy.xyR[i][nin], 1, y1.xR, 1, nout);
            }
         // E1, Grad1
            if (hkind == 0) {
               mlpgrad(&network, &x1, &y1, &v, &grad2);
            } else {
               mlpgradn(&network, &x1, &y1, &v, &grad2);
            }
            e1 += v;
            ae_v_add(grad1.xR, 1, grad2.xR, 1, wcount);
         // H1
            for (j = 0; j < wcount; j++) {
               wprev = network.weights.xR[j];
               network.weights.xR[j] = wprev - 2 * h;
               if (hkind == 0) {
                  mlpgrad(&network, &x1, &y1, &v, &grad2);
               } else {
                  mlpgradn(&network, &x1, &y1, &v, &grad2);
               }
               network.weights.xR[j] = wprev - h;
               if (hkind == 0) {
                  mlpgrad(&network, &x1, &y1, &v, &grad3);
               } else {
                  mlpgradn(&network, &x1, &y1, &v, &grad3);
               }
               ae_v_subd(grad2.xR, 1, grad3.xR, 1, wcount, 8);
               network.weights.xR[j] = wprev + h;
               if (hkind == 0) {
                  mlpgrad(&network, &x1, &y1, &v, &grad3);
               } else {
                  mlpgradn(&network, &x1, &y1, &v, &grad3);
               }
               ae_v_addd(grad2.xR, 1, grad3.xR, 1, wcount, 8);
               network.weights.xR[j] = wprev + 2 * h;
               if (hkind == 0) {
                  mlpgrad(&network, &x1, &y1, &v, &grad3);
               } else {
                  mlpgradn(&network, &x1, &y1, &v, &grad3);
               }
               ae_v_sub(grad2.xR, 1, grad3.xR, 1, wcount);
               v = 1 / (12 * h);
               ae_v_addd(h1.xyR[j], 1, grad2.xR, 1, wcount, v);
               network.weights.xR[j] = wprev;
            }
         }
         if (hkind == 0) {
            mlphessianbatch(&network, &xy, ssize, &e2, &grad2, &h2);
         } else {
            mlphessiannbatch(&network, &xy, ssize, &e2, &grad2, &h2);
         }
         set_error_flag(err, fabs(e1 - e2) / e1 > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:1440");
         for (i = 0; i < wcount; i++) {
            if (fabs(grad1.xR[i]) > 1.0E-2) {
               set_error_flag(err, fabs((grad2.xR[i] - grad1.xR[i]) / grad1.xR[i]) > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:1443");
            } else {
               set_error_flag(err, fabs(grad2.xR[i] - grad1.xR[i]) > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:1445");
            }
         }
         for (i = 0; i < wcount; i++) {
            for (j = 0; j < wcount; j++) {
               if (fabs(h1.xyR[i][j]) > 5.0E-2) {
                  set_error_flag(err, fabs((h1.xyR[i][j] - h2.xyR[i][j]) / h1.xyR[i][j]) > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:1449");
               } else {
                  set_error_flag(err, fabs(h2.xyR[i][j] - h1.xyR[i][j]) > etol, __FILE__, __LINE__, "testmlpbaseunit.ap:1451");
               }
            }
         }
      }
   }
   ae_frame_leave();
}

// Error functions (other than MLPError and MLPErrorN) test.
//
// Network of type NKind is created, with  NIn  inputs,  NHid1*NHid2   hidden
// layers (one layer if NHid2=0), NOut outputs. PassCount  random  passes  is
// performed. Dataset has random size in [SizeMin,SizeMax].
static void testmlpbaseunit_testerr(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t passcount, ae_int_t sizemin, ae_int_t sizemax, bool *err) {
   ae_frame _frame_block;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t wcount;
   double etol;
   double escale;
   double a1;
   double a2;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t ssize;
   ae_int_t subsetsize;
   double refrmserror;
   double refclserror;
   double refrelclserror;
   double refavgce;
   double refavgerror;
   double refavgrelerror;
   ae_int_t avgrelcnt;
   ae_int_t nnmax;
   ae_int_t dsmax;
   double relclstolerance;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewObj(sparsematrix, sparsexy);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(idx, 0, DT_INT);
   NewVector(dummy, 0, DT_INT);
   NewObj(modelerrors, allerrors);
   a1 = 0.0;
   a2 = 0.0;
   if (nkind == 2) {
      a1 = 500.0 * randommid();
      a2 = randommid();
   }
   if (nkind == 3) {
      a1 = 500.0 * randommid();
      a2 = a1 + (2 * randominteger(2) - 1) * (0.1 + 0.9 * randomreal());
   }
   testmlpbaseunit_createnetwork(&network, nkind, a1, a2, nin, nhid1, nhid2, nout);
   mlpproperties(&network, &n1, &n2, &wcount);
   etol = 1.0E-4;
   escale = 1.0E-2;
// Initialize
   ae_vector_set_length(&x1, nin);
   ae_vector_set_length(&y, nout);
   ae_vector_set_length(&y1, nout);
// Process
   for (pass = 1; pass <= passcount; pass++) {
   // Randomize network, then re-randomaze weights manually.
   //
   // NOTE: weights magnitude is chosen to be small, about 0.1,
   //       which allows us to avoid oversaturated network.
   //       In 10% of cases we use zero weights.
      mlprandomizefull(&network);
      if (randombool(0.1)) {
         for (i = 0; i < wcount; i++) {
            network.weights.xR[i] = 0.0;
         }
      } else {
         for (i = 0; i < wcount; i++) {
            network.weights.xR[i] = 0.1 * randommid();
         }
      }
   // Generate random dataset.
   // Calculate reference errors.
   //
   // NOTE: about 10% of tests are performed with zero SSize
      ssize = sizemin + randominteger(sizemax - sizemin + 1);
      if (mlpissoftmax(&network)) {
         ae_matrix_set_length(&xy, imax2(ssize, 1), nin + 1);
         sparsecreate(imax2(ssize, 1), nin + 1, 0, &sparsexy);
      } else {
         ae_matrix_set_length(&xy, imax2(ssize, 1), nin + nout);
         sparsecreate(imax2(ssize, 1), nin + nout, 0, &sparsexy);
      }
      refrmserror = 0.0;
      refclserror = 0.0;
      refavgce = 0.0;
      refavgerror = 0.0;
      refavgrelerror = 0.0;
      avgrelcnt = 0;
      for (i = 0; i < ssize; i++) {
      // Fill I-th row
         for (j = 0; j < nin; j++) {
            x1.xR[j] = 2.0 * randommid();
            sparseset(&sparsexy, i, j, x1.xR[j]);
         }
         ae_v_move(xy.xyR[i], 1, x1.xR, 1, nin);
         if (mlpissoftmax(&network)) {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 0.0;
            }
            xy.xyR[i][nin] = (double)randominteger(nout);
            sparseset(&sparsexy, i, nin, xy.xyR[i][nin]);
            y1.xR[iround(xy.xyR[i][nin])] = 1.0;
         } else {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 2.0 * randommid();
               if (y1.xR[j] >= 0.0) {
                  y1.xR[j] += 0.1;
               } else {
                  y1.xR[j] -= 0.1;
               }
               sparseset(&sparsexy, i, nin + j, y1.xR[j]);
            }
            ae_v_move(&xy.xyR[i][nin], 1, y1.xR, 1, nout);
         }
      // Process
         mlpprocess(&network, &x1, &y);
      // Update reference errors
         nnmax = 0;
         if (mlpissoftmax(&network)) {
            if (y.xR[iround(xy.xyR[i][nin])] > 0.0) {
               refavgce += log(1 / y.xR[iround(xy.xyR[i][nin])]);
            } else {
               refavgce += log(maxrealnumber);
            }
         }
         if (mlpissoftmax(&network)) {
            dsmax = iround(xy.xyR[i][nin]);
         } else {
            dsmax = 0;
         }
         for (j = 0; j < nout; j++) {
            refrmserror += sqr(y.xR[j] - y1.xR[j]);
            refavgerror += fabs(y.xR[j] - y1.xR[j]);
            if (y1.xR[j] != 0.0) {
               refavgrelerror += fabs(y.xR[j] - y1.xR[j]) / fabs(y1.xR[j]);
               avgrelcnt++;
            }
            if (y.xR[j] > y.xR[nnmax]) {
               nnmax = j;
            }
            if (!mlpissoftmax(&network) && y1.xR[j] > y1.xR[dsmax]) {
               dsmax = j;
            }
         }
         if (nnmax != dsmax) {
            refclserror++;
         }
      }
      sparseconverttocrs(&sparsexy);
      if (ssize > 0) {
         refrmserror = sqrt(refrmserror / (ssize * nout));
         refavgerror /= ssize * nout;
         refrelclserror = refclserror / ssize;
         refavgce /= ssize * log(2.0);
      } else {
         refrelclserror = 0.0;
      }
      if (avgrelcnt > 0) {
         refavgrelerror /= avgrelcnt;
      }
   // Test "continuous" errors on full dataset
      seterrorflagdiff(err, mlprmserror(&network, &xy, ssize), refrmserror, etol, escale);
      seterrorflagdiff(err, mlpavgce(&network, &xy, ssize), refavgce, etol, escale);
      seterrorflagdiff(err, mlpavgerror(&network, &xy, ssize), refavgerror, etol, escale);
      seterrorflagdiff(err, mlpavgrelerror(&network, &xy, ssize), refavgrelerror, etol, escale);
      seterrorflagdiff(err, mlprmserrorsparse(&network, &sparsexy, ssize), refrmserror, etol, escale);
      seterrorflagdiff(err, mlpavgcesparse(&network, &sparsexy, ssize), refavgce, etol, escale);
      seterrorflagdiff(err, mlpavgerrorsparse(&network, &sparsexy, ssize), refavgerror, etol, escale);
      seterrorflagdiff(err, mlpavgrelerrorsparse(&network, &sparsexy, ssize), refavgrelerror, etol, escale);
      mlpallerrorssubset(&network, &xy, ssize, &dummy, -1, &allerrors);
      seterrorflagdiff(err, allerrors.avgce, refavgce, etol, escale);
      seterrorflagdiff(err, allerrors.rmserror, refrmserror, etol, escale);
      seterrorflagdiff(err, allerrors.avgerror, refavgerror, etol, escale);
      seterrorflagdiff(err, allerrors.avgrelerror, refavgrelerror, etol, escale);
      mlpallerrorssparsesubset(&network, &sparsexy, ssize, &dummy, -1, &allerrors);
      seterrorflagdiff(err, allerrors.avgce, refavgce, etol, escale);
      seterrorflagdiff(err, allerrors.rmserror, refrmserror, etol, escale);
      seterrorflagdiff(err, allerrors.avgerror, refavgerror, etol, escale);
      seterrorflagdiff(err, allerrors.avgrelerror, refavgrelerror, etol, escale);
   // Test errors on dataset given by subset.
   // We perform only limited test for RMS error, assuming that either all errors
   // are calculated correctly (subject to subset given by Idx) - or none of them.
      if (ssize > 0) {
         subsetsize = randominteger(10);
      } else {
         subsetsize = 0;
      }
      ae_vector_set_length(&idx, subsetsize);
      refrmserror = 0.0;
      for (i = 0; i < subsetsize; i++) {
         k = randominteger(ssize);
         idx.xZ[i] = k;
         ae_v_move(x1.xR, 1, xy.xyR[k], 1, nin);
         if (mlpissoftmax(&network)) {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 0.0;
            }
            y1.xR[iround(xy.xyR[k][nin])] = 1.0;
         } else {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = xy.xyR[k][nin + j];
            }
         }
         mlpprocess(&network, &x1, &y);
         for (j = 0; j < nout; j++) {
            refrmserror += sqr(y.xR[j] - y1.xR[j]);
         }
      }
      if (subsetsize > 0) {
         refrmserror = sqrt(refrmserror / (subsetsize * nout));
      }
      mlpallerrorssubset(&network, &xy, ssize, &idx, subsetsize, &allerrors);
      seterrorflagdiff(err, allerrors.rmserror, refrmserror, etol, escale);
      mlpallerrorssparsesubset(&network, &sparsexy, ssize, &idx, subsetsize, &allerrors);
      seterrorflagdiff(err, allerrors.rmserror, refrmserror, etol, escale);
   // Test "discontinuous" error function.
   // Even slight changes in the network output may force these functions
   // to change by 1. So, we test them with relaxed criteria, corresponding to
   // difference in classification of two samples.
      if (ssize > 0) {
         relclstolerance = 2.5 / ssize;
         set_error_flag(err, fabs(mlpclserror(&network, &xy, ssize) - refclserror) > ssize * relclstolerance, __FILE__, __LINE__, "testmlpbaseunit.ap:1732");
         set_error_flag(err, fabs(mlprelclserror(&network, &xy, ssize) - refrelclserror) > relclstolerance, __FILE__, __LINE__, "testmlpbaseunit.ap:1733");
         set_error_flag(err, fabs(mlprelclserrorsparse(&network, &sparsexy, ssize) - refrelclserror) > relclstolerance, __FILE__, __LINE__, "testmlpbaseunit.ap:1734");
      }
   }
   ae_frame_leave();
}

// Special tests
static void testmlpbaseunit_spectests(bool *inferrors, bool *procerrors, bool *graderrors, bool *hesserrors, bool *errerrors) {
   ae_frame _frame_block;
   double f;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(g, 0, DT_REAL);
// Special test for overflow in TanH:
// * create 1x1x1 linear network
// * create dataset with 1 item: [x, y] = [0, 1]
// * set network weights to [10000000, 10000000, 10000000, 10000000]
// * check that error function is finite
// * check that gradient is finite
   mlpcreate1(1, 1, 1, &net);
   ae_matrix_set_length(&xy, 1, 2);
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = 1.0;
   for (i = 0; i < mlpgetweightscount(&net); i++) {
      net.weights.xR[i] = 10000000.0;
   }
   mlpgradbatch(&net, &xy, 1, &f, &g);
   set_error_flag(graderrors, !isfinite(f), __FILE__, __LINE__, "testmlpbaseunit.ap:1907");
   set_error_flag(graderrors, !isfinite(mlperror(&net, &xy, 1)), __FILE__, __LINE__, "testmlpbaseunit.ap:1908");
   for (i = 0; i < mlpgetweightscount(&net); i++) {
      set_error_flag(graderrors, !isfinite(g.xR[i]), __FILE__, __LINE__, "testmlpbaseunit.ap:1910");
   }
// Special test for overflow in SOFTMAX layer:
// * create 1x1x2 classifier network
// * create dataset with 1 item: [x, y] = [0, 1]
// * set network weights to [10000000, 10000000, 10000000, 10000000]
// * check that error function is finite
// * check that gradient is finite
   mlpcreatec1(1, 1, 2, &net);
   ae_matrix_set_length(&xy, 1, 2);
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = 1.0;
   for (i = 0; i < mlpgetweightscount(&net); i++) {
      net.weights.xR[i] = 10000000.0;
   }
   mlpgradbatch(&net, &xy, 1, &f, &g);
   set_error_flag(graderrors, !isfinite(f), __FILE__, __LINE__, "testmlpbaseunit.ap:1928");
   set_error_flag(graderrors, !isfinite(mlperror(&net, &xy, 1)), __FILE__, __LINE__, "testmlpbaseunit.ap:1929");
   for (i = 0; i < mlpgetweightscount(&net); i++) {
      set_error_flag(graderrors, !isfinite(g.xR[i]), __FILE__, __LINE__, "testmlpbaseunit.ap:1931");
   }
   ae_frame_leave();
}

// The function test functions MLPGradBatchMasked and MLPGradBatchSparseMasked.
static bool testmlpbaseunit_testmlpgbsubset() {
   ae_frame _frame_block;
   double e1;
   double e2;
   ae_int_t nin;
   ae_int_t nout;
   ae_int_t w;
   ae_int_t wcount;
   ae_int_t nhid1;
   ae_int_t nhid2;
   ae_int_t nkind;
   double a1;
   double a2;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t ssize;
   ae_int_t maxssize;
   ae_int_t sbsize;
   ae_int_t nvar;
   ae_int_t variant;
   ae_int_t i;
   ae_int_t j;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(parta, 0, 0, DT_REAL);
   NewObj(sparsematrix, sa);
   NewObj(sparsematrix, partsa);
   NewVector(idx, 0, DT_INT);
   NewVector(grad1, 0, DT_REAL);
   NewVector(grad2, 0, DT_REAL);
// Variant:
//  * 1 - there are all rows;
//  * 2 - there are no one rows;
//  * 3 - there are some random rows.
   nvar = 3;
   maxssize = 96;
   for (ssize = 0; ssize <= maxssize; ssize++) {
      ae_vector_set_length(&idx, ssize);
      nkind = randominteger(4);
      a1 = 0.0;
      a2 = 0.0;
      if (nkind == 2) {
         a1 = 500.0 * randommid();
         a2 = randommid();
      }
      if (nkind == 3) {
         a1 = 500.0 * randommid();
         a2 = a1 + (2 * randominteger(2) - 1) * (0.1 + 0.9 * randomreal());
      }
      nin = randominteger(20) + 1;
      nhid1 = randominteger(5);
      if (nhid1 == 0) {
         nhid2 = 0;
      } else {
         nhid2 = randominteger(5);
      }
      nout = randominteger(20) + 2;
      testmlpbaseunit_createnetwork(&net, nkind, a1, a2, nin, nhid1, nhid2, nout);
      mlpproperties(&net, &n1, &n2, &wcount);
      if (mlpissoftmax(&net)) {
         w = nin + 1;
         if (ssize > 0) {
            ae_matrix_set_length(&a, ssize, w);
            sparsecreate(ssize, w, ssize * w, &sa);
         } else {
            ae_matrix_set_length(&a, 0, 0);
            sparsecreate(1, 1, 0, &sa);
         }
         for (i = 0; i < ssize; i++) {
            for (j = 0; j < w; j++) {
               a.xyR[i][j] = randommid();
               sparseset(&sa, i, j, a.xyR[i][j]);
            }
         }
         for (i = 0; i < ssize; i++) {
            a.xyR[i][nin] = (double)randominteger(nout);
            sparseset(&sa, i, nin, a.xyR[i][nin]);
         }
      } else {
         w = nin + nout;
         if (ssize > 0) {
            ae_matrix_set_length(&a, ssize, w);
            sparsecreate(ssize, w, ssize * w, &sa);
         } else {
            ae_matrix_set_length(&a, 0, 0);
            sparsecreate(1, 1, 0, &sa);
         }
         for (i = 0; i < ssize; i++) {
            for (j = 0; j < w; j++) {
               a.xyR[i][j] = randommid();
               sparseset(&sa, i, j, a.xyR[i][j]);
            }
         }
      }
      sparseconverttocrs(&sa);
      for (variant = 1; variant <= nvar; variant++) {
         sbsize = -1;
         if (variant == 1) {
            sbsize = ssize;
            for (i = 0; i < sbsize; i++) {
               idx.xZ[i] = i;
            }
         }
         if (variant == 2) {
            sbsize = 0;
         }
         if (variant == 3) {
            if (ssize == 0) {
               sbsize = 0;
            } else {
               sbsize = randominteger(ssize);
            }
            for (i = 0; i < sbsize; i++) {
               idx.xZ[i] = randominteger(ssize);
            }
         }
         ae_assert(sbsize >= 0, "mlpbase test: integrity check failed");
         if (sbsize != 0) {
            ae_matrix_set_length(&parta, sbsize, w);
            sparsecreate(sbsize, w, sbsize * w, &partsa);
         } else {
            ae_matrix_set_length(&parta, 0, 0);
            sparsecreate(1, 1, 0, &partsa);
         }
         for (i = 0; i < sbsize; i++) {
            ae_v_move(parta.xyR[i], 1, a.xyR[idx.xZ[i]], 1, w);
            for (j = 0; j < w; j++) {
               sparseset(&partsa, i, j, parta.xyR[i][j]);
            }
         }
         sparseconverttocrs(&partsa);
         mlpgradbatch(&net, &parta, sbsize, &e1, &grad1);
         mlpgradbatchsubset(&net, &a, ssize, &idx, sbsize, &e2, &grad2);
      // Test for dense matrix
         if (fabs(e1 - e2) > 1.0E-6) {
            result = true;
            ae_frame_leave();
            return result;
         }
         for (i = 0; i < wcount; i++) {
            if (fabs(grad1.xR[i] - grad2.xR[i]) > 1.0E-6) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      // Test for sparse matrix
         mlpgradbatchsparse(&net, &partsa, sbsize, &e1, &grad1);
         mlpgradbatchsparsesubset(&net, &sa, ssize, &idx, sbsize, &e2, &grad2);
         if (fabs(e1 - e2) > 1.0E-6) {
            result = true;
            ae_frame_leave();
            return result;
         }
         for (i = 0; i < wcount; i++) {
            if (fabs(grad1.xR[i] - grad2.xR[i]) > 1.0E-6) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

bool testmlpbase(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   ae_int_t passcount;
   ae_int_t maxn;
   ae_int_t maxhid;
   ae_int_t sizemin;
   ae_int_t sizemax;
   ae_int_t nf;
   ae_int_t nl;
   ae_int_t nhid1;
   ae_int_t nhid2;
   ae_int_t nkind;
   bool inferrors;
   bool procerrors;
   bool graderrors;
   bool hesserrors;
   bool errerrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewObj(multilayerperceptron, network2);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(valxy, 0, 0, DT_REAL);
   waserrors = false;
   inferrors = false;
   procerrors = false;
   graderrors = false;
   hesserrors = false;
   errerrors = false;
   passcount = 5;
   maxn = 3;
   maxhid = 3;
// Special tests
   testmlpbaseunit_spectests(&inferrors, &procerrors, &graderrors, &hesserrors, &errerrors);
// General multilayer network tests.
// These tests are performed with small dataset, whose size is in [0,10].
// We test correctness of functions on small sets, but do not test code
// which splits large dataset into smaller chunks.
   sizemin = 0;
   sizemax = 10;
   for (nf = 1; nf <= maxn; nf++) {
      for (nl = 1; nl <= maxn; nl++) {
         for (nhid1 = 0; nhid1 <= maxhid; nhid1++) {
            for (nhid2 = 0; nhid2 <= maxhid; nhid2++) {
               for (nkind = 0; nkind <= 3; nkind++) {
               //  Skip meaningless parameters combinations
                  if (nkind == 1 && nl < 2) {
                     continue;
                  }
                  if (nhid1 == 0 && nhid2 != 0) {
                     continue;
                  }
               // Tests
                  testmlpbaseunit_testinformational(nkind, nf, nhid1, nhid2, nl, passcount, &inferrors);
                  testmlpbaseunit_testprocessing(nkind, nf, nhid1, nhid2, nl, passcount, &procerrors);
                  testmlpbaseunit_testgradient(nkind, nf, nhid1, nhid2, nl, passcount, sizemin, sizemax, &graderrors);
                  testmlpbaseunit_testhessian(nkind, nf, nhid1, nhid2, nl, passcount, &hesserrors);
                  testmlpbaseunit_testerr(nkind, nf, nhid1, nhid2, nl, passcount, sizemin, sizemax, &errerrors);
               }
            }
         }
      }
   }
// Special tests on large datasets: test ability to correctly split
// work into smaller chunks.
   nf = 2;
   nhid1 = 20;
   nhid2 = 20;
   nl = 2;
   sizemin = 50000;
   sizemax = 50000;
   testmlpbaseunit_testerr(0, nf, nhid1, nhid2, nl, 1, sizemin, sizemax, &errerrors);
   testmlpbaseunit_testgradient(0, nf, nhid1, nhid2, nl, 1, sizemin, sizemax, &graderrors);
// Test for MLPGradBatch____Subset()
   graderrors = graderrors || testmlpbaseunit_testmlpgbsubset();
// Final report
   waserrors = (((inferrors || procerrors) || graderrors) || hesserrors) || errerrors;
   if (!silent) {
      printf("MLP TEST\n");
      printf("INFORMATIONAL FUNCTIONS:                 ");
      if (!inferrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("BASIC PROCESSING:                        ");
      if (!procerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("GRADIENT CALCULATION:                    ");
      if (!graderrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("HESSIAN CALCULATION:                     ");
      if (!hesserrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("ERROR FUNCTIONS:                         ");
      if (!errerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST SUMMARY: FAILED\n");
      } else {
         printf("TEST SUMMARY: PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === mlpe testing unit ===
// Network creation
static void testmlpeunit_createensemble(mlpensemble *ensemble, ae_int_t nkind, double a1, double a2, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t ec) {
   ae_assert(((nin > 0 && nhid1 >= 0) && nhid2 >= 0) && nout > 0, "CreateNetwork error");
   ae_assert(nhid1 != 0 || nhid2 == 0, "CreateNetwork error");
   ae_assert(nkind != 1 || nout >= 2, "CreateNetwork error");
   if (nhid1 == 0) {
   // No hidden layers
      if (nkind == 0) {
         mlpecreate0(nin, nout, ec, ensemble);
      } else {
         if (nkind == 1) {
            mlpecreatec0(nin, nout, ec, ensemble);
         } else {
            if (nkind == 2) {
               mlpecreateb0(nin, nout, a1, a2, ec, ensemble);
            } else {
               if (nkind == 3) {
                  mlpecreater0(nin, nout, a1, a2, ec, ensemble);
               }
            }
         }
      }
      return;
   }
   if (nhid2 == 0) {
   // One hidden layer
      if (nkind == 0) {
         mlpecreate1(nin, nhid1, nout, ec, ensemble);
      } else {
         if (nkind == 1) {
            mlpecreatec1(nin, nhid1, nout, ec, ensemble);
         } else {
            if (nkind == 2) {
               mlpecreateb1(nin, nhid1, nout, a1, a2, ec, ensemble);
            } else {
               if (nkind == 3) {
                  mlpecreater1(nin, nhid1, nout, a1, a2, ec, ensemble);
               }
            }
         }
      }
      return;
   }
// Two hidden layers
   if (nkind == 0) {
      mlpecreate2(nin, nhid1, nhid2, nout, ec, ensemble);
   } else {
      if (nkind == 1) {
         mlpecreatec2(nin, nhid1, nhid2, nout, ec, ensemble);
      } else {
         if (nkind == 2) {
            mlpecreateb2(nin, nhid1, nhid2, nout, a1, a2, ec, ensemble);
         } else {
            if (nkind == 3) {
               mlpecreater2(nin, nhid1, nhid2, nout, a1, a2, ec, ensemble);
            }
         }
      }
   }
}

// Unsets network (initialize it to smallest network possible
static void testmlpeunit_unsetensemble(mlpensemble *ensemble) {
   mlpecreate0(1, 1, 1, ensemble);
}

// Iformational functions test
static void testmlpeunit_testinformational(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t ec, ae_int_t passcount, bool *err) {
   ae_frame _frame_block;
   ae_int_t n1;
   ae_int_t n2;
   ae_frame_make(&_frame_block);
   NewObj(mlpensemble, ensemble);
   testmlpeunit_createensemble(&ensemble, nkind, -1.0, 1.0, nin, nhid1, nhid2, nout, ec);
   mlpeproperties(&ensemble, &n1, &n2);
   *err = (*err || n1 != nin) || n2 != nout;
   ae_frame_leave();
}

// Processing functions test
static void testmlpeunit_testprocessing(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t ec, ae_int_t passcount, bool *err) {
   ae_frame _frame_block;
   double a1;
   double a2;
   ae_int_t pass;
   ae_int_t rkind;
   ae_int_t i;
   bool allsame;
   double v;
   ae_frame_make(&_frame_block);
   NewObj(mlpensemble, ensemble);
   NewObj(mlpensemble, ensemble2);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(ra, 0, DT_REAL);
   NewVector(ra2, 0, DT_REAL);
// Prepare network
   a1 = 0.0;
   a2 = 0.0;
   if (nkind == 2) {
      a1 = 500.0 * randommid();
      a2 = randommid();
   }
   if (nkind == 3) {
      a1 = 500.0 * randommid();
      a2 = a1 + (2 * randominteger(2) - 1) * (0.1 + 0.9 * randomreal());
   }
// Initialize arrays
   ae_vector_set_length(&x1, nin - 1 + 1);
   ae_vector_set_length(&x2, nin - 1 + 1);
   ae_vector_set_length(&y1, nout - 1 + 1);
   ae_vector_set_length(&y2, nout - 1 + 1);
// Main cycle:
// * Pass is a number of repeated test
// * RKind is a "replication kind":
//   * RKind=0 means that we work with original ensemble
//   * RKind=1 means that we work with replica created with MLPECopy()
//   * RKind=2 means that we work with replica created with serialization/unserialization
   for (pass = 1; pass <= passcount; pass++) {
      for (rkind = 0; rkind <= 2; rkind++) {
      // Create network, pass through replication in order to test that replicated network works correctly.
         testmlpeunit_createensemble(&ensemble, nkind, a1, a2, nin, nhid1, nhid2, nout, ec);
         if (rkind == 1) {
            mlpecopy(&ensemble, &ensemble2);
            testmlpeunit_unsetensemble(&ensemble);
            mlpecopy(&ensemble2, &ensemble);
            testmlpeunit_unsetensemble(&ensemble2);
         }
         if (rkind == 2) {
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_int_t _local_ssize;
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               mlpealloc(&_local_serializer, &ensemble);
               _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpeserialize(&_local_serializer, &ensemble);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpeunserialize(&_local_serializer, &ensemble2);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
            testmlpeunit_unsetensemble(&ensemble);
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_int_t _local_ssize;
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               mlpealloc(&_local_serializer, &ensemble2);
               _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpeserialize(&_local_serializer, &ensemble2);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               mlpeunserialize(&_local_serializer, &ensemble);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
            testmlpeunit_unsetensemble(&ensemble2);
         }
      // Same inputs leads to same outputs
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = x1.xR[i];
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = randommid();
         }
         mlpeprocess(&ensemble, &x1, &y1);
         mlpeprocess(&ensemble, &x2, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         *err = *err || !allsame;
      // Same inputs on original network leads to same outputs
      // on copy created using MLPCopy
         testmlpeunit_unsetensemble(&ensemble2);
         mlpecopy(&ensemble, &ensemble2);
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = x1.xR[i];
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = randommid();
         }
         mlpeprocess(&ensemble, &x1, &y1);
         mlpeprocess(&ensemble2, &x2, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         *err = *err || !allsame;
      // Same inputs on original network leads to same outputs
      // on copy created using MLPSerialize
         {
         // This code passes data structure through serializers
         // (serializes it to string and loads back)
            ae_int_t _local_ssize;
            ae_frame _local_frame_block;
            ae_frame_make(&_local_frame_block);
            NewSerializer(_local_serializer);
            ae_serializer_alloc_start(&_local_serializer);
            mlpealloc(&_local_serializer, &ensemble);
            _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
            NewBlock(_local_dynamic_block, _local_ssize + 1);
            ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            mlpeserialize(&_local_serializer, &ensemble);
            ae_serializer_stop(&_local_serializer);
            ae_serializer_init(&_local_serializer);
            ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
            mlpeunserialize(&_local_serializer, &ensemble2);
            ae_serializer_stop(&_local_serializer);
            ae_frame_leave();
         }
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = x1.xR[i];
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = randommid();
         }
         mlpeprocess(&ensemble, &x1, &y1);
         mlpeprocess(&ensemble2, &x2, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         *err = *err || !allsame;
      // Different inputs leads to different outputs (non-zero network)
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = randommid();
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = y1.xR[i];
         }
         mlpeprocess(&ensemble, &x1, &y1);
         mlpeprocess(&ensemble, &x2, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         *err = *err || allsame;
      // Randomization changes outputs (when inputs are unchanged, non-zero network)
         for (i = 0; i < nin; i++) {
            x1.xR[i] = randommid();
            x2.xR[i] = randommid();
         }
         for (i = 0; i < nout; i++) {
            y1.xR[i] = randommid();
            y2.xR[i] = y1.xR[i];
         }
         mlpecopy(&ensemble, &ensemble2);
         mlperandomize(&ensemble2);
         mlpeprocess(&ensemble, &x1, &y1);
         mlpeprocess(&ensemble2, &x1, &y2);
         allsame = true;
         for (i = 0; i < nout; i++) {
            allsame = allsame && y1.xR[i] == y2.xR[i];
         }
         *err = *err || allsame;
      // Normalization properties
         if (nkind == 1) {
         // Classifier network outputs are normalized
            for (i = 0; i < nin; i++) {
               x1.xR[i] = randommid();
            }
            mlpeprocess(&ensemble, &x1, &y1);
            v = 0.0;
            for (i = 0; i < nout; i++) {
               v += y1.xR[i];
               *err = *err || y1.xR[i] < 0.0;
            }
            *err = *err || fabs(v - 1) > 1000 * machineepsilon;
         }
         if (nkind == 2) {
         // B-type network outputs are bounded from above/below
            for (i = 0; i < nin; i++) {
               x1.xR[i] = randommid();
            }
            mlpeprocess(&ensemble, &x1, &y1);
            for (i = 0; i < nout; i++) {
               if (a2 >= 0.0) {
                  *err = *err || y1.xR[i] < a1;
               } else {
                  *err = *err || y1.xR[i] > a1;
               }
            }
         }
         if (nkind == 3) {
         // R-type network outputs are within [A1,A2] (or [A2,A1])
            for (i = 0; i < nin; i++) {
               x1.xR[i] = randommid();
            }
            mlpeprocess(&ensemble, &x1, &y1);
            for (i = 0; i < nout; i++) {
               *err = (*err || y1.xR[i] < rmin2(a1, a2)) || y1.xR[i] > rmax2(a1, a2);
            }
         }
      }
   }
   ae_frame_leave();
}

// Error functions
//
// Ensemble of type NKind is created, with  NIn  inputs,  NHid1*NHid2  hidden
// layers (one layer if NHid2=0), NOut outputs. PassCount  random  passes  is
// performed. Dataset has random size in [SizeMin,SizeMax].
static void testmlpeunit_testerr(ae_int_t nkind, ae_int_t nin, ae_int_t nhid1, ae_int_t nhid2, ae_int_t nout, ae_int_t ec, ae_int_t passcount, ae_int_t sizemin, ae_int_t sizemax, bool *err) {
   ae_frame _frame_block;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t wcount;
   double etol;
   double escale;
   double a1;
   double a2;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ssize;
   double refrmserror;
   double refclserror;
   double refavgce;
   double refavgerror;
   double refavgrelerror;
   ae_int_t avgrelcnt;
   ae_int_t nnmax;
   ae_int_t dsmax;
   ae_frame_make(&_frame_block);
   NewObj(mlpensemble, ensemble);
   NewObj(sparsematrix, sparsexy);
   NewObj(sparsematrix, sparsexy2);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(idx, 0, DT_INT);
   NewVector(dummy, 0, DT_INT);
   NewObj(modelerrors, allerrors);
   a1 = 0.0;
   a2 = 0.0;
   if (nkind == 2) {
      a1 = 500.0 * randommid();
      a2 = randommid();
   }
   if (nkind == 3) {
      a1 = 500.0 * randommid();
      a2 = a1 + (2 * randominteger(2) - 1) * (0.1 + 0.9 * randomreal());
   }
   testmlpeunit_createensemble(&ensemble, nkind, a1, a2, nin, nhid1, nhid2, nout, ec);
   mlpproperties(&ensemble.network, &n1, &n2, &wcount);
   etol = 1.0E-4;
   escale = 1.0E-2;
// Initialize
   ae_vector_set_length(&x1, nin);
   ae_vector_set_length(&y, nout);
   ae_vector_set_length(&y1, nout);
// Process
   for (pass = 1; pass <= passcount; pass++) {
   // Randomize Ensemble, then re-randomaze weights manually.
   //
   // NOTE: weights magnitude is chosen to be small, about 0.1,
   //       which allows us to avoid oversaturated Ensemble.
   //       In 10% of cases we use zero weights.
      mlperandomize(&ensemble);
      if (randombool(0.1)) {
         for (i = 0; i < wcount * ec; i++) {
            ensemble.weights.xR[i] = 0.0;
         }
      } else {
         for (i = 0; i < wcount * ec; i++) {
            ensemble.weights.xR[i] = 0.1 * randommid();
         }
      }
   // Generate random dataset.
   // Calculate reference errors.
   //
   // NOTE: about 10% of tests are performed with zero SSize
      ssize = sizemin + randominteger(sizemax - sizemin + 1);
      if (mlpeissoftmax(&ensemble)) {
         ae_matrix_set_length(&xy, imax2(ssize, 1), nin + 1);
         sparsecreate(imax2(ssize, 1), nin + 1, 0, &sparsexy);
      } else {
         ae_matrix_set_length(&xy, imax2(ssize, 1), nin + nout);
         sparsecreate(imax2(ssize, 1), nin + nout, 0, &sparsexy);
      }
      refrmserror = 0.0;
      refclserror = 0.0;
      refavgce = 0.0;
      refavgerror = 0.0;
      refavgrelerror = 0.0;
      avgrelcnt = 0;
      for (i = 0; i < ssize; i++) {
      // Fill I-th row
         for (j = 0; j < nin; j++) {
            x1.xR[j] = 2.0 * randommid();
            sparseset(&sparsexy, i, j, x1.xR[j]);
         }
         ae_v_move(xy.xyR[i], 1, x1.xR, 1, nin);
         if (mlpeissoftmax(&ensemble)) {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 0.0;
            }
            xy.xyR[i][nin] = (double)randominteger(nout);
            sparseset(&sparsexy, i, nin, xy.xyR[i][nin]);
            y1.xR[iround(xy.xyR[i][nin])] = 1.0;
         } else {
            for (j = 0; j < nout; j++) {
               y1.xR[j] = 2.0 * randommid();
               sparseset(&sparsexy, i, nin + j, y1.xR[j]);
            }
            ae_v_move(&xy.xyR[i][nin], 1, y1.xR, 1, nout);
         }
      // Process
         mlpeprocess(&ensemble, &x1, &y);
      // Update reference errors
         nnmax = 0;
         if (mlpeissoftmax(&ensemble)) {
            if (y.xR[iround(xy.xyR[i][nin])] > 0.0) {
               refavgce += log(1 / y.xR[iround(xy.xyR[i][nin])]);
            } else {
               refavgce += log(maxrealnumber);
            }
         }
         if (mlpeissoftmax(&ensemble)) {
            dsmax = iround(xy.xyR[i][nin]);
         } else {
            dsmax = 0;
         }
         for (j = 0; j < nout; j++) {
            refrmserror += sqr(y.xR[j] - y1.xR[j]);
            refavgerror += fabs(y.xR[j] - y1.xR[j]);
            if (y1.xR[j] != 0.0) {
               refavgrelerror += fabs(y.xR[j] - y1.xR[j]) / fabs(y1.xR[j]);
               avgrelcnt++;
            }
            if (y.xR[j] > y.xR[nnmax]) {
               nnmax = j;
            }
            if (!mlpeissoftmax(&ensemble) && y1.xR[j] > y1.xR[dsmax]) {
               dsmax = j;
            }
         }
         if (nnmax != dsmax) {
            refclserror++;
         }
      }
      sparseconverttocrs(&sparsexy);
      if (ssize > 0) {
         refrmserror = sqrt(refrmserror / (ssize * nout));
         refavgerror /= ssize * nout;
         refavgce /= ssize * log(2.0);
      }
      if (avgrelcnt > 0) {
         refavgrelerror /= avgrelcnt;
      }
   // Test "continuous" errors on full dataset
      seterrorflagdiff(err, mlpermserror(&ensemble, &xy, ssize), refrmserror, etol, escale);
      seterrorflagdiff(err, mlpeavgce(&ensemble, &xy, ssize), refavgce, etol, escale);
      seterrorflagdiff(err, mlpeavgerror(&ensemble, &xy, ssize), refavgerror, etol, escale);
      seterrorflagdiff(err, mlpeavgrelerror(&ensemble, &xy, ssize), refavgrelerror, etol, escale);
   }
   ae_frame_leave();
}

bool testmlpe(bool silent) {
   bool waserrors;
   bool inferrors;
   bool procerrors;
   bool errerrors;
   ae_int_t passcount;
   ae_int_t maxn;
   ae_int_t maxhid;
   ae_int_t nf;
   ae_int_t nl;
   ae_int_t nhid1;
   ae_int_t nhid2;
   ae_int_t ec;
   ae_int_t nkind;
   ae_int_t sizemin;
   ae_int_t sizemax;
   bool result;
   waserrors = false;
   inferrors = false;
   procerrors = false;
   errerrors = false;
   passcount = 5;
   maxn = 3;
   maxhid = 3;
// General MLP ensembles tests
// These tests are performed with small dataset, whose size is in [0,10].
// We test correctness of functions on small sets, but do not test code
// which splits large dataset into smaller chunks.
   sizemin = 0;
   sizemax = 10;
   for (nf = 1; nf <= maxn; nf++) {
      for (nl = 1; nl <= maxn; nl++) {
         for (nhid1 = 0; nhid1 <= maxhid; nhid1++) {
            for (nhid2 = 0; nhid2 <= maxhid; nhid2++) {
               for (nkind = 0; nkind <= 3; nkind++) {
                  for (ec = 1; ec <= 3; ec++) {
                  //  Skip meaningless parameters combinations
                     if (nkind == 1 && nl < 2) {
                        continue;
                     }
                     if (nhid1 == 0 && nhid2 != 0) {
                        continue;
                     }
                  // Tests
                     testmlpeunit_testinformational(nkind, nf, nhid1, nhid2, nl, ec, passcount, &inferrors);
                     testmlpeunit_testprocessing(nkind, nf, nhid1, nhid2, nl, ec, passcount, &procerrors);
                     testmlpeunit_testerr(nkind, nf, nhid1, nhid2, nl, ec, passcount, sizemin, sizemax, &errerrors);
                  }
               }
            }
         }
      }
   }
// Special tests on large datasets: test ability to correctly split
// work into smaller chunks.
   nf = 2;
   nhid1 = 10;
   nhid2 = 10;
   nl = 2;
   ec = 10;
   sizemin = 1000;
   sizemax = 1000;
   testmlpeunit_testerr(0, nf, nhid1, nhid2, nl, ec, 1, sizemin, sizemax, &errerrors);
// Final report
   waserrors = (inferrors || procerrors) || errerrors;
   if (!silent) {
      printf("MLP ENSEMBLE TEST\n");
      printf("INFORMATIONAL FUNCTIONS:                 ");
      if (!inferrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("BASIC PROCESSING:                        ");
      if (!procerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("ERROR FUNCTIONS:                         ");
      if (!errerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST SUMMARY: FAILED\n");
      } else {
         printf("TEST SUMMARY: PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === clustering testing unit ===
// This function replays merges and checks that:
// * Rep.NPoints, Rep.Z, Rep.PZ and Rep.PM are consistent and correct
// * Rep.MergeDist is consistent with distance between clusters being merged
// * clusters with minimal distance are merged at each step
// * GetKClusters() correctly unpacks clusters for each K
//
// NOTE: this algorithm correctly handle ties, i.e. situations where several
//       pairs  of  clusters  have  same intercluster distance, and we can't
//       unambiguously choose clusters to merge.
//
// Inputs:
//     D           -   distance matrix, array[NPoints,NPoints], full matrix
//                     is given (including both triangles and zeros on the
//                     main diagonal)
//     XY          -   dataset matrix, array[NPoints,NF]
//     NPoints     -   dataset size
//     NF          -   number of features
//     Rep         -   clusterizer report
//     AHCAlgo     -   AHC algorithm:
//                     * 0 - complete linkage
//                     * 1 - single linkage
//                     * 2 - unweighted average linkage
//
// This function returns True on failure, False on success.
static bool testclusteringunit_errorsinmerges(RMatrix *d, RMatrix *xy, ae_int_t npoints, ae_int_t nf, ahcreport *rep, ae_int_t ahcalgo) {
   ae_frame _frame_block;
   bool bflag;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t i0;
   ae_int_t i1;
   ae_int_t c0;
   ae_int_t c1;
   ae_int_t s0;
   ae_int_t s1;
   double v;
   ae_int_t t;
   ae_int_t mergeidx;
   ae_int_t currentelement;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(dm, 0, 0, DT_REAL);
   NewMatrix(cm, 0, 0, DT_INT);
   NewVector(clustersizes, 0, DT_INT);
   NewVector(clusterheights, 0, DT_INT);
   NewVector(b, 0, DT_BOOL);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(kidx, 0, DT_INT);
   NewVector(kidxz, 0, DT_INT);
   ae_assert(ahcalgo != 3, "integrity error");
   result = false;
   ae_vector_set_length(&x0, nf);
   ae_vector_set_length(&x1, nf);
// Basic checks:
// * positive completion code
// * sizes of arrays
// * Rep.P is correct permutation
// * Rep.Z contains correct cluster indexes
// * Rep.PZ is consistent with Rep.P/Rep.Z
// * Rep.PM contains consistent indexes
// * GetKClusters() for K=NPoints
   bflag = false;
   bflag = bflag || rep->terminationtype <= 0;
   if (bflag) {
      result = true;
      ae_frame_leave();
      return result;
   }
   bflag = bflag || rep->npoints != npoints;
   bflag = (bflag || rep->z.rows != npoints - 1) || (npoints > 1 && rep->z.cols != 2);
   bflag = (bflag || rep->pz.rows != npoints - 1) || (npoints > 1 && rep->pz.cols != 2);
   bflag = (bflag || rep->pm.rows != npoints - 1) || (npoints > 1 && rep->pm.cols != 6);
   bflag = bflag || rep->mergedist.cnt != npoints - 1;
   bflag = bflag || rep->p.cnt != npoints;
   if (bflag) {
      result = true;
      ae_frame_leave();
      return result;
   }
   ae_vector_set_length(&b, npoints);
   for (i = 0; i < npoints; i++) {
      b.xB[i] = false;
   }
   for (i = 0; i < npoints; i++) {
      if ((rep->p.xZ[i] < 0 || rep->p.xZ[i] >= npoints) || b.xB[rep->p.xZ[i]]) {
         result = true;
         ae_frame_leave();
         return result;
      }
      b.xB[rep->p.xZ[i]] = true;
   }
   for (i = 0; i < npoints - 1; i++) {
      if ((rep->z.xyZ[i][0] < 0 || rep->z.xyZ[i][0] >= rep->z.xyZ[i][1]) || rep->z.xyZ[i][1] >= npoints + i) {
         result = true;
         ae_frame_leave();
         return result;
      }
      if ((rep->pz.xyZ[i][0] < 0 || rep->pz.xyZ[i][0] >= rep->pz.xyZ[i][1]) || rep->pz.xyZ[i][1] >= npoints + i) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
   for (i = 0; i < npoints - 1; i++) {
      c0 = rep->z.xyZ[i][0];
      c1 = rep->z.xyZ[i][1];
      s0 = rep->pz.xyZ[i][0];
      s1 = rep->pz.xyZ[i][1];
      if (c0 < npoints) {
         c0 = rep->p.xZ[c0];
      }
      if (c1 < npoints) {
         c1 = rep->p.xZ[c1];
      }
      if (c0 != s0 || c1 != s1) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
   clusterizergetkclusters(rep, npoints, &kidx, &kidxz);
   if (kidx.cnt != npoints || kidxz.cnt != npoints) {
      result = true;
      ae_frame_leave();
      return result;
   }
   for (i = 0; i < npoints; i++) {
      if (kidxz.xZ[i] != i || kidx.xZ[i] != i) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
// Test description:
// * we generate (2*NPoints-1)x(2*NPoints-1) matrix of distances DM and
//   (2*NPoints-1)xNPoints matrix of clusters CM (I-th row contains indexes
//   of elements which belong to I-th cluster, negative indexes denote
//   empty cells). Leading N*N square of DM is just a distance matrix,
//   other elements are filled by some large number M (used to mark empty
//   elements).
// * we replay all merges
// * every time we merge clusters I and J into K, we:
//   * check that distance between I and J is equal to the smallest
//     element of DM (note: we account for rounding errors when we
//     decide on that)
//   * check that distance is consistent with Rep.MergeDist
//   * then, we enumerate all elements in clusters being merged,
//     and check that after permutation their indexes fall into range
//     prescribed by Rep.PM
//   * fill K-th column/row of D by distances to cluster K
//   * merge I-th and J-th rows of CM and store result into K-th row
//   * clear DM and CM: fill I-th and J-th column/row of DM by large
//     number M, fill I-th and J-th row of CM by -1.
//
// NOTE: DM is initialized by distance metric specific to AHC algorithm
//       being used. CLINK, SLINK and average linkage use user-provided
//       distance measure, say Euclidean one, without any modifications.
//       Ward's method uses (and reports) squared and scaled Euclidean
//       distances.
   ae_matrix_set_length(&dm, 2 * npoints - 1, 2 * npoints - 1);
   ae_matrix_set_length(&cm, 2 * npoints - 1, npoints);
   ae_vector_set_length(&clustersizes, 2 * npoints - 1);
   for (i = 0; i < 2 * npoints - 1; i++) {
      for (j = 0; j < 2 * npoints - 1; j++) {
         if (i < npoints && j < npoints) {
            dm.xyR[i][j] = d->xyR[i][j];
            if (ahcalgo == 4) {
               dm.xyR[i][j] = 0.5 * sqr(dm.xyR[i][j]);
            }
         } else {
            dm.xyR[i][j] = maxrealnumber;
         }
      }
   }
   for (i = 0; i < 2 * npoints - 1; i++) {
      for (j = 0; j < npoints; j++) {
         cm.xyZ[i][j] = -1;
      }
   }
   for (i = 0; i < npoints; i++) {
      cm.xyZ[i][0] = i;
      clustersizes.xZ[i] = 1;
   }
   for (i = npoints; i < 2 * npoints - 1; i++) {
      clustersizes.xZ[i] = 0;
   }
   ae_vector_set_length(&clusterheights, 2 * npoints - 1);
   for (i = 0; i < npoints; i++) {
      clusterheights.xZ[i] = 0;
   }
   for (mergeidx = 0; mergeidx < npoints - 1; mergeidx++) {
   // Check that clusters with minimum distance are merged,
   // and that MergeDist is consistent with results.
   //
   // NOTE: we do not check for specific cluster indexes,
   //       because it is possible to have a tie. We just
   //       check that distance between clusters is a true
   //       minimum over all possible clusters.
      v = maxrealnumber;
      for (i = 0; i < 2 * npoints - 1; i++) {
         for (j = 0; j < 2 * npoints - 1; j++) {
            if (i != j) {
               v = rmin2(v, dm.xyR[i][j]);
            }
         }
      }
      c0 = rep->z.xyZ[mergeidx][0];
      c1 = rep->z.xyZ[mergeidx][1];
      if (dm.xyR[c0][c1] > v + 10000 * machineepsilon) {
         result = true;
         ae_frame_leave();
         return result;
      }
      if (rep->mergedist.xR[mergeidx] > v + 10000 * machineepsilon) {
         result = true;
         ae_frame_leave();
         return result;
      }
   // Check that indexes of elements fall into range prescribed by Rep.PM,
   // and Rep.PM correctly described merge operation
      s0 = clustersizes.xZ[c0];
      s1 = clustersizes.xZ[c1];
      for (j = 0; j < clustersizes.xZ[c0]; j++) {
         if (rep->p.xZ[cm.xyZ[c0][j]] < rep->pm.xyZ[mergeidx][0] || rep->p.xZ[cm.xyZ[c0][j]] > rep->pm.xyZ[mergeidx][1]) {
         // Element falls outside of range described by PM
            result = true;
            ae_frame_leave();
            return result;
         }
      }
      for (j = 0; j < clustersizes.xZ[c1]; j++) {
         if (rep->p.xZ[cm.xyZ[c1][j]] < rep->pm.xyZ[mergeidx][2] || rep->p.xZ[cm.xyZ[c1][j]] > rep->pm.xyZ[mergeidx][3]) {
         // Element falls outside of range described by PM
            result = true;
            ae_frame_leave();
            return result;
         }
      }
      if ((rep->pm.xyZ[mergeidx][1] - rep->pm.xyZ[mergeidx][0] != s0 - 1 || rep->pm.xyZ[mergeidx][3] - rep->pm.xyZ[mergeidx][2] != s1 - 1) || rep->pm.xyZ[mergeidx][2] != rep->pm.xyZ[mergeidx][1] + 1) {
      // Cluster size (as given by PM) is inconsistent with its actual size.
         result = true;
         ae_frame_leave();
         return result;
      }
      if (rep->pm.xyZ[mergeidx][4] != clusterheights.xZ[rep->z.xyZ[mergeidx][0]] || rep->pm.xyZ[mergeidx][5] != clusterheights.xZ[rep->z.xyZ[mergeidx][1]]) {
      // Heights of subdendrograms as returned by PM are inconsistent with heights
      // calculated by us.
         result = true;
         ae_frame_leave();
         return result;
      }
   // Update cluster heights
      clusterheights.xZ[mergeidx + npoints] = imax2(clusterheights.xZ[rep->z.xyZ[mergeidx][0]], clusterheights.xZ[rep->z.xyZ[mergeidx][1]]) + 1;
   // Update CM
      t = 0;
      for (j = 0; j < clustersizes.xZ[rep->z.xyZ[mergeidx][0]]; j++) {
         cm.xyZ[npoints + mergeidx][t] = cm.xyZ[rep->z.xyZ[mergeidx][0]][j];
         t++;
      }
      for (j = 0; j < clustersizes.xZ[rep->z.xyZ[mergeidx][1]]; j++) {
         cm.xyZ[npoints + mergeidx][t] = cm.xyZ[rep->z.xyZ[mergeidx][1]][j];
         t++;
      }
      clustersizes.xZ[npoints + mergeidx] = t;
      clustersizes.xZ[rep->z.xyZ[mergeidx][0]] = 0;
      clustersizes.xZ[rep->z.xyZ[mergeidx][1]] = 0;
   // Update distance matrix D
      for (i = 0; i < 2 * npoints - 1; i++) {
      // "Remove" columns/rows corresponding to clusters being merged
         dm.xyR[i][rep->z.xyZ[mergeidx][0]] = maxrealnumber;
         dm.xyR[i][rep->z.xyZ[mergeidx][1]] = maxrealnumber;
         dm.xyR[rep->z.xyZ[mergeidx][0]][i] = maxrealnumber;
         dm.xyR[rep->z.xyZ[mergeidx][1]][i] = maxrealnumber;
      }
      for (i = 0; i < npoints + mergeidx; i++) {
         if (clustersizes.xZ[i] > 0) {
         // Calculate column/row corresponding to new cluster
            if (ahcalgo == 0) {
            // Calculate distance between clusters I and NPoints+MergeIdx for CLINK
               v = 0.0;
               for (i0 = 0; i0 < clustersizes.xZ[i]; i0++) {
                  for (i1 = 0; i1 < clustersizes.xZ[npoints + mergeidx]; i1++) {
                     v = rmax2(v, d->xyR[cm.xyZ[i][i0]][cm.xyZ[npoints + mergeidx][i1]]);
                  }
               }
            }
            if (ahcalgo == 1) {
            // Calculate distance between clusters I and NPoints+MergeIdx for SLINK
               v = maxrealnumber;
               for (i0 = 0; i0 < clustersizes.xZ[i]; i0++) {
                  for (i1 = 0; i1 < clustersizes.xZ[npoints + mergeidx]; i1++) {
                     v = rmin2(v, d->xyR[cm.xyZ[i][i0]][cm.xyZ[npoints + mergeidx][i1]]);
                  }
               }
            }
            if (ahcalgo == 2) {
            // Calculate distance between clusters I and NPoints+MergeIdx for unweighted average
               v = 0.0;
               t = 0;
               for (i0 = 0; i0 < clustersizes.xZ[i]; i0++) {
                  for (i1 = 0; i1 < clustersizes.xZ[npoints + mergeidx]; i1++) {
                     v += d->xyR[cm.xyZ[i][i0]][cm.xyZ[npoints + mergeidx][i1]];
                     t++;
                  }
               }
               v /= t;
            }
            if (ahcalgo == 3) {
               ae_assert(false, "Assertion failed");
            }
            if (ahcalgo == 4) {
            // Calculate distance between clusters I and NPoints+MergeIdx for Ward's method:
            // * X0 = center of mass for cluster I
            // * X1 = center of mass for cluster NPoints+MergeIdx
            // * S0 = size of cluster I
            // * S1 = size of cluster NPoints+MergeIdx
            // * distance between clusters is S0*S1/(S0+S1)*|X0-X1|^2
            //
               for (j = 0; j < nf; j++) {
                  x0.xR[j] = 0.0;
                  x1.xR[j] = 0.0;
               }
               for (i0 = 0; i0 < clustersizes.xZ[i]; i0++) {
                  for (j = 0; j < nf; j++) {
                     x0.xR[j] += xy->xyR[cm.xyZ[i][i0]][j] / clustersizes.xZ[i];
                  }
               }
               for (i1 = 0; i1 < clustersizes.xZ[npoints + mergeidx]; i1++) {
                  for (j = 0; j < nf; j++) {
                     x1.xR[j] += xy->xyR[cm.xyZ[npoints + mergeidx][i1]][j] / clustersizes.xZ[npoints + mergeidx];
                  }
               }
               v = 0.0;
               for (j = 0; j < nf; j++) {
                  v += sqr(x0.xR[j] - x1.xR[j]);
               }
               v = v * clustersizes.xZ[i] * clustersizes.xZ[npoints + mergeidx] / (clustersizes.xZ[i] + clustersizes.xZ[npoints + mergeidx]);
            }
            dm.xyR[i][npoints + mergeidx] = v;
            dm.xyR[npoints + mergeidx][i] = v;
         }
      }
   // Check that GetKClusters() correctly unpacks clusters for K=NPoints-(MergeIdx+1):
   // * check lengths of arays
   // * check consistency of CIdx/CZ parameters
   // * scan clusters (CZ parameter), for each cluster scan CM matrix which stores
   //   cluster elements (according to our replay of merges), for each element of
   //   the current cluster check that CIdx array correctly reflects its status.
      k = npoints - (mergeidx + 1);
      clusterizergetkclusters(rep, k, &kidx, &kidxz);
      if (kidx.cnt != npoints || kidxz.cnt != k) {
         result = true;
         ae_frame_leave();
         return result;
      }
      for (i = 0; i < k - 1; i++) {
         if ((kidxz.xZ[i] < 0 || kidxz.xZ[i] >= kidxz.xZ[i + 1]) || kidxz.xZ[i + 1] > 2 * npoints - 2) {
         // CZ is inconsistent
            result = true;
            ae_frame_leave();
            return result;
         }
      }
      for (i = 0; i < npoints; i++) {
         if (kidx.xZ[i] < 0 || kidx.xZ[i] >= k) {
         // CIdx is inconsistent
            result = true;
            ae_frame_leave();
            return result;
         }
      }
      for (i = 0; i < k; i++) {
         for (j = 0; j < clustersizes.xZ[kidxz.xZ[i]]; j++) {
            currentelement = cm.xyZ[kidxz.xZ[i]][j];
            if (kidx.xZ[currentelement] != i) {
            // We've found element which belongs to I-th cluster (according to CM
            // matrix, which reflects current status of agglomerative clustering),
            // but this element does not belongs to I-th cluster according to
            // results of ClusterizerGetKClusters()
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Basic agglomerative hierarchical clustering tests:
// returns True on failure, False on success.
//
// Basic tests study algorithm behavior on simple,  hand-made  datasets  with
// small number of points (1..10).
static bool testclusteringunit_basicahctests() {
   ae_frame _frame_block;
   bool berr;
   ae_int_t ahcalgo;
   ae_int_t i;
   ae_int_t j;
   ae_int_t npoints;
   ae_int_t k;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(clusterizerstate, s);
   NewObj(ahcreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(d, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(cidx, 0, DT_INT);
   NewVector(cz, 0, DT_INT);
   NewVector(cidx2, 0, DT_INT);
   NewVector(cz2, 0, DT_INT);
   result = true;
// Test on empty problem
   clusterizercreate(&s);
   clusterizerrunahc(&s, &rep);
   if (rep.npoints != 0) {
      ae_frame_leave();
      return result;
   }
// Test on problem with one point
   ae_matrix_set_length(&xy, 1, 2);
   xy.xyR[0][0] = randomreal();
   xy.xyR[0][1] = randomreal();
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 1, 2, 0);
   clusterizerrunahc(&s, &rep);
   if (rep.npoints != 1) {
      ae_frame_leave();
      return result;
   }
// Test on problem with two points
   ae_matrix_set_length(&xy, 2, 2);
   xy.xyR[0][0] = randomreal();
   xy.xyR[0][1] = randomreal();
   xy.xyR[1][0] = randomreal();
   xy.xyR[1][1] = randomreal();
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 2, 2, 0);
   clusterizerrunahc(&s, &rep);
   if ((rep.npoints != 2 || rep.z.rows != 1) || rep.z.cols != 2) {
      ae_frame_leave();
      return result;
   }
   if (rep.z.xyZ[0][0] != 0 || rep.z.xyZ[0][1] != 1) {
      ae_frame_leave();
      return result;
   }
// Test on specially designed problem which should have
// following dendrogram:
//
//   ------
//   |    |
// ----  ----
// |  |  |  |
// 0  1  2  3
//
// ...with first merge performed on 0 and 1, second merge
// performed on 2 and 3. Complete linkage is used.
//
// Additionally we test ClusterizerSeparatedByDist() on this
// problem for different distances. Test is performed by
// comparing function result with ClusterizerGetKClusters()
// for known K.
   ae_matrix_set_length(&xy, 4, 1);
   xy.xyR[0][0] = 0.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[2][0] = 3.0;
   xy.xyR[3][0] = 4.1;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 4, 1, 0);
   clusterizersetahcalgo(&s, 0);
   clusterizerrunahc(&s, &rep);
   if ((((rep.npoints != 4 || rep.z.rows != 3) || rep.z.cols != 2) || rep.pz.rows != 3) || rep.pz.cols != 2) {
      ae_frame_leave();
      return result;
   }
   berr = false;
   berr = (berr || rep.z.xyZ[0][0] != 0) || rep.z.xyZ[0][1] != 1;
   berr = (berr || rep.z.xyZ[1][0] != 2) || rep.z.xyZ[1][1] != 3;
   berr = (berr || rep.z.xyZ[2][0] != 4) || rep.z.xyZ[2][1] != 5;
   berr = (((berr || rep.p.xZ[0] != 0) || rep.p.xZ[1] != 1) || rep.p.xZ[2] != 2) || rep.p.xZ[3] != 3;
   berr = (berr || rep.pz.xyZ[0][0] != 0) || rep.pz.xyZ[0][1] != 1;
   berr = (berr || rep.pz.xyZ[1][0] != 2) || rep.pz.xyZ[1][1] != 3;
   berr = (berr || rep.pz.xyZ[2][0] != 4) || rep.pz.xyZ[2][1] != 5;
   berr = (((berr || rep.pm.xyZ[0][0] != 0) || rep.pm.xyZ[0][1] != 0) || rep.pm.xyZ[0][2] != 1) || rep.pm.xyZ[0][3] != 1;
   berr = (((berr || rep.pm.xyZ[1][0] != 2) || rep.pm.xyZ[1][1] != 2) || rep.pm.xyZ[1][2] != 3) || rep.pm.xyZ[1][3] != 3;
   berr = (((berr || rep.pm.xyZ[2][0] != 0) || rep.pm.xyZ[2][1] != 1) || rep.pm.xyZ[2][2] != 2) || rep.pm.xyZ[2][3] != 3;
   if (berr) {
      ae_frame_leave();
      return result;
   }
   clusterizerseparatedbydist(&rep, 0.5, &k, &cidx, &cz);
   clusterizergetkclusters(&rep, 4, &cidx2, &cz2);
   if (k != 4) {
      ae_frame_leave();
      return result;
   }
   if (((cidx.xZ[0] != cidx2.xZ[0] || cidx.xZ[1] != cidx2.xZ[1]) || cidx.xZ[2] != cidx2.xZ[2]) || cidx.xZ[3] != cidx2.xZ[3]) {
      ae_frame_leave();
      return result;
   }
   if (((cz.xZ[0] != cz2.xZ[0] || cz.xZ[1] != cz2.xZ[1]) || cz.xZ[2] != cz2.xZ[2]) || cz.xZ[3] != cz2.xZ[3]) {
      ae_frame_leave();
      return result;
   }
   clusterizerseparatedbydist(&rep, 1.05, &k, &cidx, &cz);
   clusterizergetkclusters(&rep, 3, &cidx2, &cz2);
   if (k != 3) {
      ae_frame_leave();
      return result;
   }
   if (((cidx.xZ[0] != cidx2.xZ[0] || cidx.xZ[1] != cidx2.xZ[1]) || cidx.xZ[2] != cidx2.xZ[2]) || cidx.xZ[3] != cidx2.xZ[3]) {
      ae_frame_leave();
      return result;
   }
   if ((cz.xZ[0] != cz2.xZ[0] || cz.xZ[1] != cz2.xZ[1]) || cz.xZ[2] != cz2.xZ[2]) {
      ae_frame_leave();
      return result;
   }
   clusterizerseparatedbydist(&rep, 1.15, &k, &cidx, &cz);
   clusterizergetkclusters(&rep, 2, &cidx2, &cz2);
   if (k != 2) {
      ae_frame_leave();
      return result;
   }
   if (((cidx.xZ[0] != cidx2.xZ[0] || cidx.xZ[1] != cidx2.xZ[1]) || cidx.xZ[2] != cidx2.xZ[2]) || cidx.xZ[3] != cidx2.xZ[3]) {
      ae_frame_leave();
      return result;
   }
   if (cz.xZ[0] != cz2.xZ[0] || cz.xZ[1] != cz2.xZ[1]) {
      ae_frame_leave();
      return result;
   }
// Test on specially designed problem with Pearson distance
// which should have following dendrogram:
//
//   ------
//   |    |
// ----  ----
// |  |  |  |
// 0  1  2  3
//
// This problem is used to test ClusterizerSeparatedByDist().
// The test is performed by comparing function result with
// ClusterizerGetKClusters() for known K.
//
// NOTE:
// * corr(a0,a1) = 0.866
// * corr(a2,a3) = 0.990
// * corr(a0/a1, a2/a3) <= 0.5
   ae_matrix_set_length(&xy, 4, 3);
   xy.xyR[0][0] = 0.3;
   xy.xyR[0][1] = 0.5;
   xy.xyR[0][2] = 0.3;
   xy.xyR[1][0] = 0.3;
   xy.xyR[1][1] = 0.5;
   xy.xyR[1][2] = 0.4;
   xy.xyR[2][0] = 0.1;
   xy.xyR[2][1] = 0.5;
   xy.xyR[2][2] = 0.9;
   xy.xyR[3][0] = 0.1;
   xy.xyR[3][1] = 0.4;
   xy.xyR[3][2] = 0.9;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 4, 3, 10);
   clusterizersetahcalgo(&s, 1);
   clusterizerrunahc(&s, &rep);
   clusterizerseparatedbycorr(&rep, 0.999, &k, &cidx, &cz);
   clusterizergetkclusters(&rep, 4, &cidx2, &cz2);
   if (k != 4) {
      ae_frame_leave();
      return result;
   }
   if (((cidx.xZ[0] != cidx2.xZ[0] || cidx.xZ[1] != cidx2.xZ[1]) || cidx.xZ[2] != cidx2.xZ[2]) || cidx.xZ[3] != cidx2.xZ[3]) {
      ae_frame_leave();
      return result;
   }
   if (((cz.xZ[0] != cz2.xZ[0] || cz.xZ[1] != cz2.xZ[1]) || cz.xZ[2] != cz2.xZ[2]) || cz.xZ[3] != cz2.xZ[3]) {
      ae_frame_leave();
      return result;
   }
   clusterizerseparatedbycorr(&rep, 0.900, &k, &cidx, &cz);
   clusterizergetkclusters(&rep, 3, &cidx2, &cz2);
   if (k != 3) {
      ae_frame_leave();
      return result;
   }
   if (((cidx.xZ[0] != cidx2.xZ[0] || cidx.xZ[1] != cidx2.xZ[1]) || cidx.xZ[2] != cidx2.xZ[2]) || cidx.xZ[3] != cidx2.xZ[3]) {
      ae_frame_leave();
      return result;
   }
   if ((cz.xZ[0] != cz2.xZ[0] || cz.xZ[1] != cz2.xZ[1]) || cz.xZ[2] != cz2.xZ[2]) {
      ae_frame_leave();
      return result;
   }
   clusterizerseparatedbycorr(&rep, 0.600, &k, &cidx, &cz);
   clusterizergetkclusters(&rep, 2, &cidx2, &cz2);
   if (k != 2) {
      ae_frame_leave();
      return result;
   }
   if (((cidx.xZ[0] != cidx2.xZ[0] || cidx.xZ[1] != cidx2.xZ[1]) || cidx.xZ[2] != cidx2.xZ[2]) || cidx.xZ[3] != cidx2.xZ[3]) {
      ae_frame_leave();
      return result;
   }
   if (cz.xZ[0] != cz2.xZ[0] || cz.xZ[1] != cz2.xZ[1]) {
      ae_frame_leave();
      return result;
   }
// Single linkage vs. complete linkage
   ae_matrix_set_length(&xy, 6, 1);
   xy.xyR[0][0] = 0.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[2][0] = 2.1;
   xy.xyR[3][0] = 3.3;
   xy.xyR[4][0] = 6.0;
   xy.xyR[5][0] = 4.6;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 6, 1, 0);
   clusterizersetahcalgo(&s, 0);
   clusterizerrunahc(&s, &rep);
   if (rep.npoints != 6 || rep.p.cnt != 6) {
      ae_frame_leave();
      return result;
   }
   if (((rep.z.rows != 5 || rep.z.cols != 2) || rep.pz.rows != 5) || rep.pz.cols != 2) {
      ae_frame_leave();
      return result;
   }
   berr = false;
   berr = berr || rep.p.xZ[0] != 2;
   berr = berr || rep.p.xZ[1] != 3;
   berr = berr || rep.p.xZ[2] != 4;
   berr = berr || rep.p.xZ[3] != 5;
   berr = berr || rep.p.xZ[4] != 0;
   berr = berr || rep.p.xZ[5] != 1;
   berr = (berr || rep.z.xyZ[0][0] != 0) || rep.z.xyZ[0][1] != 1;
   berr = (berr || rep.z.xyZ[1][0] != 2) || rep.z.xyZ[1][1] != 3;
   berr = (berr || rep.z.xyZ[2][0] != 4) || rep.z.xyZ[2][1] != 5;
   berr = (berr || rep.z.xyZ[3][0] != 6) || rep.z.xyZ[3][1] != 7;
   berr = (berr || rep.z.xyZ[4][0] != 8) || rep.z.xyZ[4][1] != 9;
   berr = (berr || rep.pz.xyZ[0][0] != 2) || rep.pz.xyZ[0][1] != 3;
   berr = (berr || rep.pz.xyZ[1][0] != 4) || rep.pz.xyZ[1][1] != 5;
   berr = (berr || rep.pz.xyZ[2][0] != 0) || rep.pz.xyZ[2][1] != 1;
   berr = (berr || rep.pz.xyZ[3][0] != 6) || rep.pz.xyZ[3][1] != 7;
   berr = (berr || rep.pz.xyZ[4][0] != 8) || rep.pz.xyZ[4][1] != 9;
   if (berr) {
      ae_frame_leave();
      return result;
   }
   clusterizersetahcalgo(&s, 1);
   clusterizerrunahc(&s, &rep);
   if ((rep.npoints != 6 || rep.z.rows != 5) || rep.z.cols != 2) {
      ae_frame_leave();
      return result;
   }
   berr = false;
   berr = (berr || rep.z.xyZ[0][0] != 0) || rep.z.xyZ[0][1] != 1;
   berr = (berr || rep.z.xyZ[1][0] != 2) || rep.z.xyZ[1][1] != 6;
   berr = (berr || rep.z.xyZ[2][0] != 3) || rep.z.xyZ[2][1] != 7;
   berr = (berr || rep.z.xyZ[3][0] != 5) || rep.z.xyZ[3][1] != 8;
   berr = (berr || rep.z.xyZ[4][0] != 4) || rep.z.xyZ[4][1] != 9;
   if (berr) {
      ae_frame_leave();
      return result;
   }
// Test which differentiates complete linkage and average linkage from
// single linkage:
// * we have cluster C0={(-0.5), (0)},
//   cluster C1={(19.0), (20.0), (21.0), (22.0), (23.0)},
//   and point P between them - (10.0)
// * we try three different strategies - single linkage, complete
//   linkage, average linkage.
// * any strategy will merge C0 first, then merge points of C1,
//   and then merge P with C0 or C1 (depending on linkage type)
// * we test that:
//   a) C0 is merged first
//   b) after 5 merges (including merge of C0), P is merged with C0 or C1
//   c) P is merged with C1 when we have single linkage, with C0 otherwise
   ae_matrix_set_length(&xy, 8, 1);
   xy.xyR[0][0] = -0.5;
   xy.xyR[1][0] = 0.0;
   xy.xyR[2][0] = 10.0;
   xy.xyR[3][0] = 19.0;
   xy.xyR[4][0] = 20.0;
   xy.xyR[5][0] = 21.0;
   xy.xyR[6][0] = 22.0;
   xy.xyR[7][0] = 23.0;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 8, 1, 0);
   for (ahcalgo = 0; ahcalgo <= 2; ahcalgo++) {
      clusterizersetahcalgo(&s, ahcalgo);
      clusterizerrunahc(&s, &rep);
      if ((rep.npoints != 8 || rep.z.rows != 7) || rep.z.cols != 2) {
         ae_frame_leave();
         return result;
      }
      if (rep.z.xyZ[0][0] != 0 || rep.z.xyZ[0][1] != 1) {
         ae_frame_leave();
         return result;
      }
      if (rep.z.xyZ[5][0] != 2 && rep.z.xyZ[5][1] != 2) {
         ae_frame_leave();
         return result;
      }
      if (rep.z.xyZ[5][0] != 2 && rep.z.xyZ[5][1] != 2) {
         ae_frame_leave();
         return result;
      }
      if ((ahcalgo == 0 || ahcalgo == 2) && (rep.z.xyZ[5][0] != 8 && rep.z.xyZ[5][1] != 8)) {
         ae_frame_leave();
         return result;
      }
      if (ahcalgo == 1 && (rep.z.xyZ[5][0] == 8 || rep.z.xyZ[5][1] == 8)) {
         ae_frame_leave();
         return result;
      }
   }
// Test which differentiates single linkage and average linkage from
// complete linkage:
// * we have cluster C0={(-2.5), (-2.0)},
//   cluster C1={(19.0), (20.0), (21.0), (22.0), (23.0)},
//   and point P between them - (10.0)
// * we try three different strategies - single linkage, complete
//   linkage, average linkage.
// * any strategy will merge C0 first, then merge points of C1,
//   and then merge P with C0 or C1 (depending on linkage type)
// * we test that:
//   a) C0 is merged first
//   b) after 5 merges (including merge of C0), P is merged with C0 or C1
//   c) P is merged with C0 when we have complete linkage, with C1 otherwise
   ae_matrix_set_length(&xy, 8, 1);
   xy.xyR[0][0] = -2.5;
   xy.xyR[1][0] = -2.0;
   xy.xyR[2][0] = 10.0;
   xy.xyR[3][0] = 19.0;
   xy.xyR[4][0] = 20.0;
   xy.xyR[5][0] = 21.0;
   xy.xyR[6][0] = 22.0;
   xy.xyR[7][0] = 23.0;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 8, 1, 0);
   for (ahcalgo = 0; ahcalgo <= 2; ahcalgo++) {
      clusterizersetahcalgo(&s, ahcalgo);
      clusterizerrunahc(&s, &rep);
      if ((rep.npoints != 8 || rep.z.rows != 7) || rep.z.cols != 2) {
         ae_frame_leave();
         return result;
      }
      if (rep.z.xyZ[0][0] != 0 || rep.z.xyZ[0][1] != 1) {
         ae_frame_leave();
         return result;
      }
      if (rep.z.xyZ[5][0] != 2 && rep.z.xyZ[5][1] != 2) {
         ae_frame_leave();
         return result;
      }
      if (rep.z.xyZ[5][0] != 2 && rep.z.xyZ[5][1] != 2) {
         ae_frame_leave();
         return result;
      }
      if (ahcalgo == 0 && (rep.z.xyZ[5][0] != 8 && rep.z.xyZ[5][1] != 8)) {
         ae_frame_leave();
         return result;
      }
      if ((ahcalgo == 1 || ahcalgo == 2) && (rep.z.xyZ[5][0] == 8 || rep.z.xyZ[5][1] == 8)) {
         ae_frame_leave();
         return result;
      }
   }
// Test which differentiates weighred average linkage from unweighted average linkage:
// * we have cluster C0={(0.0), (1.5), (2.5)},
//   cluster C1={(7.5), (7.99)},
//   and point P between them - (4.5)
// * we try two different strategies - weighted average linkage and unweighted average linkage
// * any strategy will merge C1 first, then merge points of C0,
//   and then merge P with C0 or C1 (depending on linkage type)
// * we test that:
//   a) C1 is merged first, C0 is merged after that
//   b) after first 3 merges P is merged with C0 or C1
//   c) P is merged with C1 when we have weighted average linkage, with C0 otherwise
   ae_matrix_set_length(&xy, 6, 1);
   xy.xyR[0][0] = 0.0;
   xy.xyR[1][0] = 1.5;
   xy.xyR[2][0] = 2.5;
   xy.xyR[3][0] = 4.5;
   xy.xyR[4][0] = 7.5;
   xy.xyR[5][0] = 7.99;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 6, 1, 0);
   for (ahcalgo = 2; ahcalgo <= 3; ahcalgo++) {
      clusterizersetahcalgo(&s, ahcalgo);
      clusterizerrunahc(&s, &rep);
      if ((rep.npoints != 6 || rep.z.rows != 5) || rep.z.cols != 2) {
         ae_frame_leave();
         return result;
      }
      if (rep.z.xyZ[0][0] != 4 || rep.z.xyZ[0][1] != 5) {
         ae_frame_leave();
         return result;
      }
      if (rep.z.xyZ[1][0] != 1 || rep.z.xyZ[1][1] != 2) {
         ae_frame_leave();
         return result;
      }
      if (rep.z.xyZ[2][0] != 0 || rep.z.xyZ[2][1] != 7) {
         ae_frame_leave();
         return result;
      }
      if (rep.z.xyZ[3][0] != 3) {
         ae_frame_leave();
         return result;
      }
      if (ahcalgo == 2 && rep.z.xyZ[3][1] != 8) {
         ae_frame_leave();
         return result;
      }
      if (ahcalgo == 3 && rep.z.xyZ[3][1] != 6) {
         ae_frame_leave();
         return result;
      }
   }
// Test which checks correctness of Ward's method on very basic problem
   ae_matrix_set_length(&xy, 4, 1);
   xy.xyR[0][0] = 0.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[2][0] = 3.1;
   xy.xyR[3][0] = 4.0;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, xy.rows, xy.cols, 2);
   clusterizergetdistances(&xy, xy.rows, xy.cols, 2, &d);
   clusterizersetahcalgo(&s, 4);
   clusterizerrunahc(&s, &rep);
   if (testclusteringunit_errorsinmerges(&d, &xy, xy.rows, xy.cols, &rep, 4)) {
      ae_frame_leave();
      return result;
   }
// One more Ward's test
   ae_matrix_set_length(&xy, 8, 2);
   xy.xyR[0][0] = 0.4700566262;
   xy.xyR[0][1] = 0.4565938448;
   xy.xyR[1][0] = 0.2394499506;
   xy.xyR[1][1] = 0.1750209592;
   xy.xyR[2][0] = 0.6518417019;
   xy.xyR[2][1] = 0.6151370746;
   xy.xyR[3][0] = 0.9863942841;
   xy.xyR[3][1] = 0.7855012189;
   xy.xyR[4][0] = 0.1517812919;
   xy.xyR[4][1] = 0.2600174758;
   xy.xyR[5][0] = 0.7840203638;
   xy.xyR[5][1] = 0.9023597604;
   xy.xyR[6][0] = 0.2604194835;
   xy.xyR[6][1] = 0.9792704661;
   xy.xyR[7][0] = 0.6353096042;
   xy.xyR[7][1] = 0.8252606906;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, xy.rows, xy.cols, 2);
   clusterizergetdistances(&xy, xy.rows, xy.cols, 2, &d);
   clusterizersetahcalgo(&s, 4);
   clusterizerrunahc(&s, &rep);
   if (rep.z.xyZ[0][0] != 1 || rep.z.xyZ[0][1] != 4) {
      ae_frame_leave();
      return result;
   }
   if (rep.z.xyZ[1][0] != 5 || rep.z.xyZ[1][1] != 7) {
      ae_frame_leave();
      return result;
   }
   if (rep.z.xyZ[2][0] != 0 || rep.z.xyZ[2][1] != 2) {
      ae_frame_leave();
      return result;
   }
   if (rep.z.xyZ[3][0] != 3 || rep.z.xyZ[3][1] != 9) {
      ae_frame_leave();
      return result;
   }
   if (rep.z.xyZ[4][0] != 10 || rep.z.xyZ[4][1] != 11) {
      ae_frame_leave();
      return result;
   }
   if (rep.z.xyZ[5][0] != 6 || rep.z.xyZ[5][1] != 12) {
      ae_frame_leave();
      return result;
   }
   if (rep.z.xyZ[6][0] != 8 || rep.z.xyZ[6][1] != 13) {
      ae_frame_leave();
      return result;
   }
   if (testclusteringunit_errorsinmerges(&d, &xy, xy.rows, xy.cols, &rep, 4)) {
      ae_frame_leave();
      return result;
   }
// Ability to solve problems with zero distance matrix
   npoints = 20;
   ae_matrix_set_length(&d, npoints, npoints);
   for (i = 0; i < npoints; i++) {
      for (j = 0; j < npoints; j++) {
         d.xyR[i][j] = 0.0;
      }
   }
   for (ahcalgo = 0; ahcalgo <= 4; ahcalgo++) {
      clusterizercreate(&s);
      clusterizersetdistances(&s, &d, npoints, true);
      clusterizersetahcalgo(&s, ahcalgo);
      clusterizerrunahc(&s, &rep);
      if ((rep.npoints != npoints || rep.z.rows != npoints - 1) || rep.z.cols != 2) {
         ae_frame_leave();
         return result;
      }
   }
// Test GetKClusters()
   ae_matrix_set_length(&xy, 8, 1);
   xy.xyR[0][0] = -2.5;
   xy.xyR[1][0] = -2.0;
   xy.xyR[2][0] = 10.0;
   xy.xyR[3][0] = 19.0;
   xy.xyR[4][0] = 20.0;
   xy.xyR[5][0] = 21.0;
   xy.xyR[6][0] = 22.0;
   xy.xyR[7][0] = 23.0;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, 8, 1, 0);
   clusterizersetahcalgo(&s, 0);
   clusterizerrunahc(&s, &rep);
   clusterizergetkclusters(&rep, 3, &cidx, &cz);
   if (((((((cidx.xZ[0] != 1 || cidx.xZ[1] != 1) || cidx.xZ[2] != 0) || cidx.xZ[3] != 2) || cidx.xZ[4] != 2) || cidx.xZ[5] != 2) || cidx.xZ[6] != 2) || cidx.xZ[7] != 2) {
      ae_frame_leave();
      return result;
   }
   if ((cz.xZ[0] != 2 || cz.xZ[1] != 8) || cz.xZ[2] != 12) {
      ae_frame_leave();
      return result;
   }
// Test is done
   result = false;
   ae_frame_leave();
   return result;
}

// Distance function: distance between X0 and X1
//
// X0, X1 - array[D], points
// DistType - distance type
static double testclusteringunit_distfunc(RVector *x0, RVector *x1, ae_int_t d, ae_int_t disttype) {
   ae_int_t i;
   double s0;
   double s1;
   double result;
   ae_assert((((((((disttype == 0 || disttype == 1) || disttype == 2) || disttype == 10) || disttype == 11) || disttype == 12) || disttype == 13) || disttype == 20) || disttype == 21, "Assertion failed");
   if (disttype == 0) {
      result = 0.0;
      for (i = 0; i < d; i++) {
         result = rmax2(result, fabs(x0->xR[i] - x1->xR[i]));
      }
      return result;
   }
   if (disttype == 1) {
      result = 0.0;
      for (i = 0; i < d; i++) {
         result += fabs(x0->xR[i] - x1->xR[i]);
      }
      return result;
   }
   if (disttype == 2) {
      result = 0.0;
      for (i = 0; i < d; i++) {
         result += sqr(x0->xR[i] - x1->xR[i]);
      }
      result = sqrt(result);
      return result;
   }
   if (disttype == 10) {
      result = rmax2(1 - pearsoncorr2(x0, x1, d), 0.0);
      return result;
   }
   if (disttype == 11) {
      result = rmax2(1 - fabs(pearsoncorr2(x0, x1, d)), 0.0);
      return result;
   }
   if (disttype == 12 || disttype == 13) {
      s0 = 0.0;
      s1 = 0.0;
      for (i = 0; i < d; i++) {
         s0 += sqr(x0->xR[i]) / d;
         s1 += sqr(x1->xR[i]) / d;
      }
      s0 = sqrt(s0);
      s1 = sqrt(s1);
      result = 0.0;
      for (i = 0; i < d; i++) {
         result += x0->xR[i] / s0 * (x1->xR[i] / s1) / d;
      }
      if (disttype == 12) {
         result = rmax2(1 - result, 0.0);
      } else {
         result = rmax2(1 - fabs(result), 0.0);
      }
      return result;
   }
   if (disttype == 20) {
      result = rmax2(1 - spearmancorr2(x0, x1, d), 0.0);
      return result;
   }
   if (disttype == 21) {
      result = rmax2(1 - fabs(spearmancorr2(x0, x1, d)), 0.0);
      return result;
   }
   result = 0.0;
   return result;
}

// Advanced  agglomerative  hierarchical  clustering  tests : returns True on
// failure, False on success.
//
// Advanced testing subroutine perform several automatically generated tests.
static bool testclusteringunit_advancedahctests() {
   ae_frame _frame_block;
   ae_int_t d;
   ae_int_t n;
   ae_int_t npoints;
   ae_int_t ahcalgo;
   ae_int_t disttype;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_int_t t;
   ae_int_t euclidean;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(clusterizerstate, s);
   NewObj(ahcreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(dm, 0, 0, DT_REAL);
   NewMatrix(dm2, 0, 0, DT_REAL);
   NewVector(idx, 0, DT_INT);
   NewVector(disttypes, 0, DT_INT);
   NewVector(x0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   result = false;
   euclidean = 2;
// Test on D-dimensional problem:
// * D = 2...5
// * D clusters, each has N points;
//   centers are located at x=(0 ... 1 ... 0);
//   cluster radii are approximately 0.1
// * single/complete/unweighted_average/weighted_average linkage/Ward's method are tested
// * Euclidean distance is used, either:
//   a) one given by distance matrix (ClusterizerSetDistances)
//   b) one calculated from dataset (ClusterizerSetPoints)
// * we have N*D points, and N*D-1 merges in total
// * points are randomly rearranged after generation
//
// For all kinds of linkage we perform following test:
// * for each point we remember index of its cluster
//   (one which is determined during dataset generation)
// * we clusterize points with ALGLIB capabilities
// * we scan Rep.Z and perform first D*(N-1) merges
// * for each merge we check that it merges points
//   from same cluster;
//
// Additonally, we call ErrorsInMerges(). See function comments
// for more information about specific tests performed. This function
// allows us to check that clusters are built exactly as specified by
// definition of the clustering algorithm.
   for (d = 2; d <= 5; d++) {
      for (ahcalgo = 0; ahcalgo <= 4; ahcalgo++) {
         n = iround(pow(3.0, (double)randominteger(3)));
         npoints = d * n;
      // 1. generate dataset.
      // 2. fill Idx (array of cluster indexes):
      //    * first N*D elements store cluster indexes
      //    * next D*(N-1) elements are filled during merges
      // 3. build distance matrix DM
         ae_matrix_set_length(&xy, n * d, d);
         ae_vector_set_length(&idx, n * d + d * (n - 1));
         for (i = 0; i < n * d; i++) {
            for (j = 0; j < d; j++) {
               xy.xyR[i][j] = 0.1 * randommid();
            }
            xy.xyR[i][i % d]++;
            idx.xZ[i] = i % d;
         }
         for (i = 0; i < n * d; i++) {
            k = randominteger(n * d);
            if (k != i) {
               for (j = 0; j < d; j++) {
                  v = xy.xyR[i][j];
                  xy.xyR[i][j] = xy.xyR[k][j];
                  xy.xyR[k][j] = v;
               }
               t = idx.xZ[k];
               idx.xZ[k] = idx.xZ[i];
               idx.xZ[i] = t;
            }
         }
         ae_matrix_set_length(&dm, npoints, npoints);
         ae_vector_set_length(&x0, d);
         ae_vector_set_length(&x1, d);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < npoints; j++) {
               ae_v_move(x0.xR, 1, xy.xyR[i], 1, d);
               ae_v_move(x1.xR, 1, xy.xyR[j], 1, d);
               dm.xyR[i][j] = testclusteringunit_distfunc(&x0, &x1, d, euclidean);
            }
         }
      // Clusterize with SetPoints()
         clusterizercreate(&s);
         clusterizersetpoints(&s, &xy, n * d, d, euclidean);
         clusterizersetahcalgo(&s, ahcalgo);
         clusterizerrunahc(&s, &rep);
      // Tests:
      // * replay first D*(N-1) merges; these merges should take place
      //   within clusters, intercluster merges will be performed at the
      //   last stages of the processing.
      // * test with ErrorsInMerges()
         if (rep.npoints != npoints) {
            result = true;
            ae_frame_leave();
            return result;
         }
         for (i = 0; i < d * (n - 1); i++) {
         // Check correctness of I-th row of Z
            if ((rep.z.xyZ[i][0] < 0 || rep.z.xyZ[i][0] >= rep.z.xyZ[i][1]) || rep.z.xyZ[i][1] >= d * n + i) {
               result = true;
               ae_frame_leave();
               return result;
            }
         // Check that merge is performed within cluster
            if (idx.xZ[rep.z.xyZ[i][0]] != idx.xZ[rep.z.xyZ[i][1]]) {
               result = true;
               ae_frame_leave();
               return result;
            }
         // Write new entry of Idx.
         // Both points from the same cluster, so result of the merge
         // belongs to the same cluster
            idx.xZ[n * d + i] = idx.xZ[rep.z.xyZ[i][1]];
         }
         if (((ahcalgo == 0 || ahcalgo == 1) || ahcalgo == 2) || ahcalgo == 4) {
            if (testclusteringunit_errorsinmerges(&dm, &xy, d * n, d, &rep, ahcalgo)) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      // Clusterize one more time, now with distance matrix
         clusterizercreate(&s);
         clusterizersetdistances(&s, &dm, n * d, randombool());
         clusterizersetahcalgo(&s, ahcalgo);
         clusterizerrunahc(&s, &rep);
      // Tests:
      // * replay first D*(N-1) merges; these merges should take place
      //   within clusters, intercluster merges will be performed at the
      //   last stages of the processing.
      // * test with ErrorsInMerges()
         if (rep.npoints != npoints) {
            result = true;
            ae_frame_leave();
            return result;
         }
         for (i = 0; i < d * (n - 1); i++) {
         // Check correctness of I-th row of Z
            if ((rep.z.xyZ[i][0] < 0 || rep.z.xyZ[i][0] >= rep.z.xyZ[i][1]) || rep.z.xyZ[i][1] >= d * n + i) {
               result = true;
               ae_frame_leave();
               return result;
            }
         // Check that merge is performed within cluster
            if (idx.xZ[rep.z.xyZ[i][0]] != idx.xZ[rep.z.xyZ[i][1]]) {
               result = true;
               ae_frame_leave();
               return result;
            }
         // Write new entry of Idx.
         // Both points from the same cluster, so result of the merge
         // belongs to the same cluster
            idx.xZ[n * d + i] = idx.xZ[rep.z.xyZ[i][1]];
         }
         if (((ahcalgo == 0 || ahcalgo == 1) || ahcalgo == 2) || ahcalgo == 4) {
            if (testclusteringunit_errorsinmerges(&dm, &xy, d * n, d, &rep, ahcalgo)) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
// Test on random D-dimensional problem:
// * D = 2...5
// * N=1..16 random points from unit hypercube
// * single/complete/unweighted_average linkage/Ward's method are tested
// * different distance functions are tested
// * we call ErrorsInMerges() and we check distance matrix
//   calculated by unit test against one returned by GetDistances()
   ae_vector_set_length(&disttypes, 9);
   disttypes.xZ[0] = 0;
   disttypes.xZ[1] = 1;
   disttypes.xZ[2] = 2;
   disttypes.xZ[3] = 10;
   disttypes.xZ[4] = 11;
   disttypes.xZ[5] = 12;
   disttypes.xZ[6] = 13;
   disttypes.xZ[7] = 20;
   disttypes.xZ[8] = 21;
   for (disttype = 0; disttype < disttypes.cnt; disttype++) {
      for (ahcalgo = 0; ahcalgo <= 4; ahcalgo++) {
         if (ahcalgo == 3) {
            continue;
         }
         if (ahcalgo == 4 && disttype != 2) {
            continue;
         }
         npoints = iround(pow(2.0, (double)randominteger(5)));
         d = 2 + randominteger(4);
      // Generate dataset and distance matrix
         ae_matrix_set_length(&xy, npoints, d);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < d; j++) {
               xy.xyR[i][j] = randomreal();
            }
         }
         ae_matrix_set_length(&dm, npoints, npoints);
         ae_vector_set_length(&x0, d);
         ae_vector_set_length(&x1, d);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < npoints; j++) {
               ae_v_move(x0.xR, 1, xy.xyR[i], 1, d);
               ae_v_move(x1.xR, 1, xy.xyR[j], 1, d);
               dm.xyR[i][j] = testclusteringunit_distfunc(&x0, &x1, d, disttypes.xZ[disttype]);
            }
         }
      // Clusterize
         clusterizercreate(&s);
         clusterizersetpoints(&s, &xy, npoints, d, disttypes.xZ[disttype]);
         clusterizersetahcalgo(&s, ahcalgo);
         clusterizerrunahc(&s, &rep);
      // Test with ErrorsInMerges()
         if (testclusteringunit_errorsinmerges(&dm, &xy, npoints, d, &rep, ahcalgo)) {
            result = true;
            ae_frame_leave();
            return result;
         }
      // Test distance matrix
         clusterizergetdistances(&xy, npoints, d, disttypes.xZ[disttype], &dm2);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < npoints; j++) {
               if (!isfinite(dm2.xyR[i][j]) || fabs(dm.xyR[i][j] - dm2.xyR[i][j]) > 1.0E5 * machineepsilon) {
                  result = true;
                  ae_frame_leave();
                  return result;
               }
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Random normal number
static double testclusteringunit_rnormal() {
   double u;
   double v;
   double s;
   double x1;
   double result;
   while (true) {
      u = randommid();
      v = randommid();
      s = sqr(u) + sqr(v);
      if (s > 0.0 && s < 1.0) {
         s = sqrt(-2 * log(s) / s);
         x1 = u * s;
         break;
      }
   }
   result = x1;
   return result;
}

// Random point from sphere
static void testclusteringunit_rsphere(RMatrix *xy, ae_int_t n, ae_int_t i) {
   ae_int_t j;
   double v;
   for (j = 0; j < n; j++) {
      xy->xyR[i][j] = testclusteringunit_rnormal();
   }
   v = ae_v_dotproduct(xy->xyR[i], 1, xy->xyR[i], 1, n);
   v = randomreal() / sqrt(v);
   ae_v_muld(xy->xyR[i], 1, n, v);
}

// Simple test 1: ellipsoid in NF-dimensional space.
// compare k-means centers with random centers
static void testclusteringunit_kmeanssimpletest1(ae_int_t nvars, ae_int_t nc, ae_int_t passcount, bool *converrors, bool *othererrors, bool *simpleerrors) {
   ae_frame _frame_block;
   ae_int_t npoints;
   ae_int_t majoraxis;
   double v;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   ae_int_t restarts;
   double ekmeans;
   double erandom;
   double dclosest;
   ae_int_t cclosest;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewObj(clusterizerstate, s);
   NewObj(kmeansreport, rep);
   npoints = nc * 100;
   restarts = 5;
   passcount = 10;
   ae_vector_set_length(&tmp, nvars - 1 + 1);
   for (pass = 1; pass <= passcount; pass++) {
   // Fill
      ae_matrix_set_length(&xy, npoints - 1 + 1, nvars - 1 + 1);
      majoraxis = randominteger(nvars);
      for (i = 0; i < npoints; i++) {
         testclusteringunit_rsphere(&xy, nvars, i);
         xy.xyR[i][majoraxis] *= nc;
      }
   // Test
      clusterizercreate(&s);
      clusterizersetpoints(&s, &xy, npoints, nvars, 2);
      clusterizersetkmeanslimits(&s, restarts, 0);
      clusterizerrunkmeans(&s, nc, &rep);
      if (rep.terminationtype <= 0) {
         *converrors = true;
         ae_frame_leave();
         return;
      }
   // Test that XYC is correct mapping to cluster centers
      for (i = 0; i < npoints; i++) {
         cclosest = -1;
         dclosest = maxrealnumber;
         for (j = 0; j < nc; j++) {
            ae_v_move(tmp.xR, 1, xy.xyR[i], 1, nvars);
            ae_v_sub(tmp.xR, 1, rep.c.xyR[j], 1, nvars);
            v = ae_v_dotproduct(tmp.xR, 1, tmp.xR, 1, nvars);
            if (v < dclosest) {
               cclosest = j;
               dclosest = v;
            }
         }
         if (cclosest != rep.cidx.xZ[i]) {
            *othererrors = true;
            ae_frame_leave();
            return;
         }
      }
   // Use first NC rows of XY as random centers
   // (XY is totally random, so it is as good as any other choice).
   //
   // Compare potential functions.
      ekmeans = 0.0;
      for (i = 0; i < npoints; i++) {
         ae_v_move(tmp.xR, 1, xy.xyR[i], 1, nvars);
         ae_v_sub(tmp.xR, 1, rep.c.xyR[rep.cidx.xZ[i]], 1, nvars);
         v = ae_v_dotproduct(tmp.xR, 1, tmp.xR, 1, nvars);
         ekmeans += v;
      }
      erandom = 0.0;
      for (i = 0; i < npoints; i++) {
         dclosest = maxrealnumber;
         v = 0.0;
         for (j = 0; j < nc; j++) {
            ae_v_move(tmp.xR, 1, xy.xyR[i], 1, nvars);
            ae_v_sub(tmp.xR, 1, xy.xyR[j], 1, nvars);
            v = ae_v_dotproduct(tmp.xR, 1, tmp.xR, 1, nvars);
            if (v < dclosest) {
               dclosest = v;
            }
         }
         erandom += v;
      }
      if (erandom < ekmeans) {
         *simpleerrors = true;
         ae_frame_leave();
         return;
      }
   }
   ae_frame_leave();
}

// This procedure is a reference version of KMeansUpdateDistances().
//
// Inputs:
//     XY          -   dataset, array [0..NPoints-1,0..NVars-1].
//     NPoints     -   dataset size, NPoints >= K
//     NVars       -   number of variables, NVars >= 1
//     CT          -   matrix of centers, centers are stored in rows
//     K           -   number of centers, K >= 1
//     XYC         -   preallocated output buffer
//     XYDist2     -   preallocated output buffer
//
// Outputs:
//     XYC         -   new assignment of points to centers
//     XYDist2     -   squared distances
// ALGLIB: Copyright 21.01.2015 by Sergey Bochkanov
static void testclusteringunit_kmeansreferenceupdatedistances(RMatrix *xy, ae_int_t npoints, ae_int_t nvars, RMatrix *ct, ae_int_t k, ZVector *xyc, RVector *xydist2) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t cclosest;
   double dclosest;
   double v;
   ae_frame_make(&_frame_block);
   NewVector(tmp, 0, DT_REAL);
   ae_vector_set_length(&tmp, nvars);
   for (i = 0; i < npoints; i++) {
      cclosest = -1;
      dclosest = maxrealnumber;
      for (j = 0; j < k; j++) {
         ae_v_move(tmp.xR, 1, xy->xyR[i], 1, nvars);
         ae_v_sub(tmp.xR, 1, ct->xyR[j], 1, nvars);
         v = ae_v_dotproduct(tmp.xR, 1, tmp.xR, 1, nvars);
         if (v < dclosest) {
            cclosest = j;
            dclosest = v;
         }
      }
      ae_assert(cclosest >= 0, "KMeansUpdateDistances: internal error");
      xyc->xZ[i] = cclosest;
      xydist2->xR[i] = dclosest;
   }
   ae_frame_leave();
}

// This test perform several checks for special properties
//
// On failure sets error flag, on success leaves it unchanged.
static void testclusteringunit_kmeansspecialtests(bool *othererrors) {
   ae_frame _frame_block;
   ae_int_t npoints;
   ae_int_t nfeatures;
   ae_int_t nclusters;
   ae_int_t initalgo;
   ae_int_t idx0;
   ae_int_t idx1;
   ae_int_t idx2;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t separation;
   bool allsame;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewVector(xyc, 0, DT_INT);
   NewVector(xycref, 0, DT_INT);
   NewVector(xydist2, 0, DT_REAL);
   NewVector(xydist2ref, 0, DT_REAL);
   NewVector(energies, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   NewObj(clusterizerstate, s);
   NewObj(kmeansreport, rep);
   NewObj(ae_shared_pool, bufferpool);
   NewObj(apbuffers, bufferseed);
   NewVector(pointslist, 0, DT_INT);
   NewVector(featureslist, 0, DT_INT);
   NewVector(clusterslist, 0, DT_INT);
   hqrndrandomize(&rs);
// Compare different initialization algorithms:
// * dataset is K balls, chosen at random gaussian points, with
//   radius equal to 2^(-Separation).
// * we generate random sample, run k-means initialization algorithm
//   and calculate mean energy for each initialization algorithm.
//   In order to suppress Lloyd's iteration we use KmeansDbgNoIts
//   debug flag.
// * then, we compare mean energies; kmeans++ must be best one,
//   random initialization must be worst one.
   ae_vector_set_length(&energies, 4);
   passcount = 1000;
   npoints = 100;
   nfeatures = 3;
   nclusters = 6;
   ae_matrix_set_length(&xy, npoints, nfeatures);
   ae_matrix_set_length(&c, nclusters, nfeatures);
   clusterizercreate(&s);
   s.kmeansdbgnoits = true;
   for (separation = 2; separation <= 5; separation++) {
   // Try different init algorithms
      for (initalgo = 1; initalgo <= 3; initalgo++) {
         energies.xR[initalgo] = 0.0;
         clusterizersetkmeansinit(&s, initalgo);
         for (pass = 1; pass <= passcount; pass++) {
         // Generate centers of balls
            for (i = 0; i < nclusters; i++) {
               for (j = 0; j < nfeatures; j++) {
                  c.xyR[i][j] = hqrndnormal(&rs);
               }
            }
         // Generate points
            for (i = 0; i < npoints; i++) {
               for (j = 0; j < nfeatures; j++) {
                  xy.xyR[i][j] = hqrndnormal(&rs) * pow(2.0, (double)-separation) + c.xyR[i % nclusters][j];
               }
            }
         // Run clusterization
            clusterizersetpoints(&s, &xy, npoints, nfeatures, 2);
            clusterizerrunkmeans(&s, nclusters, &rep);
            set_error_flag(othererrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testclusteringunit.ap:1069");
            energies.xR[initalgo] += rep.energy / passcount;
         }
      }
   // Compare
      set_error_flag(othererrors, !(energies.xR[2] < energies.xR[1]), __FILE__, __LINE__, "testclusteringunit.ap:1077");
      set_error_flag(othererrors, !(energies.xR[3] < energies.xR[1]), __FILE__, __LINE__, "testclusteringunit.ap:1078");
   }
// Test distance calculation algorithm
   ae_vector_set_length(&pointslist, 6);
   pointslist.xZ[0] = 1;
   pointslist.xZ[1] = 10;
   pointslist.xZ[2] = 32;
   pointslist.xZ[3] = 100;
   pointslist.xZ[4] = 512;
   pointslist.xZ[5] = 8000;
   ae_vector_set_length(&featureslist, 5);
   featureslist.xZ[0] = 1;
   featureslist.xZ[1] = 5;
   featureslist.xZ[2] = 32;
   featureslist.xZ[3] = 50;
   featureslist.xZ[4] = 96;
   ae_vector_set_length(&clusterslist, 5);
   clusterslist.xZ[0] = 1;
   clusterslist.xZ[1] = 5;
   clusterslist.xZ[2] = 32;
   clusterslist.xZ[3] = 50;
   clusterslist.xZ[4] = 96;
   ae_shared_pool_set_seed(&bufferpool, &bufferseed, sizeof(bufferseed), apbuffers_init, apbuffers_copy, apbuffers_free);
   for (idx0 = 0; idx0 < pointslist.cnt; idx0++) {
      for (idx1 = 0; idx1 < featureslist.cnt; idx1++) {
         for (idx2 = 0; idx2 < clusterslist.cnt; idx2++) {
            npoints = pointslist.xZ[idx0];
            nfeatures = featureslist.xZ[idx1];
            nclusters = clusterslist.xZ[idx2];
            ae_matrix_set_length(&xy, npoints, nfeatures);
            for (i = 0; i < npoints; i++) {
               for (j = 0; j < nfeatures; j++) {
                  xy.xyR[i][j] = hqrndnormal(&rs);
               }
            }
            ae_matrix_set_length(&c, nclusters, nfeatures);
            for (i = 0; i < nclusters; i++) {
               for (j = 0; j < nfeatures; j++) {
                  c.xyR[i][j] = hqrndnormal(&rs);
               }
            }
            ae_vector_set_length(&xyc, npoints);
            ae_vector_set_length(&xycref, npoints);
            ae_vector_set_length(&xydist2, npoints);
            ae_vector_set_length(&xydist2ref, npoints);
         // Test
            kmeansupdatedistances(&xy, 0, npoints, nfeatures, &c, 0, nclusters, &xyc, &xydist2, &bufferpool);
            testclusteringunit_kmeansreferenceupdatedistances(&xy, npoints, nfeatures, &c, nclusters, &xycref, &xydist2ref);
            for (i = 0; i < npoints; i++) {
               set_error_flag(othererrors, xyc.xZ[i] != xycref.xZ[i], __FILE__, __LINE__, "testclusteringunit.ap:1137");
               set_error_flag(othererrors, fabs(xydist2.xR[i] - xydist2ref.xR[i]) > 1.0E-6, __FILE__, __LINE__, "testclusteringunit.ap:1138");
            }
         }
      }
   }
// Test degenerate dataset (less than NClusters distinct points)
   for (nclusters = 2; nclusters <= 10; nclusters++) {
      for (initalgo = 0; initalgo <= 3; initalgo++) {
         for (pass = 1; pass <= 10; pass++) {
         // Initialize points. Two algorithms are used:
         // * initialization by small integers (no rounding problems)
         // * initialization by "long" fraction
            npoints = 100;
            nfeatures = 10;
            ae_matrix_set_length(&xy, npoints, nfeatures);
            if (hqrndnormal(&rs) > 0.0) {
               for (i = 0; i < nclusters - 1; i++) {
                  for (j = 0; j < nfeatures; j++) {
                     xy.xyR[i][j] = sin(hqrndnormal(&rs));
                  }
               }
            } else {
               for (i = 0; i < nclusters - 1; i++) {
                  for (j = 0; j < nfeatures; j++) {
                     xy.xyR[i][j] = (double)hqrnduniformi(&rs, 50);
                  }
               }
            }
            for (i = nclusters - 1; i < npoints; i++) {
               idx0 = hqrnduniformi(&rs, nclusters - 1);
               for (j = 0; j < nfeatures; j++) {
                  xy.xyR[i][j] = xy.xyR[idx0][j];
               }
            }
         // Clusterize with unlimited number of iterations.
         // Correct error code must be returned.
            clusterizercreate(&s);
            clusterizersetpoints(&s, &xy, npoints, nfeatures, 2);
            clusterizersetkmeanslimits(&s, 1, 0);
            clusterizersetkmeansinit(&s, initalgo);
            clusterizerrunkmeans(&s, nclusters, &rep);
            set_error_flag(othererrors, rep.terminationtype != -3, __FILE__, __LINE__, "testclusteringunit.ap:1185");
         }
      }
   }
// Test deterministic seed:
// * specyfying zero seed, or not specyfind seed at all = nondeterministic algo
// * nonzero zeed = deterministic algo
   for (initalgo = 0; initalgo <= 3; initalgo++) {
   // Initialize points.
      npoints = 100;
      nfeatures = 3;
      ae_matrix_set_length(&xy, npoints, nfeatures);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nfeatures; j++) {
            xy.xyR[i][j] = hqrndnormal(&rs);
         }
      }
   // Clusterize with negative seed.
   //
   // Perform multiple runs, compare results with
   // first one returned - at least one result must
   // be different.
      clusterizercreate(&s);
      clusterizersetpoints(&s, &xy, npoints, nfeatures, 2);
      clusterizersetkmeanslimits(&s, 1, 1);
      clusterizersetkmeansinit(&s, initalgo);
      clusterizersetseed(&s, -randominteger(3));
      allsame = true;
      for (pass = 0; pass <= 10; pass++) {
         clusterizerrunkmeans(&s, nclusters, &rep);
         set_error_flag(othererrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testclusteringunit.ap:1221");
         if (*othererrors) {
            ae_frame_leave();
            return;
         }
         if (pass == 0) {
         // Save clusters
            ae_matrix_set_length(&c, rep.c.rows, rep.c.cols);
            for (i = 0; i < rep.c.rows; i++) {
               for (j = 0; j < rep.c.cols; j++) {
                  c.xyR[i][j] = rep.c.xyR[i][j];
               }
            }
         } else {
         // Compare clusters with ones returned from first run.
            for (i = 0; i < rep.c.rows; i++) {
               for (j = 0; j < rep.c.cols; j++) {
                  allsame = allsame && c.xyR[i][j] == rep.c.xyR[i][j];
               }
            }
         }
      }
      set_error_flag(othererrors, allsame, __FILE__, __LINE__, "testclusteringunit.ap:1244");
   // Clusterize with positive seed.
   //
   // Perform multiple runs, compare results with
   // first one returned - all results must be same.
      clusterizercreate(&s);
      clusterizersetpoints(&s, &xy, npoints, nfeatures, 2);
      clusterizersetkmeanslimits(&s, 1, 1);
      clusterizersetkmeansinit(&s, initalgo);
      clusterizersetseed(&s, 1 + randominteger(3));
      allsame = true;
      for (pass = 0; pass <= 10; pass++) {
         clusterizerrunkmeans(&s, nclusters, &rep);
         set_error_flag(othererrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testclusteringunit.ap:1261");
         if (*othererrors) {
            ae_frame_leave();
            return;
         }
         if (pass == 0) {
         // Save clusters
            ae_matrix_set_length(&c, rep.c.rows, rep.c.cols);
            for (i = 0; i < rep.c.rows; i++) {
               for (j = 0; j < rep.c.cols; j++) {
                  c.xyR[i][j] = rep.c.xyR[i][j];
               }
            }
         } else {
         // Compare clusters with ones returned from first run.
            for (i = 0; i < rep.c.rows; i++) {
               for (j = 0; j < rep.c.cols; j++) {
                  allsame = allsame && c.xyR[i][j] == rep.c.xyR[i][j];
               }
            }
         }
      }
      set_error_flag(othererrors, !allsame, __FILE__, __LINE__, "testclusteringunit.ap:1284");
   // Clusterize with default seed.
   //
   // Perform multiple runs, compare results with
   // first one returned - all results must be same.
      clusterizercreate(&s);
      clusterizersetpoints(&s, &xy, npoints, nfeatures, 2);
      clusterizersetkmeanslimits(&s, 1, 1);
      clusterizersetkmeansinit(&s, initalgo);
      allsame = true;
      for (pass = 0; pass <= 10; pass++) {
         clusterizerrunkmeans(&s, nclusters, &rep);
         set_error_flag(othererrors, rep.terminationtype <= 0, __FILE__, __LINE__, "testclusteringunit.ap:1301");
         if (*othererrors) {
            ae_frame_leave();
            return;
         }
         if (pass == 0) {
         // Save clusters
            ae_matrix_set_length(&c, rep.c.rows, rep.c.cols);
            for (i = 0; i < rep.c.rows; i++) {
               for (j = 0; j < rep.c.cols; j++) {
                  c.xyR[i][j] = rep.c.xyR[i][j];
               }
            }
         } else {
         // Compare clusters with ones returned from first run.
            for (i = 0; i < rep.c.rows; i++) {
               for (j = 0; j < rep.c.cols; j++) {
                  allsame = allsame && c.xyR[i][j] == rep.c.xyR[i][j];
               }
            }
         }
      }
      set_error_flag(othererrors, !allsame, __FILE__, __LINE__, "testclusteringunit.ap:1324");
   }
   ae_frame_leave();
}

// This test checks algorithm ability to handle degenerate problems without
// causing infinite loop.
static void testclusteringunit_kmeansinfinitelooptest(bool *othererrors) {
   ae_frame _frame_block;
   ae_int_t npoints;
   ae_int_t nfeatures;
   ae_int_t nclusters;
   ae_int_t restarts;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(clusterizerstate, s);
   NewObj(kmeansreport, rep);
// Problem 1: all points are same.
//
// For NClusters=1 we must get correct solution, for NClusters>1 we must get failure.
   npoints = 100;
   nfeatures = 1;
   restarts = 5;
   ae_matrix_set_length(&xy, npoints, nfeatures);
   for (j = 0; j < nfeatures; j++) {
      xy.xyR[0][j] = randomreal();
   }
   for (i = 1; i < npoints; i++) {
      for (j = 0; j < nfeatures; j++) {
         xy.xyR[i][j] = xy.xyR[0][j];
      }
   }
   nclusters = 1;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, npoints, nfeatures, 2);
   clusterizersetkmeanslimits(&s, restarts, 0);
   clusterizerrunkmeans(&s, nclusters, &rep);
   *othererrors = *othererrors || rep.terminationtype <= 0;
   for (i = 0; i < nfeatures; i++) {
      *othererrors = *othererrors || fabs(rep.c.xyR[0][i] - xy.xyR[0][i]) > 1000 * machineepsilon;
   }
   for (i = 0; i < npoints; i++) {
      *othererrors = *othererrors || rep.cidx.xZ[i] != 0;
   }
   nclusters = 5;
   clusterizerrunkmeans(&s, nclusters, &rep);
   *othererrors = *othererrors || rep.terminationtype > 0;
// Problem 2: degenerate dataset (report by Andreas).
   npoints = 57;
   nfeatures = 1;
   restarts = 1;
   nclusters = 4;
   ae_matrix_set_length(&xy, npoints, nfeatures);
   xy.xyR[0][0] = 12.244689632138986;
   xy.xyR[1][0] = 12.244689632138982;
   xy.xyR[2][0] = 12.244689632138986;
   xy.xyR[3][0] = 12.244689632138982;
   xy.xyR[4][0] = 12.244689632138986;
   xy.xyR[5][0] = 12.244689632138986;
   xy.xyR[6][0] = 12.244689632138986;
   xy.xyR[7][0] = 12.244689632138986;
   xy.xyR[8][0] = 12.244689632138986;
   xy.xyR[9][0] = 12.244689632138986;
   xy.xyR[10][0] = 12.244689632138989;
   xy.xyR[11][0] = 12.244689632138984;
   xy.xyR[12][0] = 12.244689632138986;
   xy.xyR[13][0] = 12.244689632138986;
   xy.xyR[14][0] = 12.244689632138989;
   xy.xyR[15][0] = 12.244689632138986;
   xy.xyR[16][0] = 12.244689632138986;
   xy.xyR[17][0] = 12.244689632138986;
   xy.xyR[18][0] = 12.244689632138986;
   xy.xyR[19][0] = 12.244689632138989;
   xy.xyR[20][0] = 12.244689632138972;
   xy.xyR[21][0] = 12.244689632138986;
   xy.xyR[22][0] = 12.244689632138986;
   xy.xyR[23][0] = 12.244689632138986;
   xy.xyR[24][0] = 12.244689632138984;
   xy.xyR[25][0] = 12.244689632138982;
   xy.xyR[26][0] = 12.244689632138986;
   xy.xyR[27][0] = 12.244689632138986;
   xy.xyR[28][0] = 12.244689632138986;
   xy.xyR[29][0] = 12.244689632138986;
   xy.xyR[30][0] = 12.244689632138986;
   xy.xyR[31][0] = 12.244689632138986;
   xy.xyR[32][0] = 12.244689632138986;
   xy.xyR[33][0] = 12.244689632138986;
   xy.xyR[34][0] = 12.244689632138986;
   xy.xyR[35][0] = 12.244689632138982;
   xy.xyR[36][0] = 12.244689632138989;
   xy.xyR[37][0] = 12.244689632138986;
   xy.xyR[38][0] = 12.244689632138986;
   xy.xyR[39][0] = 12.244689632138986;
   xy.xyR[40][0] = 12.244689632138986;
   xy.xyR[41][0] = 12.244689632138986;
   xy.xyR[42][0] = 12.244689632138986;
   xy.xyR[43][0] = 12.244689632138986;
   xy.xyR[44][0] = 12.244689632138986;
   xy.xyR[45][0] = 12.244689632138986;
   xy.xyR[46][0] = 12.244689632138986;
   xy.xyR[47][0] = 12.244689632138986;
   xy.xyR[48][0] = 12.244689632138986;
   xy.xyR[49][0] = 12.244689632138986;
   xy.xyR[50][0] = 12.244689632138984;
   xy.xyR[51][0] = 12.244689632138986;
   xy.xyR[52][0] = 12.244689632138986;
   xy.xyR[53][0] = 12.244689632138986;
   xy.xyR[54][0] = 12.244689632138986;
   xy.xyR[55][0] = 12.244689632138986;
   xy.xyR[56][0] = 12.244689632138986;
   clusterizercreate(&s);
   clusterizersetpoints(&s, &xy, npoints, nfeatures, 2);
   clusterizersetkmeanslimits(&s, restarts, 0);
   clusterizerrunkmeans(&s, nclusters, &rep);
   *othererrors = *othererrors || rep.terminationtype <= 0;
   ae_frame_leave();
}

// This non-deterministic test checks that Restarts>1 significantly  improves
// quality of results.
//
// Subroutine generates random task 3 unit balls in 2D, each with 20  points,
// separated by 5 units wide gaps, and solves it  with  Restarts=1  and  with
// Restarts=5. Potential functions are compared,  outcome  of  the  trial  is
// either 0 or 1 (depending on what is better).
//
// Sequence of 1000 such tasks is  solved.  If  Restarts>1  actually  improve
// quality of solution, sum of outcome will be non-binomial.  If  it  doesn't
// matter, it will be binomially distributed.
//
// P.S. This test was added after report from Gianluca  Borello  who  noticed
// error in the handling of multiple restarts.
static void testclusteringunit_kmeansrestartstest(bool *converrors, bool *restartserrors) {
   ae_frame _frame_block;
   ae_int_t npoints;
   ae_int_t nvars;
   ae_int_t nclusters;
   ae_int_t clustersize;
   ae_int_t restarts;
   ae_int_t passcount;
   double sigmathreshold;
   double p;
   double s;
   ae_int_t i;
   ae_int_t j;
   ae_int_t pass;
   double ea;
   double eb;
   double v;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewObj(clusterizerstate, state);
   NewObj(kmeansreport, rep1);
   NewObj(kmeansreport, rep2);
   restarts = 5;
   passcount = 1000;
   clustersize = 20;
   nclusters = 3;
   nvars = 2;
   npoints = nclusters * clustersize;
   sigmathreshold = 5.0;
   ae_matrix_set_length(&xy, npoints, nvars);
   ae_vector_set_length(&tmp, nvars);
   p = 0.0;
   for (pass = 1; pass <= passcount; pass++) {
   // Fill
      for (i = 0; i < npoints; i++) {
         testclusteringunit_rsphere(&xy, nvars, i);
         for (j = 0; j < nvars; j++) {
            xy.xyR[i][j] += (double)i / clustersize * 5;
         }
      }
      clusterizercreate(&state);
      clusterizersetpoints(&state, &xy, npoints, nvars, 2);
   // Test: Restarts=1
      clusterizersetkmeanslimits(&state, 1, 0);
      clusterizerrunkmeans(&state, nclusters, &rep1);
      if (rep1.terminationtype <= 0) {
         *converrors = true;
         ae_frame_leave();
         return;
      }
      ea = 0.0;
      for (i = 0; i < npoints; i++) {
         ae_v_move(tmp.xR, 1, xy.xyR[i], 1, nvars);
         ae_v_sub(tmp.xR, 1, rep1.c.xyR[rep1.cidx.xZ[i]], 1, nvars);
         v = ae_v_dotproduct(tmp.xR, 1, tmp.xR, 1, nvars);
         ea += v;
      }
   // Test: Restarts>1
      clusterizersetkmeanslimits(&state, restarts, 0);
      clusterizerrunkmeans(&state, nclusters, &rep2);
      if (rep2.terminationtype <= 0) {
         *converrors = true;
         ae_frame_leave();
         return;
      }
      eb = 0.0;
      for (i = 0; i < npoints; i++) {
         ae_v_move(tmp.xR, 1, xy.xyR[i], 1, nvars);
         ae_v_sub(tmp.xR, 1, rep2.c.xyR[rep2.cidx.xZ[i]], 1, nvars);
         v = ae_v_dotproduct(tmp.xR, 1, tmp.xR, 1, nvars);
         eb += v;
      }
   // Calculate statistic.
      if (ea < eb) {
         p++;
      }
      if (ea == eb) {
         p += 0.5;
      }
   }
// If Restarts doesn't influence quality of centers found, P must be
// binomially distributed random value with mean 0.5*PassCount and
// standard deviation Sqrt(PassCount/4).
//
// If Restarts do influence quality of solution, P must be significantly
// lower than 0.5*PassCount.
   s = (p - 0.5 * passcount) / sqrt((double)passcount / 4.0);
   *restartserrors = *restartserrors || s > -sigmathreshold;
   ae_frame_leave();
}

// Testing clustering
bool testclustering(bool silent) {
   bool waserrors;
   bool basicahcerrors;
   bool ahcerrors;
   bool kmeansconverrors;
   bool kmeanssimpleerrors;
   bool kmeansothererrors;
   bool kmeansrestartserrors;
   ae_int_t passcount;
   ae_int_t nf;
   ae_int_t nc;
   bool result;
// AHC tests
   basicahcerrors = testclusteringunit_basicahctests();
   ahcerrors = testclusteringunit_advancedahctests();
// k-means tests
   passcount = 10;
   kmeansconverrors = false;
   kmeansothererrors = false;
   kmeanssimpleerrors = false;
   kmeansrestartserrors = false;
   testclusteringunit_kmeansspecialtests(&kmeansothererrors);
   testclusteringunit_kmeansinfinitelooptest(&kmeansothererrors);
   testclusteringunit_kmeansrestartstest(&kmeansconverrors, &kmeansrestartserrors);
   for (nf = 1; nf <= 5; nf++) {
      for (nc = 1; nc <= 5; nc++) {
         testclusteringunit_kmeanssimpletest1(nf, nc, passcount, &kmeansconverrors, &kmeansothererrors, &kmeanssimpleerrors);
      }
   }
// Results
   waserrors = false;
   waserrors = waserrors || (basicahcerrors || ahcerrors);
   waserrors = waserrors || (((kmeansconverrors || kmeansothererrors) || kmeanssimpleerrors) || kmeansrestartserrors);
   if (!silent) {
      printf("TESTING CLUSTERING\n");
      printf("AHC:                                \n");
      printf("* BASIC TESTS                       ");
      if (!basicahcerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* GENERAL TESTS                     ");
      if (!ahcerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("K-MEANS:                            \n");
      printf("* CONVERGENCE                       ");
      if (!kmeansconverrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* SIMPLE TASKS                      ");
      if (!kmeanssimpleerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* OTHER PROPERTIES                  ");
      if (!kmeansothererrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* RESTARTS PROPERTIES               ");
      if (!kmeansrestartserrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST FAILED\n");
      } else {
         printf("TEST PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === dforest testing unit ===
static const ae_int_t testdforestunit_algomax = 0;
static const ae_int_t testdforestunit_splitmax = 2;

// Unsets DF
static void testdforestunit_unsetdf(decisionforest *df) {
   ae_frame _frame_block;
   ae_int_t info;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(dfreport, rep);
   ae_matrix_set_length(&xy, 0 + 1, 1 + 1);
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = 0.0;
   dfbuildinternal(&xy, 1, 1, 1, 1, 1, 1, 0, &info, df, &rep);
   ae_frame_leave();
}

// Processing functions test
static void testdforestunit_testprocessing(bool *err) {
   ae_frame _frame_block;
   ae_int_t nvars;
   ae_int_t nclasses;
   ae_int_t ntrees;
   ae_int_t foresttype;
   ae_int_t npoints;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t i;
   ae_int_t j;
   bool allsame;
   double v;
   ae_frame_make(&_frame_block);
   NewObj(decisionforest, df1);
   NewObj(decisionforest, df2);
   NewObj(decisionforestbuilder, builder);
   NewObj(dfreport, rep);
   NewObj(decisionforestbuffer, buf);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   passcount = 100;
   hqrndrandomize(&rs);
// Main cycle
   for (pass = 1; pass <= passcount; pass++) {
   // initialize parameters
      nvars = 1 + hqrnduniformi(&rs, 5);
      nclasses = 1 + hqrnduniformi(&rs, 3);
      ntrees = 1 + hqrnduniformi(&rs, 4);
      foresttype = hqrnduniformi(&rs, 3);
   // Initialize arrays and data
      npoints = 10 + randominteger(50);
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      ae_vector_set_length(&y1, nclasses);
      ae_vector_set_length(&y2, nclasses);
      ae_matrix_set_length(&xy, npoints, nvars + 1);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            if (j % 2 == 0) {
               xy.xyR[i][j] = randommid();
            } else {
               xy.xyR[i][j] = (double)randominteger(2);
            }
         }
         if (nclasses == 1) {
            xy.xyR[i][nvars] = randommid();
         } else {
            xy.xyR[i][nvars] = (double)randominteger(nclasses);
         }
      }
   // create forest
      dfbuildercreate(&builder);
      dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
      dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
      dfbuildersetrdfsplitstrength(&builder, randominteger(testdforestunit_splitmax + 1));
      if (foresttype == 0) {
      // Build uncompressed random forest
         dfbuilderbuildrandomforest(&builder, ntrees, &df1, &rep);
      }
      if (foresttype == 1) {
      // Build uncompressed random forest, then perform 16-bit compression
         dfbuilderbuildrandomforest(&builder, ntrees, &df1, &rep);
         dfbinarycompression(&df1);
      }
      if (foresttype == 2) {
      // Build uncompressed random forest, then perform 8-bit compression
         dfbuilderbuildrandomforest(&builder, ntrees, &df1, &rep);
         dfbinarycompression8(&df1);
      }
      dfcreatebuffer(&df1, &buf);
   // Same inputs leads to same outputs
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nclasses; i++) {
         y1.xR[i] = randommid();
         y2.xR[i] = randommid();
      }
      dfprocess(&df1, &x1, &y1);
      dfprocess(&df1, &x2, &y2);
      allsame = true;
      for (i = 0; i < nclasses; i++) {
         allsame = allsame && y1.xR[i] == y2.xR[i];
      }
      *err = *err || !allsame;
   // DFProcess0 works as expected
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      ae_vector_set_length(&y1, nclasses);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nclasses; i++) {
         y1.xR[i] = hqrndnormal(&rs);
      }
      dfprocess(&df1, &x1, &y1);
      set_error_flag(err, fabs(y1.xR[0] - dfprocess0(&df1, &x2)) > 100 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:225");
   // DFClassify works as expected
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      ae_vector_set_length(&y1, nclasses);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      if (nclasses > 1) {
         for (i = 0; i < nclasses; i++) {
            y1.xR[i] = hqrndnormal(&rs);
         }
         dfprocess(&df1, &x1, &y1);
         j = dfclassify(&df1, &x2);
         for (i = 0; i < nclasses; i++) {
            set_error_flag(err, y1.xR[i] > y1.xR[j], __FILE__, __LINE__, "testdforestunit.ap:248");
         }
      } else {
         set_error_flag(err, dfclassify(&df1, &x2) != -1, __FILE__, __LINE__, "testdforestunit.ap:251");
      }
   // DFTsProcess() works as expected
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nclasses; i++) {
         y1.xR[i] = randommid();
         y2.xR[i] = randommid();
      }
      dfprocess(&df1, &x1, &y1);
      dftsprocess(&df1, &buf, &x2, &y2);
      allsame = true;
      for (i = 0; i < nclasses; i++) {
         allsame = allsame && y1.xR[i] == y2.xR[i];
      }
      set_error_flag(err, !allsame, __FILE__, __LINE__, "testdforestunit.ap:272");
   // Same inputs on original forest leads to same outputs
   // on copy created using DFCopy
      testdforestunit_unsetdf(&df2);
      dfcopy(&df1, &df2);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nclasses; i++) {
         y1.xR[i] = randommid();
         y2.xR[i] = randommid();
      }
      dfprocess(&df1, &x1, &y1);
      dfprocess(&df2, &x2, &y2);
      allsame = true;
      for (i = 0; i < nclasses; i++) {
         allsame = allsame && y1.xR[i] == y2.xR[i];
      }
      *err = *err || !allsame;
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      set_error_flag(err, fabs(dfprocess0(&df1, &x1) - dfprocess0(&df2, &x2)) > 100 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:303");
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      set_error_flag(err, dfclassify(&df1, &x1) != dfclassify(&df2, &x2), __FILE__, __LINE__, "testdforestunit.ap:309");
   // Same inputs on original forest leads to same outputs
   // on copy created using DFSerialize
      testdforestunit_unsetdf(&df2);
      {
      // This code passes data structure through serializers
      // (serializes it to string and loads back)
         ae_int_t _local_ssize;
         ae_frame _local_frame_block;
         ae_frame_make(&_local_frame_block);
         NewSerializer(_local_serializer);
         ae_serializer_alloc_start(&_local_serializer);
         dfalloc(&_local_serializer, &df1);
         _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
         NewBlock(_local_dynamic_block, _local_ssize + 1);
         ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
         dfserialize(&_local_serializer, &df1);
         ae_serializer_stop(&_local_serializer);
         ae_serializer_init(&_local_serializer);
         ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
         dfunserialize(&_local_serializer, &df2);
         ae_serializer_stop(&_local_serializer);
         ae_frame_leave();
      }
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nclasses; i++) {
         y1.xR[i] = randommid();
         y2.xR[i] = randommid();
      }
      dfprocess(&df1, &x1, &y1);
      dfprocess(&df2, &x2, &y2);
      allsame = true;
      for (i = 0; i < nclasses; i++) {
         allsame = allsame && y1.xR[i] == y2.xR[i];
      }
      *err = *err || !allsame;
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      set_error_flag(err, fabs(dfprocess0(&df1, &x1) - dfprocess0(&df2, &x2)) > 100 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:339");
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      set_error_flag(err, dfclassify(&df1, &x1) != dfclassify(&df2, &x2), __FILE__, __LINE__, "testdforestunit.ap:345");
   // Normalization properties
      if (nclasses > 1) {
         for (i = 0; i < nvars; i++) {
            x1.xR[i] = randommid();
         }
         dfprocess(&df1, &x1, &y1);
         v = 0.0;
         for (i = 0; i < nclasses; i++) {
            v += y1.xR[i];
            *err = *err || y1.xR[i] < 0.0;
         }
         *err = *err || fabs(v - 1) > 1000 * machineepsilon;
      }
   }
   ae_frame_leave();
}

// Basic test:  one-tree uncompressed forest built using full sample must
// remember all training cases.
//
// Special relaxed testing is performed for compressed forests.
static void testdforestunit_basictest1(bool *err) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t i;
   ae_int_t j;
   double s;
   ae_int_t info;
   ae_int_t nvars;
   ae_int_t nclasses;
   ae_int_t passcount;
   double tol16;
   double tol8;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforestbuilder, builder);
   NewObj(decisionforest, df);
   NewObj(decisionforest, df1);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(dfreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   tol16 = 0.0001;
   tol8 = 0.01;
// Test uncompressed forest
   passcount = 10;
   for (nvars = 1; nvars <= 4; nvars++) {
      for (nclasses = 1; nclasses <= 3; nclasses++) {
         for (pass = 0; pass < passcount; pass++) {
         // select number of points
            if (pass < 3 && passcount > 3) {
               npoints = 1 + pass;
            } else {
               npoints = 100 + hqrnduniformi(&rs, 100);
            }
         // Prepare task
            ae_matrix_set_length(&xy, npoints, nvars + 1);
            ae_vector_set_length(&x, nvars);
            ae_vector_set_length(&y, nclasses);
            for (i = 0; i < npoints; i++) {
               xy.xyR[i][0] = (double)i;
               for (j = 1; j < nvars; j++) {
                  xy.xyR[i][j] = hqrndnormal(&rs);
               }
               if (nclasses > 1) {
                  xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
               } else {
                  xy.xyR[i][nvars] = hqrndnormal(&rs);
               }
            }
         // Train
         //
         // NOTE: we also test obsolete forest construction functions
            ae_assert(passcount >= 2, "RDF: test integrity failed");
            ntrees = 1;
            if (pass > 0) {
            // Test new interface
               dfbuildercreate(&builder);
               dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
               dfbuildersetsubsampleratio(&builder, 1.0);
               if (randombool()) {
                  dfbuildersetrndvars(&builder, nvars);
               } else {
                  dfbuildersetrndvarsratio(&builder, 1.0);
               }
               dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
               dfbuildersetrdfsplitstrength(&builder, randominteger(testdforestunit_splitmax + 1));
               dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
            } else {
            // Test old interface
               if (hqrnduniformi(&rs, 2) == 0) {
                  dfbuildrandomdecisionforest(&xy, npoints, nvars, nclasses, ntrees, 1.0, &info, &df, &rep);
               } else {
                  dfbuildrandomdecisionforestx1(&xy, npoints, nvars, nclasses, ntrees, 1, 1.0, &info, &df, &rep);
               }
               if (info <= 0) {
                  set_error_flag(err, true, __FILE__, __LINE__, "testdforestunit.ap:467");
                  ae_frame_leave();
                  return;
               }
            }
         // Test
            set_error_flag(err, fabs(rep.rmserror) > 1.0E-9, __FILE__, __LINE__, "testdforestunit.ap:475");
            set_error_flag(err, fabs(rep.avgerror) > 1.0E-9, __FILE__, __LINE__, "testdforestunit.ap:476");
            set_error_flag(err, fabs(rep.avgrelerror) > 1.0E-9, __FILE__, __LINE__, "testdforestunit.ap:477");
            set_error_flag(err, fabs(rep.relclserror) > 0.0, __FILE__, __LINE__, "testdforestunit.ap:478");
            set_error_flag(err, fabs(rep.avgce) > 0.0, __FILE__, __LINE__, "testdforestunit.ap:479");
            for (i = 0; i < npoints; i++) {
               ae_v_move(x.xR, 1, xy.xyR[i], 1, nvars);
               dfprocess(&df, &x, &y);
               if (nclasses > 1) {
               // Checks for classification tasks
                  s = 0.0;
                  for (j = 0; j < nclasses; j++) {
                     set_error_flag(err, y.xR[j] < 0.0, __FILE__, __LINE__, "testdforestunit.ap:492");
                     s += y.xR[j];
                  }
                  set_error_flag(err, fabs(s - 1) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:495");
                  set_error_flag(err, fabs(y.xR[iround(xy.xyR[i][nvars])] - 1) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:496");
               } else {
               // Regression problem
                  set_error_flag(err, fabs(y.xR[0] - xy.xyR[i][nvars]) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:503");
               }
            }
         }
      }
   }
// Test compressed forest
   nvars = 1;
   npoints = 100;
   for (nclasses = 1; nclasses <= 3; nclasses++) {
      for (pass = 0; pass < passcount; pass++) {
      // Dataset
         ae_matrix_set_length(&xy, npoints, nvars + 1);
         ae_vector_set_length(&x, nvars);
         ae_vector_set_length(&y, nclasses);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = (double)i;
            if (nclasses > 1) {
               xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
            } else {
               xy.xyR[i][nvars] = hqrnduniformr(&rs) - 0.5;
            }
         }
      // Train
         ntrees = 1;
         dfbuildercreate(&builder);
         dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
         dfbuildersetsubsampleratio(&builder, 1.0);
         dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
         set_error_flag(err, fabs(rep.rmserror) > 1.0E-9, __FILE__, __LINE__, "testdforestunit.ap:541");
         set_error_flag(err, fabs(rep.avgerror) > 1.0E-9, __FILE__, __LINE__, "testdforestunit.ap:542");
         set_error_flag(err, fabs(rep.avgrelerror) > 1.0E-9, __FILE__, __LINE__, "testdforestunit.ap:543");
         set_error_flag(err, fabs(rep.relclserror) > 0.0, __FILE__, __LINE__, "testdforestunit.ap:544");
         set_error_flag(err, fabs(rep.avgce) > 0.0, __FILE__, __LINE__, "testdforestunit.ap:545");
      // Test 16-bit compression
         dfcopy(&df, &df1);
         dfbinarycompression(&df1);
         for (i = 0; i < npoints; i++) {
            x.xR[0] = xy.xyR[i][0];
            dfprocess(&df1, &x, &y);
            if (nclasses > 1) {
            // Checks for classification tasks
               s = 0.0;
               for (j = 0; j < nclasses; j++) {
                  set_error_flag(err, y.xR[j] < 0.0, __FILE__, __LINE__, "testdforestunit.ap:564");
                  s += y.xR[j];
               }
               set_error_flag(err, fabs(s - 1) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:567");
               set_error_flag(err, fabs(y.xR[iround(xy.xyR[i][nvars])] - 1) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:568");
            } else {
            // Regression problem
               set_error_flag(err, fabs(y.xR[0] - xy.xyR[i][nvars]) > tol16, __FILE__, __LINE__, "testdforestunit.ap:575");
            }
         }
      // Test 8-bit compression
         dfcopy(&df, &df1);
         dfbinarycompression8(&df1);
         for (i = 0; i < npoints; i++) {
            x.xR[0] = xy.xyR[i][0];
            dfprocess(&df1, &x, &y);
            if (nclasses > 1) {
            // Checks for classification tasks
               s = 0.0;
               for (j = 0; j < nclasses; j++) {
                  set_error_flag(err, y.xR[j] < 0.0, __FILE__, __LINE__, "testdforestunit.ap:596");
                  s += y.xR[j];
               }
               set_error_flag(err, fabs(s - 1) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:599");
               set_error_flag(err, fabs(y.xR[iround(xy.xyR[i][nvars])] - 1) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:600");
            } else {
            // Regression problem
               set_error_flag(err, fabs(y.xR[0] - xy.xyR[i][nvars]) > tol8, __FILE__, __LINE__, "testdforestunit.ap:607");
            }
         }
      }
   }
   ae_frame_leave();
}

// Basic test:  tests generalization ability on a simple noisy classification
// task:
// * 0<x<1 - P(class=0)=1
// * 1<x<2 - P(class=0)=2-x
// * 2<x<3 - P(class=0)=0
static void testdforestunit_basictest2(bool *err) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t i;
   double avgerr;
   ae_int_t cnt;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforest, df);
   NewObj(decisionforestbuilder, builder);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(dfreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   passcount = 1;
   for (pass = 1; pass <= passcount; pass++) {
   // select npoints and ntrees
      npoints = 3000;
      ntrees = 100;
   // Prepare task
      ae_matrix_set_length(&xy, npoints, 2);
      ae_vector_set_length(&x, 1);
      ae_vector_set_length(&y, 2);
      for (i = 0; i < npoints; i++) {
         xy.xyR[i][0] = 3 * hqrnduniformr(&rs);
         if (xy.xyR[i][0] <= 1.0) {
            xy.xyR[i][1] = 0.0;
         } else {
            if (xy.xyR[i][0] <= 2.0) {
               if (hqrnduniformr(&rs) < xy.xyR[i][0] - 1) {
                  xy.xyR[i][1] = 1.0;
               } else {
                  xy.xyR[i][1] = 0.0;
               }
            } else {
               xy.xyR[i][1] = 1.0;
            }
         }
      }
   // Build forest
      dfbuildercreate(&builder);
      dfbuildersetdataset(&builder, &xy, npoints, 1, 2);
      dfbuildersetsubsampleratio(&builder, 0.05);
      dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
      dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
   // Check report fields
      set_error_flag(err, fabs(rep.oobrelclserror - 1.0 / 12.0) > 0.50 * (1.0 / 12.0), __FILE__, __LINE__, "testdforestunit.ap:684");
      set_error_flag(err, rep.relclserror > rep.oobrelclserror, __FILE__, __LINE__, "testdforestunit.ap:685");
      set_error_flag(err, rep.avgce >= rep.oobavgce, __FILE__, __LINE__, "testdforestunit.ap:686");
      set_error_flag(err, rep.rmserror >= rep.oobrmserror, __FILE__, __LINE__, "testdforestunit.ap:687");
      set_error_flag(err, rep.avgerror >= rep.oobavgerror, __FILE__, __LINE__, "testdforestunit.ap:688");
      set_error_flag(err, rep.avgrelerror >= rep.oobavgrelerror, __FILE__, __LINE__, "testdforestunit.ap:689");
   // Check outputs
      avgerr = 0.0;
      cnt = 0;
      x.xR[0] = 0.0;
      while (x.xR[0] <= 3.0) {
         dfprocess(&df, &x, &y);
      // Test for basic properties
         set_error_flag(err, y.xR[0] < 0.0, __FILE__, __LINE__, "testdforestunit.ap:704");
         set_error_flag(err, y.xR[1] < 0.0, __FILE__, __LINE__, "testdforestunit.ap:705");
         set_error_flag(err, fabs(y.xR[0] + y.xR[1] - 1) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:706");
      // test for good correlation with results
         if (x.xR[0] < 1.0) {
            avgerr += fabs(1 - y.xR[0]);
         }
         if (x.xR[0] >= 1.0 && x.xR[0] <= 2.0) {
            avgerr += fabs(y.xR[1] - (x.xR[0] - 1));
         }
         if (x.xR[0] > 2.0) {
            avgerr += fabs(1 - y.xR[1]);
         }
         cnt++;
      // Advance
         x.xR[0] += 0.01;
      }
      avgerr /= cnt;
      set_error_flag(err, avgerr > 0.05, __FILE__, __LINE__, "testdforestunit.ap:725");
   }
   ae_frame_leave();
}

// Basic test:  tests  generalization ability on a simple classification task
// (no noise):
// * |x|<1, |y|<1
// * x^2+y^2 <= 0.25 - P(class=0)=1
// * x^2+y^2>0.25  - P(class=0)=0
static void testdforestunit_basictest3(bool *err) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t i;
   ae_int_t j;
   ae_int_t info;
   ae_int_t testgridsize;
   double r;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforestbuilder, builder);
   NewObj(decisionforest, df);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(dfreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   passcount = 2;
   testgridsize = 50;
   for (pass = 0; pass < passcount; pass++) {
   // select npoints and ntrees
      npoints = 2000;
      ntrees = 100;
   // Prepare task
      ae_matrix_set_length(&xy, npoints, 3);
      ae_vector_set_length(&x, 2);
      ae_vector_set_length(&y, 2);
      for (i = 0; i < npoints; i++) {
         xy.xyR[i][0] = 2 * hqrnduniformr(&rs) - 1;
         xy.xyR[i][1] = 2 * hqrnduniformr(&rs) - 1;
         if (sqr(xy.xyR[i][0]) + sqr(xy.xyR[i][1]) <= 0.25) {
            xy.xyR[i][2] = 0.0;
         } else {
            xy.xyR[i][2] = 1.0;
         }
      }
   // Build forest
   //
   // NOTE: we also test obsolete forest construction functions
      ae_assert(passcount >= 2, "RDF: test integrity failed");
      if (pass > 0) {
      // Test new interface
         dfbuildercreate(&builder);
         dfbuildersetdataset(&builder, &xy, npoints, 2, 2);
         dfbuildersetsubsampleratio(&builder, 0.10);
         dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
         dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
      } else {
      // Test old interface
         if (hqrnduniformi(&rs, 2) == 0) {
            dfbuildrandomdecisionforest(&xy, npoints, 2, 2, ntrees, 0.10, &info, &df, &rep);
         } else {
            dfbuildrandomdecisionforestx1(&xy, npoints, 2, 2, ntrees, 1, 0.10, &info, &df, &rep);
         }
         if (info <= 0) {
            set_error_flag(err, true, __FILE__, __LINE__, "testdforestunit.ap:813");
            ae_frame_leave();
            return;
         }
      }
   // Test
      for (i = -testgridsize / 2; i <= testgridsize / 2; i++) {
         for (j = -testgridsize / 2; j <= testgridsize / 2; j++) {
            x.xR[0] = (double)i / (testgridsize / 2);
            x.xR[1] = (double)j / (testgridsize / 2);
            dfprocess(&df, &x, &y);
         // Test for basic properties
            set_error_flag(err, y.xR[0] < 0.0, __FILE__, __LINE__, "testdforestunit.ap:831");
            set_error_flag(err, y.xR[1] < 0.0, __FILE__, __LINE__, "testdforestunit.ap:832");
            set_error_flag(err, fabs(y.xR[0] + y.xR[1] - 1) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:833");
         // test for good correlation with results
            r = sqrt(sqr(x.xR[0]) + sqr(x.xR[1]));
            if (r < 0.66 * 0.5) {
               set_error_flag(err, y.xR[0] < 0.66, __FILE__, __LINE__, "testdforestunit.ap:840");
            }
            if (r > 1.33 * 0.5) {
               set_error_flag(err, y.xR[1] < 0.66, __FILE__, __LINE__, "testdforestunit.ap:842");
            }
         }
      }
   }
   ae_frame_leave();
}

// Basic test: simple regression task without noise:
// * |x|<1, |y|<1
// * F(x,y) = x^2+y
static void testdforestunit_basictest4(bool *err) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t i;
   ae_int_t j;
   ae_int_t info;
   ae_int_t testgridsize;
   double maxerr;
   double avgerr;
   ae_int_t cnt;
   double ey;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforest, df);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(dfreport, rep);
   NewObj(decisionforestbuilder, builder);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   passcount = 2;
   testgridsize = 50;
   for (pass = 0; pass < passcount; pass++) {
   // select npoints and ntrees
      npoints = 5000;
      ntrees = 100;
   // Prepare task
      ae_matrix_set_length(&xy, npoints, 3);
      ae_vector_set_length(&x, 2);
      ae_vector_set_length(&y, 1);
      for (i = 0; i < npoints; i++) {
         xy.xyR[i][0] = 2 * hqrnduniformr(&rs) - 1;
         xy.xyR[i][1] = 2 * hqrnduniformr(&rs) - 1;
         xy.xyR[i][2] = sqr(xy.xyR[i][0]) + xy.xyR[i][1];
      }
   // Build forest
   //
   // NOTE: we also test obsolete forest construction functions
      ae_assert(passcount >= 2, "RDF: test integrity failed");
      if (pass > 0) {
      // Test new interface
         dfbuildercreate(&builder);
         dfbuildersetdataset(&builder, &xy, npoints, 2, 1);
         dfbuildersetsubsampleratio(&builder, 0.10);
         dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
         dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
      } else {
      // Test old interface
         if (hqrnduniformi(&rs, 2) == 0) {
            dfbuildrandomdecisionforest(&xy, npoints, 2, 1, ntrees, 0.10, &info, &df, &rep);
         } else {
            dfbuildrandomdecisionforestx1(&xy, npoints, 2, 1, ntrees, 1, 0.10, &info, &df, &rep);
         }
         if (info <= 0) {
            set_error_flag(err, true, __FILE__, __LINE__, "testdforestunit.ap:931");
            ae_frame_leave();
            return;
         }
      }
   // Check report fields
      set_error_flag(err, rep.relclserror != 0.0, __FILE__, __LINE__, "testdforestunit.ap:939");
      set_error_flag(err, rep.avgce != 0.0, __FILE__, __LINE__, "testdforestunit.ap:940");
      set_error_flag(err, rep.oobrelclserror != 0.0, __FILE__, __LINE__, "testdforestunit.ap:941");
      set_error_flag(err, rep.oobavgce != 0.0, __FILE__, __LINE__, "testdforestunit.ap:942");
      set_error_flag(err, rep.rmserror >= rep.oobrmserror, __FILE__, __LINE__, "testdforestunit.ap:943");
      set_error_flag(err, rep.avgerror >= rep.oobavgerror, __FILE__, __LINE__, "testdforestunit.ap:944");
      set_error_flag(err, rep.avgrelerror >= rep.oobavgrelerror, __FILE__, __LINE__, "testdforestunit.ap:945");
      set_error_flag(err, rep.oobrmserror > 0.05, __FILE__, __LINE__, "testdforestunit.ap:946");
      set_error_flag(err, rep.oobavgerror > 0.05, __FILE__, __LINE__, "testdforestunit.ap:947");
      set_error_flag(err, rep.oobrmserror < 0.001, __FILE__, __LINE__, "testdforestunit.ap:948");
      set_error_flag(err, rep.oobavgerror < 0.001, __FILE__, __LINE__, "testdforestunit.ap:949");
   // Test
      maxerr = 0.0;
      avgerr = 0.0;
      cnt = 0;
      for (i = iround(-0.7 * testgridsize / 2); i <= iround(0.7 * testgridsize / 2); i++) {
         for (j = iround(-0.7 * testgridsize / 2); j <= iround(0.7 * testgridsize / 2); j++) {
            x.xR[0] = (double)i / (testgridsize / 2);
            x.xR[1] = (double)j / (testgridsize / 2);
            ey = sqr(x.xR[0]) + x.xR[1];
            dfprocess(&df, &x, &y);
            maxerr = rmax2(maxerr, fabs(y.xR[0] - ey));
            avgerr += fabs(y.xR[0] - ey);
            cnt++;
         }
      }
      avgerr /= cnt;
      set_error_flag(err, maxerr > 0.15, __FILE__, __LINE__, "testdforestunit.ap:969");
      set_error_flag(err, avgerr > 0.05, __FILE__, __LINE__, "testdforestunit.ap:970");
   }
   ae_frame_leave();
}

// Basic test: extended variable selection leads to better results.
//
// Next task CAN be solved without EVS but it is very unlikely. With EVS
// it can be easily and exactly solved.
//
// Task matrix:
//     1 0 0 0 ... 0   0
//     0 1 0 0 ... 0   1
//     0 0 1 0 ... 0   2
//     0 0 0 1 ... 0   3
//     0 0 0 0 ... 1   N-1
static void testdforestunit_basictest5(bool *err) {
   ae_frame _frame_block;
   ae_int_t nvars;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t i;
   ae_int_t j;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforestbuilder, builder);
   NewObj(decisionforest, df);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(dfreport, rep);
// select npoints and ntrees
   npoints = 50;
   nvars = npoints;
   ntrees = 1;
// Prepare task
   ae_matrix_set_length(&xy, npoints, nvars + 1);
   ae_vector_set_length(&x, nvars);
   ae_vector_set_length(&y, 1);
   for (i = 0; i < npoints; i++) {
      for (j = 0; j < nvars; j++) {
         xy.xyR[i][j] = 0.0;
      }
      xy.xyR[i][i] = 1.0;
      xy.xyR[i][nvars] = (double)i;
   }
// Build forest
   dfbuildercreate(&builder);
   dfbuildersetdataset(&builder, &xy, npoints, nvars, 1);
   dfbuildersetsubsampleratio(&builder, 1.00);
   dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
   dfbuildersetrdfsplitstrength(&builder, randominteger(testdforestunit_splitmax + 1));
   dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
// Test
   set_error_flag(err, rep.rmserror >= rep.oobrmserror, __FILE__, __LINE__, "testdforestunit.ap:1039");
   set_error_flag(err, rep.avgerror >= rep.oobavgerror, __FILE__, __LINE__, "testdforestunit.ap:1040");
   set_error_flag(err, rep.avgrelerror >= rep.oobavgrelerror, __FILE__, __LINE__, "testdforestunit.ap:1041");
   set_error_flag(err, fabs(rep.rmserror) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:1042");
   set_error_flag(err, fabs(rep.avgerror) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:1043");
   set_error_flag(err, fabs(rep.avgrelerror) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:1044");
   for (i = 0; i < npoints; i++) {
      ae_v_move(x.xR, 1, xy.xyR[i], 1, nvars);
      dfprocess(&df, &x, &y);
      if (fabs(y.xR[0] - xy.xyR[i][nvars]) > 1000 * machineepsilon) {
         set_error_flag(err, true, __FILE__, __LINE__, "testdforestunit.ap:1050");
      }
   }
   ae_frame_leave();
}

// Basic test: test correctness of error reports on completely random problem;
// test that OOB errors are roughly unbiased.
static void testdforestunit_basictestrandom(bool *err) {
   ae_frame _frame_block;
   ae_int_t nvars;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t nclasses;
   ae_int_t i;
   ae_int_t j;
   ae_int_t factor;
   double meanlevel;
   double sigma;
   double v;
   double refavgce;
   double refrms;
   double refavg;
   double refavgrel;
   ae_int_t relcnt;
   double oobtol;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforestbuilder, builder);
   NewObj(decisionforest, df);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(dfreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   npoints = 200;
   nvars = 10;
   ntrees = 1000;
   oobtol = 0.15;
   for (nclasses = 1; nclasses <= 3; nclasses++) {
   // Prepare task
      ae_matrix_set_length(&xy, npoints, nvars + 1);
      meanlevel = 10 * hqrndnormal(&rs);
      sigma = pow(10.0, hqrndnormal(&rs));
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            xy.xyR[i][j] = 0.0;
            if (j % 3 == 0) {
               xy.xyR[i][j] = hqrndnormal(&rs);
            }
            if (j % 3 == 1 && hqrnduniformr(&rs) < 0.05) {
               xy.xyR[i][j] = 1.0;
            }
            if (j % 3 == 2 && hqrnduniformr(&rs) < 0.05) {
               xy.xyR[i][j] = (double)(1 + hqrnduniformi(&rs, 3));
            }
         }
         if (nclasses == 1) {
            xy.xyR[i][nvars] = meanlevel + sigma * hqrndnormal(&rs);
            if (hqrnduniformr(&rs) < 0.05) {
               xy.xyR[i][nvars] = 0.0;
            }
         } else {
            xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
         }
      }
      ae_vector_set_length(&x, nvars);
      ae_vector_set_length(&y, nclasses);
   // Build forest using 50% and 66% of the samples.
   // Check TRN and OOB errors (OOB should be 2x and 3x larger in these cases)
      for (factor = 2; factor <= 3; factor++) {
         j = hqrnduniformi(&rs, 3);
         dfbuildercreate(&builder);
         dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
         dfbuildersetsubsampleratio(&builder, 1 - 1.0 / factor);
         if (j > 0) {
            dfbuildersetrndvars(&builder, 1 + hqrnduniformi(&rs, 5));
         }
         if (j == 0) {
            dfbuildersetrndvarsauto(&builder);
         }
         if (j < 0) {
            dfbuildersetrndvarsratio(&builder, hqrnduniformr(&rs));
         }
         dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
         dfbuildersetrdfsplitstrength(&builder, randominteger(testdforestunit_splitmax + 1));
         set_error_flag(err, dfbuildergetprogress(&builder) != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1139");
         set_error_flag(err, dfbuilderpeekprogress(&builder) != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1140");
         dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
         set_error_flag(err, dfbuildergetprogress(&builder) != 1.0, __FILE__, __LINE__, "testdforestunit.ap:1142");
         set_error_flag(err, dfbuilderpeekprogress(&builder) != 1.0, __FILE__, __LINE__, "testdforestunit.ap:1143");
         refavgce = 0.0;
         refrms = 0.0;
         refavg = 0.0;
         refavgrel = 0.0;
         relcnt = 0;
         if (nclasses == 1) {
         // Check training set errors
            for (i = 0; i < npoints; i++) {
               for (j = 0; j < nvars; j++) {
                  x.xR[j] = xy.xyR[i][j];
               }
               dfprocess(&df, &x, &y);
               v = y.xR[0] - xy.xyR[i][nvars];
               refrms += sqr(v);
               refavg += fabs(v);
               if (xy.xyR[i][nvars] != 0.0) {
                  refavgrel += fabs(v / xy.xyR[i][nvars]);
                  relcnt++;
               }
            }
            refrms = sqrt(refrms / npoints);
            refavg /= npoints;
            refavgrel /= coalesce((double)relcnt, 1.0);
            set_error_flag(err, rep.relclserror != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1171");
            set_error_flag(err, rep.avgce != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1172");
            set_error_flag(err, fabs(rep.rmserror - refrms) / refrms > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1173");
            set_error_flag(err, fabs(rep.avgerror - refavg) / refavg > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1174");
            set_error_flag(err, fabs(rep.avgrelerror - refavgrel) / refavgrel > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1175");
            set_error_flag(err, dfrelclserror(&df, &xy, npoints) != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1176");
            set_error_flag(err, dfavgce(&df, &xy, npoints) != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1177");
            set_error_flag(err, fabs(dfrmserror(&df, &xy, npoints) - refrms) / refrms > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1178");
            set_error_flag(err, fabs(dfavgerror(&df, &xy, npoints) - refavg) / refavg > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1179");
            set_error_flag(err, fabs(dfavgrelerror(&df, &xy, npoints) - refavgrel) / refavgrel > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1180");
         // Check OOB errors against training set errors:
         // * RelCLS and AvgCE are not calculated for regression problems
         // * RMS and AVG should be roughly FACTOR times larger
         // * AVG-REL should be just larger (it is more prone to sampling noise than previous two)
            set_error_flag(err, rep.oobrelclserror != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1188");
            set_error_flag(err, rep.oobavgce != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1189");
            set_error_flag(err, fabs(rep.oobrmserror / rep.rmserror - factor) > oobtol * factor, __FILE__, __LINE__, "testdforestunit.ap:1190");
            set_error_flag(err, fabs(rep.oobavgerror / rep.avgerror - factor) > oobtol * factor, __FILE__, __LINE__, "testdforestunit.ap:1191");
            set_error_flag(err, rep.oobavgrelerror < rep.avgrelerror, __FILE__, __LINE__, "testdforestunit.ap:1192");
         } else {
         // Check training set errors
            for (i = 0; i < npoints; i++) {
               for (j = 0; j < nvars; j++) {
                  x.xR[j] = xy.xyR[i][j];
               }
               dfprocess(&df, &x, &y);
               for (j = 0; j < nclasses; j++) {
                  v = y.xR[j];
                  if ((double)j == xy.xyR[i][nvars]) {
                     v--;
                  }
                  refrms += sqr(v);
                  refavg += fabs(v);
                  if ((double)j == xy.xyR[i][nvars]) {
                     refavgrel += fabs(v);
                     refavgce -= log(v);
                  }
               }
            }
            refrms = sqrt(refrms / (npoints * nclasses));
            refavg /= npoints * nclasses;
            refavgrel /= npoints;
            refavgce /= npoints;
            set_error_flag(err, fabs(rep.avgce - refavgce) / refavgce > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1222");
            set_error_flag(err, fabs(rep.rmserror - refrms) / refrms > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1223");
            set_error_flag(err, fabs(rep.avgerror - refavg) / refavg > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1224");
            set_error_flag(err, fabs(rep.avgrelerror - refavgrel) / refavgrel > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1225");
            set_error_flag(err, fabs(dfrelclserror(&df, &xy, npoints) - rep.relclserror) * npoints > 5.0, __FILE__, __LINE__, "testdforestunit.ap:1227");
            set_error_flag(err, fabs(dfavgce(&df, &xy, npoints) - refavgce) / refavgce > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1228");
            set_error_flag(err, fabs(dfrmserror(&df, &xy, npoints) - refrms) / refrms > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1229");
            set_error_flag(err, fabs(dfavgerror(&df, &xy, npoints) - refavg) / refavg > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1230");
            set_error_flag(err, fabs(dfavgrelerror(&df, &xy, npoints) - refavgrel) / refavgrel > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1231");
         // Check OOB errors against training set errors
         // * RelCLS, AvgCE and AvgRel should be just larger (too prone to sampling noise to perform more sensitive tests)
         // * RMS and AVG should be roughly FACTOR times larger
         //
            set_error_flag(err, rep.oobrelclserror < rep.relclserror, __FILE__, __LINE__, "testdforestunit.ap:1239");
            set_error_flag(err, rep.oobavgce < rep.avgce, __FILE__, __LINE__, "testdforestunit.ap:1240");
            set_error_flag(err, rep.oobavgrelerror < rep.avgrelerror, __FILE__, __LINE__, "testdforestunit.ap:1241");
            set_error_flag(err, fabs(rep.oobrmserror / rep.rmserror - factor) > oobtol * factor, __FILE__, __LINE__, "testdforestunit.ap:1242");
            set_error_flag(err, fabs(rep.oobavgerror / rep.avgerror - factor) > oobtol * factor, __FILE__, __LINE__, "testdforestunit.ap:1243");
         }
      }
   }
   ae_frame_leave();
}

// Test behavior of the RDF algorithm on problem where all values of variables
// are same
static void testdforestunit_basictestallsame(bool *err) {
   ae_frame _frame_block;
   ae_int_t nvars;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t nclasses;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double refavgce;
   double refrms;
   double refavg;
   double refavgrel;
   ae_int_t relcnt;
   double oobtol;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforestbuilder, builder);
   NewObj(decisionforest, df);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(dfreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   npoints = 100;
   nvars = 10;
   ntrees = 100;
   oobtol = 0.25;
   for (nclasses = 1; nclasses <= 3; nclasses++) {
   // Prepare task
      ae_matrix_set_length(&xy, npoints, nvars + 1);
      k = hqrnduniformi(&rs, 11) - 5;
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            xy.xyR[i][j] = (double)k;
         }
         if (nclasses == 1) {
            xy.xyR[i][nvars] = hqrndnormal(&rs);
         } else {
            xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
         }
      }
      ae_vector_set_length(&x, nvars);
      ae_vector_set_length(&y, nclasses);
   // Build forest.
   // Check TRN and OOB errors.
      j = hqrnduniformi(&rs, 3);
      dfbuildercreate(&builder);
      dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
      dfbuildersetsubsampleratio(&builder, 0.5);
      if (j > 0) {
         dfbuildersetrndvars(&builder, 1 + hqrnduniformi(&rs, 5));
      }
      if (j == 0) {
         dfbuildersetrndvarsauto(&builder);
      }
      if (j < 0) {
         dfbuildersetrndvarsratio(&builder, hqrnduniformr(&rs));
      }
      dfbuildersetrdfalgo(&builder, randominteger(testdforestunit_algomax + 1));
      dfbuildersetrdfsplitstrength(&builder, randominteger(testdforestunit_splitmax + 1));
      dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
      refavgce = 0.0;
      refrms = 0.0;
      refavg = 0.0;
      refavgrel = 0.0;
      relcnt = 0;
      if (nclasses == 1) {
      // Check training set errors
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nvars; j++) {
               x.xR[j] = xy.xyR[i][j];
            }
            dfprocess(&df, &x, &y);
            v = y.xR[0] - xy.xyR[i][nvars];
            refrms += sqr(v);
            refavg += fabs(v);
            if (xy.xyR[i][nvars] != 0.0) {
               refavgrel += fabs(v / xy.xyR[i][nvars]);
               relcnt++;
            }
         }
         refrms = sqrt(refrms / npoints);
         refavg /= npoints;
         refavgrel /= coalesce((double)relcnt, 1.0);
         set_error_flag(err, rep.relclserror != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1346");
         set_error_flag(err, rep.avgce != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1347");
         set_error_flag(err, fabs(rep.rmserror - refrms) / refrms > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1348");
         set_error_flag(err, fabs(rep.avgerror - refavg) / refavg > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1349");
         set_error_flag(err, fabs(rep.avgrelerror - refavgrel) / refavgrel > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1350");
      // Check OOB errors against training set errors:
      // * RelCLS and AvgCE are not calculated for regression problems
      // * RMS and AVG should be roughly same
         set_error_flag(err, rep.oobrelclserror != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1357");
         set_error_flag(err, rep.oobavgce != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1358");
         set_error_flag(err, fabs(rep.oobrmserror / rep.rmserror - 1) > oobtol, __FILE__, __LINE__, "testdforestunit.ap:1359");
         set_error_flag(err, fabs(rep.oobavgerror / rep.avgerror - 1) > oobtol, __FILE__, __LINE__, "testdforestunit.ap:1360");
      } else {
      // Check training set errors
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nvars; j++) {
               x.xR[j] = xy.xyR[i][j];
            }
            dfprocess(&df, &x, &y);
            for (j = 0; j < nclasses; j++) {
               v = y.xR[j];
               if ((double)j == xy.xyR[i][nvars]) {
                  v--;
               }
               refrms += sqr(v);
               refavg += fabs(v);
               if ((double)j == xy.xyR[i][nvars]) {
                  refavgrel += fabs(v);
                  refavgce -= log(v);
               }
            }
         }
         refrms = sqrt(refrms / (npoints * nclasses));
         refavg /= npoints * nclasses;
         refavgrel /= npoints;
         refavgce /= npoints;
         set_error_flag(err, fabs(rep.avgce - refavgce) / refavgce > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1390");
         set_error_flag(err, fabs(rep.rmserror - refrms) / refrms > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1391");
         set_error_flag(err, fabs(rep.avgerror - refavg) / refavg > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1392");
         set_error_flag(err, fabs(rep.avgrelerror - refavgrel) / refavgrel > 1.0E-6, __FILE__, __LINE__, "testdforestunit.ap:1393");
      // Check OOB errors against training set errors
      // * RMS and AVG should be roughly same
      //
         set_error_flag(err, fabs(rep.oobrmserror / rep.rmserror - 1) > oobtol, __FILE__, __LINE__, "testdforestunit.ap:1400");
         set_error_flag(err, fabs(rep.oobavgerror / rep.avgerror - 1) > oobtol, __FILE__, __LINE__, "testdforestunit.ap:1401");
      }
   }
   ae_frame_leave();
}

// Test model compression - that it works and generates forests which correctly
// reproduce original one
static void testdforestunit_testcompression(bool *err) {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t npoints;
   ae_int_t ntrees;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t nvars;
   ae_int_t nclasses;
   double tol16;
   double tol8;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(decisionforestbuilder, builder);
   NewObj(decisionforest, dfraw);
   NewObj(decisionforest, df16);
   NewObj(decisionforest, df8);
   NewVector(x, 0, DT_REAL);
   NewVector(y0, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewObj(dfreport, rep);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
   tol16 = 0.0001;
   tol8 = 0.01;
// Test compression on small-scale problems:
// * a K-dimensional input, with 3^K distinct points located at integer grid
// * we test that compressed model produces roughly same results as uncompressed
//   one (predicts same class / predicts same scalar output subject to small
//   truncation error)
   for (nvars = 1; nvars <= 5; nvars++) {
      for (nclasses = 1; nclasses <= 3; nclasses++) {
         ae_vector_set_length(&x, nvars);
         ae_vector_set_length(&y0, nclasses);
         ae_vector_set_length(&y1, nclasses);
      // Generate dataset
         npoints = iround(pow(3.0, (double)nvars));
         ae_matrix_set_length(&xy, npoints, nvars + 1);
         for (i = 0; i < npoints; i++) {
            k = i;
            for (j = 0; j < nvars; j++) {
               xy.xyR[i][j] = (double)(k % 3 - 1);
               k /= 3;
            }
            if (nclasses == 1) {
               xy.xyR[i][nvars] = hqrnduniformr(&rs) - 0.5;
            } else {
               xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
            }
         }
      // Train uncompressed
         ntrees = 1 + hqrnduniformi(&rs, 10);
         dfbuildercreate(&builder);
         dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
         dfbuildersetsubsampleratio(&builder, 0.66);
         dfbuilderbuildrandomforest(&builder, ntrees, &dfraw, &rep);
      // Test 16-bit compression
         dfcopy(&dfraw, &df16);
         dfbinarycompression(&df16);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nvars; j++) {
               x.xR[j] = xy.xyR[i][j];
            }
            dfprocess(&dfraw, &x, &y0);
            dfprocess(&df16, &x, &y1);
            if (nclasses > 1) {
            // Compare output probabilities for classification problem
               for (j = 0; j < nclasses; j++) {
                  set_error_flag(err, fabs(y0.xR[j] - y1.xR[j]) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:1495");
               }
            } else {
            // Compare output values for regression problem
               set_error_flag(err, fabs(y0.xR[0] - y1.xR[0]) > tol16, __FILE__, __LINE__, "testdforestunit.ap:1502");
            }
         }
      // Test 8-bit compression
         dfcopy(&dfraw, &df8);
         dfbinarycompression8(&df8);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nvars; j++) {
               x.xR[j] = xy.xyR[i][j];
            }
            dfprocess(&dfraw, &x, &y0);
            dfprocess(&df8, &x, &y1);
            if (nclasses > 1) {
            // Compare output probabilities for classification problem
               for (j = 0; j < nclasses; j++) {
                  set_error_flag(err, fabs(y0.xR[j] - y1.xR[j]) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:1523");
               }
            } else {
            // Compare output values for regression problem
               set_error_flag(err, fabs(y0.xR[0] - y1.xR[0]) > tol8, __FILE__, __LINE__, "testdforestunit.ap:1530");
            }
         }
      }
   }
// Test compression on large-scale problems:
// * NVars=500, NPoints=500, I-th point is zero except for I-th position
// * NClasses=1 (random output) or NClasses=400
// * NTrees is in 1...5
   for (pass = 0; pass <= 1; pass++) {
   // Set up problem
      ae_assert(pass == 0 || pass == 1, "DF: integrity check failed");
      nvars = 500;
      npoints = 500;
      nclasses = 1;
      if (pass == 1) {
         nclasses = 400;
      }
      ae_matrix_set_length(&xy, npoints, nvars + 1);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            xy.xyR[i][j] = 0.0;
         }
         xy.xyR[i][i] = 1.0;
         if (nclasses == 1) {
            xy.xyR[i][nvars] = hqrnduniformr(&rs) - 0.5;
         } else {
            xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
         }
      }
      ae_vector_set_length(&x, nvars);
      ae_vector_set_length(&y0, nclasses);
      ae_vector_set_length(&y1, nclasses);
   // Train uncompressed
      ntrees = 1 + hqrnduniformi(&rs, 5);
      dfbuildercreate(&builder);
      dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
      dfbuildersetsubsampleratio(&builder, 0.66);
      dfbuilderbuildrandomforest(&builder, ntrees, &dfraw, &rep);
   // Test 16-bit compression
      dfcopy(&dfraw, &df16);
      dfbinarycompression(&df16);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            x.xR[j] = xy.xyR[i][j];
         }
         dfprocess(&dfraw, &x, &y0);
         dfprocess(&df16, &x, &y1);
         if (nclasses > 1) {
         // Compare output probabilities for classification problem
            for (j = 0; j < nclasses; j++) {
               set_error_flag(err, fabs(y0.xR[j] - y1.xR[j]) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:1593");
            }
         } else {
         // Compare output values for regression problem
            set_error_flag(err, fabs(y0.xR[0] - y1.xR[0]) > tol16, __FILE__, __LINE__, "testdforestunit.ap:1600");
         }
      }
   // Test 8-bit compression
      dfcopy(&dfraw, &df8);
      dfbinarycompression8(&df8);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            x.xR[j] = xy.xyR[i][j];
         }
         dfprocess(&dfraw, &x, &y0);
         dfprocess(&df8, &x, &y1);
         if (nclasses > 1) {
         // Compare output probabilities for classification problem
            for (j = 0; j < nclasses; j++) {
               set_error_flag(err, fabs(y0.xR[j] - y1.xR[j]) > 1000 * machineepsilon, __FILE__, __LINE__, "testdforestunit.ap:1621");
            }
         } else {
         // Compare output values for regression problem
            set_error_flag(err, fabs(y0.xR[0] - y1.xR[0]) > tol8, __FILE__, __LINE__, "testdforestunit.ap:1628");
         }
      }
   }
   ae_frame_leave();
}

// Randomly rearranges XY, using one of the algorithms:
// * in 50% of cases does nothing
// * in 50% of cases sorts by dependent variable (last column)
//
// Such rearrangement can be used to catch errors related to different processing
// of different parts of dataset
static void testdforestunit_randomlyrearrange(RMatrix *xy, ae_int_t npoints, ae_int_t nvars, hqrndstate *rs) {
   ae_frame _frame_block;
   ae_int_t kind;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewVector(y, 0, DT_REAL);
   NewVector(p1, 0, DT_INT);
   NewVector(p2, 0, DT_INT);
   kind = hqrnduniformi(rs, nvars + 2);
   if (kind == nvars + 1) {
      ae_frame_leave();
      return;
   }
   ae_vector_set_length(&y, npoints);
   for (i = 0; i < npoints; i++) {
      y.xR[i] = xy->xyR[i][kind];
   }
   tagsort(&y, npoints, &p1, &p2);
   for (i = 0; i < npoints; i++) {
      swaprows(xy, i, p2.xZ[i], nvars + 1);
   }
   ae_frame_leave();
}

// Test variable importance
static void testdforestunit_testimportance(bool *err) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t i1;
   ae_int_t npoints;
   ae_int_t npoints2;
   ae_int_t nvars;
   ae_int_t nclasses;
   ae_int_t ntrees;
   double v;
   double unimportantlo;
   double unimportanthi;
   double importantlo;
   double importanthi;
   ae_int_t ntype;
   ae_int_t ntypes;
   ae_int_t stype;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewMatrix(xyp, 0, 0, DT_REAL);
   NewVector(c, 0, DT_REAL);
   NewVector(vloss, 0, DT_REAL);
   NewVector(tmp, 0, DT_REAL);
   NewObj(decisionforestbuilder, builder);
   NewObj(decisionforest, df);
   NewObj(dfreport, rep);
   NewObj(hqrndstate, rs);
   ntypes = 3;
   hqrndrandomize(&rs);
// Test that default state of importance estimation is off
   npoints = 50;
   ntrees = 50;
   for (nclasses = 1; nclasses <= 3; nclasses++) {
   // Generate dataset
      nvars = 1 + hqrnduniformi(&rs, 3);
      ae_matrix_set_length(&xy, npoints, nvars + 1);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            xy.xyR[i][j] = hqrndnormal(&rs);
         }
         if (nclasses == 1) {
            xy.xyR[i][nvars] = hqrnduniformr(&rs) - 0.5;
         } else {
            xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
         }
      }
   // Train with default settings, check that variable importances reported are zero
      dfbuildercreate(&builder);
      dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
      dfbuildersetsubsampleratio(&builder, 0.66);
      dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
      set_error_flag(err, rep.varimportances.cnt != nvars, __FILE__, __LINE__, "testdforestunit.ap:1694");
      set_error_flag(err, rep.topvars.cnt != nvars, __FILE__, __LINE__, "testdforestunit.ap:1695");
      if (*err) {
         ae_frame_leave();
         return;
      }
      for (j = 0; j < nvars; j++) {
         set_error_flag(err, rep.varimportances.xR[j] != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1700");
         set_error_flag(err, rep.topvars.xZ[j] != j, __FILE__, __LINE__, "testdforestunit.ap:1701");
      }
   }
// Test that degenerate cases are handled correctly
   npoints = 50;
   ntrees = 50;
   for (nclasses = 1; nclasses <= 3; nclasses++) {
      for (npoints = 1; npoints <= 2; npoints++) {
         for (stype = 0; stype <= 1; stype++) {
            for (ntype = 0; ntype < ntypes; ntype++) {
            // Generate dataset
               nvars = 1 + hqrnduniformi(&rs, 3);
               ae_matrix_set_length(&xy, npoints, nvars + 1);
               for (i = 0; i < npoints; i++) {
                  for (j = 0; j < nvars; j++) {
                     xy.xyR[i][j] = hqrndnormal(&rs);
                  }
                  if (nclasses == 1) {
                     xy.xyR[i][nvars] = hqrnduniformr(&rs) - 0.5;
                  } else {
                     xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
                  }
               }
            // Train
               dfbuildercreate(&builder);
               dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
               dfbuildersetsubsampleratio(&builder, 1.0 - stype * 0.5);
               ae_assert(ntype <= 2, "integrity check in the test");
               if (ntype == 0) {
                  dfbuildersetimportanceoobgini(&builder);
               }
               if (ntype == 1) {
                  dfbuildersetimportancepermutation(&builder);
               }
               if (ntype == 2) {
                  dfbuildersetimportancetrngini(&builder);
               }
               dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
               set_error_flag(err, rep.varimportances.cnt != nvars, __FILE__, __LINE__, "testdforestunit.ap:1744");
               set_error_flag(err, rep.topvars.cnt != nvars, __FILE__, __LINE__, "testdforestunit.ap:1745");
               if (*err) {
                  ae_frame_leave();
                  return;
               }
               if (npoints == 1 || stype == 1) {
                  for (j = 0; j < nvars; j++) {
                     set_error_flag(err, rep.varimportances.xR[j] != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1752");
                     set_error_flag(err, rep.topvars.xZ[j] != j, __FILE__, __LINE__, "testdforestunit.ap:1753");
                  }
               }
            }
         }
      }
   }
// Test various importance types
   for (ntype = 0; ntype < ntypes; ntype++) {
   // Select variables count
      nvars = 1 + hqrnduniformi(&rs, 3);
   // Select preferred problem metrics for this importance type
      npoints = -1;
      ntrees = -1;
      unimportantlo = -1.0;
      unimportanthi = -1.0;
      importantlo = -1.0;
      importanthi = -1.0;
      if (ntype == 0) {
      // OOB Gini importance averages individual importances between multiple trees,
      // so its variance is inversely proportional to the tree count. Tasks with large number
      // of trees are preferred.
         npoints = 250;
         ntrees = 1000;
         unimportantlo = 0.00;
         unimportanthi = 0.25;
         importantlo = 0.75 * (1.0 / nvars);
         importanthi = rmin2(1.25 * (1.0 / nvars), 1.00);
      }
      if (ntype == 1) {
      // Variance of permutation importance estimate is inversely proportional to the
      // dataset size. Tasks with large number of points are preferred, trees count
      // does not matter much here.
         npoints = 5000;
         ntrees = 10;
         unimportantlo = 0.00;
         unimportanthi = 0.15;
         importantlo = 0.85;
         importanthi = 1.00;
      }
      if (ntype == 2) {
      // TRN Gini importance averages individual importances between multiple trees,
      // so its variance is inversely proportional to the tree count. Tasks with large number
      // of trees are preferred.
         npoints = 250;
         ntrees = 1000;
         unimportantlo = 0.70 * (1.0 / nvars);
         unimportanthi = rmin2(1.30 * (1.0 / nvars), 1.00);
         importantlo = 0.70 * (1.0 / nvars);
         importanthi = rmin2(1.30 * (1.0 / nvars), 1.00);
      }
   // Test on a problem with completely random outputs
      for (nclasses = 1; nclasses <= 3; nclasses++) {
      // Generate dataset
         ae_matrix_set_length(&xy, npoints, nvars + 1);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nvars; j++) {
               xy.xyR[i][j] = hqrndnormal(&rs);
            }
            if (nclasses == 1) {
               xy.xyR[i][nvars] = hqrnduniformr(&rs) - 0.5;
            } else {
               xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nclasses);
            }
         }
         testdforestunit_randomlyrearrange(&xy, npoints, nvars, &rs);
      // Train
         dfbuildercreate(&builder);
         dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
         dfbuildersetsubsampleratio(&builder, 0.66);
         dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
         ae_assert(ntype <= 2, "integrity check in the test");
         if (ntype == 0) {
            dfbuildersetimportanceoobgini(&builder);
         }
         if (ntype == 1) {
            dfbuildersetimportancepermutation(&builder);
         }
         if (ntype == 2) {
            dfbuildersetimportancetrngini(&builder);
         }
         dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
         set_error_flag(err, rep.varimportances.cnt != nvars, __FILE__, __LINE__, "testdforestunit.ap:1855");
         set_error_flag(err, rep.topvars.cnt != nvars, __FILE__, __LINE__, "testdforestunit.ap:1856");
         if (*err) {
            ae_frame_leave();
            return;
         }
         for (j = 0; j < nvars; j++) {
            set_error_flag(err, rep.varimportances.xR[j] < unimportantlo, __FILE__, __LINE__, "testdforestunit.ap:1863");
            set_error_flag(err, rep.varimportances.xR[j] > unimportanthi, __FILE__, __LINE__, "testdforestunit.ap:1864");
         }
         setlengthzero(&tmp, nvars);
         for (j = 0; j < nvars; j++) {
            set_error_flag(err, rep.topvars.xZ[j] < 0, __FILE__, __LINE__, "testdforestunit.ap:1869");
            set_error_flag(err, rep.topvars.xZ[j] >= nvars, __FILE__, __LINE__, "testdforestunit.ap:1870");
            if (*err) {
               ae_frame_leave();
               return;
            }
            set_error_flag(err, tmp.xR[rep.topvars.xZ[j]] != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1873");
            tmp.xR[rep.topvars.xZ[j]]++;
         }
         for (j = 0; j < nvars - 1; j++) {
            set_error_flag(err, rep.varimportances.xR[rep.topvars.xZ[j]] < rep.varimportances.xR[rep.topvars.xZ[j + 1]], __FILE__, __LINE__, "testdforestunit.ap:1877");
         }
         if (ntype == 2) {
         // TRN-Gini importances sum to 1.0
            v = 0.0;
            for (j = 0; j < nvars; j++) {
               v += rep.varimportances.xR[j];
            }
            set_error_flag(err, fabs(v - 1) > 1.0e-6, __FILE__, __LINE__, "testdforestunit.ap:1886");
         }
      }
   // Test that on a problem where:
   // * every variable matters
   // * every variable is critical
   // * result is completely predictable.
      for (nclasses = 1; nclasses <= 3; nclasses++) {
      // Generate dataset
         ae_matrix_set_length(&xy, npoints, nvars + 1);
         for (i = 0; i < npoints; i++) {
            if (nclasses == 1) {
               xy.xyR[i][nvars] = 0.0;
               k = i;
               for (j = 0; j < nvars; j++) {
                  xy.xyR[i][j] = (double)(k % 3);
                  xy.xyR[i][nvars] += round(xy.xyR[i][j]);
                  k /= 3;
               }
               xy.xyR[i][nvars] = (double)(iround(xy.xyR[i][nvars]) % 3 - 1);
            } else {
               xy.xyR[i][nvars] = 0.0;
               k = i;
               for (j = 0; j < nvars; j++) {
                  xy.xyR[i][j] = (double)(k % nclasses);
                  xy.xyR[i][nvars] += round(xy.xyR[i][j]);
                  k /= nclasses;
               }
               xy.xyR[i][nvars] = (double)(iround(xy.xyR[i][nvars]) % nclasses);
            }
         }
         testdforestunit_randomlyrearrange(&xy, npoints, nvars, &rs);
      // Train
         dfbuildercreate(&builder);
         dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
         dfbuildersetsubsampleratio(&builder, 0.5);
         dfbuildersetrndvars(&builder, nvars);
         ae_assert(ntype <= 2, "integrity check in the test");
         if (ntype == 0) {
            dfbuildersetimportanceoobgini(&builder);
         }
         if (ntype == 1) {
            dfbuildersetimportancepermutation(&builder);
         }
         if (ntype == 2) {
            dfbuildersetimportancetrngini(&builder);
         }
         dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
         set_error_flag(err, rep.varimportances.cnt != nvars, __FILE__, __LINE__, "testdforestunit.ap:1946");
         set_error_flag(err, rep.topvars.cnt != nvars, __FILE__, __LINE__, "testdforestunit.ap:1947");
         if (*err) {
            ae_frame_leave();
            return;
         }
         for (j = 0; j < nvars; j++) {
            set_error_flag(err, rep.varimportances.xR[j] < importantlo, __FILE__, __LINE__, "testdforestunit.ap:1954");
            set_error_flag(err, rep.varimportances.xR[j] > importanthi, __FILE__, __LINE__, "testdforestunit.ap:1955");
         }
         setlengthzero(&tmp, nvars);
         for (j = 0; j < nvars; j++) {
            set_error_flag(err, rep.topvars.xZ[j] < 0, __FILE__, __LINE__, "testdforestunit.ap:1960");
            set_error_flag(err, rep.topvars.xZ[j] >= nvars, __FILE__, __LINE__, "testdforestunit.ap:1961");
            if (*err) {
               ae_frame_leave();
               return;
            }
            set_error_flag(err, tmp.xR[rep.topvars.xZ[j]] != 0.0, __FILE__, __LINE__, "testdforestunit.ap:1964");
            tmp.xR[rep.topvars.xZ[j]]++;
         }
         for (j = 0; j < nvars - 1; j++) {
            set_error_flag(err, rep.varimportances.xR[rep.topvars.xZ[j]] < rep.varimportances.xR[rep.topvars.xZ[j + 1]], __FILE__, __LINE__, "testdforestunit.ap:1968");
         }
         if (ntype == 2) {
         // TRN-Gini importances sum to 1.0
            v = 0.0;
            for (j = 0; j < nvars; j++) {
               v += rep.varimportances.xR[j];
            }
            set_error_flag(err, fabs(v - 1) > 1.0e-6, __FILE__, __LINE__, "testdforestunit.ap:1977");
         }
      }
   }
// Test values computed by the fast MDA (permutation) algorithm against
// ones computed by definition (by simply running model on permuted dataset).
//
// We solve regression and 2-class classification problems.
//
// Large "reference" dataset is used to compute reference importances in order
// to reduce variance of at least one component in the difference |I_reference-I_computed|
   npoints = 5000;
   ntrees = 10;
   npoints2 = npoints;
   for (nclasses = 1; nclasses <= 2; nclasses++) {
   // Generate dataset
      nvars = 3;
      ae_vector_set_length(&c, nvars);
      for (j = 0; j < nvars; j++) {
         c.xR[j] = pow(2.0, (double)-j);
      }
      ae_matrix_set_length(&xy2, npoints + npoints2, nvars + 1);
      for (i = 0; i < npoints + npoints2; i++) {
         xy2.xyR[i][nvars] = 0.01 * hqrndnormal(&rs);
         for (j = 0; j < nvars; j++) {
            xy2.xyR[i][j] = hqrnduniformr(&rs) - 0.5;
            xy2.xyR[i][nvars] += xy2.xyR[i][j] * c.xR[j];
         }
         if (nclasses == 2) {
            if (xy2.xyR[i][nvars] > 0.0) {
               xy2.xyR[i][nvars] = 0.0;
            } else {
               xy2.xyR[i][nvars] = 1.0;
            }
         }
      }
      ae_matrix_set_length(&xy, npoints, nvars + 1);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j <= nvars; j++) {
            xy.xyR[i][j] = xy2.xyR[npoints2 + i][j];
         }
      }
      rmatrixresize(&xy2, npoints2, nvars + 1);
      testdforestunit_randomlyrearrange(&xy, npoints, nvars, &rs);
   // Train model
      dfbuildercreate(&builder);
      dfbuildersetdataset(&builder, &xy, npoints, nvars, nclasses);
      dfbuildersetsubsampleratio(&builder, 0.5);
      dfbuildersetimportancepermutation(&builder);
      dfbuildersetrndvars(&builder, nvars);
      dfbuilderbuildrandomforest(&builder, ntrees, &df, &rep);
      set_error_flag(err, rep.varimportances.cnt != nvars, __FILE__, __LINE__, "testdforestunit.ap:2036");
      set_error_flag(err, rep.topvars.cnt != nvars, __FILE__, __LINE__, "testdforestunit.ap:2037");
      if (*err) {
         ae_frame_leave();
         return;
      }
   // Compute importances by definition
      ae_matrix_set_length(&xyp, npoints2, nvars + 1);
      ae_vector_set_length(&vloss, nvars + 2);
      for (k = 0; k <= nvars + 1; k++) {
         for (i = 0; i < npoints2; i++) {
            for (j = 0; j <= nvars; j++) {
               xyp.xyR[i][j] = xy2.xyR[i][j];
            }
         }
         if (k < nvars) {
            for (i = 0; i < npoints2; i++) {
               i1 = i + hqrnduniformi(&rs, npoints2 - i);
               v = xyp.xyR[i][k];
               xyp.xyR[i][k] = xyp.xyR[i1][k];
               xyp.xyR[i1][k] = v;
            }
         }
         if (k == nvars + 1) {
            for (j = 0; j < nvars; j++) {
               for (i = 0; i < npoints2; i++) {
                  i1 = i + hqrnduniformi(&rs, npoints2 - i);
                  v = xyp.xyR[i][j];
                  xyp.xyR[i][j] = xyp.xyR[i1][j];
                  xyp.xyR[i1][j] = v;
               }
            }
         }
         vloss.xR[k] = sqr(dfrmserror(&df, &xyp, npoints2)) * npoints2 * nclasses + 1.0e-20;
      }
   // Compare
      for (k = 0; k < nvars; k++) {
         v = 1 - vloss.xR[nvars] / vloss.xR[nvars + 1] - (1 - vloss.xR[k] / vloss.xR[nvars + 1]);
         set_error_flag(err, fabs(v - rep.varimportances.xR[k]) > 0.25, __FILE__, __LINE__, "testdforestunit.ap:2081");
      }
   }
   ae_frame_leave();
}

bool testdforest(bool silent) {
   bool waserrors;
   bool basicerrors;
   bool procerrors;
   bool compressionerrors;
   bool importanceerrors;
   bool result;
// Primary settings
   basicerrors = false;
   procerrors = false;
   compressionerrors = false;
   importanceerrors = false;
   waserrors = false;
// Tests
   testdforestunit_testprocessing(&procerrors);
   testdforestunit_basictest1(&basicerrors);
   testdforestunit_basictest2(&basicerrors);
   testdforestunit_basictest3(&basicerrors);
   testdforestunit_basictest4(&basicerrors);
   testdforestunit_basictest5(&basicerrors);
   testdforestunit_basictestrandom(&basicerrors);
   testdforestunit_basictestallsame(&basicerrors);
   testdforestunit_testcompression(&compressionerrors);
   testdforestunit_testimportance(&importanceerrors);
// Final report
   waserrors = ((basicerrors || procerrors) || compressionerrors) || importanceerrors;
   if (!silent) {
      printf("RANDOM FOREST TEST\n");
      printf("TOTAL RESULTS:                           ");
      if (!waserrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* PROCESSING FUNCTIONS:                  ");
      if (!procerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* BASIC TESTS:                           ");
      if (!basicerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* COMPRESSION TESTS:                     ");
      if (!compressionerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* VARIABLE IMPORTANCE TESTS:             ");
      if (!importanceerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST SUMMARY: FAILED\n");
      } else {
         printf("TEST SUMMARY: PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === linreg testing unit ===
// Task generation. Meaningless task, just random numbers.
static void testlinregunit_generaterandomtask(double xl, double xr, bool randomx, double ymin, double ymax, double smin, double smax, ae_int_t n, RMatrix *xy, RVector *s) {
   ae_int_t i;
   ae_matrix_set_length(xy, n - 1 + 1, 1 + 1);
   ae_vector_set_length(s, n - 1 + 1);
   for (i = 0; i < n; i++) {
      if (randomx) {
         xy->xyR[i][0] = xl + (xr - xl) * randomreal();
      } else {
         xy->xyR[i][0] = xl + (xr - xl) * i / (n - 1);
      }
      xy->xyR[i][1] = ymin + (ymax - ymin) * randomreal();
      s->xR[i] = smin + (smax - smin) * randomreal();
   }
}

// Normal random numbers
static double testlinregunit_generatenormal(double mean, double sigma) {
   double u;
   double v;
   double sum;
   double result;
   result = mean;
   while (true) {
      u = (2 * randominteger(2) - 1) * randomreal();
      v = (2 * randominteger(2) - 1) * randomreal();
      sum = u * u + v * v;
      if (sum < 1.0 && sum > 0.0) {
         sum = sqrt(-2 * log(sum) / sum);
         result = sigma * u * sum + mean;
         break;
      }
   }
   return result;
}

// Task generation.
static void testlinregunit_generatetask(double a, double b, double xl, double xr, bool randomx, double smin, double smax, ae_int_t n, RMatrix *xy, RVector *s) {
   ae_int_t i;
   ae_matrix_set_length(xy, n - 1 + 1, 1 + 1);
   ae_vector_set_length(s, n - 1 + 1);
   for (i = 0; i < n; i++) {
      if (randomx) {
         xy->xyR[i][0] = xl + (xr - xl) * randomreal();
      } else {
         xy->xyR[i][0] = xl + (xr - xl) * i / (n - 1);
      }
      s->xR[i] = smin + (smax - smin) * randomreal();
      xy->xyR[i][1] = a + b * xy->xyR[i][0] + testlinregunit_generatenormal(0.0, s->xR[i]);
   }
}

// Task generation.
// y[i] are filled based on A, B, X[I], S[I]
static void testlinregunit_filltaskwithy(double a, double b, ae_int_t n, RMatrix *xy, RVector *s) {
   ae_int_t i;
   for (i = 0; i < n; i++) {
      xy->xyR[i][1] = a + b * xy->xyR[i][0] + testlinregunit_generatenormal(0.0, s->xR[i]);
   }
}

// Moments estimates and their errors
static void testlinregunit_calculatemv(RVector *x, ae_int_t n, double *mean, double *means, double *stddev, double *stddevs) {
   ae_int_t i;
   double v1;
   double v2;
   double variance;
   *mean = 0;
   *means = 0;
   *stddev = 0;
   *stddevs = 0;
   *mean = 0.0;
   *means = 1.0;
   *stddev = 0.0;
   *stddevs = 1.0;
   variance = 0.0;
   if (n <= 1) {
      return;
   }
// Mean
   for (i = 0; i < n; i++) {
      *mean += x->xR[i];
   }
   *mean /= n;
// Variance (using corrected two-pass algorithm)
   if (n != 1) {
      v1 = 0.0;
      for (i = 0; i < n; i++) {
         v1 += sqr(x->xR[i] - (*mean));
      }
      v2 = 0.0;
      for (i = 0; i < n; i++) {
         v2 += (x->xR[i] - (*mean));
      }
      v2 = sqr(v2) / n;
      variance = (v1 - v2) / (n - 1);
      if (variance < 0.0) {
         variance = 0.0;
      }
      *stddev = sqrt(variance);
   }
// Errors
   *means = *stddev / sqrt((double)n);
   *stddevs = *stddev * sqrt(2.0) / sqrt((double)(n - 1));
}

// Unsets LR
static void testlinregunit_unsetlr(linearmodel *lr) {
   ae_frame _frame_block;
   ae_int_t info;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(lrreport, rep);
   ae_matrix_set_length(&xy, 5 + 1, 1 + 1);
   for (i = 0; i <= 5; i++) {
      xy.xyR[i][0] = 0.0;
      xy.xyR[i][1] = 0.0;
   }
   lrbuild(&xy, 6, 1, &info, lr, &rep);
   ae_assert(info > 0, "Assertion failed");
   ae_frame_leave();
}

bool testlinreg(bool silent) {
   ae_frame _frame_block;
   double sigmathreshold;
   ae_int_t maxn;
   ae_int_t passcount;
   ae_int_t estpasscount;
   double threshold;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t tmpi;
   ae_int_t pass;
   ae_int_t epass;
   ae_int_t m;
   ae_int_t tasktype;
   ae_int_t modeltype;
   ae_int_t m1;
   ae_int_t m2;
   ae_int_t n1;
   ae_int_t n2;
   ae_int_t info;
   ae_int_t info2;
   double y1;
   double y2;
   bool allsame;
   double ea;
   double eb;
   double varatested;
   double varbtested;
   double a;
   double b;
   double vara;
   double varb;
   double a2;
   double b2;
   double covab;
   double corrab;
   double p;
   ae_int_t qcnt;
   double f;
   double fp;
   double fm;
   double v;
   double vv;
   double cvrmserror;
   double cvavgerror;
   double cvavgrelerror;
   double rmserror;
   double avgerror;
   double avgrelerror;
   bool nondefect;
   double sinshift;
   double tasklevel;
   double noiselevel;
   double hstep;
   double sigma;
   double mean;
   double means;
   double stddev;
   double stddevs;
   bool slcerrors;
   bool slerrors;
   bool grcoverrors;
   bool gropterrors;
   bool gresterrors;
   bool grothererrors;
   bool grconverrors;
   bool waserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(xy2, 0, 0, DT_REAL);
   NewVector(s, 0, DT_REAL);
   NewVector(s2, 0, DT_REAL);
   NewVector(w2, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(ta, 0, DT_REAL);
   NewVector(tb, 0, DT_REAL);
   NewVector(tc, 0, DT_REAL);
   NewVector(xy0, 0, DT_REAL);
   NewVector(tmpweights, 0, DT_REAL);
   NewObj(linearmodel, w);
   NewObj(linearmodel, wt);
   NewObj(linearmodel, wt2);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(qtbl, 0, DT_REAL);
   NewVector(qvals, 0, DT_REAL);
   NewVector(qsigma, 0, DT_REAL);
   NewObj(lrreport, ar);
   NewObj(lrreport, ar2);
// Primary settings
   maxn = 40;
   passcount = 3;
   estpasscount = 1000;
   sigmathreshold = 7.0;
   threshold = 1000000 * machineepsilon;
   slerrors = false;
   slcerrors = false;
   grcoverrors = false;
   gropterrors = false;
   gresterrors = false;
   grothererrors = false;
   grconverrors = false;
   waserrors = false;
// Quantiles table setup
   qcnt = 5;
   ae_vector_set_length(&qtbl, qcnt - 1 + 1);
   ae_vector_set_length(&qvals, qcnt - 1 + 1);
   ae_vector_set_length(&qsigma, qcnt - 1 + 1);
   qtbl.xR[0] = 0.5;
   qtbl.xR[1] = 0.25;
   qtbl.xR[2] = 0.10;
   qtbl.xR[3] = 0.05;
   qtbl.xR[4] = 0.025;
   for (i = 0; i < qcnt; i++) {
      qsigma.xR[i] = sqrt(qtbl.xR[i] * (1 - qtbl.xR[i]) / estpasscount);
   }
// Other setup
   ae_vector_set_length(&ta, estpasscount - 1 + 1);
   ae_vector_set_length(&tb, estpasscount - 1 + 1);
// Test straight line regression
   for (n = 2; n <= maxn; n++) {
   // Fail/pass test
      testlinregunit_generaterandomtask(-1.0, 1.0, false, -1.0, 1.0, 1.0, 2.0, n, &xy, &s);
      lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
      slcerrors = slcerrors || info != 1;
      testlinregunit_generaterandomtask(1.0, 1.0, false, -1.0, 1.0, 1.0, 2.0, n, &xy, &s);
      lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
      slcerrors = slcerrors || info != -3;
      testlinregunit_generaterandomtask(-1.0, 1.0, false, -1.0, 1.0, -1.0, -1.0, n, &xy, &s);
      lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
      slcerrors = slcerrors || info != -2;
      testlinregunit_generaterandomtask(-1.0, 1.0, false, -1.0, 1.0, 2.0, 1.0, 2, &xy, &s);
      lrlines(&xy, &s, 1, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
      slcerrors = slcerrors || info != -1;
   // Multipass tests
      for (pass = 1; pass <= passcount; pass++) {
      // Test S variant against non-S variant
         ea = randommid();
         eb = randommid();
         testlinregunit_generatetask(ea, eb, -5 * randomreal(), 5 * randomreal(), randombool(), 1.0, 1.0, n, &xy, &s);
         lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
         lrline(&xy, n, &info2, &a2, &b2);
         if (info != 1 || info2 != 1) {
            slcerrors = true;
         } else {
            slerrors = (slerrors || fabs(a - a2) > threshold) || fabs(b - b2) > threshold;
         }
      // Test for A/B
      //
      // Generate task with exact, non-perturbed y[i],
      // then make non-zero s[i]
         ea = randommid();
         eb = randommid();
         testlinregunit_generatetask(ea, eb, -5 * randomreal(), 5 * randomreal(), n > 4, 0.0, 0.0, n, &xy, &s);
         for (i = 0; i < n; i++) {
            s.xR[i] = 1 + randomreal();
         }
         lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
         if (info != 1) {
            slcerrors = true;
         } else {
            slerrors = (slerrors || fabs(a - ea) > 0.001) || fabs(b - eb) > 0.001;
         }
      // Test for VarA, VarB, P (P is being tested only for N>2)
         for (i = 0; i < qcnt; i++) {
            qvals.xR[i] = 0.0;
         }
         ea = randommid();
         eb = randommid();
         testlinregunit_generatetask(ea, eb, -5 * randomreal(), 5 * randomreal(), n > 4, 1.0, 2.0, n, &xy, &s);
         lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
         if (info != 1) {
            slcerrors = true;
            continue;
         }
         varatested = vara;
         varbtested = varb;
         for (epass = 0; epass < estpasscount; epass++) {
         // Generate
            testlinregunit_filltaskwithy(ea, eb, n, &xy, &s);
            lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
            if (info != 1) {
               slcerrors = true;
               continue;
            }
         // A, B, P
         // (P is being tested for uniformity, additional p-tests are below)
            ta.xR[epass] = a;
            tb.xR[epass] = b;
            for (i = 0; i < qcnt; i++) {
               if (p <= qtbl.xR[i]) {
                  qvals.xR[i] += 1.0 / estpasscount;
               }
            }
         }
         testlinregunit_calculatemv(&ta, estpasscount, &mean, &means, &stddev, &stddevs);
         slerrors = slerrors || fabs(mean - ea) / means >= sigmathreshold;
         slerrors = slerrors || fabs(stddev - sqrt(varatested)) / stddevs >= sigmathreshold;
         testlinregunit_calculatemv(&tb, estpasscount, &mean, &means, &stddev, &stddevs);
         slerrors = slerrors || fabs(mean - eb) / means >= sigmathreshold;
         slerrors = slerrors || fabs(stddev - sqrt(varbtested)) / stddevs >= sigmathreshold;
         if (n > 2) {
            for (i = 0; i < qcnt; i++) {
               if (fabs(qtbl.xR[i] - qvals.xR[i]) / qsigma.xR[i] > sigmathreshold) {
                  slerrors = true;
               }
            }
         }
      // Additional tests for P: correlation with fit quality
         if (n > 2) {
            testlinregunit_generatetask(ea, eb, -5 * randomreal(), 5 * randomreal(), false, 0.0, 0.0, n, &xy, &s);
            for (i = 0; i < n; i++) {
               s.xR[i] = 1 + randomreal();
            }
            lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
            if (info != 1) {
               slcerrors = true;
               continue;
            }
            slerrors = slerrors || p < 0.999;
            testlinregunit_generatetask(0.0, 0.0, -5 * randomreal(), 5 * randomreal(), false, 1.0, 1.0, n, &xy, &s);
            for (i = 0; i < n; i++) {
               if (i % 2 == 0) {
                  xy.xyR[i][1] = 5.0;
               } else {
                  xy.xyR[i][1] = -5.0;
               }
            }
            if (n % 2 != 0) {
               xy.xyR[n - 1][1] = 0.0;
            }
            lrlines(&xy, &s, n, &info, &a, &b, &vara, &varb, &covab, &corrab, &p);
            if (info != 1) {
               slcerrors = true;
               continue;
            }
            slerrors = slerrors || p > 0.001;
         }
      }
   }
// General regression tests:
// Simple linear tests (small sample, optimum point, covariance)
   for (n = 3; n <= maxn; n++) {
      ae_vector_set_length(&s, n - 1 + 1);
   // Linear tests:
   // a. random points, sigmas
   // b. no sigmas
      ae_matrix_set_length(&xy, n - 1 + 1, 1 + 1);
      for (i = 0; i < n; i++) {
         xy.xyR[i][0] = randommid();
         xy.xyR[i][1] = randommid();
         s.xR[i] = 1 + randomreal();
      }
      lrbuilds(&xy, &s, n, 1, &info, &wt, &ar);
      if (info != 1) {
         grconverrors = true;
         continue;
      }
      lrunpack(&wt, &tmpweights, &tmpi);
      lrlines(&xy, &s, n, &info2, &a, &b, &vara, &varb, &covab, &corrab, &p);
      gropterrors = gropterrors || fabs(a - tmpweights.xR[1]) > threshold;
      gropterrors = gropterrors || fabs(b - tmpweights.xR[0]) > threshold;
      grcoverrors = grcoverrors || fabs(vara - ar.c.xyR[1][1]) > threshold;
      grcoverrors = grcoverrors || fabs(varb - ar.c.xyR[0][0]) > threshold;
      grcoverrors = grcoverrors || fabs(covab - ar.c.xyR[1][0]) > threshold;
      grcoverrors = grcoverrors || fabs(covab - ar.c.xyR[0][1]) > threshold;
      lrbuild(&xy, n, 1, &info, &wt, &ar);
      if (info != 1) {
         grconverrors = true;
         continue;
      }
      lrunpack(&wt, &tmpweights, &tmpi);
      lrline(&xy, n, &info2, &a, &b);
      gropterrors = gropterrors || fabs(a - tmpweights.xR[1]) > threshold;
      gropterrors = gropterrors || fabs(b - tmpweights.xR[0]) > threshold;
   }
// S covariance versus S-less covariance.
// Slightly skewed task, large sample size.
// Will S-less subroutine estimate covariance matrix good enough?
   n = 1000 + randominteger(3000);
   sigma = 0.1 + randomreal() * 1.9;
   ae_matrix_set_length(&xy, n - 1 + 1, 1 + 1);
   ae_vector_set_length(&s, n - 1 + 1);
   for (i = 0; i < n; i++) {
      xy.xyR[i][0] = 1.5 * randomreal() - 0.5;
      xy.xyR[i][1] = 1.2 * xy.xyR[i][0] - 0.3 + testlinregunit_generatenormal(0.0, sigma);
      s.xR[i] = sigma;
   }
   lrbuild(&xy, n, 1, &info, &wt, &ar);
   lrlines(&xy, &s, n, &info2, &a, &b, &vara, &varb, &covab, &corrab, &p);
   if (info != 1 || info2 != 1) {
      grconverrors = true;
   } else {
      grcoverrors = grcoverrors || fabs(log(ar.c.xyR[0][0] / varb)) > log(1.2);
      grcoverrors = grcoverrors || fabs(log(ar.c.xyR[1][1] / vara)) > log(1.2);
      grcoverrors = grcoverrors || fabs(log(ar.c.xyR[0][1] / covab)) > log(1.2);
      grcoverrors = grcoverrors || fabs(log(ar.c.xyR[1][0] / covab)) > log(1.2);
   }
// General tests:
// * basis functions - up to cubic
// * task types:
// * data set is noisy sine half-period with random shift
// * tests:
//   unpacking/packing
//   optimality
//   error estimates
// * tasks:
//   0 = noised sine
//   1 = degenerate task with 1-of-n encoded categorical variables
//   2 = random task with large variation (for 1-type models)
//   3 = random task with small variation (for 1-type models)
//
//   Additional tasks TODO
//   specially designed task with defective vectors which leads to
//   the failure of the fast CV formula.
//
   m1 = 0;
   m2 = -1;
   n1 = 0;
   n2 = -1;
   for (modeltype = 0; modeltype <= 1; modeltype++) {
      for (tasktype = 0; tasktype <= 3; tasktype++) {
         if (tasktype == 0) {
            m1 = 1;
            m2 = 3;
         }
         if (tasktype == 1) {
            m1 = 9;
            m2 = 9;
         }
         if (tasktype == 2 || tasktype == 3) {
            m1 = 9;
            m2 = 9;
         }
         for (m = m1; m <= m2; m++) {
            if (tasktype == 0) {
               n1 = m + 3;
               n2 = m + 20;
            }
            if (tasktype == 1) {
               n1 = 70 + randominteger(70);
               n2 = n1;
            }
            if (tasktype == 2 || tasktype == 3) {
               n1 = 100;
               n2 = n1;
            }
            for (n = n1; n <= n2; n++) {
               ae_matrix_set_length(&xy, n - 1 + 1, m + 1);
               ae_vector_set_length(&xy0, n - 1 + 1);
               ae_vector_set_length(&s, n - 1 + 1);
               hstep = 0.001;
               noiselevel = 0.2;
            // Prepare task
               if (tasktype == 0) {
                  for (i = 0; i < n; i++) {
                     xy.xyR[i][0] = randommid();
                  }
                  for (i = 0; i < n; i++) {
                     for (j = 1; j < m; j++) {
                        xy.xyR[i][j] = xy.xyR[i][0] * xy.xyR[i][j - 1];
                     }
                  }
                  sinshift = randomreal() * pi;
                  for (i = 0; i < n; i++) {
                     xy0.xR[i] = sin(sinshift + pi * 0.5 * (xy.xyR[i][0] + 1));
                     xy.xyR[i][m] = xy0.xR[i] + noiselevel * testlinregunit_generatenormal(0.0, 1.0);
                  }
               }
               if (tasktype == 1) {
                  ae_assert(m == 9, "Assertion failed");
                  ae_vector_set_length(&ta, 8 + 1);
                  ta.xR[0] = 1.0;
                  ta.xR[1] = 2.0;
                  ta.xR[2] = 3.0;
                  ta.xR[3] = 0.25;
                  ta.xR[4] = 0.5;
                  ta.xR[5] = 0.75;
                  ta.xR[6] = 0.06;
                  ta.xR[7] = 0.12;
                  ta.xR[8] = 0.18;
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        xy.xyR[i][j] = 0.0;
                     }
                     xy.xyR[i][0 + i % 3] = 1.0;
                     xy.xyR[i][3 + i / 3 % 3] = 1.0;
                     xy.xyR[i][6 + i / 9 % 3] = 1.0;
                     v = ae_v_dotproduct(xy.xyR[i], 1, ta.xR, 1, 8 + 1);
                     xy0.xR[i] = v;
                     xy.xyR[i][m] = v + noiselevel * testlinregunit_generatenormal(0.0, 1.0);
                  }
               }
               if (tasktype == 2 || tasktype == 3) {
                  ae_assert(m == 9, "Assertion failed");
                  ae_vector_set_length(&ta, 8 + 1);
                  ta.xR[0] = 1.0;
                  ta.xR[1] = -2.0;
                  ta.xR[2] = 3.0;
                  ta.xR[3] = 0.25;
                  ta.xR[4] = -0.5;
                  ta.xR[5] = 0.75;
                  ta.xR[6] = -0.06;
                  ta.xR[7] = 0.12;
                  ta.xR[8] = -0.18;
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < m; j++) {
                        if (tasktype == 2) {
                           xy.xyR[i][j] = 1 + testlinregunit_generatenormal(0.0, 3.0);
                        } else {
                           xy.xyR[i][j] = 1 + testlinregunit_generatenormal(0.0, 0.05);
                        }
                     }
                     v = ae_v_dotproduct(xy.xyR[i], 1, ta.xR, 1, 8 + 1);
                     xy0.xR[i] = v;
                     xy.xyR[i][m] = v + noiselevel * testlinregunit_generatenormal(0.0, 1.0);
                  }
               }
               for (i = 0; i < n; i++) {
                  s.xR[i] = 1 + randomreal();
               }
            // Solve (using S-variant, non-S-variant is not tested)
               if (modeltype == 0) {
                  lrbuilds(&xy, &s, n, m, &info, &wt, &ar);
               } else {
                  lrbuildzs(&xy, &s, n, m, &info, &wt, &ar);
               }
               if (info != 1) {
                  grconverrors = true;
                  continue;
               }
               lrunpack(&wt, &tmpweights, &tmpi);
            // LRProcess test
               ae_vector_set_length(&x, m - 1 + 1);
               v = tmpweights.xR[m];
               for (i = 0; i < m; i++) {
                  x.xR[i] = randommid();
                  v += tmpweights.xR[i] * x.xR[i];
               }
               grothererrors = grothererrors || fabs(v - lrprocess(&wt, &x)) / rmax2(fabs(v), 1.0) > threshold;
            // LRPack test
               lrpack(&tmpweights, m, &wt2);
               ae_vector_set_length(&x, m - 1 + 1);
               for (i = 0; i < m; i++) {
                  x.xR[i] = randommid();
               }
               v = lrprocess(&wt, &x);
               grothererrors = grothererrors || fabs(v - lrprocess(&wt2, &x)) / fabs(v) > threshold;
            // Optimality test
               for (k = 0; k <= m; k++) {
                  if (modeltype == 1 && k == m) {
                  // 0-type models (with non-zero constant term)
                  // are tested for optimality of all coefficients.
                  //
                  // 1-type models (with zero constant term)
                  // are tested for optimality of non-constant terms only.
                     continue;
                  }
                  f = 0.0;
                  fp = 0.0;
                  fm = 0.0;
                  for (i = 0; i < n; i++) {
                     v = tmpweights.xR[m];
                     for (j = 0; j < m; j++) {
                        v += xy.xyR[i][j] * tmpweights.xR[j];
                     }
                     f += sqr((v - xy.xyR[i][m]) / s.xR[i]);
                     if (k < m) {
                        vv = xy.xyR[i][k];
                     } else {
                        vv = 1.0;
                     }
                     fp += sqr((v + vv * hstep - xy.xyR[i][m]) / s.xR[i]);
                     fm += sqr((v - vv * hstep - xy.xyR[i][m]) / s.xR[i]);
                  }
                  gropterrors = (gropterrors || f > fp) || f > fm;
               }
            // Covariance matrix test:
            // generate random vector, project coefficients on it,
            // compare variance of projection with estimate provided
            // by cov.matrix
               ae_vector_set_length(&ta, estpasscount - 1 + 1);
               ae_vector_set_length(&tb, m + 1);
               ae_vector_set_length(&tc, m + 1);
               ae_matrix_set_length(&xy2, n - 1 + 1, m + 1);
               for (i = 0; i <= m; i++) {
                  tb.xR[i] = testlinregunit_generatenormal(0.0, 1.0);
               }
               for (epass = 0; epass < estpasscount; epass++) {
                  for (i = 0; i < n; i++) {
                     ae_v_move(xy2.xyR[i], 1, xy.xyR[i], 1, m);
                     xy2.xyR[i][m] = xy0.xR[i] + s.xR[i] * testlinregunit_generatenormal(0.0, 1.0);
                  }
                  if (modeltype == 0) {
                     lrbuilds(&xy2, &s, n, m, &info, &wt, &ar2);
                  } else {
                     lrbuildzs(&xy2, &s, n, m, &info, &wt, &ar2);
                  }
                  if (info != 1) {
                     ta.xR[epass] = 0.0;
                     grconverrors = true;
                     continue;
                  }
                  lrunpack(&wt, &w2, &tmpi);
                  v = ae_v_dotproduct(tb.xR, 1, w2.xR, 1, m + 1);
                  ta.xR[epass] = v;
               }
               testlinregunit_calculatemv(&ta, estpasscount, &mean, &means, &stddev, &stddevs);
               for (i = 0; i <= m; i++) {
                  v = ae_v_dotproduct(tb.xR, 1, &ar.c.xyR[0][i], ar.c.stride, m + 1);
                  tc.xR[i] = v;
               }
               v = ae_v_dotproduct(tc.xR, 1, tb.xR, 1, m + 1);
               grcoverrors = grcoverrors || fabs((sqrt(v) - stddev) / stddevs) >= sigmathreshold;
            // Test for the fast CV error:
            // calculate CV error by definition (leaving out N
            // points and recalculating solution).
            //
            // Test for the training set error
               cvrmserror = 0.0;
               cvavgerror = 0.0;
               cvavgrelerror = 0.0;
               rmserror = 0.0;
               avgerror = 0.0;
               avgrelerror = 0.0;
               ae_matrix_set_length(&xy2, n - 2 + 1, m + 1);
               ae_vector_set_length(&s2, n - 2 + 1);
               for (i = 0; i < n - 1; i++) {
                  ae_v_move(xy2.xyR[i], 1, xy.xyR[i + 1], 1, m + 1);
                  s2.xR[i] = s.xR[i + 1];
               }
               for (i = 0; i < n; i++) {
               // Trn
                  v = ae_v_dotproduct(xy.xyR[i], 1, tmpweights.xR, 1, m);
                  v += tmpweights.xR[m];
                  rmserror += sqr(v - xy.xyR[i][m]);
                  avgerror += fabs(v - xy.xyR[i][m]);
                  avgrelerror += fabs((v - xy.xyR[i][m]) / xy.xyR[i][m]);
               // CV: non-defect vectors only
                  nondefect = true;
                  for (k = 0; k < ar.ncvdefects; k++) {
                     if (ar.cvdefects.xZ[k] == i) {
                        nondefect = false;
                     }
                  }
                  if (nondefect) {
                     if (modeltype == 0) {
                        lrbuilds(&xy2, &s2, n - 1, m, &info2, &wt, &ar2);
                     } else {
                        lrbuildzs(&xy2, &s2, n - 1, m, &info2, &wt, &ar2);
                     }
                     if (info2 != 1) {
                        grconverrors = true;
                        continue;
                     }
                     lrunpack(&wt, &w2, &tmpi);
                     v = ae_v_dotproduct(xy.xyR[i], 1, w2.xR, 1, m);
                     v += w2.xR[m];
                     cvrmserror += sqr(v - xy.xyR[i][m]);
                     cvavgerror += fabs(v - xy.xyR[i][m]);
                     cvavgrelerror += fabs((v - xy.xyR[i][m]) / xy.xyR[i][m]);
                  }
               // Next set
                  if (i != n - 1) {
                     ae_v_move(xy2.xyR[i], 1, xy.xyR[i], 1, m + 1);
                     s2.xR[i] = s.xR[i];
                  }
               }
               cvrmserror = sqrt(cvrmserror / (n - ar.ncvdefects));
               cvavgerror /= n - ar.ncvdefects;
               cvavgrelerror /= n - ar.ncvdefects;
               rmserror = sqrt(rmserror / n);
               avgerror /= n;
               avgrelerror /= n;
               gresterrors = gresterrors || fabs(log(ar.cvrmserror / cvrmserror)) > log(1 + 1.0E-5);
               gresterrors = gresterrors || fabs(log(ar.cvavgerror / cvavgerror)) > log(1 + 1.0E-5);
               gresterrors = gresterrors || fabs(log(ar.cvavgrelerror / cvavgrelerror)) > log(1 + 1.0E-5);
               gresterrors = gresterrors || fabs(log(ar.rmserror / rmserror)) > log(1 + 1.0E-5);
               gresterrors = gresterrors || fabs(log(ar.avgerror / avgerror)) > log(1 + 1.0E-5);
               gresterrors = gresterrors || fabs(log(ar.avgrelerror / avgrelerror)) > log(1 + 1.0E-5);
            }
         }
      }
   }
// Additional subroutines
   for (pass = 1; pass <= 50; pass++) {
      n = 2;
      do {
         noiselevel = randomreal() + 0.1;
         tasklevel = randommid();
      } while (fabs(noiselevel - tasklevel) <= 0.05);
      ae_matrix_set_length(&xy, 3 * n - 1 + 1, 1 + 1);
      for (i = 0; i < n; i++) {
         xy.xyR[3 * i + 0][0] = (double)i;
         xy.xyR[3 * i + 1][0] = (double)i;
         xy.xyR[3 * i + 2][0] = (double)i;
         xy.xyR[3 * i + 0][1] = tasklevel - noiselevel;
         xy.xyR[3 * i + 1][1] = tasklevel;
         xy.xyR[3 * i + 2][1] = tasklevel + noiselevel;
      }
      lrbuild(&xy, 3 * n, 1, &info, &wt, &ar);
      if (info == 1) {
         lrunpack(&wt, &tmpweights, &tmpi);
         v = lrrmserror(&wt, &xy, 3 * n);
         grothererrors = grothererrors || fabs(v - noiselevel * sqrt(2.0 / 3.0)) > threshold;
         v = lravgerror(&wt, &xy, 3 * n);
         grothererrors = grothererrors || fabs(v - noiselevel * (2.0 / 3.0)) > threshold;
         v = lravgrelerror(&wt, &xy, 3 * n);
         vv = (fabs(noiselevel / (tasklevel - noiselevel)) + fabs(noiselevel / (tasklevel + noiselevel))) / 3;
         grothererrors = grothererrors || fabs(v - vv) > threshold * vv;
      } else {
         grothererrors = true;
      }
      for (i = 0; i < n; i++) {
         xy.xyR[3 * i + 0][0] = (double)i;
         xy.xyR[3 * i + 1][0] = (double)i;
         xy.xyR[3 * i + 2][0] = (double)i;
         xy.xyR[3 * i + 0][1] = -noiselevel;
         xy.xyR[3 * i + 1][1] = 0.0;
         xy.xyR[3 * i + 2][1] = noiselevel;
      }
      lrbuild(&xy, 3 * n, 1, &info, &wt, &ar);
      if (info == 1) {
         lrunpack(&wt, &tmpweights, &tmpi);
         v = lravgrelerror(&wt, &xy, 3 * n);
         grothererrors = grothererrors || fabs(v - 1) > threshold;
      } else {
         grothererrors = true;
      }
   }
   for (pass = 1; pass <= 10; pass++) {
      m = 1 + randominteger(5);
      n = 10 + randominteger(10);
      ae_matrix_set_length(&xy, n - 1 + 1, m + 1);
      for (i = 0; i < n; i++) {
         for (j = 0; j <= m; j++) {
            xy.xyR[i][j] = randommid();
         }
      }
      lrbuild(&xy, n, m, &info, &w, &ar);
      if (info < 0) {
         grothererrors = true;
         break;
      }
      ae_vector_set_length(&x1, m - 1 + 1);
      ae_vector_set_length(&x2, m - 1 + 1);
   // Same inputs on original leads to same outputs
   // on copy created using LRCopy
      testlinregunit_unsetlr(&wt);
      lrcopy(&w, &wt);
      for (i = 0; i < m; i++) {
         x1.xR[i] = randommid();
         x2.xR[i] = x1.xR[i];
      }
      y1 = lrprocess(&w, &x1);
      y2 = lrprocess(&wt, &x2);
      allsame = y1 == y2;
      grothererrors = grothererrors || !allsame;
   }
// TODO: Degenerate tests (when design matrix and right part are zero)
// Final report
   waserrors = (((((slerrors || slcerrors) || gropterrors) || grcoverrors) || gresterrors) || grothererrors) || grconverrors;
   if (!silent) {
      printf("REGRESSION TEST\n");
      printf("STRAIGHT LINE REGRESSION:                ");
      if (!slerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("STRAIGHT LINE REGRESSION CONVERGENCE:    ");
      if (!slcerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("GENERAL LINEAR REGRESSION:               ");
      if (!((((gropterrors || grcoverrors) || gresterrors) || grothererrors) || grconverrors)) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* OPTIMALITY:                            ");
      if (!gropterrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* COV. MATRIX:                           ");
      if (!grcoverrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* ERROR ESTIMATES:                       ");
      if (!gresterrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* CONVERGENCE:                           ");
      if (!grconverrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* OTHER SUBROUTINES:                     ");
      if (!grothererrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST SUMMARY: FAILED\n");
      } else {
         printf("TEST SUMMARY: PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === filters testing unit ===
// This function tests SMA(k) filter. It returns True on error.
//
// Additional IsSilent parameter controls detailed error reporting.
static bool testsma(bool issilent) {
   ae_frame _frame_block;
   bool precomputederrors;
   bool zerohandlingerrors;
   double threshold;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   threshold = 1000 * machineepsilon;
   if (!issilent) {
      printf("SMA(K) TEST\n");
   }
// Test several pre-computed problems.
//
// NOTE: tests below rely on the fact that floating point
//       additions and subtractions are exact when dealing
//       with integer values.
   precomputederrors = false;
   ae_vector_set_length(&x, 1);
   x.xR[0] = 7.0;
   filtersma(&x, 1, 1);
   precomputederrors = precomputederrors || x.xR[0] != 7.0;
   ae_vector_set_length(&x, 3);
   x.xR[0] = 7.0;
   x.xR[1] = 8.0;
   x.xR[2] = 9.0;
   filtersma(&x, 3, 1);
   precomputederrors = ((precomputederrors || x.xR[0] != 7.0) || x.xR[1] != 8.0) || x.xR[2] != 9.0;
   filtersma(&x, 3, 2);
   precomputederrors = ((precomputederrors || x.xR[0] != 7.0) || x.xR[1] != 7.5) || x.xR[2] != 8.5;
   ae_vector_set_length(&x, 3);
   x.xR[0] = 7.0;
   x.xR[1] = 8.0;
   x.xR[2] = 9.0;
   filtersma(&x, 3, 4);
   precomputederrors = ((precomputederrors || x.xR[0] != 7.0) || x.xR[1] != 7.5) || x.xR[2] != 8.0;
// Test zero-handling:
// a) when we have non-zero sequence (N1 elements) followed by zero sequence
//    (N2 elements), then first N1+K-1 elements of the processed sequence are
//    non-zero, but elements since (N1+K)th must be exactly zero.
// b) similar property holds for zero sequence followed by non-zero one
//
// Naive implementation of SMA does not have such property.
//
// NOTE: it is important to initialize X with non-integer elements with long
// binary mantissas, because this test tries to test behaviour in the presence
// of roundoff errors, and it will be useless when used with integer inputs.
   zerohandlingerrors = false;
   ae_vector_set_length(&x, 10);
   x.xR[0] = sqrt(2.0);
   x.xR[1] = sqrt(3.0);
   x.xR[2] = sqrt(5.0);
   x.xR[3] = sqrt(6.0);
   x.xR[4] = sqrt(7.0);
   x.xR[5] = 0.0;
   x.xR[6] = 0.0;
   x.xR[7] = 0.0;
   x.xR[8] = 0.0;
   x.xR[9] = 0.0;
   filtersma(&x, 10, 3);
   zerohandlingerrors = zerohandlingerrors || fabs(x.xR[0] - sqrt(2.0)) > threshold;
   zerohandlingerrors = zerohandlingerrors || fabs(x.xR[1] - (sqrt(2.0) + sqrt(3.0)) / 2) > threshold;
   zerohandlingerrors = zerohandlingerrors || fabs(x.xR[2] - (sqrt(2.0) + sqrt(3.0) + sqrt(5.0)) / 3) > threshold;
   zerohandlingerrors = zerohandlingerrors || fabs(x.xR[3] - (sqrt(3.0) + sqrt(5.0) + sqrt(6.0)) / 3) > threshold;
   zerohandlingerrors = zerohandlingerrors || fabs(x.xR[4] - (sqrt(5.0) + sqrt(6.0) + sqrt(7.0)) / 3) > threshold;
   zerohandlingerrors = zerohandlingerrors || fabs(x.xR[5] - (sqrt(6.0) + sqrt(7.0)) / 3) > threshold;
   zerohandlingerrors = zerohandlingerrors || fabs(x.xR[6] - sqrt(7.0) / 3) > threshold;
   zerohandlingerrors = zerohandlingerrors || x.xR[7] != 0.0;
   zerohandlingerrors = zerohandlingerrors || x.xR[8] != 0.0;
   zerohandlingerrors = zerohandlingerrors || x.xR[9] != 0.0;
   x.xR[0] = 0.0;
   x.xR[1] = 0.0;
   x.xR[2] = 0.0;
   x.xR[3] = 0.0;
   x.xR[4] = 0.0;
   x.xR[5] = sqrt(2.0);
   x.xR[6] = sqrt(3.0);
   x.xR[7] = sqrt(5.0);
   x.xR[8] = sqrt(6.0);
   x.xR[9] = sqrt(7.0);
   filtersma(&x, 10, 3);
   zerohandlingerrors = zerohandlingerrors || x.xR[0] != 0.0;
   zerohandlingerrors = zerohandlingerrors || x.xR[1] != 0.0;
   zerohandlingerrors = zerohandlingerrors || x.xR[2] != 0.0;
   zerohandlingerrors = zerohandlingerrors || x.xR[3] != 0.0;
   zerohandlingerrors = zerohandlingerrors || x.xR[4] != 0.0;
   zerohandlingerrors = zerohandlingerrors || fabs(x.xR[5] - sqrt(2.0) / 3) > threshold;
   zerohandlingerrors = zerohandlingerrors || fabs(x.xR[6] - (sqrt(2.0) + sqrt(3.0)) / 3) > threshold;
   zerohandlingerrors = zerohandlingerrors || fabs(x.xR[7] - (sqrt(2.0) + sqrt(3.0) + sqrt(5.0)) / 3) > threshold;
   zerohandlingerrors = zerohandlingerrors || fabs(x.xR[8] - (sqrt(3.0) + sqrt(5.0) + sqrt(6.0)) / 3) > threshold;
   zerohandlingerrors = zerohandlingerrors || fabs(x.xR[9] - (sqrt(5.0) + sqrt(6.0) + sqrt(7.0)) / 3) > threshold;
// Final result
   result = precomputederrors || zerohandlingerrors;
   ae_frame_leave();
   return result;
}

// This function tests EMA(alpha) filter. It returns True on error.
//
// Additional IsSilent parameter controls detailed error reporting.
static bool testema(bool issilent) {
   ae_frame _frame_block;
   bool precomputederrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   if (!issilent) {
      printf("EMA(alpha) TEST\n");
   }
// Test several pre-computed problems.
//
// NOTE: tests below rely on the fact that floating point
//       additions and subtractions are exact when dealing
//       with integer values.
   precomputederrors = false;
   ae_vector_set_length(&x, 1);
   x.xR[0] = 7.0;
   filterema(&x, 1, 1.0);
   precomputederrors = precomputederrors || x.xR[0] != 7.0;
   filterema(&x, 1, 0.5);
   precomputederrors = precomputederrors || x.xR[0] != 7.0;
   ae_vector_set_length(&x, 3);
   x.xR[0] = 7.0;
   x.xR[1] = 8.0;
   x.xR[2] = 9.0;
   filterema(&x, 3, 1.0);
   precomputederrors = ((precomputederrors || x.xR[0] != 7.0) || x.xR[1] != 8.0) || x.xR[2] != 9.0;
   filterema(&x, 3, 0.5);
   precomputederrors = ((precomputederrors || x.xR[0] != 7.0) || x.xR[1] != 7.5) || x.xR[2] != 8.25;
// Final result
   result = precomputederrors;
   ae_frame_leave();
   return result;
}

// This function tests LRMA(k) filter. It returns True on error.
//
// Additional IsSilent parameter controls detailed error reporting.
static bool testlrma(bool issilent) {
   ae_frame _frame_block;
   bool precomputederrors;
   double threshold;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(x, 0, DT_REAL);
   threshold = 1000 * machineepsilon;
   if (!issilent) {
      printf("LRMA(K) TEST\n");
   }
   precomputederrors = false;
// First, check that filter does not changes points for K=1 or K=2
   ae_vector_set_length(&x, 1);
   x.xR[0] = 7.0;
   filterlrma(&x, 1, 1);
   precomputederrors = precomputederrors || x.xR[0] != 7.0;
   ae_vector_set_length(&x, 6);
   x.xR[0] = 7.0;
   x.xR[1] = 8.0;
   x.xR[2] = 9.0;
   x.xR[3] = 10.0;
   x.xR[4] = 11.0;
   x.xR[5] = 12.0;
   filterlrma(&x, 6, 1);
   precomputederrors = (((((precomputederrors || x.xR[0] != 7.0) || x.xR[1] != 8.0) || x.xR[2] != 9.0) || x.xR[3] != 10.0) || x.xR[4] != 11.0) || x.xR[5] != 12.0;
   filterlrma(&x, 6, 2);
   precomputederrors = (((((precomputederrors || x.xR[0] != 7.0) || x.xR[1] != 8.0) || x.xR[2] != 9.0) || x.xR[3] != 10.0) || x.xR[4] != 11.0) || x.xR[5] != 12.0;
// Check several precomputed problems
   ae_vector_set_length(&x, 6);
   x.xR[0] = 7.0;
   x.xR[1] = 8.0;
   x.xR[2] = 9.0;
   x.xR[3] = 10.0;
   x.xR[4] = 11.0;
   x.xR[5] = 12.0;
   filterlrma(&x, 6, 3);
   precomputederrors = precomputederrors || fabs(x.xR[0] - 7) > threshold;
   precomputederrors = precomputederrors || fabs(x.xR[1] - 8) > threshold;
   precomputederrors = precomputederrors || fabs(x.xR[2] - 9) > threshold;
   precomputederrors = precomputederrors || fabs(x.xR[3] - 10) > threshold;
   precomputederrors = precomputederrors || fabs(x.xR[4] - 11) > threshold;
   precomputederrors = precomputederrors || fabs(x.xR[5] - 12) > threshold;
   ae_vector_set_length(&x, 6);
   x.xR[0] = 7.0;
   x.xR[1] = 8.0;
   x.xR[2] = 8.0;
   x.xR[3] = 9.0;
   x.xR[4] = 12.0;
   x.xR[5] = 12.0;
   filterlrma(&x, 6, 3);
   precomputederrors = precomputederrors || fabs(x.xR[0] - 7.0000000000) > 1.0E-5;
   precomputederrors = precomputederrors || fabs(x.xR[1] - 8.0000000000) > 1.0E-5;
   precomputederrors = precomputederrors || fabs(x.xR[2] - 8.1666666667) > 1.0E-5;
   precomputederrors = precomputederrors || fabs(x.xR[3] - 8.8333333333) > 1.0E-5;
   precomputederrors = precomputederrors || fabs(x.xR[4] - 11.6666666667) > 1.0E-5;
   precomputederrors = precomputederrors || fabs(x.xR[5] - 12.5000000000) > 1.0E-5;
// Final result
   result = precomputederrors;
   ae_frame_leave();
   return result;
}

bool testfilters(bool silent) {
   bool waserrors;
   bool smaerrors;
   bool emaerrors;
   bool lrmaerrors;
   bool result;
   smaerrors = testsma(true);
   emaerrors = testema(true);
   lrmaerrors = testlrma(true);
// Final report
   waserrors = (smaerrors || emaerrors) || lrmaerrors;
   if (!silent) {
      printf("FILTERS TEST\n");
      printf("* SMA:                                   ");
      if (!smaerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* EMA:                                   ");
      if (!emaerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* LRMA:                                  ");
      if (!lrmaerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST SUMMARY: FAILED\n");
      } else {
         printf("TEST SUMMARY: PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === ssa testing unit ===
// This function tests SSA on several general purpose analysis/prediction
// problems.
//
// On failure sets ErrorFlag, on success it is untouched.
static void testssaunit_testgeneral(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   double vv;
   ae_int_t pass;
   ae_int_t ntracks;
   ae_int_t windowwidth;
   ae_int_t nlasttracklen;
   ae_int_t nzeros;
   ae_int_t nlinear;
   double sinefreq;
   double sineoffs;
   double sineamp;
   ae_int_t windowwidth2;
   ae_int_t nbasis;
   ae_int_t nbasis2;
   ae_int_t ninitial;
   ae_int_t algotype;
   ae_int_t nticks;
   ae_int_t nnoise;
   ae_int_t navg;
   double tol;
   ae_int_t datalen;
   ae_int_t forecastlen;
   ae_int_t mlimit;
   ae_int_t passcount;
   double skipprob;
   ae_frame_make(&_frame_block);
   NewObj(ssamodel, state);
   NewObj(ssamodel, state2);
   NewVector(x, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(trend, 0, DT_REAL);
   NewVector(noise, 0, DT_REAL);
   NewVector(sv, 0, DT_REAL);
   NewVector(sv2, 0, DT_REAL);
   NewVector(tmp0, 0, DT_REAL);
   NewVector(trend2, 0, DT_REAL);
   NewVector(noise2, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(a2, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
// Initialize RNG, test pass count and skip probability.
//
// When we perform several sequential tests on the same model, we may
// skip some of them with probability SkipProb in order to make sure
// that no carry-over effect is observed between tests.
   hqrndrandomize(&rs);
   passcount = 500;
   skipprob = 0.50;
// Iterate over several algorithm types.
// Algorithms unsupported by tests are skipped within tests.
   for (algotype = 1; algotype <= 3; algotype++) {
   // Test that on perfectly constant dataset SSA correctly predicts
   // perfectly constant trend. Additionally test that analysis phase
   // correctly returns nearly-zero noise and nearly-constant trend.
   //
   // Dataset is a one/few sequences with different constants; top-1
   // algorithm is used (or precomputed unit-normalized vector of 1's).
      for (pass = 1; pass <= passcount; pass++) {
         nlasttracklen = -9999999;
         ntracks = 1 + hqrnduniformi(&rs, 3);
         windowwidth = 2 + hqrnduniformi(&rs, 3);
         ssacreate(&state);
         ssasetwindow(&state, windowwidth);
         for (k = 0; k < ntracks; k++) {
            nlasttracklen = windowwidth + hqrnduniformi(&rs, windowwidth);
            v = hqrndnormal(&rs);
            ae_vector_set_length(&x, nlasttracklen);
            for (i = 0; i < nlasttracklen; i++) {
               x.xR[i] = v;
            }
            ssaaddsequence(&state, &x, nlasttracklen);
         }
         if (algotype == 1) {
            ae_matrix_set_length(&b, windowwidth, 1);
            for (i = 0; i < windowwidth; i++) {
               b.xyR[i][0] = 1 / sqrt((double)windowwidth);
            }
            ssasetalgoprecomputed(&state, &b, windowwidth, 1);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, 1);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, 1);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         tol = 1.0E-6;
         if (hqrnduniformr(&rs) > skipprob) {
            ssaanalyzelastwindow(&state, &trend, &noise, &nticks);
            set_error_flag(errorflag, nticks != windowwidth, __FILE__, __LINE__, "testssaunit.ap:143");
            set_error_flag(errorflag, noise.cnt != windowwidth, __FILE__, __LINE__, "testssaunit.ap:144");
            set_error_flag(errorflag, trend.cnt != windowwidth, __FILE__, __LINE__, "testssaunit.ap:145");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < windowwidth; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - x.xR[nlasttracklen + i - windowwidth]) > tol, __FILE__, __LINE__, "testssaunit.ap:150");
               set_error_flag(errorflag, fabs(noise.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:151");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            ssaanalyzelast(&state, nlasttracklen, &trend, &noise);
            set_error_flag(errorflag, noise.cnt != nlasttracklen, __FILE__, __LINE__, "testssaunit.ap:157");
            set_error_flag(errorflag, trend.cnt != nlasttracklen, __FILE__, __LINE__, "testssaunit.ap:158");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < nlasttracklen; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - x.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:163");
               set_error_flag(errorflag, fabs(noise.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:164");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 2 * windowwidth);
            ae_vector_set_length(&trend, 0);
            ssaforecastlast(&state, nticks, &trend);
            set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:172");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < trend.cnt; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - x.xR[nlasttracklen - 1]) > tol, __FILE__, __LINE__, "testssaunit.ap:176");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 2 * windowwidth);
            navg = 1 + hqrnduniformi(&rs, windowwidth + 3);
            ae_vector_set_length(&trend, 0);
            ssaforecastavglast(&state, navg, nticks, &trend);
            set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:184");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < trend.cnt; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - x.xR[nlasttracklen - 1]) > tol, __FILE__, __LINE__, "testssaunit.ap:188");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            datalen = windowwidth + hqrnduniformi(&rs, 10);
            forecastlen = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&x, datalen);
            x.xR[0] = hqrndnormal(&rs);
            for (i = 1; i < datalen; i++) {
               x.xR[i] = x.xR[i - 1];
            }
            ae_vector_set_length(&trend, 0);
            ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
            set_error_flag(errorflag, trend.cnt != forecastlen, __FILE__, __LINE__, "testssaunit.ap:200");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < forecastlen; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - x.xR[datalen - 1]) > tol, __FILE__, __LINE__, "testssaunit.ap:204");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            datalen = windowwidth + hqrnduniformi(&rs, 10);
            navg = 1 + hqrnduniformi(&rs, windowwidth + 3);
            forecastlen = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&x, datalen);
            x.xR[0] = hqrndnormal(&rs);
            for (i = 1; i < datalen; i++) {
               x.xR[i] = x.xR[i - 1];
            }
            ae_vector_set_length(&trend, 0);
            ssaforecastavgsequence(&state, &x, datalen, navg, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
            set_error_flag(errorflag, trend.cnt != forecastlen, __FILE__, __LINE__, "testssaunit.ap:217");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < forecastlen; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - x.xR[datalen - 1]) > tol, __FILE__, __LINE__, "testssaunit.ap:221");
            }
         }
      }
   // Test that on specially designed linear dataset SSA correctly
   // predicts perfectly linear trend. Additionally test that analysis
   // phase correctly returns nearly-zero noise and nearly-linear trend.
   // Also test that correct basis vectors are returned.
   //
   // Dataset consists of many WindowWidth-sized (exactly) sequences with
   // linear trend. Trend coefficients vary accross sequences. Top-2
   // algorithm is used (or precomputed unit-normalized linear trend basis).
   //
   // NOTE: this test requires NTracks >= 2, WindowWidth >= 3 and TopK=2 to work;
   //       however, in order to improve numerical properties (diversity among
   //       samples, different slopes and offsets) we set NTracks to be
   //       at least 5.
   //
   // NOTE: one more version of this test verifies scaling properties
   //       by solving larger task (WindowWidth=100, NTracks=5,
   //       TrackLen=2*WindowWidth). This version makes just 5 checks because
   //       of higher cost.
      for (pass = 1; pass <= passcount; pass++) {
         ntracks = 5 + hqrnduniformi(&rs, 10);
         windowwidth = 3 + hqrnduniformi(&rs, 3);
         ssacreate(&state);
         ssasetwindow(&state, windowwidth);
         ae_vector_set_length(&x, windowwidth);
         for (k = 0; k < ntracks; k++) {
            v = hqrndnormal(&rs);
            x.xR[0] = hqrndnormal(&rs);
            for (i = 1; i < windowwidth; i++) {
               x.xR[i] = x.xR[i - 1] + v;
            }
            ssaaddsequence(&state, &x, windowwidth);
         }
         if (algotype == 1) {
            ae_matrix_set_length(&b, windowwidth, 2);
            v = 0.0;
            for (i = 0; i < windowwidth; i++) {
               b.xyR[i][0] = 1 / sqrt((double)windowwidth);
               b.xyR[i][1] = (double)i;
               v += (double)i / windowwidth;
            }
            vv = 0.0;
            for (i = 0; i < windowwidth; i++) {
               b.xyR[i][1] -= v;
               vv += sqr(b.xyR[i][1]);
            }
            for (i = 0; i < windowwidth; i++) {
               b.xyR[i][1] /= sqrt(vv);
            }
            ssasetalgoprecomputed(&state, &b, windowwidth, 2);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, 2);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, 2);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         tol = 1.0E-6;
         if (hqrnduniformr(&rs) > skipprob) {
         // Basis vectors must be linear/constant functions
            ssagetbasis(&state, &a, &sv, &windowwidth2, &nbasis);
            set_error_flag(errorflag, windowwidth2 != windowwidth, __FILE__, __LINE__, "testssaunit.ap:293");
            set_error_flag(errorflag, nbasis != 2, __FILE__, __LINE__, "testssaunit.ap:294");
            set_error_flag(errorflag, a.cols != nbasis, __FILE__, __LINE__, "testssaunit.ap:295");
            set_error_flag(errorflag, a.rows != windowwidth, __FILE__, __LINE__, "testssaunit.ap:296");
            set_error_flag(errorflag, sv.cnt != nbasis, __FILE__, __LINE__, "testssaunit.ap:297");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (j = 0; j < nbasis; j++) {
               v = a.xyR[1][j] - a.xyR[0][j];
               for (i = 2; i < windowwidth; i++) {
                  set_error_flag(errorflag, fabs(a.xyR[i][j] - a.xyR[i - 1][j] - v) > tol, __FILE__, __LINE__, "testssaunit.ap:304");
               }
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            ssaanalyzelastwindow(&state, &trend, &noise, &nticks);
            set_error_flag(errorflag, nticks != windowwidth, __FILE__, __LINE__, "testssaunit.ap:310");
            set_error_flag(errorflag, noise.cnt != windowwidth, __FILE__, __LINE__, "testssaunit.ap:311");
            set_error_flag(errorflag, trend.cnt != windowwidth, __FILE__, __LINE__, "testssaunit.ap:312");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < windowwidth; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - x.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:317");
               set_error_flag(errorflag, fabs(noise.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:318");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            ssaanalyzelast(&state, windowwidth, &trend, &noise);
            set_error_flag(errorflag, noise.cnt != windowwidth, __FILE__, __LINE__, "testssaunit.ap:324");
            set_error_flag(errorflag, trend.cnt != windowwidth, __FILE__, __LINE__, "testssaunit.ap:325");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < windowwidth; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - x.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:330");
               set_error_flag(errorflag, fabs(noise.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:331");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 2 * windowwidth);
            ssaforecastlast(&state, nticks, &trend);
            set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:338");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            v = x.xR[windowwidth - 1] - x.xR[windowwidth - 2];
            set_error_flag(errorflag, fabs(trend.xR[0] - x.xR[windowwidth - 1] - v) > tol, __FILE__, __LINE__, "testssaunit.ap:342");
            for (i = 1; i < nticks; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - trend.xR[i - 1] - v) > tol, __FILE__, __LINE__, "testssaunit.ap:344");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 2 * windowwidth);
            navg = 1 + hqrnduniformi(&rs, windowwidth + 5);
            ae_vector_set_length(&trend, 0);
            ssaforecastavglast(&state, navg, nticks, &trend);
            set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:352");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            v = x.xR[windowwidth - 1] - x.xR[windowwidth - 2];
            set_error_flag(errorflag, fabs(trend.xR[0] - x.xR[windowwidth - 1] - v) > tol, __FILE__, __LINE__, "testssaunit.ap:356");
            for (i = 1; i < nticks; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - trend.xR[i - 1] - v) > tol, __FILE__, __LINE__, "testssaunit.ap:358");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            datalen = windowwidth + hqrnduniformi(&rs, 10);
            forecastlen = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&x, datalen);
            v = hqrndnormal(&rs);
            x.xR[0] = hqrndnormal(&rs);
            for (i = 1; i < datalen; i++) {
               x.xR[i] = x.xR[i - 1] + v;
            }
            ae_vector_set_length(&trend, 0);
            ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
            set_error_flag(errorflag, trend.cnt != forecastlen, __FILE__, __LINE__, "testssaunit.ap:371");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            set_error_flag(errorflag, fabs(trend.xR[0] - x.xR[datalen - 1] - v) > tol, __FILE__, __LINE__, "testssaunit.ap:374");
            for (i = 1; i < forecastlen; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - trend.xR[i - 1] - v) > tol, __FILE__, __LINE__, "testssaunit.ap:376");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            datalen = windowwidth + hqrnduniformi(&rs, 10);
            navg = 1 + hqrnduniformi(&rs, windowwidth + 5);
            forecastlen = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&x, datalen);
            v = hqrndnormal(&rs);
            x.xR[0] = hqrndnormal(&rs);
            for (i = 1; i < datalen; i++) {
               x.xR[i] = x.xR[i - 1] + v;
            }
            ae_vector_set_length(&trend, 0);
            ssaforecastavgsequence(&state, &x, datalen, navg, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
            set_error_flag(errorflag, trend.cnt != forecastlen, __FILE__, __LINE__, "testssaunit.ap:390");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            set_error_flag(errorflag, fabs(trend.xR[0] - x.xR[datalen - 1] - v) > tol, __FILE__, __LINE__, "testssaunit.ap:393");
            for (i = 1; i < forecastlen; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - trend.xR[i - 1] - v) > tol, __FILE__, __LINE__, "testssaunit.ap:395");
            }
         }
      }
      for (pass = 1; pass <= 5; pass++) {
         ntracks = 5 + hqrnduniformi(&rs, 10);
         windowwidth = 100;
         nlasttracklen = 2 * windowwidth;
         ssacreate(&state);
         ssasetwindow(&state, windowwidth);
         ae_vector_set_length(&x, nlasttracklen);
         for (k = 0; k < ntracks; k++) {
            v = hqrndnormal(&rs);
            x.xR[0] = hqrndnormal(&rs);
            for (i = 1; i < nlasttracklen; i++) {
               x.xR[i] = x.xR[i - 1] + v;
            }
            ssaaddsequence(&state, &x, nlasttracklen);
         }
         if (algotype == 1) {
            ae_matrix_set_length(&b, windowwidth, 2);
            v = 0.0;
            for (i = 0; i < windowwidth; i++) {
               b.xyR[i][0] = 1 / sqrt((double)windowwidth);
               b.xyR[i][1] = (double)i;
               v += (double)i / windowwidth;
            }
            vv = 0.0;
            for (i = 0; i < windowwidth; i++) {
               b.xyR[i][1] -= v;
               vv += sqr(b.xyR[i][1]);
            }
            for (i = 0; i < windowwidth; i++) {
               b.xyR[i][1] /= sqrt(vv);
            }
            ssasetalgoprecomputed(&state, &b, windowwidth, 2);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, 2);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, 2);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         tol = 1.0E-6;
         if (hqrnduniformr(&rs) > skipprob) {
            ssaanalyzelastwindow(&state, &trend, &noise, &nticks);
            set_error_flag(errorflag, nticks != windowwidth, __FILE__, __LINE__, "testssaunit.ap:444");
            set_error_flag(errorflag, noise.cnt != windowwidth, __FILE__, __LINE__, "testssaunit.ap:445");
            set_error_flag(errorflag, trend.cnt != windowwidth, __FILE__, __LINE__, "testssaunit.ap:446");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < windowwidth; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - x.xR[nlasttracklen + i - windowwidth]) > tol, __FILE__, __LINE__, "testssaunit.ap:451");
               set_error_flag(errorflag, fabs(noise.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:452");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            ssaanalyzelast(&state, nlasttracklen, &trend, &noise);
            set_error_flag(errorflag, noise.cnt != nlasttracklen, __FILE__, __LINE__, "testssaunit.ap:458");
            set_error_flag(errorflag, trend.cnt != nlasttracklen, __FILE__, __LINE__, "testssaunit.ap:459");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < nlasttracklen; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - x.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:464");
               set_error_flag(errorflag, fabs(noise.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:465");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 10);
            ssaforecastlast(&state, nticks, &trend);
            set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:472");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            v = x.xR[nlasttracklen - 1] - x.xR[nlasttracklen - 2];
            set_error_flag(errorflag, fabs(trend.xR[0] - x.xR[nlasttracklen - 1] - v) > tol, __FILE__, __LINE__, "testssaunit.ap:476");
            for (i = 1; i < nticks; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - trend.xR[i - 1] - v) > tol, __FILE__, __LINE__, "testssaunit.ap:478");
            }
         }
      }
   // Test that on specially designed dataset with two sinusoidal components
   // with significantly different amplitudes, whose periods are integer
   // divisors of window width, SSA correctly separates leading sine from
   // its smaller counterpart. Also test that we can correctly predict future
   // values of the sequence.
   //
   // Dataset consists of many sequences, each of them featuring either
   // sine with period=WindowWidth or sine with period=WindowWidth/2. Such
   // dataset is necessary because sum of two sines is not well separated by
   // SVD (it performs only approximate, asymptotic separation). But when
   // every sequence is either one of the sines, but not two together, we
   // can easily separate them.
   //
   // Sine coefficients are changed from sequence to sequence.
   //
   // NOTE: this test requires large WindowWidth and TopK=2 to work.
   //
   // NOTE: this test uses reduced number of passes because of higher computational complexity
      for (pass = 1; pass <= 10; pass++) {
      // Skip "precomputed basis" algorithm
         if (algotype == 1) {
            continue;
         }
      // Generate dataset
         ntracks = 100 + hqrnduniformi(&rs, 2);
         windowwidth = 64;
         nlasttracklen = windowwidth + hqrnduniformi(&rs, 10);
         ssacreate(&state);
         ae_vector_set_length(&x, nlasttracklen);
         for (k = 0; k < ntracks; k++) {
            sineoffs = (double)hqrnduniformi(&rs, windowwidth);
            if (k % 2 == 0) {
               sineamp = 1 + hqrnduniformr(&rs);
               sinefreq = 1.0;
            } else {
               sineamp = 0.1 * (1 + hqrnduniformr(&rs));
               sinefreq = 2.0;
            }
            for (i = 0; i < nlasttracklen; i++) {
               x.xR[i] = sineamp * sin((i + sineoffs) / windowwidth * 2 * pi * sinefreq);
            }
            ssaaddsequence(&state, &x, nlasttracklen);
         }
         if (algotype == 2) {
            ssasetalgotopkdirect(&state, 2);
         } else {
            if (algotype == 3) {
               ssasetalgotopkrealtime(&state, 2);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
         tol = 1.0E-6;
      // Test analysis with WindowWidth=SinePeriod:
      // * analyze sine with frequency=1, it must be recognized as trend
      // * analyze sine with frequency=2, with smoothing enabled
      //   it must be discarded as noise;
         ssasetwindow(&state, windowwidth);
         nticks = windowwidth + 1 + hqrnduniformi(&rs, windowwidth);
         sineoffs = (double)hqrnduniformi(&rs, windowwidth);
         sineamp = 1 + hqrnduniformr(&rs);
         sinefreq = 1.0;
         ae_vector_set_length(&x, nticks);
         for (i = 0; i < nticks; i++) {
            x.xR[i] = sineamp * sin((i + sineoffs) / windowwidth * 2 * pi * sinefreq);
         }
         ssaanalyzesequence(&state, &x, nticks, &trend, &noise);
         set_error_flag(errorflag, noise.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:558");
         set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:559");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < nticks; i++) {
            v = sineamp * sin((i + sineoffs) / windowwidth * 2 * pi * sinefreq);
            set_error_flag(errorflag, fabs(trend.xR[i] - v) > tol, __FILE__, __LINE__, "testssaunit.ap:565");
            set_error_flag(errorflag, fabs(noise.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:566");
         }
         forecastlen = 1 + hqrnduniformi(&rs, nticks - windowwidth);
         datalen = nticks - forecastlen;
         ae_vector_set_length(&x2, datalen);
         for (i = 0; i < datalen; i++) {
            x2.xR[i] = x.xR[i];
         }
         ssaforecastsequence(&state, &x2, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
         for (i = 0; i < forecastlen; i++) {
            set_error_flag(errorflag, fabs(trend.xR[i] - x.xR[datalen + i]) > tol, __FILE__, __LINE__, "testssaunit.ap:575");
         }
         ae_vector_set_length(&tmp0, 0);
         windowwidth2 = -1;
         ssagetlrr(&state, &tmp0, &windowwidth2);
         set_error_flag(errorflag, windowwidth2 != windowwidth, __FILE__, __LINE__, "testssaunit.ap:579");
         set_error_flag(errorflag, tmp0.cnt != windowwidth - 1, __FILE__, __LINE__, "testssaunit.ap:580");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = windowwidth - 1; i < nticks; i++) {
            v = ae_v_dotproduct(&x.xR[i - (windowwidth - 1)], 1, tmp0.xR, 1, windowwidth - 1);
            set_error_flag(errorflag, fabs(v - x.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:586");
         }
         nticks = windowwidth + 1 + hqrnduniformi(&rs, windowwidth);
         sineoffs = (double)hqrnduniformi(&rs, windowwidth);
         sineamp = 1 + hqrnduniformr(&rs);
         sinefreq = 2.0;
         ae_vector_set_length(&x, nticks);
         for (i = 0; i < nticks; i++) {
            x.xR[i] = sineamp * sin((i + sineoffs) / windowwidth * 2 * pi * sinefreq);
         }
         ssaanalyzesequence(&state, &x, nticks, &trend, &noise);
         set_error_flag(errorflag, noise.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:597");
         set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:598");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < nticks; i++) {
            v = sineamp * sin((i + sineoffs) / windowwidth * 2 * pi * sinefreq);
            set_error_flag(errorflag, fabs(trend.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:604");
            set_error_flag(errorflag, fabs(noise.xR[i] - v) > tol, __FILE__, __LINE__, "testssaunit.ap:605");
         }
         forecastlen = 1 + hqrnduniformi(&rs, nticks - windowwidth);
         datalen = nticks - forecastlen;
         ae_vector_set_length(&x2, datalen);
         for (i = 0; i < datalen; i++) {
            x2.xR[i] = x.xR[i];
         }
         ssaforecastsequence(&state, &x2, datalen, forecastlen, true, &trend);
         for (i = 0; i < forecastlen; i++) {
            set_error_flag(errorflag, fabs(trend.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:614");
         }
      }
   // Test appendPoint() functionality.
   //
   // We have specially designed dataset:
   // * NZeros ticks of exactly zero values
   // * NLinear ticks of series which linearly grow from 0 to 1
   // * NLinear ticks of series which linearly decrease from 1 to 0
   // * NZeros ticks of exactly zero values
   // * NZeros=100
   // * NLinear=20
   //
   // SSA settings have following values:
   // * WindowWidth=4 or 25 (large widths are more problematic for
   //   iterative solvers, so they help to debug incremental updates)
   // * NBasis=2
   //
   // We choose number of initial values to start with NInitial
   // in [1..2*WindowWidth], then add points one
   // by one with SSAAppendPointAndUpdate(). In the end we compare
   // results returned by SSAGetBasis() with that returned by model
   // which was created from full dataset.
   //
   // NOTE: we perform limited amount of passes because this test
   //       has high cost.
      for (pass = 1; pass <= 25; pass++) {
      // Generate dataset
         tol = 1.0E-6;
         nzeros = 100;
         nlinear = 50;
         if (hqrndnormal(&rs) > 0.0) {
            windowwidth = 25;
         } else {
            windowwidth = 4;
         }
         nbasis = 2;
         ninitial = 1 + hqrnduniformi(&rs, 2 * windowwidth);
         ae_vector_set_length(&x, 2 * nzeros + 2 * nlinear);
         for (i = 0; i < x.cnt; i++) {
            x.xR[i] = 0.0;
         }
         for (i = 0; i < nlinear; i++) {
            x.xR[nzeros + i] = (double)i / nlinear;
            x.xR[nzeros + nlinear + i] = 1 - (double)i / nlinear;
         }
         rmatrixrndorthogonal(windowwidth, &b);
      // Build model using many sequential appends
      //
      // NOTE: for NInitial >= WindowWidth with probability 50%
      //       we enforce basis calculation before first
      //       append() call. It helps to debug different
      //       branches of algorithms.
      //
      // NOTE: we may also request delayed power-up of the
      //       algorithm. It also checks various branches of
      //       the algo, although with such settings delayed
      //       power-up is hard to check (initial dataset is
      //       just zeros, zeros, zeros..).
         ae_vector_set_length(&x2, ninitial);
         for (i = 0; i < x2.cnt; i++) {
            x2.xR[i] = x.xR[i];
         }
         ssacreate(&state);
         ssasetwindow(&state, windowwidth);
         ssaaddsequence(&state, &x2, x2.cnt);
         if (algotype == 1) {
            ssasetalgoprecomputed(&state, &b, windowwidth, nbasis);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, nbasis);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, nbasis);
                  if (hqrnduniformr(&rs) > 0.5) {
                     ssasetpoweruplength(&state, 10);
                  }
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         if (ninitial >= windowwidth && hqrnduniformr(&rs) > 0.5) {
            ae_matrix_set_length(&a, 0, 0);
            ae_vector_set_length(&sv, 0);
            windowwidth2 = -1;
            nbasis2 = -1;
            ssagetbasis(&state, &a, &sv, &windowwidth2, &nbasis2);
            set_error_flag(errorflag, windowwidth2 != windowwidth, __FILE__, __LINE__, "testssaunit.ap:705");
            set_error_flag(errorflag, nbasis2 != nbasis, __FILE__, __LINE__, "testssaunit.ap:706");
            set_error_flag(errorflag, a.rows != windowwidth, __FILE__, __LINE__, "testssaunit.ap:707");
            set_error_flag(errorflag, a.cols != nbasis, __FILE__, __LINE__, "testssaunit.ap:708");
            set_error_flag(errorflag, sv.cnt != nbasis, __FILE__, __LINE__, "testssaunit.ap:709");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
         }
         for (i = x2.cnt; i < x.cnt; i++) {
            ssaappendpointandupdate(&state, x.xR[i], 1.0);
         }
         ae_matrix_set_length(&a, 0, 0);
         ae_vector_set_length(&sv, 0);
         windowwidth2 = -1;
         nbasis2 = -1;
         ssagetbasis(&state, &a, &sv, &windowwidth2, &nbasis2);
         set_error_flag(errorflag, windowwidth2 != windowwidth, __FILE__, __LINE__, "testssaunit.ap:720");
         set_error_flag(errorflag, nbasis2 != nbasis, __FILE__, __LINE__, "testssaunit.ap:721");
         set_error_flag(errorflag, a.rows != windowwidth, __FILE__, __LINE__, "testssaunit.ap:722");
         set_error_flag(errorflag, a.cols != nbasis, __FILE__, __LINE__, "testssaunit.ap:723");
         set_error_flag(errorflag, sv.cnt != nbasis, __FILE__, __LINE__, "testssaunit.ap:724");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
      // Build model using one big sequence
         ssacreate(&state2);
         ssasetwindow(&state2, windowwidth);
         ssaaddsequence(&state2, &x, x.cnt);
         if (algotype == 1) {
            ssasetalgoprecomputed(&state2, &b, windowwidth, nbasis);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state2, nbasis);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state2, nbasis);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
         ae_matrix_set_length(&a2, 0, 0);
         ae_vector_set_length(&sv2, 0);
         windowwidth2 = -1;
         nbasis2 = -1;
         ssagetbasis(&state2, &a2, &sv2, &windowwidth2, &nbasis2);
         set_error_flag(errorflag, windowwidth2 != windowwidth, __FILE__, __LINE__, "testssaunit.ap:747");
         set_error_flag(errorflag, nbasis2 != nbasis, __FILE__, __LINE__, "testssaunit.ap:748");
         set_error_flag(errorflag, a2.rows != windowwidth, __FILE__, __LINE__, "testssaunit.ap:749");
         set_error_flag(errorflag, a2.cols != nbasis, __FILE__, __LINE__, "testssaunit.ap:750");
         set_error_flag(errorflag, sv2.cnt != nbasis, __FILE__, __LINE__, "testssaunit.ap:751");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
      // Compare results
         for (i = 0; i < nbasis; i++) {
            set_error_flag(errorflag, fabs(sv.xR[i] - sv2.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:759");
         }
         for (j = 0; j < nbasis; j++) {
            v = ae_v_dotproduct(&a.xyR[0][j], a.stride, &a2.xyR[0][j], a2.stride, windowwidth);
            for (i = 0; i < windowwidth; i++) {
               set_error_flag(errorflag, fabs(a.xyR[i][j] - sign(v) * a2.xyR[i][j]) > tol, __FILE__, __LINE__, "testssaunit.ap:764");
            }
         }
      }
   // Test appendSequence() functionality.
   //
   // We have specially designed dataset:
   // * NNoise sequences of Gaussian noise
   // * NLinear linear sequences partially corrupted by noise
   // * NZeros exactly zero sequences (used to let incremental algo converge)
   // * all sequences have random size in [WindowWidth-2,WindowWidth+2]
   // * NNoise=20
   // * NLinear=20
   //
   // SSA settings have following values:
   // * WindowWidth=4 or 25 (large widths are more problematic for
   //   iterative solvers, so they help to debug incremental updates)
   // * NBasis=2
   //
   // We have two solvers:
   // * one is trained on complete dataset
   // * another one starts from NNoise noisy sequences, linear/zero sequenes
   //   are incrementally appended with AppendSequence
   //
   // NOTE: we perform limited amount of passes because this test
   //       has high cost.
      for (pass = 1; pass <= 25; pass++) {
      // Problem metrics
         tol = 1.0E-5;
         nnoise = 20;
         nlinear = 20;
         nzeros = 50;
         if (hqrndnormal(&rs) > 0.0) {
            windowwidth = 25;
         } else {
            windowwidth = 4;
         }
         nbasis = 2;
      // Initialize solvers
      //
      // NOTE: we set State.DefaultSubspaceIts to large value in order
      //       to ensure convergence to same basis.
         rmatrixrndorthogonal(windowwidth, &b);
         ssacreate(&state);
         ssacreate(&state2);
         state.defaultsubspaceits = 50;
         ssasetwindow(&state, windowwidth);
         ssasetwindow(&state2, windowwidth);
         if (algotype == 1) {
            ssasetalgoprecomputed(&state, &b, windowwidth, nbasis);
            ssasetalgoprecomputed(&state2, &b, windowwidth, nbasis);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, nbasis);
               ssasetalgotopkdirect(&state2, nbasis);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, nbasis);
                  ssasetalgotopkrealtime(&state2, nbasis);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
      // Feed noisy sequences
         for (i = 0; i < nnoise; i++) {
            k = windowwidth + (hqrnduniformi(&rs, 5) - 2);
            ae_vector_set_length(&x, k);
            for (j = 0; j < k; j++) {
               x.xR[j] = hqrndnormal(&rs);
            }
            ssaaddsequence(&state, &x, x.cnt);
            ssaaddsequence(&state2, &x, x.cnt);
         }
      // Feed linear and zero sequences.
      //
      // NOTE: with probability 50% we call SSAGetBasis(State2).
      //       Ideally, SSA should be able to handle appends correctly
      //       with or without preceeding call which requires basis
      //       to be evaluated.
         if (hqrnduniformr(&rs) > 0.5) {
            ae_matrix_set_length(&a2, 0, 0);
            ae_vector_set_length(&sv2, 0);
            windowwidth2 = -1;
            nbasis2 = -1;
            ssagetbasis(&state2, &a2, &sv2, &windowwidth2, &nbasis2);
            set_error_flag(errorflag, windowwidth2 != windowwidth, __FILE__, __LINE__, "testssaunit.ap:865");
            set_error_flag(errorflag, nbasis2 != nbasis, __FILE__, __LINE__, "testssaunit.ap:866");
            set_error_flag(errorflag, a2.rows != windowwidth, __FILE__, __LINE__, "testssaunit.ap:867");
            set_error_flag(errorflag, a2.cols != nbasis, __FILE__, __LINE__, "testssaunit.ap:868");
            set_error_flag(errorflag, sv2.cnt != nbasis, __FILE__, __LINE__, "testssaunit.ap:869");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
         }
         for (i = 0; i < nlinear; i++) {
            k = windowwidth + (hqrnduniformi(&rs, 5) - 2);
            v = hqrndnormal(&rs);
            vv = hqrndnormal(&rs);
            ae_vector_set_length(&x, k);
            x.xR[0] = v;
            for (j = 1; j < k; j++) {
               x.xR[j] = x.xR[j - 1] + vv + 0.1 * hqrndnormal(&rs);
            }
            ssaaddsequence(&state, &x, x.cnt);
            ssaappendsequenceandupdate(&state2, &x, x.cnt, 1.0);
         }
         for (i = 0; i < nzeros; i++) {
            k = windowwidth + (hqrnduniformi(&rs, 5) - 2);
            ae_vector_set_length(&x, k);
            for (j = 0; j < k; j++) {
               x.xR[j] = 0.0;
            }
            ssaaddsequence(&state, &x, x.cnt);
            ssaappendsequenceandupdate(&state2, &x, x.cnt, 1.0);
         }
      // Compare results
         ae_matrix_set_length(&a, 0, 0);
         ae_vector_set_length(&sv, 0);
         windowwidth2 = -1;
         nbasis2 = -1;
         ssagetbasis(&state, &a, &sv, &windowwidth2, &nbasis2);
         set_error_flag(errorflag, windowwidth2 != windowwidth, __FILE__, __LINE__, "testssaunit.ap:903");
         set_error_flag(errorflag, nbasis2 != nbasis, __FILE__, __LINE__, "testssaunit.ap:904");
         set_error_flag(errorflag, a.rows != windowwidth, __FILE__, __LINE__, "testssaunit.ap:905");
         set_error_flag(errorflag, a.cols != nbasis, __FILE__, __LINE__, "testssaunit.ap:906");
         set_error_flag(errorflag, sv.cnt != nbasis, __FILE__, __LINE__, "testssaunit.ap:907");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         ae_matrix_set_length(&a2, 0, 0);
         ae_vector_set_length(&sv2, 0);
         windowwidth2 = -1;
         nbasis2 = -1;
         ssagetbasis(&state2, &a2, &sv2, &windowwidth2, &nbasis2);
         set_error_flag(errorflag, windowwidth2 != windowwidth, __FILE__, __LINE__, "testssaunit.ap:915");
         set_error_flag(errorflag, nbasis2 != nbasis, __FILE__, __LINE__, "testssaunit.ap:916");
         set_error_flag(errorflag, a2.rows != windowwidth, __FILE__, __LINE__, "testssaunit.ap:917");
         set_error_flag(errorflag, a2.cols != nbasis, __FILE__, __LINE__, "testssaunit.ap:918");
         set_error_flag(errorflag, sv2.cnt != nbasis, __FILE__, __LINE__, "testssaunit.ap:919");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < nbasis; i++) {
            set_error_flag(errorflag, fabs(sv.xR[i] - sv2.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:923");
         }
         for (j = 0; j < nbasis; j++) {
            v = ae_v_dotproduct(&a.xyR[0][j], a.stride, &a2.xyR[0][j], a2.stride, windowwidth);
            for (i = 0; i < windowwidth; i++) {
               set_error_flag(errorflag, fabs(a.xyR[i][j] - sign(v) * a2.xyR[i][j]) > tol, __FILE__, __LINE__, "testssaunit.ap:928");
            }
         }
      }
   // Test memory limit functionality.
   //
   // Compare results obtained with HUGE limit vs ones obtained with small limit.
      for (windowwidth = 1; windowwidth <= 20; windowwidth++) {
         for (mlimit = -1; mlimit <= 16; mlimit++) {
         // Not tested
            if (algotype == 1) {
               continue;
            }
         // Problem metrics
            tol = 1.0E-5;
            nticks = 1000 + hqrnduniformi(&rs, 1000);
            if (windowwidth > 5) {
               nbasis = 1 + hqrnduniformi(&rs, 5);
            } else {
               nbasis = 1;
            }
         // Create solvers, dataset, set limits
            ssacreate(&state);
            ssacreate(&state2);
            if (mlimit >= 0) {
               ssasetmemorylimit(&state, iround(pow(2.0, (double)mlimit)));
            } else {
               ssasetmemorylimit(&state, 0);
            }
            ssasetmemorylimit(&state2, 999999999);
            ssasetwindow(&state, windowwidth);
            ssasetwindow(&state2, windowwidth);
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, nbasis);
               ssasetalgotopkdirect(&state2, nbasis);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, nbasis);
                  ssasetalgotopkrealtime(&state2, nbasis);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
            ae_vector_set_length(&x, nticks);
            for (i = 0; i < nticks; i++) {
               x.xR[i] = hqrndnormal(&rs);
            }
            ssaaddsequence(&state, &x, x.cnt);
            ssaaddsequence(&state2, &x, x.cnt);
         // Reset internal temporaries for this test.
         // Implementation-dependent, may fail due to future changes in the core.
            ae_matrix_set_length(&state.uxbatch, 0, 0);
            ae_matrix_set_length(&state.aseqtrajectory, 0, 0);
            ae_matrix_set_length(&state.aseqtbproduct, 0, 0);
         // Test
            ssaanalyzelast(&state, nticks, &trend, &noise);
            ssaanalyzelast(&state2, nticks, &trend2, &noise2);
            for (i = 0; i < nticks; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - trend2.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:1001");
               set_error_flag(errorflag, fabs(noise.xR[i] - noise2.xR[i]) > tol, __FILE__, __LINE__, "testssaunit.ap:1002");
            }
         // Additional tests for sizes of internal arrays.
         // Implementation-dependent, may fail due to future changes in the core.
            if (mlimit >= 0) {
               k = imax2(4 * windowwidth * windowwidth, iround(pow(2.0, (double)mlimit)));
               set_error_flag(errorflag, state.uxbatch.cols * state.uxbatch.rows > k, __FILE__, __LINE__, "testssaunit.ap:1012");
               set_error_flag(errorflag, state.aseqtrajectory.cols * state.aseqtrajectory.rows > k, __FILE__, __LINE__, "testssaunit.ap:1013");
               set_error_flag(errorflag, state.aseqtbproduct.cols * state.aseqtbproduct.rows > k, __FILE__, __LINE__, "testssaunit.ap:1014");
            } else {
               set_error_flag(errorflag, state.uxbatch.rows != nticks - windowwidth + 1, __FILE__, __LINE__, "testssaunit.ap:1018");
               set_error_flag(errorflag, state.aseqtrajectory.rows != nticks - windowwidth + 1, __FILE__, __LINE__, "testssaunit.ap:1019");
               set_error_flag(errorflag, state.aseqtbproduct.rows != nticks - windowwidth + 1, __FILE__, __LINE__, "testssaunit.ap:1020");
            }
         }
      }
   }
// Test power-up ability of the real-time algorithm.
//
// We have specially designed dataset:
// * NTicks ticks of linearly descending from 1 to 0 linear trend,
//   corrupted by random Gaussian noise
// * NZeros ticks of exactly zero values
// * NTicks=100
// * NZeros=100
//
// SSA settings have following values:
// * WindowWidth=4 or 25 (large widths are more problematic for
//   iterative solvers, so they help to debug incremental updates)
// * NBasis=1..2 (only top vectors converge stable enough for unit testing)
// * powerup length is 10
//
// We perform two SSAs:
// * one with full dataset and no powerup
// * one with powerup, NTicks+WindowWidth first elements, followed by appending of NZeros zeros
//
// We check that:
// * basis found by second model (right after initialization) is different
//   from basis of the first one
// * basis found by second model after last append is same as the first one
//
// NOTE: we perform limited amount of passes because this test
//       has high cost.
   for (pass = 1; pass <= 25; pass++) {
   // Generate dataset
      tol = 1.0E-3;
      nticks = 100;
      nzeros = 50;
      if (hqrndnormal(&rs) > 0.0) {
         windowwidth = 25;
      } else {
         windowwidth = 4;
      }
      nbasis = 1 + hqrnduniformi(&rs, 2);
      ae_vector_set_length(&x, nticks + nzeros);
      for (i = 0; i < x.cnt; i++) {
         x.xR[i] = 0.0;
      }
      for (i = 0; i < nticks; i++) {
         x.xR[i] = 1 - (double)i / nticks + 0.05 * hqrndnormal(&rs);
      }
   // Build complete model
   //
   // NOTE: we tweak S.DefaultSubspaceIts in order to enforce convergence to
   //       same basis; for this test we need extra-precise convergence.
      ssacreate(&state2);
      ssasetwindow(&state2, windowwidth);
      ssaaddsequence(&state2, &x, x.cnt);
      ssasetalgotopkrealtime(&state2, nbasis);
      ae_matrix_set_length(&a2, 0, 0);
      ae_vector_set_length(&sv2, 0);
      windowwidth2 = -1;
      nbasis2 = -1;
      ssagetbasis(&state2, &a2, &sv2, &windowwidth2, &nbasis2);
      set_error_flag(errorflag, windowwidth2 != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1088");
      set_error_flag(errorflag, nbasis2 != nbasis, __FILE__, __LINE__, "testssaunit.ap:1089");
      set_error_flag(errorflag, a2.rows != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1090");
      set_error_flag(errorflag, a2.cols != nbasis, __FILE__, __LINE__, "testssaunit.ap:1091");
      set_error_flag(errorflag, sv2.cnt != nbasis, __FILE__, __LINE__, "testssaunit.ap:1092");
      if (*errorflag) {
         ae_frame_leave();
         return;
      }
   // Build model with power-up cycle
   //
   // NOTE: with probability 50% we enforce basis calculation
   //       before first append() call and compare basis with
   //       one returned by full analysis. We do it only in 50%
   //       of the cases because randomness helps to debug different
   //       branches of algorithms.
      ae_vector_set_length(&x2, nticks + windowwidth);
      for (i = 0; i < x2.cnt; i++) {
         x2.xR[i] = x.xR[i];
      }
      ssacreate(&state);
      ssasetwindow(&state, windowwidth);
      ssaaddsequence(&state, &x2, x2.cnt);
      ssasetalgotopkrealtime(&state, nbasis);
      ssasetpoweruplength(&state, 10);
      if (hqrnduniformr(&rs) > 0.5) {
         ae_matrix_set_length(&a, 0, 0);
         ae_vector_set_length(&sv, 0);
         windowwidth2 = -1;
         nbasis2 = -1;
         ssagetbasis(&state, &a, &sv, &windowwidth2, &nbasis2);
         set_error_flag(errorflag, windowwidth2 != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1120");
         set_error_flag(errorflag, nbasis2 != nbasis, __FILE__, __LINE__, "testssaunit.ap:1121");
         set_error_flag(errorflag, a.rows != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1122");
         set_error_flag(errorflag, a.cols != nbasis, __FILE__, __LINE__, "testssaunit.ap:1123");
         set_error_flag(errorflag, sv.cnt != nbasis, __FILE__, __LINE__, "testssaunit.ap:1124");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         vv = 0.0;
         for (i = 0; i < nbasis; i++) {
            vv = rmax2(vv, fabs(sv.xR[i] - sv2.xR[i]));
         }
         for (j = 0; j < nbasis; j++) {
            v = ae_v_dotproduct(&a.xyR[0][j], a.stride, &a2.xyR[0][j], a2.stride, windowwidth);
            for (i = 0; i < windowwidth; i++) {
               vv = rmax2(vv, fabs(a.xyR[i][j] - sign(v) * a2.xyR[i][j]));
            }
         }
         set_error_flag(errorflag, fabs(vv) < tol, __FILE__, __LINE__, "testssaunit.ap:1136");
      }
      for (i = x2.cnt; i < x.cnt; i++) {
         ssaappendpointandupdate(&state, x.xR[i], 1.0);
      }
      ae_matrix_set_length(&a, 0, 0);
      ae_vector_set_length(&sv, 0);
      windowwidth2 = -1;
      nbasis2 = -1;
      ssagetbasis(&state, &a, &sv, &windowwidth2, &nbasis2);
      set_error_flag(errorflag, windowwidth2 != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1145");
      set_error_flag(errorflag, nbasis2 != nbasis, __FILE__, __LINE__, "testssaunit.ap:1146");
      set_error_flag(errorflag, a.rows != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1147");
      set_error_flag(errorflag, a.cols != nbasis, __FILE__, __LINE__, "testssaunit.ap:1148");
      set_error_flag(errorflag, sv.cnt != nbasis, __FILE__, __LINE__, "testssaunit.ap:1149");
      if (*errorflag) {
         ae_frame_leave();
         return;
      }
      vv = 0.0;
      for (i = 0; i < nbasis; i++) {
         vv = rmax2(vv, fabs(sv.xR[i] - sv2.xR[i]));
      }
      for (j = 0; j < nbasis; j++) {
         v = ae_v_dotproduct(&a.xyR[0][j], a.stride, &a2.xyR[0][j], a2.stride, windowwidth);
         for (i = 0; i < windowwidth; i++) {
            vv = rmax2(vv, fabs(a.xyR[i][j] - sign(v) * a2.xyR[i][j]));
         }
      }
      set_error_flag(errorflag, fabs(vv) > tol, __FILE__, __LINE__, "testssaunit.ap:1161");
   }
// Test that SSAForecastAvgLast/Sequence() actually performs averaging.
// We test it by comparing its results vs manually averaged predictions.
//
// Dataset is a small linear trend + Gaussian noise. We are not interested
// in getting meaningful components, we just want to check correctness of math.
   for (pass = 1; pass <= 100; pass++) {
      nticks = 75 + hqrnduniformi(&rs, 75);
      windowwidth = 5 + hqrnduniformi(&rs, 5);
      navg = 1 + hqrnduniformi(&rs, 2 * windowwidth);
      forecastlen = 1 + hqrnduniformi(&rs, 2 * windowwidth);
      ssacreate(&state);
      ssasetwindow(&state, windowwidth);
      ae_vector_set_length(&x, nticks);
      for (i = 0; i < nticks; i++) {
         x.xR[i] = 0.1 * i + hqrndnormal(&rs);
      }
      ssaaddsequence(&state, &x, nticks);
      ssasetalgotopkdirect(&state, 1 + hqrnduniformi(&rs, 3));
      tol = 1.0E-9;
      ssaforecastavglast(&state, navg, forecastlen, &trend);
      ae_vector_set_length(&trend2, forecastlen);
      for (i = 0; i < forecastlen; i++) {
         trend2.xR[i] = 0.0;
      }
      for (i = 0; i < navg; i++) {
         ssaforecastsequence(&state, &x, nticks - i, forecastlen + i, true, &tmp0);
         for (j = 0; j < forecastlen; j++) {
            trend2.xR[j] += tmp0.xR[i + j] / navg;
         }
      }
      for (i = 0; i < forecastlen; i++) {
         set_error_flag(errorflag, fabs(trend.xR[i] - trend2.xR[i]) > tol * rmax3(fabs(trend.xR[i]), fabs(trend2.xR[i]), 1.0), __FILE__, __LINE__, "testssaunit.ap:1198");
      }
      nticks = 75 + hqrnduniformi(&rs, 75);
      j = hqrnduniformi(&rs, 150) - 75;
      ae_vector_set_length(&x2, nticks);
      for (i = 0; i < nticks; i++) {
         x2.xR[i] = 0.1 * (i + j) + hqrndnormal(&rs);
      }
      ssaforecastavgsequence(&state, &x2, nticks, navg, forecastlen, true, &trend);
      ae_vector_set_length(&trend2, forecastlen);
      for (i = 0; i < forecastlen; i++) {
         trend2.xR[i] = 0.0;
      }
      for (i = 0; i < navg; i++) {
         ssaforecastsequence(&state, &x2, nticks - i, forecastlen + i, true, &tmp0);
         for (j = 0; j < forecastlen; j++) {
            trend2.xR[j] += tmp0.xR[i + j] / navg;
         }
      }
      for (i = 0; i < forecastlen; i++) {
         set_error_flag(errorflag, fabs(trend.xR[i] - trend2.xR[i]) > tol * rmax3(fabs(trend.xR[i]), fabs(trend2.xR[i]), 1.0), __FILE__, __LINE__, "testssaunit.ap:1217");
      }
      nticks = 75 + hqrnduniformi(&rs, 75);
      j = hqrnduniformi(&rs, 150) - 75;
      ae_vector_set_length(&x2, nticks);
      for (i = 0; i < nticks; i++) {
         x2.xR[i] = 0.1 * (i + j) + hqrndnormal(&rs);
      }
      ssaforecastavgsequence(&state, &x2, nticks, navg, forecastlen, false, &trend);
      ae_vector_set_length(&trend2, forecastlen);
      for (i = 0; i < forecastlen; i++) {
         trend2.xR[i] = 0.0;
      }
      for (i = 0; i < navg; i++) {
         ssaforecastsequence(&state, &x2, nticks - i, forecastlen + i, false, &tmp0);
         for (j = 0; j < forecastlen; j++) {
            trend2.xR[j] += tmp0.xR[i + j] / navg;
         }
      }
      for (i = 0; i < forecastlen; i++) {
         set_error_flag(errorflag, fabs(trend.xR[i] - trend2.xR[i]) > tol * rmax3(fabs(trend.xR[i]), fabs(trend2.xR[i]), 1.0), __FILE__, __LINE__, "testssaunit.ap:1236");
      }
   }
   ae_frame_leave();
}

// This function tests different special cases (mostly - degenerate ones).
//
// On failure sets ErrorFlag, on success it is untouched.
static void testssaunit_testspecial(bool *errorflag) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_int_t pass;
   ae_int_t algotype;
   ae_int_t nticks;
   ae_int_t nanalyzed;
   ae_int_t nlasttracklen;
   ae_int_t ntracks;
   ae_int_t maxtracklen;
   ae_int_t mintracklen;
   ae_int_t datalen;
   ae_int_t forecastlen;
   ae_int_t windowwidth;
   ae_int_t nbasis;
   ae_int_t windowwidth2;
   ae_int_t passcount;
   double skipprob;
   ae_frame_make(&_frame_block);
   NewObj(ssamodel, state);
   NewObj(ssamodel, state2);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(b, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(sv, 0, DT_REAL);
   NewVector(trend, 0, DT_REAL);
   NewVector(noise, 0, DT_REAL);
   NewVector(trend2, 0, DT_REAL);
   NewVector(noise2, 0, DT_REAL);
   NewMatrix(tracksmatrix, 0, 0, DT_REAL);
   NewVector(trackssizes, 0, DT_INT);
   NewObj(hqrndstate, rs);
// Initialize RNG, test pass count and skip probability.
//
// When we perform several sequential tests on the same model, we may
// skip some of them with probability SkipProb in order to make sure
// that no carry-over effect is observed between tests.
   hqrndrandomize(&rs);
   passcount = 500;
   skipprob = 0.50;
// Test that for empty model in default state:
// * SSAGetBasis() returns zero 1x1 basis
// * SSAAnalyzeLastWindow() returns zeros as trend/noise
// * SSAAnalyzeLast() returns zeros as trend/noise
// * SSAAnalyzeSequence() returns zeros as trend, sequence as noise
// * SSAForecastLast() returns zero trend
// * SSAForecastSequence() returns zero trend
   for (pass = 1; pass <= passcount; pass++) {
      ssacreate(&state);
      if (hqrnduniformr(&rs) > skipprob) {
         ssagetbasis(&state, &a, &sv, &windowwidth, &nbasis);
         set_error_flag(errorflag, windowwidth != 1, __FILE__, __LINE__, "testssaunit.ap:1299");
         set_error_flag(errorflag, nbasis != 1, __FILE__, __LINE__, "testssaunit.ap:1300");
         set_error_flag(errorflag, a.rows != 1, __FILE__, __LINE__, "testssaunit.ap:1301");
         set_error_flag(errorflag, a.cols != 1, __FILE__, __LINE__, "testssaunit.ap:1302");
         set_error_flag(errorflag, sv.cnt != 1, __FILE__, __LINE__, "testssaunit.ap:1303");
         for (i = 0; i < a.rows; i++) {
            for (j = 0; j < a.cols; j++) {
               set_error_flag(errorflag, a.xyR[i][j] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1306");
            }
         }
         for (i = 0; i < sv.cnt; i++) {
            set_error_flag(errorflag, sv.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1308");
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         windowwidth = -1;
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzelastwindow(&state, &trend, &noise, &windowwidth);
         set_error_flag(errorflag, windowwidth != 1, __FILE__, __LINE__, "testssaunit.ap:1316");
         set_error_flag(errorflag, trend.cnt != 1 || trend.xR[0] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1317");
         set_error_flag(errorflag, noise.cnt != 1 || noise.xR[0] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1318");
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzelast(&state, nticks, &trend, &noise);
         set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1326");
         set_error_flag(errorflag, noise.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1327");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < nticks; i++) {
            set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1332");
            set_error_flag(errorflag, noise.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1333");
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&x, nticks);
         for (i = 0; i < nticks; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzesequence(&state, &x, nticks, &trend, &noise);
         set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1345");
         set_error_flag(errorflag, noise.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1346");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < nticks; i++) {
            set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1351");
            set_error_flag(errorflag, noise.xR[i] != x.xR[i], __FILE__, __LINE__, "testssaunit.ap:1352");
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&trend, 0);
         ssaforecastlast(&state, nticks, &trend);
         set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1360");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < nticks; i++) {
            set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1364");
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         datalen = 1 + hqrnduniformi(&rs, 10);
         forecastlen = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&x, datalen);
         for (i = 0; i < datalen; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&trend, 0);
         ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
         set_error_flag(errorflag, trend.cnt != forecastlen, __FILE__, __LINE__, "testssaunit.ap:1375");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < forecastlen; i++) {
            set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1379");
         }
      }
   }
// Test that for empty model with non-default window, but default
// algorithm and no data:
// * SSAGetBasis() returns zero WINDOWx1 basis
// * SSAAnalyzeLastWindow() returns zeros as trend/noise
// * SSAAnalyzeLast() returns zeros as trend/noise
// * SSAAnalyzeSequence() returns zeros as trend, sequence as noise
// * SSAForecastLast() returns zero trend
// * SSAForecastSequence() returns zero trend
   for (pass = 1; pass <= passcount; pass++) {
      windowwidth2 = 1 + hqrnduniformi(&rs, 10);
      ssacreate(&state);
      ssasetwindow(&state, windowwidth2);
      if (hqrnduniformr(&rs) > skipprob) {
         ssagetbasis(&state, &a, &sv, &windowwidth, &nbasis);
         set_error_flag(errorflag, windowwidth != windowwidth2, __FILE__, __LINE__, "testssaunit.ap:1401");
         set_error_flag(errorflag, nbasis != 1, __FILE__, __LINE__, "testssaunit.ap:1402");
         set_error_flag(errorflag, a.rows != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1403");
         set_error_flag(errorflag, a.cols != 1, __FILE__, __LINE__, "testssaunit.ap:1404");
         set_error_flag(errorflag, sv.cnt != 1, __FILE__, __LINE__, "testssaunit.ap:1405");
         for (i = 0; i < a.rows; i++) {
            for (j = 0; j < a.cols; j++) {
               set_error_flag(errorflag, a.xyR[i][j] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1408");
            }
         }
         for (i = 0; i < sv.cnt; i++) {
            set_error_flag(errorflag, sv.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1410");
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         windowwidth = -1;
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzelastwindow(&state, &trend, &noise, &windowwidth);
         set_error_flag(errorflag, windowwidth != windowwidth2, __FILE__, __LINE__, "testssaunit.ap:1418");
         set_error_flag(errorflag, trend.cnt != windowwidth2, __FILE__, __LINE__, "testssaunit.ap:1419");
         set_error_flag(errorflag, noise.cnt != windowwidth2, __FILE__, __LINE__, "testssaunit.ap:1420");
         for (i = 0; i < trend.cnt; i++) {
            set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1422");
         }
         for (i = 0; i < noise.cnt; i++) {
            set_error_flag(errorflag, noise.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1424");
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzelast(&state, nticks, &trend, &noise);
         set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1432");
         set_error_flag(errorflag, noise.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1433");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < nticks; i++) {
            set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1438");
            set_error_flag(errorflag, noise.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1439");
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&x, nticks);
         for (i = 0; i < nticks; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzesequence(&state, &x, nticks, &trend, &noise);
         set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1451");
         set_error_flag(errorflag, noise.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1452");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < nticks; i++) {
            set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1457");
            set_error_flag(errorflag, noise.xR[i] != x.xR[i], __FILE__, __LINE__, "testssaunit.ap:1458");
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&trend, 0);
         ssaforecastlast(&state, nticks, &trend);
         set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1466");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < nticks; i++) {
            set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1470");
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         datalen = 1 + hqrnduniformi(&rs, 10);
         forecastlen = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&x, datalen);
         for (i = 0; i < datalen; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&trend, 0);
         ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
         set_error_flag(errorflag, trend.cnt != forecastlen, __FILE__, __LINE__, "testssaunit.ap:1481");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < forecastlen; i++) {
            set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1485");
         }
      }
   }
// Test that for empty model with default algorithm and one/few tracks
// (which are sometimes shorter than window, sometimes longer than window)
// * SSAGetBasis() returns zero WINDOWx1 basis
// * SSAAnalyzeLastWindow() returns zeros as trend and correctly aligned
//   cropped/padded copy of X in the noise
// * SSAAnalyzeLast() returns zeros as trend and correctly aligned
//   cropped/padded copy of X in the noise
// * SSAAnalyzeSequence() returns zeros as trend, sequence as noise
// * SSAForecastLast() returns zero trend
// * SSAForecastSequence() returns zero trend
   for (pass = 1; pass <= passcount; pass++) {
   // Generate task; last track is stored in X, its length in NLastTrackLen
      nlasttracklen = -999999;
      windowwidth2 = 1 + hqrnduniformi(&rs, 10);
      ntracks = 1 + hqrnduniformi(&rs, 3);
      ssacreate(&state);
      ssasetwindow(&state, windowwidth2);
      ae_matrix_set_length(&tracksmatrix, ntracks, 2 * windowwidth2);
      ae_vector_set_length(&trackssizes, ntracks);
      for (k = 0; k < ntracks; k++) {
         nlasttracklen = hqrnduniformi(&rs, 2 * windowwidth2);
         ae_vector_set_length(&x, nlasttracklen);
         for (i = 0; i < nlasttracklen; i++) {
            x.xR[i] = hqrndnormal(&rs);
            tracksmatrix.xyR[k][i] = x.xR[i];
         }
         trackssizes.xZ[k] = nlasttracklen;
         ssaaddsequence(&state, &x, nlasttracklen);
      }
   // Test
      if (hqrnduniformr(&rs) > skipprob) {
         ssagetbasis(&state, &a, &sv, &windowwidth, &nbasis);
         set_error_flag(errorflag, windowwidth != windowwidth2, __FILE__, __LINE__, "testssaunit.ap:1532");
         set_error_flag(errorflag, nbasis != 1, __FILE__, __LINE__, "testssaunit.ap:1533");
         set_error_flag(errorflag, a.rows != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1534");
         set_error_flag(errorflag, a.cols != 1, __FILE__, __LINE__, "testssaunit.ap:1535");
         set_error_flag(errorflag, sv.cnt != 1, __FILE__, __LINE__, "testssaunit.ap:1536");
         for (i = 0; i < a.rows; i++) {
            for (j = 0; j < a.cols; j++) {
               set_error_flag(errorflag, a.xyR[i][j] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1539");
            }
         }
         for (i = 0; i < sv.cnt; i++) {
            set_error_flag(errorflag, sv.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1541");
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         windowwidth = -1;
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzelastwindow(&state, &trend, &noise, &windowwidth);
         set_error_flag(errorflag, windowwidth != windowwidth2, __FILE__, __LINE__, "testssaunit.ap:1549");
         set_error_flag(errorflag, trend.cnt != windowwidth2, __FILE__, __LINE__, "testssaunit.ap:1550");
         set_error_flag(errorflag, noise.cnt != windowwidth2, __FILE__, __LINE__, "testssaunit.ap:1551");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < windowwidth; i++) {
            set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1555");
         }
         for (i = 0; i < imax2(windowwidth - nlasttracklen, 0); i++) {
            set_error_flag(errorflag, noise.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1557");
         }
         for (i = imax2(windowwidth - nlasttracklen, 0); i < windowwidth; i++) {
            set_error_flag(errorflag, noise.xR[i] != x.xR[nlasttracklen + (i - windowwidth)], __FILE__, __LINE__, "testssaunit.ap:1559");
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nanalyzed = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzelast(&state, nanalyzed, &trend, &noise);
         set_error_flag(errorflag, trend.cnt != nanalyzed, __FILE__, __LINE__, "testssaunit.ap:1567");
         set_error_flag(errorflag, noise.cnt != nanalyzed, __FILE__, __LINE__, "testssaunit.ap:1568");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < nanalyzed; i++) {
            set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1572");
         }
         for (i = 0; i < imax2(nanalyzed - nlasttracklen, 0); i++) {
            set_error_flag(errorflag, noise.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1574");
         }
         for (i = imax2(nanalyzed - nlasttracklen, 0); i < nanalyzed; i++) {
            set_error_flag(errorflag, noise.xR[i] != x.xR[nlasttracklen + (i - nanalyzed)], __FILE__, __LINE__, "testssaunit.ap:1576");
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&x, nticks);
         for (i = 0; i < nticks; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&trend, 0);
         ae_vector_set_length(&noise, 0);
         ssaanalyzesequence(&state, &x, nticks, &trend, &noise);
         set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1587");
         set_error_flag(errorflag, noise.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1588");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < nticks; i++) {
            set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1593");
            set_error_flag(errorflag, noise.xR[i] != x.xR[i], __FILE__, __LINE__, "testssaunit.ap:1594");
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         nticks = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&trend, 0);
         ssaforecastlast(&state, nticks, &trend);
         set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1602");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < nticks; i++) {
            set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1606");
         }
      }
      if (hqrnduniformr(&rs) > skipprob) {
         datalen = 1 + hqrnduniformi(&rs, 10);
         forecastlen = 1 + hqrnduniformi(&rs, 10);
         ae_vector_set_length(&x, datalen);
         for (i = 0; i < datalen; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&trend, 0);
         ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
         set_error_flag(errorflag, trend.cnt != forecastlen, __FILE__, __LINE__, "testssaunit.ap:1617");
         if (*errorflag) {
            ae_frame_leave();
            return;
         }
         for (i = 0; i < forecastlen; i++) {
            set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1621");
         }
      }
   }
// Tests below are performed for all algorithms supported.
   for (algotype = 1; algotype <= 3; algotype++) {
   // Test that SSAClearData() actually clears data
      for (pass = 1; pass <= passcount; pass++) {
         if (algotype == 1) {
            continue;
         }
      // Create two models, one is created after cleardata() call
      // which should erase all traces of the previous dataset.
         ssacreate(&state);
         ssacreate(&state2);
         ssasetwindow(&state, 5);
         ssasetwindow(&state2, 5);
         if (algotype == 2) {
            ssasetalgotopkdirect(&state, 2);
            ssasetalgotopkdirect(&state2, 2);
         } else {
            if (algotype == 3) {
               ssasetalgotopkrealtime(&state, 2);
               ssasetalgotopkrealtime(&state2, 2);
            } else {
               ae_assert(false, "Assertion failed");
            }
         }
         ae_vector_set_length(&x, 10);
         for (i = 0; i < x.cnt; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ssaaddsequence(&state, &x, x.cnt);
         ssacleardata(&state);
         for (i = 0; i < x.cnt; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ssaaddsequence(&state, &x, x.cnt);
         ssaaddsequence(&state2, &x, x.cnt);
      // Test
         ssaanalyzelast(&state, x.cnt, &trend, &noise);
         ssaanalyzelast(&state2, x.cnt, &trend2, &noise2);
         for (i = 0; i < x.cnt; i++) {
            set_error_flag(errorflag, fabs(trend.xR[i] - trend2.xR[i]) > 1.0E-5, __FILE__, __LINE__, "testssaunit.ap:1675");
            set_error_flag(errorflag, fabs(noise.xR[i] - noise2.xR[i]) > 1.0E-5, __FILE__, __LINE__, "testssaunit.ap:1676");
         }
      }
   // Test that for model with some algo being set, one/few tracks and unit window length:
   // * SSAGetBasis() returns 1x1 basis (unit matrix)
   // * SSAAnalyzeLastWindow() returns last element of track as trend and zeros
   //   as noise (with minor rounding error)
   // * SSAAnalyzeLast() returns tracks as trend and zeros as noise (with
   //   minor rounding error possible). For NTicks>TrackLength result is correctly
   //   prepended with zeros.
   // * SSAAnalyzeSequence() returns sequence as trend, zeros as noise (up to
   //   machine precision)
   // * SSAForecastLast() returns just copies of the last element
   // * SSAForecastSequence() returns just copies of the last element
      for (pass = 1; pass <= passcount; pass++) {
      // Generate task; last track is stored in X, its length in NLastTrackLen
         nlasttracklen = -999999;
         maxtracklen = 10;
         ntracks = 1 + hqrnduniformi(&rs, 3);
         ssacreate(&state);
         ssasetwindow(&state, 1);
         ae_matrix_set_length(&tracksmatrix, ntracks, maxtracklen);
         ae_vector_set_length(&trackssizes, ntracks);
         for (k = 0; k < ntracks; k++) {
            nlasttracklen = 1 + hqrnduniformi(&rs, maxtracklen);
            ae_vector_set_length(&x, nlasttracklen);
            for (i = 0; i < nlasttracklen; i++) {
               x.xR[i] = hqrndnormal(&rs);
               tracksmatrix.xyR[k][i] = x.xR[i];
            }
            trackssizes.xZ[k] = nlasttracklen;
            ssaaddsequence(&state, &x, nlasttracklen);
         }
         if (algotype == 1) {
            ae_matrix_set_length(&b, 1, 1);
            b.xyR[0][0] = (double)(2 * hqrnduniformi(&rs, 2) - 1);
            ssasetalgoprecomputed(&state, &b, 1, 1);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, 1);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, 1);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
      // Test
         if (hqrnduniformr(&rs) > skipprob) {
            ssagetbasis(&state, &a, &sv, &windowwidth, &nbasis);
            set_error_flag(errorflag, windowwidth != 1, __FILE__, __LINE__, "testssaunit.ap:1736");
            set_error_flag(errorflag, nbasis != 1, __FILE__, __LINE__, "testssaunit.ap:1737");
            set_error_flag(errorflag, a.rows != 1, __FILE__, __LINE__, "testssaunit.ap:1738");
            set_error_flag(errorflag, a.cols != 1, __FILE__, __LINE__, "testssaunit.ap:1739");
            set_error_flag(errorflag, sv.cnt != 1, __FILE__, __LINE__, "testssaunit.ap:1740");
            set_error_flag(errorflag, fabs(fabs(a.xyR[0][0]) - 1) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1741");
         }
         if (hqrnduniformr(&rs) > skipprob) {
            windowwidth = -1;
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzelastwindow(&state, &trend, &noise, &windowwidth);
            set_error_flag(errorflag, windowwidth != 1, __FILE__, __LINE__, "testssaunit.ap:1749");
            set_error_flag(errorflag, trend.cnt != 1, __FILE__, __LINE__, "testssaunit.ap:1750");
            set_error_flag(errorflag, noise.cnt != 1, __FILE__, __LINE__, "testssaunit.ap:1751");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            set_error_flag(errorflag, fabs(trend.xR[0] - x.xR[nlasttracklen - 1]) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1754");
            set_error_flag(errorflag, fabs(noise.xR[0]) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1755");
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nanalyzed = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzelast(&state, nanalyzed, &trend, &noise);
            set_error_flag(errorflag, trend.cnt != nanalyzed, __FILE__, __LINE__, "testssaunit.ap:1763");
            set_error_flag(errorflag, noise.cnt != nanalyzed, __FILE__, __LINE__, "testssaunit.ap:1764");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < imax2(nanalyzed - nlasttracklen, 0); i++) {
               set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1769");
               set_error_flag(errorflag, noise.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1770");
            }
            for (i = imax2(nanalyzed - nlasttracklen, 0); i < nanalyzed; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - x.xR[i - nanalyzed + nlasttracklen]) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1774");
               set_error_flag(errorflag, fabs(noise.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1775");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&x2, nticks);
            for (i = 0; i < nticks; i++) {
               x2.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzesequence(&state, &x2, nticks, &trend, &noise);
            set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1787");
            set_error_flag(errorflag, noise.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1788");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < nticks; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - x2.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1793");
               set_error_flag(errorflag, fabs(noise.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1794");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&trend, 0);
            ssaforecastlast(&state, nticks, &trend);
            set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1802");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < nticks; i++) {
               set_error_flag(errorflag, trend.xR[i] != x.xR[nlasttracklen - 1], __FILE__, __LINE__, "testssaunit.ap:1806");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            datalen = 1 + hqrnduniformi(&rs, 10);
            forecastlen = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&x, datalen);
            for (i = 0; i < datalen; i++) {
               x.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&trend, 0);
            ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
            set_error_flag(errorflag, trend.cnt != forecastlen, __FILE__, __LINE__, "testssaunit.ap:1817");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < forecastlen; i++) {
               set_error_flag(errorflag, trend.xR[i] != x.xR[datalen - 1], __FILE__, __LINE__, "testssaunit.ap:1821");
            }
         }
      }
   // Test that for model with non-unit window, some algo being set to calculate ALL
   // components, and one/few tracks which have at least window length ticks:
   // * SSAGetBasis() returns full orthonormal basis
   // * SSAAnalyzeLastWindow() returns last elements of track as trend and zeros
   //   as noise (with minor rounding error)
   // * SSAAnalyzeLast() returns track as trend and zeros as noise (with
   //   minor rounding error possible). For NTicks>TrackLength result is correctly
   //   prepended with zeros.
   // * SSAAnalyzeSequence() returns:
   //   * for sequences with length at least window width - sequence as trend,
   //     zeros as noise (up to machine precision)
   //   * for sequences shorter than window width - zeros as trend,
   //     sequence as noise (exactly)
   // * SSAForecastLast() returns just copies of the last element
   // * SSAForecastSequence() returns just copies of the last element for long enough
   //   sequences, zeros for shorter sequences
      for (pass = 1; pass <= passcount; pass++) {
      // Generate task; last track is stored in X, its length in NLastTrackLen
         windowwidth = 1 + hqrnduniformi(&rs, 5);
         ntracks = 1 + hqrnduniformi(&rs, 3);
         mintracklen = windowwidth;
         maxtracklen = mintracklen + 2 * windowwidth;
         ssacreate(&state);
         ssasetwindow(&state, windowwidth);
         ae_matrix_set_length(&tracksmatrix, ntracks, maxtracklen);
         ae_vector_set_length(&trackssizes, ntracks);
         nlasttracklen = 0;
         for (k = 0; k < ntracks; k++) {
            nlasttracklen = mintracklen + hqrnduniformi(&rs, maxtracklen - mintracklen + 1);
            ae_vector_set_length(&x, nlasttracklen);
            for (i = 0; i < nlasttracklen; i++) {
               x.xR[i] = hqrndnormal(&rs);
               tracksmatrix.xyR[k][i] = x.xR[i];
            }
            trackssizes.xZ[k] = nlasttracklen;
            ssaaddsequence(&state, &x, nlasttracklen);
         }
         if (algotype == 1) {
            rmatrixrndorthogonal(windowwidth, &b);
            ssasetalgoprecomputed(&state, &b, windowwidth, windowwidth);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, windowwidth);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, windowwidth);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
      // Test
         if (hqrnduniformr(&rs) > skipprob) {
            ssagetbasis(&state, &a, &sv, &windowwidth2, &nbasis);
            set_error_flag(errorflag, windowwidth2 != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1888");
            set_error_flag(errorflag, nbasis != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1889");
            set_error_flag(errorflag, a.rows != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1890");
            set_error_flag(errorflag, a.cols != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1891");
            set_error_flag(errorflag, sv.cnt != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1892");
            for (i = 0; i < windowwidth; i++) {
               for (j = 0; j < windowwidth; j++) {
                  v = ae_v_dotproduct(a.xyR[i], 1, a.xyR[j], 1, windowwidth);
                  if (i == j) {
                     v--;
                  }
                  set_error_flag(errorflag, fabs(v) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1899");
               }
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            windowwidth2 = -1;
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzelastwindow(&state, &trend, &noise, &windowwidth2);
            set_error_flag(errorflag, windowwidth2 != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1908");
            set_error_flag(errorflag, trend.cnt != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1909");
            set_error_flag(errorflag, noise.cnt != windowwidth, __FILE__, __LINE__, "testssaunit.ap:1910");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < windowwidth; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - x.xR[i - windowwidth + nlasttracklen]) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1915");
               set_error_flag(errorflag, fabs(noise.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1916");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nanalyzed = 1 + hqrnduniformi(&rs, 2 * maxtracklen);
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzelast(&state, nanalyzed, &trend, &noise);
            set_error_flag(errorflag, trend.cnt != nanalyzed, __FILE__, __LINE__, "testssaunit.ap:1925");
            set_error_flag(errorflag, noise.cnt != nanalyzed, __FILE__, __LINE__, "testssaunit.ap:1926");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < imax2(nanalyzed - nlasttracklen, 0); i++) {
               set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1931");
               set_error_flag(errorflag, noise.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1932");
            }
            for (i = imax2(nanalyzed - nlasttracklen, 0); i < nanalyzed; i++) {
               set_error_flag(errorflag, fabs(trend.xR[i] - x.xR[i - nanalyzed + nlasttracklen]) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1936");
               set_error_flag(errorflag, fabs(noise.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1937");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 2 * windowwidth);
            ae_vector_set_length(&x2, nticks);
            for (i = 0; i < nticks; i++) {
               x2.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzesequence(&state, &x2, nticks, &trend, &noise);
            set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1949");
            set_error_flag(errorflag, noise.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1950");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < nticks; i++) {
               if (nticks >= windowwidth) {
                  set_error_flag(errorflag, fabs(trend.xR[i] - x2.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1957");
                  set_error_flag(errorflag, fabs(noise.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1958");
               } else {
                  set_error_flag(errorflag, fabs(trend.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1962");
                  set_error_flag(errorflag, fabs(noise.xR[i] - x2.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testssaunit.ap:1963");
               }
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&trend, 0);
            ssaforecastlast(&state, nticks, &trend);
            set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:1972");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < nticks; i++) {
               set_error_flag(errorflag, trend.xR[i] != x.xR[nlasttracklen - 1], __FILE__, __LINE__, "testssaunit.ap:1976");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            if (windowwidth > 2) {
               datalen = 1 + hqrnduniformi(&rs, windowwidth - 1);
               forecastlen = 1 + hqrnduniformi(&rs, 10);
               ae_vector_set_length(&x, datalen);
               for (i = 0; i < datalen; i++) {
                  x.xR[i] = hqrndnormal(&rs);
               }
               ae_vector_set_length(&trend, 0);
               ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
               set_error_flag(errorflag, trend.cnt != forecastlen, __FILE__, __LINE__, "testssaunit.ap:1990");
               if (*errorflag) {
                  ae_frame_leave();
                  return;
               }
               for (i = 0; i < forecastlen; i++) {
                  set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:1994");
               }
            }
            datalen = windowwidth + hqrnduniformi(&rs, windowwidth);
            forecastlen = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&x, datalen);
            for (i = 0; i < datalen; i++) {
               x.xR[i] = hqrndnormal(&rs);
            }
            ae_vector_set_length(&trend, 0);
            ssaforecastsequence(&state, &x, datalen, forecastlen, hqrndnormal(&rs) > 0.0, &trend);
            set_error_flag(errorflag, trend.cnt != forecastlen, __FILE__, __LINE__, "testssaunit.ap:2005");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < forecastlen; i++) {
               set_error_flag(errorflag, trend.xR[i] != x.xR[datalen - 1], __FILE__, __LINE__, "testssaunit.ap:2009");
            }
         }
      }
   // Test that for model with
   //
   // * strictly non-unit window
   // * some algo being set to calculate one leading component
   // * a few tracks which have at least window length ticks
   // * and last track which has LESS than window length minus 1 ticks
   //
   // we have:
   //
   // * SSAAnalyzeLastWindow() returns zero trend and sequence as noise,
   //   correctly padded by zeros
   // * SSAAnalyzeLast() returns zero trend and sequence as noise,
   //   correctly padded by zeros
   // * SSAForecastLast() returns zero trend
   //
   // This test checks correct handling of the situatuon when last sequence
   // stored in the dataset is too short.
      for (pass = 1; pass <= passcount; pass++) {
      // Generate task; last track is stored in X, its length in NLastTrackLen
         windowwidth = 3 + hqrnduniformi(&rs, 5);
         ntracks = 1 + hqrnduniformi(&rs, 3);
         mintracklen = windowwidth;
         maxtracklen = mintracklen + 2 * windowwidth;
         ssacreate(&state);
         ssasetwindow(&state, windowwidth);
         for (k = 0; k < ntracks; k++) {
            nlasttracklen = mintracklen + hqrnduniformi(&rs, maxtracklen - mintracklen + 1);
            ae_vector_set_length(&x, nlasttracklen);
            for (i = 0; i < nlasttracklen; i++) {
               x.xR[i] = hqrndnormal(&rs);
            }
            ssaaddsequence(&state, &x, nlasttracklen);
         }
         nlasttracklen = windowwidth - 2;
         ae_vector_set_length(&x, nlasttracklen);
         for (i = 0; i < nlasttracklen; i++) {
            x.xR[i] = hqrndnormal(&rs);
         }
         ssaaddsequence(&state, &x, nlasttracklen);
         if (algotype == 1) {
            rmatrixrndorthogonal(windowwidth, &b);
            ssasetalgoprecomputed(&state, &b, windowwidth, 1);
         } else {
            if (algotype == 2) {
               ssasetalgotopkdirect(&state, 1);
            } else {
               if (algotype == 3) {
                  ssasetalgotopkrealtime(&state, 1);
               } else {
                  ae_assert(false, "Assertion failed");
               }
            }
         }
      // Test
         if (hqrnduniformr(&rs) > skipprob) {
            windowwidth2 = -1;
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzelastwindow(&state, &trend, &noise, &windowwidth2);
            set_error_flag(errorflag, windowwidth2 != windowwidth, __FILE__, __LINE__, "testssaunit.ap:2078");
            set_error_flag(errorflag, trend.cnt != windowwidth, __FILE__, __LINE__, "testssaunit.ap:2079");
            set_error_flag(errorflag, noise.cnt != windowwidth, __FILE__, __LINE__, "testssaunit.ap:2080");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < windowwidth; i++) {
               set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:2085");
               j = nlasttracklen + (i - windowwidth);
               if (j >= 0) {
                  set_error_flag(errorflag, noise.xR[i] != x.xR[j], __FILE__, __LINE__, "testssaunit.ap:2088");
               } else {
                  set_error_flag(errorflag, noise.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:2090");
               }
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nanalyzed = 1 + hqrnduniformi(&rs, 2 * windowwidth);
            ae_vector_set_length(&trend, 0);
            ae_vector_set_length(&noise, 0);
            ssaanalyzelast(&state, nanalyzed, &trend, &noise);
            set_error_flag(errorflag, trend.cnt != nanalyzed, __FILE__, __LINE__, "testssaunit.ap:2099");
            set_error_flag(errorflag, noise.cnt != nanalyzed, __FILE__, __LINE__, "testssaunit.ap:2100");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < imax2(nanalyzed - nlasttracklen, 0); i++) {
               set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:2105");
               set_error_flag(errorflag, noise.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:2106");
            }
            for (i = imax2(nanalyzed - nlasttracklen, 0); i < nanalyzed; i++) {
               set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:2110");
               set_error_flag(errorflag, noise.xR[i] != x.xR[nlasttracklen + (i - nanalyzed)], __FILE__, __LINE__, "testssaunit.ap:2111");
            }
         }
         if (hqrnduniformr(&rs) > skipprob) {
            nticks = 1 + hqrnduniformi(&rs, 10);
            ae_vector_set_length(&trend, 0);
            ssaforecastlast(&state, nticks, &trend);
            set_error_flag(errorflag, trend.cnt != nticks, __FILE__, __LINE__, "testssaunit.ap:2119");
            if (*errorflag) {
               ae_frame_leave();
               return;
            }
            for (i = 0; i < nticks; i++) {
               set_error_flag(errorflag, trend.xR[i] != 0.0, __FILE__, __LINE__, "testssaunit.ap:2123");
            }
         }
      }
   }
   ae_frame_leave();
}

bool testssa(bool silent) {
   bool specerrors;
   bool generrors;
   bool wereerrors;
   bool result;
   specerrors = false;
   generrors = false;
   testssaunit_testspecial(&specerrors);
   testssaunit_testgeneral(&generrors);
// Final report
   wereerrors = specerrors || generrors;
   if (!silent) {
      printf("SSA TEST\n");
      printf("* GENERAL TEST SUITE                     ");
      if (!generrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* SPECIAL CASES                          ");
      if (!specerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (wereerrors) {
         printf("TEST SUMMARY: FAILED\n");
      } else {
         printf("TEST SUMMARY: PASSED\n");
      }
      printf("\n\n");
   }
   result = !wereerrors;
   return result;
}

// === lda testing unit ===
// Normal random number
static double testldaunit_generatenormal(double mean, double sigma) {
   double u;
   double v;
   double sum;
   double result;
   result = mean;
   while (true) {
      u = (2 * randominteger(2) - 1) * randomreal();
      v = (2 * randominteger(2) - 1) * randomreal();
      sum = u * u + v * v;
      if (sum < 1.0 && sum > 0.0) {
         sum = sqrt(-2 * log(sum) / sum);
         result = sigma * u * sum + mean;
         break;
      }
   }
   return result;
}

// Generates 'simple' set - a sequence of unit 'balls' at (0,0), (1,0), (2,0)
// and so on.
static void testldaunit_gensimpleset(ae_int_t nfeatures, ae_int_t nclasses, ae_int_t nsamples, ae_int_t axis, RMatrix *xy) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t c;
   SetMatrix(xy);
   ae_assert(axis >= 0 && axis < nfeatures, "GenSimpleSet: wrong Axis!");
   ae_matrix_set_length(xy, nsamples - 1 + 1, nfeatures + 1);
   for (i = 0; i < nsamples; i++) {
      for (j = 0; j < nfeatures; j++) {
         xy->xyR[i][j] = testldaunit_generatenormal(0.0, 1.0);
      }
      c = i % nclasses;
      xy->xyR[i][axis] += c;
      xy->xyR[i][nfeatures] = (double)c;
   }
}

// Generates 'degenerate' set #1.
// NFeatures >= 3.
static void testldaunit_gendeg1set(ae_int_t nfeatures, ae_int_t nclasses, ae_int_t nsamples, ae_int_t axis, RMatrix *xy) {
   ae_int_t i;
   ae_int_t j;
   ae_int_t c;
   SetMatrix(xy);
   ae_assert(axis >= 0 && axis < nfeatures, "GenDeg1Set: wrong Axis!");
   ae_assert(nfeatures >= 3, "GenDeg1Set: wrong NFeatures!");
   ae_matrix_set_length(xy, nsamples - 1 + 1, nfeatures + 1);
   if (axis >= nfeatures - 2) {
      axis = nfeatures - 3;
   }
   for (i = 0; i < nsamples; i++) {
      for (j = 0; j < nfeatures - 1; j++) {
         xy->xyR[i][j] = testldaunit_generatenormal(0.0, 1.0);
      }
      xy->xyR[i][nfeatures - 1] = xy->xyR[i][nfeatures - 2];
      c = i % nclasses;
      xy->xyR[i][axis] += c;
      xy->xyR[i][nfeatures] = (double)c;
   }
}

// Calculates J
static double testldaunit_calcj(ae_int_t nf, RMatrix *st, RMatrix *sw, RVector *w, double *p, double *q) {
   ae_frame _frame_block;
   ae_int_t i;
   double v;
   double result;
   ae_frame_make(&_frame_block);
   *p = 0;
   *q = 0;
   NewVector(tx, 0, DT_REAL);
   ae_vector_set_length(&tx, nf - 1 + 1);
   for (i = 0; i < nf; i++) {
      v = ae_v_dotproduct(st->xyR[i], 1, w->xR, 1, nf);
      tx.xR[i] = v;
   }
   v = ae_v_dotproduct(w->xR, 1, tx.xR, 1, nf);
   *p = v;
   for (i = 0; i < nf; i++) {
      v = ae_v_dotproduct(sw->xyR[i], 1, w->xR, 1, nf);
      tx.xR[i] = v;
   }
   v = ae_v_dotproduct(w->xR, 1, tx.xR, 1, nf);
   *q = v;
   result = *p / (*q);
   ae_frame_leave();
   return result;
}

// Calculates ST/SW
static void testldaunit_fishers(RMatrix *xy, ae_int_t npoints, ae_int_t nfeatures, ae_int_t nclasses, RMatrix *st, RMatrix *sw) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_frame_make(&_frame_block);
   SetMatrix(st);
   SetMatrix(sw);
   NewVector(c, 0, DT_INT);
   NewVector(mu, 0, DT_REAL);
   NewMatrix(muc, 0, 0, DT_REAL);
   NewVector(nc, 0, DT_INT);
   NewVector(tf, 0, DT_REAL);
   NewVector(work, 0, DT_REAL);
// Prepare temporaries
   ae_vector_set_length(&tf, nfeatures - 1 + 1);
   ae_vector_set_length(&work, nfeatures + 1);
// Convert class labels from reals to integers (just for convenience)
   ae_vector_set_length(&c, npoints - 1 + 1);
   for (i = 0; i < npoints; i++) {
      c.xZ[i] = iround(xy->xyR[i][nfeatures]);
   }
// Calculate class sizes and means
   ae_vector_set_length(&mu, nfeatures - 1 + 1);
   ae_matrix_set_length(&muc, nclasses - 1 + 1, nfeatures - 1 + 1);
   ae_vector_set_length(&nc, nclasses - 1 + 1);
   for (j = 0; j < nfeatures; j++) {
      mu.xR[j] = 0.0;
   }
   for (i = 0; i < nclasses; i++) {
      nc.xZ[i] = 0;
      for (j = 0; j < nfeatures; j++) {
         muc.xyR[i][j] = 0.0;
      }
   }
   for (i = 0; i < npoints; i++) {
      ae_v_add(mu.xR, 1, xy->xyR[i], 1, nfeatures);
      ae_v_add(muc.xyR[c.xZ[i]], 1, xy->xyR[i], 1, nfeatures);
      nc.xZ[c.xZ[i]]++;
   }
   for (i = 0; i < nclasses; i++) {
      v = 1.0 / nc.xZ[i];
      ae_v_muld(muc.xyR[i], 1, nfeatures, v);
   }
   v = 1.0 / npoints;
   ae_v_muld(mu.xR, 1, nfeatures, v);
// Create ST matrix
   ae_matrix_set_length(st, nfeatures - 1 + 1, nfeatures - 1 + 1);
   for (i = 0; i < nfeatures; i++) {
      for (j = 0; j < nfeatures; j++) {
         st->xyR[i][j] = 0.0;
      }
   }
   for (k = 0; k < npoints; k++) {
      ae_v_move(tf.xR, 1, xy->xyR[k], 1, nfeatures);
      ae_v_sub(tf.xR, 1, mu.xR, 1, nfeatures);
      for (i = 0; i < nfeatures; i++) {
         v = tf.xR[i];
         ae_v_addd(st->xyR[i], 1, tf.xR, 1, nfeatures, v);
      }
   }
// Create SW matrix
   ae_matrix_set_length(sw, nfeatures - 1 + 1, nfeatures - 1 + 1);
   for (i = 0; i < nfeatures; i++) {
      for (j = 0; j < nfeatures; j++) {
         sw->xyR[i][j] = 0.0;
      }
   }
   for (k = 0; k < npoints; k++) {
      ae_v_move(tf.xR, 1, xy->xyR[k], 1, nfeatures);
      ae_v_sub(tf.xR, 1, muc.xyR[c.xZ[k]], 1, nfeatures);
      for (i = 0; i < nfeatures; i++) {
         v = tf.xR[i];
         ae_v_addd(sw->xyR[i], 1, tf.xR, 1, nfeatures, v);
      }
   }
   ae_frame_leave();
}

// Tests WN for correctness
static bool testldaunit_testwn(RMatrix *xy, RMatrix *wn, ae_int_t ns, ae_int_t nf, ae_int_t nc, ae_int_t ndeg) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t j;
   double v;
   double wprev;
   double tol;
   double p;
   double q;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(st, 0, 0, DT_REAL);
   NewMatrix(sw, 0, 0, DT_REAL);
   NewMatrix(a, 0, 0, DT_REAL);
   NewMatrix(z, 0, 0, DT_REAL);
   NewVector(tx, 0, DT_REAL);
   NewVector(jp, 0, DT_REAL);
   NewVector(jq, 0, DT_REAL);
   NewVector(work, 0, DT_REAL);
   tol = 10000.0;
   result = true;
   testldaunit_fishers(xy, ns, nf, nc, &st, &sw);
// Test for decreasing of J
   ae_vector_set_length(&tx, nf - 1 + 1);
   ae_vector_set_length(&jp, nf - 1 + 1);
   ae_vector_set_length(&jq, nf - 1 + 1);
   for (j = 0; j < nf; j++) {
      ae_v_move(tx.xR, 1, &wn->xyR[0][j], wn->stride, nf);
      v = testldaunit_calcj(nf, &st, &sw, &tx, &p, &q);
      jp.xR[j] = p;
      jq.xR[j] = q;
   }
   for (i = 1; i < nf - ndeg; i++) {
      result = result && jp.xR[i - 1] / jq.xR[i - 1] >= (1 - tol * machineepsilon) * jp.xR[i] / jq.xR[i];
   }
   for (i = nf - 1 - ndeg + 1; i < nf; i++) {
      result = result && jp.xR[i] <= tol * machineepsilon * jp.xR[0];
   }
// Test for J optimality
   ae_v_move(tx.xR, 1, wn->xyR[0], wn->stride, nf);
   v = testldaunit_calcj(nf, &st, &sw, &tx, &p, &q);
   for (i = 0; i < nf; i++) {
      wprev = tx.xR[i];
      tx.xR[i] = wprev + 0.01;
      result = result && v >= (1 - tol * machineepsilon) * testldaunit_calcj(nf, &st, &sw, &tx, &p, &q);
      tx.xR[i] = wprev - 0.01;
      result = result && v >= (1 - tol * machineepsilon) * testldaunit_calcj(nf, &st, &sw, &tx, &p, &q);
      tx.xR[i] = wprev;
   }
// Test for linear independence of W
   ae_vector_set_length(&work, nf + 1);
   ae_matrix_set_length(&a, nf - 1 + 1, nf - 1 + 1);
   matrixmatrixmultiply(wn, 0, nf - 1, 0, nf - 1, false, wn, 0, nf - 1, 0, nf - 1, true, 1.0, &a, 0, nf - 1, 0, nf - 1, 0.0, &work);
   if (smatrixevd(&a, nf, 1, true, &tx, &z)) {
      result = result && tx.xR[0] > tx.xR[nf - 1] * 1000 * machineepsilon;
   }
// Test for other properties
   for (j = 0; j < nf; j++) {
      v = ae_v_dotproduct(&wn->xyR[0][j], wn->stride, &wn->xyR[0][j], wn->stride, nf);
      v = sqrt(v);
      result = result && fabs(v - 1) <= 1000 * machineepsilon;
      v = 0.0;
      for (i = 0; i < nf; i++) {
         v += wn->xyR[i][j];
      }
      result = result && v >= 0.0;
   }
   ae_frame_leave();
   return result;
}

bool testlda(bool silent) {
   ae_frame _frame_block;
   ae_int_t maxnf;
   ae_int_t maxns;
   ae_int_t maxnc;
   ae_int_t passcount;
   bool ldanerrors;
   bool lda1errors;
   bool waserrors;
   ae_int_t nf;
   ae_int_t nc;
   ae_int_t ns;
   ae_int_t i;
   ae_int_t info;
   ae_int_t pass;
   ae_int_t axis;
   bool result;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(wn, 0, 0, DT_REAL);
   NewVector(w1, 0, DT_REAL);
// Primary settings
   maxnf = 10;
   maxns = 1000;
   maxnc = 5;
   passcount = 1;
   waserrors = false;
   ldanerrors = false;
   lda1errors = false;
// General tests
   for (nf = 1; nf <= maxnf; nf++) {
      for (nc = 2; nc <= maxnc; nc++) {
         for (pass = 1; pass <= passcount; pass++) {
         // Simple test for LDA-N/LDA-1
            axis = randominteger(nf);
            ns = maxns / 2 + randominteger(maxns / 2);
            testldaunit_gensimpleset(nf, nc, ns, axis, &xy);
            fisherldan(&xy, ns, nf, nc, &info, &wn);
            if (info != 1) {
               set_error_flag(&ldanerrors, true, __FILE__, __LINE__, "testldaunit.ap:53");
               continue;
            }
            set_error_flag(&ldanerrors, !testldaunit_testwn(&xy, &wn, ns, nf, nc, 0), __FILE__, __LINE__, "testldaunit.ap:56");
            set_error_flag(&ldanerrors, fabs(wn.xyR[axis][0]) <= 0.75, __FILE__, __LINE__, "testldaunit.ap:57");
            fisherlda(&xy, ns, nf, nc, &info, &w1);
            for (i = 0; i < nf; i++) {
               set_error_flag(&lda1errors, w1.xR[i] != wn.xyR[i][0], __FILE__, __LINE__, "testldaunit.ap:60");
            }
         // Degenerate test for LDA-N
            if (nf >= 3) {
               ns = maxns / 2 + randominteger(maxns / 2);
            // there are two duplicate features,
            // axis is oriented along non-duplicate feature
               axis = randominteger(nf - 2);
               testldaunit_gendeg1set(nf, nc, ns, axis, &xy);
               fisherldan(&xy, ns, nf, nc, &info, &wn);
               if (info != 2) {
                  set_error_flag(&ldanerrors, true, __FILE__, __LINE__, "testldaunit.ap:78");
                  continue;
               }
               set_error_flag(&ldanerrors, fabs(wn.xyR[axis][0]) <= 0.75, __FILE__, __LINE__, "testldaunit.ap:81");
               fisherlda(&xy, ns, nf, nc, &info, &w1);
               for (i = 0; i < nf; i++) {
                  set_error_flag(&lda1errors, w1.xR[i] != wn.xyR[i][0], __FILE__, __LINE__, "testldaunit.ap:84");
               }
            }
         }
      }
   }
// Final report
   waserrors = ldanerrors || lda1errors;
   if (!silent) {
      printf("LDA TEST\n");
      printf("FISHER LDA-N:                            ");
      if (!ldanerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("FISHER LDA-1:                            ");
      if (!lda1errors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST SUMMARY: FAILED\n");
      } else {
         printf("TEST SUMMARY: PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === mcpd testing unit ===
// Simple test with no "entry"/"exit" states
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testmcpdunit_testsimple(bool *err) {
   ae_frame _frame_block;
   ae_int_t n;
   double threshold;
   ae_int_t i;
   ae_int_t j;
   double v;
   double v0;
   double offdiagonal;
   ae_frame_make(&_frame_block);
   NewMatrix(pexact, 0, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(p, 0, 0, DT_REAL);
   NewObj(mcpdstate, s);
   NewObj(mcpdreport, rep);
   threshold = 1.0E-2;
// First test:
// * N-dimensional problem
// * proportional data
// * no "entry"/"exit" states
// * N tracks, each includes only two states
// * first record in I-th track is [0 ... 1 ... 0] with 1 is in I-th position
// * all tracks are modelled using randomly generated transition matrix P
   for (n = 1; n <= 5; n++) {
   // Initialize "exact" P:
   // * fill by random values
   // * make sure that each column sums to non-zero value
   // * normalize
      ae_matrix_set_length(&pexact, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            pexact.xyR[i][j] = randomreal();
         }
      }
      for (j = 0; j < n; j++) {
         i = randominteger(n);
         pexact.xyR[i][j] += 0.1;
      }
      for (j = 0; j < n; j++) {
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += pexact.xyR[i][j];
         }
         for (i = 0; i < n; i++) {
            pexact.xyR[i][j] /= v;
         }
      }
   // Initialize solver:
   // * create object
   // * add tracks
      mcpdcreate(n, &s);
      for (i = 0; i < n; i++) {
         ae_matrix_set_length(&xy, 2, n);
         for (j = 0; j < n; j++) {
            xy.xyR[0][j] = 0.0;
         }
         xy.xyR[0][i] = 1.0;
         for (j = 0; j < n; j++) {
            xy.xyR[1][j] = pexact.xyR[j][i];
         }
         mcpdaddtrack(&s, &xy, 2);
      }
   // Solve and test
      mcpdsolve(&s);
      mcpdresults(&s, &p, &rep);
      if (rep.terminationtype > 0) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               *err = *err || fabs(p.xyR[i][j] - pexact.xyR[i][j]) > threshold;
            }
         }
      } else {
         *err = true;
      }
   }
// Second test:
// * N-dimensional problem
// * proportional data
// * no "entry"/"exit" states
// * N tracks, each includes only two states
// * first record in I-th track is [0 ...0.1 0.8 0.1 ... 0] with 0.8 is in I-th position
// * all tracks are modelled using randomly generated transition matrix P
   offdiagonal = 0.1;
   for (n = 1; n <= 5; n++) {
   // Initialize "exact" P:
   // * fill by random values
   // * make sure that each column sums to non-zero value
   // * normalize
      ae_matrix_set_length(&pexact, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            pexact.xyR[i][j] = randomreal();
         }
      }
      for (j = 0; j < n; j++) {
         i = randominteger(n);
         pexact.xyR[i][j] += 0.1;
      }
      for (j = 0; j < n; j++) {
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += pexact.xyR[i][j];
         }
         for (i = 0; i < n; i++) {
            pexact.xyR[i][j] /= v;
         }
      }
   // Initialize solver:
   // * create object
   // * add tracks
      mcpdcreate(n, &s);
      for (i = 0; i < n; i++) {
         ae_matrix_set_length(&xy, 2, n);
         for (j = 0; j < n; j++) {
            xy.xyR[0][j] = 0.0;
         }
      // "main" element
         xy.xyR[0][i] = 1.0 - 2 * offdiagonal;
         for (j = 0; j < n; j++) {
            xy.xyR[1][j] = (1.0 - 2 * offdiagonal) * pexact.xyR[j][i];
         }
      // off-diagonal ones
         if (i > 0) {
            xy.xyR[0][i - 1] = offdiagonal;
            for (j = 0; j < n; j++) {
               xy.xyR[1][j] += offdiagonal * pexact.xyR[j][i - 1];
            }
         }
         if (i < n - 1) {
            xy.xyR[0][i + 1] = offdiagonal;
            for (j = 0; j < n; j++) {
               xy.xyR[1][j] += offdiagonal * pexact.xyR[j][i + 1];
            }
         }
         mcpdaddtrack(&s, &xy, 2);
      }
   // Solve and test
      mcpdsolve(&s);
      mcpdresults(&s, &p, &rep);
      if (rep.terminationtype > 0) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               *err = *err || fabs(p.xyR[i][j] - pexact.xyR[i][j]) > threshold;
            }
         }
      } else {
         *err = true;
      }
   }
// Third test:
// * N-dimensional problem
// * population data
// * no "entry"/"exit" states
// * N tracks, each includes only two states
// * first record in I-th track is V*[0 ...0.1 0.8 0.1 ... 0] with 0.8 is in I-th position, V in [1,10]
// * all tracks are modelled using randomly generated transition matrix P
   offdiagonal = 0.1;
   for (n = 1; n <= 5; n++) {
   // Initialize "exact" P:
   // * fill by random values
   // * make sure that each column sums to non-zero value
   // * normalize
      ae_matrix_set_length(&pexact, n, n);
      for (i = 0; i < n; i++) {
         for (j = 0; j < n; j++) {
            pexact.xyR[i][j] = randomreal();
         }
      }
      for (j = 0; j < n; j++) {
         i = randominteger(n);
         pexact.xyR[i][j] += 0.1;
      }
      for (j = 0; j < n; j++) {
         v = 0.0;
         for (i = 0; i < n; i++) {
            v += pexact.xyR[i][j];
         }
         for (i = 0; i < n; i++) {
            pexact.xyR[i][j] /= v;
         }
      }
   // Initialize solver:
   // * create object
   // * add tracks
      mcpdcreate(n, &s);
      for (i = 0; i < n; i++) {
         ae_matrix_set_length(&xy, 2, n);
         for (j = 0; j < n; j++) {
            xy.xyR[0][j] = 0.0;
         }
      // "main" element
         v0 = 9 * randomreal() + 1;
         xy.xyR[0][i] = v0 * (1.0 - 2 * offdiagonal);
         for (j = 0; j < n; j++) {
            xy.xyR[1][j] = v0 * (1.0 - 2 * offdiagonal) * pexact.xyR[j][i];
         }
      // off-diagonal ones
         if (i > 0) {
            xy.xyR[0][i - 1] = v0 * offdiagonal;
            for (j = 0; j < n; j++) {
               xy.xyR[1][j] += v0 * offdiagonal * pexact.xyR[j][i - 1];
            }
         }
         if (i < n - 1) {
            xy.xyR[0][i + 1] = v0 * offdiagonal;
            for (j = 0; j < n; j++) {
               xy.xyR[1][j] += v0 * offdiagonal * pexact.xyR[j][i + 1];
            }
         }
         mcpdaddtrack(&s, &xy, 2);
      }
   // Solve and test
      mcpdsolve(&s);
      mcpdresults(&s, &p, &rep);
      if (rep.terminationtype > 0) {
         for (i = 0; i < n; i++) {
            for (j = 0; j < n; j++) {
               *err = *err || fabs(p.xyR[i][j] - pexact.xyR[i][j]) > threshold;
            }
         }
      } else {
         *err = true;
      }
   }
   ae_frame_leave();
}

// Test for different combinations of "entry"/"exit" models
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testmcpdunit_testentryexit(bool *err) {
   ae_frame _frame_block;
   ae_int_t n;
   double threshold;
   ae_int_t entrystate;
   ae_int_t exitstate;
   ae_int_t entrykind;
   ae_int_t exitkind;
   ae_int_t popkind;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   double v;
   ae_frame_make(&_frame_block);
   NewMatrix(p, 0, 0, DT_REAL);
   NewMatrix(pexact, 0, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(mcpdstate, s);
   NewObj(mcpdreport, rep);
   threshold = 1.0E-3;
//
   for (n = 2; n <= 5; n++) {
      for (entrykind = 0; entrykind <= 1; entrykind++) {
         for (exitkind = 0; exitkind <= 1; exitkind++) {
            for (popkind = 0; popkind <= 1; popkind++) {
            // Generate EntryState/ExitState such that one of the following is True:
            // * EntryState != ExitState
            // * EntryState=-1 or ExitState=-1
               do {
                  if (entrykind == 0) {
                     entrystate = -1;
                  } else {
                     entrystate = randominteger(n);
                  }
                  if (exitkind == 0) {
                     exitstate = -1;
                  } else {
                     exitstate = randominteger(n);
                  }
               } while (!((entrystate == -1 || exitstate == -1) || entrystate != exitstate));
            // Generate transition matrix P such that:
            // * columns corresponding to non-exit states sums to 1.0
            // * columns corresponding to exit states sums to 0.0
            // * rows corresponding to entry states are zero
               ae_matrix_set_length(&pexact, n, n);
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     pexact.xyR[i][j] = (double)(1 + randominteger(5));
                     if (i == entrystate) {
                        pexact.xyR[i][j] = 0.0;
                     }
                     if (j == exitstate) {
                        pexact.xyR[i][j] = 0.0;
                     }
                  }
               }
               for (j = 0; j < n; j++) {
                  v = 0.0;
                  for (i = 0; i < n; i++) {
                     v += pexact.xyR[i][j];
                  }
                  if (v != 0.0) {
                     for (i = 0; i < n; i++) {
                        pexact.xyR[i][j] /= v;
                     }
                  }
               }
            // Create MCPD solver
               if (entrystate < 0 && exitstate < 0) {
                  mcpdcreate(n, &s);
               }
               if (entrystate >= 0 && exitstate < 0) {
                  mcpdcreateentry(n, entrystate, &s);
               }
               if (entrystate < 0 && exitstate >= 0) {
                  mcpdcreateexit(n, exitstate, &s);
               }
               if (entrystate >= 0 && exitstate >= 0) {
                  mcpdcreateentryexit(n, entrystate, exitstate, &s);
               }
            // Add N tracks.
            //
            // K-th track starts from vector with large value of
            // K-th component and small random noise in other components.
            //
            // Track contains from 2 to 4 elements.
            //
            // Tracks contain proportional (normalized) or
            // population data, depending on PopKind variable.
               for (k = 0; k < n; k++) {
               // Generate track whose length is in 2..4
                  ae_matrix_set_length(&xy, 2 + randominteger(3), n);
                  for (j = 0; j < n; j++) {
                     xy.xyR[0][j] = 0.05 * randomreal();
                  }
                  xy.xyR[0][k] = 1 + randomreal();
                  for (i = 1; i < xy.rows; i++) {
                     for (j = 0; j < n; j++) {
                        if (j != entrystate) {
                           v = ae_v_dotproduct(pexact.xyR[j], 1, xy.xyR[i - 1], 1, n);
                           xy.xyR[i][j] = v;
                        } else {
                           xy.xyR[i][j] = randomreal();
                        }
                     }
                  }
               // Normalize, if needed
                  if (popkind == 1) {
                     for (i = 0; i < xy.rows; i++) {
                        v = 0.0;
                        for (j = 0; j < n; j++) {
                           v += xy.xyR[i][j];
                        }
                        if (v > 0.0) {
                           for (j = 0; j < n; j++) {
                              xy.xyR[i][j] /= v;
                           }
                        }
                     }
                  }
               // Add track
                  mcpdaddtrack(&s, &xy, xy.rows);
               }
            // Solve and test
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               if (rep.terminationtype > 0) {
                  for (i = 0; i < n; i++) {
                     for (j = 0; j < n; j++) {
                        *err = *err || fabs(p.xyR[i][j] - pexact.xyR[i][j]) > threshold;
                     }
                  }
               } else {
                  *err = true;
               }
            }
         }
      }
   }
   ae_frame_leave();
}

// This function is used to create MCPD object with arbitrary combination of
// entry and exit states
static void testmcpdunit_createee(ae_int_t n, ae_int_t entrystate, ae_int_t exitstate, mcpdstate *s) {
   SetObj(mcpdstate, s);
   if (entrystate < 0 && exitstate < 0) {
      mcpdcreate(n, s);
   }
   if (entrystate >= 0 && exitstate < 0) {
      mcpdcreateentry(n, entrystate, s);
   }
   if (entrystate < 0 && exitstate >= 0) {
      mcpdcreateexit(n, exitstate, s);
   }
   if (entrystate >= 0 && exitstate >= 0) {
      mcpdcreateentryexit(n, entrystate, exitstate, s);
   }
}

// Test equality constraints.
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testmcpdunit_testec(bool *err) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t entrystate;
   ae_int_t exitstate;
   ae_int_t entrykind;
   ae_int_t exitkind;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ic;
   ae_int_t jc;
   double vc;
   ae_frame_make(&_frame_block);
   NewMatrix(p, 0, 0, DT_REAL);
   NewMatrix(ec, 0, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(mcpdstate, s);
   NewObj(mcpdreport, rep);
// We try different problems with following properties:
// * N is large enough - we won't have problems with inconsistent constraints
// * first state is either "entry" or "normal"
// * last state is either "exit" or "normal"
// * we have one long random track
//
// We test several properties which are described in comments below
   for (n = 4; n <= 6; n++) {
      for (entrykind = 0; entrykind <= 1; entrykind++) {
         for (exitkind = 0; exitkind <= 1; exitkind++) {
         // Prepare problem
            if (entrykind == 0) {
               entrystate = -1;
            } else {
               entrystate = 0;
            }
            if (exitkind == 0) {
               exitstate = -1;
            } else {
               exitstate = n - 1;
            }
            ae_matrix_set_length(&xy, 2 * n, n);
            for (i = 0; i < xy.rows; i++) {
               for (j = 0; j < xy.cols; j++) {
                  xy.xyR[i][j] = randomreal();
               }
            }
         // Test that single equality constraint on non-entry
         // non-exit elements of P is satisfied.
         //
         // NOTE: this test needs N >= 4 because smaller values
         // can give us inconsistent constraints
            ae_assert(n >= 4, "TestEC: expectation failed");
            ic = 1 + randominteger(n - 2);
            jc = 1 + randominteger(n - 2);
            vc = randomreal();
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            mcpdaddec(&s, ic, jc, vc);
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            if (rep.terminationtype > 0) {
               *err = *err || p.xyR[ic][jc] != vc;
            } else {
               *err = true;
            }
         // Test interaction with default "sum-to-one" constraint
         // on columns of P.
         //
         // We set N-1 equality constraints on random non-exit column
         // of P, which are inconsistent with this default constraint
         // (sum will be greater that 1.0).
         //
         // Algorithm must detect inconsistency.
         //
         // NOTE:
         // 1. we do not set constraints for the first element of
         //    the column, because this element may be constrained by
         //    "exit state" constraint.
         // 2. this test needs N >= 3
            ae_assert(n >= 3, "TestEC: expectation failed");
            jc = randominteger(n - 1);
            vc = 0.95;
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            for (i = 1; i < n; i++) {
               mcpdaddec(&s, i, jc, vc);
            }
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            *err = *err || rep.terminationtype != -3;
         // Test interaction with constrains on entry states.
         //
         // When model has entry state, corresponding row of P
         // must be zero. We try to set two kinds of constraints
         // on random element of this row:
         // * zero equality constraint, which must be consistent
         // * non-zero equality constraint, which must be inconsistent
            if (entrystate >= 0) {
               jc = randominteger(n);
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddec(&s, entrystate, jc, 0.0);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               *err = *err || rep.terminationtype <= 0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddec(&s, entrystate, jc, 0.5);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               *err = *err || rep.terminationtype != -3;
            }
         // Test interaction with constrains on exit states.
         //
         // When model has exit state, corresponding column of P
         // must be zero. We try to set two kinds of constraints
         // on random element of this column:
         // * zero equality constraint, which must be consistent
         // * non-zero equality constraint, which must be inconsistent
            if (exitstate >= 0) {
               ic = randominteger(n);
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddec(&s, ic, exitstate, 0.0);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               *err = *err || rep.terminationtype <= 0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddec(&s, ic, exitstate, 0.5);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               *err = *err || rep.terminationtype != -3;
            }
         // Test SetEC() call - we constrain subset of non-entry
         // non-exit elements and test it.
            ae_assert(n >= 4, "TestEC: expectation failed");
            ae_matrix_set_length(&ec, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  ec.xyR[i][j] = NAN;
               }
            }
            for (j = 1; j < n - 1; j++) {
               ec.xyR[1 + randominteger(n - 2)][j] = 0.1 + 0.1 * randomreal();
            }
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            mcpdsetec(&s, &ec);
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            if (rep.terminationtype > 0) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     if (isfinite(ec.xyR[i][j])) {
                        *err = *err || p.xyR[i][j] != ec.xyR[i][j];
                     }
                  }
               }
            } else {
               *err = true;
            }
         }
      }
   }
   ae_frame_leave();
}

// Test bound constraints.
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testmcpdunit_testbc(bool *err) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t entrystate;
   ae_int_t exitstate;
   ae_int_t entrykind;
   ae_int_t exitkind;
   ae_int_t i;
   ae_int_t j;
   ae_int_t ic;
   ae_int_t jc;
   double vl;
   double vu;
   ae_frame_make(&_frame_block);
   NewMatrix(p, 0, 0, DT_REAL);
   NewMatrix(bndl, 0, 0, DT_REAL);
   NewMatrix(bndu, 0, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(mcpdstate, s);
   NewObj(mcpdreport, rep);
// We try different problems with following properties:
// * N is large enough - we won't have problems with inconsistent constraints
// * first state is either "entry" or "normal"
// * last state is either "exit" or "normal"
// * we have one long random track
//
// We test several properties which are described in comments below
   for (n = 4; n <= 6; n++) {
      for (entrykind = 0; entrykind <= 1; entrykind++) {
         for (exitkind = 0; exitkind <= 1; exitkind++) {
         // Prepare problem
            if (entrykind == 0) {
               entrystate = -1;
            } else {
               entrystate = 0;
            }
            if (exitkind == 0) {
               exitstate = -1;
            } else {
               exitstate = n - 1;
            }
            ae_matrix_set_length(&xy, 2 * n, n);
            for (i = 0; i < xy.rows; i++) {
               for (j = 0; j < xy.cols; j++) {
                  xy.xyR[i][j] = randomreal();
               }
            }
         // Test that single bound constraint on non-entry
         // non-exit elements of P is satisfied.
         //
         // NOTE 1: this test needs N >= 4 because smaller values
         // can give us inconsistent constraints
            ae_assert(n >= 4, "TestBC: expectation failed");
            ic = 1 + randominteger(n - 2);
            jc = 1 + randominteger(n - 2);
            if (randombool()) {
               vl = 0.3 * randomreal();
            } else {
               vl = -INFINITY;
            }
            if (randombool()) {
               vu = 0.5 + 0.3 * randomreal();
            } else {
               vu = +INFINITY;
            }
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            mcpdaddbc(&s, ic, jc, vl, vu);
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            if (rep.terminationtype > 0) {
               *err = *err || p.xyR[ic][jc] < vl;
               *err = *err || p.xyR[ic][jc] > vu;
            } else {
               *err = true;
            }
         // Test interaction with default "sum-to-one" constraint
         // on columns of P.
         //
         // We set N-1 bound constraints on random non-exit column
         // of P, which are inconsistent with this default constraint
         // (sum will be greater that 1.0).
         //
         // Algorithm must detect inconsistency.
         //
         // NOTE:
         // 1. we do not set constraints for the first element of
         //    the column, because this element may be constrained by
         //    "exit state" constraint.
         // 2. this test needs N >= 3
            ae_assert(n >= 3, "TestEC: expectation failed");
            jc = randominteger(n - 1);
            vl = 0.85;
            vu = 0.95;
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            for (i = 1; i < n; i++) {
               mcpdaddbc(&s, i, jc, vl, vu);
            }
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            *err = *err || rep.terminationtype != -3;
         // Test interaction with constrains on entry states.
         //
         // When model has entry state, corresponding row of P
         // must be zero. We try to set two kinds of constraints
         // on random element of this row:
         // * bound constraint with zero lower bound, which must be consistent
         // * bound constraint with non-zero lower bound, which must be inconsistent
            if (entrystate >= 0) {
               jc = randominteger(n);
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddbc(&s, entrystate, jc, 0.0, 1.0);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               *err = *err || rep.terminationtype <= 0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddbc(&s, entrystate, jc, 0.5, 1.0);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               *err = *err || rep.terminationtype != -3;
            }
         // Test interaction with constrains on exit states.
         //
         // When model has exit state, corresponding column of P
         // must be zero. We try to set two kinds of constraints
         // on random element of this column:
         // * bound constraint with zero lower bound, which must be consistent
         // * bound constraint with non-zero lower bound, which must be inconsistent
            if (exitstate >= 0) {
               ic = randominteger(n);
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddbc(&s, ic, exitstate, 0.0, 1.0);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               *err = *err || rep.terminationtype <= 0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdaddbc(&s, ic, exitstate, 0.5, 1.0);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               *err = *err || rep.terminationtype != -3;
            }
         // Test SetBC() call - we constrain subset of non-entry
         // non-exit elements and test it.
            ae_assert(n >= 4, "TestBC: expectation failed");
            ae_matrix_set_length(&bndl, n, n);
            ae_matrix_set_length(&bndu, n, n);
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  bndl.xyR[i][j] = -INFINITY;
                  bndu.xyR[i][j] = +INFINITY;
               }
            }
            for (j = 1; j < n - 1; j++) {
               i = 1 + randominteger(n - 2);
               bndl.xyR[i][j] = 0.5 - 0.1 * randomreal();
               bndu.xyR[i][j] = 0.5 + 0.1 * randomreal();
            }
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            mcpdsetbc(&s, &bndl, &bndu);
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            if (rep.terminationtype > 0) {
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     *err = *err || p.xyR[i][j] < bndl.xyR[i][j];
                     *err = *err || p.xyR[i][j] > bndu.xyR[i][j];
                  }
               }
            } else {
               *err = true;
            }
         }
      }
   }
   ae_frame_leave();
}

// Test bound constraints.
//
// On failure sets Err to True (leaves it unchanged otherwise)
static void testmcpdunit_testlc(bool *err) {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t entrystate;
   ae_int_t exitstate;
   ae_int_t entrykind;
   ae_int_t exitkind;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   ae_int_t t;
   ae_int_t jc;
   double v;
   double threshold;
   ae_frame_make(&_frame_block);
   NewMatrix(p, 0, 0, DT_REAL);
   NewMatrix(c, 0, 0, DT_REAL);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(ct, 0, DT_INT);
   NewObj(mcpdstate, s);
   NewObj(mcpdreport, rep);
   threshold = 1.0E5 * machineepsilon;
// We try different problems with following properties:
// * N is large enough - we won't have problems with inconsistent constraints
// * first state is either "entry" or "normal"
// * last state is either "exit" or "normal"
// * we have one long random track
//
// We test several properties which are described in comments below
   for (n = 4; n <= 6; n++) {
      for (entrykind = 0; entrykind <= 1; entrykind++) {
         for (exitkind = 0; exitkind <= 1; exitkind++) {
         // Prepare problem
            if (entrykind == 0) {
               entrystate = -1;
            } else {
               entrystate = 0;
            }
            if (exitkind == 0) {
               exitstate = -1;
            } else {
               exitstate = n - 1;
            }
            ae_matrix_set_length(&xy, 2 * n, n);
            for (i = 0; i < xy.rows; i++) {
               for (j = 0; j < xy.cols; j++) {
                  xy.xyR[i][j] = randomreal();
               }
            }
         // Test that single linear equality/inequality constraint
         // on non-entry non-exit elements of P is satisfied.
         //
         // NOTE 1: this test needs N >= 4 because smaller values
         //         can give us inconsistent constraints
         // NOTE 2: Constraints are generated is such a way that P=(1/N ... 1/N)
         //         is always feasible. It guarantees that there always exists
         //         at least one feasible point
         // NOTE 3: If we have inequality constraint, we "shift" right part
         //         in order to make feasible some neighborhood of P=(1/N ... 1/N).
            ae_assert(n >= 4, "TestLC: expectation failed");
            ae_matrix_set_length(&c, 1, n * n + 1);
            ae_vector_set_length(&ct, 1);
            v = 0.0;
            for (i = 0; i < n; i++) {
               for (j = 0; j < n; j++) {
                  if (((i == 0 || i == n - 1) || j == 0) || j == n - 1) {
                     c.xyR[0][i * n + j] = 0.0;
                  } else {
                     c.xyR[0][i * n + j] = randomreal();
                     v += c.xyR[0][i * n + j] * (1.0 / n);
                  }
               }
            }
            c.xyR[0][n * n] = v;
            ct.xZ[0] = randominteger(3) - 1;
            if (ct.xZ[0] < 0) {
               c.xyR[0][n * n] += 0.1;
            }
            if (ct.xZ[0] > 0) {
               c.xyR[0][n * n] -= 0.1;
            }
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            mcpdsetlc(&s, &c, &ct, 1);
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            if (rep.terminationtype > 0) {
               v = 0.0;
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     v += p.xyR[i][j] * c.xyR[0][i * n + j];
                  }
               }
               if (ct.xZ[0] < 0) {
                  *err = *err || v >= c.xyR[0][n * n] + threshold;
               }
               if (ct.xZ[0] == 0) {
                  *err = *err || fabs(v - c.xyR[0][n * n]) >= threshold;
               }
               if (ct.xZ[0] > 0) {
                  *err = *err || v <= c.xyR[0][n * n] - threshold;
               }
            } else {
               *err = true;
            }
         // Test interaction with default "sum-to-one" constraint
         // on columns of P.
         //
         // We set linear constraint which has for "sum-to-X" on
         // on random non-exit column of P. This constraint can be
         // either consistent (X=1.0) or inconsistent (X != 1.0) with
         // this default constraint.
         //
         // Algorithm must detect inconsistency.
         //
         // NOTE:
         // 1. this test needs N >= 2
            ae_assert(n >= 2, "TestLC: expectation failed");
            jc = randominteger(n - 1);
            ae_matrix_set_length(&c, 1, n * n + 1);
            ae_vector_set_length(&ct, 1);
            for (i = 0; i < n * n; i++) {
               c.xyR[0][i] = 0.0;
            }
            for (i = 0; i < n; i++) {
               c.xyR[0][n * i + jc] = 1.0;
            }
            c.xyR[0][n * n] = 1.0;
            ct.xZ[0] = 0;
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            mcpdsetlc(&s, &c, &ct, 1);
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            *err = *err || rep.terminationtype <= 0;
            c.xyR[0][n * n] = 2.0;
            testmcpdunit_createee(n, entrystate, exitstate, &s);
            mcpdaddtrack(&s, &xy, xy.rows);
            mcpdsetlc(&s, &c, &ct, 1);
            mcpdsolve(&s);
            mcpdresults(&s, &p, &rep);
            *err = *err || rep.terminationtype != -3;
         // Test interaction with constrains on entry states.
         //
         // When model has entry state, corresponding row of P
         // must be zero. We try to set two kinds of constraints
         // on elements of this row:
         // * sums-to-zero constraint, which must be consistent
         // * sums-to-one constraint, which must be inconsistent
            if (entrystate >= 0) {
               ae_matrix_set_length(&c, 1, n * n + 1);
               ae_vector_set_length(&ct, 1);
               for (i = 0; i < n * n; i++) {
                  c.xyR[0][i] = 0.0;
               }
               for (j = 0; j < n; j++) {
                  c.xyR[0][n * entrystate + j] = 1.0;
               }
               ct.xZ[0] = 0;
               c.xyR[0][n * n] = 0.0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdsetlc(&s, &c, &ct, 1);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               *err = *err || rep.terminationtype <= 0;
               c.xyR[0][n * n] = 1.0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdsetlc(&s, &c, &ct, 1);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               *err = *err || rep.terminationtype != -3;
            }
         // Test interaction with constrains on exit states.
         //
         // When model has exit state, corresponding column of P
         // must be zero. We try to set two kinds of constraints
         // on elements of this column:
         // * sums-to-zero constraint, which must be consistent
         // * sums-to-one constraint, which must be inconsistent
            if (exitstate >= 0) {
               ae_matrix_set_length(&c, 1, n * n + 1);
               ae_vector_set_length(&ct, 1);
               for (i = 0; i < n * n; i++) {
                  c.xyR[0][i] = 0.0;
               }
               for (i = 0; i < n; i++) {
                  c.xyR[0][n * i + exitstate] = 1.0;
               }
               ct.xZ[0] = 0;
               c.xyR[0][n * n] = 0.0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdsetlc(&s, &c, &ct, 1);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               *err = *err || rep.terminationtype <= 0;
               c.xyR[0][n * n] = 1.0;
               testmcpdunit_createee(n, entrystate, exitstate, &s);
               mcpdaddtrack(&s, &xy, xy.rows);
               mcpdsetlc(&s, &c, &ct, 1);
               mcpdsolve(&s);
               mcpdresults(&s, &p, &rep);
               *err = *err || rep.terminationtype != -3;
            }
         }
      }
   }
// Final test - we generate several random constraints and
// test SetLC() function.
//
// NOTES:
//
// 1. Constraints are generated is such a way that P=(1/N ... 1/N)
//    is always feasible. It guarantees that there always exists
//    at least one feasible point
// 2. For simplicity of the test we do not use entry/exit states
//    in our model
   for (n = 1; n <= 4; n++) {
      for (k = 1; k <= 2 * n; k++) {
      // Generate track
         ae_matrix_set_length(&xy, 2 * n, n);
         for (i = 0; i < xy.rows; i++) {
            for (j = 0; j < xy.cols; j++) {
               xy.xyR[i][j] = randomreal();
            }
         }
      // Generate random constraints
         ae_matrix_set_length(&c, k, n * n + 1);
         ae_vector_set_length(&ct, k);
         for (i = 0; i < k; i++) {
         // Generate constraint and its right part
            c.xyR[i][n * n] = 0.0;
            for (j = 0; j < n * n; j++) {
               c.xyR[i][j] = randommid();
               c.xyR[i][n * n] += c.xyR[i][j] * (1.0 / n);
            }
            ct.xZ[i] = randominteger(3) - 1;
         // If we have inequality constraint, we "shift" right part
         // in order to make feasible some neighborhood of P=(1/N ... 1/N).
            if (ct.xZ[i] < 0) {
               c.xyR[i][n * n] += 0.1;
            }
            if (ct.xZ[i] > 0) {
               c.xyR[i][n * n] -= 0.1;
            }
         }
      // Test
         testmcpdunit_createee(n, -1, -1, &s);
         mcpdaddtrack(&s, &xy, xy.rows);
         mcpdsetlc(&s, &c, &ct, k);
         mcpdsolve(&s);
         mcpdresults(&s, &p, &rep);
         if (rep.terminationtype > 0) {
            for (t = 0; t < k; t++) {
               v = 0.0;
               for (i = 0; i < n; i++) {
                  for (j = 0; j < n; j++) {
                     v += p.xyR[i][j] * c.xyR[t][i * n + j];
                  }
               }
               if (ct.xZ[t] < 0) {
                  *err = *err || v >= c.xyR[t][n * n] + threshold;
               }
               if (ct.xZ[t] == 0) {
                  *err = *err || fabs(v - c.xyR[t][n * n]) >= threshold;
               }
               if (ct.xZ[t] > 0) {
                  *err = *err || v <= c.xyR[t][n * n] - threshold;
               }
            }
         } else {
            *err = true;
         }
      }
   }
   ae_frame_leave();
}

bool testmcpd(bool silent) {
   bool waserrors;
   bool simpleerrors;
   bool entryexiterrors;
   bool ecerrors;
   bool bcerrors;
   bool lcerrors;
   bool othererrors;
   bool result;
// Init
   waserrors = false;
   othererrors = false;
   simpleerrors = false;
   entryexiterrors = false;
   ecerrors = false;
   bcerrors = false;
   lcerrors = false;
// Test
   testmcpdunit_testsimple(&simpleerrors);
   testmcpdunit_testentryexit(&entryexiterrors);
   testmcpdunit_testec(&ecerrors);
   testmcpdunit_testbc(&bcerrors);
   testmcpdunit_testlc(&lcerrors);
// Final report
   waserrors = ((((othererrors || simpleerrors) || entryexiterrors) || ecerrors) || bcerrors) || lcerrors;
   if (!silent) {
      printf("MCPD TEST\n");
      printf("TOTAL RESULTS:                           ");
      if (!waserrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* SIMPLE:                                ");
      if (!simpleerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* ENTRY/EXIT:                            ");
      if (!entryexiterrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* EQUALITY CONSTRAINTS:                  ");
      if (!ecerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* BOUND CONSTRAINTS:                     ");
      if (!bcerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* LINEAR CONSTRAINTS:                    ");
      if (!lcerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* OTHER PROPERTIES:                      ");
      if (!othererrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST SUMMARY: FAILED\n");
      } else {
         printf("TEST SUMMARY: PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === knn testing unit ===
// Unsets model
static void testknnunit_unsetknn(knnmodel *model) {
   ae_frame _frame_block;
   ae_frame_make(&_frame_block);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(knnbuilder, builder);
   NewObj(knnreport, rep);
   ae_matrix_set_length(&xy, 1, 2);
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = randomreal() - 0.5;
   knnbuildercreate(&builder);
   knnbuildersetdatasetreg(&builder, &xy, 1, 1, 1);
   knnbuilderbuildknnmodel(&builder, 1, 0.0, model, &rep);
   model->nvars = -1;
   model->nout = -1;
   model->k = -1;
   model->eps = 0.0;
   model->isdummy = true;
   ae_frame_leave();
}

// Test set errors.
//
// Computes test set errors:
// * average cross-entropy
// * relative classification error (a range [RelCls0,RelCls1] is returned
//   because classification error can be computed differently in the presence
//   of the ties). All possible values of the classification error, no matter
//   how ties are resolved, are guaranteed to be within [RelCls0,RelCls1].
static void testknnunit_testseterrors(knnmodel *model, ae_int_t nvars, ae_int_t nout, bool iscls, RMatrix *xy, ae_int_t npoints, double *avgce, double *relcls0, double *relcls1, double *rms, double *avg, double *avgrel) {
   ae_frame _frame_block;
   ae_int_t relcnt;
   ae_int_t i;
   ae_int_t j;
   double v;
   double mxy;
   ae_frame_make(&_frame_block);
   *avgce = 0;
   *relcls0 = 0;
   *relcls1 = 0;
   *rms = 0;
   *avg = 0;
   *avgrel = 0;
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(ey, 0, DT_REAL);
   ae_vector_set_length(&x, nvars);
   ae_vector_set_length(&y, nout);
   ae_vector_set_length(&ey, nout);
   *avgce = 0.0;
   *relcls0 = 0.0;
   *relcls1 = 0.0;
   *rms = 0.0;
   *avg = 0.0;
   *avgrel = 0.0;
   relcnt = 0;
   for (i = 0; i < npoints; i++) {
      for (j = 0; j < nvars; j++) {
         x.xR[j] = xy->xyR[i][j];
      }
      knnprocess(model, &x, &y);
      if (iscls) {
         for (j = 0; j < nout; j++) {
            ey.xR[j] = 0.0;
         }
         ey.xR[iround(xy->xyR[i][nvars])] = 1.0;
      } else {
         for (j = 0; j < nout; j++) {
            ey.xR[j] = xy->xyR[i][nvars + j];
         }
      }
      for (j = 0; j < nout; j++) {
         v = y.xR[j] - ey.xR[j];
         if (iscls) {
            *avgce -= ey.xR[j] * log(y.xR[j] + minrealnumber);
         }
         *rms += sqr(v);
         *avg += fabs(v);
         if (ey.xR[j] != 0.0) {
            *avgrel += fabs(v / ey.xR[j]);
            relcnt++;
         }
      }
      if (iscls) {
         mxy = 0.0;
         for (j = 0; j < nout; j++) {
            mxy = rmax2(mxy, y.xR[j]);
         }
         if (y.xR[iround(xy->xyR[i][nvars])] == mxy) {
         // RelCls0 is NOT increased because correct value achieves maximum.
         // However, if ties are present, we have to increase RelCls1, upper bound
         // of the uncertainty interval for the classification error.
            for (j = 0; j < nout; j++) {
               if (j != iround(xy->xyR[i][nvars]) && y.xR[j] == mxy) {
                  ++*relcls1;
                  break;
               }
            }
         } else {
         // Both bounds of the error range are increased by 1
            ++*relcls0;
            ++*relcls1;
         }
      }
   }
   *relcls0 /= npoints;
   *relcls1 /= npoints;
   *avgce /= npoints;
   *rms = sqrt(*rms / (npoints * nout));
   *avg /= npoints * nout;
   *avgrel /= coalesce((double)relcnt, 1.0);
   ae_frame_leave();
}

// Processing functions test
static void testknnunit_testknnalgo(bool *err) {
   ae_frame _frame_block;
   ae_int_t nvars;
   ae_int_t nout;
   bool iscls;
   ae_int_t ny;
   ae_int_t k;
   double eps;
   ae_int_t npoints;
   ae_int_t testnpoints;
   ae_int_t pass;
   ae_int_t i;
   ae_int_t j;
   bool allsame;
   double v;
   double refavgce;
   double refcls0;
   double refcls1;
   double refrms;
   double refavg;
   double refavgrel;
   double maxerr;
   double avgerr;
   ae_int_t cnt;
   ae_frame_make(&_frame_block);
   NewObj(knnmodel, model1);
   NewObj(knnmodel, model2);
   NewObj(knnmodel, modelus);
   NewObj(knnbuilder, builder);
   NewObj(knnreport, rep);
   NewObj(knnreport, rep2);
   NewObj(knnreport, tstrep);
   NewObj(knnbuffer, buf);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(testxy, 0, 0, DT_REAL);
   NewVector(x1, 0, DT_REAL);
   NewVector(x2, 0, DT_REAL);
   NewVector(y1, 0, DT_REAL);
   NewVector(y2, 0, DT_REAL);
   NewVector(y3, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   hqrndrandomize(&rs);
// Test on randomly generated sets with randomly generated algo settings
//
// We test:
// * process
// * processi
// * process0
// * classify
// * serialization/unserialization
// * reports and test set error evaluation
// * knnrewritekeps()
   for (pass = 1; pass <= 100; pass++) {
   // initialize parameters
      nvars = 1 + hqrnduniformi(&rs, 5);
      if (hqrndnormal(&rs) > 0.0) {
         iscls = true;
         nout = 2 + hqrnduniformi(&rs, 3);
         ny = 1;
      } else {
         iscls = false;
         nout = 1 + hqrnduniformi(&rs, 3);
         ny = nout;
      }
      k = 1 + hqrnduniformi(&rs, 3);
      eps = hqrnduniformi(&rs, 2) * 0.1 * hqrnduniformr(&rs);
   // Initialize arrays and data: training and test sets
      npoints = 10 + hqrnduniformi(&rs, 100);
      ae_matrix_set_length(&xy, npoints, nvars + ny);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            if (j % 2 == 0) {
               xy.xyR[i][j] = hqrndnormal(&rs);
            } else {
               xy.xyR[i][j] = (double)hqrnduniformi(&rs, 2);
            }
         }
         if (iscls) {
            xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nout);
         } else {
            for (j = 0; j < nout; j++) {
               xy.xyR[i][nvars + j] = hqrndnormal(&rs);
            }
         }
      }
      testnpoints = 10 + hqrnduniformi(&rs, 100);
      ae_matrix_set_length(&testxy, testnpoints, nvars + ny);
      for (i = 0; i < testnpoints; i++) {
         for (j = 0; j < nvars; j++) {
            if (j % 2 == 0) {
               testxy.xyR[i][j] = hqrndnormal(&rs);
            } else {
               testxy.xyR[i][j] = (double)hqrnduniformi(&rs, 2);
            }
         }
         if (iscls) {
            testxy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nout);
         } else {
            for (j = 0; j < nout; j++) {
               testxy.xyR[i][nvars + j] = hqrndnormal(&rs);
            }
         }
      }
   // create model
      testknnunit_unsetknn(&model1);
      knnbuildercreate(&builder);
      if (iscls) {
         knnbuildersetdatasetcls(&builder, &xy, npoints, nvars, nout);
      } else {
         knnbuildersetdatasetreg(&builder, &xy, npoints, nvars, nout);
      }
      knnbuildersetnorm(&builder, hqrnduniformi(&rs, 3));
      knnbuilderbuildknnmodel(&builder, k, eps, &model1, &rep);
      knncreatebuffer(&model1, &buf);
   // Check that:
   // * knnprocess()   does not shrink output array, only increases
   // * knntsprocess() does not shrink output array, only increases
   // * knnprocessi() fits length exactly to NOut
      ae_vector_set_length(&x1, nvars);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
      }
      ae_vector_set_length(&y1, nout + 1);
      knnprocess(&model1, &x1, &y1);
      set_error_flag(err, y1.cnt != nout + 1, __FILE__, __LINE__, "testknnunit.ap:200");
      ae_vector_set_length(&y1, nout - 1);
      knnprocess(&model1, &x1, &y1);
      set_error_flag(err, y1.cnt != nout, __FILE__, __LINE__, "testknnunit.ap:203");
      ae_vector_set_length(&y1, nout + 1);
      knntsprocess(&model1, &buf, &x1, &y1);
      set_error_flag(err, y1.cnt != nout + 1, __FILE__, __LINE__, "testknnunit.ap:207");
      ae_vector_set_length(&y1, nout - 1);
      knntsprocess(&model1, &buf, &x1, &y1);
      set_error_flag(err, y1.cnt != nout, __FILE__, __LINE__, "testknnunit.ap:210");
      ae_vector_set_length(&y1, nout + 1);
      knnprocessi(&model1, &x1, &y1);
      set_error_flag(err, y1.cnt != nout, __FILE__, __LINE__, "testknnunit.ap:214");
      ae_vector_set_length(&y1, nout - 1);
      knnprocessi(&model1, &x1, &y1);
      set_error_flag(err, y1.cnt != nout, __FILE__, __LINE__, "testknnunit.ap:217");
      if (*err) {
         ae_frame_leave();
         return;
      }
   // knnprocess(), knnprocessi() and knntsprocess() return same results
      ae_vector_set_length(&x1, nvars);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
      }
      knnprocess(&model1, &x1, &y1);
      knnprocessi(&model1, &x1, &y2);
      knntsprocess(&model1, &buf, &x1, &y3);
      for (i = 0; i < nout; i++) {
         set_error_flag(err, fabs(y2.xR[i] - y1.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testknnunit.ap:232");
         set_error_flag(err, fabs(y3.xR[i] - y1.xR[i]) > 100 * machineepsilon, __FILE__, __LINE__, "testknnunit.ap:233");
      }
   // Same inputs leads to same outputs
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      ae_vector_set_length(&y1, nout);
      ae_vector_set_length(&y2, nout);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nout; i++) {
         y1.xR[i] = hqrndnormal(&rs);
         y2.xR[i] = hqrndnormal(&rs);
      }
      knnprocess(&model1, &x1, &y1);
      knnprocess(&model1, &x2, &y2);
      allsame = true;
      for (i = 0; i < nout; i++) {
         allsame = allsame && y1.xR[i] == y2.xR[i];
      }
      set_error_flag(err, !allsame, __FILE__, __LINE__, "testknnunit.ap:259");
   // Same inputs on original forest leads to same outputs
   // on copy created using KNNSerialize
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      ae_vector_set_length(&y1, nout);
      ae_vector_set_length(&y2, nout);
      testknnunit_unsetknn(&modelus);
      {
      // This code passes data structure through serializers
      // (serializes it to string and loads back)
         ae_int_t _local_ssize;
         ae_frame _local_frame_block;
         ae_frame_make(&_local_frame_block);
         NewSerializer(_local_serializer);
         ae_serializer_alloc_start(&_local_serializer);
         knnalloc(&_local_serializer, &model1);
         _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
         NewBlock(_local_dynamic_block, _local_ssize + 1);
         ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
         knnserialize(&_local_serializer, &model1);
         ae_serializer_stop(&_local_serializer);
         ae_serializer_init(&_local_serializer);
         ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
         knnunserialize(&_local_serializer, &modelus);
         ae_serializer_stop(&_local_serializer);
         ae_frame_leave();
      }
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nout; i++) {
         y1.xR[i] = hqrndnormal(&rs);
         y2.xR[i] = hqrndnormal(&rs);
      }
      knnprocess(&model1, &x1, &y1);
      knnprocess(&modelus, &x2, &y2);
      allsame = true;
      for (i = 0; i < nout; i++) {
         allsame = allsame && y1.xR[i] == y2.xR[i];
      }
      set_error_flag(err, !allsame, __FILE__, __LINE__, "testknnunit.ap:287");
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      set_error_flag(err, fabs(knnprocess0(&model1, &x1) - knnprocess0(&modelus, &x2)) > 100 * machineepsilon, __FILE__, __LINE__, "testknnunit.ap:293");
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      set_error_flag(err, knnclassify(&model1, &x1) != knnclassify(&modelus, &x2), __FILE__, __LINE__, "testknnunit.ap:299");
   // KNNProcess0 works as expected
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      ae_vector_set_length(&y1, nout);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      for (i = 0; i < nout; i++) {
         y1.xR[i] = hqrndnormal(&rs);
      }
      knnprocess(&model1, &x1, &y1);
      set_error_flag(err, fabs(y1.xR[0] - knnprocess0(&model1, &x2)) > 100 * machineepsilon, __FILE__, __LINE__, "testknnunit.ap:318");
   // KNNClassify works as expected
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      ae_vector_set_length(&y1, nout);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      if (iscls) {
         for (i = 0; i < nout; i++) {
            y1.xR[i] = hqrndnormal(&rs);
         }
         knnprocess(&model1, &x1, &y1);
         j = knnclassify(&model1, &x2);
         for (i = 0; i < nout; i++) {
            set_error_flag(err, y1.xR[i] > y1.xR[j], __FILE__, __LINE__, "testknnunit.ap:341");
         }
      } else {
         set_error_flag(err, knnclassify(&model1, &x2) != -1, __FILE__, __LINE__, "testknnunit.ap:344");
      }
   // Normalization properties
      if (iscls) {
         for (i = 0; i < nvars; i++) {
            x1.xR[i] = hqrndnormal(&rs);
         }
         ae_vector_set_length(&y1, 0);
         knnprocess(&model1, &x1, &y1);
         v = 0.0;
         for (i = 0; i < nout; i++) {
            v += y1.xR[i];
            set_error_flag(err, y1.xR[i] < 0.0, __FILE__, __LINE__, "testknnunit.ap:359");
         }
         set_error_flag(err, fabs(v - 1) > 1000 * machineepsilon, __FILE__, __LINE__, "testknnunit.ap:361");
      }
   // Test various error metrics reported by algorithm:
   // * training set errors included in the report
   // * errors on the test set
   //
   // NOTE: cross-entropy metric is tested only for training set.
   //       because model can produce exactly zero probabilities
   //       for completely unknown values
      testknnunit_testseterrors(&model1, nvars, nout, iscls, &xy, npoints, &refavgce, &refcls0, &refcls1, &refrms, &refavg, &refavgrel);
      if (iscls) {
         set_error_flag(err, fabs(rep.avgce - refavgce) > 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:377");
         set_error_flag(err, fabs(knnavgce(&model1, &xy, npoints) - refavgce) > 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:378");
         set_error_flag(err, rep.relclserror < refcls0 - 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:381");
         set_error_flag(err, rep.relclserror > refcls1 + 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:382");
         set_error_flag(err, knnrelclserror(&model1, &xy, npoints) < refcls0 - 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:383");
         set_error_flag(err, knnrelclserror(&model1, &xy, npoints) > refcls1 + 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:384");
      } else {
         set_error_flag(err, rep.avgce != 0.0, __FILE__, __LINE__, "testknnunit.ap:389");
         set_error_flag(err, knnavgce(&model1, &xy, npoints) != 0.0, __FILE__, __LINE__, "testknnunit.ap:390");
         set_error_flag(err, rep.relclserror != 0.0, __FILE__, __LINE__, "testknnunit.ap:393");
         set_error_flag(err, knnrelclserror(&model1, &xy, npoints) != 0.0, __FILE__, __LINE__, "testknnunit.ap:394");
      }
      set_error_flag(err, fabs(rep.rmserror - refrms) > 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:396");
      set_error_flag(err, fabs(rep.avgerror - refavg) > 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:397");
      set_error_flag(err, fabs(rep.avgrelerror - refavgrel) > 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:398");
      set_error_flag(err, fabs(knnrmserror(&model1, &xy, npoints) - refrms) > 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:399");
      set_error_flag(err, fabs(knnavgerror(&model1, &xy, npoints) - refavg) > 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:400");
      set_error_flag(err, fabs(knnavgrelerror(&model1, &xy, npoints) - refavgrel) > 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:401");
      testknnunit_testseterrors(&model1, nvars, nout, iscls, &testxy, testnpoints, &refavgce, &refcls0, &refcls1, &refrms, &refavg, &refavgrel);
      knnallerrors(&model1, &testxy, testnpoints, &tstrep);
      if (iscls) {
         set_error_flag(err, tstrep.relclserror < refcls0 - 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:406");
         set_error_flag(err, tstrep.relclserror > refcls1 + 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:407");
      } else {
         set_error_flag(err, tstrep.avgce != 0.0, __FILE__, __LINE__, "testknnunit.ap:411");
         set_error_flag(err, tstrep.relclserror != 0.0, __FILE__, __LINE__, "testknnunit.ap:412");
      }
      set_error_flag(err, fabs(tstrep.rmserror - refrms) > 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:414");
      set_error_flag(err, fabs(tstrep.avgerror - refavg) > 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:415");
      set_error_flag(err, fabs(tstrep.avgrelerror - refavgrel) > 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:416");
   }
// Test that model built with K=1 and Eps=0 remembers all training cases
   for (nvars = 1; nvars <= 4; nvars++) {
      for (pass = 0; pass <= 10; pass++) {
      // Prepare task
         npoints = 1 + hqrnduniformi(&rs, 20);
         if (hqrndnormal(&rs) > 0.0) {
            iscls = true;
            nout = 2 + hqrnduniformi(&rs, 3);
            ny = 1;
         } else {
            iscls = false;
            nout = 1 + hqrnduniformi(&rs, 3);
            ny = nout;
         }
         ae_matrix_set_length(&xy, npoints, nvars + ny);
         for (i = 0; i < npoints; i++) {
            xy.xyR[i][0] = i * 0.000001;
            for (j = 1; j < nvars; j++) {
               xy.xyR[i][j] = hqrndnormal(&rs);
            }
            if (iscls) {
               xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nout);
            } else {
               for (j = 0; j < nout; j++) {
                  xy.xyR[i][nvars + j] = hqrndnormal(&rs);
               }
            }
         }
      // Create model
         testknnunit_unsetknn(&model1);
         knnbuildercreate(&builder);
         if (iscls) {
            knnbuildersetdatasetcls(&builder, &xy, npoints, nvars, nout);
         } else {
            knnbuildersetdatasetreg(&builder, &xy, npoints, nvars, nout);
         }
         knnbuildersetnorm(&builder, hqrnduniformi(&rs, 3));
         knnbuilderbuildknnmodel(&builder, 1, 0.0, &model1, &rep);
         set_error_flag(err, rep.avgce > 0.0, __FILE__, __LINE__, "testknnunit.ap:467");
         set_error_flag(err, rep.relclserror > 0.0, __FILE__, __LINE__, "testknnunit.ap:468");
         set_error_flag(err, rep.rmserror > 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:469");
         set_error_flag(err, rep.avgerror > 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:470");
         set_error_flag(err, rep.avgrelerror > 1.0E-6, __FILE__, __LINE__, "testknnunit.ap:471");
         ae_vector_set_length(&x1, nvars);
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nvars; j++) {
               x1.xR[j] = xy.xyR[i][j];
            }
            knnprocess(&model1, &x1, &y1);
            if (iscls) {
               set_error_flag(err, fabs(y1.xR[iround(xy.xyR[i][nvars])] - 1) > 10 * machineepsilon, __FILE__, __LINE__, "testknnunit.ap:479");
            } else {
               for (j = 0; j < nout; j++) {
                  set_error_flag(err, fabs(y1.xR[j] - xy.xyR[i][nvars + j]) > 10 * machineepsilon, __FILE__, __LINE__, "testknnunit.ap:483");
               }
            }
         }
      }
   }
// Test that model rewrite works as expected
   for (nvars = 1; nvars <= 20; nvars++) {
   // Prepare task
      npoints = 50 + 5 * nvars;
      if (hqrndnormal(&rs) > 0.0) {
         iscls = true;
         nout = 2 + hqrnduniformi(&rs, 3);
         ny = 1;
      } else {
         iscls = false;
         nout = 1 + hqrnduniformi(&rs, 3);
         ny = nout;
      }
      ae_matrix_set_length(&xy, npoints, nvars + ny);
      for (i = 0; i < npoints; i++) {
         for (j = 0; j < nvars; j++) {
            xy.xyR[i][j] = hqrndnormal(&rs);
         }
         if (iscls) {
            xy.xyR[i][nvars] = (double)hqrnduniformi(&rs, nout);
         } else {
            for (j = 0; j < nout; j++) {
               xy.xyR[i][nvars + j] = hqrndnormal(&rs);
            }
         }
      }
   // Select K, Eps
      k = 1 + hqrnduniformi(&rs, 10);
      eps = hqrnduniformi(&rs, 2) * (1 + 3 * hqrnduniformr(&rs));
   // Create model 1 using K, EPS.
   // Create model 2 using other (K,Eps), then rewrite search settings
      knnbuildercreate(&builder);
      if (iscls) {
         knnbuildersetdatasetcls(&builder, &xy, npoints, nvars, nout);
      } else {
         knnbuildersetdatasetreg(&builder, &xy, npoints, nvars, nout);
      }
      testknnunit_unsetknn(&model1);
      knnbuilderbuildknnmodel(&builder, k, eps, &model1, &rep);
      testknnunit_unsetknn(&model2);
      knnbuilderbuildknnmodel(&builder, 1 + hqrnduniformi(&rs, 10), hqrnduniformi(&rs, 2) * (1 + 3 * hqrnduniformr(&rs)), &model2, &rep2);
      knnrewritekeps(&model2, k, eps);
      ae_vector_set_length(&x1, nvars);
      ae_vector_set_length(&x2, nvars);
      for (i = 0; i < nvars; i++) {
         x1.xR[i] = hqrndnormal(&rs);
         x2.xR[i] = x1.xR[i];
      }
      knnprocess(&model1, &x1, &y1);
      knnprocess(&model2, &x2, &y2);
      for (i = 0; i < nout; i++) {
         set_error_flag(err, fabs(y1.xR[i] - y2.xR[i]) > 1000 * machineepsilon, __FILE__, __LINE__, "testknnunit.ap:553");
      }
   }
// Test generalization ability on a simple noisy classification task:
// * 0<x<1 - P(class=0)=1
// * 1<x<2 - P(class=0)=2-x
// * 2<x<3 - P(class=0)=0
//
// An algorithm with K=100 and Eps={0,0.1} is tested
   for (pass = 0; pass <= 1; pass++) {
   // Prepare task
      npoints = 3000;
      ae_matrix_set_length(&xy, npoints, 2);
      for (i = 0; i < npoints; i++) {
         xy.xyR[i][0] = 3 * hqrnduniformr(&rs);
         if (xy.xyR[i][0] <= 1.0) {
            xy.xyR[i][1] = 0.0;
         } else {
            if (xy.xyR[i][0] <= 2.0) {
               if (hqrnduniformr(&rs) < xy.xyR[i][0] - 1) {
                  xy.xyR[i][1] = 1.0;
               } else {
                  xy.xyR[i][1] = 0.0;
               }
            } else {
               xy.xyR[i][1] = 1.0;
            }
         }
      }
   // Select K and Eps, create model
      k = 100;
      eps = 0.1 * (pass % 2);
      testknnunit_unsetknn(&model1);
      knnbuildercreate(&builder);
      knnbuildersetdatasetcls(&builder, &xy, npoints, 1, 2);
      knnbuildersetnorm(&builder, hqrnduniformi(&rs, 3));
      knnbuilderbuildknnmodel(&builder, k, eps, &model1, &rep);
   // Check model quality
      ae_vector_set_length(&x1, 1);
      x1.xR[0] = 0.0;
      while (x1.xR[0] <= 3.0) {
         knnprocess(&model1, &x1, &y1);
         set_error_flag(err, y1.xR[0] < 0.0, __FILE__, __LINE__, "testknnunit.ap:606");
         set_error_flag(err, y1.xR[1] < 0.0, __FILE__, __LINE__, "testknnunit.ap:607");
         set_error_flag(err, fabs(y1.xR[0] + y1.xR[1] - 1) > 1000 * machineepsilon, __FILE__, __LINE__, "testknnunit.ap:608");
         if (x1.xR[0] < 1.0) {
            set_error_flag(err, y1.xR[0] < 0.8, __FILE__, __LINE__, "testknnunit.ap:610");
         }
         if (x1.xR[0] >= 1.0 && x1.xR[0] <= 2.0) {
            set_error_flag(err, fabs(y1.xR[1] - (x1.xR[0] - 1)) > 0.5, __FILE__, __LINE__, "testknnunit.ap:612");
         }
         if (x1.xR[0] > 2.0) {
            set_error_flag(err, y1.xR[1] < 0.8, __FILE__, __LINE__, "testknnunit.ap:614");
         }
         x1.xR[0] += 0.01;
      }
   }
// Test simple regression task without noise:
// * |x|<1, |y|<1
// * F(x,y) = x^2+y
//
// A model with K=50 is used, we check that
// * Eps=0 is good enough
// * having Eps>0 results in worse error metrics, but not too bad
// Prepare task
   npoints = 5000;
   ae_matrix_set_length(&xy, npoints, 3);
   for (i = 0; i < npoints; i++) {
      xy.xyR[i][0] = 2 * hqrnduniformr(&rs) - 1;
      xy.xyR[i][1] = 2 * hqrnduniformr(&rs) - 1;
      xy.xyR[i][2] = sqr(xy.xyR[i][0]) + xy.xyR[i][1];
   }
// Build model with Eps=0, check model quality
   k = 50;
   testknnunit_unsetknn(&model1);
   knnbuildercreate(&builder);
   knnbuildersetdatasetreg(&builder, &xy, npoints, 2, 1);
   knnbuildersetnorm(&builder, hqrnduniformi(&rs, 3));
   knnbuilderbuildknnmodel(&builder, k, 0.0, &model1, &rep);
   ae_vector_set_length(&x1, 2);
   maxerr = 0.0;
   avgerr = 0.0;
   cnt = 0;
   for (i = 0; i <= 1000; i++) {
   // NOTE: we test model in the inner points, it deteriorates near the bounds
      x1.xR[0] = 0.8 * (2 * hqrnduniformr(&rs) - 1);
      x1.xR[1] = 0.8 * (2 * hqrnduniformr(&rs) - 1);
      v = sqr(x1.xR[0]) + x1.xR[1];
      knnprocess(&model1, &x1, &y1);
      v = fabs(y1.xR[0] - v);
      maxerr = rmax2(maxerr, v);
      avgerr += v;
      cnt++;
   }
   avgerr /= cnt;
   set_error_flag(err, maxerr > 0.15, __FILE__, __LINE__, "testknnunit.ap:669");
   set_error_flag(err, avgerr > 0.05, __FILE__, __LINE__, "testknnunit.ap:670");
// Build model with Eps=1.0, compare error metrics with Eps=0
   knnbuilderbuildknnmodel(&builder, k, 1.0, &model2, &rep2);
   set_error_flag(err, rep2.rmserror <= rep.rmserror, __FILE__, __LINE__, "testknnunit.ap:676");
   set_error_flag(err, rep2.rmserror <= rep.rmserror + 0.001, __FILE__, __LINE__, "testknnunit.ap:677");
   set_error_flag(err, rep2.rmserror >= rep.rmserror + 0.020, __FILE__, __LINE__, "testknnunit.ap:678");
   ae_frame_leave();
}

bool testknn(bool silent) {
   bool waserrors;
   bool knnerrors;
   bool result;
// Primary settings
   knnerrors = false;
   waserrors = false;
// Tests
   testknnunit_testknnalgo(&knnerrors);
// Final report
   waserrors = knnerrors;
   if (!silent) {
      printf("KNN CLASSIFIER/REGRESSION TEST\n");
      printf("TOTAL RESULTS:                           ");
      if (!waserrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("* KNN (AKNN) ALGORITHM                   ");
      if (!knnerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      if (waserrors) {
         printf("TEST SUMMARY: FAILED\n");
      } else {
         printf("TEST SUMMARY: PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   return result;
}

// === mlptrain testing unit ===
// This function tests MLPTrainES().
//
// It returns True in case of errors, False when no errors were detected
static bool testmlptrainunit_testmlptraines() {
   ae_frame _frame_block;
   ae_int_t pass;
   ae_int_t passcount;
   ae_int_t n;
   ae_int_t i;
   ae_int_t j;
   ae_int_t nrestarts;
   ae_int_t info;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewMatrix(trnxy, 0, 0, DT_REAL);
   NewMatrix(valxy, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewObj(mlpreport, rep);
   result = false;
// First test checks that MLPTrainES() - when training set is equal to the validation
// set, MLPTrainES() behaves just like a "normal" training algorithm.
//
// Test sequence:
// * generate training set - 100 random points from 2D square [-1,+1]*[-1,+1]
// * generate network with 2 inputs, no hidden layers, nonlinear output layer,
//   use its outputs as target values for the test set
// * randomize network
// * train with MLPTrainES(), using original set as both training and validation set
// * trained network must reproduce training set with good precision
//
// NOTE: it is important to test algorithm on nonlinear network because linear
//       problems converge too fast. Slow convergence is important to detect
//       some kinds of bugs.
//
// NOTE: it is important to have NRestarts at least equal to 5, because with just
//       one restart algorithm fails test about once in several thousands of passes.
   passcount = 10;
   nrestarts = 5;
   for (pass = 1; pass <= passcount; pass++) {
   // Create network, generate training/validation sets
      mlpcreater0(2, 1, -2.0, 2.0, &network);
      mlprandomize(&network);
      n = 100;
      ae_matrix_set_length(&trnxy, n, 3);
      ae_matrix_set_length(&valxy, n, 3);
      ae_vector_set_length(&x, 2);
      ae_vector_set_length(&y, 1);
      for (i = 0; i < n; i++) {
         for (j = 0; j <= 1; j++) {
            trnxy.xyR[i][j] = randommid();
            valxy.xyR[i][j] = trnxy.xyR[i][j];
            x.xR[j] = trnxy.xyR[i][j];
         }
         mlpprocess(&network, &x, &y);
         trnxy.xyR[i][2] = y.xR[0];
         valxy.xyR[i][2] = y.xR[0];
      }
      mlprandomize(&network);
      mlptraines(&network, &trnxy, n, &valxy, n, 0.0001, nrestarts, &info, &rep);
      if (info <= 0) {
         result = true;
         ae_frame_leave();
         return result;
      }
      if (sqrt(mlperror(&network, &valxy, n) / n) > 0.01) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
   ae_frame_leave();
   return result;
}

// This  function   tests   MLPTrainLM,  MLPTrainLBFGS   and  MLPTrainNetwork
// functions  for regression.  It check that  train functions  work correctly.
// Test use Create1 with 10 neurons.
// Test function is f(x,y)=X^2+cos(3*Pi*y).
static bool testmlptrainunit_testmlptrainregr() {
   ae_frame _frame_block;
   ae_int_t info;
   ae_int_t n;
   ae_int_t sn;
   ae_int_t nneurons;
   double vdecay;
   double averr;
   double st;
   double eps;
   double traineps;
   ae_int_t nneedrest;
   ae_int_t trainits;
   ae_int_t shift;
   ae_int_t i;
   ae_int_t j;
   ae_int_t vtrain;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net);
   NewObj(mlptrainer, trainer);
   NewObj(mlpreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(sparsematrix, sm);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   eps = 0.02;
   vdecay = 0.001;
   nneurons = 10;
   nneedrest = 5;
   traineps = 1.0E-3;
   trainits = 0;
   sn = 5;
   n = sn * sn;
   st = 2.0 / (sn - 1);
   sparsecreate(n, 3, n * 3, &sm);
   ae_matrix_set_length(&xy, n, 3);
   ae_vector_set_length(&x, 2);
   for (vtrain = 0; vtrain <= 3; vtrain++) {
      averr = 0.0;
   // Create a train set(uniformly distributed set of points).
      for (i = 0; i < sn; i++) {
         for (j = 0; j < sn; j++) {
            shift = i * sn + j;
            xy.xyR[shift][0] = i * st - 1.0;
            xy.xyR[shift][1] = j * st - 1.0;
            xy.xyR[shift][2] = xy.xyR[shift][0] * xy.xyR[shift][0] + cos(3 * pi * xy.xyR[shift][1]);
         }
      }
   // Create and train a neural network
      mlpcreate1(2, nneurons, 1, &net);
      if (vtrain == 0) {
         mlptrainlm(&net, &xy, n, vdecay, nneedrest, &info, &rep);
      }
      if (vtrain == 1) {
         mlptrainlbfgs(&net, &xy, n, vdecay, nneedrest, traineps, trainits, &info, &rep);
      }
   // Train with trainer, using:
   //  * dense matrix;
      if (vtrain == 2) {
         mlpcreatetrainer(2, 1, &trainer);
         mlpsetdataset(&trainer, &xy, n);
         mlpsetdecay(&trainer, vdecay);
         mlpsetcond(&trainer, traineps, trainits);
         mlptrainnetwork(&trainer, &net, nneedrest, &rep);
      }
   //  * sparse matrix.
      if (vtrain == 3) {
         for (i = 0; i < n; i++) {
            for (j = 0; j <= 2; j++) {
               sparseset(&sm, i, j, xy.xyR[i][j]);
            }
         }
         mlpcreatetrainer(2, 1, &trainer);
         mlpsetsparsedataset(&trainer, &sm, n);
         mlpsetdecay(&trainer, vdecay);
         mlpsetcond(&trainer, traineps, trainits);
         mlptrainnetwork(&trainer, &net, nneedrest, &rep);
      }
   // Check that network is trained correctly
      for (i = 0; i < n; i++) {
         x.xR[0] = xy.xyR[i][0];
         x.xR[1] = xy.xyR[i][1];
         mlpprocess(&net, &x, &y);
      // Calculate average error
         averr += fabs(y.xR[0] - xy.xyR[i][2]);
      }
      if (averr / n > eps) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// This  function tests  MLPTrainNetwork/MLPStartTraining/MLPContinueTraining
// functions for  regression.  It check  that train  functions work correctly.
// Test use Create1 with 2 neurons.
// Test function is XOR(x,y).
static bool testmlptrainunit_testmlpxorregr() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t sn;
   ae_int_t nneurons;
   double vdecay;
   double averr;
   double eps;
   ae_int_t numxp;
   double traineps;
   ae_int_t nneedrest;
   ae_int_t trainits;
   ae_int_t shift;
   ae_int_t i;
   ae_int_t j;
   ae_int_t vtrain;
   ae_int_t xp;
   ae_int_t nfailures;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net);
   NewObj(mlptrainer, trainer);
   NewObj(mlpreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(sparsematrix, sm);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   result = false;
   eps = 0.01;
   numxp = 15;
   vdecay = 0.0001;
   nneurons = 4;
   nneedrest = 1;
   traineps = 1.0E-4;
   trainits = 0;
   sn = 2;
   n = sn * sn;
   sparsecreate(n, 3, n * 3, &sm);
   ae_matrix_set_length(&xy, n, 3);
   ae_vector_set_length(&x, 2);
   nfailures = 0;
   for (xp = 1; xp <= numxp; xp++) {
      for (vtrain = 0; vtrain <= 3; vtrain++) {
      // Create a train set(uniformly distributed set of points).
         for (i = 0; i < sn; i++) {
            for (j = 0; j < sn; j++) {
               shift = i * sn + j;
               xy.xyR[shift][0] = (double)i;
               xy.xyR[shift][1] = (double)j;
               if (xy.xyR[shift][0] == xy.xyR[shift][1]) {
                  xy.xyR[shift][2] = 0.0;
               } else {
                  xy.xyR[shift][2] = 1.0;
               }
            }
         }
      // Create and train a neural network
         mlpcreate1(2, nneurons, 1, &net);
      // Train with trainer, using:
      //  * dense matrix;
         if (vtrain == 0) {
            mlpcreatetrainer(2, 1, &trainer);
            mlpsetdataset(&trainer, &xy, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net, nneedrest, &rep);
         }
         if (vtrain == 1) {
            mlpcreatetrainer(2, 1, &trainer);
            mlpsetdataset(&trainer, &xy, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlpstarttraining(&trainer, &net, true);
            while (mlpcontinuetraining(&trainer, &net)) {
            }
         }
      //  * sparse matrix.
         if (vtrain == 2) {
            for (i = 0; i < n; i++) {
               for (j = 0; j <= 2; j++) {
                  sparseset(&sm, i, j, xy.xyR[i][j]);
               }
            }
            mlpcreatetrainer(2, 1, &trainer);
            mlpsetsparsedataset(&trainer, &sm, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net, nneedrest, &rep);
         }
         if (vtrain == 3) {
            for (i = 0; i < n; i++) {
               for (j = 0; j <= 2; j++) {
                  sparseset(&sm, i, j, xy.xyR[i][j]);
               }
            }
            mlpcreatetrainer(2, 1, &trainer);
            mlpsetsparsedataset(&trainer, &sm, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlpstarttraining(&trainer, &net, true);
            while (mlpcontinuetraining(&trainer, &net)) {
            }
         }
      // Check that network is trained correctly
         averr = 0.0;
         for (i = 0; i < n; i++) {
            x.xR[0] = xy.xyR[i][0];
            x.xR[1] = xy.xyR[i][1];
            mlpprocess(&net, &x, &y);
         // Calculate average error
            averr += fabs(y.xR[0] - xy.xyR[i][2]);
         }
         if (averr / n > eps) {
            nfailures++;
         }
      }
   }
   set_error_flag(&result, nfailures >= 2, __FILE__, __LINE__, "testmlptrainunit.ap:580");
   ae_frame_leave();
   return result;
}

// This  function   tests   MLPTrainLM,  MLPTrainLBFGS  and   MLPTrainNetwork
// functions for classification problems. It check that train  functions work
// correctly  when  is used CreateC1  function.  Here  the network  tries  to
// distinguish positive from negative numbers.
static bool testmlptrainunit_testmlptrainclass() {
   ae_frame _frame_block;
   ae_int_t info;
   ae_int_t n;
   double vdecay;
   double traineps;
   ae_int_t nneedrest;
   ae_int_t trainits;
   double tmp;
   double mnc;
   double mxc;
   ae_int_t nxp;
   ae_int_t i;
   ae_int_t rndind;
   ae_int_t vtrain;
   ae_int_t xp;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net);
   NewObj(mlptrainer, trainer);
   NewObj(mlpreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(sparsematrix, sm);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   result = false;
   mnc = 10.0;
   mxc = 11.0;
   nxp = 15;
   vdecay = 0.0001;
   nneedrest = 10;
   traineps = 1.0E-4;
   trainits = 0;
   n = 100;
   sparsecreate(n, 2, n * 2, &sm);
   ae_vector_set_length(&x, 1);
   ae_matrix_set_length(&xy, n, 2);
   for (xp = 1; xp <= nxp; xp++) {
      for (vtrain = 0; vtrain <= 3; vtrain++) {
      // Initialization:
      //  * create negative part of the set;
         for (i = 0; i < n / 2; i++) {
            xy.xyR[i][0] = -1 * ((mxc - mnc) * randomreal() + mnc);
            xy.xyR[i][1] = 0.0;
         }
      //  * create positive part of the set;
         for (i = n / 2; i < n; i++) {
            xy.xyR[i][0] = (mxc - mnc) * randomreal() + mnc;
            xy.xyR[i][1] = 1.0;
         }
      //  * mix two parts.
         for (i = 0; i < n; i++) {
            do {
               rndind = randominteger(n);
            } while (rndind == i);
            tmp = xy.xyR[i][0];
            xy.xyR[i][0] = xy.xyR[rndind][0];
            xy.xyR[rndind][0] = tmp;
            tmp = xy.xyR[i][1];
            xy.xyR[i][1] = xy.xyR[rndind][1];
            xy.xyR[rndind][1] = tmp;
         }
      // Create and train a neural network
         mlpcreatec0(1, 2, &net);
         if (vtrain == 0) {
            mlptrainlm(&net, &xy, n, vdecay, nneedrest, &info, &rep);
         }
         if (vtrain == 1) {
            mlptrainlbfgs(&net, &xy, n, vdecay, nneedrest, traineps, trainits, &info, &rep);
         }
      // Train with trainer, using:
      //  * dense matrix;
         if (vtrain == 2) {
            mlpcreatetrainercls(1, 2, &trainer);
            mlpsetdataset(&trainer, &xy, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net, nneedrest, &rep);
         }
      //  * sparse matrix.
         if (vtrain == 3) {
            for (i = 0; i < n; i++) {
               sparseset(&sm, i, 0, xy.xyR[i][0]);
               sparseset(&sm, i, 1, xy.xyR[i][1]);
            }
            mlpcreatetrainercls(1, 2, &trainer);
            mlpsetsparsedataset(&trainer, &sm, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net, nneedrest, &rep);
         }
      // Test on training set
         for (i = 0; i < n; i++) {
            x.xR[0] = xy.xyR[i][0];
            mlpprocess(&net, &x, &y);
         // Negative number has to be negative and
         // positive number has to be positive.
            if (x.xR[0] < 0.0 ? y.xR[0] < 0.95 && y.xR[1] > 0.05 : y.xR[0] > 0.05 && y.xR[1] < 0.95) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testmlptrainunit.ap:730");
               ae_frame_leave();
               return result;
            }
         }
      // Test on random set
         for (i = 0; i < n; i++) {
            x.xR[0] = pow(-1.0, (double)randominteger(2)) * ((mxc - mnc) * randomreal() + mnc);
            mlpprocess(&net, &x, &y);
            if (x.xR[0] < 0.0 ? y.xR[0] < 0.95 && y.xR[1] > 0.05 : y.xR[0] > 0.05 && y.xR[1] < 0.95) {
               set_error_flag(&result, true, __FILE__, __LINE__, "testmlptrainunit.ap:745");
               ae_frame_leave();
               return result;
            }
         }
      }
   }
   ae_frame_leave();
   return result;
}

// This function tests   MLPTrainNetwork/MLPStartTraining/MLPContinueTraining
// functions for classification problems. It check that train  functions work
// correctly  when  is used CreateC1  function.  Here  the network  tries  to
// distinguish positive from negative numbers.
static bool testmlptrainunit_testmlpxorcls() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t nin;
   ae_int_t nout;
   ae_int_t wcount;
   double e;
   double ebest;
   double v;
   double vdecay;
   double traineps;
   ae_int_t nneurons;
   ae_int_t nneedrest;
   ae_int_t trainits;
   ae_int_t nxp;
   ae_int_t i;
   ae_int_t vtrain;
   ae_int_t xp;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net);
   NewObj(mlptrainer, trainer);
   NewObj(mlpreport, rep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewObj(sparsematrix, sm);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   NewVector(wbest, 0, DT_REAL);
   nxp = 15;
   nneurons = 4;
   vdecay = 0.001;
   nneedrest = 3;
   traineps = 1.0E-4;
   trainits = 0;
   n = 4;
   sparsecreate(n, 3, n * 3, &sm);
   ae_vector_set_length(&x, 2);
   ae_matrix_set_length(&xy, n, 3);
// Initialization:
   xy.xyR[0][0] = 0.0;
   xy.xyR[0][1] = 0.0;
   xy.xyR[0][2] = 0.0;
   xy.xyR[1][0] = 0.0;
   xy.xyR[1][1] = 1.0;
   xy.xyR[1][2] = 1.0;
   xy.xyR[2][0] = 1.0;
   xy.xyR[2][1] = 0.0;
   xy.xyR[2][2] = 1.0;
   xy.xyR[3][0] = 1.0;
   xy.xyR[3][1] = 1.0;
   xy.xyR[3][2] = 0.0;
// Create a neural network
   mlpcreatec1(2, nneurons, 2, &net);
   mlpproperties(&net, &nin, &nout, &wcount);
   ae_vector_set_length(&wbest, wcount);
// Test
   for (xp = 1; xp <= nxp; xp++) {
      for (vtrain = 0; vtrain <= 3; vtrain++) {
      // Train with trainer, using:
      //  * dense matrix;
         if (vtrain == 0) {
            mlpcreatetrainercls(2, 2, &trainer);
            mlpsetdataset(&trainer, &xy, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net, nneedrest, &rep);
         }
         if (vtrain == 1) {
            mlpcreatetrainercls(2, 2, &trainer);
            mlpsetdataset(&trainer, &xy, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            ebest = maxrealnumber;
            for (i = 1; i <= nneedrest; i++) {
               mlpstarttraining(&trainer, &net, true);
               while (mlpcontinuetraining(&trainer, &net)) {
               }
               v = ae_v_dotproduct(net.weights.xR, 1, net.weights.xR, 1, wcount);
               e = mlperror(&net, &xy, n) + 0.5 * vdecay * v;
            // Compare with the best answer.
               if (e < ebest) {
                  ae_v_move(wbest.xR, 1, net.weights.xR, 1, wcount);
                  ebest = e;
               }
            }
         // The best result
            ae_v_move(net.weights.xR, 1, wbest.xR, 1, wcount);
         }
      //  * sparse matrix.
         if (vtrain == 2) {
            for (i = 0; i < n; i++) {
               sparseset(&sm, i, 0, xy.xyR[i][0]);
               sparseset(&sm, i, 1, xy.xyR[i][1]);
               sparseset(&sm, i, 2, xy.xyR[i][2]);
            }
            mlpcreatetrainercls(2, 2, &trainer);
            mlpsetsparsedataset(&trainer, &sm, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net, nneedrest, &rep);
         }
         if (vtrain == 3) {
            for (i = 0; i < n; i++) {
               sparseset(&sm, i, 0, xy.xyR[i][0]);
               sparseset(&sm, i, 1, xy.xyR[i][1]);
               sparseset(&sm, i, 2, xy.xyR[i][2]);
            }
            mlpcreatetrainercls(2, 2, &trainer);
            mlpsetsparsedataset(&trainer, &sm, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            ebest = maxrealnumber;
            for (i = 1; i <= nneedrest; i++) {
               mlpstarttraining(&trainer, &net, true);
               while (mlpcontinuetraining(&trainer, &net)) {
               }
               v = ae_v_dotproduct(net.weights.xR, 1, net.weights.xR, 1, wcount);
               e = mlperror(&net, &xy, n) + 0.5 * vdecay * v;
            // Compare with the best answer.
               if (e < ebest) {
                  ae_v_move(wbest.xR, 1, net.weights.xR, 1, wcount);
                  ebest = e;
               }
            }
         // The best result
            ae_v_move(net.weights.xR, 1, wbest.xR, 1, wcount);
         }
      // Test on training set
         for (i = 0; i < n; i++) {
            x.xR[0] = xy.xyR[i][0];
            x.xR[1] = xy.xyR[i][1];
            mlpprocess(&net, &x, &y);
            if (x.xR[0] == x.xR[1] ? y.xR[0] < 0.95 && y.xR[1] > 0.05 : y.xR[0] > 0.05 && y.xR[1] < 0.95) {
               result = true;
               ae_frame_leave();
               return result;
            }
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// The  test  check,  that  all weights are zero after training with trainer
// using empty dataset(either zero size or is't used MLPSetDataSet function).
// Test  on  regression and classification problems given by dense or sparse
// matrix.
//
// NOTE: Result of the function is written in MLPTrainRegrErr variable in
//       unit test.
static bool testmlptrainunit_testmlpzeroweights() {
   ae_frame _frame_block;
   ae_int_t nin;
   ae_int_t nout;
   ae_int_t wcount;
   ae_int_t mxnin;
   ae_int_t mxnout;
   double vdecay;
   double traineps;
   ae_int_t trainits;
   ae_int_t nneedrest;
   bool iscls;
   bool issparse;
   ae_int_t c;
   ae_int_t n;
   ae_int_t xp;
   ae_int_t nxp;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(mlptrainer, trainer);
   NewObj(multilayerperceptron, net);
   NewObj(mlpreport, rep);
   NewMatrix(dds, 0, 0, DT_REAL);
   NewObj(sparsematrix, sds);
   mxnin = 10;
   mxnout = 10;
   vdecay = 1.0E-3;
   nneedrest = 1;
   traineps = 1.0E-3;
   trainits = 0;
   sparsecreate(1, 1, 0, &sds);
   sparseconverttocrs(&sds);
   nxp = 10;
   for (xp = 1; xp <= nxp; xp++) {
      c = randominteger(2);
      iscls = c == 1;
      c = randominteger(2);
      issparse = c == 1;
   // Create trainer and network
      if (!iscls) {
      // Regression
         nin = randominteger(mxnin) + 1;
         nout = randominteger(mxnout) + 1;
         mlpcreatetrainer(nin, nout, &trainer);
         mlpcreate0(nin, nout, &net);
      } else {
      // Classification
         nin = randominteger(mxnin) + 1;
         nout = randominteger(mxnout) + 2;
         mlpcreatetrainercls(nin, nout, &trainer);
         mlpcreatec0(nin, nout, &net);
      }
      n = randominteger(2) - 1;
      if (n == 0) {
         if (!issparse) {
            mlpsetdataset(&trainer, &dds, n);
         } else {
            mlpsetsparsedataset(&trainer, &sds, n);
         }
      }
      mlpsetdecay(&trainer, vdecay);
      mlpsetcond(&trainer, traineps, trainits);
      c = randominteger(2);
      if (c == 0) {
         mlpstarttraining(&trainer, &net, true);
         while (mlpcontinuetraining(&trainer, &net)) {
         }
      }
      if (c == 1) {
         mlptrainnetwork(&trainer, &net, nneedrest, &rep);
      }
   // Check weights
      mlpproperties(&net, &nin, &nout, &wcount);
      for (c = 0; c < wcount; c++) {
         if (net.weights.xR[c] != 0.0) {
            result = true;
            ae_frame_leave();
            return result;
         }
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// This function tests that increasing numbers of restarts lead to statistical
// improvement quality of solution.
// Neural network created by Create1(10 neurons) and trained by MLPTrainLBFGS.
//
// TEST's DISCRIPTION:
//
// Net0   -   network trained with one restart (denoted as R1)
// Net1   -   network trained with more than one restart (denoted as Rn)
//
// We must refuse hypothesis that R1 equivalent to Rn.
// Here Mean = N/2, Sigma = Sqrt(N)/2.
//        _
//       | 0   -   R1 worse than Rn;
//  ri = |
//       |_1   -   Rn same or worse then R1.
//
// If Sum(ri)<Mean-5*Sigma then hypothesis is refused and test is passed.
// In another case if Mean-5*Sigma <= Sum(ri) <= Mean+5*Sigma then hypothesis
// is't refused and test is broken; and if Mean+5*Sigma<Sum(ri) then test
// broken too hard!
static bool testmlptrainunit_testmlprestarts() {
   ae_frame _frame_block;
   ae_int_t info;
   ae_int_t n;
   ae_int_t nneurons;
   double vdecay;
   ae_int_t wcount0;
   ae_int_t wcount1;
   ae_int_t nin;
   ae_int_t nout;
   double avval;
   double e0;
   double e1;
   double mean;
   double numsigma;
   ae_int_t numxp;
   double traineps;
   ae_int_t nneedrest;
   ae_int_t trainits;
   ae_int_t i;
   ae_int_t vtrain;
   ae_int_t xp;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net0);
   NewObj(multilayerperceptron, net1);
   NewObj(mlptrainer, trainer);
   NewObj(mlpreport, rep);
   NewObj(sparsematrix, sm);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   vdecay = 0.001;
   nneurons = 4;
   nneedrest = 3;
   traineps = 0.00;
   trainits = 2;
   n = 20;
   numxp = 400;
   ae_matrix_set_length(&xy, n, 2);
   ae_vector_set_length(&x, 1);
   sparsecreate(n, 2, n * 2, &sm);
   mean = numxp / 2.0;
   numsigma = 5.0 * sqrt((double)numxp) / 2.0;
   for (vtrain = 0; vtrain <= 2; vtrain++) {
      avval = 0.0;
      for (xp = 1; xp <= numxp; xp++) {
      // Create a train set
         for (i = 0; i < n; i++) {
            xy.xyR[i][0] = randommid();
            xy.xyR[i][1] = randommid();
         }
      // Create and train a neural network
         mlpcreate1(1, nneurons, 1, &net0);
         mlpcreate1(1, nneurons, 1, &net1);
         if (vtrain == 0) {
            mlptrainlbfgs(&net0, &xy, n, vdecay, 1, traineps, trainits, &info, &rep);
            mlptrainlbfgs(&net1, &xy, n, vdecay, nneedrest, traineps, trainits, &info, &rep);
         }
         if (vtrain == 1) {
            mlpcreatetrainer(1, 1, &trainer);
            mlpsetdataset(&trainer, &xy, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net0, 1, &rep);
            mlptrainnetwork(&trainer, &net1, nneedrest, &rep);
         }
         if (vtrain == 2) {
            for (i = 0; i < n; i++) {
               sparseset(&sm, i, 0, xy.xyR[i][0]);
               sparseset(&sm, i, 1, xy.xyR[i][1]);
            }
            mlpcreatetrainer(1, 1, &trainer);
            mlpsetsparsedataset(&trainer, &sm, n);
            mlpsetdecay(&trainer, vdecay);
            mlpsetcond(&trainer, traineps, trainits);
            mlptrainnetwork(&trainer, &net0, 1, &rep);
            mlptrainnetwork(&trainer, &net1, nneedrest, &rep);
         }
      // Calculate errors for...
      //
      // ...for Net0, trained with 1 restart.
         mlpproperties(&net0, &nin, &nout, &wcount0);
         e0 = ae_v_dotproduct(net0.weights.xR, 1, net0.weights.xR, 1, wcount0);
         e0 = mlperrorn(&net0, &xy, n) + 0.5 * vdecay * e0;
      // ...for Net1, trained with NNeedRest>1 restarts.
         mlpproperties(&net1, &nin, &nout, &wcount1);
         e1 = ae_v_dotproduct(net1.weights.xR, 1, net1.weights.xR, 1, wcount1);
         e1 = mlperrorn(&net1, &xy, n) + 0.5 * vdecay * e1;
         if (e0 <= e1) {
            avval++;
         }
      }
      if (mean - numsigma < avval) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

// The function test function MLPKFoldCV.
static bool testmlptrainunit_testmlpcverror() {
   ae_frame _frame_block;
   ae_int_t nin;
   ae_int_t nout;
   ae_int_t nneurons;
   ae_int_t rowsz;
   double decay;
   double wstep;
   ae_int_t maxits;
   ae_int_t foldscount;
   ae_int_t nneedrest;
   ae_int_t npoints;
   ae_int_t ntstpoints;
   double mean;
   double numsigma;
   double diffms;
   double tstrelclserror;
   double tstavgce;
   double tstrmserror;
   double tstavgerror;
   double tstavgrelerror;
   ae_int_t r0;
   ae_int_t r1;
   ae_int_t r2;
   ae_int_t r3;
   ae_int_t r4;
   ae_int_t ntest;
   ae_int_t xp;
   ae_int_t nxp;
   bool isregr;
   ae_int_t issparse;
   ae_int_t i;
   ae_int_t j;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, net);
   NewObj(mlptrainer, trainer);
   NewObj(mlpreport, rep);
   NewObj(mlpreport, cvrep);
   NewObj(sparsematrix, sptrainingset);
   NewMatrix(trainingset, 0, 0, DT_REAL);
   NewMatrix(testset, 0, 0, DT_REAL);
   result = false;
   decay = 1.0E-6;
   wstep = 0.0;
   foldscount = 5;
   nneedrest = 1;
   ntest = randominteger(4);
   nxp = 1000;
   maxits = 50;
   nin = 1;
   nout = 1;
   npoints = 5;
   ntstpoints = 100;
   isregr = true;
   nneurons = 3;
   if (ntest == 1) {
      nxp = 1000;
      maxits = 50;
      nin = 1;
      nout = 10;
      npoints = 5;
      ntstpoints = 100;
      isregr = true;
   }
   if (ntest == 2) {
      nxp = 1000;
      maxits = 50;
      nin = 10;
      nout = 1;
      npoints = 20;
      ntstpoints = 100;
      isregr = true;
   }
   if (ntest == 3) {
      nxp = 2000;
      maxits = 10;
      nin = 1;
      nneurons = 3;
      nout = 3;
      npoints = 10;
      ntstpoints = 100;
      isregr = false;
   }
   mean = nxp / 2.0;
   numsigma = 3.0 * sqrt((double)nxp / 4.0);
   diffms = mean - numsigma;
   issparse = randominteger(2);
   if (isregr) {
      mlpcreate0(nin, nout, &net);
      mlpcreatetrainer(nin, nout, &trainer);
   } else {
      mlpcreatec1(nin, nneurons, nout, &net);
      mlpcreatetrainercls(nin, nout, &trainer);
   }
   mlpsetcond(&trainer, wstep, maxits);
   mlpsetdecay(&trainer, decay);
   if (isregr) {
      rowsz = nin + nout;
   } else {
      rowsz = nin + 1;
   }
   r0 = 0;
   r1 = 0;
   r2 = 0;
   r3 = 0;
   r4 = 0;
   for (xp = 1; xp <= nxp; xp++) {
   // Dense matrix
      if (issparse == 0) {
         matrixsetlengthatleast(&trainingset, npoints, rowsz);
      // Create training set
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nin; j++) {
               trainingset.xyR[i][j] = randommid();
            }
         }
         if (isregr) {
            for (i = 0; i < npoints; i++) {
               for (j = nin; j < rowsz; j++) {
                  trainingset.xyR[i][j] = 2 * randomreal() + 1;
               }
            }
         } else {
            for (i = 0; i < npoints; i++) {
               for (j = nin; j < rowsz; j++) {
                  trainingset.xyR[i][j] = (double)randominteger(nout);
               }
            }
         }
         mlpsetdataset(&trainer, &trainingset, npoints);
      }
   // Sparse matrix
      if (issparse == 1) {
         sparsecreate(npoints, rowsz, npoints * rowsz, &sptrainingset);
      // Create training set
         for (i = 0; i < npoints; i++) {
            for (j = 0; j < nin; j++) {
               sparseset(&sptrainingset, i, j, randommid());
            }
         }
         if (isregr) {
            for (i = 0; i < npoints; i++) {
               for (j = nin; j < rowsz; j++) {
                  sparseset(&sptrainingset, i, j, 2 * randomreal() + 1);
               }
            }
         } else {
            for (i = 0; i < npoints; i++) {
               for (j = nin; j < rowsz; j++) {
                  sparseset(&sptrainingset, i, j, (double)randominteger(nout));
               }
            }
         }
         sparseconverttocrs(&sptrainingset);
         mlpsetsparsedataset(&trainer, &sptrainingset, npoints);
      }
      matrixsetlengthatleast(&testset, ntstpoints, rowsz);
   // Create test set
      for (i = 0; i < ntstpoints; i++) {
         for (j = 0; j < nin; j++) {
            testset.xyR[i][j] = randommid();
         }
      }
      if (isregr) {
         for (i = 0; i < ntstpoints; i++) {
            for (j = nin; j < rowsz; j++) {
               testset.xyR[i][j] = 2 * randomreal() + 1;
            }
         }
      } else {
         for (i = 0; i < ntstpoints; i++) {
            for (j = nin; j < rowsz; j++) {
               testset.xyR[i][j] = (double)randominteger(nout);
            }
         }
      }
      mlptrainnetwork(&trainer, &net, nneedrest, &rep);
      tstrelclserror = 0.0;
      tstavgce = 0.0;
      tstrmserror = 0.0;
      tstavgerror = 0.0;
      tstavgrelerror = 0.0;
      if (!isregr) {
         tstrelclserror = mlprelclserror(&net, &testset, ntstpoints);
         tstavgce = mlpavgce(&net, &testset, ntstpoints);
      }
      tstrmserror = mlprmserror(&net, &testset, ntstpoints);
      tstavgerror = mlpavgerror(&net, &testset, ntstpoints);
      tstavgrelerror = mlpavgrelerror(&net, &testset, ntstpoints);
   // Cross-validation
      mlpkfoldcv(&trainer, &net, nneedrest, foldscount, &cvrep);
      if (!isregr) {
         if (fabs(tstrelclserror - rep.relclserror) < fabs(tstrelclserror - cvrep.relclserror)) {
            r0++;
         }
         if (fabs(tstavgce - rep.avgce) < fabs(tstavgce - cvrep.avgce)) {
            r1++;
         }
      }
      if (fabs(tstrmserror - rep.rmserror) < fabs(tstrmserror - cvrep.rmserror)) {
         r2++;
      }
      if (fabs(tstavgerror - rep.avgerror) < fabs(tstavgerror - cvrep.avgerror)) {
         r3++;
      }
      if (fabs(tstavgrelerror - rep.avgrelerror) < fabs(tstavgrelerror - cvrep.avgrelerror)) {
         r4++;
      }
   }
   if (!isregr) {
      if (diffms <= (double)r0 || diffms <= (double)r1) {
         set_error_flag(&result, true, __FILE__, __LINE__, "testmlptrainunit.ap:1488");
         ae_frame_leave();
         return result;
      }
   }
   if ((diffms <= (double)r2 || diffms <= (double)r3) || diffms <= (double)r4) {
      set_error_flag(&result, true, __FILE__, __LINE__, "testmlptrainunit.ap:1493");
      ae_frame_leave();
      return result;
   }
// Test FoldCV when  no dataset  was specified with
// MLPSetDataset/SetSparseDataset(), or subset with
// only one point  was  given.
//
// NPoints values:
//  * -1 - don't set dataset with using MLPSetDataset..;
//  *  0 - zero dataset;
//  *  1 - dataset with one point.
   for (npoints = -1; npoints <= 1; npoints++) {
      if (isregr) {
         mlpcreatetrainer(nin, nout, &trainer);
      } else {
         mlpcreatetrainercls(nin, nout, &trainer);
      }
      if (npoints > -1) {
         if (issparse == 0) {
            mlpsetdataset(&trainer, &trainingset, npoints);
         }
         if (issparse == 1) {
            mlpsetsparsedataset(&trainer, &sptrainingset, npoints);
         }
      }
      mlpkfoldcv(&trainer, &net, nneedrest, foldscount, &cvrep);
      if (((((((cvrep.relclserror != 0.0 || cvrep.avgce != 0.0) || cvrep.rmserror != 0.0) || cvrep.avgerror != 0.0) || cvrep.avgrelerror != 0.0) || cvrep.ngrad != 0) || cvrep.nhess != 0) || cvrep.ncholesky != 0) {
         set_error_flag(&result, true, __FILE__, __LINE__, "testmlptrainunit.ap:1527");
         ae_frame_leave();
         return result;
      }
   }
   ae_frame_leave();
   return result;
}

// The  function  tests  functions  for  training  ensembles:  MLPEBaggingLM,
// MLPEBaggingLBFGS.
static bool testmlptrainunit_testmlptrainens() {
   ae_frame _frame_block;
   ae_int_t info;
   ae_int_t nin;
   ae_int_t nout;
   ae_int_t npoints;
   ae_int_t nhid;
   ae_int_t algtype;
   ae_int_t tasktype;
   ae_int_t pass;
   double e;
   ae_int_t nless;
   ae_int_t nall;
   ae_int_t nclasses;
   ae_int_t i;
   ae_int_t j;
   ae_int_t k;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(mlpensemble, ensemble);
   NewObj(mlpreport, rep);
   NewObj(mlpcvreport, oobrep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(hf, 0, 0, DT_REAL);
   NewObj(hqrndstate, rs);
   result = false;
   hqrndrandomize(&rs);
// network training must reduce error
// test on random regression task
   nin = 3;
   nout = 2;
   nhid = 5;
   npoints = 100;
   nless = 0;
   nall = 0;
   for (pass = 1; pass <= 10; pass++) {
      for (algtype = 0; algtype <= 1; algtype++) {
         for (tasktype = 0; tasktype <= 1; tasktype++) {
            if (tasktype == 0) {
               ae_matrix_set_length(&hf, nout, nin + 1);
               for (i = 0; i < nout; i++) {
                  for (j = 0; j <= nin; j++) {
                     hf.xyR[i][j] = hqrndnormal(&rs);
                  }
               }
               ae_matrix_set_length(&xy, npoints, nin + nout);
               for (i = 0; i < npoints; i++) {
                  for (j = 0; j < nin; j++) {
                     xy.xyR[i][j] = hqrndnormal(&rs);
                  }
                  for (j = 0; j < nout; j++) {
                     xy.xyR[i][nin + j] = hqrndnormal(&rs) + rdotrr(nin, &hf, j, &xy, i);
                  }
               }
               mlpecreate1(nin, nhid, nout, 1 + randominteger(3), &ensemble);
            } else {
               ae_matrix_set_length(&xy, npoints, nin + 1);
               nclasses = 2 + randominteger(2);
               ae_assert(nclasses <= nin, "MLPTrain: bug in test");
               for (i = 0; i < npoints; i++) {
                  for (j = 0; j < nin; j++) {
                     xy.xyR[i][j] = hqrndnormal(&rs);
                  }
                  k = 0;
                  for (j = 0; j < nclasses; j++) {
                     if (xy.xyR[i][j] > xy.xyR[i][k]) {
                        k = j;
                     }
                  }
                  if (hqrndnormal(&rs) > 0.0) {
                     xy.xyR[i][nin] = (double)k;
                  } else {
                     xy.xyR[i][nin] = (double)hqrnduniformi(&rs, nclasses);
                  }
               }
               mlpecreatec1(nin, nhid, nclasses, 1 + randominteger(3), &ensemble);
            }
            e = mlpermserror(&ensemble, &xy, npoints);
            if (algtype == 0) {
               mlpebagginglm(&ensemble, &xy, npoints, 0.001, 1, &info, &rep, &oobrep);
            } else {
               mlpebagginglbfgs(&ensemble, &xy, npoints, 0.001, 1, 0.01, 0, &info, &rep, &oobrep);
            }
            if (info < 0) {
               result = true;
            } else {
               if (mlpermserror(&ensemble, &xy, npoints) < e) {
                  nless++;
               }
            }
            nall++;
         }
      }
   }
   set_error_flag(&result, (double)(nall - nless) > 0.3 * nall, __FILE__, __LINE__, "testmlptrainunit.ap:1636");
   ae_frame_leave();
   return result;
}

// Testing  for  functions  MLPETrainES and MLPTrainEnsembleES  on regression
// problems. Returns TRUE for errors, FALSE for success.
static bool testmlptrainunit_testmlptrainensregr() {
   ae_frame _frame_block;
   ae_int_t info;
   ae_int_t nin;
   ae_int_t nout;
   ae_int_t nneurons;
   double decay;
   double wstep;
   ae_int_t maxits;
   ae_int_t nneedrest;
   ae_int_t enssize;
   double mnval;
   double mxval;
   ae_int_t ntrain;
   ae_int_t ntest;
   double avgerr;
   ae_int_t issparse;
   ae_int_t withtrainer;
   double eps;
   ae_int_t xp;
   ae_int_t i;
   ae_int_t j;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(mlptrainer, trainer);
   NewObj(mlpensemble, netens);
   NewObj(mlpreport, rep);
   NewObj(modelerrors, repx);
   NewObj(sparsematrix, xytrainsp);
   NewMatrix(xytrain, 0, 0, DT_REAL);
   NewMatrix(xytest, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   result = false;
// This test checks ability to train ensemble on simple regression
// problem "f(x0,x1,x2,...) = x0 + x1 + x2 + ...".
   eps = 5.0E-2;
   mnval = -1.0;
   mxval = 1.0;
   ntrain = 40;
   ntest = 20;
   decay = 1.0E-3;
   wstep = 1.0E-3;
   maxits = 20;
   nneedrest = 1;
   nneurons = 20;
   nout = 1;
   enssize = 100;
   for (xp = 1; xp <= 2; xp++) {
      nin = randominteger(3) + 1;
      vectorsetlengthatleast(&x, nin);
      mlpcreatetrainer(nin, nout, &trainer);
      mlpsetdecay(&trainer, decay);
      mlpsetcond(&trainer, wstep, maxits);
      matrixsetlengthatleast(&xytrain, ntrain, nin + nout);
      matrixsetlengthatleast(&xytest, ntest, nin + nout);
      withtrainer = randominteger(2);
      issparse = 0;
      if (withtrainer == 0) {
         issparse = 0;
      }
      if (withtrainer == 1) {
         issparse = randominteger(2);
      }
   // Training set
      for (i = 0; i < ntrain; i++) {
         for (j = 0; j < nin; j++) {
            xytrain.xyR[i][j] = (mxval - mnval) * randomreal() + mnval;
         }
         xytrain.xyR[i][nin] = 0.0;
         for (j = 0; j < nin; j++) {
            xytrain.xyR[i][nin] += xytrain.xyR[i][j];
         }
      }
      if (withtrainer == 1) {
      // Dense matrix
         if (issparse == 0) {
            mlpsetdataset(&trainer, &xytrain, ntrain);
         }
      // Sparse matrix
         if (issparse == 1) {
            sparsecreate(ntrain, nin + nout, ntrain * (nin + nout), &xytrainsp);
         // Just copy dense matrix to sparse matrix(using SparseGet() is too expensive).
            for (i = 0; i < ntrain; i++) {
               for (j = 0; j < nin + nout; j++) {
                  sparseset(&xytrainsp, i, j, xytrain.xyR[i][j]);
               }
            }
            sparseconverttocrs(&xytrainsp);
            mlpsetsparsedataset(&trainer, &xytrainsp, ntrain);
         }
      }
   // Test set
      for (i = 0; i < ntest; i++) {
         for (j = 0; j < nin; j++) {
            xytest.xyR[i][j] = (mxval - mnval) * randomreal() + mnval;
         }
         xytest.xyR[i][nin] = 0.0;
         for (j = 0; j < nin; j++) {
            xytest.xyR[i][nin] += xytest.xyR[i][j];
         }
      }
   // Create ensemble
      mlpecreate1(nin, nneurons, nout, enssize, &netens);
   // Train ensembles:
   //  * without trainer;
      if (withtrainer == 0) {
         mlpetraines(&netens, &xytrain, ntrain, decay, nneedrest, &info, &rep);
      }
   //  * with trainer.
      if (withtrainer == 1) {
         mlptrainensemblees(&trainer, &netens, nneedrest, &rep);
      }
   // Test that Rep contains correct error values
      mlpeallerrorsx(&netens, &xytrain, &xytrainsp, ntrain, 0, &netens.network.dummyidx, 0, ntrain, 0, &netens.network.buf, &repx);
      seterrorflagdiff(&result, rep.relclserror, repx.relclserror, 1.0E-4, 1.0E-2);
      seterrorflagdiff(&result, rep.avgce, repx.avgce, 1.0E-4, 1.0E-2);
      seterrorflagdiff(&result, rep.rmserror, repx.rmserror, 1.0E-4, 1.0E-2);
      seterrorflagdiff(&result, rep.avgerror, repx.avgerror, 1.0E-4, 1.0E-2);
      seterrorflagdiff(&result, rep.avgrelerror, repx.avgrelerror, 1.0E-4, 1.0E-2);
   // Test that network fits data well. Calculate average error:
   //  * on training dataset;
   //  * on test dataset. (here we reduce the accuracy
   //    requirements - average error is compared with 2*Eps).
      avgerr = 0.0;
      for (i = 0; i < ntrain; i++) {
         if (issparse == 0) {
            ae_v_move(x.xR, 1, xytrain.xyR[i], 1, nin);
         }
         if (issparse == 1) {
            sparsegetrow(&xytrainsp, i, &x);
         }
         mlpeprocess(&netens, &x, &y);
         avgerr += fabs(y.xR[0] - xytrain.xyR[i][nin]);
      }
      avgerr /= ntrain;
      set_error_flag(&result, avgerr > eps, __FILE__, __LINE__, "testmlptrainunit.ap:1817");
      avgerr = 0.0;
      for (i = 0; i < ntest; i++) {
         ae_v_move(x.xR, 1, xytest.xyR[i], 1, nin);
         mlpeprocess(&netens, &x, &y);
         avgerr += fabs(y.xR[0] - xytest.xyR[i][nin]);
      }
      avgerr /= ntest;
      set_error_flag(&result, avgerr > 2 * eps, __FILE__, __LINE__, "testmlptrainunit.ap:1826");
   }
// Catch bug in implementation of MLPTrainEnsembleX:
// test ensemble training on empty dataset.
//
// Unfixed version should crash with violation of array
// bounds (at least in C#).
   nin = 2;
   nout = 2;
   nneurons = 3;
   enssize = 3;
   nneedrest = 2;
   wstep = 0.001;
   maxits = 2;
   mlpcreatetrainer(nin, nout, &trainer);
   mlpsetcond(&trainer, wstep, maxits);
   mlpecreate1(nin, nneurons, nout, enssize, &netens);
   mlptrainensemblees(&trainer, &netens, nneedrest, &rep);
   ae_frame_leave();
   return result;
}

// Testing for functions MLPETrainES and MLPTrainEnsembleES on classification
// problems.
static bool testmlptrainunit_testmlptrainenscls() {
   ae_frame _frame_block;
   ae_int_t info;
   ae_int_t nin;
   ae_int_t nout;
   double decay;
   double wstep;
   ae_int_t maxits;
   ae_int_t nneedrest;
   ae_int_t enssize;
   ae_int_t val;
   ae_int_t ntrain;
   ae_int_t ntest;
   double avgerr;
   double eps;
   double delta;
   ae_int_t issparse;
   ae_int_t withtrainer;
   ae_int_t xp;
   ae_int_t nxp;
   ae_int_t i;
   ae_int_t j;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(mlptrainer, trainer);
   NewObj(mlpensemble, netens);
   NewObj(mlpreport, rep);
   NewObj(sparsematrix, xytrainsp);
   NewMatrix(xytrain, 0, 0, DT_REAL);
   NewMatrix(xytest, 0, 0, DT_REAL);
   NewVector(x, 0, DT_REAL);
   NewVector(y, 0, DT_REAL);
   eps = 5.0E-2;
   delta = 0.1;
   ntrain = 90;
   ntest = 90;
   nin = 3;
   nout = 3;
   vectorsetlengthatleast(&x, nin);
   matrixsetlengthatleast(&xytrain, ntrain, nin + 1);
   matrixsetlengthatleast(&xytest, ntest, nin + 1);
   decay = 1.0E-3;
   wstep = 1.0E-3;
   maxits = 100;
   nneedrest = 1;
   mlpcreatetrainercls(nin, nout, &trainer);
   mlpsetdecay(&trainer, decay);
   mlpsetcond(&trainer, wstep, maxits);
   nxp = 5;
   for (xp = 1; xp <= nxp; xp++) {
      enssize = iround(pow(10.0, (double)(randominteger(2) + 1)));
      withtrainer = randominteger(2);
      issparse = 0;
      if (withtrainer == 0) {
         issparse = 0;
      }
      if (withtrainer == 1) {
         issparse = randominteger(2);
      }
      for (i = 0; i < ntrain; i++) {
         val = i % nin;
         for (j = 0; j < nin; j++) {
            xytrain.xyR[i][j] = delta * (randomreal() - 1);
         }
         xytrain.xyR[i][val]++;
         xytrain.xyR[i][nin] = (double)val;
      }
   // Set dense dataset in trainer
      if (issparse == 0) {
         mlpsetdataset(&trainer, &xytrain, ntrain);
      }
   //  * Sparse dataset(create it with using dense dataset).
      if (issparse == 1) {
         sparsecreate(ntrain, nin + 1, ntrain * (nin + 1), &xytrainsp);
         for (i = 0; i < ntrain; i++) {
            for (j = 0; j < nin; j++) {
               sparseset(&xytrainsp, i, j, xytrain.xyR[i][j]);
            }
            sparseset(&xytrainsp, i, nin, xytrain.xyR[i][nin]);
         }
         sparseconverttocrs(&xytrainsp);
      // Set sparse dataset in trainer
         mlpsetsparsedataset(&trainer, &xytrainsp, ntrain);
      }
   // Create test set
      for (i = 0; i < ntest; i++) {
         val = randominteger(nin);
         for (j = 0; j < nin; j++) {
            xytest.xyR[i][j] = delta * (randomreal() - 1);
         }
         xytest.xyR[i][val]++;
         xytest.xyR[i][nin] = (double)val;
      }
   // Create ensemble
      mlpecreatec0(nin, nout, enssize, &netens);
   // Train ensembles:
   //  * without trainer;
      if (withtrainer == 0) {
         mlpetraines(&netens, &xytrain, ntrain, decay, nneedrest, &info, &rep);
      }
   //  * with trainer.
      if (withtrainer == 1) {
         mlptrainensemblees(&trainer, &netens, nneedrest, &rep);
      }
   // Calculate average error:
   //  * on training dataset;
      avgerr = 0.0;
      for (i = 0; i < ntrain; i++) {
         if (issparse == 0) {
            ae_v_move(x.xR, 1, xytrain.xyR[i], 1, nin);
         }
         if (issparse == 1) {
            sparsegetrow(&xytrainsp, i, &x);
         }
         mlpeprocess(&netens, &x, &y);
         for (j = 0; j < nout; j++) {
            if ((double)j != xytrain.xyR[i][nin]) {
               avgerr += y.xR[j];
            } else {
               avgerr += (1 - y.xR[j]);
            }
         }
      }
      avgerr /= ntrain * nout;
      if (avgerr > eps) {
         result = true;
         ae_frame_leave();
         return result;
      }
   //  * on test dataset.
      avgerr = 0.0;
      for (i = 0; i < ntest; i++) {
         ae_v_move(x.xR, 1, xytest.xyR[i], 1, nin);
         mlpeprocess(&netens, &x, &y);
         for (j = 0; j < nout; j++) {
            if ((double)j != xytest.xyR[i][nin]) {
               avgerr += y.xR[j];
            } else {
               avgerr += (1 - y.xR[j]);
            }
         }
      }
      avgerr /= ntest * nout;
      if (avgerr > eps) {
         result = true;
         ae_frame_leave();
         return result;
      }
   }
   result = false;
   ae_frame_leave();
   return result;
}

bool testmlptrain(bool silent) {
   ae_frame _frame_block;
   bool waserrors;
   ae_int_t info;
   bool trnerrors;
   bool mlpcverrorerr;
   bool mlptrainregrerr;
   bool mlptrainclasserr;
   bool mlprestartserr;
   bool mlpxorregrerr;
   bool mlpxorclserr;
   bool mlptrainenserrors;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(multilayerperceptron, network);
   NewObj(multilayerperceptron, network2);
   NewObj(mlpreport, rep);
   NewObj(mlpcvreport, cvrep);
   NewMatrix(xy, 0, 0, DT_REAL);
   NewMatrix(valxy, 0, 0, DT_REAL);
   waserrors = false;
   trnerrors = false;
   mlpcverrorerr = false;
   mlptrainregrerr = false;
   mlptrainclasserr = false;
   mlprestartserr = false;
   mlpxorregrerr = false;
   mlpxorclserr = false;
   mlptrainenserrors = false;
// Test network training on simple XOR problem
   ae_matrix_set_length(&xy, 3 + 1, 2 + 1);
   xy.xyR[0][0] = -1.0;
   xy.xyR[0][1] = -1.0;
   xy.xyR[0][2] = -1.0;
   xy.xyR[1][0] = 1.0;
   xy.xyR[1][1] = -1.0;
   xy.xyR[1][2] = 1.0;
   xy.xyR[2][0] = -1.0;
   xy.xyR[2][1] = 1.0;
   xy.xyR[2][2] = 1.0;
   xy.xyR[3][0] = 1.0;
   xy.xyR[3][1] = 1.0;
   xy.xyR[3][2] = -1.0;
   mlpcreate1(2, 2, 1, &network);
   mlptrainlm(&network, &xy, 4, 0.0001, 20, &info, &rep);
   trnerrors = trnerrors || mlprmserror(&network, &xy, 4) > 0.1;
// Test early stopping
   trnerrors = trnerrors || testmlptrainunit_testmlptraines();
// Test for function MLPFoldCV()
   mlpcverrorerr = testmlptrainunit_testmlpcverror();
// Test for training functions
   mlptrainregrerr = testmlptrainunit_testmlptrainregr() || testmlptrainunit_testmlpzeroweights();
   mlptrainclasserr = testmlptrainunit_testmlptrainclass();
   mlprestartserr = testmlptrainunit_testmlprestarts();
   mlpxorregrerr = testmlptrainunit_testmlpxorregr();
   mlpxorclserr = testmlptrainunit_testmlpxorcls();
// Training for ensembles
   mlptrainenserrors = (testmlptrainunit_testmlptrainens() || testmlptrainunit_testmlptrainensregr()) || testmlptrainunit_testmlptrainenscls();
// Final report
   waserrors = ((((((trnerrors || mlptrainregrerr) || mlptrainclasserr) || mlprestartserr) || mlpxorregrerr) || mlpxorclserr) || mlpcverrorerr) || mlptrainenserrors;
   if (!silent) {
      printf("MLP TEST\n");
      printf("CROSS-VALIDATION ERRORS:                 ");
      if (!mlpcverrorerr) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("TRAINING:                                ");
      if (!trnerrors) {
         printf("OK\n");
      } else {
         printf("FAILED\n");
      }
      printf("TRAIN -LM -LBFGS FOR REGRESSION:         ");
      if (mlptrainregrerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("TRAIN -LM -LBFGS FOR CLASSIFIER:         ");
      if (mlptrainclasserr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("PARAMETER RESTARTS IN TRAIN -LBFGS:      ");
      if (mlprestartserr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("TRAINIG WITH TRAINER FOR REGRESSION:     ");
      if (mlpxorregrerr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("TRAINIG WITH TRAINER FOR CLASSIFIER:     ");
      if (mlpxorclserr) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      printf("TRAINING ENSEMBLES:                      ");
      if (mlptrainenserrors) {
         printf("FAILED\n");
      } else {
         printf("OK\n");
      }
      if (waserrors) {
         printf("TEST SUMMARY: FAILED\n");
      } else {
         printf("TEST SUMMARY: PASSED\n");
      }
      printf("\n\n");
   }
   result = !waserrors;
   ae_frame_leave();
   return result;
}

// === alglibbasics testing unit ===
struct rec1 {
   bool bfield;
   double rfield;
   ae_int_t ifield;
   complex cfield;
   ae_vector b1field;
   ae_vector r1field;
   ae_vector i1field;
   ae_vector c1field;
   ae_matrix b2field;
   ae_matrix r2field;
   ae_matrix i2field;
   ae_matrix c2field;
};

static void rec1_init(void *_p, bool make_automatic) {
   rec1 *p = (rec1 *)_p;
   ae_vector_init(&p->b1field, 0, DT_BOOL, make_automatic);
   ae_vector_init(&p->r1field, 0, DT_REAL, make_automatic);
   ae_vector_init(&p->i1field, 0, DT_INT, make_automatic);
   ae_vector_init(&p->c1field, 0, DT_COMPLEX, make_automatic);
   ae_matrix_init(&p->b2field, 0, 0, DT_BOOL, make_automatic);
   ae_matrix_init(&p->r2field, 0, 0, DT_REAL, make_automatic);
   ae_matrix_init(&p->i2field, 0, 0, DT_INT, make_automatic);
   ae_matrix_init(&p->c2field, 0, 0, DT_COMPLEX, make_automatic);
}

static void rec1_copy(void *_dst, void *_src, bool make_automatic) {
   rec1 *dst = (rec1 *)_dst;
   rec1 *src = (rec1 *)_src;
   dst->bfield = src->bfield;
   dst->rfield = src->rfield;
   dst->ifield = src->ifield;
   dst->cfield = src->cfield;
   ae_vector_copy(&dst->b1field, &src->b1field, make_automatic);
   ae_vector_copy(&dst->r1field, &src->r1field, make_automatic);
   ae_vector_copy(&dst->i1field, &src->i1field, make_automatic);
   ae_vector_copy(&dst->c1field, &src->c1field, make_automatic);
   ae_matrix_copy(&dst->b2field, &src->b2field, make_automatic);
   ae_matrix_copy(&dst->r2field, &src->r2field, make_automatic);
   ae_matrix_copy(&dst->i2field, &src->i2field, make_automatic);
   ae_matrix_copy(&dst->c2field, &src->c2field, make_automatic);
}

static void rec1_free(void *_p, bool make_automatic) {
   rec1 *p = (rec1 *)_p;
   ae_vector_free(&p->b1field, make_automatic);
   ae_vector_free(&p->r1field, make_automatic);
   ae_vector_free(&p->i1field, make_automatic);
   ae_vector_free(&p->c1field, make_automatic);
   ae_matrix_free(&p->b2field, make_automatic);
   ae_matrix_free(&p->r2field, make_automatic);
   ae_matrix_free(&p->i2field, make_automatic);
   ae_matrix_free(&p->c2field, make_automatic);
}

struct rec4serialization {
   ae_vector b;
   ae_vector i;
   ae_vector r;
};

static void rec4serialization_init(void *_p, bool make_automatic) {
   rec4serialization *p = (rec4serialization *)_p;
   ae_vector_init(&p->b, 0, DT_BOOL, make_automatic);
   ae_vector_init(&p->i, 0, DT_INT, make_automatic);
   ae_vector_init(&p->r, 0, DT_REAL, make_automatic);
}

static void rec4serialization_copy(void *_dst, void *_src, bool make_automatic) {
   rec4serialization *dst = (rec4serialization *)_dst;
   rec4serialization *src = (rec4serialization *)_src;
   ae_vector_copy(&dst->b, &src->b, make_automatic);
   ae_vector_copy(&dst->i, &src->i, make_automatic);
   ae_vector_copy(&dst->r, &src->r, make_automatic);
}

static void rec4serialization_free(void *_p, bool make_automatic) {
   rec4serialization *p = (rec4serialization *)_p;
   ae_vector_free(&p->b, make_automatic);
   ae_vector_free(&p->i, make_automatic);
   ae_vector_free(&p->r, make_automatic);
}

static void rec4serializationalloc(ae_serializer *s, rec4serialization *v) {
   ae_int_t i;
// boolean fields
   ae_serializer_alloc_entry(s);
   for (i = 0; i < v->b.cnt; i++) {
      ae_serializer_alloc_entry(s);
   }
// integer fields
   ae_serializer_alloc_entry(s);
   for (i = 0; i < v->i.cnt; i++) {
      ae_serializer_alloc_entry(s);
   }
// real fields
   ae_serializer_alloc_entry(s);
   for (i = 0; i < v->r.cnt; i++) {
      ae_serializer_alloc_entry(s);
   }
}

static void rec4serializationserialize(ae_serializer *s, rec4serialization *v) {
   ae_int_t i;
// boolean fields
   ae_serializer_serialize_int(s, v->b.cnt);
   for (i = 0; i < v->b.cnt; i++) {
      ae_serializer_serialize_bool(s, v->b.xB[i]);
   }
// integer fields
   ae_serializer_serialize_int(s, v->i.cnt);
   for (i = 0; i < v->i.cnt; i++) {
      ae_serializer_serialize_int(s, v->i.xZ[i]);
   }
// real fields
   ae_serializer_serialize_int(s, v->r.cnt);
   for (i = 0; i < v->r.cnt; i++) {
      ae_serializer_serialize_double(s, v->r.xR[i]);
   }
}

static void rec4serializationunserialize(ae_serializer *s, rec4serialization *v) {
   ae_int_t i;
   ae_int_t k;
   SetObj(rec4serialization, v);
// boolean fields
   k = ae_serializer_unserialize_int(s);
   if (k > 0) {
      ae_vector_set_length(&v->b, k);
      for (i = 0; i < k; i++) {
         v->b.xB[i] = ae_serializer_unserialize_bool(s);
      }
   }
// integer fields
   k = ae_serializer_unserialize_int(s);
   if (k > 0) {
      ae_vector_set_length(&v->i, k);
      for (i = 0; i < k; i++) {
         v->i.xZ[i] = ae_serializer_unserialize_int(s);
      }
   }
// real fields
   k = ae_serializer_unserialize_int(s);
   if (k > 0) {
      ae_vector_set_length(&v->r, k);
      for (i = 0; i < k; i++) {
         v->r.xR[i] = ae_serializer_unserialize_double(s);
      }
   }
}

struct poolrec1 {
   complex cval;
   double rval;
   ae_int_t ival;
   bool bval;
   ae_vector i1val;
};

static void poolrec1_init(void *_p, bool make_automatic) {
   poolrec1 *p = (poolrec1 *)_p;
   ae_vector_init(&p->i1val, 0, DT_INT, make_automatic);
}

static void poolrec1_copy(void *_dst, void *_src, bool make_automatic) {
   poolrec1 *dst = (poolrec1 *)_dst;
   poolrec1 *src = (poolrec1 *)_src;
   dst->cval = src->cval;
   dst->rval = src->rval;
   dst->ival = src->ival;
   dst->bval = src->bval;
   ae_vector_copy(&dst->i1val, &src->i1val, make_automatic);
}

static void poolrec1_free(void *_p, bool make_automatic) {
   poolrec1 *p = (poolrec1 *)_p;
   ae_vector_free(&p->i1val, make_automatic);
}

struct poolrec2 {
   bool bval;
   poolrec1 recval;
   ae_shared_pool pool;
};

static void poolrec2_init(void *_p, bool make_automatic) {
   poolrec2 *p = (poolrec2 *)_p;
   poolrec1_init(&p->recval, make_automatic);
   ae_shared_pool_init(&p->pool, make_automatic);
}

static void poolrec2_copy(void *_dst, void *_src, bool make_automatic) {
   poolrec2 *dst = (poolrec2 *)_dst;
   poolrec2 *src = (poolrec2 *)_src;
   dst->bval = src->bval;
   poolrec1_copy(&dst->recval, &src->recval, make_automatic);
   ae_shared_pool_copy(&dst->pool, &src->pool, make_automatic);
}

static void poolrec2_free(void *_p, bool make_automatic) {
   poolrec2 *p = (poolrec2 *)_p;
   poolrec1_free(&p->recval, make_automatic);
   ae_shared_pool_free(&p->pool, make_automatic);
}

struct poolsummand {
   ae_int_t val;
};

static void poolsummand_init(void *_p, bool make_automatic) {
}

static void poolsummand_copy(void *_dst, void *_src, bool make_automatic) {
   poolsummand *dst = (poolsummand *)_dst;
   poolsummand *src = (poolsummand *)_src;
   dst->val = src->val;
}

static void poolsummand_free(void *_p, bool make_automatic) {
}

// Tests for pool functions
static void testalglibbasicsunit_createpoolandrecords(poolrec2 *seedrec2, poolrec2 *seedrec2copy, ae_shared_pool *pool) {
   SetObj(poolrec2, seedrec2);
   SetObj(poolrec2, seedrec2copy);
   SetObj(ae_shared_pool, pool);
   seedrec2->bval = randombool();
   seedrec2->recval.bval = randombool();
   seedrec2->recval.ival = randominteger(10);
   seedrec2->recval.rval = randomreal();
   seedrec2->recval.cval = complex_from_d(randomreal(), randomreal());
   ae_vector_set_length(&seedrec2->recval.i1val, 3);
   seedrec2->recval.i1val.xZ[0] = randominteger(10);
   seedrec2->recval.i1val.xZ[1] = randominteger(10);
   seedrec2->recval.i1val.xZ[2] = randominteger(10);
   seedrec2copy->bval = seedrec2->bval;
   seedrec2copy->recval.bval = seedrec2->recval.bval;
   seedrec2copy->recval.ival = seedrec2->recval.ival;
   seedrec2copy->recval.rval = seedrec2->recval.rval;
   seedrec2copy->recval.cval = seedrec2->recval.cval;
   ae_vector_set_length(&seedrec2copy->recval.i1val, 3);
   seedrec2copy->recval.i1val.xZ[0] = seedrec2->recval.i1val.xZ[0];
   seedrec2copy->recval.i1val.xZ[1] = seedrec2->recval.i1val.xZ[1];
   seedrec2copy->recval.i1val.xZ[2] = seedrec2->recval.i1val.xZ[2];
   ae_shared_pool_set_seed(pool, seedrec2, sizeof(*seedrec2), poolrec2_init, poolrec2_copy, poolrec2_free);
}

static bool testalglibbasicsunit_sharedpoolerrors() {
   ae_frame _frame_block;
   ae_int_t val100cnt;
   ae_int_t val101cnt;
   ae_int_t val102cnt;
   ae_int_t tmpval;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(poolrec1, seedrec1);
   NewObj(poolrec2, seedrec2);
   NewObj(poolrec2, seedrec2copy);
   NewObj(ae_shared_pool, pool);
   NewObj(ae_shared_pool, pool2);
   RefObj(poolrec2, prec2);
   RefObj(poolrec2, p0);
   RefObj(poolrec2, p1);
   RefObj(poolrec2, p2);
   RefObj(poolrec1, q0);
   RefObj(poolrec1, q1);
   RefObj(ae_shared_pool, ppool0);
   RefObj(ae_shared_pool, ppool1);
   result = true;
// Test 1: test that:
// a) smart pointer is null by default
// b) "conventional local" is valid by default
// b) unitinitialized shared pool is "not initialized"
   if (prec2 != NULL) {
      ae_frame_leave();
      return result;
   }
   if (!(&seedrec1 != NULL)) {
      ae_frame_leave();
      return result;
   }
   if (ae_shared_pool_is_initialized(&pool)) {
      ae_frame_leave();
      return result;
   }
// Test 2: basic copying of complex structures
// * check that pool is recognized as "initialized"
// * change original seed record,
// * retrieve value from pool,
// * check that it is valid
// * and it is unchanged.
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   if (!ae_shared_pool_is_initialized(&pool)) {
      ae_frame_leave();
      return result;
   }
   seedrec2.bval = !seedrec2.bval;
   seedrec2.recval.i1val.xZ[0]++;
   ae_shared_pool_retrieve(&pool, &_prec2);
   if (!(prec2 != NULL)) {
      ae_frame_leave();
      return result;
   }
   if (seedrec2copy.bval != prec2->bval) {
      ae_frame_leave();
      return result;
   }
   if (seedrec2copy.recval.i1val.xZ[0] != prec2->recval.i1val.xZ[0]) {
      ae_frame_leave();
      return result;
   }
// Test 3: unrecycled values are lost
// * retrieve value from pool,
// * change it,
// * retrieve one more time,
// * check that it is unchanged.
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   ae_shared_pool_retrieve(&pool, &_prec2);
   prec2->recval.ival++;
   ae_shared_pool_retrieve(&pool, &_prec2);
   if (prec2->recval.ival != seedrec2copy.recval.ival) {
      ae_frame_leave();
      return result;
   }
// Test 4: recycled values are reused, PoolClearRecycled() removes recycled values
// * retrieve value from pool,
// * change it,
// * recycle,
// * check that recycled pointer is null
// * retrieve one more time,
// * check that modified value was returned,
// * recycle,
// * clear pool,
// * retrieve one more time,
// * check that unmodified value was returned,
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   ae_shared_pool_retrieve(&pool, &_prec2);
   prec2->recval.ival++;
   ae_shared_pool_recycle(&pool, &_prec2);
   if (prec2 != NULL) {
      ae_frame_leave();
      return result;
   }
   ae_shared_pool_retrieve(&pool, &_prec2);
   if (!(prec2 != NULL)) {
      ae_frame_leave();
      return result;
   }
   if (prec2->recval.ival != seedrec2copy.recval.ival + 1) {
      ae_frame_leave();
      return result;
   }
   ae_shared_pool_recycle(&pool, &_prec2);
   ae_shared_pool_clear_recycled(&pool, true);
   ae_shared_pool_retrieve(&pool, &_prec2);
   if (!(prec2 != NULL)) {
      ae_frame_leave();
      return result;
   }
   if (prec2->recval.ival != seedrec2copy.recval.ival) {
      ae_frame_leave();
      return result;
   }
// Test 5: basic enumeration
// * retrieve 3 values from pool
// * fill RecVal.iVal by 100, 101, 102
// * recycle values
// * enumerate, check that each iVal occurs only once during enumeration
// * repeat enumeration to make sure that it can be repeated
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   ae_shared_pool_retrieve(&pool, &_p0);
   ae_shared_pool_retrieve(&pool, &_p1);
   ae_shared_pool_retrieve(&pool, &_p2);
   p0->recval.ival = 100;
   p1->recval.ival = 101;
   p2->recval.ival = 102;
   ae_shared_pool_recycle(&pool, &_p1);
   ae_shared_pool_recycle(&pool, &_p2);
   ae_shared_pool_recycle(&pool, &_p0);
   val100cnt = 0;
   val101cnt = 0;
   val102cnt = 0;
   ae_shared_pool_first_recycled(&pool, &_prec2);
   while (prec2 != NULL) {
      if (prec2->recval.ival == 100) {
         val100cnt++;
      }
      if (prec2->recval.ival == 101) {
         val101cnt++;
      }
      if (prec2->recval.ival == 102) {
         val102cnt++;
      }
      ae_shared_pool_next_recycled(&pool, &_prec2);
   }
   if ((val100cnt != 1 || val101cnt != 1) || val102cnt != 1) {
      ae_frame_leave();
      return result;
   }
   val100cnt = 0;
   val101cnt = 0;
   val102cnt = 0;
   ae_shared_pool_first_recycled(&pool, &_prec2);
   while (prec2 != NULL) {
      if (prec2->recval.ival == 100) {
         val100cnt++;
      }
      if (prec2->recval.ival == 101) {
         val101cnt++;
      }
      if (prec2->recval.ival == 102) {
         val102cnt++;
      }
      ae_shared_pool_next_recycled(&pool, &_prec2);
   }
   if ((val100cnt != 1 || val101cnt != 1) || val102cnt != 1) {
      ae_frame_leave();
      return result;
   }
// Test 6: pool itself can be pooled
// * pool can be seeded with another pool
// * smart pointers to pool are correctly handled
// * pool correctly returns different references on "retrieve":
//   * we retrieve, modify and recycle back to PPool0
//   * we retrieve from PPool1 - unmodified value is returned
//   * we retrievefrom PPool0  - modified value is returned
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   ae_shared_pool_set_seed(&pool2, &pool, sizeof(pool), ae_shared_pool_init, ae_shared_pool_copy, ae_shared_pool_free);
   if (ppool0 != NULL || ppool1 != NULL) {
      ae_frame_leave();
      return result;
   }
   ae_shared_pool_retrieve(&pool2, &_ppool0);
   ae_shared_pool_retrieve(&pool2, &_ppool1);
   if (!(ppool0 != NULL && ppool1 != NULL)) {
      ae_frame_leave();
      return result;
   }
   ae_shared_pool_retrieve(ppool0, &_p0);
   p0->recval.ival++;
   tmpval = p0->recval.ival;
   ae_shared_pool_recycle(ppool0, &_p0);
   ae_shared_pool_retrieve(ppool1, &_p1);
   if (p1->recval.ival == tmpval) {
      ae_frame_leave();
      return result;
   }
   ae_shared_pool_recycle(ppool1, &_p1);
   ae_shared_pool_retrieve(ppool0, &_p0);
   if (p0->recval.ival != tmpval) {
      ae_frame_leave();
      return result;
   }
// Test 7: pools which are fields of records are correctly handled
// * pool can be seeded with record which has initialized pool as its field
// * when record is retrieved from pool, its fields are correctly copied (including
//   fields which are pools)
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   tmpval = 99;
   seedrec1.ival = tmpval;
   ae_shared_pool_set_seed(&seedrec2.pool, &seedrec1, sizeof(seedrec1), poolrec1_init, poolrec1_copy, poolrec1_free);
   ae_shared_pool_set_seed(&pool, &seedrec2, sizeof(seedrec2), poolrec2_init, poolrec2_copy, poolrec2_free);
   ae_shared_pool_retrieve(&pool, &_p0);
   ae_shared_pool_retrieve(&p0->pool, &_q0);
   q0->ival = tmpval - 1;
   ae_shared_pool_recycle(&p0->pool, &_q0);
   ae_shared_pool_retrieve(&pool, &_p1);
   ae_shared_pool_retrieve(&p1->pool, &_q1);
   if (q1->ival != tmpval) {
      ae_frame_leave();
      return result;
   }
   ae_shared_pool_recycle(&p1->pool, &_q1);
   ae_shared_pool_retrieve(&p0->pool, &_q0);
   if (q0->ival != tmpval - 1) {
      ae_frame_leave();
      return result;
   }
// Test 8: after call to PoolReset(), call to PoolFirstRecycled() returns null references
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   ae_shared_pool_retrieve(&pool, &_p0);
   ae_shared_pool_retrieve(&pool, &_p1);
   ae_shared_pool_retrieve(&pool, &_p2);
   ae_shared_pool_recycle(&pool, &_p1);
   ae_shared_pool_recycle(&pool, &_p2);
   ae_shared_pool_recycle(&pool, &_p0);
   ae_shared_pool_first_recycled(&pool, &_p0);
   if (!(p0 != NULL)) {
      ae_frame_leave();
      return result;
   }
   ae_shared_pool_next_recycled(&pool, &_p0);
   if (!(p0 != NULL)) {
      ae_frame_leave();
      return result;
   }
   ae_shared_pool_next_recycled(&pool, &_p0);
   if (!(p0 != NULL)) {
      ae_frame_leave();
      return result;
   }
   ae_shared_pool_next_recycled(&pool, &_p0);
   if (p0 != NULL) {
      ae_frame_leave();
      return result;
   }
   ae_shared_pool_reset(&pool);
   ae_shared_pool_first_recycled(&pool, &_p0);
   if (p0 != NULL) {
      ae_frame_leave();
      return result;
   }
   ae_shared_pool_next_recycled(&pool, &_p0);
   if (p0 != NULL) {
      ae_frame_leave();
      return result;
   }
   ae_shared_pool_next_recycled(&pool, &_p0);
   if (p0 != NULL) {
      ae_frame_leave();
      return result;
   }
   ae_shared_pool_next_recycled(&pool, &_p0);
   if (p0 != NULL) {
      ae_frame_leave();
      return result;
   }
// Test 9: invalid pointer is recognized as non-null (we do not reference it, just test)
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   ae_shared_pool_retrieve(&pool, &_p0);
   ae_shared_pool_retrieve(&pool, &_p1);
   ae_shared_pool_retrieve(&pool, &_p2);
   ae_shared_pool_recycle(&pool, &_p1);
   ae_shared_pool_recycle(&pool, &_p2);
   ae_shared_pool_recycle(&pool, &_p0);
   ae_shared_pool_first_recycled(&pool, &_p0);
   if (!(p0 != NULL)) {
      ae_frame_leave();
      return result;
   }
   ae_shared_pool_clear_recycled(&pool, true);
   if (!(p0 != NULL)) {
      ae_frame_leave();
      return result;
   }
// Test 9: non-null pointer is nulled by calling SetNull()
   testalglibbasicsunit_createpoolandrecords(&seedrec2, &seedrec2copy, &pool);
   ae_shared_pool_retrieve(&pool, &_p0);
   if (!(p0 != NULL)) {
      ae_frame_leave();
      return result;
   }
   ae_smart_ptr_assign(&_p0, NULL, false, false, NULL);
   if (p0 != NULL) {
      ae_frame_leave();
      return result;
   }
   result = false;
   ae_frame_leave();
   return result;
}

static bool testalglibbasicsunit_testsharedpool(bool silent) {
   bool result;
   result = !testalglibbasicsunit_sharedpoolerrors();
   if (!silent) {
      if (result) {
         printf("SHARED POOL:                             OK\n");
      } else {
         printf("SHARED POOL:                             FAILED\n");
      }
   }
   return result;
}

// This function merges sorted A[Idx0,Idx1) and A[Idx1,Idx2) into sorted array
// A[Idx0,Idx2) using corresponding elements of Buf.
static void testalglibbasicsunit_mergesortedarrays(ZVector *a, ZVector *buf, ae_int_t idx0, ae_int_t idx1, ae_int_t idx2) {
   ae_int_t srcleft;
   ae_int_t srcright;
   ae_int_t dst;
   srcleft = idx0;
   srcright = idx1;
   dst = idx0;
   while (true) {
      if (srcleft == idx1 && srcright == idx2) {
         break;
      }
      if (srcleft == idx1) {
         buf->xZ[dst] = a->xZ[srcright];
         srcright++;
         dst++;
         continue;
      }
      if (srcright == idx2) {
         buf->xZ[dst] = a->xZ[srcleft];
         srcleft++;
         dst++;
         continue;
      }
      if (a->xZ[srcleft] < a->xZ[srcright]) {
         buf->xZ[dst] = a->xZ[srcleft];
         srcleft++;
         dst++;
      } else {
         buf->xZ[dst] = a->xZ[srcright];
         srcright++;
         dst++;
      }
   }
   for (dst = idx0; dst < idx2; dst++) {
      a->xZ[dst] = buf->xZ[dst];
   }
}

// Tests for SMP functions
//
// testSort0: sort function
static void testalglibbasicsunit_testsort0func(ZVector *a, ZVector *buf, ae_int_t idx0, ae_int_t idx2) {
   ae_int_t idx1;
   if (idx2 <= idx0 + 1) {
      return;
   }
   idx1 = (idx0 + idx2) / 2;
   testalglibbasicsunit_testsort0func(a, buf, idx0, idx1);
   testalglibbasicsunit_testsort0func(a, buf, idx1, idx2);
   testalglibbasicsunit_mergesortedarrays(a, buf, idx0, idx1, idx2);
}

// testSort0: recursive sorting by splitting array into two subarrays.
// Returns True on success, False on failure.
static bool testalglibbasicsunit_performtestsort0() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t k;
   ae_int_t t;
   ae_int_t n;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(a, 0, DT_INT);
   NewVector(buf, 0, DT_INT);
   n = 100000;
   ae_vector_set_length(&a, n);
   ae_vector_set_length(&buf, n);
   for (i = 0; i < n; i++) {
      a.xZ[i] = i;
   }
   for (i = 0; i < n; i++) {
      k = randominteger(n);
      if (k != i) {
         t = a.xZ[i];
         a.xZ[i] = a.xZ[k];
         a.xZ[k] = t;
      }
   }
   testalglibbasicsunit_testsort0func(&a, &buf, 0, n);
   result = true;
   for (i = 0; i < n; i++) {
      result = result && a.xZ[i] == i;
   }
   ae_frame_leave();
   return result;
}

// TestSort0: sort function
static void testalglibbasicsunit_testsort1func(ZVector *a, ZVector *buf, ae_int_t idx0, ae_int_t idx2, bool usesmp) {
   ae_int_t idxa;
   ae_int_t idxb;
   ae_int_t idxc;
   ae_int_t cnt4;
   if (idx2 <= idx0 + 1) {
      return;
   }
   if (idx2 == idx0 + 2) {
      testalglibbasicsunit_mergesortedarrays(a, buf, idx0, idx0 + 1, idx0 + 2);
      return;
   }
   if (idx2 == idx0 + 3) {
      testalglibbasicsunit_mergesortedarrays(a, buf, idx0 + 0, idx0 + 1, idx0 + 2);
      testalglibbasicsunit_mergesortedarrays(a, buf, idx0 + 0, idx0 + 2, idx0 + 3);
      return;
   }
   if (idx2 == idx0 + 4) {
      testalglibbasicsunit_mergesortedarrays(a, buf, idx0 + 0, idx0 + 1, idx0 + 2);
      testalglibbasicsunit_mergesortedarrays(a, buf, idx0 + 2, idx0 + 3, idx0 + 4);
      testalglibbasicsunit_mergesortedarrays(a, buf, idx0 + 0, idx0 + 2, idx0 + 4);
      return;
   }
   cnt4 = (idx2 - idx0) / 4;
   idxa = idx0 + cnt4;
   idxb = idx0 + 2 * cnt4;
   idxc = idx0 + 3 * cnt4;
   testalglibbasicsunit_testsort1func(a, buf, idx0, idxa, usesmp);
   testalglibbasicsunit_testsort1func(a, buf, idxa, idxb, usesmp);
   testalglibbasicsunit_testsort1func(a, buf, idxb, idxc, usesmp);
   testalglibbasicsunit_testsort1func(a, buf, idxc, idx2, usesmp);
   testalglibbasicsunit_mergesortedarrays(a, buf, idx0, idxa, idxb);
   testalglibbasicsunit_mergesortedarrays(a, buf, idxb, idxc, idx2);
   testalglibbasicsunit_mergesortedarrays(a, buf, idx0, idxb, idx2);
}

// TestSort0: recursive sorting by splitting array into 4 subarrays.
//
// Sorting is performed in three rounds:
// * parallel sorting of randomly permuted array
// * result is randomly shuffled and sequentially sorted
// * result is randomly shuffled (again) and sorted in parallel mode (again)
//
// The idea of such "multitry sort" is that we test ability of  SMP  core  to
// interleave highly parallel parts of code with long sequential parts.
//
// Returns True on success, False on failure.
static bool testalglibbasicsunit_performtestsort1() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t k;
   ae_int_t t;
   ae_int_t n;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(a, 0, DT_INT);
   NewVector(buf, 0, DT_INT);
// Generate array
   n = 100000;
   ae_vector_set_length(&a, n);
   ae_vector_set_length(&buf, n);
   for (i = 0; i < n; i++) {
      a.xZ[i] = i;
   }
// round 0: parallel sorting of randomly permuted array
   for (i = 0; i < n; i++) {
      k = randominteger(n);
      if (k != i) {
         t = a.xZ[i];
         a.xZ[i] = a.xZ[k];
         a.xZ[k] = t;
      }
   }
   testalglibbasicsunit_testsort1func(&a, &buf, 0, n, true);
// round 1: result is randomly shuffled and sequentially sorted
   for (i = 0; i < n; i++) {
      k = randominteger(n);
      if (k != i) {
         t = a.xZ[i];
         a.xZ[i] = a.xZ[k];
         a.xZ[k] = t;
      }
   }
   testalglibbasicsunit_testsort1func(&a, &buf, 0, n, false);
// round 2: result is randomly shuffled (again) and sorted in parallel mode (again)
   for (i = 0; i < n; i++) {
      k = randominteger(n);
      if (k != i) {
         t = a.xZ[i];
         a.xZ[i] = a.xZ[k];
         a.xZ[k] = t;
      }
   }
   testalglibbasicsunit_testsort1func(&a, &buf, 0, n, true);
// Test
   result = true;
   for (i = 0; i < n; i++) {
      result = result && a.xZ[i] == i;
   }
   ae_frame_leave();
   return result;
}

// Tests for SMP functions
//
// testSort2: sort function
static void testalglibbasicsunit_testsort2func(ZVector *a, ZVector *buf, ae_int_t idx0, ae_int_t idx2) {
   ae_int_t idx1;
   if (idx2 <= idx0 + 1) {
      return;
   }
   idx1 = idx0 + 1 + randominteger(idx2 - idx0 - 1);
   testalglibbasicsunit_testsort0func(a, buf, idx0, idx1);
   testalglibbasicsunit_testsort0func(a, buf, idx1, idx2);
   testalglibbasicsunit_mergesortedarrays(a, buf, idx0, idx1, idx2);
}

// testSort2: recursive sorting by splitting array into two subarrays of
// different length (main difference from testsort0).
// Returns True on success, False on failure.
static bool testalglibbasicsunit_performtestsort2() {
   ae_frame _frame_block;
   ae_int_t i;
   ae_int_t k;
   ae_int_t t;
   ae_int_t n;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(a, 0, DT_INT);
   NewVector(buf, 0, DT_INT);
   n = 100000;
   ae_vector_set_length(&a, n);
   ae_vector_set_length(&buf, n);
   for (i = 0; i < n; i++) {
      a.xZ[i] = i;
   }
   for (i = 0; i < n; i++) {
      k = randominteger(n);
      if (k != i) {
         t = a.xZ[i];
         a.xZ[i] = a.xZ[k];
         a.xZ[k] = t;
      }
   }
   testalglibbasicsunit_testsort2func(&a, &buf, 0, n);
   result = true;
   for (i = 0; i < n; i++) {
      result = result && a.xZ[i] == i;
   }
   ae_frame_leave();
   return result;
}

// Complex arithmetics test
static bool testalglibbasicsunit_testcomplexarithmetics(bool silent) {
   bool absc;
   bool addcc;
   bool addcr;
   bool addrc;
   bool subcc;
   bool subcr;
   bool subrc;
   bool mulcc;
   bool mulcr;
   bool mulrc;
   bool divcc;
   bool divcr;
   bool divrc;
   complex ca;
   complex cb;
   complex res;
   double ra;
   double rb;
   double threshold;
   ae_int_t pass;
   ae_int_t passcount;
   bool result;
   threshold = 100 * machineepsilon;
   passcount = 1000;
   result = true;
   absc = true;
   addcc = true;
   addcr = true;
   addrc = true;
   subcc = true;
   subcr = true;
   subrc = true;
   mulcc = true;
   mulcr = true;
   mulrc = true;
   divcc = true;
   divcr = true;
   divrc = true;
   for (pass = 1; pass <= passcount; pass++) {
   // Test AbsC
      ca = complex_from_d(randommid(), randommid());
      ra = abscomplex(ca);
      absc = absc && fabs(ra - sqrt(sqr(ca.x) + sqr(ca.y))) < threshold;
   // test Add
      ca = complex_from_d(randommid(), randommid());
      cb = complex_from_d(randommid(), randommid());
      ra = randommid();
      rb = randommid();
      res = ae_c_add(ca, cb);
      addcc = (addcc && fabs(res.x - ca.x - cb.x) < threshold) && fabs(res.y - ca.y - cb.y) < threshold;
      res = ae_c_add_d(ca, rb);
      addcr = (addcr && fabs(res.x - ca.x - rb) < threshold) && fabs(res.y - ca.y) < threshold;
      res = ae_c_add_d(cb, ra);
      addrc = (addrc && fabs(res.x - ra - cb.x) < threshold) && fabs(res.y - cb.y) < threshold;
   // test Sub
      ca = complex_from_d(randommid(), randommid());
      cb = complex_from_d(randommid(), randommid());
      ra = randommid();
      rb = randommid();
      res = ae_c_sub(ca, cb);
      subcc = (subcc && fabs(res.x - (ca.x - cb.x)) < threshold) && fabs(res.y - (ca.y - cb.y)) < threshold;
      res = ae_c_sub_d(ca, rb);
      subcr = (subcr && fabs(res.x - (ca.x - rb)) < threshold) && fabs(res.y - ca.y) < threshold;
      res = ae_c_d_sub(ra, cb);
      subrc = (subrc && fabs(res.x - (ra - cb.x)) < threshold) && fabs(res.y + cb.y) < threshold;
   // test Mul
      ca = complex_from_d(randommid(), randommid());
      cb = complex_from_d(randommid(), randommid());
      ra = randommid();
      rb = randommid();
      res = ae_c_mul(ca, cb);
      mulcc = (mulcc && fabs(res.x - (ca.x * cb.x - ca.y * cb.y)) < threshold) && fabs(res.y - (ca.x * cb.y + ca.y * cb.x)) < threshold;
      res = ae_c_mul_d(ca, rb);
      mulcr = (mulcr && fabs(res.x - ca.x * rb) < threshold) && fabs(res.y - ca.y * rb) < threshold;
      res = ae_c_mul_d(cb, ra);
      mulrc = (mulrc && fabs(res.x - ra * cb.x) < threshold) && fabs(res.y - ra * cb.y) < threshold;
   // test Div
      ca = complex_from_d(randommid(), randommid());
      do {
         cb = complex_from_d(randommid(), randommid());
      } while (abscomplex(cb) <= 0.5);
      ra = randommid();
      do {
         rb = randommid();
      } while (fabs(rb) <= 0.5);
      res = ae_c_div(ca, cb);
      divcc = (divcc && fabs(ae_c_mul(res, cb).x - ca.x) < threshold) && fabs(ae_c_mul(res, cb).y - ca.y) < threshold;
      res = ae_c_div_d(ca, rb);
      divcr = (divcr && fabs(res.x - ca.x / rb) < threshold) && fabs(res.y - ca.y / rb) < threshold;
      res = ae_c_d_div(ra, cb);
      divrc = (divrc && fabs(ae_c_mul(res, cb).x - ra) < threshold) && fabs(ae_c_mul(res, cb).y) < threshold;
   }
// summary
   result = result && absc;
   result = result && addcc;
   result = result && addcr;
   result = result && addrc;
   result = result && subcc;
   result = result && subcr;
   result = result && subrc;
   result = result && mulcc;
   result = result && mulcr;
   result = result && mulrc;
   result = result && divcc;
   result = result && divcr;
   result = result && divrc;
   if (!silent) {
      if (result) {
         printf("COMPLEX ARITHMETICS:                     OK\n");
      } else {
         printf("COMPLEX ARITHMETICS:                     FAILED\n");
         printf("* AddCC - - - - - - - - - - - - - - - -  ");
         if (addcc) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* AddCR - - - - - - - - - - - - - - - -  ");
         if (addcr) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* AddRC - - - - - - - - - - - - - - - -  ");
         if (addrc) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* SubCC - - - - - - - - - - - - - - - -  ");
         if (subcc) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* SubCR - - - - - - - - - - - - - - - -  ");
         if (subcr) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* SubRC - - - - - - - - - - - - - - - -  ");
         if (subrc) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* MulCC - - - - - - - - - - - - - - - -  ");
         if (mulcc) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* MulCR - - - - - - - - - - - - - - - -  ");
         if (mulcr) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* MulRC - - - - - - - - - - - - - - - -  ");
         if (mulrc) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* DivCC - - - - - - - - - - - - - - - -  ");
         if (divcc) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* DivCR - - - - - - - - - - - - - - - -  ");
         if (divcr) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* DivRC - - - - - - - - - - - - - - - -  ");
         if (divrc) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
      }
   }
   return result;
}

// Tests for IEEE special quantities
static bool testalglibbasicsunit_testieeespecial(bool silent) {
   bool oknan;
   bool okinf;
   bool okother;
   double v1;
   double v2;
   bool result;
   result = true;
   oknan = true;
   okinf = true;
   okother = true;
// Test classification functions
   okother = okother && !isinf(NAN);
   okother = okother && isinf(+INFINITY);
   okother = okother && !isinf(maxrealnumber);
   okother = okother && !isinf(1.0);
   okother = okother && !isinf(minrealnumber);
   okother = okother && !isinf(0.0);
   okother = okother && !isinf(-minrealnumber);
   okother = okother && !isinf(-1.0);
   okother = okother && !isinf(-maxrealnumber);
   okother = okother && isinf(-INFINITY);
   okother = okother && !isposinf(NAN);
   okother = okother && isposinf(+INFINITY);
   okother = okother && !isposinf(maxrealnumber);
   okother = okother && !isposinf(1.0);
   okother = okother && !isposinf(minrealnumber);
   okother = okother && !isposinf(0.0);
   okother = okother && !isposinf(-minrealnumber);
   okother = okother && !isposinf(-1.0);
   okother = okother && !isposinf(-maxrealnumber);
   okother = okother && !isposinf(-INFINITY);
   okother = okother && !isneginf(NAN);
   okother = okother && !isneginf(+INFINITY);
   okother = okother && !isneginf(maxrealnumber);
   okother = okother && !isneginf(1.0);
   okother = okother && !isneginf(minrealnumber);
   okother = okother && !isneginf(0.0);
   okother = okother && !isneginf(-minrealnumber);
   okother = okother && !isneginf(-1.0);
   okother = okother && !isneginf(-maxrealnumber);
   okother = okother && isneginf(-INFINITY);
   okother = okother && isnan(NAN);
   okother = okother && !isnan(+INFINITY);
   okother = okother && !isnan(maxrealnumber);
   okother = okother && !isnan(1.0);
   okother = okother && !isnan(minrealnumber);
   okother = okother && !isnan(0.0);
   okother = okother && !isnan(-minrealnumber);
   okother = okother && !isnan(-1.0);
   okother = okother && !isnan(-maxrealnumber);
   okother = okother && !isnan(-INFINITY);
   okother = okother && !isfinite(NAN);
   okother = okother && !isfinite(+INFINITY);
   okother = okother && isfinite(maxrealnumber);
   okother = okother && isfinite(1.0);
   okother = okother && isfinite(minrealnumber);
   okother = okother && isfinite(0.0);
   okother = okother && isfinite(-minrealnumber);
   okother = okother && isfinite(-1.0);
   okother = okother && isfinite(-maxrealnumber);
   okother = okother && !isfinite(-INFINITY);
// Test NAN
   v1 = NAN;
   v2 = NAN;
   oknan = oknan && isnan(v1);
   oknan = oknan && v1 != v2;
   oknan = oknan && !(v1 == v2);
// Test INF:
// * basic properties
// * comparisons involving PosINF on one of the sides
// * comparisons involving NegINF on one of the sides
   v1 = +INFINITY;
   v2 = -INFINITY;
   okinf = okinf && isinf(+INFINITY);
   okinf = okinf && isinf(v1);
   okinf = okinf && isinf(-INFINITY);
   okinf = okinf && isinf(v2);
   okinf = okinf && isposinf(+INFINITY);
   okinf = okinf && isposinf(v1);
   okinf = okinf && !isposinf(-INFINITY);
   okinf = okinf && !isposinf(v2);
   okinf = okinf && !isneginf(+INFINITY);
   okinf = okinf && !isneginf(v1);
   okinf = okinf && isneginf(-INFINITY);
   okinf = okinf && isneginf(v2);
   okinf = okinf && +INFINITY == +INFINITY;
   okinf = okinf && +INFINITY == v1;
   okinf = okinf && !(+INFINITY == -INFINITY);
   okinf = okinf && !(+INFINITY == v2);
   okinf = okinf && !(+INFINITY == 0.0);
   okinf = okinf && !(+INFINITY == 1.2);
   okinf = okinf && !(+INFINITY == -1.2);
   okinf = okinf && v1 == +INFINITY;
   okinf = okinf && !(-INFINITY == +INFINITY);
   okinf = okinf && !(v2 == +INFINITY);
   okinf = okinf && !(0.0 == +INFINITY);
   okinf = okinf && !(1.2 == +INFINITY);
   okinf = okinf && !(-1.2 == +INFINITY);
   okinf = okinf && !(+INFINITY != +INFINITY);
   okinf = okinf && !(+INFINITY != v1);
   okinf = okinf && +INFINITY != -INFINITY;
   okinf = okinf && +INFINITY != v2;
   okinf = okinf && +INFINITY != 0.0;
   okinf = okinf && +INFINITY != 1.2;
   okinf = okinf && +INFINITY != -1.2;
   okinf = okinf && !(v1 != +INFINITY);
   okinf = okinf && -INFINITY != +INFINITY;
   okinf = okinf && v2 != +INFINITY;
   okinf = okinf && 0.0 != +INFINITY;
   okinf = okinf && 1.2 != +INFINITY;
   okinf = okinf && -1.2 != +INFINITY;
   okinf = okinf && !(+INFINITY < +INFINITY);
   okinf = okinf && !(+INFINITY < v1);
   okinf = okinf && !(+INFINITY < -INFINITY);
   okinf = okinf && !(+INFINITY < v2);
   okinf = okinf && !(+INFINITY < 0.0);
   okinf = okinf && !(+INFINITY < 1.2);
   okinf = okinf && !(+INFINITY < -1.2);
   okinf = okinf && !(v1 < +INFINITY);
   okinf = okinf && -INFINITY < +INFINITY;
   okinf = okinf && v2 < +INFINITY;
   okinf = okinf && 0.0 < +INFINITY;
   okinf = okinf && 1.2 < +INFINITY;
   okinf = okinf && -1.2 < +INFINITY;
   okinf = okinf && +INFINITY <= +INFINITY;
   okinf = okinf && +INFINITY <= v1;
   okinf = okinf && !(+INFINITY <= -INFINITY);
   okinf = okinf && !(+INFINITY <= v2);
   okinf = okinf && !(+INFINITY <= 0.0);
   okinf = okinf && !(+INFINITY <= 1.2);
   okinf = okinf && !(+INFINITY <= -1.2);
   okinf = okinf && v1 <= +INFINITY;
   okinf = okinf && -INFINITY <= +INFINITY;
   okinf = okinf && v2 <= +INFINITY;
   okinf = okinf && 0.0 <= +INFINITY;
   okinf = okinf && 1.2 <= +INFINITY;
   okinf = okinf && -1.2 <= +INFINITY;
   okinf = okinf && !(+INFINITY > +INFINITY);
   okinf = okinf && !(+INFINITY > v1);
   okinf = okinf && +INFINITY > -INFINITY;
   okinf = okinf && +INFINITY > v2;
   okinf = okinf && +INFINITY > 0.0;
   okinf = okinf && +INFINITY > 1.2;
   okinf = okinf && +INFINITY > -1.2;
   okinf = okinf && !(v1 > +INFINITY);
   okinf = okinf && !(-INFINITY > +INFINITY);
   okinf = okinf && !(v2 > +INFINITY);
   okinf = okinf && !(0.0 > +INFINITY);
   okinf = okinf && !(1.2 > +INFINITY);
   okinf = okinf && !(-1.2 > +INFINITY);
   okinf = okinf && +INFINITY >= +INFINITY;
   okinf = okinf && +INFINITY >= v1;
   okinf = okinf && +INFINITY >= -INFINITY;
   okinf = okinf && +INFINITY >= v2;
   okinf = okinf && +INFINITY >= 0.0;
   okinf = okinf && +INFINITY >= 1.2;
   okinf = okinf && +INFINITY >= -1.2;
   okinf = okinf && v1 >= +INFINITY;
   okinf = okinf && !(-INFINITY >= +INFINITY);
   okinf = okinf && !(v2 >= +INFINITY);
   okinf = okinf && !(0.0 >= +INFINITY);
   okinf = okinf && !(1.2 >= +INFINITY);
   okinf = okinf && !(-1.2 >= +INFINITY);
   okinf = okinf && !(-INFINITY == +INFINITY);
   okinf = okinf && !(-INFINITY == v1);
   okinf = okinf && -INFINITY == -INFINITY;
   okinf = okinf && -INFINITY == v2;
   okinf = okinf && !(-INFINITY == 0.0);
   okinf = okinf && !(-INFINITY == 1.2);
   okinf = okinf && !(-INFINITY == -1.2);
   okinf = okinf && !(v1 == -INFINITY);
   okinf = okinf && -INFINITY == -INFINITY;
   okinf = okinf && v2 == -INFINITY;
   okinf = okinf && !(0.0 == -INFINITY);
   okinf = okinf && !(1.2 == -INFINITY);
   okinf = okinf && !(-1.2 == -INFINITY);
   okinf = okinf && -INFINITY != +INFINITY;
   okinf = okinf && -INFINITY != v1;
   okinf = okinf && !(-INFINITY != -INFINITY);
   okinf = okinf && !(-INFINITY != v2);
   okinf = okinf && -INFINITY != 0.0;
   okinf = okinf && -INFINITY != 1.2;
   okinf = okinf && -INFINITY != -1.2;
   okinf = okinf && v1 != -INFINITY;
   okinf = okinf && !(-INFINITY != -INFINITY);
   okinf = okinf && !(v2 != -INFINITY);
   okinf = okinf && 0.0 != -INFINITY;
   okinf = okinf && 1.2 != -INFINITY;
   okinf = okinf && -1.2 != -INFINITY;
   okinf = okinf && -INFINITY < +INFINITY;
   okinf = okinf && -INFINITY < v1;
   okinf = okinf && !(-INFINITY < -INFINITY);
   okinf = okinf && !(-INFINITY < v2);
   okinf = okinf && -INFINITY < 0.0;
   okinf = okinf && -INFINITY < 1.2;
   okinf = okinf && -INFINITY < -1.2;
   okinf = okinf && !(v1 < -INFINITY);
   okinf = okinf && !(-INFINITY < -INFINITY);
   okinf = okinf && !(v2 < -INFINITY);
   okinf = okinf && !(0.0 < -INFINITY);
   okinf = okinf && !(1.2 < -INFINITY);
   okinf = okinf && !(-1.2 < -INFINITY);
   okinf = okinf && -INFINITY <= +INFINITY;
   okinf = okinf && -INFINITY <= v1;
   okinf = okinf && -INFINITY <= -INFINITY;
   okinf = okinf && -INFINITY <= v2;
   okinf = okinf && -INFINITY <= 0.0;
   okinf = okinf && -INFINITY <= 1.2;
   okinf = okinf && -INFINITY <= -1.2;
   okinf = okinf && !(v1 <= -INFINITY);
   okinf = okinf && -INFINITY <= -INFINITY;
   okinf = okinf && v2 <= -INFINITY;
   okinf = okinf && !(0.0 <= -INFINITY);
   okinf = okinf && !(1.2 <= -INFINITY);
   okinf = okinf && !(-1.2 <= -INFINITY);
   okinf = okinf && !(-INFINITY > +INFINITY);
   okinf = okinf && !(-INFINITY > v1);
   okinf = okinf && !(-INFINITY > -INFINITY);
   okinf = okinf && !(-INFINITY > v2);
   okinf = okinf && !(-INFINITY > 0.0);
   okinf = okinf && !(-INFINITY > 1.2);
   okinf = okinf && !(-INFINITY > -1.2);
   okinf = okinf && v1 > -INFINITY;
   okinf = okinf && !(-INFINITY > -INFINITY);
   okinf = okinf && !(v2 > -INFINITY);
   okinf = okinf && 0.0 > -INFINITY;
   okinf = okinf && 1.2 > -INFINITY;
   okinf = okinf && -1.2 > -INFINITY;
   okinf = okinf && !(-INFINITY >= +INFINITY);
   okinf = okinf && !(-INFINITY >= v1);
   okinf = okinf && -INFINITY >= -INFINITY;
   okinf = okinf && -INFINITY >= v2;
   okinf = okinf && !(-INFINITY >= 0.0);
   okinf = okinf && !(-INFINITY >= 1.2);
   okinf = okinf && !(-INFINITY >= -1.2);
   okinf = okinf && v1 >= -INFINITY;
   okinf = okinf && -INFINITY >= -INFINITY;
   okinf = okinf && v2 >= -INFINITY;
   okinf = okinf && 0.0 >= -INFINITY;
   okinf = okinf && 1.2 >= -INFINITY;
   okinf = okinf && -1.2 >= -INFINITY;
// summary
   result = result && oknan;
   result = result && okinf;
   result = result && okother;
   if (!silent) {
      if (result) {
         printf("IEEE SPECIAL VALUES:                     OK\n");
      } else {
         printf("IEEE SPECIAL VALUES:                     FAILED\n");
         printf("* NAN - - - - - - - - - - - - - - - - -  ");
         if (oknan) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* INF - - - - - - - - - - - - - - - - -  ");
         if (okinf) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* FUNCTIONS - - - - - - - - - - - - - -  ");
         if (okother) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
      }
   }
   return result;
}

// Tests for swapping functions
static bool testalglibbasicsunit_testswapfunctions(bool silent) {
   ae_frame _frame_block;
   bool okb1;
   bool okb2;
   bool oki1;
   bool oki2;
   bool okr1;
   bool okr2;
   bool okc1;
   bool okc2;
   bool result;
   ae_frame_make(&_frame_block);
   NewVector(b11, 0, DT_BOOL);
   NewVector(b12, 0, DT_BOOL);
   NewVector(i11, 0, DT_INT);
   NewVector(i12, 0, DT_INT);
   NewVector(r11, 0, DT_REAL);
   NewVector(r12, 0, DT_REAL);
   NewVector(c11, 0, DT_COMPLEX);
   NewVector(c12, 0, DT_COMPLEX);
   NewMatrix(b21, 0, 0, DT_BOOL);
   NewMatrix(b22, 0, 0, DT_BOOL);
   NewMatrix(i21, 0, 0, DT_INT);
   NewMatrix(i22, 0, 0, DT_INT);
   NewMatrix(r21, 0, 0, DT_REAL);
   NewMatrix(r22, 0, 0, DT_REAL);
   NewMatrix(c21, 0, 0, DT_COMPLEX);
   NewMatrix(c22, 0, 0, DT_COMPLEX);
   result = true;
   okb1 = true;
   okb2 = true;
   oki1 = true;
   oki2 = true;
   okr1 = true;
   okr2 = true;
   okc1 = true;
   okc2 = true;
// Test B1 swaps
   ae_vector_set_length(&b11, 1);
   ae_vector_set_length(&b12, 2);
   b11.xB[0] = true;
   b12.xB[0] = false;
   b12.xB[1] = true;
   ae_swap_vectors(&b11, &b12);
   if (b11.cnt == 2 && b12.cnt == 1) {
      okb1 = okb1 && !b11.xB[0];
      okb1 = okb1 && b11.xB[1];
      okb1 = okb1 && b12.xB[0];
   } else {
      okb1 = false;
   }
// Test I1 swaps
   ae_vector_set_length(&i11, 1);
   ae_vector_set_length(&i12, 2);
   i11.xZ[0] = 1;
   i12.xZ[0] = 2;
   i12.xZ[1] = 3;
   ae_swap_vectors(&i11, &i12);
   if (i11.cnt == 2 && i12.cnt == 1) {
      oki1 = oki1 && i11.xZ[0] == 2;
      oki1 = oki1 && i11.xZ[1] == 3;
      oki1 = oki1 && i12.xZ[0] == 1;
   } else {
      oki1 = false;
   }
// Test R1 swaps
   ae_vector_set_length(&r11, 1);
   ae_vector_set_length(&r12, 2);
   r11.xR[0] = 1.5;
   r12.xR[0] = 2.5;
   r12.xR[1] = 3.5;
   ae_swap_vectors(&r11, &r12);
   if (r11.cnt == 2 && r12.cnt == 1) {
      okr1 = okr1 && r11.xR[0] == 2.5;
      okr1 = okr1 && r11.xR[1] == 3.5;
      okr1 = okr1 && r12.xR[0] == 1.5;
   } else {
      okr1 = false;
   }
// Test C1 swaps
   ae_vector_set_length(&c11, 1);
   ae_vector_set_length(&c12, 2);
   c11.xC[0] = complex_from_i(1);
   c12.xC[0] = complex_from_i(2);
   c12.xC[1] = complex_from_i(3);
   ae_swap_vectors(&c11, &c12);
   if (c11.cnt == 2 && c12.cnt == 1) {
      okc1 = okc1 && ae_c_eq_d(c11.xC[0], 2.0);
      okc1 = okc1 && ae_c_eq_d(c11.xC[1], 3.0);
      okc1 = okc1 && ae_c_eq_d(c12.xC[0], 1.0);
   } else {
      okc1 = false;
   }
// Test B2 swaps
   ae_matrix_set_length(&b21, 1, 2);
   ae_matrix_set_length(&b22, 2, 1);
   b21.xyB[0][0] = true;
   b21.xyB[0][1] = false;
   b22.xyB[0][0] = false;
   b22.xyB[1][0] = true;
   ae_swap_matrices(&b21, &b22);
   if (((b21.rows == 2 && b21.cols == 1) && b22.rows == 1) && b22.cols == 2) {
      okb2 = okb2 && !b21.xyB[0][0];
      okb2 = okb2 && b21.xyB[1][0];
      okb2 = okb2 && b22.xyB[0][0];
      okb2 = okb2 && !b22.xyB[0][1];
   } else {
      okb2 = false;
   }
// Test I2 swaps
   ae_matrix_set_length(&i21, 1, 2);
   ae_matrix_set_length(&i22, 2, 1);
   i21.xyZ[0][0] = 1;
   i21.xyZ[0][1] = 2;
   i22.xyZ[0][0] = 3;
   i22.xyZ[1][0] = 4;
   ae_swap_matrices(&i21, &i22);
   if (((i21.rows == 2 && i21.cols == 1) && i22.rows == 1) && i22.cols == 2) {
      oki2 = oki2 && i21.xyZ[0][0] == 3;
      oki2 = oki2 && i21.xyZ[1][0] == 4;
      oki2 = oki2 && i22.xyZ[0][0] == 1;
      oki2 = oki2 && i22.xyZ[0][1] == 2;
   } else {
      oki2 = false;
   }
// Test R2 swaps
   ae_matrix_set_length(&r21, 1, 2);
   ae_matrix_set_length(&r22, 2, 1);
   r21.xyR[0][0] = 1.0;
   r21.xyR[0][1] = 2.0;
   r22.xyR[0][0] = 3.0;
   r22.xyR[1][0] = 4.0;
   ae_swap_matrices(&r21, &r22);
   if (((r21.rows == 2 && r21.cols == 1) && r22.rows == 1) && r22.cols == 2) {
      okr2 = okr2 && r21.xyR[0][0] == 3.0;
      okr2 = okr2 && r21.xyR[1][0] == 4.0;
      okr2 = okr2 && r22.xyR[0][0] == 1.0;
      okr2 = okr2 && r22.xyR[0][1] == 2.0;
   } else {
      okr2 = false;
   }
// Test C2 swaps
   ae_matrix_set_length(&c21, 1, 2);
   ae_matrix_set_length(&c22, 2, 1);
   c21.xyC[0][0] = complex_from_i(1);
   c21.xyC[0][1] = complex_from_i(2);
   c22.xyC[0][0] = complex_from_i(3);
   c22.xyC[1][0] = complex_from_i(4);
   ae_swap_matrices(&c21, &c22);
   if (((c21.rows == 2 && c21.cols == 1) && c22.rows == 1) && c22.cols == 2) {
      okc2 = okc2 && ae_c_eq_d(c21.xyC[0][0], 3.0);
      okc2 = okc2 && ae_c_eq_d(c21.xyC[1][0], 4.0);
      okc2 = okc2 && ae_c_eq_d(c22.xyC[0][0], 1.0);
      okc2 = okc2 && ae_c_eq_d(c22.xyC[0][1], 2.0);
   } else {
      okc2 = false;
   }
// summary
   result = result && okb1;
   result = result && okb2;
   result = result && oki1;
   result = result && oki2;
   result = result && okr1;
   result = result && okr2;
   result = result && okc1;
   result = result && okc2;
   if (!silent) {
      if (result) {
         printf("SWAPPING FUNCTIONS:                      OK\n");
      } else {
         printf("SWAPPING FUNCTIONS:                      FAILED\n");
      }
   }
   ae_frame_leave();
   return result;
}

// Tests for standard functions
static bool testalglibbasicsunit_teststandardfunctions(bool silent) {
   bool result;
   result = true;
// Test Sign()
   result = result && sign(1.2) == 1;
   result = result && sign(0.0) == 0;
   result = result && sign(-1.2) == -1;
// summary
   if (!silent) {
      if (result) {
         printf("STANDARD FUNCTIONS:                      OK\n");
      } else {
         printf("STANDARD FUNCTIONS:                      FAILED\n");
      }
   }
   return result;
}

// Tests for serualization functions
static bool testalglibbasicsunit_testserializationfunctions(bool silent) {
   ae_frame _frame_block;
   bool okb;
   bool oki;
   bool okr;
   ae_int_t nb;
   ae_int_t ni;
   ae_int_t nr;
   ae_int_t i;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(rec4serialization, r0);
   NewObj(rec4serialization, r1);
   result = true;
   okb = true;
   oki = true;
   okr = true;
   for (nb = 1; nb <= 4; nb++) {
      for (ni = 1; ni <= 4; ni++) {
         for (nr = 1; nr <= 4; nr++) {
            ae_vector_set_length(&r0.b, nb);
            for (i = 0; i < nb; i++) {
               r0.b.xB[i] = randominteger(2) != 0;
            }
            ae_vector_set_length(&r0.i, ni);
            for (i = 0; i < ni; i++) {
               r0.i.xZ[i] = randominteger(10) - 5;
            }
            ae_vector_set_length(&r0.r, nr);
            for (i = 0; i < nr; i++) {
               r0.r.xR[i] = randommid();
            }
            {
            // This code passes data structure through serializers
            // (serializes it to string and loads back)
               ae_int_t _local_ssize;
               ae_frame _local_frame_block;
               ae_frame_make(&_local_frame_block);
               NewSerializer(_local_serializer);
               ae_serializer_alloc_start(&_local_serializer);
               rec4serializationalloc(&_local_serializer, &r0);
               _local_ssize = ae_serializer_get_alloc_size(&_local_serializer);
               NewBlock(_local_dynamic_block, _local_ssize + 1);
               ae_serializer_sstart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               rec4serializationserialize(&_local_serializer, &r0);
               ae_serializer_stop(&_local_serializer);
               ae_serializer_init(&_local_serializer);
               ae_serializer_ustart_str(&_local_serializer, (char *)_local_dynamic_block.ptr);
               rec4serializationunserialize(&_local_serializer, &r1);
               ae_serializer_stop(&_local_serializer);
               ae_frame_leave();
            }
            if ((r0.b.cnt == r1.b.cnt && r0.i.cnt == r1.i.cnt) && r0.r.cnt == r1.r.cnt) {
               for (i = 0; i < nb; i++) {
                  okb = okb && r0.b.xB[i] == r1.b.xB[i];
               }
               for (i = 0; i < ni; i++) {
                  oki = oki && r0.i.xZ[i] == r1.i.xZ[i];
               }
               for (i = 0; i < nr; i++) {
                  okr = okr && r0.r.xR[i] == r1.r.xR[i];
               }
            } else {
               oki = false;
            }
         }
      }
   }
// summary
   result = result && okb;
   result = result && oki;
   result = result && okr;
   if (!silent) {
      if (result) {
         printf("SERIALIZATION FUNCTIONS:                 OK\n");
      } else {
         printf("SERIALIZATION FUNCTIONS:                 FAILED\n");
         printf("* BOOLEAN - - - - - - - - - - - - - - -  ");
         if (okb) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* INTEGER - - - - - - - - - - - - - - -  ");
         if (oki) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* REAL  - - - - - - - - - - - - - - - -  ");
         if (okr) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
      }
   }
   ae_frame_leave();
   return result;
}

// Summation routune for parallel summation test.
static void testalglibbasicsunit_parallelpoolsum(ae_shared_pool *sumpool, ae_int_t ind0, ae_int_t ind1) {
   ae_frame _frame_block;
   ae_int_t i;
   ae_frame_make(&_frame_block);
   RefObj(poolsummand, ptr);
   if (ind1 - ind0 <= 2) {
      ae_shared_pool_retrieve(sumpool, &_ptr);
      ptr->val += ind1 - ind0;
      ae_shared_pool_recycle(sumpool, &_ptr);
   } else {
      i = (ind0 + ind1) / 2;
      testalglibbasicsunit_parallelpoolsum(sumpool, ind0, i);
      testalglibbasicsunit_parallelpoolsum(sumpool, i, ind1);
   }
   ae_frame_leave();
}

// TestPoolSum: summation with pool
//
// We perform summation of 500000 numbers (each of them is equal to 1) in the
// recurrent manner, by accumulation of result in the pool.
//
// This test checks pool ability to handle continuous stream of operations.
//
// Returns True on success, False on failure.
static bool testalglibbasicsunit_performtestpoolsum() {
   ae_frame _frame_block;
   ae_int_t n;
   ae_int_t sum;
   bool result;
   ae_frame_make(&_frame_block);
   NewObj(ae_shared_pool, pool);
   RefObj(poolsummand, ptr);
   NewObj(poolsummand, seed);
   n = 500000;
   seed.val = 0;
   ae_shared_pool_set_seed(&pool, &seed, sizeof(seed), poolsummand_init, poolsummand_copy, poolsummand_free);
   testalglibbasicsunit_parallelpoolsum(&pool, 0, n);
   sum = 0;
   ae_shared_pool_first_recycled(&pool, &_ptr);
   while (ptr != NULL) {
      sum += ptr->val;
      ae_shared_pool_next_recycled(&pool, &_ptr);
   }
   result = sum == n;
   ae_frame_leave();
   return result;
}

static bool testalglibbasicsunit_testsmp(bool silent) {
   bool t0;
   bool t1;
   bool t2;
   bool ts;
   bool result;
   t0 = testalglibbasicsunit_performtestsort0();
   t1 = testalglibbasicsunit_performtestsort1();
   t2 = testalglibbasicsunit_performtestsort2();
   ts = testalglibbasicsunit_performtestpoolsum();
   result = ((t0 && t1) && t2) && ts;
   if (!silent) {
      if (result) {
         printf("SMP FUNCTIONS:                           OK\n");
      } else {
         printf("SMP FUNCTIONS:                           FAILED\n");
         printf("* TEST SORT0 (sorting, split-2)          ");
         if (t0) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* TEST SORT1 (sorting, split-4)          ");
         if (t1) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* TEST SORT2 (sorting, split-2, unequal) ");
         if (t2) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
         printf("* TEST POOLSUM (accumulation with pool)  ");
         if (ts) {
            printf("OK\n");
         } else {
            printf("FAILED\n");
         }
      }
   }
   return result;
}

bool testalglibbasics(bool silent) {
   bool result;
   result = true;
   result = result && testalglibbasicsunit_testcomplexarithmetics(silent);
   result = result && testalglibbasicsunit_testieeespecial(silent);
   result = result && testalglibbasicsunit_testswapfunctions(silent);
   result = result && testalglibbasicsunit_teststandardfunctions(silent);
   result = result && testalglibbasicsunit_testserializationfunctions(silent);
   result = result && testalglibbasicsunit_testsharedpool(silent);
   result = result && testalglibbasicsunit_testsmp(silent);
   if (!silent) {
      printf("\n\n");
   }
   return result;
}

// === main testing unit ===
#if AE_OS == AE_POSIX || defined AE_DEBUG4POSIX
#   include <unistd.h>
#   include <pthread.h>
#endif
#if AE_OS == AE_WINDOWS || defined AE_DEBUG4WINDOWS
#   include <windows.h>
#endif

unsigned seed;

static const enum {
   AE_NOENV, AE_SINGLECORE, AE_SEQUENTIAL_MULTICORE, AE_PARALLEL_SINGLECORE, AE_PARALLEL_MULTICORE, AE_SKIP_TEST
} TestMode = AE_SINGLECORE;

int global_failure_flag = 0;
bool use_smp = false;

#if AE_OS == AE_POSIX || defined AE_DEBUG4POSIX
pthread_mutex_t tests_lock;
pthread_mutex_t print_lock;
#elif AE_OS == AE_WINDOWS || defined AE_DEBUG4WINDOWS
CRITICAL_SECTION tests_lock;
CRITICAL_SECTION print_lock;
#else
void *tests_lock = NULL;
void *print_lock = NULL;
#endif

struct _s_testrecord {
   const char *name;
   bool (*testfunc)(bool);
};

int unittests_processed = 0;

_s_testrecord unittests[] = {
   { "ablasf", testablasf },
   { "hqrnd", testhqrnd },
   { "ablas", testablas },
   { "hblas", testhblas },
   { "creflections", testcreflections },
   { "sblas", testsblas },
   { "ortfac", testortfac },
   { "matgen", testmatgen },
   { "tsort", testtsort },
   { "sparse", testsparse },
   { "blas", testblas },
   { "evd", testevd },
   { "trfac", testtrfac },
   { "polynomialsolver", testpolynomialsolver },
   { "bdsvd", testbdsvd },
   { "svd", testsvd },
   { "trlinsolve", testtrlinsolve },
   { "safesolve", testsafesolve },
   { "rcond", testrcond },
   { "xblas", testxblas },
   { "directdensesolvers", testdirectdensesolvers },
   { "directsparsesolvers", testdirectsparsesolvers },
   { "fbls", testfbls },
   { "iterativesparse", testiterativesparse },
   { "lincg", testlincg },
   { "normestimator", testnormestimator },
   { "linlsqr", testlinlsqr },
   { "linmin", testlinmin },
   { "nleq", testnleq },
   { "matinv", testmatinv },
   { "optserv", testoptserv },
   { "minlbfgs", testminlbfgs },
   { "cqmodels", testcqmodels },
   { "snnls", testsnnls },
   { "sactivesets", testsactivesets },
   { "minbleic", testminbleic },
   { "minqp", testminqp },
   { "minlm", testminlm },
   { "mincg", testmincg },
   { "minlp", testminlp },
   { "minnlc", testminnlc },
   { "minns", testminns },
   { "minbc", testminbc },
   { "nearestneighbor", testnearestneighbor },
   { "odesolver", testodesolver },
   { "inverseupdate", testinverseupdate },
   { "schur", testschur },
   { "spdgevd", testspdgevd },
   { "gammafunc", testgammafunc },
   { "gq", testgq },
   { "gkq", testgkq },
   { "autogk", testautogk },
   { "normaldistr", testnormaldistr },
   { "basestat", testbasestat },
   { "wsr", testwsr },
   { "mannwhitneyu", testmannwhitneyu },
   { "stest", teststest },
   { "studentttests", teststudentttests },
   { "ratint", testratint },
   { "idw", testidw },
   { "polint", testpolint },
   { "spline1d", testspline1d },
   { "lsfit", testlsfit },
   { "fitsphere", testfitsphere },
   { "parametric", testparametric },
   { "spline2d", testspline2d },
   { "spline3d", testspline3d },
   { "rbf", testrbf },
   { "fft", testfft },
   { "fht", testfht },
   { "conv", testconv },
   { "corr", testcorr },
   { "chebyshev", testchebyshev },
   { "hermite", testhermite },
   { "legendre", testlegendre },
   { "laguerre", testlaguerre },
   { "pca", testpca },
   { "bdss", testbdss },
   { "mlpbase", testmlpbase },
   { "mlpe", testmlpe },
   { "clustering", testclustering },
   { "dforest", testdforest },
   { "linreg", testlinreg },
   { "filters", testfilters },
   { "ssa", testssa },
   { "lda", testlda },
   { "mcpd", testmcpd },
   { "knn", testknn },
   { "mlptrain", testmlptrain },
   { "alglibbasics", testalglibbasics },
   { NULL, NULL }
};

#if AE_OS == AE_POSIX || defined AE_DEBUG4POSIX
void acquire_lock(pthread_mutex_t *p_lock) {
   pthread_mutex_lock(p_lock);
}

void release_lock(pthread_mutex_t *p_lock) {
   pthread_mutex_unlock(p_lock);
}
#elif AE_OS == AE_WINDOWS || defined AE_DEBUG4WINDOWS
void acquire_lock(CRITICAL_SECTION *p_lock) {
   EnterCriticalSection(p_lock);
}

void release_lock(CRITICAL_SECTION *p_lock) {
   LeaveCriticalSection(p_lock);
}
#else
void acquire_lock(void **p_lock) {
}

void release_lock(void **p_lock) {
}
#endif

bool call_unittest(bool (*testfunc)(bool), int *psticky) {
#ifndef AE_USE_CPP_ERROR_HANDLING
   ae_frame _frame_block;
   bool result;
   ae_state_init();
   TryX {
      *psticky = 1;
      return false;
   }
   if (use_smp)
      ae_state_set_flags(ParTH);
   ae_frame_make(&_frame_block);
   result = testfunc(true);
   ae_state_clear();
   if (!result)
      *psticky = 1;
   return result;
#else
   try {
      ae_frame _frame_block;
      bool result;
      ae_state_init();
      ae_frame_make(&_frame_block);
      if (use_smp)
         ae_state_set_flags(ParTH);
      result = testfunc(true);
      ae_state_clear();
      if (!result)
         *psticky = 1;
      return result;
   } catch(...) {
      *psticky = 1;
      return false;
   }
#endif
}

#if AE_OS == AE_POSIX || defined AE_DEBUG4POSIX
void *tester_function(void *T) {
#elif AE_OS == AE_WINDOWS || defined AE_DEBUG4WINDOWS
DWORD WINAPI tester_function(LPVOID T) {
#else
void tester_function(void *T) {
#endif
   int idx;
   bool status;
   while (true) {
   // try to acquire test record
      acquire_lock(&tests_lock);
      if (unittests[unittests_processed].name == NULL) {
         release_lock(&tests_lock);
         break;
      }
      idx = unittests_processed;
      unittests_processed++;
      release_lock(&tests_lock);
   // Call unit test
      status = call_unittest(unittests[idx].testfunc, &global_failure_flag);
      acquire_lock(&print_lock);
      if (status)
         printf("%-32s OK\n", unittests[idx].name);
      else
         printf("%-32s FAILED\n", unittests[idx].name);
      fflush(stdout);
      release_lock(&print_lock);
   }
#if AE_OS == AE_POSIX || defined AE_DEBUG4POSIX
   return NULL;
#elif AE_OS == AE_WINDOWS || defined AE_DEBUG4WINDOWS
   return 0;
#else
#endif
}

int main(int argc, char **argv) {
   time_t time_0, time_1;
   union {
      double a;
      ae_int32_t p[2];
   } u;
   if (argc == 2)
      seed = (unsigned)atoi(argv[1]);
   else {
      time_t t;
      seed = (unsigned)time(&t);
   }
#if AE_OS == AE_POSIX || defined AE_DEBUG4POSIX
   pthread_mutex_init(&tests_lock, NULL);
   pthread_mutex_init(&print_lock, NULL);
#elif AE_OS == AE_WINDOWS || defined AE_DEBUG4WINDOWS
   InitializeCriticalSection(&tests_lock);
   InitializeCriticalSection(&print_lock);
#endif
// SMP settings
   use_smp = TestMode == AE_PARALLEL_MULTICORE || TestMode == AE_SEQUENTIAL_MULTICORE;
// Seed
   printf("SEED: %u\n", (unsigned int)seed);
   srand(seed);
// Compiler
#if AE_COMPILER == AE_GNUC
   printf("COMPILER: GCC\n");
#elif AE_COMPILER == AE_SUNC
   printf("COMPILER: SunStudio\n");
#elif AE_COMPILER == AE_MSVC
   printf("COMPILER: MSVC\n");
#else
   printf("COMPILER: unknown\n");
#endif
// Architecture
   if (sizeof(void *) == 4)
      printf("HARDWARE: 32-bit\n");
   else if (sizeof(void *) == 8)
      printf("HARDWARE: 64-bit\n");
   else
      printf("HARDWARE: strange (non-32, non-64)\n");
// Determine the native byte ordering of the hardware.
// 1983 is a good number - non-periodic double representation allow us to
// easily distinguish between upper and lower halfs and to detect mixed endian hardware.
   u.a = 1.0 / 1983.0;
   if (u.p[1] == 0x3f408642)
      printf("HARDWARE: little-endian\n");
   else if (u.p[0] == 0x3f408642)
      printf("HARDWARE: big-endian\n");
   else
      printf("HARDWARE: mixed-endian\n");
// CPU (as defined)
#if AE_CPU == AE_INTEL
   printf("CPU:   Intel\n");
#elif AE_CPU == AE_SPARC
   printf("CPU:   SPARC\n");
#else
   printf("CPU:   unknown\n");
#endif
// Cores count
#ifdef _ALGLIB_HAS_WORKSTEALING
   printf("CORES: %d\n", (int)ae_cores_count());
#else
   printf("CORES: 1 (serial version)\n");
#endif
// Support for vendor libraries
#ifdef AE_MKL
   printf("LIBS:  MKL (Intel)\n");
#else
   printf("LIBS:  \n");
#endif
// CPUID results
   printf("CPUID:%s%s%s\n", CurCPU & CPU_SSE2 ? " sse2" : "", CurCPU & CPU_AVX2 ? " avx2" : "", CurCPU & CPU_FMA ? " fma" : "");
// OS
#if AE_OS == AE_POSIX
   printf("OS: POSIX\n");
#elif AE_OS == AE_WINDOWS
   printf("OS: Windows\n");
#else
   printf("OS: unknown\n");
#endif
// Testing mode
   switch (TestMode) {
      case AE_NOENV: case AE_SINGLECORE: printf("Testing Mode: single core\n"); break;
      case AE_PARALLEL_SINGLECORE: printf("Testing Mode: single core, parallel\n"); break;
      case AE_SEQUENTIAL_MULTICORE: printf("Testing Mode: multi-core, sequential\n"); break;
      case AE_PARALLEL_MULTICORE: printf("Testing Mode: multi-core, parallel\n"); break;
      case AE_SKIP_TEST: printf("Testing Mode: just compiling\nDone in 0 seconds\n"); return EXIT_SUCCESS;
      default: printf("Testing Mode: unknown\n"); return EXIT_FAILURE;
   }
// now we are ready to test!
   time(&time_0);
#ifdef _ALGLIB_HAS_WORKSTEALING
   bool smpOk = ae_smpselftests();
   printf("%-32s %s\n", "SMP self tests", smpOk ? "Ok" : "Failed");
   if (!smpOk) return EXIT_FAILURE;
#endif
   fflush(stdout);
   switch (TestMode) {
      case AE_NOENV: case AE_SINGLECORE: case AE_SEQUENTIAL_MULTICORE: case AE_SKIP_TEST:
         tester_function(NULL);
      break;
      case AE_PARALLEL_MULTICORE: case AE_PARALLEL_SINGLECORE: {
#ifdef _ALGLIB_HAS_WORKSTEALING
         setnworkers(0);
#endif
#if AE_OS == AE_POSIX || defined AE_DEBUG4POSIX
         long cpu_cnt = sysconf(_SC_NPROCESSORS_ONLN);
         ae_assert(cpu_cnt >= 1, "processors count is less than 1");
         pthread_t *Bundle = (pthread_t *)malloc(cpu_cnt * sizeof *Bundle);
         ae_assert(Bundle != NULL, "malloc failure");
         for (int cpu = 0; cpu < cpu_cnt; cpu++) {
            int status = pthread_create(&Bundle[cpu], NULL, tester_function, NULL);
            if (status != 0) {
               printf("Failed to create thread\n");
               abort();
            }
         }
         for (int cpu = 0; cpu < cpu_cnt; cpu++) pthread_join(Bundle[cpu], NULL);
#elif AE_OS == AE_WINDOWS || defined AE_DEBUG4WINDOWS
         SYSTEM_INFO sysInfo; GetSystemInfo(&sysInfo); long cpu_cnt = sysInfo.dwNumberOfProcessors;
         ae_assert(cpu_cnt >= 1, "processors count is less than 1");
         HANDLE *Bundle = (HANDLE *)malloc(cpu_cnt * sizeof *Bundle);
         ae_assert(Bundle != NULL, "malloc failure");
         for (int cpu = 0; cpu < cpu_cnt; cpu++)
            Bundle[cpu] = CreateThread(NULL, 0, tester_function, NULL, 0, NULL);
         WaitForMultipleObjects(cpu_cnt, Bundle, TRUE, INFINITE);
#else
#   error Unable to determine OS (define AE_OS, AE_DEBUG4POSIX or AE_DEBUG4WINDOWS)
#endif
      }
      default: printf("Unexpected test mode\n"); return EXIT_FAILURE;
   }
   time(&time_1);
   printf("Done in %ld seconds\n", (long)difftime(time_1, time_0));
   if (global_failure_flag)
      printf("Last error at %s:%d (%s)\n", sef_file, (int)sef_line, sef_xdesc);
// Free structures
#if AE_OS == AE_POSIX || defined AE_DEBUG4POSIX
   pthread_mutex_destroy(&tests_lock);
   pthread_mutex_destroy(&print_lock);
#elif AE_OS == AE_WINDOWS || defined AE_DEBUG4WINDOWS
   DeleteCriticalSection(&tests_lock);
   DeleteCriticalSection(&print_lock);
#endif
#ifdef AE_HPC
   ae_free_disposed_items();
   ae_complete_finalization_before_exit();
#endif
// Return result
   return global_failure_flag;
}
