<html>
<head>
<title>ALGLIB++ Supplementary Sections</title>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<style type="text/css">
h1		{ font-family: Arial, Helvetica, sans-serif; color: #000000; font-size: 36pt; margin-top: 0; margin-bottom: 0; }
h2		{ font-family: Arial, Helvetica, sans-serif; color: #003300; font-size: 20pt; margin-bottom: 0; }
h3		{ font-family: Arial, Helvetica, sans-serif; color: #006600; font-size: 15pt; margin-bottom: 0; }
h4		{ font-family: Arial, Helvetica, sans-serif; color: #666600; font-size: 14pt; margin-bottom: 0; }
h5		{ font-family: Arial, Helvetica, sans-serif; color: #660000; font-size: 14pt; margin-top: 10pt; margin-bottom: 0; }
h6		{ font-family: Arial, Helvetica, sans-serif; color: #000066; font-size: 13pt; margin-top: 10pt; margin-bottom: 0; }
sheader		{ }
.inlineheader	{ background-color: #e8e8e8; padding: 0.1em; font-weight: bold; }
.pagecontent	{ font-family: Verdana, Arial, sans-serif; font-size: 10pt; text-align: justify; }
.pageheader	{ width: 50em; }
.source		{ font-family: "Courier New"; font-size: 1.0em; margin-top: 0; margin-bottom: 0; }
.narration	{ font-family: "Courier New"; font-size: 1.0em; margin-top: 0; margin-bottom: 0; color: navy; }
.declaration	{ font-family: "Courier New"; font-size: 1.0em; margin-top: 0; margin-bottom: 0; color: blue; }
code		{ font-family: "Courier New"; font-size: 1.0em; }
.p_example	{ margin-left: 4em; font-family: "Courier New"; font-size: 1.0em; }
.p_note		{ margin-left: 10%; margin-right: 10%; font-size: 80%; }
.p_att		{ margin-left: 10%; margin-right: 10%; color: red; font-weight: bold; }
.p_code_head	{ margin-left: 5%; margin-top: 0; margin-bottom: 0; padding: 5px; width: 90%; font-family: "Courier New", monospace; background-color: #aaaaaa; font-weight: bold; color: white; }
.p_code_body	{ margin-left: 5%; margin-top: 0; margin-bottom: 0; padding: 5px; width: 90%; font-family: "Courier New", monospace; background-color: #f0f0f0; }
.p_code		{ margin-left: 5%; margin-top: 0; margin-bottom: 0; padding: 5px; width: 90%; font-family: "Courier New", monospace; background-color: #f0f0f0; }
.s_code		{ font-family: "Courier New"; background-color: #f0f0f0; }
.s_str		{ font-family: "Courier New"; color: blue; font-weight: bold; }
.s_comment	{ color: navy; font-style: italic; }
.s_preprocessor	{ color: green; }
a		{ color: #000077; text-decoration: underline; }
a:link		{ color: #0000ff; text-decoration: underline; }
a:visited	{ color: #000077; text-decoration: underline; }
a:active	{ color: #6666ff; text-decoration: underline; }
a:hover		{ color: #ff6666; text-decoration: underline; }
a.toc		{ color: #000077; text-decoration: none; }
a.toc:link	{ color: #0000ff; text-decoration: none; }
a.toc:visited	{ color: #000077; text-decoration: none; }
a.toc:active	{ color: #6666ff; text-decoration: none; }
a.toc:hover	{ color: #ff6666; text-decoration: none; }
a.nav		{ color: #000077; font-weight: bold; text-decoration: none; }
a.nav:link	{ color: #0000ff; font-weight: bold; text-decoration: none; }
a.nav:visited	{ color: #000077; font-weight: bold; text-decoration: none; }
a.nav:active	{ color: #6666ff; font-weight: bold; text-decoration: none; }
a.nav:hover	{ color: #ff6666; font-weight: bold; text-decoration: none; }
.cond		{ color: blue; }
.const		{ color: #222222; }
.func		{ color: #111111; }
</style>
</head>
<body>
<div class=pagecontent>
<p>
<h1>ALGLIB++ Supplementary Notes</h1>
Additional notes on the implementation and revisions of ALGLIB++.
This is a supplement to the <a href="Manual.htm">ALGLIB++ Reference Manual</a>.
</p>
<p>
<font size=2>[
<a href=#supp_CppDemoModule>C++ Demo Module</a> |
<a href=#supp_DemoFile>ALGLIB++ Demo</a> |
<a href=#supp_Classes>ALGLIB++ Object Classes</a> |
<a href=#supp_Links>ALGLIB++ Package Dependencies</a> |
<a href=#supp_Commercial>ALGLIB Commercial and Free Versions: Notes</a> |
<a href=#supp_History>ALGLIB &rArr; ALGLIB++ Revision Sequence</a>
]</font>
</p>
<p>
<a name=supp_CppDemoModule class=sheader></a><h2>A1. C++ Demo Module</h2>
ALGLIB++ is an intermediate stage between ALGLIB and the future library undergoing development, with only minimal recoding (but this will change, soon).
A reengineered, refactored, re-commented version is currently undergoing testing, but has not yet been released.
We intend to roll back much of the Version 3 infrastructure, to something similar to Version 2, and move upwards from there.
We are still experimenting with different methods for re-encapsulating the ALGLIB/ALGLIB++ classes.
A demonstration may be found under the <a href="New/">New/</a> directory.
If running under the configuration Linux:X86:GCC, run "make test" in the New/ directory.
Other configurations have not been tested, but this should be suitable for a POSIX system; you may need to experiment a bit.
</p>
<p>
<a name=supp_DemoFile class=sheader></a><h2>A2. ALGLIB++ Demo</h2>
An implementation of the demo program cited in <a href="Manual.htm#gs_compile_examples">Section 4.4</a> of the ALGLIB Reference Manual for the configuration Linux:x86_64:GCC may be found under the <a href="Demo/">Demo/</a> directory.
If running under this configuration, run ./Test.sh under Demo/.
Again, for other configurations, you will need to do some experimentation to find what works.
</p>
<p>
<a name=supp_Classes class=sheader></a><h2>A3. ALGLIB++ Object Classes</h2>
<font size=2>[
<a href=#supp_ObjClassMac>Object Class Macros</a> |
<a href=#supp_ObjClassDef>Defining Object Classes</a>
]</font>
</p>
<p>
<a name=supp_ObjClassMac class=sheader></a><h3>A3.1. Object Class Macros</h3>
For some of the types given in the C (<code>alglib_impl::</code>) namespace; in the C++ (<code>alglib::</code>) namespace, object classes are:
<ul>
<li>defined in a *.cpp file by <code>DefClass(Type, Vars)</code></li>
<li>declared in the corresponding *.h file by <code>DecClass(Type, Pars)</code></li>
</ul>
Object classes are defined in the C++ (<code>alglib::</code>) namespace of a *.cpp file, for some of the types given in the C (<code>alglib_impl::</code>) namespace, by <code>DefClass(Type, Vars)</code>.
</p>
<p>
<u>Examples:</u>
<pre class=p_example>
   DefClass(hqrndstate, )
   DecClass(hqrndstate, );
<span class=s_comment>// define/declare the object class alglib::hqrndstate for the type alglib_impl::hqrndstate, with no public members.</span>
   DefClass(xdebugrecord1, DecVal(i) DecComplex(c) DecVar(a))
   DecClass(xdebugrecord1, ae_int_t &amp;i; complex &amp;c; real_1d_array a;);
<span class=s_comment>// define/declare the object class alglib::xdebugrecord1 for the type alglib_impl::xdebugrecord, with the data members i, c and a made public.</span>
</pre>
In <code>DefClass()</code>, public members match those of the same name declared in the <code>alglib_impl</code> Type, with the macros:
<ul>
<li><code>DecComplex(X)</code>, for members X of type <code>alglib_impl::ae_complex</code>;</li>
<li><code>DecVal(X)</code>, for all other members X of scalar types (i.e., <code>bool</code>, <code>alglib_impl::ae_int_t</code> or <code>double</code>);</li>
<li><code>DecVar(X)</code>, for non-scalar members (in particular: {integer,real}_{1,2}d_array).</li>
</ul>
In <code>DecClass()</code>, public members are declared as:
<ul>
<li><code>alglib::complex &amp;X</code>, for members X of type <code>alglib_impl::ae_complex</code>;</li>
<li><code>alglib::ae_int_t &amp;X</code>, for members X of type <code>alglib_impl::ae_int_t</code>;</li>
<li><code>alglib::T &amp;X</code>, for members X of types T = <code>bool</code> or T = <code>double</code>;</li>
<li><code>alglib::T_1d_array X</code>, for members of types <code>alglib_impl::ae_vector</code>;</li>
<li><code>alglib::T_2d_array X</code>, for members of types <code>alglib_impl::ae_matrix</code>;</li>
<li>For the vector and matrix types, T = {<code>boolean</code>,<code>integer</code>,<code>real</code>,<code>complex</code>} matching the datatypes {<code>DT_BOOL</code>,<code>DT_INT</code>,<code>DT_REAL</code>,<code>DT_COMPLEX</code>}; the corresponding field in the C (<code>alglib_impl::</code>) type is always initialized to the corresponding datatype.</li>
</ul>
</p>
<p>
In the C++ (<code>alglib::</code>) namespace, a reflection of most routines from the C (<code>alglib_impl::</code>) namespace is called under an error-handling wrapper.
In almost all cases, this takes the form
<pre class=p_example>
   alglib_impl::ae_state_init();
   TryCatch()
   alglib_impl::Op(Args);
   alglib_impl::ae_state_clear();
</pre>
Arguments are converted as:
<ul>
<li><code>*X.c_ptr()</code> &mdash; for <code>alglib_impl::ae_complex</code> types,</li>
<li><code>X</code> &mdash; for all other scalar types (<code>bool</code>, <code>alglib_impl::ae_int_t</code>, <code>double</code>),</li>
<li><code>ConstT(Type, X)</code> &mdash; for vector, matrix and other object types <code>alglib_impl::</code>T.</li>
</ul>
The values returned are always of scalar type and are returned as
<ul>
<li><code>ComplexOf(X)</code> &mdash; for routines of type <code>alglib_impl::ae_complex</code>,</li>
<li><code>X</code> &mdash; for routines of all other scalar types (<code>bool</code>, <code>alglib_impl::ae_int_t</code>, <code>double</code>),</li>
</ul>
</p>
<p>
The other wrapper forms that occur in the C++ namespace are for
<ul>
<li>reduced forms of wrapper routines in which some arguments are internally assigned default values this always occurs under the conditional #if !defined AE_NO_EXCEPTIONS</li>
<li>polling loops for the interation routines, which have the general form
<pre class=p_example>
   alglib_impl::ae_state_init();
   TryCatch()
   alglib_impl::ae_assert(... conditions ... message);
   while (alglib_impl::IterationRoutine(state.c_ptr()))
   BegPoll
      if (state.Flag1) Op1(...);
      else if (state.Flag2) Op2(...);
      ...
      else alglib_impl::ae_assert(false, "ALGLIB: exception generated in user callback");
   EndPoll
   alglib_impl::ae_state_clear();
</pre>
</li>
</ul>
</p>
<p>
<a name=supp_ObjClassDef class=sheader></a><h3>A3.2. Defining Object Classes</h3>
The current implementation defines an object class for some C types <code>alglib_impl::</code>Type,
layering on top of it a C++ type <code>alglib::</code>TypeI to handle object constructors and <code>alglib::</code>Type to internalize *_init(), *_copy(), *_free() and to enforce the distinction for <code>alglib_impl::</code>Type between public and private members. The details of this implementation should not be relied on: it will undergo further changes as we experiment with different object models, with an eye toward eliminating it entirely and going fully native with C++.
</p>
<p>
To expedite this process, the routines _Type_{init,init_copy,clear,destroy} have been renamed and/or redefined as Type_{init,copy,free}.
In the original ALGLIB distribution (the GPL version, as of version 3.16.0), malloc() and free() are used.
Most of the need for them has been eliminated, which also entails minor revisions to TestZ.cpp to redefine some of its test conditions.
</p>
<p>
For <code>DecClass</code>, the declaration is:
<pre class=p_example>
struct TypeI {
   TypeI();
   TypeI(const Type &amp;A);
protected:
   alglib_impl::Type Obj;
};
struct Type: public TypeI {
   Type();
   Type(const Type &amp;A);
   Type &amp;operator=(const Type &amp;A);
   ~Type();
   alglib_impl::Type *c_ptr() const;
   alglib_impl::Type *c_ptr();
   Pars ... public members (reference variables for scalar types) ...
}
</pre>
</p>
<p>
For <code>DefClass</code>, the definition is:
<pre class=p_example>
TypeI::TypeI() {
   alglib_impl::ae_state_init();
   TryX { alglib_impl::Type_free(&amp;Obj, false); ThrowErrorMsg(); }
   memset(&amp;Obj, 0, sizeof Obj), alglib_impl::Type_init(&amp;Obj, false);
   alglib_impl::ae_state_clear();
}
TypeI::TypeI(const TypeI &amp;A) {
   alglib_impl::ae_state_init();
   TryX { alglib_impl::Type_free(&amp;Obj, false); ThrowErrorMsg(); }
   memset(&amp;Obj, 0, sizeof Obj), alglib_impl::Type_copy(&amp;Obj, const_cast&lt;alglib_impl::Type *&gt;(&amp;A.Obj), false);
   alglib_impl::ae_state_clear();
}
Type::Type(): TypeI() Vars ... initializations of public members ... { }
Type::Type(const Type &amp;A): TypeI(A) Vars ... initializations of public members ... { }
Type &amp;Type::operator=(const Type &amp;A) {
   if (this == &amp;A) return *this;
   alglib_impl::ae_state_init();
   TryCatch(*this)
   alglib_impl::Type_free(&amp;Obj, false);
   memset(&amp;Obj, 0, sizeof Obj), alglib_impl::Type_copy(&amp;Obj, const_cast&lt;alglib_impl::Type *&gt;(&amp;A.Obj), false);
   alglib_impl::ae_state_clear();
   return *this;
}
Type::~Type() { alglib_impl::Type_free(&amp;Obj, false); }
alglib_impl::Type *Type::c_ptr() const { return const_cast&lt;alglib_impl::Type *&gt;(&amp;Obj); }
alglib_impl::Type *Type::c_ptr() { return &amp;Obj; }
</pre>
</p>
<p>
The following alternate form has also been tested, where the destruction and assignment operators are moved into TypeI:
</p>
<p>
For DecClass, the declaration is:
<pre class=p_example>
struct TypeI {
   TypeI();
   TypeI(const TypeI &amp;A);
   TypeI &amp;operator=(const TypeI &amp;A);
   ~TypeI();
protected:
   alglib_impl::Type Obj;
};
struct Type: public TypeI {
   Type();
   Type(const Type &amp;A);
   Type &amp;operator=(const Type &amp;A);
   ~Type();
   alglib_impl::Type *c_ptr() const;
   alglib_impl::Type *c_ptr();
   Pars ... public members (reference variables for scalar types) ...
}
</pre>
</p>
For DefClass, the definition is:
<pre class=p_example>
TypeI::TypeI() {
   alglib_impl::ae_state_init();
   TryX { alglib_impl::Type_free(&amp;Obj, false); ThrowErrorMsg(); }
   memset(&amp;Obj, 0, sizeof Obj), alglib_impl::Type_init(&amp;Obj, false);
   alglib_impl::ae_state_clear();
}
TypeI::TypeI(const TypeI &amp;A) {
   alglib_impl::ae_state_init();
   TryX { alglib_impl::Type_free(&amp;Obj, false); ThrowErrorMsg(); }
   memset(&amp;Obj, 0, sizeof Obj), alglib_impl::Type_copy(&amp;Obj, const_cast&lt;alglib_impl::Type *&gt;(&amp;A.Obj), false);
   alglib_impl::ae_state_clear();
}
TypeI &amp;TypeI::operator=(const TypeI &amp;A) {
   if (this == &amp;A) return *this;
   alglib_impl::ae_state_init();
   TryCatch(*this)
   alglib_impl::Type_free(&amp;Obj, false);
   memset(&amp;Obj, 0, sizeof Obj), alglib_impl::Type_copy(&amp;Obj, const_cast&lt;alglib_impl::Type *&gt;(&amp;A.Obj), false);
   alglib_impl::ae_state_clear();
   return *this;
}
TypeI::~TypeI() { alglib_impl::Type_free(&amp;Obj, false); }
Type::Type(): TypeI() Type::Type(): TypeI() Vars ... initializations of public members ... { }
Type::Type(const Type &amp;A): TypeI(A) Vars ... initializations of public members ... { }
Type &amp;Type::operator=(const Type &amp;A) { TypeI::operator=(A); return *this; }
Type::~Type() { }
alglib_impl::Type *Type::c_ptr() const { return const_cast&lt;alglib_impl::Type *&gt;(&amp;Obj); }
alglib_impl::Type *Type::c_ptr() { return &amp;Obj; }
</pre>
</p>
<p>
<a name=supp_Links class=sheader></a><h2>A4. ALGLIB++ Package Dependencies</h2>
ALGLIB originally distributed each of the subpackage modules in separate files.
Starting with Version 3, they were compiled into larger package modules, in most cases, each module dedicated to a specific application area.
A vestige of the earlier configuration was later reintroduced, as a compromise.
This compromise is retained in ALGLIB++, except that the subpackages have each been segregated within their respective package modules.
A dependency list has not been included in the Makefiles distributed with ALGLIB++, except for the package modules themselves.
Subpackage dependencies are listed within the module files, themselves.
For reference, the following is the minimal spanning tree of the dependency hierarchy, listed roughly in order of dependence.
Note that all packages depend on the infrastructure provided in the Ap.{cpp,h} files.
<ul>
<li>AlgLibInternal:<ul>
   <li>APSERV:</li>
   <li>ABLASF: APSERV</li>
   <li>HBLAS:</li>
   <li>CREFLECTIONS:</li>
   <li>SBLAS: APSERV</li>
   <li>ABLASMKL:</li>
   <li>SCODES:</li>
   <li>TSORT: ABLASF</li>
   <li>BLAS:</li>
   <li>ROTATIONS:</li>
   <li>BASICSTATOPS: TSORT</li>
   <li>TRLINSOLVE:</li>
   <li>SAFESOLVE:</li>
   <li>XBLAS:</li>
   <li>LINMIN:</li>
   <li>NEARUNITYUNIT:</li>
   <li>NTHEORY:</li>
   <li>FTBASE: APSERV, NTHEORY</li>
   <li>HPCCORES:</li>
</ul></li>
<li>AlgLibMisc: AlgLibInternal<ul>
   <li>HQRND: (AlgLibInternal) ABLASF</li>
   <li>XDEBUG:</li>
   <li>NEARESTNEIGHBOR: (AlgLibInternal) SCODES, TSORT</li>
</ul></li>
<li>DiffEquations: AlgLibInternal<ul>
   <li>ODESOLVER: (AlgLibInternal) APSERV</li>
</ul></li>
<li>FastTransforms: AlgLibInternal<ul>
   <li>FFT: (AlgLibInternal) FTBASE</li>
   <li>FHT: FFT</li>
   <li>CONV: FFT</li>
   <li>CORR: CONV</li>
</ul></li>
<li>SpecialFunctions: AlgLibMisc [AlgLibInternal]<ul>
   <li>GAMMAFUNC:</li>
   <li>NORMALDISTR: (AlgLibMisc) HQRND</li>
   <li>IBETAF: GAMMAFUNC, NORMALDISTR</li>
   <li>STUDENTTDISTR: IBETAF</li>
   <li>FDISTR: IBETAF</li>
   <li>IGAMMAF: GAMMAFUNC, NORMALDISTR</li>
   <li>CHISQUAREDISTR: IGAMMAF</li>
   <li>BINOMIALDISTR: (AlgLibInternal) NEARUNITYUNIT │ IBETAF</li>
   <li>EXPINTEGRALS:</li>
   <li>JACOBIANELLIPTIC:</li>
   <li>TRIGINTEGRALS:</li>
   <li>CHEBYSHEV:</li>
   <li>POISSONDISTR: IGAMMAF</li>
   <li>BETAF: GAMMAFUNC</li>
   <li>FRESNEL:</li>
   <li>PSIF:</li>
   <li>AIRYF:</li>
   <li>DAWSON:</li>
   <li>HERMITE:</li>
   <li>LEGENDRE:</li>
   <li>BESSEL:</li>
   <li>LAGUERRE:</li>
   <li>ELLIPTIC:</li>
</ul></li>
<li>LinAlg: AlgLibMisc [AlgLibInternal]<ul>
   <li>ABLAS: (AlgLibInternal) ABLASF, ABLASMKL</li>
   <li>ORTFAC: (AlgLibInternal) HBLAS, CREFLECTIONS, SBLAS │ (AlgLibMisc) HQRND │ ABLAS</li>
   <li>MATGEN: (AlgLibInternal) CREFLECTIONS │ (AlgLibMisc) HQRND │ ABLAS</li>
   <li>SPARSE: (AlgLibInternal) ABLASMKL, SCODES, TSORT │ (AlgLibMisc) HQRND</li>
   <li>HSSCHUR: (AlgLibInternal) BLAS, ROTATIONS │ ABLAS</li>
   <li>EVD: (AlgLibInternal) BASICSTATOPS │ ORTFAC, MATGEN, SPARSE, HSSCHUR</li>
   <li>DLU: ABLAS</li>
   <li>SPTRF: SPARSE, DLU</li>
   <li>AMDORDERING: ABLAS, SPARSE</li>
   <li>SPCHOL: AMDORDERING</li>
   <li>TRFAC: (AlgLibInternal) ROTATIONS │ MATGEN, SPTRF, SPCHOL</li>
   <li>BDSVD: (AlgLibInternal) ROTATIONS │ (AlgLibMisc) HQRND │ ABLAS</li>
   <li>SVD: (AlgLibInternal) BLAS │ ORTFAC, BDSVD</li>
   <li>RCOND: (AlgLibInternal) TRLINSOLVE, SAFESOLVE │ TRFAC</li>
   <li>FBLS: (AlgLibInternal) ROTATIONS │ ORTFAC</li>
   <li>NORMESTIMATOR: MATGEN, SPARSE</li>
   <li>MATINV: RCOND</li>
   <li>INVERSEUPDATE:</li>
   <li>SCHUR: ORTFAC, HSSCHUR</li>
   <li>SPDGEVD: EVD, MATINV</li>
   <li>MATDET: TRFAC</li>
</ul></li>
<li>Integration: SpecialFunctions LinAlg<ul>
   <li>GQ: (SpecialFunctions) GAMMAFUNC │ (LinAlg) EVD</li>
   <li>GKQ: GQ</li>
   <li>AUTOGK: GKQ</li>
</ul></li>
<li>Solvers: LinAlg [AlgLibInternal]<ul>
   <li>POLYNOMIALSOLVER: (LinAlg) EVD, TRFAC</li>
   <li>DIRECTDENSESOLVERS: (AlgLibInternal) XBLAS │ (LinAlg) SVD, RCOND</li>
   <li>DIRECTSPARSESOLVERS: (LinAlg) TRFAC</li>
   <li>ITERATIVESPARSE: (LinAlg) FBLS │ DIRECTSPARSESOLVERS</li>
   <li>LINCG: (LinAlg) MATGEN, SPARSE</li>
   <li>LINLSQR: (LinAlg) SVD, NORMESTIMATOR</li>
   <li>NLEQ: (AlgLibInternal) LINMIN │ (LinAlg) FBLS</li>
</ul></li>
<li>Statistics: SpecialFunctions LinAlg [AlgLibInternal AlgLibMisc]<ul>
   <li>BASESTAT: (AlgLibInternal) BASICSTATOPS │ (LinAlg) ABLAS</li>
   <li>CORRELATIONTESTS: (SpecialFunctions) STUDENTTDISTR │ BASESTAT</li>
   <li>JARQUEBERA:</li>
   <li>VARIANCETESTS: (SpecialFunctions) FDISTR, CHISQUAREDISTR</li>
   <li>WSR: (AlgLibInternal) APSERV</li>
   <li>MANNWHITNEYU: (AlgLibMisc) HQRND</li>
   <li>STEST: (SpecialFunctions) BINOMIALDISTR</li>
   <li>STUDENTTTESTS: (SpecialFunctions) STUDENTTDISTR</li>
</ul></li>
<li>Optimization: Solvers [AlgLibInternal LinAlg]<ul>
   <li>OPTGUARDAPI: (AlgLibInternal) APSERV</li>
   <li>OPTSERV: (LinAlg) SVD, MATINV │ OPTGUARDAPI</li>
   <li>MINLBFGS: (AlgLibInternal) LINMIN │ (LinAlg) FBLS │ OPTSERV</li>
   <li>CQMODELS: (LinAlg) TRFAC, FBLS</li>
   <li>LPQPSERV: (LinAlg) SPARSE</li>
   <li>SNNLS: (LinAlg) TRFAC, FBLS</li>
   <li>SACTIVESETS: OPTSERV, SNNLS</li>
   <li>QQPSOLVER: CQMODELS, SACTIVESETS</li>
   <li>QPDENSEAULSOLVER: (Solvers) DIRECTDENSESOLVERS, LINLSQR │ MINLBFGS, LPQPSERV, QQPSOLVER</li>
   <li>MINBLEIC: (AlgLibInternal) LINMIN │ CQMODELS, SACTIVESETS</li>
   <li>QPBLEICSOLVER: MINBLEIC</li>
   <li>VIPMSOLVER: (Solvers) DIRECTDENSESOLVERS │ MINLBFGS, CQMODELS, LPQPSERV</li>
   <li>MINQP: QPDENSEAULSOLVER, QPBLEICSOLVER, VIPMSOLVER</li>
   <li>MINLM: MINQP</li>
   <li>MINCG: (AlgLibInternal) LINMIN │ OPTSERV</li>
   <li>NLCSQP: VIPMSOLVER</li>
   <li>LPQPPRESOLVE: (LinAlg) SPARSE</li>
   <li>REVISEDDUALSIMPLEX: (LinAlg) TRFAC │ LPQPPRESOLVE</li>
   <li>MINLP: VIPMSOLVER, REVISEDDUALSIMPLEX</li>
   <li>NLCSLP: (AlgLibInternal) LINMIN │ OPTSERV, REVISEDDUALSIMPLEX</li>
   <li>MINNLC: MINBLEIC, NLCSQP, NLCSLP</li>
   <li>MINNS: MINBLEIC</li>
   <li>MINCOMP: MINLBFGS, MINBLEIC</li>
   <li>MINBC: (AlgLibInternal) LINMIN │ OPTSERV</li>
   <li>OPTS: MINLP</li>
</ul></li>
<li>Interpolation: Integration Optimization [AlgLibInternal AlgLibMisc LinAlg Solvers]<ul>
   <li>RATINT: (AlgLibInternal) TSORT</li>
   <li>IDW: (AlgLibMisc) HQRND, NEARESTNEIGHBOR │ (LinAlg) ABLAS</li>
   <li>INTFITSERV: (LinAlg) TRFAC</li>
   <li>POLINT: RATINT</li>
   <li>SPLINE1D: (LinAlg) FBLS │ (Solvers) LINLSQR │ INTFITSERV</li>
   <li>LSFIT: (Optimization) MINLM │ POLINT, SPLINE1D</li>
   <li>FITSPHERE: (Optimization) MINLM, MINNLC</li>
   <li>PARAMETRIC: (Integration) AUTOGK │ SPLINE1D</li>
   <li>RBFV1: (AlgLibMisc) NEARESTNEIGHBOR │ LSFIT</li>
   <li>SPLINE2D: SPLINE1D</li>
   <li>RBFV2: (AlgLibMisc) NEARESTNEIGHBOR │ LSFIT</li>
   <li>SPLINE3D: SPLINE1D</li>
   <li>INTCOMP: SPLINE1D, FITSPHERE</li>
   <li>RBF: RBFV1, RBFV2</li>
</ul></li>
<li>DataAnalysis: Statistics Optimization [AlgLibInternal AlgLibMisc SpecialFunctions LinAlg Solvers]<ul>
   <li>PCA: (LinAlg) EVD, SVD │ (Statistics) BASESTAT</li>
   <li>BDSS: (Statistics) BASESTAT</li>
   <li>MLPBASE: (AlgLibInternal) HPCCORES │ (LinAlg) SPARSE │ BDSS</li>
   <li>MLPE: MLPBASE</li>
   <li>CLUSTERING: (AlgLibInternal) BLAS │ (AlgLibMisc) HQRND │ (Statistics) BASESTAT</li>
   <li>DFOREST: (AlgLibInternal) SCODES │ (AlgLibMisc) HQRND │ BDSS</li>
   <li>LINREG: (SpecialFunctions) IGAMMAF │ (LinAlg) SVD │ (Statistics) BASESTAT</li>
   <li>FILTERS: LINREG</li>
   <li>SSA: (LinAlg) EVD, SVD</li>
   <li>LDA: (LinAlg) EVD, MATINV</li>
   <li>MCPD: (Optimization) MINBLEIC</li>
   <li>LOGIT: (Solvers) DIRECTDENSESOLVERS │ MLPBASE</li>
   <li>KNN: (AlgLibMisc) HQRND, NEARESTNEIGHBOR │ BDSS</li>
   <li>MLPTRAIN: (Solvers) DIRECTDENSESOLVERS │ (Optimization) MINLBFGS │ MLPE</li>
   <li>DATACOMP: CLUSTERING</li>
</ul></li>
<li>TestC, TestI: DataAnalysis DiffEquations FastTransforms Interpolation</li>
<li>TestX: DataAnalysis Interpolation</li>
<li>TestZ: Interpolation</li>
<li>TestY: LinAlg</li>
</ul>
</p>
<p>
<a name=supp_Commercial class=sheader></a><h2>A5. ALGLIB Commercial and Free Versions: Notes</h2>
<font size=2>[
<a href=#supp_Commercial1>ALGLIB Commercial and Free Notifications</a> |
<a href=#supp_Commercial2>ALGLIB Commercial Support by Routine</a>
]</font>
</p>
<p>
For those who wish to use the improvements provided by the Commercial version of ALGLIB,
the following is a list of the routines in ALGLIB that have been provided with enhancements there; along with the corresponding notifications.
</p><p>
Multi-threading support for ALGLIB++, in place of that provided by the commercial version, is currently being developed.
In addition, some enhancements, which have been made available for the free edition of ALGLIB, are inherited by ALGLIB++.
</p><p>
There are 6 groups of routines (labeled A, B, C, D, E and F), based on which parts of which notifications apply to them.
</p>
<p>
<a name=supp_Commercial1 class=sheader></a><h3>A5.1. ALGLIB Commercial and Free Notifications</h3>
<pre class=narration>
ABCDEF	│ COMMERCIAL EDITION OF ALGLIB:
ABCDEF	│
ABC──F	│ Commercial Edition of ALGLIB includes following important improvements of this function:
───DE─	│ Commercial version of ALGLIB includes one important improvement of this function, which can be used from C++ and C#:
ABC──F	│ ∙	high-performance native backend with same C# interface (C# version)
AB───F	│ ∙	multithreading support (C++ and C# versions)
─BC──F	│ ∙	hardware vendor (Intel) implementations of linear algebra primitives (C++ and C# versions, x86/x64 platform)
───DE─	│ ∙	Intel MKL support (lightweight Intel MKL is shipped with ALGLIB)
ABCDEF	│
───DE─	│ Intel MKL gives approximately constant (with respect to number of worker threads)
───DE─	│ acceleration factor which depends on CPU being used,
───DE─	│ problem size and "baseline" ALGLIB edition which is used for comparison.
───DE─	│
───D──	│ Generally, commercial ALGLIB is several times faster than open-source generic C edition,
───D──	│ and many times faster than open-source C# edition.
───D──	│
───DE─	│ Multithreaded acceleration is NOT supported for this function.
ABCDEF	│
ABCDEF	│ We recommend you to read 'Working with commercial version' section of ALGLIB Reference Manual
ABCDEF	│ in order to find out how to use performance-related features provided by commercial edition of ALGLIB.

─────F	│ FREE EDITION OF ALGLIB:
─────F	│
─────F	│ Free Edition of ALGLIB supports following important features for this function:
─────F	│ ∙	C++ version: x64 SIMD support using C++ intrinsics
─────F	│ ∙	C# version: x64 SIMD support using NET5/NetCore hardware intrinsics
─────F	│ We recommend you to read 'Compiling ALGLIB' section of the ALGLIB Reference Manual
─────F	│ in order to find out how to activate SIMD support in ALGLIB.
</pre>
</p>
<p>
<a name=supp_Commercial2 class=sheader></a><h3>A5.2. ALGLIB Commercial Support and Free Enhancements by Routine</h3>
The routines are listed by subpackage module:
<ul>
<li>8.2.2. clustering<ul>
<li><b>F</b>: clusterizergetdistances, clusterizerrunahc, clusterizerrunkmeans</li>
</ul></li>
<li>8.2.4. dforest<ul>
<li><b>A</b>: dfbuilderbuildrandomforest</li>
</ul></li>
<li>8.2.6. knn<ul>
<li><b>A</b>: knnbuilderbuildknnmodel</li>
</ul></li>
<li>8.2.7. lda<ul>
<li><b>F</b>: fisherlda, fisherldan</li>
</ul></li>
<li>8.2.11. mlpbase<ul>
<li><b>A</b>: mlpallerrorssparsesubset, mlpallerrorssubset, mlpavgce, mlpavgcesparse, mlpavgerror, mlpavgerrorsparse, mlpavgrelerror, mlpavgrelerrorsparse, mlpclserror, mlperror, mlperrorsparse, mlperrorsparsesubset, mlperrorsubset, mlpgradbatch, mlpgradbatchsparse, mlpgradbatchsparsesubset, mlpgradbatchsubset, mlprelclserror, mlprelclserrorsparse, mlprmserror, mlprmserrorsparse</li>
</ul></li>
<li>8.2.13. mlptrain<ul>
<li><b>A</b>: mlpcontinuetraining, mlpkfoldcv, mlptrainensemblees, mlptrainnetwork</li>
</ul></li>
<li>8.2.14. pca<ul>
<li><b>F</b>: pcabuildbasis, pcatruncatedsubspace, pcatruncatedsubspacesparse</li>
</ul></li>
<li>8.6.2. idw<ul>
<li><b>A</b>: idwbuildercreate</li>
</ul></li>
<li>8.6.4. lsfit<ul>
<li><b>F</b>: barycentricfitfloaterhormann, barycentricfitfloaterhormannwc, lsfitlinear, lsfitlinearc, lsfitlinearw, lsfitlinearwc, polynomialfit, polynomialfitwc, spline1dfitcubic, spline1dfitcubicwc, spline1dfithermite, spline1dfithermitewc</li>
</ul></li>
<li>8.6.8. rbf<ul>
<li><b>A</b>: rbfgridcalc2v, rbfgridcalc2vsubset, rbfgridcalc3v, rbfgridcalc3vsubset</li>
</ul></li>
<li>8.6.10. spline2d<ul>
<li><b>B</b>: spline2dbuildercreate, spline2dbuildersetalgoblocklls, spline2dbuildersetalgofastddm, spline2dfit</li>
</ul></li>
<li>8.7.1. ablas<ul>
<li><b>F</b>: cmatrixgemm, cmatrixherk, cmatrixlefttrsm, cmatrixrighttrsm, rmatrixgemm, rmatrixlefttrsm, rmatrixrighttrsm, rmatrixsyrk</li>
</ul></li>
<li>8.7.2. bdsvd<ul>
<li><b>D</b>: rmatrixbdsvd</li>
</ul></li>
<li>8.7.3. evd<ul>
<li><b>F</b>: eigsubspacesolvedenses</li>
<li><b>C</b>: hmatrixevd, rmatrixevd, smatrixevd, smatrixevdr, smatrixtdevd</li>
</ul></li>
<li>8.7.7. matinv<ul>
<li><b>F</b>: cmatrixinverse, cmatrixluinverse, cmatrixtrinverse, hpdmatrixcholeskyinverse, hpdmatrixinverse, rmatrixinverse, rmatrixluinverse, rmatrixtrinverse, spdmatrixcholeskyinverse, spdmatrixinverse</li>
</ul></li>
<li>8.7.9. ortfac<ul>
<li><b>F</b>: cmatrixlq, cmatrixlqunpackq, cmatrixqr, cmatrixqrunpackq, rmatrixlq, rmatrixlqunpackq, rmatrixqr, rmatrixqrunpackq</li>
<li><b>C</b>: hmatrixtd, hmatrixtdunpackq, rmatrixbd, rmatrixbdmultiplybyq, rmatrixbdunpackq, rmatrixhessenberg, rmatrixhessenbergunpackq, smatrixtd, smatrixtdunpackq</li>
</ul></li>
<li>8.7.11. schur<ul>
<li><b>E</b>: rmatrixschur</li>
</ul></li>
<li>8.7.14. svd<ul>
<li><b>C</b>: rmatrixsvd</li>
</ul></li>
<li>8.7.15. trfac<ul>
<li><b>F</b>: cmatrixlu, hpdmatrixcholesky, rmatrixlu, spdmatrixcholesky</li>
</ul></li>
<li>8.9.1. directdensesolvers<ul>
<li><b>F</b>: cmatrixlusolvem, cmatrixlusolvemfast, cmatrixsolve, cmatrixsolvefast, cmatrixsolvem, cmatrixsolvemfast, hpdmatrixsolve, hpdmatrixsolvefast, hpdmatrixsolvem, hpdmatrixsolvemfast, rmatrixlusolvem, rmatrixlusolvemfast, rmatrixsolve, rmatrixsolvefast, rmatrixsolvels, rmatrixsolvem, rmatrixsolvemfast, spdmatrixsolve, spdmatrixsolvefast, spdmatrixsolvem, spdmatrixsolvemfast</li>
</ul></li>
<li>8.11.1. basestat<ul>
<li><b>A</b>: rankdata, rankdatacentered</li>
<li><b>B</b>: covm, covm2, pearsoncorrm, pearsoncorrm2, spearmancorrm, spearmancorrm2</li>
</ul></li>
</ul>
</p>
<p>
<a name=supp_History class=sheader></a><h2>A6. ALGLIB &rArr; ALGLIB++ Revision Sequence</h2>
<font size=2>[
<a href=#supp_History1 class=sheader>Revision Notes</a> |
<a href="History.htm#supp_History2" class=sheader>Test Stages</a> |
<a href="History.htm#supp_History3" class=sheader>Test Results</a> |
<a href="History.htm#supp_History4" class=sheader>The Most Recent Test Run</a>
]</font>
</p>
<p>
We maintain several independently recoded versions of ALGLIB, locally, for testing and experimentation and cross-validation.
The <a href=#supp_CppDemoModule>C++ Demo Module</a> is partly derived from one of these; and the revisions made here - as well as in the local versions - result from reconciling the different versions with one another.
</p>
<p>
<a name=supp_History1 class=sheader></a><h3>A6.1. Revision Notes</h3>
<pre class=narration>
∙	The files were moved to a single top-level directory and the names normalized.
∙	References to Commercial ALGLIB in the comments and functions were removed.
	A separate file was compiled collating all of the Commercial ALGLIB comments of the original package.
∙	The reprogramming, itself, will be under GPL, except that recoding, repairs, and other additions made,
	particularly in DSP, file {en/de}-coding, video/music/sound processing, time-frequency analysis,
	will be made available for the commercial version to use, except those derived from other GPL-sources.
∙	Full integration of a C++ version of the Time Frequency Toolkit (currently in MATLAB)
	or the equivalent into FastTransforms is planned.
∙	Full integration of GMP (as part of the expanded FastTransforms / DSP module)
	and a C/C++ version of LAPACK (as part of the expanded LinAlg and Solvers modules) are both planned.
∙	DSP and Time-Frequency analysis; file-transfer; voice generation/recognition, computer vision, sound and video production
	is also planned.
∙	Expansion of serialization/deserialization routines to include I/O for different file formats.
	Possible inclusion of JSON.
∙	Possible integration with a refactored C++ version FFMPEG++, of FFMPEG, is undergoing evaluation.
∙	Possible integration of a refactored C++ GUI-free version of Audacity is undergoing evaluation.
∙	For POSIX non-compliant configurations, the user assumes primary responsibility for maintenance.
	No support will be provided, but corrections or fixes reported will be noted, tested (where possible) and added.
∙	Conflicting labelling in 6.3 and 6.3.1: partially repaired in the version 3.16.0 manual.
∙	The alglib_impl namespace in ALGLIB was mostly in C, as was TestC.cpp.
∙	Support for C is now moved away from in favor of nativizing the C++ code.
	The Idw{0,1}.c files are a demonstration of possible future directions; we're also re-examining ALGLIB Version 2.
	The ALGLIB library's infrastructure is naturally tailored for C++; laden with idioms that practically scream out "C++!".
∙	Test{I,X,Y,Z} work with alglib and are C++.
∙	The Makefile and revisions have only been tried with Linux:x86_64:GCC.
∙	The revision to handle the rounding on the FP unit was only added in for Linux:x86_64:GCC.
∙	Only the structural changes mentioned here were made; not any recoding, other than what was done for this.
	The initial "structural" changes made, before actual recoding included a normalization of the ordering
	(determined automatically with the aid of the compiler) of the routines and extraction of a dependency list;
	and various equivalence transforms.
∙	The God-objects in alglib_impl (ae_state) and RCOMM routines were removed.
	For the time being, static and global variable are no longer thread-local.
	Only the commercial version has support for multi-processors or multi-threading;
	but a small amount of it has crept into the GPL version in test_x and inherited, from this, in ALGLIB++'s TestX file.
∙	The partial compilation dependency includes from ALGLIB are not present.
	Instead, the modules are collated and the minimal dependency network is sorted out and documented separately.
	Intra-module and extra-module dependencies are distinguished.
	There's enough information here to separate out the modules and create a suitable Makefile.
∙	The order of
		minlm_lmprepare(...), minlmsetacctype(...), minlmsetcond(...)
	is switched to:
		minlmsetacctype(...), minlmsetcond(...), minlm_lmprepare(...)
	In the namespace alglib_impl in:
		minlmcreatevj(), minlmcreatev(), minlmcreatefgh(), minlmcreatefj()
∙	The calculation of refavgce in:
		testdforestunit_basictestallsame()
		testdforestunit_basictestrandom()
	is rewritten to match that used by dfavgce().
	These tests produce false positives: NAN's may be produced, which pass, because the comparison condition is stated negatively.
∙	The minqp tests produced sporadic failures (about 4% of the time) in the original version of ALGLIB.
	They were masked as false positives, which was uncovered in ALGLIB++ after stage 31, and became visible as a result.
	This issue has been left unresolved.
∙	2 C-incompatibilities: ByteOrder and CurCPU are defined at start-up time.
	In C, it'll have to be replaced by a "startup" routine in Ap.cpp and called in up front main().
	SSE2 intrinsics are not present in all GCC installations on Intel, so the automatic definition of AE_HAS_SSE2_INTRINSICS has been removed.
	It must be explicitly #defined, instead (preferrably in Ap.h, where indicated).
∙	Many more C-incompatibilities are introduced on and after stage 33.
∙	The replacement of ae_cpuid() by CurCPU excludes the 1-compiler/loader - heterogeneous-CPU configurations;
	which is not supported in the GPL version.
∙	In ALGLIB _clear should have been _destroy in ~vector_wrapper(), ~matrix_wrapper() (as well as in attach_to()).
	That is
	vector_clear	⇒	vector_destroy in ae_vector_wrapper::~ae_vector_wrapper() and ae_vector_wrapper::attach_to()
	matrix_clear	⇒	matrix_destroy in ae_matrix_wrapper::~ae_matrix_wrapper() and ae_matrix_wrapper::attach_to()
	Under the revisions described here, they each become *_free(..., ae_false), while *_clear(...) would have been written as *_free(..., ae_true).
	Both are equivalent in the GPL version, because *_clear() and *_destroy() are the same in that version;
	but this is only an incidental equivalence that should not be relied on.
∙	To better and more directly implement the assignment operator, a move constructor should be added;
		Type_move(T *A, const T *B),
	which has the effect of
		(Type_free(A), Type_copy(A, B)),
	except for optimizing out any (free + malloc) sequences.
	Then, under the revision, there would be:
	―	Type_init(Type *A),
	―	Type_copy(Type *A, const Type *B),
	―	Type_free(Type *A),
	―	Type_move(Type *A, const Type *B).
∙	Different/expanded version of the testing routines is planned for SpecialFunctions, including forward/inverse pair testing.
∙	A possible redefinition of SpecialFunctions using the interpolation methods in ALGLIB itself is planned.
</pre>
</p>
<p>
<h3>A6.2. Test Stages</h3>
<a href="History.htm#supp_History2" class=sheader>(External link)</a>
</p>
<p>
<h3>A6.3. Test Results</h3>
<a href="History.htm#supp_History3" class=sheader>(External link)</a>
</p>
<p>
<h3>A6.4. The Most Recent Test Run</h3>
<a href="History.htm#supp_History4" class=sheader>(External link)</a>
</p>
</div>
</body>
</html>
